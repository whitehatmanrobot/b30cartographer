   if (RegQueryValueEx (hKey, TEXT("WarnUserTimeout"), NULL,
                                     &dwType, (LPBYTE) &g_dwWarnUserTimeout, &dwSize) == ERROR_SUCCESS) {

                        if (g_dwWarnUserTimeout > 1440) {
                            g_dwWarnUserTimeout = 1440;
                        }

                        DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  User warning reminder timeout:  %d"), g_dwWarnUserTimeout));
                    }
                }
                    
                //
                // Now read the message that needs to be displayed
                //

                if (!ReadQuotaMsg(hKey)) {
                    RegCloseKey (hKey);
                    return FALSE;
                }


                if (ReadExclusionList()) {
                    RegCloseKey (hKey);                
                    return TRUE;
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to read the ExclusionList")));
                }

            } else {
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Profile quotas are DISABLED.")));
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to query EnableProfileQuota with error %d."), lResult));
        }

        RegCloseKey (hKey);

    } else {
        DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to open System policy key with error %d."), lResult));
    }

    return FALSE;
}


//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//              cchBuffer - Buffer size in char
//              pcchRemaining - buffer remaining after adding '\',
//                              can be NULL if not required
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemaining)
{
    UINT  cchDir = lstrlen(lpDir);
    LPTSTR lpEnd;

    lpEnd = lpDir + cchDir;
    if (pcchRemaining) {
        *pcchRemaining = cchBuffer - cchDir - 1;
    }

    if (*(lpEnd - 1) != TEXT('\\')) {
        if (cchDir + 1 >= cchBuffer) {  // No space to put \, should never happen
            return NULL;
        }
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
        if (pcchRemaining)
            *pcchRemaining -= 1;
    }

    return lpEnd;
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//              cchSize -   buffer size in character
//
//  Return:     TRUE   - success
//              FALSE  - Insufficient buffer space
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
BOOL CheckSemicolon (LPTSTR lpDir, UINT cchBuffer)
{
    UINT  cchDir = lstrlen(lpDir);
    LPTSTR lpEnd;

    lpEnd = lpDir + cchDir;

    if (*(lpEnd - 1) != TEXT(';')) {
        if (cchDir + 1 >= cchBuffer) {
            return FALSE;  // No space to put ;, should never happen
        }
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return TRUE;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectories counting the size.
//
//  Parameters: lpDir         -   Directory
//              cchBuffer     -   Buffer size in char
//              lpTop         -   Top of the display name
//              hLV           -   Listview window handle (optional)
//              lpExcludeList -   Null-termed list of dirs to be skipped (optional)             
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/30/96     ericflo    Created
//              12/22/98    ushaji     Added exclusionlist support
// Notes:
//      The buffer size expected is MAX_PATH+4 for some internal processing
// We should fix this to be better post Win 2K.
//*************************************************************

BOOL RecurseDirectory (LPTSTR lpDir, UINT cchBuffer, LPTSTR lpTop, HWND hLV, LPTSTR lpExcludeList)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd, lpTemp;
    BOOL bResult = TRUE;
    BOOL bSkip;
    UINT cchRemaining;
    HRESULT hr;


    //
    // Setup the ending pointer
    //

    lpEnd = CheckSlash (lpDir, cchBuffer, &cchRemaining);
    if (!lpEnd) {
        return FALSE;
    }


    //
    // Append *.* to the source directory
    //

    hr = StringCchCopy(lpEnd, cchRemaining, TEXT("*.*"));
    if (FAILED(hr)) {
        bResult = FALSE;
        goto RecurseDir_Exit;
    }

    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            //
            // bResult is already initialized to TRUE, so
            // just fall through.
            //

        } else {

            DebugMsg((DM_WARNING, TEXT("RecurseDirectory:  FindFirstFile for <%s> failed with %d."),
                     lpDir, GetLastError()));
            bResult = FALSE;
        }

        goto RecurseDir_Exit;
    }


    do {

        //
        // Append the file / directory name to the working buffer
        //

        // skip the file if the path > MAX_PATH
        
        if ((UINT)(1+lstrlen(fd.cFileName)+lstrlen(lpDir)+lstrlen(TEXT("\\*.*"))) >= cchBuffer) {
            continue;
        }

        hr = StringCchCopy(lpEnd, cchRemaining, fd.cFileName);
        if (FAILED(hr)) {
            bResult = FALSE;
            goto RecurseDir_Exit;
        }

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, TEXT("."))) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
                continue;
            }

            //
            // Check for reparse point
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: Found a reparse point <%s>,  skip it!"), lpDir));
                continue;
            }

            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> due to exclusion list."),
                             lpDir));
                    continue;
                }
            }

            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Recurse the subdirectory
            //

            if (!RecurseDirectory(lpDir, cchBuffer, lpTop, hLV, lpExcludeList))
            {
                // Ignore error and continue
                DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> due to error."), lpDir));
            }

        } else {

            //
            // Found a file, add the filesize and put in the listview
            // if appropriate.
            //

            g_dwProfileSizeTemp += fd.nFileSizeLow;
            DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Profile Size <%d> after <%s> "), g_dwProfileSizeTemp,
                             fd.cFileName));

            if (hLV) {
                LV_ITEM lvi;
                BOOL bAddItem = TRUE;

                if ((lstrlen(fd.cFileName) >= 6) &&
                    (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                    TEXT("ntuser"), 6,
                                    fd.cFileName, 6) == 2)) {
                    bAddItem = (g_bShowReg ? TRUE : FALSE);
                }

                if (bAddItem && g_bHideSmallItems && (fd.nFileSizeLow <= 2048)) {
                    bAddItem = FALSE;
                }

                if (bAddItem) {
                    TCHAR szSize[40];
                    TCHAR szDisplayName[MAX_PATH*3];
                    DWORD dwFileSize;
                    INT  iItem;

                    if (fd.nFileSizeLow <= 1024) {
                        dwFileSize = 1;
                    } else {
                        dwFileSize = fd.nFileSizeLow / 1024;
                    }

                    hr = StringCchPrintf(szSize, ARRAYSIZE(szSize), szSizeFormat, dwFileSize);
                    if (FAILED(hr)) {
                        bResult = FALSE;
                        goto RecurseDir_Exit;
                    }

                    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    lvi.state = 0;
                    lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    lvi.pszText = GetDisplayName(lpDir, lpTop, szDisplayName, ARRAYSIZE(szDisplayName)) ? szDisplayName : lpTop;
                    lvi.lParam = fd.nFileSizeLow;

                    iItem = ListView_InsertItem (hLV, &lvi);

                    lvi.mask = LVIF_TEXT | LVIF_STATE;
                    lvi.iItem = iItem;
                    lvi.iSubItem = 1;
                    lvi.state = 0;
                    lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    lvi.pszText = szSize;
                    lvi.lParam = fd.nFileSizeLow;

                    ListView_SetItem (hLV, &lvi);
                }
            }
        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


RecurseDir_Exit:

    //
    // Remove the file / directory name appended above
    //

    *lpEnd = TEXT('\0');


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bResult;
}

//*************************************************************
//
//  CenterWindow()
//
//  Purpose:    Centers a window on the screen
//
//  Parameters: hwnd    -   window handle to center
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Ported
//
//*************************************************************

void CenterWindow (HWND hwnd)
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    //
    // Get window rect
    //

    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;


    //
    // Get parent rect
    //

    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        //
        // Return the desktop windows size (size of main screen)
        //

        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    //
    // Center the child in the parent
    //

    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;


    //
    // Move the child into position
    //

    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
}



//*************************************************************
//
//  QuotaDlgProc()
//
//  Purpose:    Quota dialog box
//
//  Parameters: hDlg    -   Window handle
//              message -   Window message
//              wParam  -   WPARAM
//              lParam  -   LPARAM
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LRESULT CALLBACK QuotaDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[40];
    TCHAR szSize[40];
    HWND hLV;
    LV_COLUMN col;
    RECT rect;
    INT  cx;
    HKEY hKey;
    DWORD dwSize, dwType;
    LPTSTR lpMessage;
    HRESULT hr;


    switch (message) {
       case WM_INITDIALOG:

          hLV = GetDlgItem (hDlg, IDC_QUOTA_FILELIST);


          //
          // Add the columns to the listview
          //

          GetClientRect (hLV, &rect);
          cx = (rect.right * 31) / 40;

          LoadString (hInst, IDS_COLUMN1, szBuffer, ARRAYSIZE(szBuffer));

          col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
          col.fmt = LVCFMT_LEFT;
          col.cx = cx;
          col.pszText = szBuffer;
          col.iSubItem = 0;
          ListView_InsertColumn (hLV, 0, &col);

          LoadString (hInst, IDS_COLUMN2, szBuffer, ARRAYSIZE(szBuffer));

          col.cx = rect.right - cx - GetSystemMetrics(SM_CYHSCROLL);
          col.fmt = LVCFMT_RIGHT;
          col.iSubItem = 1;
          ListView_InsertColumn (hLV, 1, &col);


          //
          // Hide small items by default
          //

          g_bHideSmallItems = TRUE;
          CheckDlgButton (hDlg, IDC_QUOTA_HIDESMALL, BST_CHECKED);


          CenterWindow (hDlg);
          SetForegroundWindow (hDlg);


          // EnumerateProfile (GetDlgItem (hDlg, IDC_QUOTA_FILELIST));


          dwSize = 500 * sizeof(TCHAR);
          lpMessage = LocalAlloc (LPTR, dwSize);
          if (!lpMessage)
              break;

          LoadString (hInst ,IDS_QUOTAENUMMSG, lpMessage, 500);
          
          SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);


          if (g_dwProfileSize > g_dwMaxProfileSize) {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconStop, 0);

          } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconCaution, 0);

          }  else {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconGood, 0);
          }

          //
          // Setting the global value at the end QuotaThread is not trying
          // to refresh the dialog etc. at the same time.
          //
          
          g_hQuotaDlg = hDlg;

          SetEvent(g_hQuotaDlgEvent);

          LocalFree (lpMessage);

          break;
          
      case WM_REFRESH:

          //
          // Popuplate the listview
          //


          //
          // Set the size information
          //

          hr = StringCchPrintf(szSize, ARRAYSIZE(szSize), szSizeFormat, g_dwProfileSize);
          if (FAILED(hr))
              break;
          SetDlgItemText (hDlg, IDC_QUOTA_SIZE, szSize);

          hr = StringCchPrintf(szSize, ARRAYSIZE(szSize), szSizeFormat, g_dwMaxProfileSize);
          if (FAILED(hr))
              break;
          SetDlgItemText (hDlg, IDC_QUOTA_MAXSIZE, szSize);


          dwSize = 500 * sizeof(TCHAR);
          lpMessage = LocalAlloc (LPTR, dwSize);

          if (!lpMessage) {
              break;
          }

          if (g_dwProfileSize > g_dwMaxProfileSize) {

              //
              // This messge is already read
              //

              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, g_lpQuotaMessage);
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconStop, 0);

          } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {

              LoadString (hInst, IDS_CAUTION, lpMessage, 500);
              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);

              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconCaution, 0);

          }  else {

              LoadString (hInst, IDS_LOGOFFOK, lpMessage, 500);
              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);

              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconGood, 0);
          }

          LocalFree (lpMessage);
          break;


       case WM_COMMAND:
          if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
             g_hQuotaDlg = NULL;
             if ((g_dwProfileSize < g_dwMaxProfileSize) && (g_bQueryEndSession) && (g_dwProfileSize != 0)) {
                 PostMessage (hwndMain, WM_EXITWINDOWS, 0, 0);
             }
             EndDialog(hDlg, TRUE);
             return TRUE;
          }

          if (LOWORD(wParam) == IDC_QUOTA_HIDESMALL) {
              g_bHideSmallItems = IsDlgButtonChecked (hDlg, IDC_QUOTA_HIDESMALL);
              SetEvent(g_hQuotaDlgEvent);
          }

          break;
    }

    return FALSE;
}

//*************************************************************
//
//  ListViewSortCallback()
//
//  Purpose:    List view callback function for sorting
//
//  Parameters: lParam1     -   lParam1
//              lParam2     -   lParam2
//              lParamSort  -   Column id
//
//  Return:     -1, 0, 1
//
//*************************************************************
INT CALLBACK ListViewSortCallback (LPARAM lParam1, LPARAM lParam2,
                                    LPARAM lParamSort)
{

    if (lParam1 < lParam2) {
        return 1;

    } else if (lParam1 == lParam2) {
        return 0;

    } else {
        return -1;
    }

}


//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;
    UINT  cchRemaining;
    HRESULT hr;

    //
    // Setup a temp buffer to work with
    //

    hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpSourceDir);
    if (FAILED(hr)) {
        return NULL;
    }

    lpEnd = CheckSlash (szTemp, ARRAYSIZE(szTemp), &cchRemaining);
    if (!lpEnd) {
        return NULL;
    }

    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }

        //
        // Remove any leading spaces
        //

        while (*lpDir && *lpDir == TEXT(' ')) {
            lpDir++;
        }

        //
        // Check whether the entry is empty
        //

        if (lpDir == lpTemp) {
            // If we are at the end of the exclusion list, we're done
            if (!*lpTemp) {
                goto Exit;
            }

            //
            // Prep for the next entry
            //

            lpTemp++;
            lpDir = lpTemp;
            continue;
        }
        
        //
        // Put the directory name on the temp buffer
        //

        *lpEnd = TEXT('\0');
        hr = StringCchCatN(lpEnd, cchRemaining, lpDir, (int)(lpTemp - lpDir));
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to copy 0x%x"), hr));
            LocalFree (lpExcludeList);
            lpExcludeList = NULL;
            goto Exit;
        }

        //
        // Add the string to the exclusion list
        //

        if (lpExcludeList) {

            dwStrLen = lstrlen (szTemp) + 1;
            dwSize += dwStrLen;

            lpTempList = LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTempList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to realloc memory with %d"), GetLastError()));
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

            lpExcludeList = lpTempList;

            lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
            hr = StringCchCopy(lpInsert, dwStrLen, szTemp);
            if (FAILED(hr)) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to copy 0x%x"), hr));
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

        } else {

            dwSize += lstrlen (szTemp);
            lpExcludeList = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

            if (!lpExcludeList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to alloc memory with %d"), GetLastError()));
                goto Exit;
            }

            hr = StringCchCopy(lpExcludeList, dwSize, szTemp);
            if (FAILED(hr)) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to copy 0x%x"), hr));
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }
        }


        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            goto Exit;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

Exit:

    return lpExcludeList;
}

//*************************************************************
//
//  EnumerateProfile()
//
//  Purpose:    Enumerates the profile for size and names
//
//  Parameters: hLV -   listview window handle (optional)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EnumerateProfile (HWND hLV)
{
    TCHAR szProfile[2*MAX_PATH];
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    LPTSTR lpExcludeList = NULL;
    LVITEM item;


    //
    // Get the profile directory
    //

    szProfile[0] = TEXT('\0');
    GetEnvironmentVariable (TEXT("USERPROFILE"), szProfile, MAX_PATH);

    if (szProfile[0] == TEXT('\0')) {
        ExitThread (0);
    }

    lpEnd = CheckSlash (szProfile, ARRAYSIZE(szProfile), NULL);
    if (!lpEnd) {
        ExitThread (0);
    }


    //
    // Claim the critical section
    //

    EnterCriticalSection (&g_cs);


    if (hLV) {
        ListView_DeleteAllItems (hLV);
    }

    //
    // Get current profile size
    //

    g_dwProfileSizeTemp = 0;


    //
    // Convert the exclusionlist read from the registry to a Null terminated list
    // readable by recursedirectory.
    //

    if (g_szExcludeList[0] != TEXT('\0'))
        lpExcludeList = ConvertExclusionList (szProfile, g_szExcludeList);
    else
        lpExcludeList = NULL;


    if (!RecurseDirectory (szProfile, ARRAYSIZE(szProfile), lpEnd, hLV, lpExcludeList)) {
        SendMessage (hLV, WM_SETREDRAW, TRUE, 0);
        goto Exit;
    }

    g_dwProfileSize = g_dwProfileSizeTemp;

    //
    // Sort by size
    //

    ListView_SortItems (hLV, ListViewSortCallback, 1);


    //
    // Select the next item
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    //
    // Convert to K
    //

    if (g_dwProfileSize < 1024) {
        g_dwProfileSize = 1;
    } else {
        g_dwProfileSize /= 1024;
    }


    bRetVal = TRUE;

Exit:
    //
    // Release the critical section
    //

    LeaveCriticalSection (&g_cs);

    return bRetVal;
}

//*************************************************************
//
//  GetDisplayName()
//
//  Purpose:    Get display name from shell for specific directory
//              to display on the dialog box list view
//
//  Parameters: IN  lpDir : full directory name which display name is required
//              IN  lpTop : relative directory name from %USERPROFILE%
//              OUT lpDisplayName : buffer to retrieve the display name
//              IN  cchDisplayName : size of display name buffer
//
//  Return:     TRUE if success, else FALSE
//
//  Remark:     This function loops through each directory level of 
//              the lpDir and get the shell display name of it, append to the 
//              display name buffer. 
//
//*************************************************************
BOOL GetDisplayName(LPCTSTR lpDir, LPTSTR lpTop, LPTSTR lpDisplayName, DWORD cchDisplayName)
{
    SHFILEINFO   Info;
    BOOL         bFirstSlash = TRUE;
    HRESULT      hr;
    
    hr = StringCchCopy(lpDisplayName, cchDisplayName, TEXT(""));
    if (FAILED(hr))
        return FALSE;

    for ( ; lpTop[0]; lpTop++)
    {
        if (lpTop[0] == TEXT('\\'))
        {
            lpTop[0] = TEXT('\0');
            if (!SHGetFileInfo(lpDir, 0, &Info, sizeof(Info), SHGFI_DISPLAYNAME))
            {
                DebugMsg((DM_WARNING, TEXT("SHGetFileInfo failed, err = %d"), GetLastError()));
                lpTop[0] = TEXT('\\');
                return FALSE;
            }
            lpTop[0] = TEXT('\\');
            if (bFirstSlash)
            {
                bFirstSlash = FALSE;
            }
            else
            {
                hr = StringCchCat(lpDisplayName, cchDisplayName, TEXT("\\"));
                if (FAILED(hr))
                    return FALSE;
            }

            hr = StringCchCat(lpDisplayName, cchDisplayName, Info.szDisplayName);
            if (FAILED(hr))
                return FALSE;
        }
    }
    if (!SHGetFileInfo(lpDir, 0, &Info, sizeof(Info), SHGFI_DISPLAYNAME))
    {
        DebugMsg((DM_WARNING, TEXT("SHGetFileInfo failed, err = %d"), GetLastError()));
        return FALSE;
    }

    hr = StringCchCat(lpDisplayName, cchDisplayName, TEXT("\\"));
    if (FAILED(hr))
        return FALSE;
    hr = StringCchCat(lpDisplayName, cchDisplayName, Info.szDisplayName);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refreshevent\test\evprov.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:  EVPROV.cpp
//
// Description:
//    Sample event provider.
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include "oahelp.inl"
#include "evprov.h"


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::CMyEventProvider()
{
    m_pNs = 0;
    m_pSink = 0;
    m_cRef = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::~CMyEventProvider()
{
    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release();        
}


//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMyEventProvider::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // If here, we are shutting down.
    // ==============================

    m_eStatus = PendingStop;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags
    )
{
    // Copy the sink.
    // ==============
    
    m_pSink = pSink;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CMyEventProvider::EventThread,
        this,
        0,
        &dwTID
        );


    // Wait for provider to be 'ready'.
    // ================================
    
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  This particular provider, being in a DLL operates via its own thread.  
//
//  In practice, such a provider would probably be implemented within a 
//  separate EXE.
//
//***************************************************************************
// ok

DWORD WINAPI CMyEventProvider::EventThread(LPVOID pArg)
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CMyEventProvider *)pArg)->InstanceThread();
    return 0;
}

//***************************************************************************
//
//  Events are generated from here
//
//***************************************************************************
// ok

void CMyEventProvider::InstanceThread()
{
    int nIteration = 0;

    m_eStatus = Running;
        
    while (m_eStatus == Running)
    {
        Sleep(10000);    // Provide an event every ten seconds
        
        
        // Generate a new event object.
        // ============================
        
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;   // Failed
            

        // Generate some values to put in the event.
        // =========================================
                
        wchar_t Buf[128];
        swprintf(Buf, L"Test Event <%d>", nIteration);
 
        CVARIANT vName(Buf);
        pEvt->Put(CBSTR(L"Name"), 0, vName, 0);        

        if (nIteration % 2)
            swprintf(Buf, L"Machine");
        else
            swprintf(Buf, L"User");

 
        CVARIANT vTarget(Buf);
        pEvt->Put(CBSTR(L"MachineOrUser"), 0, vTarget, 0);       

        if (((nIteration >> 1) % 4) == 0)
            swprintf(Buf, L"");
        else if (((nIteration >> 1) % 4) == 1)
            swprintf(Buf, L"Force");
        else if (((nIteration >> 1) % 4) == 2)
            swprintf(Buf, L"FetchAndStore");
        else if (((nIteration >> 1) % 4) == 3)
            swprintf(Buf, L"MergeAndApply");


        CVARIANT vOption(Buf);
        pEvt->Put(CBSTR(L"RefreshOption"), 0, vOption, 0);       


        // Deliver the event to CIMOM.
        // ============================
        
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (hRes)
        {
            // If here, delivery failed.  Do something to report it.
        }

        pEvt->Release();                    
        nIteration++;
    }

    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    
    m_eStatus = Stopped;
    delete this;
}





//***************************************************************************
//
//***************************************************************************

    // Inherited from IWbemProviderInit
    // ================================

HRESULT CMyEventProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    // ===========================================================

    m_pNs = pNamespace;
    m_pNs->AddRef();    

    // Grab the class definition for the event.
    // ======================================
    
    IWbemClassObject *pObj = 0;

    HRESULT hRes = m_pNs->GetObject(
        CBSTR(EVENTCLASS),          
        0,                          
        pCtx,  
        &pObj,
        0
        );

    if (hRes != 0)
        return WBEM_E_FAILED;

    m_pEventClassDef = pObj;

    // Tell CIMOM that we're up and running.
    // =====================================

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refreshevent\test\evprov.h ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  EVPROV.H
//
// Description:
//        Sample event provider - header file defines event provider class
//
// History:
//
// **************************************************************************

#ifndef _EVPROV_H_
#define _EVPROV_H_

// {C0A94C66-CB70-4D06-91D2-5DE68C0D0EC5}
DEFINE_GUID(CLSID_MyEventProvider, 
0xC0A94C66, 0xCB70, 0x4D06, 0x91, 0xD2, 0x5D, 0xE6, 0x8C, 0x0D, 0x0E, 0xC5);

#define EVENTCLASS  L"PolicyRefreshEvent"


class CMyEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
    ULONG               m_cRef;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    int                 m_eStatus;
    HANDLE              m_hThread;
            
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

public:
    enum { Pending, Running, PendingStop, Stopped };

    CMyEventProvider();
   ~CMyEventProvider();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Inherited from IWbemEventProvider
    // =================================

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags
            );

    // Inherited from IWbemProviderInit
    // ================================

    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\create.cpp ===
//*************************************************************
//
//  Create namespace classes
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    9-Sep-99   SitaramR    Created
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include <ole2.h>
#include <initguid.h>
#include <wbemcli.h>

#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <seopaque.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <lm.h>

#include "smartptr.h"
#include "RsopInc.h"
#include "rsopsec.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "stdio.h"
#include "wbemtime.h"
#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *pwszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2,
                    DWORD dwParam3 );

//
// b7b1b3dd-ab09-4242-9e30-9980e5d322f7
//
const GUID guidProperty = {0xb7b1b3dd, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

DWORD
RSoPBuildPrivileges( PSECURITY_DESCRIPTOR pSD, PSECURITY_DESCRIPTOR pAbsoluteSD, LPWSTR*, DWORD );

LPWSTR
GetDomainName();

DWORD
MakeUserName( LPWSTR szDomain, LPWSTR szUser, LPWSTR* pszUserName );

//*************************************************************
//
//  CreateNameSpace
//
//  Purpose:  Creates a new namespace
//
//  Parameters: pwszNameSpace - Namespace to create
//              pwszParentNS  - Parent namespace in which to create pwszNameSpace
//
//              pWbemLocator  - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
CreateNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNS, IWbemLocator *pWbemLocator )
{
    IWbemClassObject *pNSClass = NULL;
    IWbemClassObject *pNSInstance = NULL;
    IWbemServices *pWbemServices = NULL;

    XBStr xParentNameSpace( pwszParentNS );
    if ( !xParentNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("LogRegistryRsopData: Unable to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pWbemLocator->ConnectServer( xParentNameSpace,
                                              NULL,
                                              NULL,
                                              0L,
                                              0L,
                                              NULL,
                                              NULL,
                                              &pWbemServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemServices> xWbemServices( pWbemServices );

    XBStr xbstrNS( L"__Namespace" );
    if ( !xbstrNS )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->GetObject( xbstrNS,
                                   0, NULL, &pNSClass, NULL );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::GetObject failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemClassObject> xNSClass( pNSClass );

    hr = pNSClass->SpawnInstance( 0, &pNSInstance );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: SpawnInstance failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemClassObject> xNSInstance( pNSInstance );

    XBStr xbstrName( L"Name" );
    if ( !xbstrName )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    XBStr xbstrNameSpace( pwszNameSpace );
    if ( !xbstrNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xbstrNameSpace;

    hr = pNSInstance->Put( xbstrName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: Put failed with 0x%x" ), hr );
        return hr;
    }

    hr = pWbemServices->PutInstance( pNSInstance, WBEM_FLAG_CREATE_ONLY, NULL, NULL );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: PutInstance failed with 0x%x" ), hr );
        return hr;
    }

    return hr;
}


//*************************************************************
//
//  Function:   SetupCreationTimeAndCommit
//
//  Purpose:    Connects to a namespace where it expects to
//              find class RSOP_Session as defined in rsop.mof.
//              It then instantiates the class and sets the
//              data member 'creationTime' to the current
//              date and time.
//
//  Parameters: pWbemLocator -  Pointer to IWbemLocator used to
//                              connect to the namespace.
//              wszNamespace -  Name of the Namespace to connect.
//
//  Returns:    On success, it returns S_OK.
//              On failure, it returns an HRESULT error code.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT SetupCreationTimeAndCommit(IWbemLocator* pWbemLocator, LPWSTR wszNamespace)
{
    //
    // Check arguments
    //

    if(!pWbemLocator || !wszNamespace || (wcscmp(wszNamespace, L"") == 0))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function called with invalid argument(s)."));
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Connect to the namespace
    //

    XBStr xbstrNamespace = wszNamespace;
    if(!xbstrNamespace)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XInterface<IWbemServices>xpNamespace;
    HRESULT hr = pWbemLocator->ConnectServer(   xbstrNamespace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpNamespace);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: ConnectServer failed. hr=0x%08X"), hr);
        return hr;
    }


    VARIANT var;
    VariantInit(&var);

    //
    // Get class RSOP_Session
    //

    XBStr xbstrClassName = L"RSOP_Session";
    if (!xbstrClassName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XInterface<IWbemClassObject>xpClass;
    hr = xpNamespace->GetObject(xbstrClassName, 0, NULL, &xpClass, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: GetObject failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Spawn an instance of class RSOP_Session
    //

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory."));
        return FALSE;
    }


    XInterface<IWbemClassObject>xpInstance;

    hr = xpNamespace->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupCreationTimeAndCommit: GetObject failed. trying to spawn instance. hr=0x%08X"), hr);
        hr = xpClass->SpawnInstance(0, &xpInstance);
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: SpawnInstance failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'id' data member of class RSOP_Session
    //

    XBStr xbstrPropertyName;
    XBStr xbstrPropertyValue;

    xbstrPropertyName = L"id";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    xbstrPropertyValue = L"Session1";
    if(!xbstrPropertyValue)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrPropertyValue;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'creationTime' data member of class RSOP_Session
    //

    xbstrPropertyName = L"creationTime";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    hr = GetCurrentWbemTime(xbstrPropertyValue);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: GetCurrentWbemTime. hr=0x%08X"), hr);
        return hr;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrPropertyValue;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'ttlMinutes' data member of class RSOP_Session
    //

    xbstrPropertyName = L"ttlMinutes";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    var.vt = VT_I4;
    var.lVal = DEFAULT_NAMESPACE_TTL_MINUTES;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    // if any more data integrity checks needs to be done
    // it can be done at this point

    
    //
    // Put instance of class RSOP_Session
    //

    hr = xpNamespace->PutInstance(xpInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: PutInstance failed. hr=0x%08X"), hr);
        return hr;
    }

    return S_OK;
}


//*************************************************************
//
//  SetupNameSpaceSecurity
//
//  Purpose:  Sets namespace security.
//
//  Parameters: szNamespace  - New namespace returned here
//              pSD - source security descriptor
//              pWbemLocator   - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
SetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR pSD,
                        IWbemLocator* pWbemLocator)
{
    XBStr xNameSpace( (LPWSTR) szNamespace );
    if ( !xNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNameSpaceSecurity: Unable to allocate memory" ));
        return E_FAIL;
    }

    XInterface<IWbemServices> xptrServices;

    HRESULT hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              &xptrServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNameSpaceSecurity::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    return SetNamespaceSD( (SECURITY_DESCRIPTOR*)pSD, xptrServices);
}

//*************************************************************
//
//  GetNameSpaceSecurity
//
//  Purpose:  Sets namespace security.
//
//  Parameters: szNamespace  - New namespace returned here
//              pSD - source security descriptor
//              pWbemLocator   - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
GetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR *ppSD,
                        IWbemLocator* pWbemLocator)
{
    XBStr xNameSpace( (LPWSTR) szNamespace );
    if ( !xNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetNameSpaceSecurity: Unable to allocate memory" ));
        return E_FAIL;
    }

    XInterface<IWbemServices> xptrServices;

    HRESULT hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              &xptrServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetNameSpaceSecurity::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    return GetNamespaceSD(xptrServices, (SECURITY_DESCRIPTOR **)ppSD);
}


//*************************************************************
//
//  CopyNameSpaceSecurity
//
//  Purpose:  Copies namespace security.
//
//  Parameters: pwszSrcNameSpace  - Source namespace
//              pwszDstNameSpace  - Dest   namespace
//              pWbemLocator      - Wbem locator
//
//  Returns:    HRESULT
//
//*************************************************************

HRESULT CopyNameSpaceSecurity(LPWSTR pwszSrcNameSpace, LPWSTR pwszDstNameSpace, IWbemLocator *pWbemLocator )
{
    XHandle xhThreadToken;
    HRESULT hr              =       S_OK;

    //
    // There is a bug in WMI which destroys the current thread token
    // if connectserver is called to the local machine with impersonation.
    // The following SetThreadToken needs to be removed once WMI bug 454721 is fixed.
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, &xhThreadToken)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        if(hr != HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Openthreadtoken failed with error 0x%x."), hr);
            return hr;
        }

        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CopyNameSpaceSecurity: Openthreadtoken failed with error 0x%x."), hr);
    }


    // internal function. arg checks not needed

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CopyNameSpaceSecurity: Copying Sec Desc from <%s> -> <%s>."),
                                    pwszSrcNameSpace, pwszDstNameSpace );


    //
    // Copy to a BStr
    //

    XBStr xSrcNameSpace(pwszSrcNameSpace);

    if (!xSrcNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XBStr xDstNameSpace(pwszDstNameSpace);

    if (!xDstNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }


    //
    // Get the Source WBem Service
    //

    XInterface<IWbemServices> xpSrcSvc;

    hr = pWbemLocator->ConnectServer(   xSrcNameSpace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpSrcSvc);


    if(!SetThreadToken(NULL, xhThreadToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: SetThreadToken failed for src. hr=0x%08X"), hr);
        return hr;
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: ConnectServer failed for src. hr=0x%08X"), hr);
        return hr;
    }


    //
    // Self relative SD on the Source Name Space
    //

    XPtrLF<SECURITY_DESCRIPTOR> xpSelfRelativeSD;

    hr = GetNamespaceSD(xpSrcSvc, &xpSelfRelativeSD);

    if(!SetThreadToken(NULL, xhThreadToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: SetThreadToken failed for src. hr=0x%08X"), hr);
        return hr;
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: GetNameSpaceSD failed for src. hr=0x%08X"), hr);
        return hr;
    }



    //
    // Get the Dest WBem Service
    //

    XInterface<IWbemServices> xpDstSvc;

    hr = pWbemLocator->ConnectServer(           xDstNameSpace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpDstSvc);


    if(!SetThreadToken(NULL, xhThreadToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: SetThreadToken failed for src. hr=0x%08X"), hr);
        return hr;
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: ConnectServer failed for Dst. hr=0x%08X"), hr);
        return hr;
    }


    //
    // Set the SD already got on the Destination
    //

    hr = SetNamespaceSD( xpSelfRelativeSD, xpDstSvc);

    if(!SetThreadToken(NULL, xhThreadToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: SetThreadToken failed for src. hr=0x%08X"), hr);
        return hr;
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CopyNameSpaceSecurity: SetNamespaceSD failed on Dst, 0x%08X", hr );
        return hr;
    }


    // All Done
    return S_OK;
}


//*************************************************************
//
//  ProviderDeleteRsopNameSpace
//
//  Purpose:    WMI doesn't provide a mechanism to allow a user to delete a namespace
//              unless it has write permissions on the parent
//
//  Parameters: pwszNameSpace       - Namespace to be deleted
//              hToken              - Token of the calling user.
//              szSidString         - String form of the calling user's sid.
//              dwFlags             - Flag to indicate planning mode or diagnostic mode
//
//  Returns:    S_OK if successful, HRESULT o/w
//
//*************************************************************

HRESULT ProviderDeleteRsopNameSpace( IWbemLocator *pWbemLocator, LPWSTR szNameSpace, HANDLE hToken, LPWSTR szSidString, DWORD dwFlags)
{

    BOOL bDelete = FALSE;
    BOOL bFound = FALSE;
    HRESULT hr = S_OK;
    LPWSTR  pStr = szNameSpace;

    //
    // Make sure that the namespace is under root\rsop
    //

    for ( ;*pStr; pStr++) {
        if (_wcsnicmp(pStr, RSOP_NS_ROOT_CHK, wcslen(RSOP_NS_ROOT_CHK)) == 0) {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: namespace is not under root\\rsop" );
        return E_INVALIDARG;
    }


    if ( dwFlags & SETUP_NS_SM && IsInteractiveNameSpace(szNameSpace, szSidString)) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: interactive namespace for the user." );
        bDelete = TRUE;
    }
    else {
        //
        // if it is not interactive namespace check access
        //

        XPtrLF<SECURITY_DESCRIPTOR> xsd;

        hr = GetNameSpaceSecurity(szNameSpace, (PSECURITY_DESCRIPTOR *)&xsd, pWbemLocator);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: GetNameSpaceSecurity failed with error 0x%x", hr );
            return hr;
        }


        GENERIC_MAPPING map;
        PRIVILEGE_SET ps[3];
        DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
        BOOL bResult;
        DWORD dwGranted = 0;
    
        map.GenericRead    = WMI_GENERIC_READ;
        map.GenericWrite   = WMI_GENERIC_WRITE;
        map.GenericExecute = WMI_GENERIC_EXECUTE;
        map.GenericAll     = WMI_GENERIC_ALL;
        

        if (!AccessCheck(xsd, hToken, RSOP_ALL_PERMS, &map, ps, &dwSize, &dwGranted, &bResult)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: AccessCheck failed with error 0x%x", hr );
            return hr;
        }
    

        if(bResult && dwGranted) {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: User has full rights on the child namespace");
            bDelete = TRUE;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: This user is not granted access on the namespace", hr );

        }
    }

    if (bDelete) {
        hr = DeleteRsopNameSpace(szNameSpace, pWbemLocator);
    }
    else {
        hr = WBEM_E_ACCESS_DENIED;
    }

    return hr;
}


//*************************************************************
//
//  SetupNewNameSpace
//
//  Purpose:    Creates a new temp namespace and two child namespaces, User and Computer.
//              It also copies all the class definitions
//              Additionally, it calls SetupCreationTimeAndCommit
//              which in turn instantiates RSOP_Session and updates the
//              data member 'creationTime' with the current time.
//
//  Parameters: pwszNameSpace       - New namespace returned here (This is allocated here)
//              szRemoteComputer    - Remote Computer under which this name space has to be
//                                    created.
//              szUserSid           - UserSid. Only relevant in Diagnostic mode
//              pSid                - Sid of the calling User
//              pWbemLocator        - Wbem locator
//              dwFlags             - Flag to indicate planning mode or diagnostic mode
//              dwExtendedInfo      - The extended info to modify appropriately
//
//  Returns:    True if successful, false otherwise
//
//
// Usage:
//      In Diagnostic mode, we copy instances. In planning mode we just copy Classes
//*************************************************************

HRESULT SetupNewNameSpace( 
                        LPWSTR       *pwszOutNameSpace,
                        LPWSTR        szRemoteComputer,
                        LPWSTR        szUserSid,
                        PSID          pSid,
                        IWbemLocator *pWbemLocator,
                        DWORD         dwFlags,
                        DWORD        *pdwExtendedInfo)
{
    GUID          guid;
    XPtrLF<WCHAR> xwszRelNameSpace;
    XPtrLF<WCHAR> xwszRootNameSpace;
    XPtrLF<WCHAR> xwszSrcNameSpace;
    DWORD         dwSrcNSLen;
    XPtrLF<WCHAR> xwszNameSpace;
    LPWSTR        szComputerLocal;
    HRESULT       hr = S_OK, hrUser = S_OK, hrMachine = S_OK;

    if ((dwFlags & SETUP_NS_SM_INTERACTIVE) || 
        (dwFlags & SETUP_NS_SM_NO_USER) ||  
        (dwFlags & SETUP_NS_SM_NO_COMPUTER)) {

        if (!(dwFlags & SETUP_NS_SM)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::invalid flag parameters"));
            return E_INVALIDARG;
        }
    }


    
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;

    *pwszOutNameSpace = NULL;
    
    Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);

    if (dwFlags & SETUP_NS_SM)
    {
        Csd.AddNetworkService(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    }

    if (dwFlags & SETUP_NS_SM_INTERACTIVE) {
        Csd.AddSid(pSid, RSOP_READ_PERMS, CONTAINER_INHERIT_ACE);
    }
    else {
        Csd.AddSid(pSid, RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    }


    Csd.AddAdministratorsAsOwner();
    Csd.AddAdministratorsAsGroup();


    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Makeselfrelativesd failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // ignore inheritted perms..
    //

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::SetSecurityDescriptorControl failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Initialise the out params
    //

    if ((dwFlags & SETUP_NS_SM) && (!szUserSid))
        return E_INVALIDARG;


    //
    // Calculate the length required for the name spaces
    //

    DWORD dwLenNS = RSOP_NS_TEMP_LEN;

    if ((szRemoteComputer) && (*szRemoteComputer)) {
        dwLenNS += lstrlen(szRemoteComputer);
        szComputerLocal = szRemoteComputer;
    }
    else {
        szComputerLocal = L".";
    }

    //
    // guid for the Name Space
    //

    hr = CoCreateGuid( &guid );
    if ( FAILED(hr) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CoCreateGuid failed with 0x%x"), hr );
        return hr;
    }

    //
    // Allocate the memory and initialise
    //

    DWORD dwRootNSLength = lstrlen(szComputerLocal) + RSOP_NS_ROOT_LEN;
    xwszRootNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwRootNSLength));
    if (!xwszRootNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Not enough Space. Error - 0x%x"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }        

    // allocating max needed        

    dwSrcNSLen = ( RSOP_NS_ROOT_LEN + lstrlen(szUserSid) + RSOP_NS_MAX_OFFSET_LEN + 10);

    if (dwFlags & SETUP_NS_SM)
        dwSrcNSLen += lstrlen(szUserSid);

    xwszSrcNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSrcNSLen);

    if (!xwszSrcNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Not enough Space. Error - 0x%x"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }        

    hr = StringCchPrintf(xwszRootNameSpace, dwRootNSLength, RSOP_NS_REMOTE_ROOT_FMT, szComputerLocal);

    if(FAILED(hr))
        return hr;

    hr = StringCchCopy(xwszSrcNameSpace, dwSrcNSLen, RSOP_NS_DIAG_ROOT);

    if(FAILED(hr))
        return hr;

    LPTSTR lpEnd =  xwszSrcNameSpace + lstrlen(xwszSrcNameSpace);

    //
    // Create a new Name Space under the root
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupNewNameSpace: Creating new NameSpace <%s>"), xwszRootNameSpace);

    DWORD dwRelNSLength = 1 + MAX(lstrlen(szUserSid), RSOP_NS_TEMP_LEN); 
    xwszRelNameSpace = (LPWSTR)LocalAlloc(LPTR, ( dwRelNSLength ) * sizeof(WCHAR));

    if (!xwszRelNameSpace) {
        hr = E_OUTOFMEMORY;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::AllocMem failed with 0x%x"), hr );
        return hr;
    }

    if (dwFlags & SETUP_NS_SM_INTERACTIVE) {

        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (lstrlen(szUserSid) + 1));
        if (!xszWmiName) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
            return E_OUTOFMEMORY;
        }

        ConvertSidToWMIName(szUserSid, xszWmiName);
        
        hr = StringCchPrintf( xwszRelNameSpace,
                              dwRelNSLength,
                              L"%s%s",
                              RSOP_NS_TEMP_PREFIX,
                              (LPWSTR) xszWmiName);
    }
    else {
        
        hr = StringCchPrintf( xwszRelNameSpace,
                              dwRelNSLength, 
                              L"%s%08lX_%04X_%04X_%02X%02X_%02X%02X%02X%02X%02X%02X",
                              RSOP_NS_TEMP_PREFIX,
                              guid.Data1,
                              guid.Data2,
                              guid.Data3,
                              guid.Data4[0], guid.Data4[1],
                              guid.Data4[2], guid.Data4[3],
                              guid.Data4[4], guid.Data4[5],
                              guid.Data4[6], guid.Data4[7] );
    }

    if(FAILED(hr))
        return hr;

    hr = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszRootNameSpace, 
                            xwszRelNameSpace, 0, xsd, &xwszNameSpace);
              
    if ( FAILED(hr) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hr );
        return hr;
    }

    //
    // if it has come till here, the assumption is that we
    // could create the namespace in the context that we are running in
    //
    // In diagnostic interactive mode we have already made sure that the sid is the 
    // same as the user.
    //

    if (pdwExtendedInfo) {
        *pdwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;
        *pdwExtendedInfo &= ~RSOP_COMPUTER_ACCESS_DENIED;

    }

    hr = StringCchCat(lpEnd,  dwSrcNSLen - (lpEnd - xwszSrcNameSpace), L"\\"); 
    
    if(FAILED(hr))
        return hr;

    lpEnd++;

    DWORD dwCopyFlags = 0;
    
    if (dwFlags & SETUP_NS_PM) {

        //
        // if it is planning mode, copy classes from RSOP_NS_USER
        //

        hr = StringCchCopy(lpEnd, dwSrcNSLen - (lpEnd - xwszSrcNameSpace), RSOP_NS_USER_OFFSET);
        
        if(FAILED(hr))
            return hr;

        dwCopyFlags = NEW_NS_FLAGS_COPY_CLASSES;
    }
    else {

        if (dwFlags & SETUP_NS_SM_NO_USER) {

            //
            // If no user copy classes from root\rsop\user itself
            //

            hr = StringCchCopy(lpEnd, dwSrcNSLen - (lpEnd - xwszSrcNameSpace), RSOP_NS_SM_USER_OFFSET);

            if(FAILED(hr))
                return hr;

            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
        }
        else {
            
            //
            // if it is diagnostic mode, copy classes and instances from RSOP_NS_USER_SId
            //

            XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szUserSid)+1));
            if (!xszWmiName) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
                return FALSE;
            }

            ConvertSidToWMIName(szUserSid, xszWmiName);
            
            hr = StringCchPrintf(lpEnd, dwSrcNSLen - (lpEnd - xwszSrcNameSpace), RSOP_NS_DIAG_USER_OFFSET_FMT, (LPWSTR) xszWmiName);

            if(FAILED(hr))
                return hr;

            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS;
        }
    }
    

    hrUser = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszNameSpace, 
                            RSOP_NS_SM_USER_OFFSET, dwCopyFlags, 
                            xsd, NULL);
              
    if ( FAILED(hrUser) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hrUser );
    }


    //
    // for machine only the flags are different. source namespaces are the same
    //
    
    if (dwFlags & SETUP_NS_PM) {
        dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
    }
    else {
        if (dwFlags & SETUP_NS_SM_NO_COMPUTER) 
            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
        else
            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS;
    }


    hr = StringCchCopy(lpEnd, dwSrcNSLen - (lpEnd - xwszSrcNameSpace), RSOP_NS_MACHINE_OFFSET);

    if(FAILED(hr))
        return hr;
    
    hrMachine = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszNameSpace,
                            RSOP_NS_DIAG_MACHINE_OFFSET, dwCopyFlags, 
                            xsd, NULL);
              
    if ( FAILED(hrMachine) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hrMachine );
    }


    if (FAILED(hrUser)) {
        if (pdwExtendedInfo) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::User part of rsop failed with 0x%x"), hrUser );
            *pdwExtendedInfo |= RSOP_USER_ACCESS_DENIED;
        }
    }

    if (FAILED(hrMachine)) {
        if (pdwExtendedInfo) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::computer part of rsop failed with 0x%x"), hrMachine );
            *pdwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;
        }
    }

    if (FAILED(hrUser)) {
        return hrUser;
    }

    if (FAILED(hrMachine)) {
        return hrMachine;
    }


    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupNewNameSpace: Returning Successfully"));


    //
    // Now handover the ownership to the caller.
    //

    *pwszOutNameSpace = xwszNameSpace.Acquire();

    return S_OK;
}


//*************************************************************
// ConvertSidToWMIName
//
// WMI doesn't like '-' in names. Connverting - to '_' blindly
//*************************************************************

void ConvertSidToWMIName(LPTSTR lpSid, LPTSTR lpWmiName)
{
    for (;(*lpSid); lpSid++, lpWmiName++) {
        if (*lpSid == L'-')
            *lpWmiName = L'_';
        else
            *lpWmiName = *lpSid;
    }

    *lpWmiName = L'\0';
}


//*************************************************************
// ConvertWMINameToSid
//
// WMI doesn't like '-' in names. 
//*************************************************************

void ConvertWMINameToSid(LPTSTR lpWmiName, LPTSTR lpSid )
{
    for (;(*lpWmiName); lpSid++, lpWmiName++) {
        if (*lpWmiName == L'_')
            *lpSid = L'-';
        else
            *lpSid = *lpWmiName;
    }

    *lpSid = L'\0';
}



//*************************************************************
//
//  DeleteNameSpace
//
//  Purpose:  Deletes namespace
//
//  Parameters: pwszNameSpace - Namespace to delete
//              pWbemLocator  - Wbem locator pointer
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
DeleteNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNameSpace, IWbemLocator *pWbemLocator )
{
    XBStr xParentNameSpace( pwszParentNameSpace );
    if ( !xParentNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteNameSpace: Unable to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    IWbemServices *pWbemServices = NULL;
    HRESULT hr = pWbemLocator->ConnectServer( xParentNameSpace,
                                              NULL,
                                              NULL,
                                              0L,
                                              0L,
                                              NULL,
                                              NULL,
                                              &pWbemServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemServices> xWbemServices( pWbemServices );

    WCHAR wszNSRef[] = L"__Namespace.name=\"%ws\"";
    XPtrST<WCHAR> xwszNSValue;

    if ( !PrintToString( xwszNSValue, wszNSRef, pwszNameSpace, 0, 0 ) )
    {
        return E_OUTOFMEMORY;
    }

    XBStr xbstrNSValue( xwszNSValue );
    if ( !xbstrNSValue )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteNameSpace: Failed to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xbstrNSValue;

    hr = pWbemServices->DeleteInstance( var.bstrVal,
                                        0L,
                                        NULL,
                                        NULL );

    if ( FAILED(hr) )
    {
         dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace: Failed to DeleteInstance with 0x%x"), hr );
        return hr;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace: Deleted namespace %s under %s" ), pwszNameSpace, pwszParentNameSpace);
    return hr;
}

//*************************************************************
//
//  DeleteRsopNameSpace
//
//  Purpose:  Deletes namespace
//
//  Parameters: pwszNameSpace - Namespace to delete (the full path)
//              pWbemLocator  - Wbem locator pointer
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT DeleteRsopNameSpace( WCHAR *pwszNameSpace, IWbemLocator *pWbemLocator )
{
    LPWSTR pwszChildName = NULL;
    HRESULT hr = S_OK;

    //
    // Generating the parent child name by traversing the name
    //
     
    pwszChildName = wcsrchr(pwszNameSpace, L'\\');

    if (!pwszChildName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteRsopNameSpace: Invalid format - %s" ), pwszNameSpace);
        return E_INVALIDARG;
    }


    WCHAR wTmp = *pwszChildName;
    *pwszChildName = L'\0';
    pwszChildName++;

    hr = DeleteNameSpace(pwszChildName, pwszNameSpace, pWbemLocator);

    *(pwszChildName-1) = wTmp;
    return hr;
}

//*************************************************************
//
//  IsInteractiveNameSpace
//
//  Purpose:  returns whether a namespace is a special namespace
//            specifically created to allow interactive users to get rsop
//            data
//
//  Parameters: pwszNameSpace - Namespace 
//              szSid         - Sid of the user
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

BOOL IsInteractiveNameSpace(WCHAR *pwszNameSpace, WCHAR *szSid)
{
    LPWSTR          pwszChildName = NULL;
    HRESULT         hr            = S_OK;
    XPtrLF<WCHAR>   xwszInteractiveNameSpace;
    BOOL            bInteractive  = FALSE;

    DWORD dwInteractiveNSLength = 5 + wcslen(RSOP_NS_TEMP_PREFIX) + wcslen(szSid);
    xwszInteractiveNameSpace = (LPWSTR)LocalAlloc(LPTR, ( dwInteractiveNSLength )*sizeof(WCHAR));

    if (!xwszInteractiveNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace: Couldn't Allocate memory. Error - %d" ), GetLastError());
        return bInteractive;
    }
    
    //
    // Generating the parent child name by traversing the name
    //
     
    pwszChildName = wcsrchr(pwszNameSpace, L'\\');

    if (!pwszChildName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace: Invalid format - %s" ), pwszNameSpace);
        return bInteractive;
    }

    pwszChildName++;

    XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szSid)+1));
    if (!xszWmiName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
        return bInteractive;
    }

    ConvertSidToWMIName(szSid, xszWmiName);

    hr = StringCchPrintf( xwszInteractiveNameSpace,
                          dwInteractiveNSLength,
                          L"%s%s",
                          RSOP_NS_TEMP_PREFIX,
                          (LPWSTR) xszWmiName );

    if(FAILED(hr))
        return bInteractive;

    if (_wcsicmp(pwszChildName, xwszInteractiveNameSpace) == 0) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("IsInteractiveNameSpace:: Interactive namespace"));
        bInteractive = TRUE;
    }

    return bInteractive;
}


//*************************************************************
//
//  GetInteractiveNameSpace
//
//  Purpose:  returns whether a namespace is a special namespace
//            specifically created to allow interactive users to get rsop
//            data
//
//  Parameters: pwszNameSpace - Namespace 
//              szSid         - Sid of the user
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT GetInteractiveNameSpace(WCHAR *szSid, LPWSTR *szNameSpace)
{
    XPtrLF<WCHAR>   xwszInteractiveNameSpace;

    *szNameSpace = NULL;

    DWORD dwInteractiveNSLength = 5 + wcslen(RSOP_NS_TEMP_FMT) + wcslen(szSid);
    xwszInteractiveNameSpace = (LPWSTR)LocalAlloc(LPTR, ( dwInteractiveNSLength )*sizeof(WCHAR));

    if (!xwszInteractiveNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetInteractiveNameSpace: Couldn't Allocate memory. Error - %d" ), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szSid)+1));
    if (!xszWmiName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetInteractiveNameSpace::Couldn't allocate memory with error %d"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ConvertSidToWMIName(szSid, xszWmiName);

    HRESULT hr = StringCchPrintf( xwszInteractiveNameSpace,
                          dwInteractiveNSLength,
                          RSOP_NS_TEMP_FMT,
                          (LPWSTR) xszWmiName);

    if(FAILED(hr))
        return hr;

    *szNameSpace = xwszInteractiveNameSpace.Acquire();

    return S_OK;
}

//*************************************************************
//
//  PrintToString
//
//  Purpose:    Safe swprintf routine
//
//  Parameters: xwszValue  - String returned here
//              wszString  - Format string
//              pwszParam1 - Param 1
//              pwszParam2 - Param 2
//              dwParam3   - Param 3
//
//*************************************************************

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *pwszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2,
                    DWORD dwParam3 )
{
    DWORD dwSize = wcslen(pwszString) + 32;

    if ( pwszParam1 )
    {
        dwSize += wcslen( pwszParam1 );
    }
    if ( pwszParam2 )
    {
        dwSize += wcslen( pwszParam2 );
    }

    xwszValue = new WCHAR[dwSize];
    if ( !xwszValue ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("PrintToString: Failed to allocate memory" ));
        return FALSE;
    }

    HRESULT hr = StringCchPrintf( xwszValue, dwSize, pwszString,
                                  pwszParam1, pwszParam2, dwParam3 );

    while ( FAILED(hr) ) {

        dwSize *= 2;
        xwszValue = new WCHAR[dwSize];
        if ( !xwszValue ) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("PrintToString: Failed to allocate memory" ));
            return FALSE;
        }

        hr = StringCchPrintf( xwszValue, dwSize, pwszString,
                              pwszParam1, pwszParam2, dwParam3 );
    }       

    return TRUE;
}



//*************************************************************
//
//  CreateAndCopyNameSpace
//
//  Purpose:  Creates and Copies the name space
//            This does an exact replica of the Src Name Space including
//            copying the security Descriptors from the Source
//
//  Parameters:
//
//  Returns:    domain name if successful, 0 otherwise
//
//*************************************************************

HRESULT
CreateAndCopyNameSpace(IWbemLocator *pWbemLocator, LPWSTR szSrcNameSpace, LPWSTR szDstRootNameSpace, 
                            LPWSTR szDstRelNameSpace, DWORD dwFlags, PSECURITY_DESCRIPTOR pSecDesc, LPWSTR *szDstNameSpaceOut)
{

    BOOL            bOk = TRUE, bAbort = FALSE;
    BOOL            bCopyClasses   = (dwFlags & NEW_NS_FLAGS_COPY_CLASSES) ? TRUE : FALSE;
    BOOL            bCopyInstances = (dwFlags & NEW_NS_FLAGS_COPY_INSTS)   ? TRUE : FALSE;
    XPtrLF<WCHAR>   xszDstNameSpace;
    HRESULT         hr = S_OK;
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: New Name space from %s -> %s,%s, flags 0x%x "), 
                                    szSrcNameSpace, szDstRootNameSpace, szDstRelNameSpace, dwFlags);
    
    if (szDstNameSpaceOut)
    {
        *szDstNameSpaceOut = 0;
    }
    
    DWORD dwDstNSLength = lstrlen(szDstRootNameSpace) + lstrlen(szDstRelNameSpace) + 5;
    xszDstNameSpace = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwDstNSLength ));
    if (!xszDstNameSpace)
    {
        return E_OUTOFMEMORY;      
    }

    hr = StringCchCopy(xszDstNameSpace, dwDstNSLength, szDstRootNameSpace);

    if(FAILED(hr))
        return hr;

    hr = StringCchCat(xszDstNameSpace, dwDstNSLength, L"\\");

    if(FAILED(hr))
        return hr;

    hr = StringCchCat(xszDstNameSpace, dwDstNSLength, szDstRelNameSpace);
    
    if(FAILED(hr))
        return hr;

    hr = CreateNameSpace( szDstRelNameSpace, szDstRootNameSpace, pWbemLocator );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CreateNameSpace failed with 0x%x"), hr );
        return hr;
    }

    if (!pSecDesc)
    {
        hr = CopyNameSpaceSecurity(szSrcNameSpace, xszDstNameSpace, pWbemLocator );

        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CopyNameSpaceSecurity failed with 0x%x"), hr );
            goto Exit;
        }
    }
    else 
    {
        hr = SetNameSpaceSecurity( xszDstNameSpace, pSecDesc, pWbemLocator);

        if ( FAILED(hr) ) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::SetNameSpaceSecurity failed with 0x%x"), hr );
            goto Exit;
        }
    }
    

    

    if (bCopyClasses) {
    
        hr = CopyNameSpace( szSrcNameSpace, xszDstNameSpace, bCopyInstances, &bAbort, pWbemLocator );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CopyNameSpace failed with 0x%x"), hr );
            goto Exit;
        }


        //
        // Instantiate class RSOP_Session and set data member
        // 'creationTime' with current date and time.
        //

        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: Setting up creation time"));

        hr = SetupCreationTimeAndCommit(pWbemLocator, xszDstNameSpace);
        if(FAILED(hr))
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace: SetupCreationTimeAndCommit failed with 0x%x"), hr );
            goto Exit;
        }
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: Returning with Success NameSpace %s "), 
                                    xszDstNameSpace);
    
    if (szDstNameSpaceOut)
    {
        *szDstNameSpaceOut = xszDstNameSpace.Acquire();    
    }

    return hr;    

Exit:
    DeleteNameSpace(szDstRelNameSpace, szDstRootNameSpace, pWbemLocator);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refgp\refgp.h ===
////////////////////////////////////////////////////////////////
//
// Refgp.h
//
// Refresh Group Policy exe
//
//
////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#define SECURITY_WIN32
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlwapi.h>
#include "userenv.h"
#include "userenvp.h"
#include <strsafe.h>
                                                   
#define    IDS_USAGE_FIRST                      101

#define    IDS_USAGE1                           101
#define    IDS_USAGE2                           102
#define    IDS_USAGE3                           103
#define    IDS_USAGE4                           104
#define    IDS_USAGE5                           105
#define    IDS_USAGE6                           106
#define    IDS_USAGE7                           107
#define    IDS_USAGE8                           108
#define    IDS_USAGE9                           109
#define    IDS_USAGE10                          110
#define    IDS_USAGE11                          111
#define    IDS_USAGE12                          112
#define    IDS_USAGE13                          113
#define    IDS_USAGE14                          114
#define    IDS_USAGE15                          115
#define    IDS_USAGE16                          116
#define    IDS_USAGE17                          117
#define    IDS_USAGE18                          118
#define    IDS_USAGE19                          119
#define    IDS_USAGE20                          120
#define    IDS_USAGE21                          121
#define    IDS_USAGE22                          122
#define    IDS_USAGE23                          123
#define    IDS_USAGE24                          124
#define    IDS_USAGE25                          125
#define    IDS_USAGE26                          126
#define    IDS_USAGE27                          127
#define    IDS_USAGE28                          128
#define    IDS_USAGE29                          129
#define    IDS_USAGE30                          130
#define    IDS_USAGE31                          131
#define    IDS_USAGE32                          132
#define    IDS_USAGE33                          133
#define    IDS_USAGE34                          134
#define    IDS_USAGE35                          135
#define    IDS_USAGE36                          136
#define    IDS_USAGE37                          137
#define    IDS_USAGE38                          138
#define    IDS_USAGE39                          139
#define    IDS_USAGE40                          140
#define    IDS_USAGE41                          141
#define    IDS_USAGE42                          142
#define    IDS_USAGE43                          143
#define    IDS_USAGE44                          144
#define    IDS_USAGE45                          145
#define    IDS_USAGE46                          146

#define    IDS_USAGE_LAST                       146



#define    IDS_REFRESH_LAUNCHED                 201
#define    IDS_REFRESH_FAILED_USER              202
#define    IDS_POLWAIT_FAILED_USER              203
#define    IDS_POLWAIT_TIMEDOUT_USER            204
#define    IDS_REFRESH_BACKGND_SUCCESS_USER     205
#define    IDS_NEED_LOGOFF                      206
#define    IDS_NEED_REBOOT                      207
#define    IDS_PROMPT_REBOOT                    208
#define    IDS_PROMPT_LOGOFF                    209
#define    IDS_YES                              210
#define    IDS_NO                               211
#define    IDS_REFRESH_POLICY_FAILED            212
#define    IDS_COULDNT_REBOOT                   213
#define    IDS_COULDNT_LOGOFF                   214
#define    IDS_NOTIFY_MACHINE_FG                215
#define    IDS_NOTIFY_USER_FG                   216
#define    IDS_REBOOTING                        217
#define    IDS_LOGGING_OFF                      218
#define    IDS_OUT_OF_MEMORY                    219
#define    IDS_REFRESH_BACKGND_TRIGGERED_USER   220
#define    IDS_SPACE                            221
#define    IDS_SET_MODE_FAILED                  222
#define    IDS_NEED_LOGOFF_SYNC                 223
#define    IDS_NEED_REBOOT_SYNC                 224
#define    IDS_LOOK_EVENT_LOG                   225

                                                
#define    IDS_TARGET                           301
#define    IDS_USER                             302
#define    IDS_MACHINE                          303
#define    IDS_BOTH                             304
#define    IDS_TIME                             305
#define    IDS_FORCE                            306
#define    IDS_LOGOFF                           307
#define    IDS_BOOT                             308
#define    IDS_SYNC                             309


#define    IDS_REFRESH_FAILED_COMPUTER            310
#define    IDS_POLWAIT_FAILED_COMPUTER            311
#define    IDS_POLWAIT_TIMEDOUT_COMPUTER          312
#define    IDS_REFRESH_BACKGND_SUCCESS_COMPUTER   313
#define    IDS_REFRESH_BACKGND_TRIGGERED_COMPUTER 314

#include <stdio.h>
#include <locale.h>
#include <winnlsp.h>

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);

#define COMPUTER_TARGET 0
#define USER_TARGET     1

#define REFRESH_ID(x,y) (REFRESH_STATUS_IDS[x][y])

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refreshevent\test\oahelp.inl ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  OAHELP.INL
//
// Description:
//        OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\gpfilter.h ===
//***********************************************

//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  GPO WQL filter class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include <initguid.h>


typedef struct _GPFILTER {
    WCHAR *             pwszId;  // Gpo filter id
    struct _GPFILTER *  pNext;   // Singly linked list pointer
} GPFILTER;



class CGpoFilter
{

public:
    CGpoFilter() : m_pFilterList(0) {}
    ~CGpoFilter();

    HRESULT Add( VARIANT *pVar );
    BOOL FilterCheck( WCHAR *pwszId );

private:

    void Insert( GPFILTER *pGpFilter );
    GPFILTER * AllocGpFilter( WCHAR *pwszId );
    void FreeGpFilter( GPFILTER *pGpFilter );

    GPFILTER *   m_pFilterList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\gpfilter.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  GPO WQL filter class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "windows.h"
#include "ole2.h"
#include "gpfilter.h"
#include "rsopdbg.h"
#include <strsafe.h>

CDebug dbgFilt(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"UserEnvDebugLevel",
                 L"userenv.log",
                 L"userenv.bak",
                 FALSE );

//*************************************************************
//
//  CGpoFilter::~CGpoFilter
//
//  Purpose:    Destructor
//
//*************************************************************

CGpoFilter::~CGpoFilter()
{
    GPFILTER *pFilterTemp;

    while ( m_pFilterList ) {
        pFilterTemp = m_pFilterList->pNext;
        FreeGpFilter( m_pFilterList );
        m_pFilterList = pFilterTemp;
    }
}



//*************************************************************
//
//  CGpoFilter::Add
//
//  Purpose:    Adds the list of planning mode filters
//              whose filter access check succeeds
//
//  Parameters: pVar - Pointer to variant of safearray of filters
//
//*************************************************************

HRESULT CGpoFilter::Add( VARIANT *pVar )
{
    if ( pVar->vt == VT_NULL || pVar->vt == VT_EMPTY )
        return S_OK;

    UINT ul = SafeArrayGetDim( pVar->parray );

    //
    // Null filter can be specified
    //

    if ( ul == 0 )
        return S_OK;

    if ( ul != 1 ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: Dimension of input safearray is not 1"),
                  GetLastError());
        return E_FAIL;
    }

    if ( pVar->vt != (VT_ARRAY | VT_BSTR ) ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: Variant type 0x%x is unexpected"), pVar->vt );
        return E_FAIL;
    }

    long lLower, lUpper;

    HRESULT hr = SafeArrayGetLBound( pVar->parray, 1, &lLower );
    if ( FAILED(hr)) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetLBound failed with 0x%x"), hr );
        return E_FAIL;
    }

    hr = SafeArrayGetUBound( pVar->parray, 1, &lUpper );
    if ( FAILED(hr)) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetUBound failed with 0x%x"), hr );
        return E_FAIL;
    }

    for ( long i=lLower; i<(lUpper+1); i++ ) {

        BSTR bstrId = NULL;
        hr = SafeArrayGetElement( pVar->parray, &i, &bstrId );

        if ( FAILED(hr)) {
            dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetElement failed with 0x%x"), hr );
            return E_FAIL;
        }

        dbgFilt.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CGpoFilter::Add: Filter %d. <%s>"), i, bstrId );

        GPFILTER *pGpFilter = AllocGpFilter( (WCHAR *) bstrId );
        if ( pGpFilter == NULL )
            return E_OUTOFMEMORY;

        //
        // Insert does not fail, because it's an insertion into a linked list
        //

        Insert( pGpFilter );
    }

    return S_OK;
}



//*************************************************************
//
//  CGpoFilter::Insert
//
//  Purpose:    Insert filter into sorted list in ascending order
//
//  Parameters: pGpFilter - Filter to insert
//
//*************************************************************

void CGpoFilter::Insert( GPFILTER *pGpFilter )
{
    GPFILTER *pCurPtr = m_pFilterList;
    GPFILTER *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                      pGpFilter->pwszId, -1, pCurPtr->pwszId, -1 );

        if ( iResult == CSTR_EQUAL ) {

            //
            // Duplicate, so do nothing
            //

            return;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since filters are in ascending order, this means
            // filter is not in list, so add.
            //

            pGpFilter->pNext = pCurPtr;
            if ( pTrailPtr == NULL )
                m_pFilterList = pGpFilter;
            else
                pTrailPtr->pNext = pGpFilter;

            return;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }
    }   // while

    //
    // Null list or end of list case
    //

    pGpFilter->pNext = pCurPtr;

    if ( pTrailPtr == NULL )
        m_pFilterList = pGpFilter;
    else
        pTrailPtr->pNext = pGpFilter;

    return;
}


//*************************************************************
//
//  CGpoFilter::FilterCheck
//
//  Purpose:    Checks if a filter passes the query check
//
//  Parameters: pwszId - Filter id to check
//
//*************************************************************

BOOL CGpoFilter::FilterCheck( WCHAR *pwszId )
{
    GPFILTER *pCurPtr = m_pFilterList;

    while ( pCurPtr ) {

        INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                      pwszId, -1, pCurPtr->pwszId, -1 );
        if ( iResult == CSTR_EQUAL ) {

           return TRUE;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since ids are in ascending order,
            // we are done.
            //

            return FALSE;

        } else {

            //
            // Advance down the list
            //

            pCurPtr = pCurPtr->pNext;

        } // final else

    }   // while pcurptr

    return FALSE;
}


//*************************************************************
//
//  CGpoFilter::AllocGpFilter
//
//  Purpose:    Allocs and returns a GPFILTER struct
//
//  Parameters: pwszId  - Id of filter
//
//*************************************************************

GPFILTER * CGpoFilter::AllocGpFilter( WCHAR *pwszId )
{
    GPFILTER *pGpFilter = (GPFILTER *) LocalAlloc( LPTR, sizeof(GPFILTER) );

    if ( pGpFilter == NULL ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::AllocGpFilter failed to allocate memory") );
        return NULL;
    }

    DWORD dwLength = lstrlen(pwszId) + 1;
    pGpFilter->pwszId = (LPWSTR) LocalAlloc( LPTR, ( dwLength ) * sizeof(WCHAR) );
    if ( pGpFilter->pwszId == NULL ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::AllocGpFilter failed to allocate memory") );
        LocalFree( pGpFilter );
        return NULL;
    }

    HRESULT hr = StringCchCopy( pGpFilter->pwszId, dwLength, pwszId );

    if(FAILED(hr))
    {
        LocalFree( pGpFilter->pwszId );
        LocalFree( pGpFilter );
        return NULL;
    }

    return pGpFilter;
}



//*************************************************************
//
//  FreeGpFilter()
//
//  Purpose:    Frees GPFILTER struct
//
//  Parameters: pGpFilter - GPFILTER to free
//
//*************************************************************

void CGpoFilter::FreeGpFilter( GPFILTER *pGpFilter )
{
    if ( pGpFilter ) {
        LocalFree( pGpFilter->pwszId );
        LocalFree( pGpFilter );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\indicate.cpp ===
//*************************************************************
//
//  Resultant set of policy, Progressor Indicator class
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   NishadM    Created
//
//*************************************************************

#include "Indicate.h"

//*************************************************************
//
//  CProgressIndicator::CProgressIndicator(()
//
//  Purpose:    Constructor
//
//  Parameters:
//              pObjectSink         - response handler
//              pOutParams          - out parameters
//              bstrNumer           - numerator string
//              bstrDenom           - denominator string
//              ulNumer             - numerator
//              ulDenom             - denominator
//              fIntermediateStatus - intermediate status reqd.
//                  
//
//*************************************************************
CProgressIndicator::CProgressIndicator( IWbemObjectSink* pObjectSink,
                                        bool fIntermediateStatus,
                                        unsigned long ulNumer,
                                        unsigned long ulDenom ) :
                                        m_ulNumerator( ulNumer ),
                                        m_ulDenominator( ulDenom ),
                                        m_xObjectSink( pObjectSink ),
                                        m_fIntermediateStatus( fIntermediateStatus ),
                                        m_fIsValid( pObjectSink != 0 )
{
}

//*************************************************************
//
//  CProgressIndicator::~CProgressIndicator(()
//
//  Purpose:    Destructor
//
//
//*************************************************************
CProgressIndicator::~CProgressIndicator()
{
    m_xObjectSink.Acquire();
}

//*************************************************************
//
//  CProgressIndicator::IncrementBy(()
//
//  Purpose:    Increments the progress by x%
//
//  Parameters:
//              ulPercent - percent to increment by
//                  
//
//*************************************************************
HRESULT
CProgressIndicator::IncrementBy( unsigned long ulPercent )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }
    
    //
    // numerator cannot be greater than denominator
    //
    m_ulNumerator += ulPercent;
    if ( m_ulNumerator > m_ulDenominator )
    {
        m_ulNumerator = m_ulDenominator;
    }

    if ( m_fIntermediateStatus )
    {
        return m_xObjectSink->SetStatus(WBEM_STATUS_PROGRESS, MAKELONG( m_ulNumerator, m_ulDenominator ), 0, 0 );
    }

    return S_OK;
}

//*************************************************************
//
//  CProgressIndicator::SetComplete()
//
//  Purpose:    Increments progress to 100% and forces Indicate
//
//
//*************************************************************
HRESULT
CProgressIndicator::SetComplete()
{
    return IncrementBy( MaxProgress() - CurrentProgress() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\indicate.h ===
//***********************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   NishadM    Created
//
//*************************************************************

#ifndef _INDICATE_H_
#define _INDICATE_H_

#include <wbemcli.h>
#include "smartptr.h"

class CProgressIndicator
{
    public:
    CProgressIndicator( IWbemObjectSink*    pObjectSink,        // response handler
                        bool                fIntermediateStatus = FALSE, // need intermediate status
                        unsigned long       ulNumer = 0,
                        unsigned long       ulDenom = 100
                         );
    ~CProgressIndicator();

    HRESULT
    IncrementBy( unsigned long ulPercent );

    HRESULT
    SetComplete();

    unsigned long
    CurrentProgress() { return m_ulNumerator; };

    unsigned long
    MaxProgress() { return m_ulDenominator; };

    inline bool
    IsValid() { return m_fIsValid; };

    private:
    unsigned long       m_ulNumerator;
    unsigned long       m_ulDenominator;

    XInterface<IWbemObjectSink>     m_xObjectSink;

    bool                m_fIsValid;
    bool                m_fIntermediateStatus;
};

#endif // _INDICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsopinc.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopInc.h
//
// Description: Headers for utility functions
//
// History:     8-26-99   NishadM    Created
//
//*************************************************************

#ifndef __RSOPINC_H__
#define __RSOPINC_H__

//****************************************************
// Definitions used in constructing the name spaces.
//
// PM Stands for Planning Mode Provider
// SM stands for Snapshot Mode Provider
//
// DIAG for diagnostic logging
//****************************************************

#define RSOP_MOF_SCHEMA_VERSION         0x00220003

#define RSOP_NS_ROOT                    L"\\\\.\\Root\\Rsop"
#define RSOP_NS_PM_ROOT                 RSOP_NS_ROOT
#define RSOP_NS_SM_ROOT                 RSOP_NS_ROOT
#define RSOP_NS_DIAG_ROOT               RSOP_NS_ROOT
#define RSOP_NS_ROOT_LEN                20

// Garbage collectable name spaces
#define RSOP_NS_TEMP_PREFIX             L"NS"
#define RSOP_NS_TEMP_FMT                L"\\\\.\\Root\\Rsop\\"RSOP_NS_TEMP_PREFIX L"%s"

#define RSOP_NS_TEMP_LEN                100

#define RSOP_NS_PM_FMT                  RSOP_NS_TEMP_FMT
#define RSOP_NS_SM_FMT                  RSOP_NS_TEMP_FMT

// user offsets
#define RSOP_NS_USER_OFFSET             L"User"
#define RSOP_NS_PM_USER_OFFSET          RSOP_NS_USER_OFFSET
#define RSOP_NS_SM_USER_OFFSET          RSOP_NS_USER_OFFSET
#define RSOP_NS_DIAG_ROOTUSER_OFFSET    RSOP_NS_USER_OFFSET

// The code assumes that this is a Sid when the name is generated and
// and when users are enumerated in snapshot provider.

#define RSOP_NS_DIAG_USER_OFFSET_FMT    L"User\\%s"

// machine offsets
#define RSOP_NS_MACHINE_OFFSET          L"Computer"
#define RSOP_NS_PM_MACHINE_OFFSET       RSOP_NS_MACHINE_OFFSET
#define RSOP_NS_SM_MACHINE_OFFSET       RSOP_NS_MACHINE_OFFSET
#define RSOP_NS_DIAG_MACHINE_OFFSET     RSOP_NS_MACHINE_OFFSET

#define RSOP_NS_MAX_OFFSET_LEN          20

// user
#define RSOP_NS_USER                    L"\\\\.\\Root\\Rsop\\User"
#define RSOP_NS_SM_USER                 RSOP_NS_USER
#define RSOP_NS_PM_USER                 RSOP_NS_USER
#define RSOP_NS_DIAG_USERROOT           RSOP_NS_USER

#define RSOP_NS_DIAG_USER_FMT           L"\\\\.\\Root\\Rsop\\User\\%s"

// machine
#define RSOP_NS_MACHINE                 L"\\\\.\\Root\\Rsop\\Computer"
#define RSOP_NS_SM_MACHINE              RSOP_NS_MACHINE
#define RSOP_NS_PM_MACHINE              RSOP_NS_MACHINE
#define RSOP_NS_DIAG_MACHINE            RSOP_NS_MACHINE

// remote name spaces
#define RSOP_NS_REMOTE_ROOT_FMT         L"\\\\%s\\Root\\Rsop"
#define RSOP_NS_SM_REMOTE_ROOT_FMT      RSOP_NS_REMOTE_ROOT_FMT
#define RSOP_NS_PM_REMOTE_ROOT_FMT      RSOP_NS_REMOTE_ROOT_FMT

// user
#define RSOP_NS_REMOTE_USER_FMT             L"\\\\%s\\Root\\Rsop\\User"
#define RSOP_NS_SM_REMOTE_USER_FMT          RSOP_NS_REMOTE_USER_FMT
#define RSOP_NS_PM_REMOTE_USER_FMT          RSOP_NS_REMOTE_USER_FMT
#define RSOP_NS_DIAG_REMOTE_USERROOT_FMT    RSOP_NS_REMOTE_USER_FMT

#define RSOP_NS_DIAG_REMOTE_USER_FMT        L"\\\\%s\\Root\\Rsop\\User\\%s"

// machine
#define RSOP_NS_REMOTE_MACHINE_FMT      L"\\\\%s\\Root\\Rsop\\Computer"
#define RSOP_NS_SM_REMOTE_MACHINE_FMT   RSOP_NS_REMOTE_MACHINE_FMT
#define RSOP_NS_PM_REMOTE_MACHINE_FMT   RSOP_NS_REMOTE_MACHINE_FMT

// check to make sure that the namespace is under root\rsop                                                        
#define RSOP_NS_ROOT_CHK                L"root\\rsop\\"   
             
#define RSOP_ALL_PERMS              (WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                                    WBEM_WRITE_PROVIDER | WBEM_REMOTE_ACCESS | READ_CONTROL |  WRITE_DAC) 

#define RSOP_READ_PERMS             (WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_REMOTE_ACCESS | READ_CONTROL )

// WMI bits passed as generic mask into AccessCheck

#define WMI_GENERIC_READ    1
#define WMI_GENERIC_WRITE   0x1C
#define WMI_GENERIC_EXECUTE 0x2
#define WMI_GENERIC_ALL     0x6001f


#ifdef  __cplusplus
extern "C" {
#endif

#define DEFAULT_NAMESPACE_TTL_MINUTES 1440 

HRESULT
CopyNameSpace(  LPCWSTR         wszSrc,
                LPCWSTR         wszDest,
                BOOL            bCopyInstances,
                BOOL*           pbAbort,
                IWbemLocator*   pWbemLocator );



/*
HRESULT
SetupNewNameSpacePlanningMode(  LPWSTR              *pwszNameSpace,
                                LPWSTR               szRemoteComputer,
                                IWbemLocator        *pWbemLocator,
                                PSECURITY_DESCRIPTOR pSDUser,
                                PSECURITY_DESCRIPTOR pSDMach );

HRESULT
SetupNewNameSpaceDiagMode(  LPWSTR              *pwszNameSpace,
                            LPWSTR               szRemoteComputer,
                            LPWSTR               szUserSid,
                            IWbemLocator        *pWbemLocator);
*/
  
// SetupNewNameSpace flags 
#define SETUP_NS_PM             0x1
#define SETUP_NS_SM             0x2
#define SETUP_NS_SM_NO_USER     0x4
#define SETUP_NS_SM_NO_COMPUTER 0x8
#define SETUP_NS_SM_INTERACTIVE 0x10


HRESULT
SetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR pSD,
                        IWbemLocator* pWbemLocator);


HRESULT
GetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR *ppSD,
                        IWbemLocator* pWbemLocator);
        
HRESULT 
SetupNewNameSpace(
                        LPWSTR              *pwszNameSpace,
                        LPWSTR               szRemoteComputer,
                        LPWSTR               szUserSid,
                        PSID                 pSid,
                        IWbemLocator        *pWbemLocator,
                        DWORD                dwFlags,
                        DWORD               *pdwExtendedInfo);
                        
HRESULT 
ProviderDeleteRsopNameSpace( IWbemLocator *pWbemLocator, 
                             LPWSTR szNameSpace, 
                             HANDLE hToken, 
                             LPWSTR szSidString, 
                             DWORD dwFlags);


BOOL IsInteractiveNameSpace(WCHAR *pwszNameSpace, WCHAR *szSid);
HRESULT GetInteractiveNameSpace(WCHAR *szSid, LPWSTR *szNameSpace);


// copy flags
#define NEW_NS_FLAGS_COPY_CLASSES     1                // Copy Instances
#define NEW_NS_FLAGS_COPY_SD          2                // Copy Security Descriptor
#define NEW_NS_FLAGS_COPY_INSTS       4                // Copy Classes

HRESULT
CreateAndCopyNameSpace( IWbemLocator *pWbemLocator,
                        LPWSTR szSrcNameSpace,
                        LPWSTR szDstRootNameSpace,
                        LPWSTR szDstRelNameSpace, 
                        DWORD dwFlags,
                        PSECURITY_DESCRIPTOR pSecDesc,
                        LPWSTR *szDstNameSpaceOut);

// WMI doesn't like '-' in names. so to create an entry in WMI space
// using Sid use these 2 utility functions.

void ConvertSidToWMIName(LPTSTR lpSid, LPTSTR lpWmiName);
void ConvertWMINameToSid(LPTSTR lpWmiName, LPTSTR lpSid);

HRESULT
DeleteNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNameSpace, IWbemLocator *pWbemLocator );
HRESULT
DeleteRsopNameSpace( WCHAR *pwszNameSpace, IWbemLocator *pWbemLocator );

HRESULT
GetWbemServicesPtr( LPCWSTR         wszNameSpace,
                    IWbemLocator**  ppLocator,
                    IWbemServices** ppServices );


/*
typedef struct __tagPrincipal
{
    LPWSTR  szName; // e.g. Administrators, "Domain Admins"
    bool    bLocal; // e.g. true, false
} Principal;
*/

#ifdef  __cplusplus
}   // extern "C" {
#endif

#ifdef  __cplusplus
  
class CFailRetStatus
{

private:
        IWbemObjectSink*    m_pResponseHandler;  // We don't own m_pResponseHandler
        HRESULT             m_hr;

public:
        CFailRetStatus( IWbemObjectSink* pResponseHandler )
           : m_pResponseHandler(pResponseHandler),
           m_hr( 0 )
        {
        }

        ~CFailRetStatus()
        {
            if ( m_pResponseHandler )
                m_pResponseHandler->SetStatus( WBEM_STATUS_COMPLETE, m_hr, NULL, NULL );
        }

        void SetError( HRESULT hr )
        {
            m_hr = hr;
        }

};

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif


#endif

#endif // __RSOPINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsopsec.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:     RsopSec.cpp
//
// Description:  RSOP Namespace Security functions
//
// History:      8-26-99   leonardm    Created
//
//******************************************************************************

#include <windows.h>
#include <objbase.h>
#include <wbemcli.h>
#include <accctrl.h>
#include <aclapi.h>
#include <lm.h>
#include "RsopUtil.h"
#include "RsopSec.h"
#include "rsopdbg.h"
#include "smartptr.h"


//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP GetExplicitAccesses(   long lSecurityLevel,
                                    EXPLICIT_ACCESS** ppExplicitAccess,
                                    DWORD* pdwCount,
                                    CWString* psTrustees)
{

    WKSTA_INFO_100* pWkstaInfo = NULL;
    NET_API_STATUS status = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pWkstaInfo);
    if(status != NERR_Success)
    {
        return E_FAIL;
    }

    CWString sCurrentDomain = pWkstaInfo->wki100_langroup;
    NetApiBufferFree(pWkstaInfo);

    if(!sCurrentDomain.ValidString() || sCurrentDomain == L"")
    {
        return E_FAIL;
    }


    static ACCESS_MODE AccessMode = GRANT_ACCESS;
    static DWORD Inheritance = SUB_CONTAINERS_ONLY_INHERIT;
    static DWORD AccessPermissions =    WBEM_ENABLE |
                                        WBEM_METHOD_EXECUTE |
                                        WBEM_FULL_WRITE_REP |
                                        WBEM_PARTIAL_WRITE_REP |
                                        WBEM_WRITE_PROVIDER |
                                        WBEM_REMOTE_ACCESS |
                                        READ_CONTROL |
                                        WRITE_DAC;

    XPtrArray<EXPLICIT_ACCESS> xpExplicitAccess = NULL;

    if(lSecurityLevel == NAMESPACE_SECURITY_DIAGNOSTIC)
    {
        if(*pdwCount < 1)
        {
            *pdwCount = 1;
            return E_FAIL;
        }

        *pdwCount = 1;

        xpExplicitAccess = new EXPLICIT_ACCESS[*pdwCount];
        if(!xpExplicitAccess)
        {
            return E_OUTOFMEMORY;
        }

        psTrustees[0] = sCurrentDomain + L"\\Domain Users";
        if(!psTrustees[0].ValidString())
        {
            return E_OUTOFMEMORY;
        }

        BuildExplicitAccessWithName(&(xpExplicitAccess[0]),
                                    psTrustees[0],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

    }
    else if(lSecurityLevel == NAMESPACE_SECURITY_PLANNING)
    {
        if(*pdwCount < 2)
        {
            *pdwCount = 2;
            return E_FAIL;
        }

        *pdwCount = 2;

        xpExplicitAccess = new EXPLICIT_ACCESS[*pdwCount];

        if(!xpExplicitAccess)
        {
            return E_OUTOFMEMORY;
        }
        psTrustees[0] = sCurrentDomain + L"\\RSOP Admins";
        if(!psTrustees[0].ValidString())
        {
            return E_OUTOFMEMORY;
        }
        BuildExplicitAccessWithName(&(xpExplicitAccess[0]),
                                    psTrustees[0],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

        psTrustees[1] = sCurrentDomain + L"\\Domain Admins";
        if(!psTrustees[1].ValidString())
        {
            return E_OUTOFMEMORY;
        }
        BuildExplicitAccessWithName(&(xpExplicitAccess[1]),
                                    psTrustees[1],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

    }
    else
    {
        return E_INVALIDARG;
    }

    *ppExplicitAccess = xpExplicitAccess.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD)
{
    BOOL bRes = IsValidSecurityDescriptor(pSelfRelativeSD);
    if(!bRes)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    XPtrLF<SECURITY_DESCRIPTOR> xpAbsoluteSD;
    XPtrLF<ACL> xpDacl;
    XPtrLF<ACL> xpSacl;
    XPtrLF<SID> xpOwner;
    XPtrLF<SID> xpPrimaryGroup;


    DWORD dwAbsoluteSecurityDescriptorSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwPrimaryGroupSize = 0;

    bRes = ::MakeAbsoluteSD(
                            pSelfRelativeSD,
                            xpAbsoluteSD,
                            &dwAbsoluteSecurityDescriptorSize,
                            xpDacl,           // discretionary ACL
                            &dwDaclSize,     // size of discretionary ACL
                            xpSacl,           // system ACL
                            &dwSaclSize,     // size of system ACL
                            xpOwner,          // owner SID
                            &dwOwnerSize,    // size of owner SID
                            xpPrimaryGroup,       // primary-group SID
                            &dwPrimaryGroupSize  // size of group SID
                            );

    DWORD dwLastError = GetLastError();
    if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }

    if(!dwAbsoluteSecurityDescriptorSize)
    {
        return E_FAIL;
    }

    xpAbsoluteSD = reinterpret_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwAbsoluteSecurityDescriptorSize));
    if(!xpAbsoluteSD)
    {
        return E_OUTOFMEMORY;
    }

    if(dwDaclSize)
    {
        xpDacl = reinterpret_cast<ACL*>(LocalAlloc(LPTR, dwDaclSize));
        if(!xpDacl)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwSaclSize)
    {
        xpSacl = reinterpret_cast<ACL*>(LocalAlloc(LPTR, dwSaclSize));
        if(!xpSacl)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwOwnerSize)
    {
        xpOwner = reinterpret_cast<SID*>(LocalAlloc(LPTR, dwOwnerSize));
        if(!xpOwner)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwPrimaryGroupSize)
    {
        xpPrimaryGroup = reinterpret_cast<SID*>(LocalAlloc(LPTR, dwPrimaryGroupSize));
        if(!xpPrimaryGroup)
        {
            return E_OUTOFMEMORY;
        }
    }

    bRes = ::MakeAbsoluteSD(
                        pSelfRelativeSD,
                        xpAbsoluteSD,
                        &dwAbsoluteSecurityDescriptorSize,
                        xpDacl,           // discretionary ACL
                        &dwDaclSize,     // size of discretionary ACL
                        xpSacl,           // system ACL
                        &dwSaclSize,     // size of system ACL
                        xpOwner,          // owner SID
                        &dwOwnerSize,    // size of owner SID
                        xpPrimaryGroup,       // primary-group SID
                        &dwPrimaryGroupSize  // size of group SID
                        );

    if(!bRes)
    {
        return E_FAIL;
    }

    bRes = IsValidSecurityDescriptor(xpAbsoluteSD);

    if(!bRes)
    {
        return E_FAIL;
    }

    xpDacl.Acquire();
    xpSacl.Acquire();
    xpOwner.Acquire();
    xpPrimaryGroup.Acquire();

    *ppAbsoluteSD = xpAbsoluteSD.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD)
{
    if(!pAbsoluteSD)
    {
        return E_POINTER;
    }

    BOOL bRes;

    BOOL bDaclPresent;
    BOOL bDaclDefaulted;

    XPtrLF<ACL> xpDacl;
    bRes = GetSecurityDescriptorDacl(       pAbsoluteSD,
                                        &bDaclPresent,
                                        &xpDacl,
                                        &bDaclDefaulted);

    if(!bRes)
    {
        return E_FAIL;
    }

    BOOL bSaclPresent;
    BOOL bSaclDefaulted;

    XPtrLF<ACL> xpSacl;
    bRes = GetSecurityDescriptorSacl(       pAbsoluteSD,
                                        &bSaclPresent,
                                        &xpSacl,
                                        &bSaclDefaulted);

    if(!bRes)
    {
        return E_FAIL;
    }

    BOOL bOwnerDefaulted;

    XPtrLF<SID>xpOwner;
    bRes = GetSecurityDescriptorOwner(pAbsoluteSD, reinterpret_cast<void**>(&xpOwner), &bOwnerDefaulted);
    if(!bRes)
    {
        return E_FAIL;
    }


    BOOL bGroupDefaulted;

    XPtrLF<SID>xpPrimaryGroup;
    bRes = GetSecurityDescriptorGroup(pAbsoluteSD, reinterpret_cast<void**>(&xpPrimaryGroup), &bGroupDefaulted);
    if(!bRes)
    {
        return E_FAIL;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP GetNamespaceSD(IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD)
{
    if(!pWbemServices)
    {
        return E_POINTER;
    }

    HRESULT hr;

    XInterface<IWbemClassObject> xpOutParams;

    const BSTR bstrInstancePath = SysAllocString(L"__systemsecurity=@");
    if(!bstrInstancePath)
    {
        return E_OUTOFMEMORY;
    }

    const BSTR bstrMethodName = SysAllocString(L"GetSD");
    if(!bstrMethodName)
    {
        SysFreeString(bstrInstancePath);
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->ExecMethod( bstrInstancePath,
                                    bstrMethodName,
                                    0,
                                    NULL,
                                    NULL,
                                    &xpOutParams,
                                    NULL);

    SysFreeString(bstrInstancePath);
    SysFreeString(bstrMethodName);

    if(FAILED(hr))
    {
        return hr;
    }


    VARIANT v;
    XVariant xv(&v);

    VariantInit(&v);

    hr = xpOutParams->Get(L"sd", 0, &v, NULL, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    if(v.vt != (VT_ARRAY | VT_UI1))
    {
        return E_FAIL;
    }

    long lLowerBound;
    hr = SafeArrayGetLBound(v.parray, 1, &lLowerBound);
    if(FAILED(hr))
    {
        return hr;
    }

    long lUpperBound;
    hr = SafeArrayGetUBound(v.parray, 1, &lUpperBound);
    if(FAILED(hr))
    {
        return hr;
    }

    DWORD dwSize = static_cast<DWORD>(lUpperBound - lLowerBound + 1);

    XPtrLF<SECURITY_DESCRIPTOR> xpSelfRelativeSD = static_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwSize));
    if(!xpSelfRelativeSD)
    {
        return E_OUTOFMEMORY;
    }

    BYTE* pSrc;
    hr = SafeArrayAccessData(v.parray, reinterpret_cast<void**>(&pSrc));
    if(FAILED(hr))
    {
        return hr;
    }

    CopyMemory(xpSelfRelativeSD, pSrc, dwSize);

    hr = SafeArrayUnaccessData(v.parray);
    if(FAILED(hr))
    {
        return hr;
    }

    *ppSD = xpSelfRelativeSD.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         8/20/99     leonardm    Created.
//
//******************************************************************************
STDMETHODIMP SetNamespaceSD(SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices)
{
    if(!pWbemServices)
    {
        return E_POINTER;
    }

    HRESULT hr;


    //
    // Get the class object
    //

    XInterface<IWbemClassObject> xpClass;

    BSTR bstrClassPath = SysAllocString(L"__systemsecurity");
    if(!bstrClassPath)
    {
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->GetObject(bstrClassPath, 0, NULL, &xpClass, NULL);

    SysFreeString(bstrClassPath);

    if(FAILED(hr))
    {
        return hr;
    }


    //
    // Get the input parameter class
    //

    XInterface<IWbemClassObject> xpMethod;
    hr = xpClass->GetMethod(L"SetSD", 0, &xpMethod, NULL);
    if(FAILED(hr))
    {
        return hr;
    }


    //
    // move the SD into a variant.
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;

    DWORD dwLength = GetSecurityDescriptorLength(pSD);

    rgsabound[0].cElements = dwLength;

    SAFEARRAY* psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if(!psa)
    {
        return E_FAIL;
    }

    BYTE* pDest = NULL;

    hr = SafeArrayAccessData(psa, reinterpret_cast<void**>(&pDest));
    if(FAILED(hr))
    {
        return hr;
    }

    CopyMemory(pDest, pSD, dwLength);

    hr = SafeArrayUnaccessData(psa);
    if(FAILED(hr))
    {
        return hr;
    }

    VARIANT v;
    XVariant xv(&v);
    v.vt = VT_UI1|VT_ARRAY;
    v.parray = psa;


    //
    // put the property
    //

    XInterface<IWbemClassObject> xpInParam;
    hr = xpMethod->SpawnInstance(0, &xpInParam);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = xpInParam->Put(L"sd" , 0, &v, 0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Execute the method
    //

    BSTR bstrInstancePath = SysAllocString(L"__systemsecurity=@");
    if(!bstrInstancePath)
    {
        return E_OUTOFMEMORY;
    }


    BSTR bstrMethodName = SysAllocString(L"SetSD");
    if(!bstrMethodName)
    {
        SysFreeString(bstrInstancePath);
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->ExecMethod( bstrInstancePath,
                                    bstrMethodName,
                                    0,
                                    NULL,
                                    xpInParam,
                                    NULL,
                                    NULL);

    SysFreeString(bstrInstancePath);
    SysFreeString(bstrMethodName);

    return hr;
}


#undef dbg
#define dbg dbgCommon


const DWORD DEFAULT_ACE_NUM=10;

CSecDesc::CSecDesc() : 
                          m_cAces(0), m_xpSidList(NULL), 
                          m_cAllocated(0), m_bInitialised(FALSE), m_bFailed(FALSE)
{
    m_xpSidList = (SidStruct *)LocalAlloc(LPTR, sizeof(SidStruct)*DEFAULT_ACE_NUM);
    if (!m_xpSidList)
        return;

    m_cAllocated = DEFAULT_ACE_NUM;
    m_bInitialised = TRUE;
}


CSecDesc::~CSecDesc()
{
    if (m_xpSidList) 
        for (DWORD i = 0; i < m_cAllocated; i++) 
            if (m_xpSidList[i].pSid) 
                if (m_xpSidList[i].bUseLocalFree)
                    LocalFree(m_xpSidList[i].pSid);
                else
                    FreeSid(m_xpSidList[i].pSid);
}


BOOL CSecDesc::ReAllocSidList()
{
    XPtrLF<SidStruct>  xSidListNew;


    //
    // first allocate a larger buffer
    //

    xSidListNew = (SidStruct *)LocalAlloc(LPTR, sizeof(SidStruct)*(m_cAllocated+DEFAULT_ACE_NUM));

    if (!xSidListNew) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::ReallocArgStrings  Cannot add memory, error = %d", GetLastError());
        m_bFailed = TRUE;
        return FALSE;
    }


    //
    // copy the arguments
    //

    for (DWORD i = 0; i < (m_cAllocated); i++) {
        xSidListNew[i] = m_xpSidList[i];
    }

    m_xpSidList = xSidListNew.Acquire();
    m_cAllocated+= DEFAULT_ACE_NUM;

    return TRUE;
}



BOOL CSecDesc::AddLocalSystem(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddLocalSystem: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddLocalSystem: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddAdministrators(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddNetworkService(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddNetworkService: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_NETWORK_SERVICE_RID,
                                 0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddNetworkService: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}



BOOL CSecDesc::AddAdministratorsAsOwner()
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    m_xpOwnerSid = xSid.Acquire();

    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddAdministratorsAsGroup()
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    m_xpGrpSid = xSid.Acquire();

    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddEveryOne(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddEveryOne: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddEveryOne: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


#if 0

BOOL CSecDesc::AddThisUser(HANDLE hToken, DWORD dwAccess, DWORD AceFlags)
{
    XPtrLF<SID>             xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddThisUser: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;
    
    xSid = (SID *)GetUserSid(hToken);        

    if (!pSid) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddThisUser: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }
    
    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;

    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].bUseLocalFree = TRUE;    
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}
#endif



BOOL CSecDesc::AddUsers(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;


    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {

         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddUsers: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddAuthUsers(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAuthUsers: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;


    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                   0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {

         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAuthUsers: Failed to initialize authenticated users sid.  Error = %d", GetLastError());
         return FALSE;
     }
     

    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddSid(PSID pSid, DWORD dwAccess, DWORD AceFlags)
{
    XPtrLF<SID>    pLocalSid = 0;
    DWORD          dwSidLen = 0;
    
    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!IsValidSid(pSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Not a vaild Sid.");
         return FALSE;
    }


    dwSidLen = GetLengthSid(pSid);

    pLocalSid = (SID *)LocalAlloc(LPTR, dwSidLen);
    if (!pLocalSid) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Couldn't allocate memory. Error %d", GetLastError());
         return FALSE;
    }

    
    if (!CopySid(dwSidLen, pLocalSid, pSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Couldn't copy Sid. Error %d", GetLastError());
         return FALSE;
    }
    
    
    m_xpSidList[m_cAces].pSid = (SID *)pLocalSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].bUseLocalFree = TRUE;    
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


PISECURITY_DESCRIPTOR CSecDesc::MakeSD()
{
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    PACL    pAcl = 0;
    DWORD   cbMemSize;
    DWORD   cbAcl;
    DWORD   i;    
    
    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeSD: Not initialised or failure.");
         return NULL;
    }
    
    m_bFailed = TRUE;

    cbAcl = 0;

    for (i = 0; i < m_cAces; i++) 
        cbAcl+= GetLengthSid((SID *)(m_xpSidList[i].pSid));

    cbAcl += sizeof(ACL) + m_cAces*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
    

    //
    // Allocate space for the SECURITY_DESCRIPTOR + ACL
    //

    cbMemSize = sizeof( SECURITY_DESCRIPTOR ) + cbAcl;

    xsd = (PISECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbMemSize);

    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to alocate security descriptor.  Error = %d", GetLastError());
        return NULL;
    }


    //
    // increment psd by sizeof SECURITY_DESCRIPTOR
    //

    pAcl = (PACL) ( ( (unsigned char*)((SECURITY_DESCRIPTOR *)xsd) ) + sizeof(SECURITY_DESCRIPTOR) );

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to initialize acl.  Error = %d", GetLastError());
        return NULL;
    }


    //
    // Add each of the new ACEs
    //
    
    for (i = 0; i < m_cAces; i++) {
        if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, m_xpSidList[i].AceFlags, m_xpSidList[i].dwAccess, m_xpSidList[i].pSid)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to add ace (%d).  Error = %d", i, GetLastError());
            return NULL;
        }
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(xsd, SECURITY_DESCRIPTOR_REVISION)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to initialize security descriptor.  Error = %d", GetLastError());
        return NULL;
    }

    if (!SetSecurityDescriptorDacl(xsd, TRUE, pAcl, FALSE)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
        return NULL;
    }


    if (m_xpOwnerSid) {
        if (!SetSecurityDescriptorOwner(xsd, m_xpOwnerSid, 0)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
            return NULL;
        }
    }

    if (m_xpGrpSid) {
        if (!SetSecurityDescriptorGroup(xsd, m_xpGrpSid, 0)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
            return NULL;
        }
    }



    m_bFailed = FALSE;
    return xsd.Acquire();    
}


PISECURITY_DESCRIPTOR CSecDesc::MakeSelfRelativeSD()
{
    XPtrLF<SECURITY_DESCRIPTOR> xAbsoluteSD;
    DWORD dwLastError;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    xAbsoluteSD = MakeSD();

    if (!xAbsoluteSD) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSelfRelativeSD: Failed to set security descriptor dacl.  Error = %d", GetLastError());
        return NULL;
    }

    m_bFailed = TRUE;


    //
    // Make a new self-relative SD here
    //

    DWORD dwBufferLength = 0;
    ::MakeSelfRelativeSD( xAbsoluteSD, 0, &dwBufferLength);

    dwLastError = GetLastError();
    if((dwLastError != ERROR_INSUFFICIENT_BUFFER) || !dwBufferLength)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", dwLastError );
        return NULL;
    }


    XPtrLF<SECURITY_DESCRIPTOR> xsd = reinterpret_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwBufferLength));
    if(!xsd)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", E_OUTOFMEMORY );
        return NULL;
    }

    BOOL bRes = ::MakeSelfRelativeSD( xAbsoluteSD, xsd, &dwBufferLength);

    if (!bRes) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", GetLastError() );
        return NULL;
    }

    m_bFailed = FALSE;
    return xsd.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\namespc.cpp ===
//*************************************************************
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        NameSpace.cpp
//
// Contents:    Functions to copy classes and instances from one namespace to
//              another
//
// History:     25-Aug-99       NishadM    Created
//
//*************************************************************

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <wbemcli.h>
#include "smartptr.h"
#include "RsopInc.h"
#include "rsoputil.h"
#include "rsopdbg.h"


HRESULT
GetWbemServicesPtr( LPCWSTR         wszNameSpace,
                    IWbemLocator**  ppLocator,
                    IWbemServices** ppServices )
{
    HRESULT                     hr;
    IWbemLocator*               pWbemLocator = 0;

    if ( !wszNameSpace || !ppLocator || !ppServices )
    {
        hr =  E_INVALIDARG;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetWbemServicesPtr: Invalid argument" ));
    }
    else
    {
        if ( !*ppLocator )
        {
            //
            // get a handle to IWbemLocator
            //
            hr = CoCreateInstance(  CLSID_WbemLocator,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator,
                                    (void**) &pWbemLocator );
            if ( SUCCEEDED( hr ) )
            {
                *ppLocator = pWbemLocator;
            }
            else
            {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetWbemServicesPtr: CoCreateInstance failed with 0x%x"), hr );
            }
        }
        else
        {
            //
            // IWbemLocator was passed in. don't create it
            //
            pWbemLocator = *ppLocator;
        }
    }

    if ( pWbemLocator )
    {
        XBStr xNameSpace( (LPWSTR) wszNameSpace );

        if ( xNameSpace )
        {
            //
            // based on the name space, get a handle to IWbemServices
            //
            hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              ppServices );
        }
    }

    return hr;
}

HRESULT
CopyClassInstances(  IWbemServices*  pServicesSrc,
                IWbemServices*  pServicesDest,
                BSTR            bstrClass,
                BOOL*           pbAbort )
{
    HRESULT hr;
    IEnumWbemClassObject*       pEnum = 0;

    //
    // create an enumeration of instances
    //

    hr = pServicesSrc->CreateInstanceEnum(  bstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &pEnum );

    XInterface<IEnumWbemClassObject> xEnum( pEnum );
    ULONG ulReturned = 1;

    hr = *pbAbort ? E_ABORT : hr ;

    while ( SUCCEEDED( hr ) )
    {
        IWbemClassObject *pInstance;

        //
        // for every instance
        //
        hr = xEnum->Next( -1,
                          1,
                          &pInstance,
                          &ulReturned );
        //
        // perf: use batching calls
        //

        if ( SUCCEEDED( hr ) && ulReturned == 1 )
        {
            XInterface<IWbemClassObject> xInstance( pInstance );

            //
            // copy to the destination namespace
            //
            hr = pServicesDest->PutInstance(    pInstance,
                                                WBEM_FLAG_CREATE_OR_UPDATE,
                                                0,
                                                0 );
            hr = *pbAbort ? E_ABORT : hr ;
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
CopyInstances(IWbemServices*  pServicesSrc,
            IWbemServices*  pServicesDest,
            BSTR            bstrParent,
            BOOL*           pbAbort )
{
    HRESULT hr = S_OK;
    XBStr   xbstrClass( L"__CLASS" );
    if ( !xbstrClass )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyInstances::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    //
    // create an enumeration of classes
    //

    XInterface<IEnumWbemClassObject> xEnum;
    hr = pServicesDest->CreateClassEnum( bstrParent,
                                        WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                        0,
                                        &xEnum );

    ULONG   ulReturned = 1;

    hr = *pbAbort ? E_ABORT : hr ;

    while ( SUCCEEDED( hr ) )
    {
        XInterface<IWbemClassObject> xClass;

        //
        // for every class
        //
        hr = xEnum->Next( -1,
                          1,
                          &xClass,
                          &ulReturned );

        hr = *pbAbort ? E_ABORT : hr ;
        
        if ( SUCCEEDED( hr ) && ulReturned == 1 )
        {
            VARIANT var;

            VariantInit( &var );
            
            //
            // get __CLASS system property
            //
            hr = xClass->Get(   xbstrClass,
                                0,
                                &var,
                                0,
                                0 );

            if ( SUCCEEDED( hr ) )
            {
                //
                // system classes begin with "_", don't copy them
                //
                if ( wcsncmp( var.bstrVal, L"_", 1 ) )
                {
                    //
                    // copy instances
                    //
                    hr = CopyClassInstances( pServicesSrc, pServicesDest, var.bstrVal, pbAbort );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = CopyInstances(   pServicesSrc,
                                            pServicesDest,
                                            var.bstrVal,
                                            pbAbort );
                        if ( FAILED( hr ) )
                        {
                            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyInstances: CopyInstances failed with 0x%x"), hr );
                        }
                    }
                    else
                    {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyInstances: CopyClassInstances failed with 0x%x"), hr );
                    }
                }
                
                VariantClear( &var );
            }
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
CopyClasses(IWbemServices*  pServicesSrc,
            IWbemServices*  pServicesDest,
            BSTR            bstrParent,
            BOOL*           pbAbort )
{
    HRESULT hr = S_OK;
    XBStr   xbstrClass( L"__CLASS" );
    if ( !xbstrClass )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyClasses::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    //
    // create an enumeration of classes
    //

    XInterface<IEnumWbemClassObject> xEnum;
    hr = pServicesSrc->CreateClassEnum( bstrParent,
                                        WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                        0,
                                        &xEnum );

    ULONG   ulReturned = 1;

    hr = *pbAbort ? E_ABORT : hr ;

    while ( SUCCEEDED( hr ) )
    {
        XInterface<IWbemClassObject> xClass;

        //
        // for every class
        //
        hr = xEnum->Next( -1,
                          1,
                          &xClass,
                          &ulReturned );

        hr = *pbAbort ? E_ABORT : hr ;
        
        if ( SUCCEEDED( hr ) && ulReturned == 1 )
        {
            VARIANT var;

            VariantInit( &var );
            
            //
            // get __CLASS system property
            //
            hr = xClass->Get(   xbstrClass,
                                0,
                                &var,
                                0,
                                0 );

            if ( SUCCEEDED( hr ) )
            {
                //
                // system classes begin with "_", don't copy them
                //
                if ( wcsncmp( var.bstrVal, L"_", 1 ) )
                {
                    //
                    // copy class
                    //
                    hr = pServicesDest->PutClass(   xClass,
                                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                                    0,
                                                    0 );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = CopyClasses(   pServicesSrc,
                                            pServicesDest,
                                            var.bstrVal,
                                            pbAbort );
                        if ( FAILED( hr ) )
                        {
                            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyClasses: CopyClassesSorted failed with 0x%x"), hr );
                        }
                    }
                }
                
                VariantClear( &var );
            }
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
CopyNameSpace(  LPCWSTR       wszSrc,
                LPCWSTR       wszDest,
                BOOL          bCopyInstances,
                BOOL*         pbAbort,
                IWbemLocator* pWbemLocator )
{
    //
    // parameter validation
    //

    if ( !wszSrc || !wszDest || !pbAbort )
    {
            return E_POINTER;
    }

    BOOL            bLocatorObtained = ( pWbemLocator == 0 );
    IWbemServices*  pServicesSrc;

    //
    // get a pointer to the source namespace
    //
    HRESULT hr = GetWbemServicesPtr( wszSrc, &pWbemLocator, &pServicesSrc );

    hr = *pbAbort ? E_ABORT : hr ;

    if ( SUCCEEDED( hr ) )
    {
        XInterface<IWbemServices>   xServicesSrc( pServicesSrc );
        IWbemServices*              pServicesDest;

        //
        // get a pointer to the destination namespace
        //
        hr = GetWbemServicesPtr( wszDest, &pWbemLocator, &pServicesDest );

        hr = *pbAbort ? E_ABORT : hr ;

        if ( SUCCEEDED( hr ) )
        {
            XInterface<IWbemServices> xServicesDest( pServicesDest );

            //
            // copy classes
            //
            hr = CopyClasses(   pServicesSrc,
                                pServicesDest,
                                0,
                                pbAbort );
            if ( FAILED(hr) )
            {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNamespace: CopyClasses failed with 0x%x"), hr );
            }
            else if ( bCopyInstances )
            {
                //
                // now copy instances
                //
                hr = CopyInstances( pServicesSrc,
                                    pServicesDest,
                                    0,
                                    pbAbort );
                if ( FAILED(hr) )
                {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNamespace: CopyInstances failed with 0x%x"), hr );
                }
            }
        }
    }

    //
    // if we created IWbemLocator, release it
    //
    if ( bLocatorObtained && pWbemLocator )
    {
        pWbemLocator->Release();
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsopsec.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopSec.h
//
// Description: RSOP Namespace Security functions
//
// History:     8-26-99   leonardm    Created
//
//******************************************************************************

#ifndef _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED
#define _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED

#include "smartptr.h"

#ifdef  __cplusplus
extern "C" {
#endif

HRESULT SetNamespaceSecurity(const WCHAR* pszNamespace,
                             long lSecurityLevel,
                             IWbemServices* pWbemServices=NULL);

HRESULT SetNamespaceSD( SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices);
HRESULT GetNamespaceSD( IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD);
HRESULT RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD);
HRESULT FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD);

LPWSTR GetSOM( LPCWSTR szAccount );
DWORD GetDomain( LPCWSTR szSOM, LPWSTR *pszDomain );


HRESULT AuthenticateUser(HANDLE  hToken, 
                         LPCWSTR szMachSOM, 
                         LPCWSTR szUserSOM, 
                         BOOL    bLogging,
                         DWORD  *pdwExtendedInfo);


//
// lSecurityLevels
//

const long NAMESPACE_SECURITY_DIAGNOSTIC = 0;
const long NAMESPACE_SECURITY_PLANNING = 1;

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

#ifdef  __cplusplus
}   // extern "C" {
#endif


typedef struct _SidStruct {
    PSID    pSid;
    DWORD   dwAccess;
    BOOL    bUseLocalFree;
    DWORD   AceFlags;
} SidStruct;
        

// need to add code for inheritted aces..
class CSecDesc
{
    private:
        XPtrLF<SidStruct> m_xpSidList;        
        DWORD             m_cAces;
        DWORD             m_cAllocated;
        BOOL              m_bInitialised;
        BOOL              m_bFailed;
        XPtrLF<SID>       m_xpOwnerSid;
        XPtrLF<SID>       m_xpGrpSid;

    
       // Not implemented.
       CSecDesc(const CSecDesc& x);
       CSecDesc& operator=(const CSecDesc& x);

       BOOL ReAllocSidList();
    
public:
    CSecDesc();
   ~CSecDesc();
   BOOL AddLocalSystem(DWORD dwAccess=GENERIC_ALL, DWORD AceFlags=0);
   BOOL AddAdministrators(DWORD dwAccess=GENERIC_ALL, DWORD AceFlags=0);
   BOOL AddNetworkService(DWORD dwAccess=GENERIC_ALL, DWORD AceFlags=0);
   BOOL AddEveryOne(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddAdministratorsAsOwner();
   BOOL AddAdministratorsAsGroup();

    //   BOOL AddThisUser(HANDLE hToken, DWORD dwAccess, BYTE AceFlags=0);   

    // This cannot be implemented here currently because it needs to call
    // GetUserSid which is in userenv\sid.c. To add that code we need to add the
    // common headers..

   BOOL AddUsers(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddAuthUsers(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddSid(PSID pSid, DWORD dwAccess, DWORD AceFlags=0);
   PISECURITY_DESCRIPTOR MakeSD();   
   PISECURITY_DESCRIPTOR MakeSelfRelativeSD();
};

#endif // _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rights.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <rpc.h>
#include <ntdsapi.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <wbemcli.h>

#include "smartptr.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "rsopsec.h"
#include <strsafe.h>

extern "C" {
DWORD CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
                                LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted);

}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//*************************************************************
//
//  CheckAccessForPolicyGeneration()
//
//  Purpose:    Finds out whether user has the right to generate rsop data
//
//  Parameters: hToken          -  Token of the user who is using the tool
//              szContainer     -  DS Container with which it needs to be validated
//              bLogging        -  Logging or Planning mode
//              pbAccessGranted -  Access was granted or not
//
//  Return:     ERROR_SUCCESS
//              Error Code otherwise
//
// The container passed in is actually parsed to figure out the first ou= or
// dc= supercontainer and then the rights are evaluated..
//
//*************************************************************

DWORD
CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
                                LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted)
{
    DWORD    dwError = ERROR_SUCCESS;
    XHandle  xhTokenDup;
    BOOL     bDomain = FALSE;
//    BOOLEAN  bSecurityWasEnabled;
    WCHAR   *pDomainString[1];
    PDS_NAME_RESULT pNameResult = NULL;

    *pbAccessGranted = 0;

    //
    // Parse the container first to get the OU= or DC=
    // The "Actual SOM"
    //

    while (*szContainer) {

        //
        // See if the DN name starts with OU=
        //

        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                           szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
            break;
        }

        //
        // See if the DN name starts with DC=
        //

        else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
            break;
        }


        //
        // Move to the next chunk of the DN name
        //

        while (*szContainer && (*szContainer != TEXT(','))) {
            szContainer++;
        }

        if (*szContainer == TEXT(',')) {
            szContainer++;
        }
    }

    if (!*szContainer) {
        return ERROR_INVALID_PARAMETER;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: SOM for account is %s", szContainer );

    
    //
    // See if the DN name starts with DC=
    //

    if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
        bDomain = TRUE;
    }
    
    
    //
    // preparse the name to just get the string , dc=
    //

    XPtrLF<WCHAR> xwszDomain;
    LPWSTR        szDomLocal;


    if (!szDomain) {
        dwError = GetDomain(szContainer, &xwszDomain);

        if (dwError != ERROR_SUCCESS) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: GetDomain failed with error %d", dwError );
            return dwError;
        }

        szDomLocal = xwszDomain;
    }
    else {
        szDomLocal = szDomain;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: Som resides in domain %s", szDomLocal );

    DWORD         dwDSObjLength = wcslen(L"LDAP://") + wcslen(szDomLocal) + wcslen(szContainer) + 5;
    XPtrLF<WCHAR> xszDSObject = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwDSObjLength ));

    if (!xszDSObject) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration:  AllocMem failed with %d.", GetLastError() );
        return GetLastError();
    }

    HRESULT hr = StringCchCopy(xszDSObject, dwDSObjLength, L"LDAP://");
    if(SUCCEEDED(hr))
        hr = StringCchCat(xszDSObject, dwDSObjLength, szDomLocal);
    if(SUCCEEDED(hr))
        hr = StringCchCat(xszDSObject, dwDSObjLength, L"/");
    if(SUCCEEDED(hr))
        hr = StringCchCat(xszDSObject, dwDSObjLength, szContainer);

    if(FAILED(hr))
        return HRESULT_CODE(hr);

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: getting SD off %s", xszDSObject );

    if ( !DuplicateTokenEx( hToken,
                            TOKEN_IMPERSONATE | TOKEN_QUERY,
                            0,
                            SecurityImpersonation,
                            TokenImpersonation,
                            &xhTokenDup ) )
    {
        dwError = GetLastError();
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }


    //
    // Enable privilege to read SDs
    //

/*
    dwError = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, TRUE, FALSE, &bSecurityWasEnabled);

    if (!NT_SUCCESS(dwError)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }
*/


    XPtrLF<SECURITY_DESCRIPTOR> xptrSD;

    dwError = GetNamedSecurityInfo( (LPWSTR) xszDSObject,
                                    SE_DS_OBJECT_ALL,
                                    DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
                                    0,
                                    0,
                                    0,
                                    0,
                                    (void**) &xptrSD );

    if ( !dwError )
    {

        //
        // bf967aa5-0de6-11d0-a285-00aa003049e
        //
        GUID OUClass = {0xbf967aa5, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2};

        //
        // 19195a5b-6da0-11d0-afd3-00c04fd930c9
        //

        GUID DomainClass = {0x19195a5b, 0x6da0, 0x11d0, 0xaf, 0xd3, 0x00, 0xc0, 0x4f, 0xd9, 0x30, 0xc9};
        

        //
        // b7b1b3dd-ab09-4242-9e30-9980e5d322f7
        //
        GUID planningRight = {0xb7b1b3dd, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

        //
        // b7b1b3de-ab09-4242-9e30-9980e5d322f7
        //
        GUID loggingRight = {0xb7b1b3de, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

        OBJECT_TYPE_LIST ObjType[2];

        ObjType[0].Level = ACCESS_OBJECT_GUID;
        ObjType[0].Sbz = 0;

        if (bDomain) {
            ObjType[0].ObjectType = &DomainClass;
        }
        else {
            ObjType[0].ObjectType = &OUClass;
        }


        ObjType[1].Level = ACCESS_PROPERTY_SET_GUID;
        ObjType[1].Sbz = 0;

        if (bLogging) {
            ObjType[1].ObjectType = &loggingRight;
        }
        else {
            ObjType[1].ObjectType = &planningRight;
        }


        GENERIC_MAPPING GenericMapping =    {
                                            DS_GENERIC_READ,
                                            DS_GENERIC_WRITE,
                                            DS_GENERIC_EXECUTE,
                                            DS_GENERIC_ALL
                                            };

        const DWORD PriviledgeSize = 2 * ( sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES) );
        BYTE PrivilegeSetBuffer[PriviledgeSize];
        DWORD cPrivilegeSet = PriviledgeSize;
        PPRIVILEGE_SET pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;
        DWORD dwGrantedAccess;

        if ( !AccessCheckByType( xptrSD,
                                0,
                                xhTokenDup,
                                ACTRL_DS_CONTROL_ACCESS,
                                ObjType,
                                ARRAYSIZE(ObjType),
                                &GenericMapping,
                                pPrivilegeSet,
                                &cPrivilegeSet,
                                &dwGrantedAccess,
                                pbAccessGranted ) )
        {
            dwError = GetLastError();
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: AccessCheckByType failed, 0x%X", dwError );
        }
    }
    else {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: GetNamedSecurityInfo failed, 0x%X", dwError );
    }

/*    
    dwError = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, bSecurityWasEnabled, FALSE, &bSecurityWasEnabled);

    if (!NT_SUCCESS(dwError)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }
*/

    return dwError;
}

//*************************************************************
//
//  GetSOM()
//
//  Purpose:    Finds out the FQDN of a given user/computer
//
//  Parameters: szAccount       -  User or computer Account name in an appropriate format
//
//  Return:     SOM, NULL otherwise. GetLastError() for details
//              This just returns the DN of the user
//
//*************************************************************


LPWSTR
GetSOM( LPCWSTR szAccount )
{
    DWORD   dwSize = 0;
    XPtrLF<WCHAR>  xszXlatName;
    XPtrLF<WCHAR>  xszSOM;

    TranslateName(  szAccount,
                    NameUnknown,
                    NameFullyQualifiedDN,
                    xszXlatName,
                    &dwSize );
    if (!dwSize)
    {
        return 0;
    }

    xszXlatName = (LPWSTR)LocalAlloc( LPTR, ( dwSize + 1 ) * sizeof( WCHAR ) );
    if ( !xszXlatName )
    {
        return 0;
    }

    if ( !TranslateName(szAccount,
                        NameUnknown,
                        NameFullyQualifiedDN,
                        xszXlatName,
                        &dwSize ) )
    {
        return 0;
    }


    xszSOM = xszXlatName.Acquire();
    
    return xszSOM.Acquire();
}


//*************************************************************
//
//  GetDomain()
//
//  Purpose:    Finds out the domain given a SOM. 
//
//  Parameters: szSOM    -  SOM
//
//  Return:     domain Dns if success, null otherwise
//
//*************************************************************


DWORD
GetDomain( LPCWSTR szSOM, LPWSTR *pszDomain )
{
    DWORD    dwError = ERROR_SUCCESS;
    WCHAR   *pDomainString[1];
    PDS_NAME_RESULT pNameResult = NULL;

    //
    // preparse the name to just get the string , dc=
    //

    pDomainString[0] = NULL;

    LPWSTR pwszTemp = (LPWSTR)szSOM;

    while ( *pwszTemp ) {

        if (CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                            pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
            pDomainString[0] = pwszTemp;
            break;
        }
    
        //
        // Move to the next chunk of the DN name
        //
    
        while ( *pwszTemp && (*pwszTemp != TEXT(',')))
            pwszTemp++;
    
        if ( *pwszTemp == TEXT(','))
            pwszTemp++;
    
    }

    if (pDomainString[0] == NULL) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetDomain: Som doesn't have DC=. failing" );
        return ERROR_INVALID_PARAMETER;
    }



    dwError = DsCrackNames( (HANDLE) -1,
                            DS_NAME_FLAG_SYNTACTICAL_ONLY,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            pDomainString,
                            &pNameResult );

    if ( dwError != ERROR_SUCCESS
         || pNameResult->cItems == 0
         || pNameResult->rItems[0].status != ERROR_SUCCESS
         || pNameResult->rItems[0].pDomain == NULL ) {

        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetDomain:  DsCrackNames failed with 0x%x.", dwError );
        return dwError;
    }

    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"GetDomain: Som resides in domain %s", pNameResult->rItems[0].pDomain );

    DWORD dwDomainLength = wcslen(pNameResult->rItems[0].pDomain) + 2;
    XPtrLF<WCHAR> xszDomain = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwDomainLength ));

    if (!xszDomain) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration:  AllocMem failed with %d.", GetLastError() );
        DsFreeNameResult( pNameResult );
        return GetLastError();
    }

    HRESULT hr = StringCchCopy(xszDomain, dwDomainLength, pNameResult->rItems[0].pDomain);

    if(FAILED(hr)){
        DsFreeNameResult( pNameResult );
        return HRESULT_CODE(hr);
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"GetDomain: Domain for som %s = %s", szSOM, xszDomain );
    DsFreeNameResult( pNameResult );

    *pszDomain = xszDomain.Acquire();

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  AuthenticateUser()
//
//  Purpose:    Authenticates whether the user has the right to do the operation
//
//  Parameters: hToken       -  Token of the user
//              szMachSOM    -  Machine SOM (optional)
//              szUserSOM    -  User SOM    (optional)
//              bLogging     -  Logging or Planning mode
//
//  Return:     S_OK on success, error code otherwise
//
//*************************************************************


HRESULT AuthenticateUser(HANDLE  hToken, LPCWSTR szMachSOM, LPCWSTR szUserSOM, BOOL bLogging, DWORD *pdwExtendedInfo)
{
    if ( !szMachSOM && !szUserSOM )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: No mach and user som specified" );
        return E_INVALIDARG;
    }


    DWORD dwError = ERROR_SUCCESS;
    BOOL bMachAccess = FALSE, bUserAccess = FALSE;


    //
    // authenticate for machine SOM
    //

    *pdwExtendedInfo = 0;
    if (szMachSOM) {
        *pdwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;
    }


    if (szUserSOM) {
        *pdwExtendedInfo |= RSOP_USER_ACCESS_DENIED;
    }

    if (szMachSOM) {
        dwError = CheckAccessForPolicyGeneration(   hToken, 
                                                    szMachSOM,
                                                    NULL,
                                                    bLogging,
                                                    &bMachAccess
                                                    );

        if ( dwError != ERROR_SUCCESS )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: CheckAccessForPolicyGeneration Machine returned error - %d", dwError );
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( bMachAccess )
        {
            *pdwExtendedInfo &= ~RSOP_COMPUTER_ACCESS_DENIED;
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"AuthenticateUser: Access granted on Machine SOM");
        }
    }
    else {
        bMachAccess = TRUE;
    }


    //
    // authenticate for user SOM
    //

    if (szUserSOM) {
        dwError = CheckAccessForPolicyGeneration(   hToken,
                                                    szUserSOM,
                                                    NULL,
                                                    bLogging,
                                                    &bUserAccess
                                                    );

        if ( dwError != ERROR_SUCCESS )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: CheckAccessForPolicyGeneration User returned error - %d", dwError );
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( bUserAccess )
        {
            *pdwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"AuthenticateUser: Access granted on User SOM");
        }
    }
    else {
        bUserAccess = TRUE;
    }

    if ( !bUserAccess || !bMachAccess )
        return E_ACCESSDENIED;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsopdbg.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:                        RsopDbg.cpp
//
// Description:
//
// History:    8-20-99   leonardm    Created
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include "RsopUtil.h"
#include "smartptr.h"
#include "RsopDbg.h"
#include <strsafe.h>

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

CDebug::CDebug() :
    _bInitialized(false)
{
#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_NONE;
#endif
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

CDebug::CDebug( const WCHAR* sRegPath,
                        const WCHAR* sKeyName,
                        const WCHAR* sLogFilename,
                        const WCHAR* sBackupLogFilename,
                        bool bResetLogFile)
     : _sRegPath(sRegPath),
       _sKeyName(sKeyName),
       _sLogFilename(sLogFilename),
       _sBackupLogFilename(sBackupLogFilename)
{

#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_NONE;
#endif

    Initialize(bResetLogFile);
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

bool CDebug::Initialize( const WCHAR* sRegPath,
                             const WCHAR* sKeyName,
                             const WCHAR* sLogFilename,
                             const WCHAR* sBackupLogFilename,
                             bool bResetLogFile)
{
    if (!xCritSec)
        return FALSE;

    XEnterCritSec xEnterCS(xCritSec);
    
    _sRegPath = sRegPath;
    _sKeyName = sKeyName;
    _sLogFilename = sLogFilename;
    _sBackupLogFilename = sBackupLogFilename;

    return Initialize(bResetLogFile);
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

bool CDebug::Initialize(bool bResetLogFile)
{

    //
    // reinitialize the default value
    //

#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_NONE;
#endif
    
    _bInitialized = false;

    //
    // Check the registry for the appropriate debug level.
    //

    HKEY hKey;
    LONG lResult = RegOpenKey (HKEY_LOCAL_MACHINE, _sRegPath, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(_dwDebugLevel);
        DWORD dwType;
        RegQueryValueEx(hKey,_sKeyName,NULL,&dwType,(LPBYTE)&_dwDebugLevel,&dwSize);
        RegCloseKey(hKey);
    }


    //
    // If a new log file has been requested, copy current log file to backup
    // file by overwriting then start a new log file.
    //

    if (bResetLogFile)
    {
        WCHAR szExpLogFileName[MAX_PATH+1];
        WCHAR szExpBackupLogFileName[MAX_PATH+1];

        CWString sTmp;
        sTmp = L"%systemroot%\\debug\\UserMode\\" + _sLogFilename;
        if(!sTmp.ValidString())
        {
            return false;
        }

        DWORD dwRet = ExpandEnvironmentStrings( sTmp, szExpLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
        {
            return false;
        }

        sTmp = L"%systemroot%\\debug\\UserMode\\" + _sBackupLogFilename;

        if(!sTmp.ValidString())
        {
            return false;
        }

        dwRet = ExpandEnvironmentStrings ( sTmp, szExpBackupLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
        {
            return false;
        }


        dwRet = MoveFileEx( szExpLogFileName, szExpBackupLogFileName, 
                        MOVEFILE_REPLACE_EXISTING);

                        
        XHandle hFile = CreateFile(  szExpLogFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);

        if(hFile == INVALID_HANDLE_VALUE)
        {
            return false;
        }
    }

    _bInitialized = true;
    return _bInitialized;
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

void CDebug::Msg(DWORD dwMask, LPCTSTR pszMsg, ...)
{

    //
    // Save the last error code (so the debug output doesn't change it).
    //

    DWORD dwErrCode = GetLastError();

    if(!_bInitialized)
    {
        return;
    }


    //
    // Display the error message if appropriate
    //

    bool bDebugOutput = (_dwDebugLevel & 0xFFFF0000 & DEBUG_DESTINATION_DEBUGGER) != 0;
    bool bLogfileOutput = (_dwDebugLevel & 0xFFFF0000 & DEBUG_DESTINATION_LOGFILE) != 0;

    if(!bDebugOutput && !bLogfileOutput)
    {

        //
        // No output
        //

        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }


    //
    // Determine the correct amount of debug output
    //

    bool bOutput;
    switch(_dwDebugLevel & 0x0000FFFF)
    {

        //
        // No output
        //


        case DEBUG_LEVEL_NONE:
                bOutput = false;
                break;


        //
        // Asserts and warnings
        //

        case DEBUG_LEVEL_WARNING:
                bOutput = dwMask & (DEBUG_MESSAGE_ASSERT | DEBUG_MESSAGE_WARNING) ? true : false;
                break;


        //
        // Asserts, warnings and verbose
        //

        case DEBUG_LEVEL_VERBOSE:
                bOutput = dwMask & (DEBUG_MESSAGE_ASSERT | DEBUG_MESSAGE_WARNING | DEBUG_MESSAGE_VERBOSE) ? true : false;
                break;


        //
        // No output
        //

        default:
                bOutput = false;
                break;
    }

    if(!bOutput)
    {
        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }

    WCHAR* pszMessageLevel;
    if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_ASSERT)
    {
        pszMessageLevel = L" [ASSERT] ";
    }
    else if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_WARNING)
    {
        pszMessageLevel = L" [WARNING] ";
    }
    else if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_VERBOSE)
    {
        pszMessageLevel = L" [VERBOSE] ";
    }
    else
    {
        pszMessageLevel = L" [<Unknown message type>] ";
    }

    SYSTEMTIME systime;
    GetLocalTime (&systime);

    const DWORD dwDbgTitleLength = 128;
    WCHAR szDebugTitle[dwDbgTitleLength];

    HRESULT hr = StringCchPrintf (  szDebugTitle,
                dwDbgTitleLength,
                L"[%x.%x] %2d/%02d/%4d %02d:%02d:%02d:%03d ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                systime.wMonth, systime.wDay, systime.wYear,
                systime.wHour, systime.wMinute, systime.wSecond,systime.wMilliseconds);

    if(FAILED(hr))
        return;

    const int nDebugBufferWChars = 2048;
    XPtrLF<WCHAR>xpDebugBuffer = (LPTSTR) LocalAlloc (LPTR, nDebugBufferWChars * sizeof(WCHAR));

    if(!xpDebugBuffer)
    {
        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }

    va_list marker;
    va_start(marker, pszMsg);
    hr = StringCchVPrintf(xpDebugBuffer, nDebugBufferWChars, pszMsg, marker);

    if(FAILED(hr))
        return;

    if(bDebugOutput)
    {
        OutputDebugString(szDebugTitle);
        OutputDebugString(pszMessageLevel);
        OutputDebugString(xpDebugBuffer);
        OutputDebugString(L"\r\n");
    }

    va_end(marker);

    if(bLogfileOutput)
    {
        WCHAR szExpLogFileName[MAX_PATH+1];
        CWString sTmp = L"%systemroot%\\debug\\usermode\\" + _sLogFilename;
        if(!sTmp.ValidString())
        {
            return;
        }

        DWORD dwRet = ExpandEnvironmentStrings ( sTmp, szExpLogFileName, MAX_PATH+1);

        if(dwRet == 0 || dwRet > MAX_PATH)
        {
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        HANDLE hFile = CreateFile( szExpLogFileName,
                                   FILE_WRITE_DATA | FILE_APPEND_DATA,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

        XHandle autoCloseHandle(hFile);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwLastError = GetLastError();
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        if(SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_FILE_SIZE)
        {
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        DWORD dwBytesWritten;
        WriteFile(hFile, (LPCVOID) szDebugTitle,lstrlen (szDebugTitle) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) pszMessageLevel,lstrlen (pszMessageLevel) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) xpDebugBuffer,lstrlen (xpDebugBuffer) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) L"\r\n",lstrlen (L"\r\n") * sizeof(WCHAR),&dwBytesWritten,NULL);
    }

    CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
    return;
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

void CDebug::CleanupAndCheckForDbgBreak(DWORD dwErrorCode, DWORD dwMask)
{
    SetLastError(dwErrorCode);

    // Break to the debugger if appropriate
#ifdef DEBUG
    if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_ASSERT)
    {
        DebugBreak();
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsopdbg.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopDbg.h
//
// Description: Debugging functions
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#ifndef DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
#define DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_

#include "rsoputil.h"
#include "smartptr.h"

//
// Debug Levels
//

const DWORD DEBUG_LEVEL_NONE =     0x00000000;
const DWORD DEBUG_LEVEL_WARNING =  0x00000001;
const DWORD DEBUG_LEVEL_VERBOSE =  0x00000002;


//
// Debug message output destination
//

const DWORD DEBUG_DESTINATION_LOGFILE =  0x00010000;
const DWORD DEBUG_DESTINATION_DEBUGGER = 0x00020000;


//
// Debug message types
//

const DWORD DEBUG_MESSAGE_ASSERT =   0x00000001;
const DWORD DEBUG_MESSAGE_WARNING =  0x00000002;
const DWORD DEBUG_MESSAGE_VERBOSE =  0x00000004;



//*************************************************************
//
// Class:
//
// Description:
//
//*************************************************************

class CDebug
{
private:
    CWString _sRegPath;
    CWString _sKeyName;

    CWString _sLogFilename;
    CWString _sBackupLogFilename;

    bool _bInitialized;

    DWORD _dwDebugLevel;

    XCritSec xCritSec;
    
    void CleanupAndCheckForDbgBreak(DWORD dwErrorCode, DWORD dwMask);

public:
    CDebug();
    CDebug( const WCHAR* sRegPath,
                const WCHAR* sKeyName,
                const WCHAR* sLogFilename,
                const WCHAR* sBackupLogFilename,
                bool bResetLogFile = false);

    bool Initialize(const WCHAR* sRegPath,
                    const WCHAR* sKeyName,
                    const WCHAR* sLogFilename,
                    const WCHAR* sBackupLogFilename,
                    bool bResetLogFile = false);

    bool Initialize(bool bResetLogFile = false);

    void Msg(DWORD dwMask, LPCTSTR pszMsg, ...);
};

extern CDebug dbgRsop;
extern CDebug dbgCommon;
extern CDebug dbgAccessCheck;

// default to dbgRsop..
// The common routines need to define it to dbgCommon or #define dbg to dbgCommon and then
// use..

#define dbg dbgRsop


#endif // DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsoputil.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            RsopUtil.cpp
//
// Description:        
//
// History:    8-20-99   leonardm    Created
//
//******************************************************************************

#include <windows.h>
#include "RsopUtil.h"
#include <strsafe.h>

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString() : _pW(NULL), _len(0), _bState(false)
{
    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        HRESULT hr = StringCchCopy(_pW, _len + 1, L"");

        if(FAILED(hr))
        {
            Reset();
            return;
        }

        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString(const CWString& s) : _pW(NULL), _len(0), _bState(false)
{
    if(!s.ValidString())
    {
        return;
    }

    _len = s._len;

    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        HRESULT hr = StringCchCopy(_pW, _len + 1, s._pW);
        
        if(FAILED(hr))
        {
            Reset();
            return;
        }

        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString(const WCHAR* s) : _pW(NULL), _len(0), _bState(false)
{
    if(s)
    {
        _len = wcslen(s);
    }
    _pW = new WCHAR[_len + 1];

    if(_pW)
    {
        HRESULT hr = StringCchCopy(_pW, _len + 1, s ? s : L"");

        if(FAILED(hr))
        {
            Reset();
            return;
        }

        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::~CWString()
{
    Reset();
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator = (const CWString& s)
{
    if(&s == this)
    {
        return *this;
    }

    Reset();

    if(s.ValidString())
    {
        _len = s._len;
        _pW = new WCHAR[_len+1];
        if(_pW)
        {
            HRESULT hr = StringCchCopy(_pW, _len + 1, s._pW);

            if(FAILED(hr))
            {
                Reset();
                return *this;
            }

            _bState = true;
        }
    }

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator = (const WCHAR* s)
{
    Reset();

    _len = s ? wcslen(s) : 0;

    _pW = new WCHAR[_len + 1];

    if(_pW)
    {
        HRESULT hr = StringCchCopy(_pW, _len + 1, s ? s : L"");

        if(FAILED(hr))
        {
            Reset();
            return *this;
        }

        _bState = true;
    }

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
void CWString::Reset()
{
    if (_pW)
        delete[] _pW;
    _pW = NULL;
    _len =0;
    _bState = false;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator += (const CWString& s)
{
    if(!s.ValidString())
    {
        Reset();
        return *this;
    }

    int newLen = _len + s._len;

    WCHAR* pW = new WCHAR[newLen+1];
    if(!pW)
    {
        Reset();
        return *this;
    }

    HRESULT hr = StringCchCopy(pW, newLen + 1, _pW);
    
    if(SUCCEEDED(hr))
        hr = StringCchCat(pW, newLen + 1, s._pW);

    if(FAILED(hr))
    {
        delete [] pW;
        Reset();
        return *this;
    }

    *this = pW;

    delete[] pW;

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString CWString::operator + (const CWString& s) const
{
    if(!s.ValidString())
    {
        return *this;
    }

    CWString tmp;
    tmp.Reset();

    tmp._len = _len + s._len;
    tmp._pW = new WCHAR[tmp._len+1];

    if(!tmp._pW)
    {
        tmp.Reset();
        return tmp;
    }

    HRESULT hr = StringCchCopy(tmp._pW, tmp._len + 1, _pW);
    if(SUCCEEDED(hr))
        hr = StringCchCat(tmp._pW, tmp._len + 1, s._pW);

    if(FAILED(hr))
    {
        tmp.Reset();
        return tmp;
    }
    tmp._bState = true;

    return tmp;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString operator + (const WCHAR* s1, const CWString& s2)
{
    CWString tmp;

    if(!s1 || !s2.ValidString())
    {
        return tmp;
    }

    tmp.Reset();

    tmp._len = wcslen(s1) + s2._len;
    tmp._pW = new WCHAR[tmp._len+1];

    if(!tmp._pW)
    {
        tmp.Reset();
        return tmp;
    }

    HRESULT hr = StringCchCopy(tmp._pW, tmp._len + 1, s1);
    
    if(SUCCEEDED(hr))
        hr = StringCchCat(tmp._pW, tmp._len + 1, s2._pW);

    if(FAILED(hr))
    {
        tmp.Reset();
        return tmp;
    }
    tmp._bState = true;
    
    return tmp;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::operator const WCHAR* ()  const
{
    return _pW;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::operator WCHAR* ()  const
{
    return _pW;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator == (const WCHAR* s)  const
{
    CWString tmp = s;
    
    return (*this == tmp);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator == (const CWString& s)  const
{
    if(!ValidString() || !s.ValidString())
    {
        return false;
    }

    if(&s == this)
    {
        return true;
    }

    if(_len != s._len || _bState != s._bState)
    {
        return false;
    }

    if(_wcsicmp(s._pW, _pW) != 0)
    {
        return false;
    }

    return true;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::CaseSensitiveCompare(const CWString& s)  const
{
    if(!ValidString() || !s.ValidString())
    {
        return false;
    }

    if(&s == this)
    {
        return true;
    }

    if(_len != s._len || _bState != s._bState)
    {
        return false;
    }

    if(wcscmp(s._pW, _pW) != 0)
    {
        return false;
    }

    return true;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator != (const CWString& s) const
{
    return !(*this == s);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator != (const WCHAR* s) const
{
    CWString tmp = s;
    
    return !(*this == tmp);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
int CWString::length() const
{
    return _len;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::ValidString() const
{
    return _bState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\wbemtime.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            WbemTime.cpp
//
// Description:     Utility functions to convert between SYSTEMTIME and strings in
//                  WBEM datetime format.
//
// History:    12-08-99   leonardm    Created
//
//******************************************************************************

#include <wchar.h>
#include "smartptr.h"
#include "WbemTime.h"
#include <strsafe.h>

//******************************************************************************
//
// Function:        SystemTimeToWbemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, XBStr& xbstrWbemTime)
{

    DWORD         dwTempLength = WBEM_TIME_STRING_LENGTH + 1;
    XPtrST<WCHAR> xTemp = new WCHAR[dwTempLength];

    if(!xTemp)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = StringCchPrintf(xTemp,
                                 dwTempLength,
                                 L"%04d%02d%02d%02d%02d%02d.000000+000",
                                 sysTime.wYear,
                                 sysTime.wMonth,
                                 sysTime.wDay,
                                 sysTime.wHour,
                                 sysTime.wMinute,
                                 sysTime.wSecond);

    if(FAILED(hr))
    {
        return E_FAIL;
    }

    xbstrWbemTime = xTemp;

    if(!xbstrWbemTime)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime)
{
    if(!xbstrWbemTime || wcslen(xbstrWbemTime) != WBEM_TIME_STRING_LENGTH)
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(int i = 0; i < 14; i++)
    {
        if(!iswdigit(xbstrWbemTime[i]))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }


    XPtrST<WCHAR>xpTemp = new WCHAR[5];
    if(!xpTemp)
    {
        return E_OUTOFMEMORY;
    }

    wcsncpy(xpTemp, xbstrWbemTime, 4);
    xpTemp[4] = L'\0';
    sysTime.wYear = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 4, 2);
    xpTemp[2] = L'\0';
    sysTime.wMonth = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 6, 2);
    xpTemp[2] = L'\0';
    sysTime.wDay = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 8, 2);
    xpTemp[2] = L'\0';
    sysTime.wHour = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 10, 2);
    xpTemp[2] = L'\0';
    sysTime.wMinute = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 12, 2);
    xpTemp[2] = L'\0';
    sysTime.wSecond = (WORD)_wtol(xpTemp);

    sysTime.wMilliseconds = 0;
    sysTime.wDayOfWeek = 0;

    return S_OK;
}

//*************************************************************
//
//  Function:   GetCurrentWbemTime
//
//  Purpose:    Gets the current date and time in WBEM format.
//
//  Parameters: xbstrCurrentTime -  Reference to XBStr which, on
//                                  success, receives the formated
//                                  string containing the current
//                                  date and time.
//
//  Returns:    On success it returns S_OK.
//              On failure, it returns E_OUTOFMEMORY.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT GetCurrentWbemTime(XBStr& xbstrCurrentTime)
{
    SYSTEMTIME sytemTime;
    GetSystemTime(&sytemTime);

    HRESULT hr = SystemTimeToWbemTime(sytemTime, xbstrCurrentTime);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\wbemtime.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            WbemTime.h
//
// Description:     Utility functions to convert between SYSTEMTIME and strings in 
//                  WBEM datetime format.   
//
// History:    12-08-99   leonardm    Created
//
//******************************************************************************

#ifndef WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
#define WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_


#ifdef  __cplusplus
extern "C" {
#endif


#define WBEM_TIME_STRING_LENGTH 25

//******************************************************************************
//
// Function:        SystemTimeToWbemTime
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, XBStr& xbstrWbemTime);


//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime);


//*************************************************************
//
//  Function:   GetCurrentWbemTime
//
//  Purpose:    Gets the current date and time in WBEM format.
//
//  Parameters: xbstrCurrentTime -  Reference to XBStr which, on 
//                                  success, receives the formated
//                                  string containing the current 
//                                  date and time.
//
//  Returns:    On success it returns S_OK.
//              On failure, it returns E_OUTOFMEMORY.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT GetCurrentWbemTime(XBStr& xbstrCurrentTime);


#ifdef  __cplusplus
}   // extern "C" {
#endif


#endif // #ifndef WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\smartptr.h ===
//*************************************************************
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        smartptr.h
//
// Contents:    Classes for smart pointers
//
// History:     7-Jun-99       SitaramR    Created
//
//              2-Dec-99       LeonardM    Major revision and cleanup.
//
//*************************************************************

#ifndef SMARTPTR_H
#define SMARTPTR_H

#include <comdef.h>
#include "userenv.h"

#pragma once
#pragma warning(disable:4284)


//*************************************************************
//
//  Class:      XPtrST
//
//  Purpose:    Smart pointer template to wrap pointers to a single type.
//
//*************************************************************

template<class T> class XPtrST
{

private:

    XPtrST (const XPtrST<T>& x);
    XPtrST<T>& operator=(const XPtrST<T>& x);

    T* _p;

public:

    XPtrST(T* p = NULL) : _p(p){}

    ~XPtrST(){ delete _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XPtrArray
//
//  Purpose:    Smart pointer template to wrap pointers to an array .
//
//*************************************************************

template<class T> class XPtrArray
{

private:

    XPtrArray (const XPtrArray<T>& x);
    XPtrArray<T>& operator=(const XPtrArray<T>& x);

    T* _p;

public:

    XPtrArray(T* p = NULL) : _p(p){}

    ~XPtrArray(){ delete[] _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete[] _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XInterface
//
//  Purpose:    Smart pointer template for items Release()'ed, not ~'ed
//
//*************************************************************

template<class T> class XInterface
{

private:

    XInterface(const XInterface<T>& x);
    XInterface<T>& operator=(const XInterface<T>& x);

    T* _p;

public:

    XInterface(T* p = NULL) : _p(p){}

    ~XInterface()
    {
        if (_p)
        {
            _p->Release();
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XBStr
//
//  Purpose:    Smart pointer class for BSTRs
//
//*************************************************************

class XBStr
{

private:

    XBStr(const XBStr& x);
    XBStr& operator=(const XBStr& x);

    BSTR _p;

public:

    XBStr(WCHAR* p = 0) : _p(0)
    {
        if(p)
        {
            _p = SysAllocString(p);
        }
    }

    ~XBStr()
    {
        SysFreeString(_p);
    }

    operator BSTR(){ return _p; }

    void operator=(WCHAR* p)
    {
        SysFreeString(_p);
        _p = p ? SysAllocString(p) : NULL;
    }

    BSTR Acquire()
    {
        BSTR p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XSafeArray
//
//  Purpose:    Smart pointer class for SafeArrays
//
//*************************************************************

class XSafeArray
{

private:

    XSafeArray(const XSafeArray& x);
    XSafeArray& operator=(const XSafeArray& x);

    SAFEARRAY* _p;

public:

    XSafeArray(SAFEARRAY* p = 0) : _p(p){}

    ~XSafeArray()
    {
        if (_p)
        {
            SafeArrayDestroy(_p);
        }
    }

    operator SAFEARRAY*(){ return _p; }

    SAFEARRAY ** operator&(){ return &_p; }

    void operator=(SAFEARRAY* p)
    {
        if(_p)
        {
            SafeArrayDestroy(_p);
        }

        _p = p;
    }

    SAFEARRAY* Acquire()
    {
        SAFEARRAY* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XVariant
//
//  Purpose:    Smart pointer class for Variants
//
//*************************************************************

class XVariant
{

private:

    XVariant(const XVariant& x);
    XVariant& operator=(const XVariant& x);

    VARIANT* _p;

public:

    XVariant(VARIANT* p = 0) : _p(p){}

    ~XVariant()
    {
        if (_p)
        {
            VariantClear(_p);
        }
    }

    void operator=(VARIANT* p)
    {
        if(_p)
        {
            VariantClear(_p);
        }
        _p = p;
    }

    operator VARIANT*(){ return _p; }

    VARIANT* Acquire()
    {
        VARIANT* p = _p;
        _p = 0;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtrLF
//
//  Purpose:    Smart pointer template for pointers that should be LocalFree()'d
//
//*************************************************************

template <typename T> class XPtrLF
{

private:

    XPtrLF(const XPtrLF<T>& x);
    XPtrLF<T>& operator=(const XPtrLF<T>& x);

    T* _p;

public:

    XPtrLF(HLOCAL p = 0 ) :
            _p((T*)p)
    {
    }

    ~XPtrLF()
    {
        if(_p)
        {
            LocalFree(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            LocalFree(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtr
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNFREE)(HLOCAL);

//
// usage : XPtr<SID, FreeSid> xptrSid;
//

template <typename T, PFNFREE _f> class XPtr
{
private:
    XPtr(const XPtr<T, _f>& x);
    XPtr<T, _f>& operator=(const XPtr<T, _f>& x);
    T* _p;

public:

    XPtr( HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) )
    {
    }

    ~XPtr()
    {
        if(_p)
        {
            _f(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }
};

//*************************************************************
//
//  Class:      XArray
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNARRAYFREE)(HLOCAL, int);

//
// usage : XArray<EXPLICIT_ACCESS, 10> xaExplicitAccess( FreeAccessArray );
//

template <typename T, int nElements> class XArray
{
private:
    XArray(const XArray<T,nElements>& x);
    XArray<T,nElements>& operator=(const XArray<T,nElements>& x);
    T* _p;
    int _n;
    PFNARRAYFREE _f;

public:

    XArray( PFNARRAYFREE pfnFree, HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) ), _f( pfnFree ), _n( nElements )
    {
    }

    ~XArray()
    {
        if(_p)
        {
            _f(_p, _n);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p, _n);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p, _p = 0;
        return p;
    }
};

//******************************************************************************
//
// Class:
//
// Description:
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
class XHandle
{
private:
    HANDLE _h;

public:
    XHandle(HANDLE h = NULL) : _h(h) {}
    ~XHandle()
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
    }
    HANDLE* operator&(){return &_h;}
    operator HANDLE(){return _h;}

    void operator=(HANDLE h)
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
        _h = h;
    }
};

class XKey
{
private:
    HKEY _h;

public:
    XKey(HKEY h = NULL) : _h(h) {}
    ~XKey()
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(_h);
        }
    }
    HKEY* operator&(){return &_h;}
    operator HKEY(){return _h;}

    void operator=(HKEY h)
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(_h);
        }
        _h = h;
    }
};


class XCoInitialize
{
public:
    XCoInitialize()
    {
        m_hr = CoInitializeEx( 0, COINIT_MULTITHREADED );
    };

    ~XCoInitialize()
    {
        if ( SUCCEEDED( m_hr ) )
        {
            CoUninitialize();
        }
    };

    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT      m_hr;
};

class XImpersonate
{
public:
    XImpersonate() : 
        m_hImpToken( 0 ), 
        m_hThreadToken( 0 ), 
        m_bRevertAttempted(FALSE),
        m_bImpersonated(FALSE),
        m_hr(S_OK)
    {
        m_hr = CoImpersonateClient();
        if (SUCCEEDED(m_hr))
        {
            m_bImpersonated = TRUE;
        }
    };

    XImpersonate( HANDLE hToken ) : 
            m_hImpToken( hToken ), 
            m_hThreadToken( 0 ), 
            m_bRevertAttempted(FALSE),
            m_bImpersonated(FALSE),
            m_hr(S_OK)
    {
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &m_hThreadToken )) {
            if (GetLastError() != ERROR_NO_TOKEN )
            {
                m_hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (SUCCEEDED(m_hr)) {

            if (!ImpersonateLoggedOnUser( hToken )) {
                m_hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else {
                m_bImpersonated = TRUE;
            }
        }
    };

    HRESULT Revert()
    {
        if ( m_bImpersonated )
        {
            m_bRevertAttempted = TRUE;
            if ( m_hImpToken )
            {
                if (!SetThreadToken( 0, m_hThreadToken)) {
                    m_hr = HRESULT_FROM_WIN32(GetLastError());
                }
                else {
                    m_bImpersonated = FALSE;
                    m_hr = S_OK;
                }

            }
            else
            {
                m_hr = CoRevertToSelf();
                if (SUCCEEDED(m_hr))
                {
                    m_bImpersonated = FALSE;
                }
            }
        }

        return m_hr;
    }

    ~XImpersonate()
    {
        HRESULT hr = S_OK;

        if (!m_bRevertAttempted)
        {
            hr = Revert();
        }

        if (m_hThreadToken)
        {
            CloseHandle(m_hThreadToken);
        }

        if (FAILED(hr))
        {
            RaiseException(Status(), 
                           EXCEPTION_NONCONTINUABLE, 
                           0, 
                           NULL);
        }
    };


    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT     m_hr;
    XHandle     m_hThreadToken;
    HANDLE      m_hImpToken;   // we don't own this
    BOOL        m_bImpersonated;
    BOOL        m_bRevertAttempted;
};


//*************************************************************
//
//  Class:      XCriticalPolicySection
//
//  Purpose:    Smart pointer for freeing Group Policy critical section
//
//*************************************************************

class XCriticalPolicySection
{
private:
    HANDLE _h;

public:
    XCriticalPolicySection(HANDLE h = NULL) : _h(h){}
    ~XCriticalPolicySection()
    {
        if(_h)
        {
            LeaveCriticalPolicySection (_h);
        }
    }

    void operator=(HANDLE h)
    {
        if(_h)
        {
            LeaveCriticalPolicySection (_h);
        }
        _h = h;
    }
    
    operator bool() {return _h ? true : false;}
};


// critical section smartptr
class XCritSec
{
public:
    XCritSec()
    {
        lpCritSec = &CritSec;
        __try {
            if (!InitializeCriticalSectionAndSpinCount(&CritSec, 0x80001000)) {
                lpCritSec = NULL;
            }
        }            
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // assumption, exception is out of memory
            // this is used in spewing debug messages. so cannot add a debug spew.
            lpCritSec = NULL;
        }            
    }

    ~XCritSec()
    {
        if (lpCritSec)
            DeleteCriticalSection(lpCritSec);
    }

    operator LPCRITICAL_SECTION(){return lpCritSec;}

    
private:
    CRITICAL_SECTION      CritSec;    
    LPCRITICAL_SECTION    lpCritSec;
};



// enter and exit critical section
class XEnterCritSec
{
public:
    XEnterCritSec(LPCRITICAL_SECTION lpCritSec) : m_lpCritSec( lpCritSec )
    {
        if (lpCritSec)
            EnterCriticalSection(lpCritSec);
    };

    
    ~XEnterCritSec()
    {
        if (m_lpCritSec)
            LeaveCriticalSection(m_lpCritSec);
    };


private:
    LPCRITICAL_SECTION      m_lpCritSec;   // we don't own this
};


//////////////////////////////////////////////////////////////////////
// XLastError
//
//
// Sets the Last Error Correctly..
//////////////////////////////////////////////////////////////////////

class XLastError
{
private:
    DWORD _e;

public:
    XLastError(){_e = GetLastError();}
    XLastError(DWORD e) : _e(e) {}
    ~XLastError(){SetLastError(_e);} 
    
    void operator=(DWORD e) {_e = e;}
    operator DWORD() {return _e;}
};



#endif SMARTPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-94   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

extern  DWORD   GINAInfoLevel;

#define DebugLog(x) LogEvent x


void    LogEvent(long, const char *, ...);
void    InitDebugSupport(void);

#define DEB_ERROR           0x00000001
#define DEB_WARN            0x00000002
#define DEB_TRACE           0x00000004



#else

#define DebugLog(x)

#endif



#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\rsoputil\rsoputil.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            RsopUtil.h
//
// Description:        
//
// History:    8-20-99   leonardm    Created
//
//******************************************************************************

#ifndef RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_
#define RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_



//******************************************************************************
//
// Class:    
//
// Description:    
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
class CWString
{
private:
    WCHAR* _pW;
    int _len;
    bool _bState;

    void Reset();

public:
    CWString();

    CWString(const WCHAR* s);
    CWString(const CWString& s);

    ~CWString();

    CWString& operator = (const CWString& s);
    CWString& operator = (const WCHAR* s);

    operator const WCHAR* () const;
    operator WCHAR* () const;

    CWString& operator += (const CWString& s);
    CWString operator + (const CWString& s) const;
    
    friend CWString operator + (const WCHAR* s1, const CWString& s2);

    bool operator == (const CWString& s) const;
    bool operator == (const WCHAR* s) const;
    bool operator != (const CWString& s) const;
    bool operator != (const WCHAR* s) const;

    bool CaseSensitiveCompare(const CWString& s) const;

    int length() const;

    bool ValidString() const;
};

#endif // #ifndef RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\gina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       gina.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Make sure that you have defined UNICODE, _UNICODE, and WIN32 correctly in
// your build environment.
//

#include <windows.h>
#include <commctrl.h>
#include <lm.h>
#include <winwlx.h>

#include "ginadlg.h"
#include "resids.h"

#include "debug.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [Gina]
//      DebugFlags=<Flag>[<,Flag>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace
//

#if DBG         // NOTE:  This file not compiled for retail builds

#include "gina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;
DWORD   GINAInfoLevel = 3;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "Gina";
char * DebLevel[] = {"GINA-Error", "GINA-Warn", "GINA-Trace"
                    };

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   DebugKeyNames[] = {
                {"Error",       DEB_ERROR},
                {"Warning",     DEB_WARN},
                {"Trace",       DEB_TRACE},
                };

#define NUM_DEBUG_KEYS  sizeof(DebugKeyNames) / sizeof(DebugKeys)
#define NUM_BREAK_KEYS  sizeof(BreakKeyNames) / sizeof(DebugKeys)

//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];
    long    OriginalMask = Mask;


    if (Mask & GINAInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= (sizeof(DebLevel) / sizeof(char *)) )
        {
            Level = (sizeof(DebLevel) / sizeof(char *)) - 1;
        }


        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), DebLevel[Level]);


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;

            GetLocalTime(&stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    DebugLog((DEB_TRACE, "Log file '%s' begins\n", pszLogFile));
}


DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_stricmp(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;

    cbVal = GetProfileStringA(szSection, "DebugFlags", "Error,Warning", szVal, sizeof(szVal));

    pszDebug = strtok(szVal, ", \t");
    while (pszDebug)
    {
        GINAInfoLevel |= GetDebugKeyValue(DebugKeyNames, NUM_DEBUG_KEYS, pszDebug);
        pszDebug = strtok(NULL, ", \t");
    }

    cbVal = GetProfileStringA(szSection, "LogFile", "", szVal, sizeof(szVal));
    if (cbVal)
    {
        OpenLogFile(szVal);
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the GINAgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
InitDebugSupport(void)
{
    LoadDebugParameters();

}



#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\gina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       gina.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "gina.h"
#pragma hdrstop


HINSTANCE                   hDllInstance;   // My instance, for resource loading
HANDLE                      hGlobalWlx;     // Handle to tell winlogon who's calling
PWLX_DISPATCH_VERSION_1_0   pWlxFuncs;      // Ptr to table of functions

#define WINLOGON_APP        TEXT("Winlogon")
#define USERINIT            TEXT("Userinit")
#define USERINIT_DEFAULT    TEXT("Userinit.exe")



//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL Entrance point
//
//  Arguments:  [hInstance]  --
//              [dwReason]   --
//              [lpReserved] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            hDllInstance = hInstance;
#if DBG
            InitDebugSupport();
#endif
        case DLL_PROCESS_DETACH:
        default:
            return(TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxNegotiate
//
//  Synopsis:   Negotiate version of interface with Winlogon
//
//  Arguments:  [dwWinlogonVersion] --
//              [pdwDllVersion]     --
//
//  Algorithm:
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxNegotiate(
    DWORD                   dwWinlogonVersion,
    DWORD                   *pdwDllVersion
    )
{
    if (dwWinlogonVersion < WLX_CURRENT_VERSION)
    {
        DebugLog((DEB_ERROR, "Unknown version: %d\n", dwWinlogonVersion));
        return(FALSE);
    }

    *pdwDllVersion = WLX_CURRENT_VERSION;

    DebugLog((DEB_TRACE, "Negotiate:  successful!\n"));

    return(TRUE);

}


//+---------------------------------------------------------------------------
//
//  Function:   WlxInitialize
//
//  Synopsis:   Initialize entrypoint from winlogon
//
//  Arguments:  [lpWinsta]           --
//              [hWlx]               --
//              [pvReserved]         --
//              [pWinlogonFunctions] --
//              [pWlxContext]        --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxInitialize(
    LPWSTR                  lpWinsta,
    HANDLE                  hWlx,
    PVOID                   pvReserved,
    PVOID                   pWinlogonFunctions,
    PVOID                   *pWlxContext
    )
{
    PGlobals  pGlobals;

    pWlxFuncs = (PWLX_DISPATCH_VERSION_1_0) pWinlogonFunctions;

    hGlobalWlx = hWlx;

    pGlobals = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(Globals));

    *pWlxContext = (PVOID) pGlobals;

    //
    // Read from registry...
    //

    pGlobals->fAllowNewUser = TRUE;


    pWlxFuncs->WlxUseCtrlAltDel(hWlx);

    InitCommonControls();

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplaySASNotice
//
//  Synopsis:   Where we display the welcome, we're waiting dialog box
//
//  Arguments:  [pContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxDisplaySASNotice(PVOID   pContext)
{
    int Result;

    Result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_WELCOME_DLG),
                                            NULL,
                                            WelcomeDlgProc,
                                            0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxLoggedOutSAS
//
//  Synopsis:   Called when no one logged on...
//
//  Arguments:  [pWlxContext]       --
//              [dwSasType]         --
//              [pAuthenticationId] --
//              [pLogonSid]         --
//              [pdwOptions]        --
//              [phToken]           --
//              [pMprNotifyInfo]    --
//              [pProfile]          --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxLoggedOutSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PLUID                   pAuthenticationId,
    PSID                    pLogonSid,
    PDWORD                  pdwOptions,
    PHANDLE                 phToken,
    PWLX_MPR_NOTIFY_INFO    pMprNotifyInfo,
    PVOID *                 pProfile
    )
{
    int         result;
    // PWLX_PROFILE_V1_0   pWlxProfile;
    // PMiniAccount    pAccount;
    PGlobals        pGlobals;

    pGlobals = (PGlobals) pWlxContext;

    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_LOGON_DIALOG),
                                            NULL,
                                            LogonDlgProc,
                                            (LPARAM) pGlobals );

    if (result == WLX_SAS_ACTION_LOGON)
    {
        result = AttemptLogon(pGlobals, pGlobals->pAccount,
                                pLogonSid, pAuthenticationId);

        if (result == WLX_SAS_ACTION_LOGON)
        {
            *pdwOptions = 0;
            *phToken = pGlobals->hUserToken;
            *pProfile = NULL;

            pMprNotifyInfo->pszUserName = DupString(pGlobals->pAccount->pszUsername);
            pMprNotifyInfo->pszDomain = DupString(pGlobals->pAccount->pszDomain);
            pMprNotifyInfo->pszPassword = DupString(pGlobals->pAccount->pszPassword);
            pMprNotifyInfo->pszOldPassword = NULL;

        }
    }
    return(result);
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxActivateUserShell
//
//  Synopsis:   Activates progman or whatever for the user
//
//  Arguments:  [pWlxContext]       --
//              [pszDesktop]        --
//              [pszMprLogonScript] --
//              [pEnvironment]      --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxActivateUserShell(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PWSTR                   pszMprLogonScript,
    PVOID                   pEnvironment
    )
{
    // BOOL        bExec;
    WCHAR       szText[MAX_PATH];
    PWSTR       pszScan;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    PGlobals    pGlobals;
    DWORD       StartCount;

    pGlobals = (PGlobals) pWlxContext;

    GetProfileString(WINLOGON_APP, USERINIT, USERINIT_DEFAULT, szText, MAX_PATH);

    StartCount = 0;

    pszScan = wcstok(szText, TEXT(","));
    while (pszScan)
    {
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(STARTUPINFO);
        si.lpTitle = pszScan;
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.dwFlags = 0;
        si.wShowWindow = SW_SHOW;   // at least let the guy see it
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;
        si.lpDesktop = pszDesktop;

        DebugLog((DEB_TRACE, "Starting '%ws' as user\n", pszScan));

        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            if (CreateProcessAsUser(pGlobals->hUserToken,   // Token to run as
                                NULL,                   // App name
                                pszScan,                // Command Line
                                NULL,                   // Process SD
                                NULL,                   // Thread SD
                                FALSE,                  // No inherit
                                CREATE_UNICODE_ENVIRONMENT,
                                pEnvironment,
                                NULL,
                                &si,
                                &pi))
            {
                StartCount++;
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }

            RevertToSelf();
        }
        else
        {
            break;  // It's not going to improve
        }

        pszScan = wcstok(NULL, TEXT(","));
    }

    return(StartCount > 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxLoggedOnSAS
//
//  Synopsis:   Called when someone hits CAD when we're logged on
//
//  Arguments:  [pWlxContext] --
//              [dwSasType]   --
//              [pReserved]   --
//
//  Algorithm:
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxLoggedOnSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PVOID                   pReserved
    )
{
    int result;

    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_OPTIONS_DIALOG),
                                            NULL,
                                            OptionsDlgProc,
                                            (LPARAM) pWlxContext );



    return(result);

}

//+---------------------------------------------------------------------------
//
//  Function:   WlxIsLockOk
//
//  Synopsis:   Called to make sure that locking is ok
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxIsLockOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplayLockedNotice
//
//  Synopsis:   Displays a notice while the workstation is locked
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxDisplayLockedNotice(PVOID   pWlxContext)
{
    int Result;

    Result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_WKSTA_LOCKED),
                                            NULL,
                                            WelcomeDlgProc,
                                            0 );

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxWkstaLockedSAS
//
//  Synopsis:   Responds during an unlock attempt
//
//  Arguments:  [pWlxContext] --
//              [dwSasType]   --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxWkstaLockedSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType
    )
{
    return(WLX_SAS_ACTION_UNLOCK_WKSTA);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxIsLogoffOk
//
//  Synopsis:   Called to make sure that logoff is ok
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxIsLogoffOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxLogoff
//
//  Synopsis:   Called when the user logs off
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxLogoff(
    PVOID                   pWlxContext
    )
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) pWlxContext;

    //
    // Winlogon has closed it for us..
    //

    pGlobals->hUserToken = NULL;
    pGlobals->pAccount = NULL;

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxShutdown
//
//  Synopsis:   Called before shutdown so that we can unload/clean up.
//
//  Arguments:  [pWlxContext]  --
//              [ShutdownType] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxShutdown(
    PVOID                   pWlxContext,
    DWORD                   ShutdownType
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\globals.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       globals.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


extern  HINSTANCE                   hDllInstance;
extern  HANDLE                      hGlobalWlx;
extern  PWLX_DISPATCH_VERSION_1_0   pWlxFuncs;


#define GINA_SAS_1      256
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\ginadlg.h ===
#define IDD_WELCOME_DLG             100
#define IDD_WELCOME_TEXT            101
#define IDD_LOGON_LV                201
#define IDD_SHUTDOWN_BUTTON         202
#define IDD_LOGON_BUTTON            203
#define IDD_LOGON_DIALOG            300
#define IDD_OPTIONS_DIALOG          400
#define IDD_OPTIONS_ICON_SPOT       401
#define IDD_OPTIONS_ICON            402
#define IDD_OPTIONS_LOGON_TEXT      403
#define IDD_LOCK_BUTTON             405
#define IDD_PASSWORD_BUTTON         406
#define IDD_TASK_BUTTON             407
#define IDD_HELP_BUTTON             408
#define IDD_OPTION_TEXT             409
#define IDD_OPTIONS_EXIT            410
#define IDD_SHUTDOWN                500
#define IDD_CONFIRM_TEXT            501
#define IDD_CONFIRM_LOGOFF          502
#define IDD_CONFIRM_SHUTDOWN        503
#define IDD_CONFIRM_REBOOT          504
#define IDD_SHUTDOWN_ICON_SPOT      506
#define IDD_SHUTDOWN_ICON           507
#define IDD_CONFIG_BUTTON           411
#define IDD_NEW_USER_LOGON          600
#define IDD_NEW_USER_ICON_SPOT      601
#define IDD_NEW_USER_ICON_X         602
#define IDD_USERNAME_TEXT           603
#define IDD_USER_NAME               604
#define IDD_DOMAIN_TEXT             605
#define IDD_DOMAIN                  606
#define IDD_PASSWORD_TEXT           607
#define IDD_PASSWORD                608
#define IDD_LOGON_CONFIG            700
#define IDD_AUTO_LOGON              701
#define IDD_AUTO_LOGOFF_LOGON       702
#define IDD_LOCK_OTHERS             703
#define IDD_CONFIRM_POWEROFF        508
#define IDD_CHANGE_PASSWORD         800
#define IDD_USER_NAME_TEXT          801
#define IDD_NEW_PASSWORD_TEXT       802
#define IDD_FROM_TEXT               803
#define IDD_OLD_PASSWORD_TEXT       804
#define IDD_OLD_PASSWORD            805
#define IDD_NEW_PASSWORD            807
#define IDD_CONFIRM_PASSWORD_TEXT   808
#define IDD_CONFIRM_PASSWORD        809
#define IDD_FROM_TEXT               803
#define IDD_NO_NEW_USERS            704
#define IDD_WKSTA_LOCKED            200
#define IDD_LOCKED_ICON_SPOT        204
#define IDI_LOCKED_ICON             205
#define IDD_LOCKED_TEXT             206
#define IDD_LOCKED_BY_LABEL         207
#define IDD_LOCKED_BY               208
#define IDD_LOCKED_INST             209
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\out.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       out.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"

PMiniAccount    pAccountList = NULL;

BOOL
InitializeAccountList(
    VOID)
{
    // PMiniAccount
    //
    //
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\logon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       logon.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

HIMAGELIST      hiLogonSmall;
HIMAGELIST      hiLogonLarge;
PMiniAccount    pAccountList;
WCHAR           szMiniKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Accounts");

BYTE            LongPseudoRandomString[] = {0x27, 0xbd, 0xff, 0xa0,
                                            0xaf, 0xbf, 0x00, 0x1c,
                                            0x24, 0x0e, 0x00, 0x01,
                                            0x24, 0x0f, 0x00, 0x05 };


MiniAccount TestAccounts[]  = { {NULL, TEXT("daveth"), TEXT("\\msft\\risc\\dev"), TEXT("daveth"), TEXT("Oooh"), 0, MINI_CAN_EDIT},
                                {NULL, TEXT("Test1"), TEXT("Redmond"), TEXT("Test1"), TEXT("Mine"), 0, MINI_CAN_EDIT},
                                {NULL, TEXT("Test2"), TEXT("NtWksta"), TEXT("Test2"), TEXT("Yours"), 0, 0},
                                {NULL, TEXT("New User"), TEXT(""), TEXT(""), TEXT(""), 0, MINI_NEW_ACCOUNT}

                              };

BOOL
SaveMiniAccount(PMiniAccount    pAccount)
{
    HKEY                    hMiniKey;
    PSerializedMiniAccount  pPacked;
    DWORD                   cbNeeded;
    PWSTR                   pszPack;
    int                     err;
    DWORD                   Disposition;

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            szMiniKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hMiniKey,
                            &Disposition);

    if (err)
    {
        return(FALSE);
    }

    cbNeeded = sizeof(SerializedMiniAccount) +
                (wcslen(pAccount->pszDomain) + 1 +
                 wcslen(pAccount->pszPassword) + 1 +
                 wcslen(pAccount->pszComment) + 1 ) * sizeof(WCHAR) ;

    pPacked = LocalAlloc(LMEM_FIXED, cbNeeded);

    if (!pPacked)
    {
        return(FALSE);
    }

    pszPack = (PWSTR) (pPacked + 1);

    pPacked->Version = MINI_VERSION;
    pPacked->Flags = pAccount->Flags;
    pPacked->IconId = pAccount->IconId;

    pPacked->dwDomainOffset = sizeof(SerializedMiniAccount);
    pPacked->dwDomainLength = (wcslen(pAccount->pszDomain) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszDomain);
    pszPack += (pPacked->dwDomainLength / sizeof(WCHAR) );

    pPacked->dwPasswordOffset = pPacked->dwDomainOffset + pPacked->dwDomainLength;
    pPacked->dwPasswordLength = (wcslen(pAccount->pszPassword) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszPassword);
    pszPack += (pPacked->dwPasswordLength / sizeof(WCHAR) );

    pPacked->dwCommentOffset = pPacked->dwPasswordOffset + pPacked->dwPasswordLength;
    pPacked->dwCommentLength = (wcslen(pAccount->pszComment) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszComment);

    err = RegSetValueEx(hMiniKey,
                        pAccount->pszUsername,
                        0,
                        REG_BINARY,
                        (PBYTE) pPacked,
                        cbNeeded);

    RegCloseKey(hMiniKey);

    return(err == 0);
}

BOOL
LoadMiniAccounts(PGlobals   pGlobals)
{
    FILETIME            LastWrite;
    // HKEY                hKey;
    HKEY                hMiniKey;
    WCHAR               szClass[64];
    DWORD               err;
    DWORD               Disposition;
    DWORD               Class;
    DWORD               cKeys;
    DWORD               LongestKeyName;
    DWORD               LongestClass;
    DWORD               cValues;
    DWORD               LongestValueName;
    DWORD               LongestValueData;
    DWORD               Security;
    DWORD               i;
    WCHAR               szValue[MAX_PATH];
    DWORD               cbValue;
    DWORD               dwType;
    DWORD               cbData;
    PBYTE               pBuffer;
    DWORD               cbBuffer;
    PMiniAccount        pAccount;
    PSerializedMiniAccount  pPacked;


    if (pGlobals->fAllowNewUser)
    {
        pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount) );
        if (pAccount)
        {
            pAccount->pNext = NULL;
            pAccount->pszUsername = TEXT("New User");
            pAccount->pszDomain = TEXT("");
            pAccount->pszPassword = TEXT("");
            pAccount->pszComment = TEXT("");
            pAccount->Flags = MINI_NEW_ACCOUNT;

            pAccountList = pAccount;
        }
        else
            return(FALSE);
    }
    else
    {
        pAccountList = NULL;
    }

    //
    //

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            szMiniKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hMiniKey,
                            &Disposition);

    if (err)
    {
        return(FALSE);
    }

    if (Disposition == REG_OPENED_EXISTING_KEY)
    {
        //
        // Enumerate the sub keys of our class, and Load them.
        //
        Class = sizeof(szClass) / sizeof(WCHAR);
        err = RegQueryInfoKey(  hMiniKey,
                                szClass,
                                &Class,
                                NULL,
                                &cKeys,
                                &LongestKeyName,
                                &LongestClass,
                                &cValues,
                                &LongestValueName,
                                &LongestValueData,
                                &Security,
                                &LastWrite);

        pBuffer = LocalAlloc(LMEM_FIXED, 512);
        cbBuffer = 512;

        for (i = 0; i < cValues ; i++ )
        {
            cbValue = MAX_PATH;

            err = RegEnumValue( hMiniKey,
                                i,
                                szValue,
                                &cbValue,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData);

            if (err)
            {
                break;
            }

            if (dwType != REG_BINARY)
            {
                continue;
            }

            if (cbData > cbBuffer)
            {
                pBuffer = LocalReAlloc(pBuffer, LMEM_FIXED, cbData);
                if (!pBuffer)
                {
                    break;
                }
                cbBuffer = cbData;
            }

            err = RegQueryValueEx(  hMiniKey,
                                    szValue,
                                    0,
                                    &dwType,
                                    pBuffer,
                                    &cbData);

            if (err == 0)
            {
                pPacked = (PSerializedMiniAccount) pBuffer;

                if (pPacked->Version != MINI_VERSION)
                {
                    continue;
                }

                pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount));
                if (pAccount)
                {
                    pAccount->Flags = pPacked->Flags;
                    pAccount->IconId = pPacked->IconId;
                    pAccount->pszUsername = LocalAlloc(LMEM_FIXED, (cbValue+1)*sizeof(TCHAR));
                    if (pAccount->pszUsername)
                    {
                        wcscpy(pAccount->pszUsername, szValue);
                    }

                    pAccount->pszDomain = LocalAlloc(LMEM_FIXED, pPacked->dwDomainLength);
                    if (pAccount->pszDomain)
                    {
                        wcscpy(pAccount->pszDomain,
                               (PWSTR) ((pBuffer) + pPacked->dwDomainOffset) );
                    }

                    pAccount->pszPassword = LocalAlloc(LMEM_FIXED, pPacked->dwPasswordLength);
                    if (pAccount->pszPassword)
                    {
                        wcscpy(pAccount->pszPassword,
                               (PWSTR) (pBuffer + pPacked->dwPasswordOffset) );
                    }

                    pAccount->pszComment = LocalAlloc(LMEM_FIXED, pPacked->dwCommentLength);
                    if (pAccount->pszComment)
                    {
                        wcscpy(pAccount->pszComment,
                               (PWSTR) (pBuffer + pPacked->dwCommentOffset) );
                    }

                    pAccount->pNext = pAccountList;
                    pAccountList = pAccount;
                }
            }

        }

    }

    return(TRUE);
}

VOID
InitializeImageLists()
{
    HICON   hIcon;

    hiLogonSmall = ImageList_Create(16, 16, TRUE, 4, 0);
    hiLogonLarge = ImageList_Create(32, 32, TRUE, 4, 0);

    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_USER_ICON));
    if (!hIcon)
    {
        DebugLog((DEB_ERROR, "Unable to load icon, %d\n", GetLastError()));
    }
    ImageList_AddIcon(hiLogonLarge, hIcon);
    ImageList_AddIcon(hiLogonSmall, hIcon);

    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_NEW_USER_ICON));
    ImageList_AddIcon(hiLogonLarge, hIcon);
    ImageList_AddIcon(hiLogonSmall, hIcon);

}


PopulateListView(
    HWND            hLV,
    PMiniAccount    pAccList)
{
    LV_ITEM     lvi;
    LV_COLUMN   lvc;
    DWORD       Count;


    ListView_SetImageList(hLV, hiLogonLarge, LVSIL_NORMAL);
    ListView_SetImageList(hLV, hiLogonSmall, LVSIL_SMALL);

    //
    // Ok, now set up the columns for the list view
    //

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 0;

    lvc.iSubItem = 0;
    lvc.pszText = TEXT("Name        ");
    ListView_InsertColumn(hLV, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.pszText = TEXT("Domain   ");
    ListView_InsertColumn(hLV, 1, &lvc);
    //
    // Comment
    //

    lvc.iSubItem = 2;
    lvc.pszText = TEXT("Comment   ");
    ListView_InsertColumn(hLV, 2, &lvc);

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;


    Count = 0;
    while (pAccList)
    {
        lvi.iItem = Count;
        lvi.iSubItem  = 0;
        lvi.iImage = (pAccList->Flags & MINI_NEW_ACCOUNT) ? 1 : 0;
        lvi.pszText = pAccList->pszUsername;
        lvi.lParam = (LPARAM) pAccList;

        ListView_InsertItem(hLV, &lvi);

        ListView_SetItemText(hLV, Count, 1, pAccList->pszDomain);
        ListView_SetItemText(hLV, Count, 2, pAccList->pszComment);

        Count++;
        pAccList = pAccList->pNext;

    }

    return(TRUE);
}

INT_PTR
CALLBACK
NewUserDlgProc(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    PGlobals        pGlobals;
    PMiniAccount    pMini;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                pMini = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount));
                pMini->pszUsername = AllocAndCaptureText(hDlg, IDD_USER_NAME);
                pMini->pszDomain = AllocAndCaptureText(hDlg, IDD_DOMAIN);
                pMini->pszPassword = AllocAndCaptureText(hDlg, IDD_PASSWORD);
                pMini->pszComment = DupString(TEXT(""));
                pMini->Flags = MINI_SAVE | MINI_CAN_EDIT;
                pMini->IconId = 0;
                pMini->pNext = pAccountList;
                pAccountList = pMini;
                pGlobals->pAccount = pMini;
                EndDialog(hDlg, IDOK);
            }
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, IDCANCEL);
            }
            return(TRUE);
    }

    return(FALSE);

}

LogonDlgInit(
    HWND    hDlg,
    LPARAM  lParam)
{
    PGlobals        pGlobals;
    HWND            hLV;

    pGlobals = (PGlobals) lParam;
    SetWindowLong(hDlg, GWL_USERDATA, lParam);
    pGlobals->pAccount = NULL;

    if (pAccountList == NULL)
    {
        LoadMiniAccounts(pGlobals);
    }

    InitializeImageLists();

    hLV = GetDlgItem(hDlg, IDD_LOGON_LV);
    PopulateListView(hLV, pAccountList);

    CenterWindow(hDlg);

    ListView_SetColumnWidth(hLV, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hLV, 1, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hLV, 2, LVSCW_AUTOSIZE);

    ShowWindow(hLV, SW_NORMAL);
    EnableWindow(hLV, TRUE);
    EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), FALSE);

    return(TRUE);

}

int
HandleLvNotify(
    HWND        hDlg,
    PGlobals    pGlobals,
    NMHDR *     pNMH)
{
    NM_LISTVIEW *   pNotify;
    LV_ITEM         lvi;
    HWND            hLV;
    PMiniAccount *  ppAcc;
    int             ret;
    int             index;

    pNotify = (NM_LISTVIEW *) pNMH;

    hLV = GetDlgItem(hDlg, IDD_LOGON_LV);

    ppAcc = &pGlobals->pAccount;

    switch (pNotify->hdr.code)
    {
        case NM_CLICK:
        case NM_DBLCLK:
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), TRUE);

            index = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);
            if (index >= 0)
            {
                lvi.iItem = index;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;

                ret = ListView_GetItem(hLV, &lvi);
                *ppAcc = (PMiniAccount) lvi.lParam;
                DebugLog((DEB_TRACE, "Selected Item %d, lParam = %x\n", index, lvi.lParam));
            }

            if (pNotify->hdr.code == NM_DBLCLK)
            {
                PostMessage(hDlg, WM_COMMAND, IDOK, 0);
            }
            return(TRUE);

    }
    return(FALSE);

}

INT_PTR
CALLBACK
LogonDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    NMHDR *     pNotifyHeader;
    PGlobals    pGlobals;
    int         result;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            return(LogonDlgInit(hDlg, lParam));

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, WLX_SAS_ACTION_NONE);
            }
            if (LOWORD(wParam) == IDD_LOGON_BUTTON)
            {
                if (pGlobals->pAccount->Flags & MINI_NEW_ACCOUNT)
                {
                    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                            hDllInstance,
                                                            (LPTSTR) MAKEINTRESOURCE(IDD_NEW_USER_LOGON),
                                                            hDlg,
                                                            NewUserDlgProc,
                                                            (LPARAM) pGlobals);
                }
                else
                {
                    result = IDOK;
                }

                if (result == IDOK)
                {
                    EndDialog(hDlg, WLX_SAS_ACTION_LOGON);
                }
            }
            if (LOWORD(wParam) == IDD_SHUTDOWN_BUTTON)
            {
                result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                        hDllInstance,
                                                        (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
                                                        hDlg,
                                                        ShutdownDlgProc,
                                                        (LPARAM) pGlobals);
                if (result != WLX_SAS_ACTION_NONE)
                {
                    EndDialog(hDlg, result);
                }
            }
            return(TRUE);
            break;

        case WM_NOTIFY:
            pNotifyHeader = (NMHDR *) lParam;
            if (wParam == IDD_LOGON_LV)
            {
                return(HandleLvNotify(hDlg, pGlobals, pNotifyHeader));
            }
        case WM_CLOSE:
            hiLogonSmall = NULL;
            hiLogonLarge = NULL;
            return(TRUE);

    }

    return(FALSE);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

int
AttemptLogon(
    PGlobals        pGlobals,
    PMiniAccount    pAccount,
    PSID            pLogonSid,
    PLUID           pLogonId)
{
    HANDLE              hUser;
    TOKEN_STATISTICS    TStats;
    TOKEN_GROUPS    *   pGroups;
    DWORD               size;
    DWORD               i;

    if (LogonUser(  pAccount->pszUsername,
                    pAccount->pszDomain,
                    pAccount->pszPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &hUser))
    {
        if (pAccount->Flags & MINI_SAVE)
        {
            SaveMiniAccount(pAccount);
            pAccount->Flags &= ~MINI_SAVE;
        }

        pGlobals->hUserToken = hUser;

        //
        // Now, grovel the token we got back for interesting stuff:
        //

        GetTokenInformation(hUser,
                            TokenStatistics,
                            &TStats,
                            sizeof(TStats),
                            &size);

        *pLogonId = TStats.AuthenticationId;

        pGroups = LocalAlloc(LMEM_FIXED, 1024);

        if (!pGroups)
        {
            CloseHandle(hUser);
            return(WLX_SAS_ACTION_NONE);
        }

        //
        // The tricky part.  We need to get the Logon SID from the token,
        // since that is what Winlogon will use to protect the windowstation
        // and desktop.
        //

        GetTokenInformation(hUser,
                            TokenGroups,
                            pGroups,
                            1024,
                            &size);

        if (size > 1024)
        {
            pGroups = LocalReAlloc(pGroups, LMEM_FIXED, size);
            GetTokenInformation(hUser,
                                TokenGroups,
                                pGroups,
                                size,
                                &size);
        }

        for (i = 0; i < pGroups->GroupCount ; i++)
        {
            if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == SE_GROUP_LOGON_ID)
            {
                CopySid(GetLengthSid(pLogonSid),
                        pLogonSid,
                        pGroups->Groups[i].Sid );
                break;
            }
        }

        LocalFree(pGroups);

        return(WLX_SAS_ACTION_LOGON);
    }

    return(WLX_SAS_ACTION_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by res.rc
//
#define IDD_WELCOME_DIALOG              101
#define IDD_LOGON_DIALOG                102
#define IDD_LOGON_LV                    1001
#define IDD_LOGON                       1002
#define IDD_SHUTDOWN                    1003
#define IDD_WELCOME_TEXT                -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\resids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       resids.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------


#define IDI_USER_ICON       10
#define IDI_NEW_USER_ICON   11
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


int
CALLBACK
WelcomeDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
LogonDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
ShutdownDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
OptionsDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
CenterWindow(
    HWND    hwnd
    );

int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons);

int
AttemptLogon(
    PGlobals        pGlobals,
    PMiniAccount    pAccount,
    PSID            pLogonSid,
    PLUID           pLogonId);

PWSTR
AllocAndCaptureText(
    HWND    hDlg,
    int     Id);

PWSTR
DupString(
    PWSTR   pszText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\options.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       options.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

typedef
NET_API_STATUS (NET_API_FUNCTION * NUCP)(LPWSTR, LPWSTR, LPWSTR, LPWSTR);

NUCP    NetUserChangePasswordFn = NULL;
HMODULE hNetApi32;

BOOL
LoadNetapi(HWND hDlg)
{
    hNetApi32 = LoadLibrary(TEXT("netapi32.dll"));
    if (hNetApi32)
    {
        NetUserChangePasswordFn = (NUCP) GetProcAddress(hNetApi32, "NetUserChangePassword");
        if (NetUserChangePasswordFn)
        {
            return(TRUE);
        }
    }

    ErrorMessage(hDlg, TEXT("Change Password"), MB_ICONSTOP | MB_OK);

    return(FALSE);

}

PWSTR
AllocAndCaptureText(
    HWND    hDlg,
    int     Id)
{
    WCHAR   szTemp[MAX_PATH];
    PWSTR   New;
    DWORD   cb;

    cb = GetDlgItemText(hDlg, Id, szTemp, MAX_PATH);
    New = LocalAlloc(LMEM_FIXED, (cb + 1) * sizeof(WCHAR));
    if (New)
    {
        wcscpy(New, szTemp);
    }
    return(New);
}

PWSTR
DupString(
    PWSTR   pszText)
{
    PWSTR   New;
    DWORD   cb;

    cb = (wcslen(pszText) + 1) * sizeof(WCHAR);
    New = LocalAlloc(LMEM_FIXED, cb);

    if (New)
    {
        wcscpy(New, pszText);
    }

    return(New);
}

BOOL
TryToChangePassword(
    HWND        hDlg,
    PGlobals    pGlobals)
{
    PWSTR   pszUsername;
    PWSTR   pszDomain;
    PWSTR   pszOld;
    PWSTR   pszNew;
    PWSTR   pszTemp;

    NET_API_STATUS  NetStatus;

    if (!NetUserChangePasswordFn)
    {
        if (!LoadNetapi(hDlg))
        {
            return(FALSE);
        }
    }

    pszUsername = AllocAndCaptureText(hDlg, IDD_USER_NAME);
    pszDomain = AllocAndCaptureText(hDlg, IDD_DOMAIN);
    pszOld = AllocAndCaptureText(hDlg, IDD_OLD_PASSWORD);
    pszNew = AllocAndCaptureText(hDlg, IDD_NEW_PASSWORD);

    if (!pszUsername || !pszDomain || !pszOld || !pszNew)
    {
        goto clean_exit;
    }

    pszTemp = AllocAndCaptureText(hDlg, IDD_CONFIRM_PASSWORD);
    if (wcscmp(pszNew, pszTemp))
    {
        LocalFree(pszTemp);
        MessageBox(hDlg, TEXT("Your passwords did not match."), TEXT("Change Password"),
                        MB_ICONSTOP | MB_OK);
        goto clean_exit;
    }

    NetStatus = NetUserChangePasswordFn(pszDomain, pszUsername, pszOld, pszNew);
    if (NetStatus != NERR_Success)
    {
        SetLastError(NetStatus);
        ErrorMessage(hDlg, TEXT("Change Password"), MB_ICONSTOP | MB_OK);
    }
    else
        MessageBox(hDlg, TEXT("Your password was changed successfully"),
                    TEXT("Change Password"), MB_ICONINFORMATION | MB_OK);

clean_exit:
    if (pszUsername)
    {
        LocalFree(pszUsername);
    }
    if (pszDomain)
    {
        LocalFree(pszDomain);
    }
    if (pszOld)
    {
        LocalFree(pszOld);
    }
    if (pszNew)
    {
        LocalFree(pszNew);
    }

    return(NetStatus == NERR_Success);
}

int
CALLBACK
ChangePasswordDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (TryToChangePassword(hDlg, pGlobals))
                {
                    SetWindowText(GetDlgItem(hDlg, IDCANCEL), TEXT("Done"));
                }
                SetDlgItemText(hDlg, IDD_OLD_PASSWORD, TEXT(""));
                SetDlgItemText(hDlg, IDD_NEW_PASSWORD, TEXT(""));
                SetDlgItemText(hDlg, IDD_CONFIRM_PASSWORD, TEXT(""));
                SetFocus(GetDlgItem(hDlg, IDD_OLD_PASSWORD));

                return(TRUE);
            }
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, 0);
                return(TRUE);
            }

    }
    return(FALSE);
}



int
CALLBACK
ConfigDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            pGlobals = (PGlobals) lParam;

            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);

            CheckDlgButton(hDlg, IDD_NO_NEW_USERS, !pGlobals->fAllowNewUser);

            CheckDlgButton(hDlg, IDD_AUTO_LOGON,
                    (pGlobals->pAccount->Flags & MINI_AUTO_LOGON) ? 1 : 0 );

            return(TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    pGlobals->fAllowNewUser = !IsDlgButtonChecked(hDlg, IDD_NO_NEW_USERS);
                    if (IsDlgButtonChecked(hDlg, IDD_AUTO_LOGON))
                    {
                        pGlobals->pAccount->Flags |= MINI_AUTO_LOGON;
                    }
                    else
                    {
                        pGlobals->pAccount->Flags &= ~MINI_AUTO_LOGON;
                    }
                    EndDialog(hDlg, IDOK);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return(TRUE);

            }
    }

    return(FALSE);

}

int
InitOptionsDialog(
    HWND        hDlg,
    LPARAM      lParam)
{
    CenterWindow(hDlg);
    SetWindowLong(hDlg, GWL_USERDATA, lParam);

    return(1);
}



int
CALLBACK
OptionsDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;
    int         result;


    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);

    switch (Message)
    {
        case WM_INITDIALOG:
            return InitOptionsDialog(hDlg, lParam);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hDlg, WLX_SAS_ACTION_NONE);
                    return(TRUE);

                case IDD_LOCK_BUTTON:
                    EndDialog(hDlg, WLX_SAS_ACTION_LOCK_WKSTA);
                    return(TRUE);

                case IDD_TASK_BUTTON:
                    EndDialog(hDlg, WLX_SAS_ACTION_TASKLIST);
                    return(TRUE);

                case IDD_OPTIONS_EXIT:
                    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                        hDllInstance,
                                                        (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
                                                        hDlg,
                                                        ShutdownDlgProc,
                                                        (LONG) pGlobals);
                    if (result != WLX_SAS_ACTION_NONE)
                    {
                        EndDialog(hDlg, result);
                    }
                    return(TRUE);

                case IDD_PASSWORD_BUTTON:
                    pWlxFuncs->WlxDialogBoxParam(   hGlobalWlx,
                                                    hDllInstance,
                                                    (LPTSTR) MAKEINTRESOURCE(IDD_CHANGE_PASSWORD),
                                                    hDlg,
                                                    ChangePasswordDlgProc,
                                                    (LONG) pGlobals);
                    return(TRUE);

                case IDD_CONFIG_BUTTON:
                    pWlxFuncs->WlxDialogBoxParam(   hGlobalWlx,
                                                    hDllInstance,
                                                    (LPTSTR) MAKEINTRESOURCE(IDD_LOGON_CONFIG),
                                                    hDlg,
                                                    ConfigDlgProc,
                                                    (LONG) pGlobals);
                    return(TRUE);

            }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\structs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       structs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


typedef struct _MiniAccount {
    struct _MiniAccount *   pNext;
    PWSTR                   pszUsername;
    PWSTR                   pszDomain;
    PWSTR                   pszPassword;
    PWSTR                   pszComment;
    DWORD                   IconId;
    DWORD                   Flags;
} MiniAccount, * PMiniAccount;

typedef struct _SerializedMiniAccount {
    DWORD                   Version;
    DWORD                   dwDomainOffset;
    DWORD                   dwDomainLength;
    DWORD                   dwPasswordOffset;
    DWORD                   dwPasswordLength;
    DWORD                   dwCommentOffset;
    DWORD                   dwCommentLength;
    DWORD                   Flags;
    DWORD                   IconId;
} SerializedMiniAccount, * PSerializedMiniAccount;

#define MINI_VERSION            0

#define MINI_PASSWORD_REQUIRED  0x00000001
#define MINI_PASSWORD_ALWAYS    0x00000002
#define MINI_NEW_ACCOUNT        0x00000004
#define MINI_CAN_EDIT           0x00000008
#define MINI_AUTO_LOGON         0x00000010
#define MINI_SAVE               0x00000020


typedef struct _Globals {
    BOOL                    fAllowNewUser;
    BOOL                    fAutoLogonAtBoot;
    BOOL                    fAutoLogonAlways;
    HANDLE                  hUserToken;
    PMiniAccount            pAccount;
} Globals, * PGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\shutdown.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       shutdown.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

WCHAR   szShutdownSettingPath[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Shutdown");
int
ShutdownDialogInit(
    HWND        hDlg,
    LPARAM      lParam)
{
    PGlobals    pGlobals;
    HKEY        hKey;
    DWORD       dwValue;
    DWORD       dwSize;
    DWORD       dwType;
    DWORD       PowerOff;

    pGlobals = (PGlobals) lParam;

    SetWindowLong(hDlg, GWL_USERDATA, lParam);

    PowerOff = GetProfileInt(TEXT("Winlogon"), TEXT("PowerDownAfterShutdown"), 0);

    if (pGlobals->hUserToken)
    {
        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            dwValue = 0;

            if (!RegOpenKey(HKEY_CURRENT_USER,
                            szShutdownSettingPath,
                            &hKey))
            {
                dwSize = sizeof(DWORD);
                RegQueryValueEx(hKey, TEXT("Shutdown Setting"), 0, &dwType, (PBYTE) &dwValue, &dwSize);
                RegCloseKey(hKey);
            }

            RevertToSelf();
        }
    }

    if (!PowerOff)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_CONFIRM_POWEROFF), SW_HIDE);
    }

    if (!pGlobals->hUserToken)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_CONFIRM_LOGOFF), SW_HIDE);
    }

    switch (dwValue)
    {
        case 0:
            if (pGlobals->hUserToken)
            {
                CheckDlgButton(hDlg, IDD_CONFIRM_LOGOFF, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_LOGOFF));
                break;
            }

        case 2:
            CheckDlgButton(hDlg, IDD_CONFIRM_REBOOT, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_REBOOT));
            break;
        case 3:
            if (PowerOff)
            {
                CheckDlgButton(hDlg, IDD_CONFIRM_POWEROFF, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_POWEROFF));
                break;
            }
        default:
            CheckDlgButton(hDlg, IDD_CONFIRM_SHUTDOWN, 1);
            SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_SHUTDOWN));

    }

    CenterWindow(hDlg);

    SetFocus(GetDlgItem(hDlg, IDOK));

    return(1);

}

VOID
UpdateShutdownSettings(
            PGlobals    pGlobals,
            DWORD       Setting)
{
    // int err;
    HKEY    hKey;
    DWORD   Actual;

    switch (Setting)
    {
        default:
        case IDD_CONFIRM_LOGOFF:
            Actual = 0;
            break;

        case IDD_CONFIRM_SHUTDOWN:
            Actual = 1;
            break;

        case IDD_CONFIRM_REBOOT:
            Actual = 2;
            break;

        case IDD_CONFIRM_POWEROFF:
            Actual = 3;
            break;
    }


    if (pGlobals->hUserToken)
    {
        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            if (!RegOpenKey(HKEY_CURRENT_USER,
                            szShutdownSettingPath,
                            &hKey))
            {
                RegSetValueEx(  hKey,
                                TEXT("Shutdown Setting"),
                                0,
                                REG_DWORD,
                                (PBYTE) &Actual,
                                sizeof(DWORD) );
                RegCloseKey(hKey);
            }

            RevertToSelf();
        }
    }

}

int
CALLBACK
ShutdownDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    switch (Message)
    {
        case WM_INITDIALOG:
            return(ShutdownDialogInit(hDlg, lParam));

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, WLX_SAS_ACTION_NONE);
            }
            if (LOWORD(wParam) == IDOK)
            {
                pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);

                if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_LOGOFF))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_LOGOFF);
                    EndDialog(hDlg, WLX_SAS_ACTION_LOGOFF);
                }
                else if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_REBOOT))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_REBOOT);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN_REBOOT);
                }
                else if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_POWEROFF))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_POWEROFF);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
                }
                else
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_SHUTDOWN);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN);
                }

            }
            return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       util.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

HMODULE hNetMsg = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   CenterWindow
//
//  Synopsis:   Centers a window
//
//  Arguments:  [hwnd] --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CenterWindow(
    HWND    hwnd
    )
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOPMOST, rect.left, rect.top, 0, 0, SWP_NOSIZE);

    SetForegroundWindow(hwnd);
}


int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons)
{
    WCHAR   szMessage[256];
    DWORD   GLE;

    GLE = GetLastError();

    if (GLE >= NERR_BASE)
    {
        if (!hNetMsg)
        {
            hNetMsg = LoadLibrary(TEXT("netmsg.dll"));
        }
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
            hNetMsg,                               // ignored
            GLE,                                  // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    }

    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,                               // ignored
            (GetLastError()),                     // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    return(MessageBox(hWnd, szMessage, pszTitleBar, Buttons));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gpext2\gpext.c ===
#include <windows.h>
#include <userenv.h>
#include "events.h"

//
//  This is a simple client side extension that reads its return value from the
//  registry and exits.  The registry value it reads is controlled via the gpext.adm
//  file in this directory.
//



#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{febf1209-8aff-11d2-a8a1-00c04fbbcfa2}")
#define GPEXT_NAME   TEXT("Sample CSE")



BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


DWORD ProcessGroupPolicy ( DWORD   dwFlags,
                           HANDLE  hToken,
                           HKEY    hKeyRoot,
                           PGROUP_POLICY_OBJECT   pDeletedGPOList,
                           PGROUP_POLICY_OBJECT   pChangedGPOList,
                           ASYNCCOMPLETIONHANDLE  pHandle,
                           BOOL*   pbAbort,
                           PFNSTATUSMESSAGECALLBACK pStatusCallback )
{
    HKEY hKey;
    DWORD dwResult = ERROR_SUCCESS, dwSize, dwType;
    TCHAR szMsg[100] = {0};
    TCHAR szMsg2[100] = {0};
    HANDLE  hEventLog;
    LPTSTR szStrings[2] = {0,0};

    if (RegOpenKeyEx (hKeyRoot, TEXT("Software\\Policies\\Microsoft\\Windows\\SampleCSE"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwResult);

        RegQueryValueEx (hKey, TEXT("ReturnValue"), NULL, &dwType, (LPBYTE) &dwResult, &dwSize);

        if (dwResult != ERROR_SUCCESS)
        {
            dwSize = sizeof(szMsg);
            RegQueryValueEx (hKey, TEXT("EventMsg1"), NULL, &dwType, (LPBYTE) szMsg, &dwSize);

            dwSize = sizeof(szMsg2);
            RegQueryValueEx (hKey, TEXT("EventMsg2"), NULL, &dwType, (LPBYTE) szMsg2, &dwSize);
        }

        RegCloseKey (hKey);
    }


    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Put message in event log
        //

        hEventLog = RegisterEventSource(NULL, TEXT("gpext"));

        if (hEventLog)
        {

            szStrings[0] = szMsg;
            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0,
                        szStrings, NULL);

            szStrings[0] = szMsg2;
            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0,
                        szStrings, NULL);


            DeregisterEventSource(hEventLog);
        }
    }

    wsprintf (szMsg, TEXT("SampleCSE:  returning 0x%x\r\n"), dwResult);
    OutputDebugString (szMsg);

    return dwResult;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPEXT_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)GPEXT_NAME,
                   (lstrlen(GPEXT_NAME) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                   (lstrlen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);



    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\gpext"), 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, TEXT("EventMessageFile"), 0, REG_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 7;
    RegSetValueEx (hKey, TEXT("TypesSupported"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));


    RegCloseKey (hKey);


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);
    RegDeleteKey (HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\gpext"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gina\welcome.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       welcome.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"


int
CALLBACK
WelcomeDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                pWlxFuncs->WlxSasNotify(hGlobalWlx, GINA_SAS_1);
            }
            return(TRUE);

        default:
            return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gpext\gpext.c ===
#include <windows.h>
#include <userenv.h>

//
//  Some helpful tips about group policy extensions
//
//  1)  You will be called in the LocalSystem's context
//      If you need to access the net, you'll need to impersonate
//      the user via the hToken passed in.
//
//



#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{febf1208-8aff-11d2-a8a1-00c04fbbcfa2}")
#define GPEXT_NAME   TEXT("Group Policy client side extension sample")



BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


DWORD ProcessGroupPolicy ( DWORD   dwFlags,
                           HANDLE  hToken,
                           HKEY    hKeyRoot,
                           PGROUP_POLICY_OBJECT   pDeletedGPOList,
                           PGROUP_POLICY_OBJECT   pChangedGPOList,
                           ASYNCCOMPLETIONHANDLE  pHandle,
                           BOOL*   pbAbort,
                           PFNSTATUSMESSAGECALLBACK pStatusCallback )
{
    PGROUP_POLICY_OBJECT pCurGPO;

    if (dwFlags & GPO_INFO_FLAG_MACHINE)
        OutputDebugString (TEXT("GPEXT:  Machine GPO\r\n"));

    if (dwFlags & GPO_INFO_FLAG_BACKGROUND)
        OutputDebugString (TEXT("GPEXT:  Background processing of GPO\r\n"));

    if (dwFlags & GPO_INFO_FLAG_SLOWLINK)
        OutputDebugString (TEXT("GPEXT:  Policy is being applied across a slow link.\r\n"));

    if (dwFlags & GPO_INFO_FLAG_VERBOSE)
        OutputDebugString (TEXT("GPEXT:  Verbose policy logging is requested (to the eventlog).\r\n"));

    if (dwFlags & GPO_INFO_FLAG_NOCHANGES)
        OutputDebugString (TEXT("GPEXT:  No changes where detected in this series of GPOs.  Policy should be refreshed as quickly as possible.\r\n"));

    if (dwFlags & GPO_INFO_FLAG_LINKTRANSITION)
        OutputDebugString (TEXT("GPEXT:  Link speed transition (either slow to fast or fast to slow)\r\n"));

    //
    // Process list of deleted GPOs
    //

    OutputDebugString (TEXT("GPEXT:  Processing deleted GPO list\n"));

    for (pCurGPO = pDeletedGPOList; pCurGPO; pCurGPO = pCurGPO->pNext)
    {
        if ( *pbAbort )
        {
            OutputDebugString (TEXT("GPEXT:  Aborting further processing\n"));
            break;
        }

        OutputDebugString (pCurGPO->lpDisplayName);
        OutputDebugString (TEXT(" aka "));
        OutputDebugString (pCurGPO->szGPOName);
        OutputDebugString (TEXT(".\r\n"));
    }

    //
    // Process list of changed GPOs
    //

    OutputDebugString (TEXT("GPEXT:  Processing changed GPO list\n"));

    for (pCurGPO = pChangedGPOList; pCurGPO; pCurGPO = pCurGPO->pNext)
    {
        if ( *pbAbort )
        {
            OutputDebugString (TEXT("GPEXT:  Aborting further processing\n"));
            break;
        }

        OutputDebugString (pCurGPO->lpDisplayName);
        OutputDebugString (TEXT(" aka "));
        OutputDebugString (pCurGPO->szGPOName);
        OutputDebugString (TEXT(".\r\n"));
    }

    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPEXT_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)GPEXT_NAME,
                   (lstrlen(GPEXT_NAME) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                   (lstrlen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\compdata.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentData::CComponentData()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
}

CComponentData::~CComponentData()
{
    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<long*>(bmp16x16),
                      reinterpret_cast<long*>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(long cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPTDATAOBJECT pGPTDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPTDataObject->SetType(type);
    pGPTDataObject->SetCookie(cookie);
    pGPTDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (!m_pGPTInformation)
                {
                    lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                }

                if (m_pGPTInformation)
                {
                    hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == NUM_NAMESPACE_ITEMS)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    LONG cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_GPTDemoSnapIn;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = item.lParam;
    }

    for (i = 0; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 1;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_GPTDemoSnapIn)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\dataobj.h ===
//
// IGPTDataobject interface id
//

// {C14C50E2-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(IID_IGPTDataObject,0xc14c50e2, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);




#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPTDataObject
DECLARE_INTERFACE_(IGPTDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPTDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ long cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ long *cookie) PURE;
};
typedef IGPTDataObject *LPGPTDATAOBJECT;



//
// CDataObject class
//

class CDataObject : public IDataObject,
                    public IGPTDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    LONG                   m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;



public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IGPTDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (LONG cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (LONG *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\compdata.h ===
//
// CComponentData class
//

class CComponentData:
    public IComponentData,
    public IPersistStreamInit
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                m_cRef;
    HWND		 m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
};



//
// ComponentData class factory
//


class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\layout.h ===
#define NUM_NAMESPACE_ITEMS       2
#define MAX_DISPLAYNAME_SIZE    100


typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;


extern RESULTITEM g_Root[];
extern RESULTITEM g_Undefined[];
extern NAMESPACEITEM g_NameSpace[];

BOOL InitNameSpace();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "main.h"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTDemo[] = TEXT("GPTDEMO(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPTDemoDebugLevel")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szGPTDemo, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("c:\\GPTDemo.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\dataobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPTDataObject))
    {
        *ppv = (LPGPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[100];

    LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPTDemoSnapIn, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\gptdemo.cpp ===
#include "main.h"
#include <initguid.h>
#include <gptdemo.h>
#include <gpedit.h>


//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
#if DBG
       InitDebugSupport();
#endif
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return (CreateComponentDataClassFactory (rclsid, riid, ppv));
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\GPTDemo.dll");

STDAPI DllRegisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;


    StringFromGUID2 (CLSID_GPTDemoSnapIn, szSnapInKey, 50);

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szSnapInLocation,
                   (lstrlen(szSnapInLocation) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register in the NodeTypes key
    //

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (NODEID_User, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    DWORD dwIndex;
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    StringFromGUID2 (CLSID_GPTDemoSnapIn, szSnapInKey, 50);

    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }


    StringFromGUID2 (NODEID_User, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\gptdemo.h ===
//-----------------------------------------------------------------------------
//
// gptdemo.h - Definitions and prototypes for the GPTDEMO.DLL
//
// Copyright 1997, Microsoft Corporation
//
//-----------------------------------------------------------------------------


//
// Group Policy Editor Demo SnapIn extension GUID
//

// {C14C50E0-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(CLSID_GPTDemoSnapIn, 0xc14c50e0, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);



//
// Group Policy Editor node ids
//

// {C14C50E1-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(NODEID_GPTDemoRoot, 0xc14c50e1, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);


//
// User Interface Policy
//

// {81244660-FF22-11d0-8D04-248D0B000000}
DEFINE_GUID(NODEID_Samples, 0x81244660, 0xff22, 0x11d0, 0x8d, 0x4, 0x24, 0x8d, 0xb, 0x0, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\layout.cpp ===
#include "main.h"


//
//  This file contains the tool's namespace and result pane items
//


//
// Result pane items for the nodes with no result pane items
//

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


//
// Result pane items for the Samples node
//

RESULTITEM g_Samples[] =
{
    { 2, 1, IDS_README, 4, {0} },
    { 3, 1, IDS_APPEAR, 7, {0} }
};




//
// Namespace (scope) items
//
// Be sure to update NUM_NAMESPACE_ITEMS define in layout.h if you
// add / remove from this array.
//

NAMESPACEITEM g_NameSpace[] =
{
    { 0, -1, 0,          0, {0}, 0, g_Undefined, &NODEID_User },   // Root
    { 1, 0, IDS_SAMPLES, 0, {0}, 2, g_Samples,   &NODEID_Samples }
};


BOOL InitNameSpace()
{
    DWORD dwIndex;

    for (dwIndex = 1; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                    g_NameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\util.cpp ===
#include "main.h"
#define  PCOMMON_IMPL
#include "pcommon.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    lstrcpy (szDelKey, lpSubKey);


    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\main.h ===
#include <windows.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <mmc.h>
#include <gpedit.h>
#include <gptdemo.h>

class CSnapIn;

#include "layout.h"
#include "compdata.h"
#include "snapin.h"
#include "dataobj.h"
#include "debug.h"
#include "util.h"
#include "pcommon.h"


//
// Resource ids
//

#define IDS_SNAPIN_NAME          1
#define IDS_NAME                 2
#define IDS_POLICY               3
#define IDS_DISPLAY              4
#define IDS_SAMPLES              5
#define IDS_README               8
#define IDS_APPEAR              19


//
// Icons
//

#define IDI_POLICY               1
#define IDI_README               2
#define IDI_APPEAR               7


//
// Bitmaps
//

#define IDB_16x16                1
#define IDB_32x32                2


//
// Dialogs
//


#define IDD_README             150

#define IDD_APPEAR             600
#define IDC_RED                601
#define IDC_GREEN              602
#define IDC_BLUE               603
#define IDC_BLACK              604
#define IDC_GRAY               605
#define IDC_DEFAULT            606
#define IDC_WALLPAPER          607
#define IDC_TILE               608
#define IDC_CENTER             609


//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//
// Functions to create class factories
//

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\notify\notify.c ===
#include <windows.h>
#include <winwlx.h>

//
//  Some helpful tips about winlogon's notify events
//
//  1)  The logoff and shutdown notifications are always done
//      synchronously regardless of the Asynchronous registry entry.
//
//  2)  If you need to spawn child processes, you have to use
//      CreateProcessAsUser() otherwise the process will start
//      on winlogon's desktop (not the user's)
//
//  3)  The logon notification comes before the user's network
//      connections are restored.  If you need the user's persisted
//      net connections, use the StartShell event.
//
//  4)  Don't put any UI up during either screen saver event.
//      These events are intended for background processing only.
//



#define NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\notify")


BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


VOID WLEventLogon (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLogon.\r\n"));
}

VOID WLEventLogoff (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLogff.\r\n"));
}

VOID WLEventStartup (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartup.\r\n"));
}

VOID WLEventShutdown (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventShutdown.\r\n"));
}

VOID WLEventStartScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartScreenSaver.\r\n"));
}

VOID WLEventStopScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStopScreenSaver.\r\n"));
}

VOID WLEventLock (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLock.\r\n"));
}

VOID WLEventUnlock (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventUnlock.\r\n"));
}

VOID WLEventStartShell (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartShell.\r\n"));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwTemp;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, NOTIFY_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("Logon"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogon"),
                   (lstrlen(TEXT("WLEventLogon")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Logoff"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogoff"),
                   (lstrlen(TEXT("WLEventLogoff")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Startup"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartup"),
                   (lstrlen(TEXT("WLEventStartup")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Shutdown"), 0, REG_SZ, (LPBYTE)TEXT("WLEventShutdown"),
                   (lstrlen(TEXT("WLEventShutdown")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartScreenSaver"),
                   (lstrlen(TEXT("WLEventStartScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StopScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStopScreenSaver"),
                   (lstrlen(TEXT("WLEventStopScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Lock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLock"),
                   (lstrlen(TEXT("WLEventLock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Unlock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventUnlock"),
                   (lstrlen(TEXT("WLEventUnlock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartShell"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartShell"),
                   (lstrlen(TEXT("WLEventStartShell")) + 1) * sizeof(TCHAR));

    dwTemp = 0;
    RegSetValueEx (hKey, TEXT("Impersonate"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    dwTemp = 1;
    RegSetValueEx (hKey, TEXT("Asynchronous"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("notify.dll"),
                   (lstrlen(TEXT("notify.dll")) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, NOTIFY_PATH);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\sethc\access.c ===
/****************************** Module Header ******************************\
* Module Name: access.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* Accessibility notification dialogs
*
* History:
* 02-01-97  Fritz Sands   Created
\***************************************************************************/

#include <stdio.h>
#include <wtypes.h>
#include "dialogs.h"
#include <winuserp.h>
#include <oleacc.h>
#pragma hdrstop

/*
 * Notification Dialog Stuff
 */
 
extern HINSTANCE  g_hInstance;

#define cchBuf 1024                       // plenty of room for title
#define cchTitle 128
typedef struct tagACCESSINFO {
    UINT  Feature;
    UINT  TitleID;
    HANDLE hDesk;
    WCHAR  wcTitle[cchTitle];
} ACCESSINFO, *PACCESSINFO;

#define NOTIF_KEY                __TEXT("Control Panel\\Accessibility")
#define NOTIFY_VALUE   __TEXT("Warning Sounds")

#define HOTKEYCODE                    100

#define ID_STICKYKEYNAME    NOTIF_KEY __TEXT("\\StickyKeys")
#define ID_TOGGLEKEYS       NOTIF_KEY __TEXT("\\ToggleKeys")
#define ID_HIGHCONTROST     NOTIF_KEY __TEXT("\\HighContrast")
#define ID_MOUSEKEYS        NOTIF_KEY __TEXT("\\MouseKeys")
#define ID_SERIALKEYS       NOTIF_KEY __TEXT("\\SerialKeys")

/***************************************************************************
 *                                                                         *
 * ConfirmHandler_InitDialog                                               *
 *                                                                         *
 * Input: hWnd = dialog window handle                                      *
 *                  uiTitle = resource ID of dialog box title              *
 *                  uiTitle+1 through uiTitle+n = resource ID of dialog box text *
 * Output: Returns TRUE on success, FALSE on failure.                      *
 *                                                                         *
 ***************************************************************************/

BOOL ConfirmHandler_InitDialog(HWND hWnd, HDESK hDesk, UINT uiTitle, WCHAR *pszTitle) {
    RECT    rc;   // Current window size
    WCHAR *pszBuf;
    WCHAR *pszNext;
    int cchBufLeft;
    int cchHelpText;
    int fSuccess = 0;
    WCHAR szDesktop[MAX_PATH];
    DWORD Len1 = MAX_PATH;
    BOOL b;

    szDesktop[0] = 0;
    b = GetUserObjectInformation(hDesk, UOI_NAME, szDesktop, MAX_PATH, &Len1);
    SetWindowText(hWnd, pszTitle);                                    // Init title bar

    pszBuf = (WCHAR *)LocalAlloc(LMEM_FIXED, cchBuf * sizeof (WCHAR));
    if (!pszBuf) goto Exit;

    pszNext = pszBuf; cchBufLeft = cchBuf;
    while (cchHelpText = LoadString(g_hInstance, ++uiTitle, pszNext, cchBufLeft)) {
        pszNext += cchHelpText;
        cchBufLeft -= cchHelpText;
    }

    SetDlgItemText(hWnd, ID_HELPTEXT, pszBuf);       // Init help text

    if (b && (0 == wcscmp(szDesktop,L"Winlogon"))) {
        EnableWindow(GetDlgItem(hWnd, IDHELP), FALSE);

    }

// Make us a topmost window and center ourselves.

    GetWindowRect(hWnd, &rc);                                               // Get size of dialog

// Center dialog and make it topmost
    SetWindowPos(hWnd,
                 HWND_TOPMOST,
                 (GetSystemMetrics(SM_CXFULLSCREEN)/2) - (rc.right - rc.left)/2,
                 (GetSystemMetrics(SM_CYFULLSCREEN)/2) - (rc.bottom - rc.top)/2,
                 0,0, SWP_NOSIZE );

       // Make sure we're active!
// Lets try setting this to be the foreground window.
    // SetForegroundWindow(hWnd);


    // SetForgroundWindow will not work because we are not the forground task.  So use accSelect
	if ( hWnd )
	{
		IAccessible *pAcc = NULL;
		VARIANT varChild;

		varChild.vt = VT_I4;
		varChild.lVal = 0;
		
		if ( AccessibleObjectFromWindow( hWnd, OBJID_CLIENT, &IID_IAccessible, (void**)&pAcc ) == S_OK )
		{
			if ( pAcc )
			    pAcc->lpVtbl->accSelect( pAcc, SELFLAG_TAKEFOCUS, varChild );
		}
	}
	
	
    fSuccess = 1;

    LocalFree((HLOCAL)pszBuf);
Exit:
    return fSuccess;
}

/***************************************************************************
 *                                                                         *
 *                                                                         *
 * ConfirmHandler                                                          *
 *                                                                         *
 * Input: Std Window messages                                              *
 * Output: IDOK if success, IDCANCEL if we should abort                    *
 *                                                                         *
 *                                                                         *
 * Put up the main dialog to tell the user what is happening and to get    *
 * permission to continue.                                                 *
 ***************************************************************************/


INT_PTR CALLBACK ConfirmHandler(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR       buf[100];
    WCHAR       szRundll[] = L"rundll32.exe";
    WCHAR       szDesktop[MAX_PATH];
    DWORD       Len1, Len2;
    PACCESSINFO pAccessInfo;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO si;

    GetStartupInfo(&si);

    switch(message) {
    case WM_INITDIALOG:
       SetWindowLongPtr(hWnd, DWLP_USER, lParam);
       pAccessInfo = (PACCESSINFO)lParam;
       
       return ConfirmHandler_InitDialog(hWnd, pAccessInfo->hDesk, pAccessInfo->TitleID, pAccessInfo->wcTitle);

    case WM_COMMAND:
       pAccessInfo = (PACCESSINFO)GetWindowLongPtr(hWnd, DWLP_USER);

       switch (LOWORD(wParam)) {
       case IDOK:
       case IDCANCEL:
            EndDialog(hWnd, LOWORD(wParam));

            return TRUE;

       case IDHELP:
            // IDHELP (Settings... really) dismisses dialog with no changes
            EndDialog(hWnd, IDCANCEL);

//
// Spawn the correct help
//
            lstrcpy(buf,L" Shell32.dll,Control_RunDLL access.cpl,,");
            switch (pAccessInfo->Feature) {
            case ACCESS_STICKYKEYS:
            case ACCESS_FILTERKEYS:
            case ACCESS_TOGGLEKEYS:
            default:
                 lstrcat(buf,L"1");
                 break;

            case ACCESS_MOUSEKEYS:
                 lstrcat(buf,L"4");
                 break;

            case ACCESS_HIGHCONTRAST:
                 lstrcat(buf,L"3");
                 break;
            }

			CreateProcess( szRundll, buf, NULL, NULL, FALSE, 0, NULL, NULL, &si, &ProcessInfo );

            return TRUE;
            break;

       default:
            return FALSE;
       }
       break;
    
    default:
       // fall thru rather than return FALSE to keep compiler happy
       break;
    }
    return FALSE;
}

DWORD MakeAccessDlg(PACCESSINFO pAccessInfo) {
    DWORD iRet = 0;
    HDESK  hDeskOld;

    hDeskOld = GetThreadDesktop(GetCurrentThreadId());
    if (hDeskOld == NULL) return 0;

    pAccessInfo->hDesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (pAccessInfo->hDesk == NULL) return 0;

    if (LoadString(g_hInstance, pAccessInfo->TitleID, pAccessInfo->wcTitle, cchTitle)) {
        SetThreadDesktop(pAccessInfo->hDesk);
        if (!FindWindowEx(GetDesktopWindow(), NULL, (LPCTSTR)0x8002, pAccessInfo->wcTitle)) {
            iRet = (DWORD)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(DLG_CONFIRM), NULL, ConfirmHandler, (LPARAM)pAccessInfo);
        }
        SetThreadDesktop(hDeskOld);
    }
    CloseDesktop(pAccessInfo->hDesk);

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI StickyKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    STICKYKEYS sticky;
    DWORD dwS;
    BOOL b;

    AccessInfo.Feature = ACCESS_STICKYKEYS;
    AccessInfo.TitleID = ID_STICKY_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet)
    {
        sticky.cbSize = sizeof sticky;
        b = SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof sticky, &sticky, 0);
        dwS= sticky.dwFlags;

        if (iRet & HOTKEYCODE) {
            sticky.dwFlags &= ~SKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof sticky, &sticky, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            sticky.dwFlags |= SKF_STICKYKEYSON;
        }

        if (dwS != sticky.dwFlags) {
            b = SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof sticky, &sticky, 0);

           SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETSTICKYKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }

        iRet = 1;
    }

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI FilterKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    FILTERKEYS filter;
    DWORD dwF;
    BOOL b;

    AccessInfo.Feature = ACCESS_FILTERKEYS;
    AccessInfo.TitleID = ID_FILTER_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        filter.cbSize = sizeof filter;
        b = SystemParametersInfo(SPI_GETFILTERKEYS, sizeof filter, &filter, 0);
        dwF = filter.dwFlags;

        if (iRet & HOTKEYCODE) {
            filter.dwFlags &= ~FKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETFILTERKEYS, sizeof filter, &filter, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            filter.dwFlags |= FKF_FILTERKEYSON;
        }
        if (dwF !=filter.dwFlags) {
            b = SystemParametersInfo(SPI_SETFILTERKEYS, sizeof filter, &filter, 0);
            // Broadcast a message. Being extra safe not to turn on filter keys 
            // during logon. Send message to notify all specially systray: a-anilk 
           SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETFILTERKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);

        }
        iRet = 1;
    }

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI ToggleKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL;
    ACCESSINFO AccessInfo;
    TOGGLEKEYS toggle;
    DWORD dwT;
    BOOL b;

    toggle.cbSize = sizeof toggle;

    AccessInfo.Feature = ACCESS_TOGGLEKEYS;
    AccessInfo.TitleID = ID_TOGGLE_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        toggle.cbSize = sizeof toggle;
        b = SystemParametersInfo(SPI_GETTOGGLEKEYS, sizeof toggle, &toggle, 0);
        dwT = toggle.dwFlags;

        if (iRet & HOTKEYCODE) {
            toggle.dwFlags &= ~TKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof toggle, &toggle, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            toggle.dwFlags |= TKF_TOGGLEKEYSON;
        }

        if (toggle.dwFlags != dwT) {
            b = SystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof toggle, &toggle, 0);
            // Not required to send message, As it currently has no indicators...
        }
        iRet = 1;
    }
        
    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI MouseKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL;
    ACCESSINFO AccessInfo;
    MOUSEKEYS mouse;
    DWORD dwM;
    BOOL b;

    AccessInfo.Feature = ACCESS_MOUSEKEYS;
    AccessInfo.TitleID = ID_MOUSE_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        mouse.cbSize = sizeof mouse;
        b = SystemParametersInfo(SPI_GETMOUSEKEYS, sizeof mouse, &mouse, 0);
        dwM = mouse.dwFlags;

        if (iRet & HOTKEYCODE) {
            mouse.dwFlags &= ~MKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETMOUSEKEYS, sizeof mouse, &mouse, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }

        if (iRet == IDOK) {
            mouse.dwFlags |= MKF_MOUSEKEYSON;
        }

        if (mouse.dwFlags != dwM) {
            b = SystemParametersInfo(SPI_SETMOUSEKEYS, sizeof mouse, &mouse, 0);

            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETMOUSEKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }

        iRet = 1;
    }
        
    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI HighContNotification(BOOL fNotifReq)
{
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    HIGHCONTRAST  hc;
    DWORD dwH;
    BOOL b;

    AccessInfo.Feature = ACCESS_HIGHCONTRAST;
    AccessInfo.TitleID = ID_HC_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        hc.cbSize = sizeof hc;
        b = SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof hc, &hc, 0);
        dwH = hc.dwFlags;

        if (iRet & HOTKEYCODE) {
            hc.dwFlags &= ~HCF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof hc, &hc, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }

        if (iRet == IDOK) {
            hc.dwFlags |= HCF_HIGHCONTRASTON;
        }

        if (hc.dwFlags != dwH) {
            b = SystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof hc, &hc, 0);

            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETHIGHCONTRAST, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }
        iRet = 1;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\rsopreg\rsopreg.cpp ===
//*************************************************************
//  File name: RSOPREG.CPP
//
//  Description:  A small command line utility that shows how
//                to query for all the registry policy objects
//                in a WMI namespace
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <ole2.h>
#include <wbemcli.h>
#include <tchar.h>
#include <stdio.h>


//*************************************************************
//
//  EnumObjects()
//
//  Purpose:    Enumerates the given namespace for all registry
//              policy objects
//
//  Parameters: pIWbemServices - Interface pointer to the namespace
//
//  Return:     void
//
//*************************************************************

void EnumObjects (IWbemServices * pIWbemServices)
{
    BSTR pLanguage = NULL, pQuery = NULL, pValueName = NULL, pRegistryKey = NULL;
    IEnumWbemClassObject * pEnum;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varRegistryKey, varValueName;
    ULONG ulCount = 0;


    //
    // Print heading
    //

    _tprintf (TEXT("\n\nRegistry objects in the RSOP\\User namespace:\n\n"));


    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));
    pQuery = SysAllocString (TEXT("SELECT * FROM RSOP_RegistryPolicySetting"));


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pRegistryKey = SysAllocString (TEXT("registryKey"));
    pValueName = SysAllocString (TEXT("valueName"));


    //
    // Check if the allocations succeeded
    //

    if (pLanguage && pQuery && pRegistryKey && pValueName)
    {

        //
        // Execute the query
        //

        hr = pIWbemServices->ExecQuery (pLanguage, pQuery, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                        NULL, &pEnum);

        if (SUCCEEDED(hr))
        {

            //
            // Loop through the results retreiving the registry key and value names
            //

            while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
            {
                hr = pObjects[0]->Get (pRegistryKey, 0, &varRegistryKey, NULL, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = pObjects[0]->Get (pValueName, 0, &varValueName, NULL, NULL);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Print the key / value names
                        //

                        _tprintf (TEXT("    %s\\%s\n"), varRegistryKey.bstrVal, varValueName.bstrVal);
                        VariantClear (&varValueName);
                    }

                    VariantClear (&varRegistryKey);
                }

                ulCount++;
            }

            if (ulCount == 0)
            {
                _tprintf (TEXT("\tNo registry objects found\n"));
            }

            pEnum->Release();
        }
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pRegistryKey)
    {
        SysFreeString (pRegistryKey);
    }

    if (pValueName)
    {
        SysFreeString (pValueName);
    }

}


//*************************************************************
//
//  main()
//
//  Purpose:    Entry point of this application
//
//  Parameters: argc & argv
//
//  Return:     0
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    BSTR pNamespace = NULL;
    HRESULT hr;


    //
    // Initialize COM
    //

    CoInitialize(NULL);


    //
    // Create the locator interface
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (hr != S_OK)
    {
        _tprintf(TEXT("CoCreateInstance failed with 0x%x\n"), hr);
        goto Exit;
    }


    //
    // Using the locator, connect to the RSOP user namespace
    //

    pNamespace = SysAllocString(TEXT("root\\rsop\\user"));

    if (pNamespace)
    {
        hr = pIWbemLocator->ConnectServer(pNamespace,
                                        NULL,   //using current account for simplicity
                                        NULL,   //using current password for simplicity
                                        0L,             // locale
                                        0L,             // securityFlags
                                        NULL,   // authority (domain for NTLM)
                                        NULL,   // context
                                        &pIWbemServices);

        if (hr != S_OK)
        {
            _tprintf(TEXT("ConnectServer failed with 0x%x\n"), hr);
            goto Exit;
        }


        EnumObjects (pIWbemServices);
    }

Exit:

    if (pNamespace)
    {
        SysFreeString(pNamespace);
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    CoUninitialize ();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\util.h ===
//
// Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\snapin.h ===
//
// SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendPropertySheet
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPIMAGELIST          m_pImageResult; // Result pane's image list interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    WCHAR                m_column1[20];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;
    static TCHAR m_szDefaultIcon[];

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(long);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, long, long);
    STDMETHODIMP         QueryDataObject(long, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(long, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      long handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


private:
    static BOOL CALLBACK UserGroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK MachineGroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK GroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, BOOL bUser);
    static BOOL CALLBACK ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK NetHoodDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK StartMenuDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL AddEntry (HWND hLV, LPTSTR lpPlace, LPTSTR lpLocation);
    static BOOL InitializePlacesDlg (CSnapIn* pSnapIn, HWND hDlg);
    static BOOL SavePlaces (CSnapIn* pSnapIn, HWND hLV);
    static BOOL RemoveEntries (CSnapIn* pSnapIn, HWND hLV);
    static BOOL CALLBACK MyDocsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AddPlaceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK MyDocsTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\samples\gptdemo\snapin.cpp ===
#include "main.h"


// {febf1208-8aff-11d2-a8a1-00c04fbbcfa2}
#define GPEXT_GUID { 0xfebf1208, 0x8aff, 0x11d2, { 0xa8, 0xa1, 0x0, 0xc0, 0x4f, 0xbb, 0xcf, 0xa2} };

GUID guidGPExt = GPEXT_GUID;
GUID guidSnapin = CLSID_GPTDemoSnapIn;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_ICON;

    LoadString(g_hInstance, IDS_NAME, m_column1, sizeof(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);


    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(long cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (m_pImageResult != NULL)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

        // Set the images
        m_pImageResult->ImageListSetStrip(reinterpret_cast<long*>(hbmp16x16),
                                          reinterpret_cast<long*>(hbmp32x32),
                                          0, RGB(255, 0, 255));

        DeleteObject(hbmp16x16);
        DeleteObject(hbmp32x32);
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPTDATAOBJECT pGPTDataObject;
            long cookie;
            INT i;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            //m_pResult->Sort(0, 0, -1);
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPTDATAOBJECT pGPTDataObject;
            DATA_OBJECT_TYPES type;
            LONG cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                break;

            pGPTDataObject->GetType(&type);
            pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(long cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    LONG cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendPropertySheet)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             long handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPGPTDATAOBJECT pGPTDataObject;
    LPRESULTITEM pItem;
    LONG cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pGPTDataObject->GetCookie(&cookie);
    pGPTDataObject->Release();


    pItem = (LPRESULTITEM)cookie;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) this;


    //
    // Do the page specific stuff
    //

    switch (pItem->dwID)
    {
        case 2:

            psp.pszTemplate = MAKEINTRESOURCE(IDD_README);
            psp.pfnDlgProc = ReadmeDlgProc;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 3:

            psp.pszTemplate = MAKEINTRESOURCE(IDD_APPEAR);
            psp.pfnDlgProc = AppearDlgProc;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;
    }


    return (hr);
}

STDMETHODIMP CSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPGPTDATAOBJECT pGPTDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                               (LPVOID *)&pGPTDataObject)))
    {
        pGPTDataObject->GetType(&type);
        pGPTDataObject->Release();

        if (type == CCT_RESULT)
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (Internal functions)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK CSnapIn::ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}


BOOL CALLBACK CSnapIn::AppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSnapIn * pCS;
    static BOOL bAppearDirty;
    HKEY hKeyRoot, hKey;
    DWORD dwType, dwSize, dwDisp;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szPath[2 * MAX_PATH];
    HRESULT hr;


    switch (message)
    {
        case WM_INITDIALOG:
        {
            pCS = (CSnapIn *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLong (hDlg, DWL_USER, (LONG) pCS);

            if (!pCS) {
                break;
            }

            CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_DEFAULT);

            hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath (GPO_SECTION_USER, szPath, ARRAYSIZE(szPath));

            if (SUCCEEDED(hr))
            {

                lstrcat (szPath, TEXT("\\gpext.ini"));

                GetPrivateProfileString (TEXT("Colors"), TEXT("Background"), TEXT("0 128 128"),
                                         szBuffer, MAX_PATH, szPath);

                if (!lstrcmpi(szBuffer, TEXT("255 0 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_RED);
                else if (!lstrcmpi(szBuffer, TEXT("0 255 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_GREEN);
                else if (!lstrcmpi(szBuffer, TEXT("0 0 255")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_BLUE);
                else if (!lstrcmpi(szBuffer, TEXT("0 0 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_BLACK);
                else if (!lstrcmpi(szBuffer, TEXT("160 160 164")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_GRAY);


                GetPrivateProfileString (TEXT("Desktop"), TEXT("Wallpaper"), TEXT("(None)"),
                                         szBuffer, MAX_PATH, szPath);

                SetDlgItemText (hDlg, IDC_WALLPAPER, szBuffer);

                GetPrivateProfileString (TEXT("Desktop"), TEXT("TileWallpaper"), TEXT("0"),
                                         szBuffer, MAX_PATH, szPath);

                if (szBuffer[0] == TEXT('1'))
                    CheckRadioButton (hDlg, IDC_TILE, IDC_CENTER, IDC_TILE);
                else
                    CheckRadioButton (hDlg, IDC_TILE, IDC_CENTER, IDC_CENTER);
            }


            bAppearDirty = FALSE;
            break;
        }

        case WM_COMMAND:
            if ((HIWORD(wParam) == BN_CLICKED) || (HIWORD(wParam) == EN_UPDATE))
            {
                if (!bAppearDirty)
                {
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    bAppearDirty = TRUE;
                }
            }
            break;

        case WM_NOTIFY:

            pCS = (CSnapIn *) GetWindowLong (hDlg, DWL_USER);

            if (!pCS) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    if (bAppearDirty)
                    {

                       hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath (GPO_SECTION_USER, szPath, ARRAYSIZE(szPath));

                       if (SUCCEEDED(hr))
                       {
                           lstrcat (szPath, TEXT("\\gpext.ini"));
                           lstrcpy (szBuffer, TEXT("0 128 128"));

                           if (IsDlgButtonChecked (hDlg, IDC_RED) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("255 0 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_GREEN) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 255 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_BLUE) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 0 255"));

                           else if (IsDlgButtonChecked (hDlg, IDC_BLACK) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 0 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_GRAY) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("160 160 164"));

                           WritePrivateProfileString (TEXT("Colors"), TEXT("Background"), szBuffer, szPath);


                           lstrcpy (szBuffer, TEXT("(None)"));

                           GetDlgItemText (hDlg, IDC_WALLPAPER, szBuffer, MAX_PATH);

                           WritePrivateProfileString (TEXT("Desktop"), TEXT("Wallpaper"), szBuffer, szPath);

                           if (IsDlgButtonChecked (hDlg, IDC_TILE) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("1"));
                           else
                               lstrcpy (szBuffer, TEXT("0"));

                           WritePrivateProfileString (TEXT("Desktop"), TEXT("TileWallpaper"), szBuffer, szPath);

                           bAppearDirty = FALSE;
                           pCS->m_pcd->m_pGPTInformation->PolicyChanged(FALSE, TRUE, &guidGPExt, &guidSnapin);
                       }
                    }
                }
                // fall through...

                case PSN_RESET:
                    SetWindowLong (hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\sethc\access.h ===
DWORD WINAPI StickyKeysNotification(BOOL fNotify);
DWORD WINAPI FilterKeysNotification(BOOL fNotify);
DWORD WINAPI ToggleKeysNotification(BOOL fNotify);
DWORD WINAPI MouseKeysNotification(BOOL fNotify);
DWORD WINAPI HighContNotification(BOOL fNotify);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\shutdown\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Strings.rc
//
#define IDS_USAGE0  1200
#define IDS_USAGE1	IDS_USAGE0 + 1
#define IDS_USAGE2	IDS_USAGE1 + 1
#define IDS_USAGE2a IDS_USAGE2 + 1       
#define IDS_USAGE3	IDS_USAGE2a + 1
#define IDS_USAGE3a IDS_USAGE3 + 1
#define IDS_USAGE4	IDS_USAGE3a + 1
#define IDS_USAGE5	IDS_USAGE4 + 1
#define IDS_USAGE6	IDS_USAGE5 + 1
#define IDS_USAGE7	IDS_USAGE6 + 1
#define IDS_USAGE7a IDS_USAGE7 + 1
#define IDS_USAGE8	IDS_USAGE7a + 1
#define IDS_USAGE8a	IDS_USAGE8 + 1
#define IDS_USAGE9	IDS_USAGE8a + 1
#define IDS_USAGE9a IDS_USAGE9 + 1
#define IDS_USAGE10	IDS_USAGE9a + 1
#define IDS_USAGE11	IDS_USAGE10 + 1
#define IDS_USAGE12	IDS_USAGE11 + 1
#define IDS_USAGE12a IDS_USAGE12 + 1
#define IDS_USAGE13	IDS_USAGE12a + 1
#define IDS_USAGE13a IDS_USAGE13 + 1
#define IDS_USAGE14	IDS_USAGE13a + 1
#define IDS_USAGE15	IDS_USAGE14 + 1
#define IDS_USAGE17	IDS_USAGE15 + 1
#define IDS_USAGE18	IDS_USAGE17 + 1
#define IDS_USAGE19	IDS_USAGE18 + 1
#define IDS_USAGE_END	IDS_USAGE19 + 1

#define IDS_ACTION_SHUTDOWN             2
#define IDS_ACTION_RESTART              3
#define IDS_ACTION_ABORT                4
#define IDS_ACTION_LOGOFF               5
#define IDS_ACTION_STANDBY              6
#define IDS_ACTION_DISCONNECT           7
#define IDS_CANNOTGETPRIVILAGE          8
#define IDS_ACTIONNOTSUPPORTED          9
#define IDS_ERROR_NOT_READY             10
#define IDS_ERROR_NOT_AVAILABLE         11
#define IDS_DIALOGTITLEWARNING		15
#define	IDS_SUCCEEDED			16
#define IDS_FAILED			17
#define IDS_REASONLISTTITLE      	18
#define IDS_ERR_HIBERNATE_NOT_ENABLED 	19
#define IDS_ACTION_HIBERNATE		20
#define IDS_EMPTYLISTMSG		21
#define IDS_ACTION_ANNOTATE             22
#define IDS_PROMOTE_COMMENT             23
#define IDS_COMMENT_REQUIRED            24
#define IDS_COMMENT_OPTIONAL            25
#define IDS_NO_DIRTY_SHUTDOWN           26
#define IDS_ANNOTATION_FAILED           27
#define IDS_FAILED_REG_CONN      	28
#define IDS_FAILED_REG_OPEN      	29
#define IDS_FAILED_EVENT_REG            30
#define IDS_FAILED_EVENT_REPORT         31
#define IDD_DIALOGSHUTDOWN              101
#define IDD_DIALOG_ADDNEW               102
#define IDC_COMBOACTION                 1000
#define IDC_COMBOOPTION                 1001
#define IDC_LISTSELECTEDCOMPUTERS       1003
#define IDC_BUTTONREMOVE                1004
#define IDC_BUTTONBROWSE                1010
#define IDC_CHECKWARNING                1011
#define IDC_EDITTIMEOUT                 1012
#define IDC_EDITCOMMENT                 1014
#define IDC_BUTTONADDNEW                1015
#define IDC_EDIT_ADDCOMPUTERS_COMPUTERS 1016
#define IDC_STATICDESCRIPTION           1017
#define IDC_EDITDOMAIN                  1018
#define IDC_STATIC_PROGRESS             1019
#define IDC_CHECK_PLANNED		1020
#define IDC_STATIC_COMMENT              1021

#define IDH_SHUTDOWN_OK			2000
#define	IDH_SHUTDOWN_CANCEL		2001
#define IDH_SHUTDOWN_HELP               2002
#define IDH_SHUTDOWN_COMBOACTION        2003
#define IDH_SHUTDOWN_COMBOOPTION        2004
#define IDH_SHUTDOWN_SELECTEDCOMPUTERS  2005
#define IDH_SHUTDOWN_BUTTONREMOVE       2006
#define IDH_SHUTDOWN_BUTTONBROWSE       2007
#define IDH_SHUTDOWN_CHECKWARNING       2008
#define IDH_SHUTDOWN_EDITTIMEOUT        2009
#define IDH_SHUTDOWN_EDITCOMMENT        2010
#define IDH_SHUTDOWN_BUTTONADDNEW       2011
#define IDH_SHUTDOWN_CHECK_PLANNED      2012
#define IDH_ADDNEW_OK                   2015
#define IDH_ADDNEW_CANCEL               2016
#define IDH_ADDNEW_COMPUTERS            2017

#define IDC_STATIC                      65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\sethc\dialogs.h ===
/****************************** Module Header ******************************\
* Module Name: dialogs.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define contants used by dialog edit when editting dialog.dlg
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


// Accessibility notification dialogs
#define DLG_CONFIRM               0x1230
#define ID_HELPTEXT               0x1231
#define ID_NOHOTKEY               0x1232

#define ID_STICKY_TITLE         0x1240
#define ID_STICKY_TEXT          0x1240

#define ID_FILTER_TITLE         0x1250
#define ID_FILTER_TEXT          0x1250

#define ID_MOUSE_TITLE          0x1260
#define ID_MOUSE_TEXT           0x1260

#define ID_HC_TITLE             0x1270
#define ID_HC_TEXT              0x1270

#define ID_TOGGLE_TITLE         0x1280
#define ID_TOGGLE_TEXT          0x1280

#define ID_SERIAL_TITLE         0x1290
#define ID_SERIAL_TEXT          0x1290

#define ID_ACCESS_TITLE         0x1300
#define ID_ACCESS_TEXT          0x1300

#define ID_WHITEBLACK_HC        0x1320
#define ID_PRE_HC_SCHEME        0x1321
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\addupgrd.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       addupgrd.cpp
//
//  Contents:   add upgrade dialog
//
//  Classes:    CAddUpgrade
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog


CAddUpgrade::CAddUpgrade(CWnd* pParent /*=NULL*/)
        : CDialog(CAddUpgrade::IDD, pParent)
{
        //{{AFX_DATA_INIT(CAddUpgrade)
        m_iUpgradeType = 1; // default to rip-and-replace
        m_iSource = 0;  // default to current container
        m_szGPOName = L"";
        //}}AFX_DATA_INIT
        m_fPopulated = FALSE;
}


void CAddUpgrade::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAddUpgrade)
        DDX_Radio(pDX, IDC_RADIO4, m_iUpgradeType);
        DDX_Radio(pDX, IDC_RADIO1, m_iSource);
        DDX_Text(pDX, IDC_EDIT1, m_szGPOName);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddUpgrade, CDialog)
        //{{AFX_MSG_MAP(CAddUpgrade)
        ON_BN_CLICKED(IDC_RADIO1, OnCurrentContainer)
        ON_BN_CLICKED(IDC_RADIO2, OnOtherContainer)
        ON_BN_CLICKED(IDC_RADIO10, OnAllContainers)
        ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
        ON_LBN_DBLCLK(IDC_LIST1, OnOK)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade message handlers

BOOL CAddUpgrade::OnInitDialog()
{
    // If m_fPopulated is FALSE then populate the map with all packages in
    // this GPO container _EXCEPT_ the current app.
    if (!m_fPopulated)
    {
        OnCurrentContainer();
        m_szGPO = m_pScope->m_szGPO;
        m_fPopulated = TRUE;
    }
    else
    {
        // This will be done in OnCurrentContainer if m_fPopulated is FALSE
        RefreshList();
    }

    CDialog::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddUpgrade::RefreshList()
{
    // For every element in the map, if it isn't already in the upgrade
    // list then add it to the list.

    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    pList->ResetContent();

    BOOL fEnable = FALSE;

    // add all elements that aren't already in the upgrade list
    map<CString, CUpgradeData>::iterator i;
    for (i = m_NameIndex.begin(); i != m_NameIndex.end(); i++)
    {
        if (m_pUpgradeList->end() == m_pUpgradeList->find(GetUpgradeIndex(i->second.m_PackageGuid)))
        {
            fEnable = TRUE;
            pList->AddString(i->first);
            CDC * pDC = pList->GetDC();
            CSize size = pDC->GetTextExtent(i->first);
            pDC->LPtoDP(&size);
            pList->ReleaseDC(pDC);
            if (pList->GetHorizontalExtent() < size.cx)
            {
                pList->SetHorizontalExtent(size.cx);
            }
        }
    }
    GetDlgItem(IDOK)->EnableWindow(fEnable);
    if (NULL == GetFocus())
    {
        GetDlgItem(IDCANCEL)->SetFocus();
    }
    pList->SetCurSel(0);
}

void CAddUpgrade::OnOK()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        // only allow the dialog to close with IDOK if a selection has been made
        CDialog::OnOK();

        // Do this part later to make sure that all data members are
        // refreshed (this happens as part of the OnOk processing)
        pList->GetText(iSel, m_szPackageName);
        m_UpgradeData = m_NameIndex[m_szPackageName];
        m_UpgradeData.m_flags = (m_iUpgradeType == 1) ? UPGFLG_Uninstall : UPGFLG_NoUninstall;
    }
}

void CAddUpgrade::OnCurrentContainer()
{
    // Populate the map with all packages in this GPO container _EXCEPT_ the
    // current app.
    CString szClassStore;
    HRESULT hr = m_pScope->GetClassStoreName(szClassStore, FALSE);
    ASSERT(hr == S_OK);
    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());
    map <MMC_COOKIE, CAppData>::iterator i;
    for (i = m_pScope->m_AppData.begin(); i != m_pScope->m_AppData.end(); i ++)
    {
        CString szIndex = GetUpgradeIndex(i->second.m_pDetails->pInstallInfo->PackageGuid);
        if (0 != _wcsicmp(szIndex, m_szMyGuid))
        {
            // make sure we exclude legacy apps
            if (i->second.m_pDetails->pInstallInfo->PathType != SetupNamePath)
            {
                CUpgradeData data;
                memcpy(&data.m_PackageGuid, &i->second.m_pDetails->pInstallInfo->PackageGuid, sizeof(GUID));
                data.m_szClassStore = szClassStore;
                // Add this element to the list
                m_NameIndex[i->second.m_pDetails->pszPackageName] = data;
            }
        }
    }

    RefreshList();
}

void CAddUpgrade::OnOtherContainer()
{
    // Populate the map with all packages in the other container.

    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());
    WCHAR szBuffer[MAX_DS_PATH];
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (SUCCEEDED(hr))
    {
        // open GPO object without opening registry data
        hr = pGPO->OpenDSGPO((LPOLESTR)((LPCOLESTR)m_szGPO), GPO_OPEN_READ_ONLY);
        if (SUCCEEDED(hr))
        {
            hr = pGPO->GetDSPath(m_pScope->m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
            if (SUCCEEDED(hr))
            {
                // OK, we should now have a DS path that we can use to locate
                // a class store.
                LPOLESTR szCSPath;
                hr = CsGetClassStorePath((LPOLESTR)((LPCOLESTR)szBuffer), &szCSPath);
                if (SUCCEEDED(hr))
                {
                    // now we should have the DS path to the class store itself
                    IClassAdmin * pIClassAdmin;
                    hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&pIClassAdmin);
                    if (SUCCEEDED(hr))
                    {
                        // and finally we should have a pointer to the IClassAdmin
                        IEnumPackage * pIPE = NULL;

                        hr = pIClassAdmin->EnumPackages(NULL,
                                                        NULL,
                                                        APPQUERY_ADMINISTRATIVE,
                                                        NULL,
                                                        NULL,
                                                        &pIPE);
                        if (SUCCEEDED(hr))
                        {
                            hr = pIPE->Reset();
                            PACKAGEDISPINFO stPDI;
                            ULONG nceltFetched;
                            while (SUCCEEDED(hr))
                            {
                                hr = pIPE->Next(1, &stPDI, &nceltFetched);
                                if (nceltFetched)
                                {
                                    // make sure we exclude legacy apps
                                    // and deleted apps
                                    if (stPDI.PathType != SetupNamePath)
                                    {
                                        CString szIndex = GetUpgradeIndex(stPDI.PackageGuid);
                                        if (0 != _wcsicmp(szIndex, m_szMyGuid))
                                        {
                                            // Add this element to the list
                                            CString sz = stPDI.pszPackageName;
                                            if (0 != _wcsicmp(m_szGPO, m_pScope->m_szGPO))
                                            {
                                                // This isn't in the host GPO
                                                sz += L" (";
                                                sz += m_szGPOName;
                                                sz += L")";
                                            }
                                            CUpgradeData data;
                                            data.m_szClassStore = szCSPath;
                                            memcpy(&data.m_PackageGuid, &stPDI.PackageGuid, sizeof(GUID));
                                            m_NameIndex[sz] = data;
                                        }
                                    }
                                }
                                else
                                {
                                    break;
                                }
                                OLESAFE_DELETE(stPDI.pszPackageName);
                                OLESAFE_DELETE(stPDI.pszScriptPath);
                                OLESAFE_DELETE(stPDI.pszPublisher);
                                OLESAFE_DELETE(stPDI.pszUrl);
                                UINT n = stPDI.cUpgrades;
                                while (n--)
                                {
                                    OLESAFE_DELETE(stPDI.prgUpgradeInfoList[n].szClassStore);
                                }
                                OLESAFE_DELETE(stPDI.prgUpgradeInfoList);
                            }
                            pIPE->Release();
                        }

                        pIClassAdmin->Release();
                    }
                    OLESAFE_DELETE(szCSPath);
                }
            }
        }
        pGPO->Release();
    }

    RefreshList();
}

void CAddUpgrade::OnAllContainers()
{
    RefreshList();
}

//+--------------------------------------------------------------------------
//
//  Function:   GetDomainFromLDAPPath
//
//  Synopsis:   returns a freshly allocated string containing the LDAP path
//              to the domain name contained with an arbitrary LDAP path.
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     5-06-1998   stevebl   Created
//              10-20-1998   stevebl   modified to preserve server names
//
//  Notes:      This routine works by repeatedly removing leaf elements from
//              the LDAP path until an element with the "DC=" prefix is
//              found, indicating that a domain name has been located.  If a
//              path is given that is not rooted in a domain (is that even
//              possible?) then NULL would be returned.
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//              Stolen from GPEDIT\UTIL.CPP
//
//---------------------------------------------------------------------------

LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        BSTR bstrSzIn;

        bstrSzIn = SysAllocString(szIn);
        if (NULL == szIn || bstrSzIn != NULL) 
        {
            hr = pADsPathname->Set(bstrSzIn, ADS_SETTYPE_FULL);
            SysFreeString(bstrSzIn);

            if (SUCCEEDED(hr))
            {
                BSTR bstr;
                BOOL fStop = FALSE;

                while (!fStop)
                {
                    hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
                    if (SUCCEEDED(hr))
                    {

                        // keep peeling them off until we find something
                        // that is a domain name
                        fStop = (0 == _wcsnicmp(L"DC=", bstr, 3));
                        SysFreeString(bstr);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
                    }

                    if (!fStop)
                    {
                        hr = pADsPathname->RemoveLeafElement();
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to remove leaf with 0x%x."), hr));
                            fStop = TRUE;
                        }
                    }
                }

                hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                if (SUCCEEDED(hr))
                {
                    ULONG ulNoChars = wcslen(bstr)+1; 

                    sz = new OLECHAR[ulNoChars];
                    if (sz)
                    {
                        hr = StringCchCopy(sz, ulNoChars, bstr);
                        ASSERT(SUCCEEDED(hr));
                    }
                    SysFreeString(bstr);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve full path with 0x%x."), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to set pathname with 0x%x."), hr));
            }

            pADsPathname->Release();
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to allocate memory")));
        }
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}


void CAddUpgrade::OnBrowse()
{
    // Browse to the other container and then call OnOtherContainer.
    OLECHAR szPath[MAX_DS_PATH];
    OLECHAR szName[256];
    GPOBROWSEINFO stGBI;
    memset(&stGBI, 0, sizeof(GPOBROWSEINFO));
    stGBI.dwSize = sizeof(GPOBROWSEINFO);
    stGBI.dwFlags = GPO_BROWSE_NOCOMPUTERS | GPO_BROWSE_INITTOALL;
    stGBI.hwndOwner = m_hWnd;
    stGBI.lpInitialOU =  GetDomainFromLDAPPath((LPWSTR)((LPCWSTR)m_szGPO));
    stGBI.lpDSPath = szPath;
    stGBI.dwDSPathSize = MAX_DS_PATH;
    stGBI.lpName = szName;
    stGBI.dwNameSize = 256;
    if (SUCCEEDED(BrowseForGPO(&stGBI)))
    {
        m_szGPO = szPath;
        m_szGPOName = szName;
        m_iSource = 1;
        UpdateData(FALSE);
        OnOtherContainer();
    }
    if (stGBI.lpInitialOU != NULL)
    {
        delete [] stGBI.lpInitialOU;
    }
}

LRESULT CAddUpgrade::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CAddUpgrade::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FIND_UPGRADE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\advdep.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvDep.cpp
//
//  Contents:   addvanced deployment settings dialog
//
//  Classes:
//
//  Functions:
//
//  History:    01-28-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdvDep dialog


CAdvDep::CAdvDep(CWnd* pParent /*=NULL*/)
    : CDialog(CAdvDep::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAdvDep)
    m_fIgnoreLCID = FALSE;
    m_fInstallOnAlpha = FALSE;
    m_f32On64 = FALSE;
    m_szProductCode = _T("");
    m_szDeploymentCount = _T("");
    m_szScriptName = _T("");
    m_fIncludeOLEInfo = FALSE;
    //}}AFX_DATA_INIT
}


void CAdvDep::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAdvDep)
    DDX_Check(pDX, IDC_CHECK1, m_fIgnoreLCID);
    DDX_Check(pDX, IDC_CHECK3, m_fUninstallUnmanaged);
    DDX_Check(pDX, IDC_CHECK4, m_fIncludeOLEInfo);
    DDX_Check(pDX, IDC_CHECK2, m_f32On64);
    DDX_Text(pDX, IDC_STATIC1, m_szProductCode);
    DDX_Text(pDX, IDC_STATIC2, m_szDeploymentCount);
    DDX_Text(pDX, IDC_STATIC3, m_szScriptName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdvDep, CDialog)
    //{{AFX_MSG_MAP(CAdvDep)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

int FindBreak(CString &sz)
{
    int iReturn = sz.ReverseFind(L'\\');
    int i2 = sz.ReverseFind(L' ');
    if (i2 > iReturn)
    {
        iReturn = i2;
    }
    return iReturn;
}

BOOL CAdvDep::OnInitDialog()
{
    BOOL fIntel = FALSE;
    GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    
    //
    // The include COM information flag is not supported by RSoP
    // so in RSoP mode, we will hide this control
    //
    if ( m_pDeploy->m_fRSOP )
    {
        GetDlgItem( IDC_CHECK4 )->ShowWindow( SW_HIDE );
    }

    if (m_pDeploy->m_fPreDeploy)
    {
        // and we're in pre-deploy mode - enable the extensions only field
        GetDlgItem(IDC_CHECK4)->EnableWindow(TRUE);
    }

    // search for an Intel processor code
    int nPlatforms = m_pDeploy->m_pData->m_pDetails->pPlatformInfo->cPlatforms;
    while (nPlatforms--)
    {
        if (m_pDeploy->m_pData->m_pDetails->pPlatformInfo->
            prgPlatform[nPlatforms].dwProcessorArch
            == PROCESSOR_ARCHITECTURE_INTEL)
        {
            fIntel = TRUE;
        }
    }
//    GetDlgItem(IDC_CHECK2)->EnableWindow(fIntel);
    CString sz;
    if (m_pDeploy->m_fMachine)
    {
        sz.LoadString(IDS_ADVANCEDMACHINES);
    }
    
    if (m_pDeploy->m_pData->Is64Bit())
    {
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->ShowWindow(SW_HIDE);
    }
    else
    {
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK2)->ShowWindow(SW_SHOW);
    }

    //
    // In the past, we allowed administrators to optionally specify
    // that unmanaged installs should be removed for per-user non-admin
    // installs.  Due to security issues, it is clear that the
    // behavior should not be configurable, that the client
    // should transparently make the decision.  For this reason,
    // we hide this option in the ui below, and note that
    // we leave the resource in the executable so that
    // test code will not be broken by a resource change at this
    // stage in the project -- this resource should be removed altogether
    // in the next release
    //
    GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->ShowWindow(SW_HIDE);


    if (m_pDeploy->m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }

    // split the path so it will fit in the control

    RECT rect;
    CWnd * pwndStatic =  GetDlgItem(IDC_STATIC3);
    pwndStatic->GetClientRect(&rect);
    DWORD dwControl = rect.right-rect.left;
    CString szPath = m_szScriptName;
    m_szScriptName = "";
    CDC * pDC = pwndStatic->GetDC();
    CSize size = pDC->GetTextExtent(szPath);
    pDC->LPtoDP(&size);
    int ich;
    while (size.cx >= dwControl)
    {
        ich = FindBreak(szPath);
        if (ich <= 0)
        {
            // there's no where else to break this string
            break;
        }
        else
        {
            // break off the front of the string
            CString szFront;
            do
            {
                szFront = szPath.Left(ich);
                size = pDC->GetTextExtent(szFront);
                pDC->LPtoDP(&size);
                ich = FindBreak(szFront);
            } while (ich > 0 && size.cx >= dwControl);
            m_szScriptName += szFront;
            m_szScriptName += L'\n';
            szPath = szPath.Mid(szFront.GetLength());
        }
        size = pDC->GetTextExtent(szPath);
        pDC->LPtoDP(&size);
    }
    m_szScriptName += szPath;
    pwndStatic->ReleaseDC(pDC);

    CDialog::OnInitDialog();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAdvDep message handlers

void CAdvDep::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_ADVDEP);
}

LRESULT CAdvDep::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\sethc\sethc.c ===
/****************************** Module Header ******************************\
* Module Name: sethc.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* SetHC -- exe to set or clear high contrast state.
*
* History:
* 02-01-97  Fritz Sands Created
* Bug fixes : a-anilk June 99
\***************************************************************************/

/***************************************************************************
 * Use the following define if for some reason we have to go back to using
 * a message loop to let shell have time to update the UI
 *
#define NEED_MSG_PUMP
 **************************************************************************/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>
#include <cpl.h>
#include <stdarg.h>
#include <stdlib.h>
#include <WININET.H>
#include <shlobj.h>
#include <objbase.h>
#include <shlguid.h>
#include <uxthemep.h>
#include "access.h"
#pragma hdrstop

HINSTANCE  g_hInstance;

#ifdef DBG
  #define DBPRINTF MyOutputDebugString
  void MyOutputDebugString( LPCTSTR lpOutputString, ...);
#else
  #define DBPRINTF   1 ? (void)0 : (void)
#endif

/*
 * High Contrast Stuff
 */

#define HC_KEY                  TEXT("Control Panel\\Accessibility\\HighContrast")
#define HIGHCONTRASTSCHEME      TEXT("High Contrast Scheme")
#define REGSTR_VAL_FLAGS        TEXT("Flags")
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define APPEARANCESCHEME        REGSTR_PATH_LOOKSCHEMES
#define DEFSCHEMEKEY            REGSTR_PATH_APPEARANCE
#define DEFSCHEMENAME           TEXT("Current")
#define WHITEBLACK_HC           TEXT("High Contrast Black (large)")
#define CURHCSCHEME             TEXT("Volatile HC Scheme")
// the extension for an appearance filename
#define THEME_EXT L".msstyles"
// the following is a Windows Classic color scheme or a THEME_EXT file name
#define PRE_HC_SCHEME           TEXT("Pre-High Contrast Scheme")
// the following is the color scheme when pre-HC was a .mstheme
#define PRE_HC_THM_COLOR        TEXT("Pre-High Contrast Color")
// the following is the font size when pre-HC was a .mstheme
#define PRE_HC_THM_SIZE         TEXT("Pre-High Contrast Size")
// the following is the wallpaper for pre-HC
#define PRE_HC_WALLPAPER        TEXT("Pre-High Contrast Wallpaper")

// increase this value so we can store a theme filename
#ifdef MAX_SCHEME_NAME_SIZE
#undef MAX_SCHEME_NAME_SIZE
#endif
#define MAX_SCHEME_NAME_SIZE 512

#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])
/*
 * Note -- this must match the desktop applet
 */

#define SCHEME_VERSION 2        // Ver 2 == Unicode
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA;

typedef DWORD (WINAPI* PFNDIALOGRTN)(BOOL);
PFNDIALOGRTN g_aRtn[] = {
    NULL,
    StickyKeysNotification,   //ACCESS_STICKYKEYS
    FilterKeysNotification,   //ACCESS_FILTERKEYS
    ToggleKeysNotification,   //ACCESS_TOGGLEKEYS
    MouseKeysNotification,    //ACCESS_MOUSEKEYS
    HighContNotification, //ACCESS_HIGHCONTRAST
};


/***************************************************************************
 * GetRegValue
 *
 * Passed the key, and the identifier, return the string data from the
 * registry.
 ***************************************************************************/
 long GetRegValue(LPWSTR RegKey, LPWSTR RegEntry, LPWSTR RegVal, long Size)
{
    HKEY  hReg;       // Registry handle for schemes
    DWORD Type;       // Type of value
    long retval;
    DWORD ccbSize = Size;

    RegVal[0] = 0; // in case something fails always return null-terminated
    
    retval = RegCreateKey(HKEY_CURRENT_USER, RegKey, &hReg);
    if (retval != ERROR_SUCCESS)
        return retval;

    retval = RegQueryValueEx(hReg,
        RegEntry,
        NULL,
        (LPDWORD)&Type,
        (LPBYTE)RegVal,
        &ccbSize);

    // 'ccbSize' is in bytes
    if (retval == ERROR_SUCCESS && Type == REG_SZ && ccbSize > 0)
    {
        ccbSize /= 2;
        RegVal[ccbSize - 1] = 0; // ensure null-termination
    }
    else
    {
        RegVal[0] = 0; // if reg type is not string don't return anything
    }
    
    RegCloseKey(hReg);
    return retval;
}

/***************************************************************************
 * SetRegValue
 *
 * Passed the key, and the identifier, set the string data from the
 * registry.
 ***************************************************************************/
long SetRegValue(LPTSTR RegKey, LPWSTR RegEntry, LPVOID RegVal, long Size, DWORD Type)
{
    HKEY  hReg;                                // Registry handle for schemes
    DWORD Reserved = 0;
    long retval;

    if (RegCreateKey(HKEY_CURRENT_USER,RegKey, &hReg) != ERROR_SUCCESS)
        return 0;

    // A common error is to omit the `+1', so we just smash the correct
    // value into place regardless.
    if (Type == REG_SZ)
        Size = (lstrlen(RegVal) + 1) * sizeof(WCHAR);

    retval = RegSetValueEx(hReg,
                     RegEntry,
                     0,
                     Type,
                     RegVal,
                     Size);


    RegCloseKey(hReg);
    return retval;
 }


/***************************************************************************
 * SaveAndRemoveWallpaper
 * 
 * Gets the current wallpaper setting from the system and saves it in the
 * accessibility registry entries.  No error return as there isn't anything
 * we can do.
 *
 * ISSUE we aren't getting all the active desktop properties; just wallpaper.
 * This isn't a regression in that we didn't even restore wallpaper in W2K.
 *
 ***************************************************************************/
void SaveAndRemoveWallpaper()
{
    WCHAR szWallpaper[MAX_SCHEME_NAME_SIZE] = {0};
    IActiveDesktop *p;
    HRESULT hr;

    hr = CoCreateInstance(
                  &CLSID_ActiveDesktop
                , NULL
                , CLSCTX_INPROC_SERVER
                , &IID_IActiveDesktop
                , (void **)&p);
    if (SUCCEEDED(hr))
    {
        hr = p->lpVtbl->GetWallpaper(p, szWallpaper, MAX_SCHEME_NAME_SIZE, 0);
        if (SUCCEEDED(hr))
        {
            // save the current wallpaper setting

            SetRegValue(HC_KEY, PRE_HC_WALLPAPER, szWallpaper, 0, REG_SZ);
            
            // now remove the wallpaper, if necessary

            if (szWallpaper[0])
            {
                szWallpaper[0] = 0;
                hr = p->lpVtbl->SetWallpaper(p, szWallpaper, 0);
                if (SUCCEEDED(hr))
                    hr = p->lpVtbl->ApplyChanges(p, AD_APPLY_ALL);
            }
        }
        p->lpVtbl->Release(p);
    }
}

/***************************************************************************
 * RestoreWallpaper
 *
 * Restores the pre-high contrast wallpaper setting.  Reads the setting
 * stored in the accessibility registry entries and restores the system
 * setting.  No error return as there isn't anything we can do.
 * 
 ***************************************************************************/
void RestoreWallpaper()
{
    long lRv;
    TCHAR szWallpaper[MAX_SCHEME_NAME_SIZE] = {0};

    lRv = GetRegValue(HC_KEY, PRE_HC_WALLPAPER, szWallpaper, sizeof(szWallpaper));
    if (lRv == ERROR_SUCCESS && szWallpaper[0])
    {
        IActiveDesktop *p;
        HRESULT hr;

        hr = CoCreateInstance(
                      &CLSID_ActiveDesktop
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , &IID_IActiveDesktop
                    , (void **)&p);
        if (SUCCEEDED(hr))
        {
            hr = p->lpVtbl->SetWallpaper(p, szWallpaper, 0);
            if (SUCCEEDED(hr))
                hr = p->lpVtbl->ApplyChanges(p, AD_APPLY_ALL);

            p->lpVtbl->Release(p);
        }
    }
}

/***************************************************************************
 * AppearanceRestored
 *
 * lpszName  [in] the name of a theme file (mstheme).  
 * 
 * Function returns TRUE if lpszName is a theme file and it was restored
 * otherwise it returns FALSE.  May return TRUE if restoring the theme
 * fails (not much we can do if theme api's fail).
 * 
 ***************************************************************************/
BOOL AppearanceRestored(LPCWSTR lpszName)
{
    HRESULT hr;
    DWORD   dwThemeFlags;
    int cch = lstrlen(lpszName) - lstrlen(THEME_EXT);
    TCHAR szColor[MAX_SCHEME_NAME_SIZE] = {0};
    TCHAR szSize[MAX_SCHEME_NAME_SIZE] = {0};

    if (cch <= 0 || lstrcmpi(&lpszName[cch], THEME_EXT))
    {
        DBPRINTF(TEXT("AppearanceRestored:  %s is not a theme file\r\n"), lpszName);
        return FALSE;   // this isn't a theme file
    }

    // This is a theme file, get the color and size parts of the theme

    GetRegValue(HC_KEY, PRE_HC_THM_COLOR, szColor, sizeof(szColor));
    GetRegValue(HC_KEY, PRE_HC_THM_SIZE, szSize, sizeof(szSize));

    // Load the theme file, color and size then apply it
    dwThemeFlags = AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS;
    hr = SetSystemVisualStyle(lpszName, szColor, szSize, dwThemeFlags);
    DBPRINTF(TEXT("AppearanceRestored:  SetSystemVisualStyle(%s, %s, %s, 0x%x) returned 0x%x\r\n"), 
                  lpszName, szColor, szSize, dwThemeFlags, hr);

    return TRUE;
}

/***************************************************************************
 * DelRegValue
 *
 * Passed the key and the subkey, delete the subkey.
 *
 ***************************************************************************/
long DelRegValue(LPTSTR RegKey, LPTSTR RegEntry)
{
    HKEY  hReg;                                // Registry handle for schemes
    DWORD Reserved = 0;
    long retval;

    retval = RegCreateKey(HKEY_CURRENT_USER,RegKey, &hReg);
    if (retval != ERROR_SUCCESS)
        return retval;

    retval = RegDeleteValue(hReg, RegEntry);

    RegCloseKey(hReg);
    return retval;
}

#define COLOR_MAX_400       (COLOR_INFOBK + 1)
void FAR SetMagicColors(HDC, DWORD, WORD);


/***************************************************************************
 *
 *
 * SetCurrentSchemeName
 *
 * Input: szName -> name of scheme or theme to become current
 * Output: Boolean success/failure
 *
 ***************************************************************************/

typedef LONG (CALLBACK *APPLETPROC)(HWND, UINT, LPARAM, LPARAM);
typedef BOOL (CALLBACK *SETSCHEME)(LPCTSTR);
typedef BOOL (CALLBACK *SETSCHEMEA)(LPCSTR);

BOOL SetCurrentSchemeName(LPCWSTR lpszName, BOOL fNoReg)
{
    BOOL fRc = FALSE;

    if (fNoReg) 
    {
        // Setting a non-persistent scheme; we come to this code path for
        // both setting or unsetting HC via hot keys

        HKEY hkSchemes;

        // For Whistler, because it may confuse users, we are always turning off
        // theming and any wallpaper.  Otherwise, sometimes they'll loose these
        // settings (when they log off and log back on) and sometimes they won't
        // (when they use the hot keys to turn HC off).

        DBPRINTF(TEXT("SetCurrentSchemeName:  To %s w/o persisting to registry\r\n"), lpszName);
        if (IsThemeActive())
        {
            DBPRINTF(TEXT("SetCurrentSchemeName:  Turning off active Themes\r\n"));
            ApplyTheme(NULL, 0, NULL);
        }

        if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_LOOKSCHEMES, &hkSchemes) == ERROR_SUCCESS) {
            SCHEMEDATA sd;
            DWORD dwType, dwSize;
            BOOL b;
            HDC  hdc;
            int iColors[COLOR_MAX];
            int i;
            COLORREF rgbColors[COLOR_MAX];

            dwType = REG_BINARY;
            dwSize = sizeof(sd);
            if (RegQueryValueEx(hkSchemes, lpszName, NULL, &dwType, (LPBYTE)&sd, &dwSize) == ERROR_SUCCESS && dwType == REG_BINARY) 
           {
                int n;
                if (sd.version != SCHEME_VERSION) {
                    RegCloseKey(hkSchemes);
                    return FALSE;
                    }
                n = (int)(dwSize - (sizeof(sd) - sizeof(sd.rgb))) / sizeof(COLORREF);

                sd.ncm.cbSize = sizeof(NONCLIENTMETRICS);

                b = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(sd.ncm),
                    (void far *)&sd.ncm,
                    0);

                b = SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT),
                    (void far *)(LPLOGFONT)&sd.lfIconTitle,
                    0);

                if (n == COLOR_MAX_400)
                {
                    sd.rgb[COLOR_HOTLIGHT] = sd.rgb[COLOR_ACTIVECAPTION];
                    sd.rgb[COLOR_GRADIENTACTIVECAPTION] = RGB(0,0,0);
                    sd.rgb[COLOR_GRADIENTINACTIVECAPTION] = RGB(0,0,0);
                }

#if(WINVER >= 0x0501)
                // new Whistler colors
                sd.rgb[COLOR_MENUBAR] = sd.rgb[COLOR_MENU];
                sd.rgb[COLOR_MENUHILIGHT] = sd.rgb[COLOR_HIGHLIGHT];

                // reset "flatmenu" and "dropshadows" settings 
                SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
                SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
#endif /* WINVER >= 0x0501 */

            //
            // restore magic colors back to Win31 defaults.
            //
                hdc = GetDC(NULL);
                SetMagicColors(hdc, 0x00c0dcc0, 8);         // money green
                SetMagicColors(hdc, 0x00f0caa6, 9);         // IBM blue
                SetMagicColors(hdc, 0x00f0fbff, 246);       // off white
                ReleaseDC(NULL, hdc);

                for (i=0; i<COLOR_MAX; i++)
                {
                    iColors[i] = i;
                    rgbColors[i] = sd.rgb[i] & 0x00FFFFFF;
                }

                SetSysColors(COLOR_MAX, iColors, rgbColors);
                SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0, SMTO_ABORTIFHUNG, 5000, NULL);
            }
            RegCloseKey(hkSchemes);
           fRc = TRUE;
        }
    } else 
    {
        /*
         * We need to persist this setting.  First see if lpszName is a
         * theme file and restore it if it is
         */
        fRc = AppearanceRestored(lpszName);
        if (!fRc)
        {
            /*
             * The user is in "Windows Classic" appearance so use desk CPL to restore
             */
            HINSTANCE hinst = LoadLibrary(TEXT("DESK.CPL"));
            if (NULL != hinst) 
            {
                APPLETPROC ap = (APPLETPROC)GetProcAddress((HMODULE)hinst, "CPlApplet");
                if (ap) 
                {
                    if (ap(0, CPL_INIT, 0, 0)) 
                    {
                        SETSCHEME ss = (SETSCHEME)GetProcAddress(hinst, "DeskSetCurrentSchemeW");
                        if (ss) 
                        {
                            fRc = ss(lpszName);
                            DBPRINTF(TEXT("SetCurrentSchemeName:  DeskSetCurrentSchemeW(%s) returned %d\r\n"), lpszName, fRc);
                        }

                        ap(0, CPL_EXIT, 0, 0);
                    }
                }
                FreeLibrary(hinst);
            }
        }
    }

    return fRc;
}

/***************************************************************************
 *
 * GetCurrentSchemeName
 *
 * szBuf     [out] Buffer to receive name of scheme (MAXSCHEMENAME) or theme file
 * ctchBuf   [in]  Size of szBuf
 * szColor   [out] If szBuf is a theme file, the color scheme name
 * ctchColor [in]  Size of szColor
 * szSize    [out] If szBuf is a theme file, the font size
 * ctchSize  [in]  Size of szSize
 *
 *     Returns the name of the current scheme.  This will be either the name
 *     of a theme file (if Professional visual style is on) or the name of
 *     a color scheme (if Windows Classic visual style is on).  If the 
 *     current scheme does not have a name, create one (ID_PRE_HC_SCHEME).
 *
 *     If anything goes wrong, there isn't much we can do.
 *
 ***************************************************************************/

void GetCurrentSchemeName(LPTSTR szBuf, long ctchBuf, LPTSTR szColor, long ctchColor, LPTSTR szSize, long ctchSize)
{
    HRESULT hr;

    // First try to get a theme filename

    hr = GetCurrentThemeName(szBuf, ctchBuf, szColor, ctchColor, szSize, ctchSize);
    if (FAILED(hr))
    {
        // User is in Windows Classic appearance (visual style)

        szColor[0] = 0;
        szSize[0] = 0;

        if (GetRegValue(DEFSCHEMEKEY, DEFSCHEMENAME, szBuf, ctchBuf * sizeof(TCHAR))
                       != ERROR_SUCCESS) 
        {
            SCHEMEDATA scm;
            int i;

            /* Load the current scheme into scm */
            scm.version = SCHEME_VERSION;
            scm.wDummy = 0;
            scm.ncm.cbSize = sizeof(NONCLIENTMETRICS);
            SystemParametersInfo(SPI_GETNONCLIENTMETRICS,
                sizeof(NONCLIENTMETRICS),
                &scm.ncm,
                0);

            SystemParametersInfo(SPI_GETICONTITLELOGFONT,
                sizeof(LOGFONT),
                &scm.lfIconTitle,
                0);

            for (i = 0; i < COLOR_MAX; i++) {
                scm.rgb[i] = GetSysColor(i);
            }

            /* Now give it a name */
            SetRegValue(APPEARANCESCHEME, PRE_HC_SCHEME, &scm, sizeof(scm), REG_BINARY);
            /*
             * NOTE -- PRE_HC_SCHEME in APPEARANCESCHEME is actual scheme data, NOT a scheme
             *         name,  This data has info about settings if the user did not have a
             *         desktop scheme in place before switching to high contrast mode.
             */

            wcscpy(szBuf, PRE_HC_SCHEME);
        }
    }
}

/***************************************************************************
 *
 *
 * SetHighContrast
 *
 * Input: None
 * Output: None
 *
 * Outline:
 *
 ***************************************************************************/

int SetHighContrast(BOOL fEnabledOld, BOOL fNoReg)
{
    BOOL fOk = 0;
    TCHAR szBuf[MAX_SCHEME_NAME_SIZE];
    TCHAR szColor[MAX_SCHEME_NAME_SIZE];
    TCHAR szSize[MAX_SCHEME_NAME_SIZE];
    HIGHCONTRAST hc;

    szBuf[0] = TEXT('\0');

    if (!fEnabledOld)
    {
        /*
         * Get the current scheme information (create it if necessary)
         * Note -- we need to put this in the registry, even in "no registry"
         * cases, so we can restore the values.
         */
        GetCurrentSchemeName(szBuf, MAX_SCHEME_NAME_SIZE, szColor, MAX_SCHEME_NAME_SIZE, szSize, MAX_SCHEME_NAME_SIZE);
        DBPRINTF(TEXT("SetHighContrast:  Save to registry ThemeFile=%s Color=%s Size=%s\r\n"), szBuf, szColor, szSize);
        SetRegValue(HC_KEY, PRE_HC_SCHEME, szBuf, 0, REG_SZ); /* Save it */
        SetRegValue(HC_KEY, PRE_HC_THM_COLOR, szColor, 0, REG_SZ);
        SetRegValue(HC_KEY, PRE_HC_THM_SIZE, szSize, 0, REG_SZ);
        /*
         * NOTE -- PRE_HC_SCHEME in HC_KEY is the NAME of the scheme (which may be a made-up
         *         name) holding the settings before High Contrast was invoked.
         */
    }

    hc.cbSize = sizeof(hc);

    SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof hc, &hc, 0);
    if ((NULL != hc.lpszDefaultScheme) && (TEXT('\0') != *(hc.lpszDefaultScheme)))
    {
        lstrcpy(szBuf, hc.lpszDefaultScheme);
    }
    else
    {
       /*
        *  Get the name of the HC scheme.  By design, we have to look
        *  in about fifty places...  We get the default one first, then try
        * to get better and better ones.  That way, when we're done, we have
        *  the best one that succeeded.
        */
        lstrcpy(szBuf, WHITEBLACK_HC);
        GetRegValue(HC_KEY, HIGHCONTRASTSCHEME, szBuf, sizeof(szBuf));
        GetRegValue(DEFSCHEMEKEY, CURHCSCHEME, szBuf, sizeof(szBuf));
    }
    fOk = SetCurrentSchemeName(szBuf, fNoReg);
    if (fOk)
        SaveAndRemoveWallpaper();

    return (short)fOk;
}



/***************************************************************************
 *
 *
 * ClearHighContrast
 *
 * Input: None
 * Output: None
 *
 * Outline:
 *
 *         If high contrast is currently on:
 *
 *                 Get the PRE_HC_SCHEME.
 *
 *                 If able to get it:
 *
 *                         Make it the current scheme.
 *
 *                         If the name is IDS_PRE_HC_SCHEME, then delete the scheme
 *                         data and set the current scheme name to null.  (Clean up.)
 *
 *                 End if
 *
 *                 Set the key that says that high contrast is now off.
 *
 *         End if
 *
 ***************************************************************************/

BOOL FAR PASCAL ClearHighContrast(BOOL fNoReg)
{
    BOOL fOk = FALSE;
    WCHAR szBuf[MAX_SCHEME_NAME_SIZE];

    szBuf[0] = '\0';
    if (ERROR_SUCCESS == GetRegValue(HC_KEY, PRE_HC_SCHEME, szBuf, sizeof(szBuf)))
    {
        DBPRINTF(TEXT("ClearHighContrast:  Reset to pre-HC scheme %s\r\n"), szBuf);
        fOk = SetCurrentSchemeName(szBuf, fNoReg);    // reset the scheme

        // If persisting this setting, wallpaper may need to be restored.
        // If clearing a temporary setting then, to avoid user confusion,
        // we turned theming and wallpaper off permanently.  Otherwise, 
        // sometimes they'll loose these settings (when they log off and 
        // log back on) and sometimes they won't (when they use the hot
        // keys to turn HC off).

        if (!fNoReg)
        {
            RestoreWallpaper();
            if (lstrcmpi(szBuf, PRE_HC_SCHEME) == 0) 
            {
                DelRegValue(APPEARANCESCHEME, PRE_HC_SCHEME);
                DBPRINTF(TEXT("DelRegValue(%s, %s)\r\n"), APPEARANCESCHEME, PRE_HC_SCHEME);
                DelRegValue(DEFSCHEMEKEY, DEFSCHEMENAME);
                DBPRINTF(TEXT("DelRegValue(%s, %s)\r\n"), DEFSCHEMEKEY, DEFSCHEMENAME);
            }
        }
    }

    return fOk;
}


#if NEED_MSG_PUMP
/***************************************************************************\
*  WndProc
*
*  Processes messages for the main window.
\***************************************************************************/
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message) 
	{
        case WM_TIMER:
        if (wParam == 1)
        {
            KillTimer(hWnd, wParam);
            DBPRINTF(TEXT("WM_TIMER\r\n"));
            DestroyWindow(hWnd);
        }
        break;

		case WM_DESTROY:
		PostQuitMessage(0);
		break;

		default:
		return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
#endif

/***************************************************************************\
* WinMain
*
* History:
* 02-01-97  Fritz Sands  Created
* 12-19-00  micw added windowing code so theming calls would work
\***************************************************************************/
int WINAPI WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow)
{
#if NEED_MSG_PUMP
	MSG msg;
	WNDCLASSEX wcex;
    LPTSTR pszWindowClass = TEXT("SetHC"); // message-only window doesn't need localization
    HWND hWnd;
#endif
	UINT index;
	BOOL fSet, fWasSet, fNoReg;


    CoInitialize(NULL);
    
	// Safety checks to make sure that it is not run from command line
	// Should have 3 characters, And all of them numeric...:a-anilk
	if ( strlen(lpszCmdParam) != 3 )
		return 0;

	for ( index = 0; index < 3 ; index++ )
    {
	  if ( lpszCmdParam[index] < '0' || lpszCmdParam[index] > '9' )
      {
		  return 0;
      }
    }
    
	fSet = lpszCmdParam[0] - '0';
    fWasSet = lpszCmdParam[1] - '0';
    fNoReg = lpszCmdParam[2] - '0';
    DBPRINTF(TEXT("WinMain:  fSet=%d fWasSet=%d fNoReg=%d\r\n"), fSet, fWasSet, fNoReg);
    
    // this is to deal with HighContrast, StickyKey, ToggleKey, FilterKey and MouseKeys
    if ( fSet == 2 )
    {
        // this is which Dialog will be displayed 
        LONG lPopup = lpszCmdParam[1] - '0';

        // This indicate wheather we will actually display the dialog or just do the work without asking
        BOOL fNotify = lpszCmdParam[2] - '0';

        DBPRINTF(TEXT("WinMain:  lPopup=%d fNotify=%d\r\n"), lPopup, fNotify );

        // Make sure we don't access outside the bounds of the funtion pointer array
        if ( lPopup < 1 || lPopup > 5 )
            return 0;

        // Index into a table of functions pointers and call the 
        // funtion to bring up the right hotkey dialog.
        g_aRtn[lPopup]( fNotify );
        	
        CoUninitialize();
        return 1;
    }

#if NEED_MSG_PUMP
    // Create a message only window to process messages from theme api

	wcex.cbSize         = sizeof(WNDCLASSEX); 
	wcex.style			= 0;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= NULL;
	wcex.hCursor		= NULL;
	wcex.hbrBackground	= NULL;
	wcex.lpszMenuName	= NULL;
	wcex.lpszClassName	= pszWindowClass;
	wcex.hIconSm		= NULL;

	RegisterClassEx(&wcex);

    hWnd = CreateWindow(pszWindowClass,NULL,0,0,0,0,0,HWND_MESSAGE,NULL,hInstance,NULL);
    if (!hWnd)
    {
        return 0;
    }
#endif

    if (fSet) 
    {
        SetHighContrast(fWasSet, fNoReg);
    }
    else
    {
        ClearHighContrast(fNoReg);
    }

#if NEED_MSG_PUMP

    SetTimer(hWnd, 1, 4000, NULL);

	// The calls to set/unset visual style require that messages
    // be processed.  When the timer goes we'll exit.

	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
#endif

    CoUninitialize();
    return 1;
}

#ifdef DEBUG
void MyOutputDebugString( LPCTSTR lpOutputString, ...)
{
    TCHAR achBuffer[500];
    /* create the output buffer */
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);

    OutputDebugString(achBuffer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\addupgrd.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       addupgrd.h
//
//  Contents:   add upgrade deployment dialog
//
//  Classes:    CAddUpgrade
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddUpgrd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog

class CAddUpgrade : public CDialog
{
// Construction
public:
        CAddUpgrade(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CAddUpgrade)
        enum { IDD = IDD_FIND_UPGRADE };
        int             m_iUpgradeType;
        int             m_iSource;
        //}}AFX_DATA

        CUpgradeData    m_UpgradeData; // out
        CString         m_szPackageName;// out

        UINT            m_cUpgrades;    // in
        map <CString, CUpgradeData> * m_pUpgradeList;
        CString     m_szMyGuid;     // in - script file for the current
                                    //      application (used to exclude the
                                    //      current script file from the
                                    //      potential upgrade set)

        CScopePane * m_pScope;      // in - used to build the list of
                                    //      deployed apps

        CString     m_szGPO;        //      LDAP path to selected GPO
        CString     m_szGPOName;    //      Name of selected GPO;

private:
        map<CString, CUpgradeData> m_NameIndex;
        BOOL        m_fPopulated;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CAddUpgrade)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CAddUpgrade)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        afx_msg void OnCurrentContainer();
        afx_msg void OnOtherContainer();
        afx_msg void OnAllContainers();
        afx_msg void OnBrowse();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\shutdown\main.cpp ===
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <initguid.h>
#include <windowsx.h>
#include <winuserp.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <mdcommsg.h>
#include <lm.h>

#include <shlobj.h>
#include <Cmnquery.h>
#include <dsclient.h>
#include <Dsquery.h>

#include <htmlhelp.h>

#include <reason.h>
#include <regstr.h>
#include "resource.h"

#ifndef WARNING_DIRTY_REBOOT
#define WARNING_DIRTY_REBOOT 0x80000434L
#endif

//#define SNAPSHOT_TEST
#ifdef SNAPSHOT_TEST
#define TESTMSG(x) \
	WriteToConsole((x))
#else
#define TESTMSG(x)
#endif //SNAPSHOT_TEST

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define ERROR_WITH_SZ(id, sz, code) \
    { \
        LPWSTR szBuf = LoadWString(id);\
        if (szBuf)\
        {\
			if (sz && wcslen(sz) > 0) \
			{\
				LPWSTR szBuf1 = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szBuf) + wcslen(sz) + 20) * sizeof(WCHAR));\
				if (szBuf1)\
				{\
                    if (code != 0) \
                        wsprintf(szBuf1, L"%s: %s(%d)\n", sz, szBuf, code);\
                    else \
                        wsprintf(szBuf1, L"%s: %s\n", sz, szBuf);\
					WriteToError(szBuf1);\
					LocalFree(szBuf1);\
				}\
			}\
			else\
			{\
				LPWSTR szBuf1 = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szBuf) + 20) * sizeof(WCHAR));\
				if (szBuf1)\
				{\
                    if (code != 0) \
                        wsprintf(szBuf1, L"%s(%d)\n", szBuf, code);\
                    else \
                        wsprintf(szBuf1, L"%s\n", szBuf);\
					WriteToError(szBuf1);\
					LocalFree(szBuf1);\
				}\
			}\
            LocalFree(szBuf);\
        }\
    }
//
//	Default warning state for warning user check button
//
#define		DEFAULTWARNINGSTATE BST_CHECKED

#define		TITLEWARNINGLEN 32
#define     MINCOMMENTLEN 0

#define		MAX_TIMEOUT 60*10 // 10 min.
#define		DEFAULT_TIMEOUT 30

//	Name of the executable
LPWSTR		g_lpszProgramName = NULL;

// Help dir.
LPWSTR		g_lpszHelpdir = NULL;
LPWSTR		g_lpszHelpdirHlp = NULL;
LPWSTR		g_lpszHelpdirChm = NULL;
LPWSTR      g_lpszHelpdirWindows = NULL;
//	Name of help file.
LPWSTR		HELP_FILE = L"rrc.hlp";
LPWSTR		CHM_FILE = L"rrc.chm";
LPWSTR      WINDOWS_HELP = L"Windows.hlp";
LPWSTR		CHM_MAIN = L"::/rrcHowToShutdownRemotely.htm";
LPWSTR		g_lpszDefaultTimeout = L"30";
LPWSTR		g_lpszMaxTimeout = L"600";

// original edit control win proc.
WNDPROC wpOrigEditProc; 

//
// Help ids
//
DWORD	ShutdownDialogHelpIds[] =
{
	IDOK,                         28443,
	IDCANCEL,                     28444,
	IDHELP,                       28445 ,
    IDC_COMBOACTION,              IDH_SHUTDOWN_COMBOACTION,
    IDC_COMBOOPTION,              IDH_SHUTDOWN_COMBOOPTION,
    IDC_LISTSELECTEDCOMPUTERS,    IDH_SHUTDOWN_SELECTEDCOMPUTERS,
    IDC_BUTTONREMOVE,             IDH_SHUTDOWN_BUTTONREMOVE,
    IDC_BUTTONBROWSE,             IDH_SHUTDOWN_BUTTONBROWSE,
    IDC_CHECKWARNING,             IDH_SHUTDOWN_CHECKWARNING,
    IDC_EDITTIMEOUT,              IDH_SHUTDOWN_EDITTIMEOUT,
    IDC_EDITCOMMENT,              IDH_SHUTDOWN_EDITCOMMENT,
    IDC_BUTTONADDNEW,             IDH_SHUTDOWN_BUTTONADDNEW,
	IDC_CHECK_PLANNED,            IDH_SHUTDOWN_CHECK_PLANNED,

    0, 0
};


DWORD AddNewDialogHelpIds[] =
{
	IDOK,                             28443,
	IDCANCEL,                         28444,
    IDC_EDIT_ADDCOMPUTERS_COMPUTERS,  IDH_ADDNEW_COMPUTERS,

    0, 0
};

//
//	Enum for all of the actions.
//
enum 
{
	ACTION_SHUTDOWN = 0,
	ACTION_RESTART = 1,
    ACTION_ANNOTATE,
	ACTION_LOGOFF,
	ACTION_STANDBY,
	ACTION_DISCONNECT,
	ACTION_ABORT
};

//
//	Resource IDs for actions.
//
DWORD g_dwActions[] = 
{
	IDS_ACTION_SHUTDOWN,
	IDS_ACTION_RESTART,
//	IDS_ACTION_LOGOFF,
    IDS_ACTION_ANNOTATE
	//IDS_ACTION_STANDBY,
	//IDS_ACTION_DISCONNECT,
	//IDS_ACTION_ABORT
};

enum
{
    OPTION_ABORT = 0,
    OPTION_ANNOTATE,
    OPTION_HIBERNATE,
    OPTION_LOGOFF,
    OPTION_POWEROFF,
    OPTION_RESTART,
    OPTION_SHUTDOWN,
    FLAG_COMMENT = 0,
    FLAG_REASON,
    FLAG_MACHINE,
    FLAG_FORCE
};

//
//	Number of actions and the action strings loaded from resource.
//
const int	g_nActions = sizeof(g_dwActions) / sizeof(DWORD);
WCHAR		g_lppszActions[g_nActions][MAX_PATH];

LPWSTR		g_lpszNewComputers = NULL;
WCHAR		g_lpszDefaultDomain[MAX_PATH] = L"";
WCHAR		g_lpszLocalComputerName[MAX_PATH] = L"";
WCHAR		g_lpszTitleWarning[TITLEWARNINGLEN];
BOOL		g_bAssumeShutdown = FALSE;
BOOL        g_bDirty = FALSE;

struct _PROVIDER{
	LPWSTR	szName;
	DWORD	dwLen;
};

typedef struct _SHUTDOWNREASON
{
	DWORD dwCode;
	WCHAR lpName[MAX_REASON_NAME_LEN];
	WCHAR lpDesc[MAX_REASON_DESC_LEN];
} SHUTDOWNREASON, *PSHUTDOWNREASON;

DWORD		g_dwReasonSelect;
DWORD		g_dwActionSelect;

typedef struct _SHUTDOWNCACHEDHWNDS
{
	HWND hwndShutdownDialog;
	HWND hwndListSelectComputers;
	HWND hwndEditComment;
	HWND hwndStaticDesc;
	HWND hwndEditTimeout;
	HWND hwndButtonWarning;
	HWND hwndComboAction;
	HWND hwndComboOption;
	HWND hwndBtnAdd;
	HWND hwndBtnRemove;
	HWND hwndBtnBrowse;
	HWND hwndChkPlanned;
	HWND hwndButtonOK;
    HWND hwndStaticComment;
} SHUTDOWNCACHEDHWNDS, *PSHUTDOWNCACHEDHWNDS;

SHUTDOWNCACHEDHWNDS g_wins;

enum
{
	POWER_OPTION_HIBERNATE,
	POWER_OPTION_POWEROFF
};

HMODULE		g_hDllInstance = NULL;
typedef		BOOL (*REASONBUILDPROC)(REASONDATA *, BOOL, BOOL);
typedef		VOID (*REASONDESTROYPROC)(REASONDATA *);

BOOL		GetComputerNameFromPath(LPWSTR szPath, LPWSTR szName);
VOID		AdjustWindowState();
INT_PTR 
CALLBACK	Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR 
CALLBACK	AddNew_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR 
CALLBACK	Browse_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
BOOL		Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		AddNew_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		Browse_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
BOOL		Browse_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
BOOL		PowerOptionEnabled(UINT option);
BOOL        Annotate(LPCWSTR lpMachine, LPDWORD lpdwReason, LPCWSTR lpComment, LPDWORD lpdwErr);
VOID        report_error(DWORD error_code, LPCWSTR pwszComputer);
BOOL        GetTokenHandle(PHANDLE pTokenHandle);
BOOL        GetUserSid(PTOKEN_USER *ppTokenUser);
BOOL        IsStaticControl (HWND hwnd);
WCHAR*      LoadWString(int resid);

LRESULT APIENTRY EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef         void (*PSetThreadUILanguage)(DWORD);

class ShutdownHelp
{
	DWORD dwCookie;
public:
	ShutdownHelp():dwCookie(NULL)
	{
		HtmlHelp(NULL, NULL, HH_INITIALIZE, (ULONG_PTR)(&dwCookie));
	}

	~ShutdownHelp()
	{
        // HtmlHelp(NULL, NULL, HH_CLOSE_ALL, 0);
		HtmlHelp(NULL, NULL, HH_UNINITIALIZE, dwCookie);
	}
};

class Reasons
{
public:
    PSHUTDOWNREASON m_lpReasons;
    int  		    m_cReasons;
    int             m_dwReasonSelect;
    WCHAR           m_lpszDefaultTitle[MAX_REASON_NAME_LEN];

    Reasons():m_lpReasons(NULL),m_cReasons(0),m_dwReasonSelect(-1)
    {
	    HMODULE				hUser32;
	    REASONBUILDPROC		buildProc;
	    REASONDESTROYPROC	DestroyProc;
	    WCHAR				lpReasonName[MAX_REASON_NAME_LEN];
	    REASONDATA			Reasons;

        m_lpszDefaultTitle[0] = L'\0';
        hUser32 = LoadLibraryW(L"user32.dll");
	    if(hUser32 != NULL)
	    {
		    //
		    //	We are using the user32.dll to get and destroy the reasons.
		    //	The reasons are added to the option combo and also cached for later use.
		    //
            LoadStringW(hUser32, IDS_REASON_DEFAULT_TITLE, m_lpszDefaultTitle, MAX_REASON_NAME_LEN);
            m_lpszDefaultTitle[MAX_REASON_NAME_LEN-1] = L'\0';
		    buildProc = (REASONBUILDPROC)GetProcAddress(hUser32, "BuildReasonArray");
		    DestroyProc = (REASONDESTROYPROC)GetProcAddress(hUser32, "DestroyReasons");
		    if(!buildProc || !DestroyProc)
		    {
			    FreeLibrary(hUser32);
			    hUser32 = NULL;
			    return;
		    }
            if(!(*buildProc)(&Reasons, FALSE, FALSE))
			{
				report_error( GetLastError( ), NULL);
				FreeLibrary(hUser32);
                return;
			}

            if (Reasons.cReasons == 0)
            {

                (*DestroyProc)(&Reasons);

                //
                //  BUG 592702: shutdown.exe .NET - no reasons listed when running on XP.
                //  ON XP if both Clean and Dirty flags are FALSE, user32 won't build 
                //  any reason and return success, so we will retry it with Clean
                //  and Dirty both are set to TRUE.
                //
                if(!(*buildProc)(&Reasons, TRUE, TRUE))
                {
                    report_error( GetLastError( ), NULL);
                    FreeLibrary(hUser32);
                    return;
                }
            }
	    }
        else
        {
            report_error( GetLastError( ), NULL);
            return;
        }

        //
		//	Alloc space for reasons.
		//
		m_lpReasons = (PSHUTDOWNREASON)LocalAlloc(LMEM_FIXED, Reasons.cReasons * sizeof(SHUTDOWNREASON));
		if(!m_lpReasons)
		{
            (*DestroyProc)(&Reasons);
			report_error( GetLastError( ), NULL);
			FreeLibrary(hUser32);
			return;
		}

        //
		//	Now populate the combo according the current check state and action.
		//
		for (int iOption = 0; iOption < (int)Reasons.cReasons; iOption++)
		{
			wcscpy(m_lpReasons[iOption].lpName, Reasons.rgReasons[iOption]->szName);
			wcscpy(m_lpReasons[iOption].lpDesc, Reasons.rgReasons[iOption]->szDesc);
			m_lpReasons[iOption].dwCode = Reasons.rgReasons[iOption]->dwCode;
		}

        m_cReasons = (int)Reasons.cReasons;
		(*DestroyProc)(&Reasons);
		FreeLibrary(hUser32);
    }

    ~Reasons()
    {
        if(m_lpReasons)
            LocalFree(m_lpReasons);
    }

    BOOL RequireComment(DWORD dwReason, BOOL isDirty = FALSE)
    {
        DWORD dwFlag = isDirty ? SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED : SHTDN_REASON_FLAG_COMMENT_REQUIRED;
        DWORD dwDirtyOrClean = isDirty ? SHTDN_REASON_FLAG_DIRTY_UI : SHTDN_REASON_FLAG_CLEAN_UI;
        DWORD dwAll = SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED | SHTDN_REASON_FLAG_COMMENT_REQUIRED
                        | SHTDN_REASON_FLAG_DIRTY_UI | SHTDN_REASON_FLAG_CLEAN_UI;

        if (!m_lpReasons)
            return FALSE;

        if (dwReason & dwFlag)
            return TRUE;

        for(int i = 0; i < m_cReasons; i++)
        {
            if(m_lpReasons[i].dwCode & dwFlag)
            {
                if ( ((m_lpReasons[i].dwCode & ~dwAll) == (dwReason & ~dwAll))
                     && (m_lpReasons[i].dwCode & dwDirtyOrClean) )
                     return TRUE;
            }
        }
        
        return FALSE;
    }

    BOOL RequireComment(DWORD dwMajor, DWORD dwMinor, BOOL isDirty, BOOL isPlanned, BOOL isUserDefined)
    {
        DWORD dwReason = dwMinor;
        dwReason <<= 20;
        dwReason &= dwMajor;

        if(isPlanned)
            dwReason &= SHTDN_REASON_FLAG_PLANNED;

        if(isUserDefined)
            dwReason &=  SHTDN_REASON_FLAG_USER_DEFINED;

        return RequireComment (dwReason, isDirty);
    }

    VOID FillCombo(HWND hwnd, BOOL isDirty, BOOL isPlanned, HWND hwndStatic)
    {
        int iOption;
        int iFirst = -1;
        DWORD dwPlanned = isPlanned ? SHTDN_REASON_FLAG_PLANNED : 0;
        DWORD dwDirty = isDirty ? SHTDN_REASON_FLAG_DIRTY_UI : SHTDN_REASON_FLAG_CLEAN_UI;

        if(! hwnd)
            return;

        //
		//	Remove all items from combo
		//
		while (ComboBox_GetCount(hwnd))
			ComboBox_DeleteString(hwnd, 0);

		//
		//	Now populate the combo according the current check state.
		//
		for (iOption = 0; iOption < (int)m_cReasons; iOption++)
		{
			if(((m_lpReasons[iOption].dwCode & SHTDN_REASON_FLAG_PLANNED) == dwPlanned)
                && ((m_lpReasons[iOption].dwCode & dwDirty) == dwDirty))
			{
				ComboBox_AddString(hwnd, m_lpReasons[iOption].lpName);
                if (iFirst == -1)
                    iFirst = iOption;
			}
		}

        if(iFirst != -1)
        {
            ComboBox_SelectString(hwnd, -1, m_lpReasons[iFirst].lpName);
            if (hwndStatic)
                SetWindowTextW(hwndStatic,  m_lpReasons[iFirst].lpDesc);
        }
        m_dwReasonSelect = iFirst;
    }

    VOID SetDesc(HWND hCombo, HWND hDesc)
    {
        WCHAR szName[MAX_REASON_NAME_LEN];

        if(!hCombo || !hDesc)
            return;

        GetWindowText(hCombo, (LPWSTR)szName, MAX_REASON_NAME_LEN);
        szName[MAX_REASON_NAME_LEN-1] = '\0';

		for(DWORD dwIndex = 0; dwIndex < (DWORD)m_cReasons; dwIndex++)
		{
			if(lstrcmp(szName, m_lpReasons[dwIndex].lpName) == 0)
			{
				SetWindowTextW(hDesc, m_lpReasons[dwIndex].lpDesc);
				m_dwReasonSelect = dwIndex;
				break;
			}
		}
    }

    VOID GetReasonTitle(DWORD dwReason, LPWSTR szBuf, DWORD dwSize)
    {
        DWORD dwFlagBits = SHTDN_REASON_FLAG_CLEAN_UI | SHTDN_REASON_FLAG_DIRTY_UI;
        if(!szBuf || dwSize == 0)
            return;
        for(int i = 0; i < m_cReasons; i++)
        {
            if ((dwReason & SHTDN_REASON_VALID_BIT_MASK) == (m_lpReasons[i].dwCode & SHTDN_REASON_VALID_BIT_MASK)) 
            {
                if ((!(dwReason & dwFlagBits) && !(m_lpReasons[i].dwCode & dwFlagBits))
                    || (dwReason & SHTDN_REASON_FLAG_CLEAN_UI && m_lpReasons[i].dwCode & SHTDN_REASON_FLAG_CLEAN_UI)
                    || (dwReason & SHTDN_REASON_FLAG_DIRTY_UI && m_lpReasons[i].dwCode & SHTDN_REASON_FLAG_DIRTY_UI) ) { // check flag bits.
                    lstrcpynW(szBuf, m_lpReasons[i].lpName, dwSize - 1);
                    szBuf[dwSize - 1] = '\0';
                    return;
                }
            }
        }
        wcsncpy(szBuf, m_lpszDefaultTitle, dwSize - 1);
        szBuf[dwSize - 1] = '\0';
    }

} g_reasons;

//
//	Check whether a string is all white spaces.
//
BOOL 
IsEmpty(LPCWSTR lpCWSTR)
{
	if(!lpCWSTR)
		return TRUE;
	while(*lpCWSTR && (*lpCWSTR == '\n' || *lpCWSTR == '\t' || *lpCWSTR == '\r' || *lpCWSTR == ' '))
		lpCWSTR++;
	if(*lpCWSTR)
		return FALSE;
	return TRUE;
}

// Write the string to console
VOID
WriteOutput(
    LPWSTR  pszMsg,
	DWORD	nStdHandle
    )
{
	HANDLE	hConsole = GetStdHandle( nStdHandle );

    if ( !pszMsg || !*pszMsg )
        return;

    DWORD   dwStrLen        = lstrlenW( pszMsg );
    LPSTR   pszAMsg         = NULL;
    DWORD   dwBytesWritten  = 0;
    DWORD   dwMode          = 0;

    if ( (GetFileType ( hConsole ) & FILE_TYPE_CHAR ) && 
         GetConsoleMode( hConsole, &dwMode ) )
    {
         WriteConsoleW( hConsole, pszMsg, dwStrLen, &dwBytesWritten, 0 );
         return;
    } 	
    
    // console redirect to a file.
    if ( !(pszAMsg = (LPSTR)LocalAlloc(LMEM_FIXED, (dwStrLen + 1) * sizeof(WCHAR) ) ) )
    {
        return;
    }

    if (WideCharToMultiByte(GetConsoleOutputCP(),
                                    0,
                                    pszMsg,
                                    -1,
                                    pszAMsg,
                                    dwStrLen * sizeof(WCHAR),
                                    NULL,
                                    NULL) != 0 
									&& hConsole)
    {
        WriteFile(  hConsole,
                        pszAMsg,
                        lstrlenA(pszAMsg),
                        &dwBytesWritten,
                        NULL );
    
    }
    
    LocalFree( pszAMsg );
}

// Write the string to stdout
VOID
WriteToConsole(
    LPWSTR  pszMsg
    )
{
	WriteOutput(pszMsg, STD_OUTPUT_HANDLE);
}

// Write the string to stderr
VOID
WriteToError(
    LPWSTR  pszMsg
    )
{
	WriteOutput(pszMsg, STD_ERROR_HANDLE);
}

// Report error.
VOID
report_error(
    DWORD error_code,
    LPCWSTR szComputer
    )
{
    LPVOID msgBuf = 0;
    LPWSTR szBuf = NULL;
    int len = 0;

    if (error_code == 997 || error_code == 0)
        return;

    if (error_code == ERROR_NOT_READY)
    {
        ERROR_WITH_SZ(IDS_ERROR_NOT_READY, szComputer, error_code);
        return;
    }
    else if (error_code == ERROR_BAD_NETPATH || error_code == WSAHOST_NOT_FOUND)
    {
        ERROR_WITH_SZ(IDS_ERROR_NOT_AVAILABLE, szComputer, error_code);
        return;
    }
    else 
        FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            error_code,
            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
            reinterpret_cast< wchar_t* >( &msgBuf ),
            0,
            NULL);

    if (msgBuf)
    {
        // remove end newline.
        len = wcslen(reinterpret_cast< wchar_t* >( msgBuf ));
        reinterpret_cast< wchar_t* >( msgBuf )[len - 2] = L'\0';
        if (szComputer && wcslen(szComputer) > 0)
	    {
		    LPWSTR szBuf1 = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                            (len + wcslen(szComputer) + 20) * sizeof(WCHAR));
		    if (szBuf1)
		    {
                wsprintf(szBuf1, L"%s: %s(%d)\n", szComputer, reinterpret_cast< wchar_t* >( msgBuf ), error_code);
			    WriteToError(szBuf1);
			    LocalFree(szBuf1);
		    }
	    }
	    else
	    {
		    LPWSTR szBuf1 = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                            (len + 20) * sizeof(WCHAR));
		    if (szBuf1)
		    {
                wsprintf(szBuf1, L"%s(%d)\n", reinterpret_cast< wchar_t* >( msgBuf ), error_code);
			    WriteToError(szBuf1);
			    LocalFree(szBuf1);
		    }
	    }

        LocalFree( msgBuf );
    }
}

BOOL
parse_reason_code(
    LPCWSTR  arg,
    LPDWORD  lpdwReason
    )
{
    // Code consists of flags;major;minor
	// Qingboz: Now we make major and minor code mandatory
	//

    BOOL fMajor = FALSE;
    BOOL fMinor = FALSE;
    BOOL fUserDefined = FALSE;
    int major = 0;
    int minor = 0;

    const int state_start = 0;
    const int state_flags = 0;
    const int state_major = 1;
    const int state_minor = 2;
    const int state_null = 3;
    const int state_done = 4;

    for( int i = 0, state = state_start; state != state_done; ++i )
    {
        switch( state )
        {
        case state_flags :
            // Expecting flags
            switch( arg[ i ] ) {
            case L'U' : case L'u' :
				if(fUserDefined)
				{
					//
					//	Already set.
					//
					return FALSE;
				}
                fUserDefined = TRUE;
                break;
            case L'P' : case L'p' :
				if(*lpdwReason & 0x80000000)
				{
					//
					//	Already set.
					//
					return FALSE;
				}
                *lpdwReason |= 0x80000000; // SHTDN_REASON_FLAG_PLANNED
                break;
            case L':' :
                if(i == 0) // ':' cannot be the first one now.
                    return FALSE;
                state = state_major;
                break;
			case L'0':
			case L'1':
			case L'2':
			case L'3':
			case L'4':
			case L'5':
			case L'6':
			case L'7':
			case L'8':
			case L'9':
				if(i != 0) // A number here must be the first one.
					return FALSE;
				state = state_major;
				i--; // Go back one.
				break;
            default :
                return FALSE;
            }
            break;
        case state_major :
            // Expecting major
            if( arg[ i ] >= L'0' && arg[ i ] <= L'9' ) {
                fMajor = TRUE;
                major = major * 10 + arg[ i ] - L'0';
            }
            else {
                if(!fMajor)
                    return FALSE;
                // Make sure we only have 8 bits
                if( major > 0xff ) return FALSE;
                if (major >= 64)
                    *lpdwReason |= SHTDN_REASON_FLAG_USER_DEFINED;

                *lpdwReason |= major << 16;
                if( arg[ i ] != L':') {
                    // missing minor reason.
                    return FALSE;
                }
                
                state = state_minor;
            }
            break;
        case state_minor :
            // Expecting minor reason
            if( arg[ i ] >= L'0' && arg[ i ] <= L'9' ) {
                fMinor = TRUE;
                minor = minor * 10 + arg[ i ] - L'0';
            }
            else {
                if(!fMinor)
                    return FALSE;
                // Make sure we only have 16 bits
                if( minor > 0xffff ) return FALSE;
                *lpdwReason = ( *lpdwReason & 0xffff0000 ) | minor;
                if( arg[ i ] != 0 ) 
					return FALSE;
                return TRUE;
            }
            break;
        default :
            return FALSE;
        }
    }
    return FALSE;
}


// Parses an integer if it is in decimal notation.
// Returns FALSE if it is malformed.
BOOL
parse_int(
    const wchar_t* arg,
    LPDWORD lpdwInt
    )
{
    *lpdwInt = 0;
    while( *arg ) {
        if( *arg >= L'0' && *arg <= L'9' ) {
            *lpdwInt = *lpdwInt * 10 + int( *arg++ - L'0' );
        }
        else {
            return FALSE;
        }
    }
    return TRUE;
}

// Parse options.
// Returns FALSE if the option strings are malformed.  This causes the usage to be printed.
BOOL
parse_options(
    int      argc,
    wchar_t  *argv[],
    LPBOOL   lpfLogoff,
    LPBOOL   lpfForce,
    LPBOOL   lpfReboot,
	LPBOOL   lpfHibernate,
    LPBOOL   lpfAbort,
	LPBOOL	 lpfPoweroff,
    LPBOOL   lpfAnnotate,
    LPWSTR   *ppServerName,
    LPWSTR   *ppMessage,
    LPDWORD  lpdwTimeout,
    LPDWORD  lpdwReason
    )
{
    BOOL  fShutdown = FALSE;
	BOOL  fTimeout = FALSE;
	BOOL  fComment = FALSE;
	BOOL  fMachine = FALSE;
	BOOL  fReason = FALSE;
    DWORD dwOption = 0;
    DWORD dwFlag = 0;

    *lpfLogoff    = FALSE;
    *lpfForce     = FALSE;
    *lpfReboot    = FALSE;
	*lpfHibernate = FALSE;
    *lpfAbort     = FALSE;
	*lpfPoweroff  = FALSE;
    *lpfAnnotate  = FALSE;
    *ppServerName = NULL;
    *ppMessage    = NULL;
    *lpdwTimeout  = DEFAULT_TIMEOUT;
    *lpdwReason   = 0xff;

	//
	//	Set default reason to be planned
	//
	*lpdwReason |= SHTDN_REASON_FLAG_PLANNED;

    for( int i = 1; i < argc; ++i )
    {
        wchar_t* arg = argv[ i ];

        switch( arg[ 0 ] )
        {
            case L'/' : case L'-' :

                switch( arg[ 1 ] )
                {
                    case L'L' : case L'l' :

						if (*lpfLogoff)
							return FALSE;
                        *lpfLogoff = TRUE;
                        if (arg[2] != 0) return FALSE;
                        dwOption++;
                        break;

                    case L'S' : case L's' :

                        //
                        // Use server name if supplied  (i.e. do nothing here)
                        //

						if(fShutdown)
							return FALSE;

                        fShutdown = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;

                    case L'F' : case L'f' :
						if (*lpfForce)
							return FALSE;

                        *lpfForce = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        break;

					case L'H' : case L'h' :
						if (*lpfHibernate)
							return FALSE;

                        *lpfHibernate = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;                        

                    case L'R' : case L'r' :
						if (*lpfReboot)
							return FALSE;

                        *lpfReboot = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;

                    case L'A' : case L'a' :
						if (*lpfAbort)
							return FALSE;
                        *lpfAbort = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;

					case L'P' : case L'p' :
						if (*lpfPoweroff)
							return FALSE;
                        *lpfPoweroff = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;

                    case L'E' : case L'e' :
						if (*lpfAnnotate)
							return FALSE;
                        *lpfAnnotate = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        dwOption++;
                        break;

                    case L'T' : case L't' :

                        //
                        // Next arg should be number of seconds
                        //

						if(fTimeout) // Already did.
						{
							return FALSE;
						}

                        if (++i == argc)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

                        if( arg[ 0 ] < L'0' || arg[ 0 ] > L'9' ) return FALSE;
                        if( !parse_int( arg, lpdwTimeout )) return FALSE;
						if(*lpdwTimeout > MAX_TIMEOUT)
							return FALSE;
						fTimeout = TRUE;
                        break;

                    case L'Y' : case L'y' :

                        // Ignore this option.
                        break;

                    case L'D' : case L'd' :

                        //
                        // Next arg should be reason code
                        //

						if (fReason)
							return FALSE;

                        if (++i == argc)
                        {
                            return FALSE;
                        }

                        arg = argv[i];
						
						//
						//If reason code is given, we clear the planned bit.
						//
						*lpdwReason = (DWORD)0xFF;

                        if( !parse_reason_code( arg, lpdwReason ))
                        {
                            return FALSE;
                        }

						fReason = TRUE;

                        break;

                    case L'C' : case L'c' :

                        //
                        // Next arg should be shutdown message.  Make
                        // sure only one is specified.
                        //
						if (fComment)
							return FALSE;

                        if (++i == argc || *ppMessage)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

						if(wcslen(arg) > MAX_REASON_COMMENT_LEN - 1 || wcslen(arg) <= MINCOMMENTLEN)
							return FALSE;

                        *ppMessage = arg;
						fComment = TRUE;

                        break;

                    case L'M' : case L'm' :

                        //
                        // Next arg should be machine name.  Make
                        // sure only one is specified.
                        //
						
						if (fMachine)
							return FALSE;

                        if (++i == argc || *ppServerName)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

                        if (arg[0] == L'\\' && arg[1] == L'\\')
                        {
                            *ppServerName = arg + 2;
                        }
                        else
                        {
                            *ppServerName = arg;
                        }
							
						fMachine = TRUE;

                        break;

                    case L'?' : default : 

                        return FALSE;
                }

                break;

            default :

                //
                // Junk
                //

                return FALSE;
        }
    }


    //
    // Check for mutually exclusive options
    //

    if (dwOption > 1)
        return FALSE;

    //
    // Default is to logoff
    //

	if (dwOption == 0)
    {
        *lpfLogoff = TRUE;
    }

    //
    // Only -f can go with -l
    //

    if (*lpfLogoff && (fTimeout || fReason || fComment || fMachine))
        return FALSE;

    //
    // -a can only take -m
    //

    if (*lpfAbort && (fTimeout || fReason || *lpfForce || fComment))
        return FALSE;

    //
    //  -h only with -f
    //

    if (*lpfHibernate && (fTimeout || fReason || fComment || fMachine))
        return FALSE;

    //
    //  -p can only take -d
    //

    if (*lpfPoweroff && (fTimeout || *lpfForce || fComment || fMachine))
        return FALSE;

    //
    //  -e must have -d.
    //

    if (*lpfAnnotate)
    {
        if (*lpfForce || fTimeout)
            return FALSE;
        if (! fReason)
            return FALSE;
    }

    //
    //  Shutdown and reboot the same, comment must require a reason.
    //  Removed upon request.
    //
#if 0
    if (fShutdown || *lpfReboot)
    {
        if (fComment && !fReason)
            return FALSE;
    }
#endif

    //
    //  Add the clean or dirty flag.
    //

    if (*lpfAnnotate)
        *lpdwReason |= SHTDN_REASON_FLAG_DIRTY_UI;
    else
        *lpdwReason |= SHTDN_REASON_FLAG_CLEAN_UI;

    return TRUE;
}


// Print out usage help string.
VOID
usage(
    VOID
    )
{
    HMODULE  	hModule = GetModuleHandle( NULL );
	HMODULE             hUser32;
	REASONBUILDPROC     buildProc;
	REASONDESTROYPROC   DestroyProc;
	WCHAR               lpReasonName[MAX_PATH];
	REASONDATA          Reasons;

    if( hModule == NULL )
    {
        report_error( GetLastError(), NULL);
        return;
    }

	for (DWORD i = IDS_USAGE0; i < IDS_USAGE_END; i++)
	{
        WCHAR *szBuf = LoadWString(i);
        if(!szBuf)
            continue;
		if (i == IDS_USAGE0)
		{
			LPWSTR msg = (LPWSTR) LocalAlloc(LMEM_FIXED, (lstrlenW(szBuf) + lstrlenW( g_lpszProgramName ) + 2) * sizeof(WCHAR));
			if(!msg)
			{
                LocalFree(szBuf);
				report_error( GetLastError(), NULL);
				return;
			}
			swprintf(msg, szBuf, g_lpszProgramName );
			WriteToConsole( msg );
			LocalFree(msg);
		}
		else
        {
			WriteToConsole( szBuf );
        }
        LocalFree(szBuf);
	}

	//
	//	Now print out the reasons.
	//
    WCHAR szCode[MAX_PATH];
	WCHAR *szTitle = LoadWString(IDS_REASONLISTTITLE);
        
    if(szTitle)
    {
	    WriteToConsole(szTitle);
        LocalFree(szTitle);
    }

	for (int iOption = 0; iOption < (int)g_reasons.m_cReasons; iOption++)
	{
		WriteToConsole(L"\n");

		if(g_reasons.m_lpReasons[iOption].dwCode &  SHTDN_REASON_FLAG_CLEAN_UI)
			WriteToConsole(L"E");
		else
			WriteToConsole(L" ");

        if(g_reasons.m_lpReasons[iOption].dwCode &  SHTDN_REASON_FLAG_DIRTY_UI)
			WriteToConsole(L"U");
		else
			WriteToConsole(L" ");

		if(g_reasons.m_lpReasons[iOption].dwCode &  SHTDN_REASON_FLAG_PLANNED)
			WriteToConsole(L"P");
		else
			WriteToConsole(L" ");

		if(g_reasons.m_lpReasons[iOption].dwCode &  SHTDN_REASON_FLAG_USER_DEFINED)
			WriteToConsole(L"C");
		else
			WriteToConsole(L" ");

		swprintf(szCode, L"\t%d\t%d\t", (g_reasons.m_lpReasons[iOption].dwCode & 0x00ff0000)>>16, 
			g_reasons.m_lpReasons[iOption].dwCode & 0x0000ffff);
		WriteToConsole(szCode);
		WriteToConsole(g_reasons.m_lpReasons[iOption].lpName);
	}
    if(iOption)
        WriteToConsole(L"\n");
}


// We need shutdown privileges enabled to be able to shut down our machines.
BOOL
enable_privileges(
    LPCWSTR  lpServerName,
    BOOL     fLogoff 
    )
{
    NTSTATUS	Status = STATUS_SUCCESS;
	NTSTATUS	Status1 = STATUS_SUCCESS;
    BOOLEAN		fWasEnabled;

    if (fLogoff)
    {
        //
        // No privileges to get
        //

        return TRUE;
    }

	//
	//	We will always enable both privileges so 
	//	it can work for telnet sessions.
	//
	Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
									TRUE,
									FALSE,
									&fWasEnabled);

	Status1 = RtlAdjustPrivilege(SE_REMOTE_SHUTDOWN_PRIVILEGE,
									TRUE,
									FALSE,
									&fWasEnabled);

    return TRUE;
}

BOOL		
PowerOptionEnabled(
	UINT option
	)
//  --------------------------------------------------------------------------
//  PowerOptionEnabled
//
//  Arguments:  option
//
//  Returns:    TRUE indicates the option is enabled.
//
//  Purpose:    Detects if the specified power option is enabled on the system.
//
//  --------------------------------------------------------------------------
{
    NTSTATUS                    status;
    SYSTEM_POWER_CAPABILITIES   spc;
    BOOL RetVal = FALSE;

    status = NtPowerInformation(SystemPowerCapabilities,
                                NULL,
                                0,
                                &spc,
                                sizeof(spc));
	switch (option)
	{
	case POWER_OPTION_HIBERNATE:
		if (NT_SUCCESS(status) && spc.HiberFilePresent){
			RetVal = TRUE;
		}
		break;
	case POWER_OPTION_POWEROFF:
		if (NT_SUCCESS(status) && spc.SystemS5){
			RetVal = TRUE;
		}
		break;
	default:
		break;
	}
    
    return(RetVal);
}

BOOL WINAPI ConsoleHandlerRoutine(
    DWORD   dwCtrlType
    )
//  --------------------------------------------------------------------------
//
//  Ignore the Ctrl-C and Ctrl-Break.
//
//  Arguments:  type of the control signal
//
//  Returns:    TRUE if the function handles the control.
//              if return FALSE, the next handler function in the list is used.
//
//  --------------------------------------------------------------------------
{
    if ( dwCtrlType == CTRL_BREAK_EVENT ||
         dwCtrlType == CTRL_C_EVENT )
         return TRUE;
    
    return FALSE;
}

int __cdecl
wmain(
    int      argc,
    wchar_t *argv[]
    )
{
    BOOL    fLogoff;
    BOOL    fForce;
    BOOL    fReboot;
    BOOL    fAbort;
	BOOL	fPoweroff;
    BOOL    fAnnotate;
	BOOL    fHibernate;
    LPWSTR  lpServerName;
    LPWSTR  lpMessage;
    DWORD   dwTimeout;
    DWORD   dwReason = 0;
	DWORD	dwRet = 0;
	INT_PTR hResult;
	NTSTATUS Status;
    WCHAR   szComment[MAX_REASON_COMMENT_LEN];

	HINSTANCE hInstance;

    //
    //  ignore any control-c / control-break 
    //
    SetConsoleCtrlHandler(ConsoleHandlerRoutine, TRUE);
    
    if ( (hInstance = LoadLibrary( L"kernel32.dll" ) ) )
    {
        PSetThreadUILanguage SetThreadUILang = (PSetThreadUILanguage)GetProcAddress( hInstance, "SetThreadUILanguage" );
        
        if ( SetThreadUILang )
             (*SetThreadUILang)( 0 );

        FreeLibrary( hInstance );
    }

    if(!GetEnvironmentVariableW(L"COMPUTERNAME", g_lpszLocalComputerName, MAX_PATH))
	{
		report_error(GetLastError(), NULL);
        return 1;
	}

    g_hDllInstance = GetModuleHandle(NULL);
    if (!g_hDllInstance)
    {
        report_error(GetLastError(), g_lpszLocalComputerName);
        return 1;
    }

    // We use the program name for reporting errors.
    g_lpszProgramName = argv[ 0 ];

	//
	//	Userdomain is used as the default domain.
	//
	if(!GetEnvironmentVariableW(L"USERDOMAIN", g_lpszDefaultDomain, MAX_PATH))
	{
		report_error(GetLastError(), g_lpszLocalComputerName);
		return 1;
	}

	//
	//	if there is no arguments, we will display help.
	//
	if(argc == 1)
	{
		usage();
        return 0;
	}

	//
	//	If the first argument is -i or /i, we pop up UI.
	//
	if(wcsncmp(argv[1], L"-i", 2) == 0 || wcsncmp(argv[1], L"/i", 2) == 0
		|| wcsncmp(argv[1], L"-I", 2) == 0 || wcsncmp(argv[1], L"/I", 2) == 0)
	{
		if(g_hDllInstance)
		{
            ShutdownHelp shutdownHelp;
			int len = GetEnvironmentVariableW(L"SystemRoot", g_lpszHelpdir, 0);
			if(len)
			{
				g_lpszHelpdir = new WCHAR[len + 6];
				if(g_lpszHelpdir)
				{
					GetEnvironmentVariableW(L"SystemRoot", g_lpszHelpdir, len+6);
					wcscat(g_lpszHelpdir, L"\\");
					wcscat(g_lpszHelpdir, L"Help\\");
				}
                else
                {
                    dwRet = ERROR_OUTOFMEMORY;
                    goto exit;
                }
                
                g_lpszHelpdirHlp = new WCHAR[wcslen(g_lpszHelpdir) + wcslen(HELP_FILE) + 1];
                if (g_lpszHelpdirHlp)
                {
                    wcscpy(g_lpszHelpdirHlp, g_lpszHelpdir);
                    wcscat(g_lpszHelpdirHlp, HELP_FILE);
                }
                else
                {
                    dwRet = ERROR_OUTOFMEMORY;
                    goto exit;
                }

                g_lpszHelpdirChm = new WCHAR[wcslen(g_lpszHelpdir) + wcslen(CHM_FILE) + wcslen(CHM_MAIN) + 1];
                if (g_lpszHelpdirChm)
                {
                    wcscpy(g_lpszHelpdirChm, g_lpszHelpdir);
                    wcscat(g_lpszHelpdirChm, CHM_FILE);
                    wcscat(g_lpszHelpdirChm, CHM_MAIN);
                }
                else
                {
                    dwRet = ERROR_OUTOFMEMORY;
                    goto exit;
                }

                g_lpszHelpdirWindows = new WCHAR[wcslen(g_lpszHelpdir) + wcslen(WINDOWS_HELP) + 1];
                if (g_lpszHelpdirWindows)
                {
                    wcscpy(g_lpszHelpdirWindows, g_lpszHelpdir);
                    wcscat(g_lpszHelpdirWindows, WINDOWS_HELP);
                }
                else
                {
                    dwRet = ERROR_OUTOFMEMORY;
                    goto exit;
                }

			}
			hResult = DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOGSHUTDOWN), NULL, Shutdown_DialogProc, NULL);
            dwRet = (DWORD)HRESULTTOWIN32(hResult);
exit:
			if(g_lpszHelpdir)
				delete [] g_lpszHelpdir;
            if(g_lpszHelpdirHlp)
                delete [] g_lpszHelpdirHlp;
            if(g_lpszHelpdirChm)
                delete [] g_lpszHelpdirChm;
            if(g_lpszHelpdirWindows)
                delete [] g_lpszHelpdirWindows;

            if (dwRet != 0)
                report_error(dwRet, NULL);
			WinHelpW((HWND)0, NULL, HELP_QUIT, 0) ;
		}
		return dwRet;
	}
    // Parse the options.
    if( !parse_options( argc,
                        argv,
                        &fLogoff,
                        &fForce,
                        &fReboot,
						&fHibernate,
                        &fAbort,
						&fPoweroff,
                        &fAnnotate,
                        &lpServerName,
                        &lpMessage,
                        &dwTimeout,
                        &dwReason ))
    {
        usage();
        return 1;
    }

    //
    //  Add the comment field for the reason.
    //
    if (g_reasons.RequireComment(dwReason, fAnnotate))
    {
        if (fAnnotate)
            dwReason |= SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED;
        else
            dwReason |= SHTDN_REASON_FLAG_COMMENT_REQUIRED;
    }

    //
    //  Promote (no more)for comment if it is required and not given
    //
    if (g_reasons.RequireComment(dwReason, fAnnotate) && (!lpMessage || wcslen(lpMessage) == 0))
    {
        lpMessage = NULL;
    }

    // Get all privileges so that we can shutdown the machine.
    enable_privileges( lpServerName, fLogoff );

    // Do the work.
    if( fAbort )
    {
        if( !AbortSystemShutdownW( lpServerName ))
        {
			dwRet = GetLastError();
            report_error( dwRet, lpServerName);
        }
    }
    else if (fLogoff)
    {
        if (!ExitWindowsEx(fForce ? (EWX_LOGOFF | EWX_FORCE) : (EWX_LOGOFF | EWX_FORCEIFHUNG),
                           0))
        {
            dwRet = GetLastError();
            report_error( dwRet, g_lpszLocalComputerName);
        }
    }
	else if (fHibernate) 
	{
        if (!PowerOptionEnabled(POWER_OPTION_HIBERNATE)) 
		{
            ERROR_WITH_SZ(IDS_ERR_HIBERNATE_NOT_ENABLED, lpServerName, GetLastError());
        } 
		else 
		{
            Status = NtInitiatePowerAction(
                                PowerActionHibernate, 
                                PowerSystemSleeping1, 
                                fForce 
                                 ? POWER_ACTION_CRITICAL 
                                 : POWER_ACTION_QUERY_ALLOWED, 
                                FALSE);
            if (!NT_SUCCESS(Status)) 
			{
				dwRet = RtlNtStatusToDosError(Status);
				report_error( dwRet, lpServerName);
            }
        }
    } 
	else if (fPoweroff)
	{
		//
		//	Special case, we call ExitWindowsEx
		//	Check whether power off is supported, if not just shutdown the machine.
		//	Although we fixed ExitWindowsEx, but we will leave this so it will work
		//	with older builds.
		//
		if(PowerOptionEnabled(POWER_OPTION_POWEROFF))
		{
			if (!ExitWindowsEx(EWX_POWEROFF, dwReason))
			{
				dwRet = GetLastError();
				report_error( dwRet, lpServerName);
			}
		}
		else
		{
			if (!ExitWindowsEx(EWX_SHUTDOWN, dwReason))
			{
				dwRet = GetLastError();
				report_error( dwRet, lpServerName);
			}
		}
	}
    else if (fAnnotate)
	{
		//
        // Annotate dirty shutdown.
        //
        Annotate(lpServerName, &dwReason, lpMessage, &dwRet);
	}
    else
    {
        // Do the normal form.
        if( !InitiateSystemShutdownExW( lpServerName,
                                        lpMessage,
                                        dwTimeout,
                                        fForce,
                                        fReboot,
                                        dwReason ))
        {
            dwRet = GetLastError();
			report_error( dwRet, lpServerName);
        }
    }

	return dwRet;
}

//
//	Get computername from ADSI path
//	Here we only handle WinNT, LDAP, NWCOMPAT, and NDS.
//
BOOL GetComputerNameFromPath(LPWSTR szPath, LPWSTR szName)
{
	static _PROVIDER p[] =
	{
		{L"LDAP://", 7},
		{L"WinNT://", 8}, 
		{L"NWCOMPAT://", 11},
		{L"NDS://", 6}
	};

	static UINT np = sizeof(p)/sizeof(_PROVIDER);
	LPWSTR lpsz = NULL;

	if(!szPath || !szName)
		return FALSE;

	for(UINT i = 0; i < np; i++)
	{
		if(wcsncmp(szPath, p[i].szName, p[i].dwLen) == 0)
		{
			switch(i)
			{
			case 0: //	LDAP
				lpsz = wcsstr(szPath, L"CN=");
				if(!lpsz)
					return FALSE;
				lpsz += 3;
				
				while(*lpsz && *lpsz != ',')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			case 1: //	WinNT
			case 2: //	NWCOMPAT
				lpsz = szPath + p[i].dwLen;
				//
				//	skip domain or provider path
				//
				while(*lpsz && *lpsz != '/')
					lpsz++;
				lpsz++;

				while(*lpsz && *lpsz != '/')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			case 3: //	NDS
				lpsz = wcsstr(szPath, L"CN=");
				if(!lpsz)
					return FALSE;
				lpsz += 3;
				
				while(*lpsz && *lpsz != '/')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

//
//	A centralized place for adjusting window states.
//
VOID AdjustWindowState()
{
	if(g_dwActionSelect == ACTION_SHUTDOWN || g_dwActionSelect == ACTION_RESTART || g_dwActionSelect == ACTION_ANNOTATE)
	{
        if (g_dwActionSelect == ACTION_ANNOTATE)
        {
            EnableWindow(g_wins.hwndButtonWarning, FALSE);
            EnableWindow(g_wins.hwndEditTimeout, FALSE);
        }
        else
        {
		    EnableWindow(g_wins.hwndButtonWarning, TRUE);
		    if (IsDlgButtonChecked(g_wins.hwndShutdownDialog, IDC_CHECKWARNING) == BST_CHECKED)
			    EnableWindow(g_wins.hwndEditTimeout, TRUE);
		    else
			    EnableWindow(g_wins.hwndEditTimeout, FALSE);
        }

		EnableWindow(g_wins.hwndEditComment, TRUE);
		if(g_bAssumeShutdown)
		{
			EnableWindow(g_wins.hwndComboOption, FALSE);
			EnableWindow(g_wins.hwndChkPlanned, FALSE);
			EnableWindow(g_wins.hwndButtonOK, TRUE);
		}
		else
		{
			EnableWindow(g_wins.hwndComboOption, TRUE);
			EnableWindow(g_wins.hwndChkPlanned, TRUE);
			if((g_reasons.m_dwReasonSelect != -1) 
                && g_reasons.RequireComment(g_reasons.m_lpReasons[g_reasons.m_dwReasonSelect].dwCode, g_dwActionSelect == ACTION_ANNOTATE))
			{
                LPWSTR szStaticComment = LoadWString(IDS_COMMENT_REQUIRED);
                if(szStaticComment)
                {
                    SetWindowTextW(g_wins.hwndStaticComment, szStaticComment);
                    LocalFree(szStaticComment);
                }
				if(Edit_GetTextLength(g_wins.hwndEditComment) > MINCOMMENTLEN
					&& ListBox_GetCount(g_wins.hwndListSelectComputers) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
			else
			{
                LPWSTR szStaticComment = LoadWString(IDS_COMMENT_OPTIONAL);
                if(szStaticComment)
                {
                    SetWindowTextW(g_wins.hwndStaticComment, szStaticComment);
                    LocalFree(szStaticComment);
                }

				if (g_reasons.m_dwReasonSelect == -1)
					EnableWindow(g_wins.hwndComboOption, FALSE);

				if(ListBox_GetCount(g_wins.hwndListSelectComputers) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
		}
		EnableWindow(g_wins.hwndBtnAdd, TRUE);
		EnableWindow(g_wins.hwndBtnBrowse, TRUE);


		{
			int	cItems = 1024;
			int	lpItems[1024];
			int	cActualItems;

			//
			//	Get the number of selected items.
			//
			cActualItems = ListBox_GetSelItems(g_wins.hwndListSelectComputers, cItems, lpItems);
			if(cActualItems > 0)
				EnableWindow(g_wins.hwndBtnRemove, TRUE);
			else
				EnableWindow(g_wins.hwndBtnRemove, FALSE);
		}
		EnableWindow(g_wins.hwndListSelectComputers, TRUE);
	}
	else
	{
		EnableWindow(g_wins.hwndChkPlanned, FALSE);
		EnableWindow(g_wins.hwndButtonWarning, FALSE);
		EnableWindow(g_wins.hwndBtnAdd, FALSE);
		EnableWindow(g_wins.hwndBtnBrowse, FALSE);
		EnableWindow(g_wins.hwndBtnRemove, FALSE);
		EnableWindow(g_wins.hwndComboOption, FALSE);
		EnableWindow(g_wins.hwndEditComment, FALSE);
		EnableWindow(g_wins.hwndEditTimeout, FALSE);
		EnableWindow(g_wins.hwndListSelectComputers, FALSE);
		EnableWindow(g_wins.hwndButtonOK, TRUE);
	}
}

//
//	Init dialog handler for the shutdown dialog.
//
BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	int					i;

	//
	//	Init all of the dialog items so we dont have to find
	//	them everytime we need them.
	//
	g_wins.hwndShutdownDialog	= hwnd;
	g_wins.hwndButtonWarning	= GetDlgItem(hwnd, IDC_CHECKWARNING);
	g_wins.hwndComboAction		= GetDlgItem(hwnd, IDC_COMBOACTION);
	g_wins.hwndComboOption		= GetDlgItem(hwnd, IDC_COMBOOPTION);
	g_wins.hwndEditComment		= GetDlgItem(hwnd, IDC_EDITCOMMENT);
	g_wins.hwndStaticDesc		= GetDlgItem(hwnd, IDC_STATICDESCRIPTION);
	g_wins.hwndEditTimeout		= GetDlgItem(hwnd, IDC_EDITTIMEOUT);
	g_wins.hwndListSelectComputers = GetDlgItem(hwnd, IDC_LISTSELECTEDCOMPUTERS);
	g_wins.hwndBtnAdd			= GetDlgItem(hwnd, IDC_BUTTONADDNEW);
	g_wins.hwndBtnBrowse		= GetDlgItem(hwnd, IDC_BUTTONBROWSE);
	g_wins.hwndBtnRemove		= GetDlgItem(hwnd, IDC_BUTTONREMOVE);
	g_wins.hwndChkPlanned		= GetDlgItem(hwnd, IDC_CHECK_PLANNED);
	g_wins.hwndButtonOK			= GetDlgItem(hwnd, IDOK);
    g_wins.hwndStaticComment    = GetDlgItem(hwnd, IDC_STATIC_COMMENT);
	
	if(g_wins.hwndButtonWarning == NULL 
		|| g_wins.hwndComboAction == NULL 
		|| g_wins.hwndComboOption == NULL 
		|| g_wins.hwndEditComment == NULL
		|| g_wins.hwndStaticDesc == NULL
		|| g_wins.hwndEditTimeout == NULL
		|| g_wins.hwndListSelectComputers == NULL
		|| g_wins.hwndBtnAdd == NULL
		|| g_wins.hwndBtnBrowse == NULL
		|| g_wins.hwndBtnRemove == NULL
		|| g_wins.hwndChkPlanned == NULL)
	{
		report_error( GetLastError( ), NULL);
		EndDialog(hwnd, (int)-1);
		return FALSE;
	}
	
	LoadString(g_hDllInstance, IDS_DIALOGTITLEWARNING, g_lpszTitleWarning, TITLEWARNINGLEN);

	// Subclass the edit control. 
	wpOrigEditProc = (WNDPROC) SetWindowLongPtr(g_wins.hwndEditTimeout, 
		GWLP_WNDPROC, (LONG_PTR) EditSubclassProc); 

	// Limit timeout to 3 chars.
	SendMessage(g_wins.hwndEditTimeout, EM_LIMITTEXT, (WPARAM)3, 0);

	//
	//	Default timeout is set to 30 seconds.
	//
	Edit_SetText(g_wins.hwndEditTimeout, g_lpszDefaultTimeout);
	if(! CheckDlgButton(hwnd, IDC_CHECKWARNING, DEFAULTWARNINGSTATE))
	{
		report_error( GetLastError( ), NULL);
		EndDialog(hwnd, (int)-1);
		return FALSE;
	}

	//
	//	The for loop will load all of the actions into action combo.
	//	in the meantime we save them for later use.
	//
	for(i = 0; i < g_nActions; i++)
	{
		LoadString(g_hDllInstance, g_dwActions[i], g_lppszActions[i], MAX_PATH - 1);
		ComboBox_AddString(g_wins.hwndComboAction, g_lppszActions[i]);
		if(g_dwActions[i] == IDS_ACTION_RESTART)
		{
			ComboBox_SelectString(g_wins.hwndComboAction, -1, g_lppszActions[i]);
			g_dwActionSelect = ACTION_RESTART;
		}
	}

    if(g_reasons.m_cReasons)
        g_bAssumeShutdown = FALSE;
    else
        g_bAssumeShutdown = TRUE;

	//
	//	Set the default to be planned.
	//
	CheckDlgButton(hwnd, IDC_CHECK_PLANNED, BST_CHECKED);

    g_reasons.FillCombo(g_wins.hwndComboOption, g_bDirty, 
        IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED, g_wins.hwndStaticDesc);

	//
	// Setup the comment box.
	// We must fix the maximum characters.
	//
	SendMessage( g_wins.hwndEditComment, EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN-1, (LPARAM)0 );

	AdjustWindowState();

	return TRUE;
}

//
//	Init dialog handler for browse dialog
//
BOOL Browse_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	HWND	hwndDomain = NULL;
	int		cItems = 1024;
	int		lpItems[1024];
	int		cActualItems;
	WCHAR	lpDomain[MAX_PATH];

	hwndDomain = GetDlgItem(hwnd, IDC_EDITDOMAIN);

	if(!hwndDomain)
		return FALSE;

	Edit_SetText(hwndDomain, g_lpszDefaultDomain);;

	return TRUE;
}

//
//	winproc for shutdown dialog
//
INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);

		case WM_SYSCOMMAND: 
			return (Shutdown_OnCommand(hwnd, (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L);

		case WM_HELP:      // F1
            if(g_lpszHelpdirHlp)
			{
                LPHELPINFO phinfo = (LPHELPINFO) lParam;
                DWORD dwHelpID = 0;

				if (IsStaticControl((HWND)phinfo->hItemHandle))
					return (TRUE);

                for(int i = 0; i < sizeof(ShutdownDialogHelpIds)/sizeof(DWORD); i++)
                {
                    if(ShutdownDialogHelpIds[i] == phinfo->iCtrlId)
                    {
                        dwHelpID = ShutdownDialogHelpIds[++i];
                        break;
                    }
                    i++;
                }

                if ( i == sizeof(ShutdownDialogHelpIds)/sizeof(DWORD))
                    return TRUE;

                if (dwHelpID == 28443 || dwHelpID == 28444 || dwHelpID == 28445) // special case.
                    WinHelpW((HWND)phinfo->hItemHandle, g_lpszHelpdirWindows, HELP_CONTEXTPOPUP,dwHelpID);
                else
				    WinHelpW((HWND)phinfo->hItemHandle, g_lpszHelpdirHlp, HELP_CONTEXTPOPUP,dwHelpID);
			}
            return (TRUE);

        case WM_CONTEXTMENU:      // right mouse click
			if (IsStaticControl((HWND)wParam))
					return (TRUE);

			if(g_lpszHelpdirHlp)
				WinHelpW((HWND)wParam, g_lpszHelpdirHlp, HELP_CONTEXTMENU,(DWORD_PTR)(LPSTR)&ShutdownDialogHelpIds[6]);
            return (TRUE);
		case WM_DESTROY:
			// Remove the subclass from the edit control. 
            SetWindowLongPtr(g_wins.hwndEditTimeout, GWLP_WNDPROC, 
                (LONG_PTR)wpOrigEditProc); 
            // 
            // Continue the cleanup procedure. 
            // 
            break; 
    }

    return FALSE;
}

//
//	winproc for AddNew dialog
//
INT_PTR CALLBACK AddNew_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND, AddNew_OnCommand);

		case WM_HELP:      // F1
			if (GetDlgCtrlID((HWND)wParam) == IDC_STATIC)
				return (TRUE);
            if(g_lpszHelpdirHlp)
			{
                LPHELPINFO phinfo = (LPHELPINFO) lParam;
                DWORD dwHelpID = 0;

				if (IsStaticControl((HWND)phinfo->hItemHandle))
					return (TRUE);

                for(int i = 0; i < sizeof(AddNewDialogHelpIds)/sizeof(DWORD); i++)
                {
                    if(AddNewDialogHelpIds[i] == phinfo->iCtrlId)
                    {
                        dwHelpID = AddNewDialogHelpIds[++i];
                        break;
                    }
                    i++;
                }
                if ( i == sizeof(AddNewDialogHelpIds)/sizeof(DWORD))
                    return TRUE;

                if (dwHelpID == 28443 || dwHelpID == 28444 || dwHelpID == 28445) // special case.
                    WinHelpW((HWND)phinfo->hItemHandle, g_lpszHelpdirWindows, HELP_CONTEXTPOPUP,dwHelpID);
                else
				    WinHelpW((HWND)phinfo->hItemHandle, g_lpszHelpdirHlp, HELP_CONTEXTPOPUP,dwHelpID);
			}
            return (TRUE);

        case WM_CONTEXTMENU:      // right mouse click
			if (IsStaticControl((HWND)wParam))
				return (TRUE);
            if(g_lpszHelpdirHlp)
				WinHelpW((HWND)wParam, g_lpszHelpdirHlp, HELP_CONTEXTMENU,(DWORD_PTR)(LPSTR)&AddNewDialogHelpIds[4]);
            return (TRUE);
    }

    return FALSE;
}

//
//	Command handler for the shutdown dialog.
//
BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL		fHandled = FALSE;
    DWORD		dwDlgResult = 0;
	HINSTANCE	h;

    switch (id)
    {
    case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {  
			EndDialog(hwnd, (int) dwDlgResult);
        }
	fHandled = TRUE;
        break;
	case SC_CLOSE:
		EndDialog(hwnd, (int) dwDlgResult);
		fHandled = TRUE;
		break;
	case IDC_BUTTONREMOVE:
        if (codeNotify == BN_CLICKED)
        {  
			  int	cItems = 1024;
			  int	lpItems[1024];
			  int	cActualItems;
			  WCHAR	lpServerName[MAX_PATH];

			  //
			  //	Get the number of selected items. If there is any remove them one by one.
			  //
			  cActualItems = ListBox_GetSelItems(g_wins.hwndListSelectComputers, cItems, lpItems);
			  if(cActualItems > 0)
			  {
				  int i;
				  for(i = cActualItems-1; i >= 0; i--)
				  {
					  ListBox_DeleteString(g_wins.hwndListSelectComputers, lpItems[i]);
				  }

				  AdjustWindowState();
				  SetFocus(g_wins.hwndListSelectComputers);
			  }
			  fHandled = TRUE;
		}
        break;
	case IDC_CHECK_PLANNED:
		if (codeNotify == BN_CLICKED)
        { 
			int		iOption;
			int		iFirst = -1;
			DWORD	dwCheckState = 0x0;

			//
			//	Get check button state.
			//
			if (IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED)
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

            g_reasons.FillCombo(g_wins.hwndComboOption, g_bDirty, 
                    IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED, g_wins.hwndStaticDesc);
			
			AdjustWindowState();
			fHandled = TRUE;
		}
		break;
	case IDC_EDITCOMMENT:
        if( codeNotify == EN_CHANGE) 
        {
			if(g_bAssumeShutdown)
			{
				EnableWindow(g_wins.hwndButtonOK, TRUE);
			}
			else if(g_reasons.m_dwReasonSelect != -1 && 
                (g_reasons.m_lpReasons[g_reasons.m_dwReasonSelect].dwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED))
			{
				if(Edit_GetTextLength(g_wins.hwndEditComment) > MINCOMMENTLEN
					&& ListBox_GetCount(g_wins.hwndListSelectComputers) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
			else
			{
				if(ListBox_GetCount(g_wins.hwndListSelectComputers) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
            fHandled = TRUE;
        }
        break;
	case IDC_EDITTIMEOUT:
		if( codeNotify == EN_KILLFOCUS) 
        {
			WCHAR szTimeout[8];
			int len = GetWindowTextW(g_wins.hwndEditTimeout, szTimeout, 7);
			fHandled = TRUE;
			
			if (_wtoi(szTimeout) > MAX_TIMEOUT)
				SetWindowTextW(g_wins.hwndEditTimeout, g_lpszMaxTimeout);
        }
        break;

	case IDC_BUTTONADDNEW:
        if (codeNotify == BN_CLICKED)
        {  
			WCHAR	lpServerName[MAX_PATH];
			LPWSTR	lpBuffer;
			DWORD	dwIndex = 0;
			INT_PTR	hResult;

			//
			//	Will pop up the addnew dialog. User can type in computer names seperated
			//	by white space. After click on OK, we will parse the computer names and
			//	add them to the selected computer list. No duplicates will be added.
			//
			hResult = DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOG_ADDNEW), hwnd, AddNew_DialogProc, NULL);
			if(g_lpszNewComputers)
			{
				lpBuffer = g_lpszNewComputers;
				while(*lpBuffer)
				{
					lpServerName[dwIndex] = '\0';
					while(*lpBuffer && *lpBuffer != '\t' && *lpBuffer != '\n' && *lpBuffer != '\r' && *lpBuffer != ' ')
						lpServerName[dwIndex++] = *lpBuffer++;
					lpServerName[dwIndex] = '\0';
					if(dwIndex > 0 && LB_ERR == ListBox_FindStringExact(g_wins.hwndListSelectComputers, -1, lpServerName))
						ListBox_AddString(g_wins.hwndListSelectComputers, lpServerName);
					dwIndex = 0;
					while(*lpBuffer && (*lpBuffer == '\t' || *lpBuffer == '\n' || *lpBuffer == '\r' || *lpBuffer == ' '))
						lpBuffer++;
				}
				AdjustWindowState();
				LocalFree((HLOCAL)g_lpszNewComputers);
				g_lpszNewComputers = NULL;
			}
			fHandled = TRUE;
		}
        break;
	case IDOK:
		//
		//	Here we gather all of the information and do the action.
		//
        if (codeNotify == BN_CLICKED)
        {  
			int		cItems = 1024;
			int		lpItems[1024];
			int		cActualItems;
			BOOL	fLogoff = FALSE;
			BOOL	fAbort = FALSE;
			BOOL	fForce = FALSE;
			BOOL	fReboot = FALSE;
			BOOL	fDisconnect = FALSE;
			BOOL	fStandby = FALSE;
            BOOL    fAnnotate = FALSE;
			DWORD	dwTimeout = 0;
			DWORD	dwReasonCode = 0;
			WCHAR	lpServerName[MAX_PATH];
			WCHAR	lpMsg[MAX_REASON_COMMENT_LEN] = L"";
			DWORD	dwCnt = 0;
			DWORD	dwActionCode = g_dwActionSelect;
			WCHAR	lpNotSupported[MAX_PATH];
			WCHAR	lpRes[MAX_PATH * 2];
			WCHAR	lpFailed[MAX_PATH];
			WCHAR	lpSuccess[MAX_PATH];

			//
			//	The default reason code is 0 and default comment is L"".
			//
			if(IsDlgButtonChecked(hwnd, IDC_CHECKWARNING))
			{
				fForce = FALSE;
				lpServerName[0] = '\0';
				GetWindowText(g_wins.hwndEditTimeout, lpServerName, MAX_PATH);
				if(lstrlen(lpServerName) == 0)
				  dwTimeout = 0;
				else dwTimeout = _wtoi(lpServerName);
				if(dwTimeout > MAX_TIMEOUT)
					dwTimeout = MAX_TIMEOUT;
			}
			else 
			{
				fForce = TRUE;
			}

			LoadString(g_hDllInstance, IDS_ACTIONNOTSUPPORTED, lpNotSupported, MAX_PATH);
			GetWindowText(g_wins.hwndEditComment, lpMsg, MAX_REASON_COMMENT_LEN);
            lpMsg[MAX_REASON_COMMENT_LEN-1] = 0;


			if(dwActionCode == ACTION_LOGOFF)
			{
				fLogoff = TRUE;
			}
			else if (dwActionCode == ACTION_RESTART)
			{
				fReboot = TRUE;
			}
            else if (dwActionCode == ACTION_ANNOTATE)
                fAnnotate = TRUE;

			//
			//	Logoff is only for the local computer.
			//	Everything else will ingored.
			//
			if(fLogoff)
			{
				if (!ExitWindowsEx(fForce ? EWX_LOGOFF : (EWX_LOGOFF | EWX_FORCE),
										   0))
				{
					report_error(GetLastError(), g_lpszLocalComputerName);
				}
				EndDialog(hwnd, (int) dwDlgResult);
				break;
			}

			if(! g_bAssumeShutdown)
			{
				dwReasonCode = g_reasons.m_lpReasons[g_reasons.m_dwReasonSelect].dwCode;
			}
            else if (fAnnotate)
                break;

			dwCnt = ListBox_GetCount(g_wins.hwndListSelectComputers);
			if(dwCnt > 0)
			{
				DWORD i;
				for(i = 0; i < dwCnt; i++)
				{
					ListBox_GetText(g_wins.hwndListSelectComputers, i, lpServerName);


					//
					// Get all privileges so that we can shutdown the machine.
					//
					enable_privileges(lpServerName, fLogoff);

					//
					// Do the work.
					//
					if( fAbort )
					{
						if( !AbortSystemShutdown( lpServerName ))
						{
							report_error( GetLastError( ), lpServerName);
						}
					}
                    else if (fAnnotate)
                    {
                        DWORD err;
                        Annotate(lpServerName, &dwReasonCode, lpMsg, &err);
                    }
					else
					{
						//
						// Do the normal form.
						//
						if( !InitiateSystemShutdownEx( lpServerName,
														lpMsg,
														dwTimeout,
														fForce,
														fReboot,
														dwReasonCode ))
						{
							report_error( GetLastError( ), lpServerName);
						}
					}

					
				}
			}
			else
			{
				//
				//	We will keep the dialog up in case user forget to add computers.
				//
				break;
			}
			EndDialog(hwnd, (int) dwDlgResult);
		}
        break;
	case IDC_CHECKWARNING:
		//
		//	The checkbutton state decides the state of the timeout edit box.
		//
        if (codeNotify == BN_CLICKED)
        {  
			if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECKWARNING))
			{
				EnableWindow(g_wins.hwndEditTimeout, TRUE);
			}
			else 
			{
				EnableWindow(g_wins.hwndEditTimeout, FALSE);
			}
			fHandled = TRUE;
		}
        break;
	case IDC_BUTTONBROWSE:
		//
		//	Simply pop up the browse dialog. That dialog will be responsible
		//	for adding the user selection to the selected computer list.
		//
        if (codeNotify == BN_CLICKED)
        {  
			HRESULT hr;
			ICommonQuery* pcq;
			OPENQUERYWINDOW oqw = { 0 };
			DSQUERYINITPARAMS dqip = { 0 };
			IDataObject *pdo;

			FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES), 
							  NULL,
							  DVASPECT_CONTENT, 
							  -1, 
							  TYMED_HGLOBAL};
			FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSQUERYPARAMS), 
							  NULL,
							  DVASPECT_CONTENT, 
							  -1, 
							  TYMED_HGLOBAL};
			STGMEDIUM medium = { TYMED_NULL, NULL, NULL };

			DSOBJECTNAMES *pdon;
			DSQUERYPARAMS *pdqp;

			CoInitialize(NULL);

			//
			// Windows 2000: Always use IID_ICommonQueryW explicitly. IID_ICommonQueryA is not supported.
			//
			hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (void**)&pcq);
			if (FAILED(hr)) {
				//
				// if failed return.
				//
				CoUninitialize();
				DbgPrint("Cannot create ICommonQuery, return.\n");
				break;
			}

			//
			// Initialize the OPENQUERYWINDOW structure to indicate 
			// we want to do a Directory Service
			// Query, the default form is printers and the search 
			// should start once the window is initialized.
			//
			oqw.cbStruct = sizeof(oqw);
			oqw.dwFlags = OQWF_OKCANCEL|OQWF_DEFAULTFORM|OQWF_HIDEMENUS|OQWF_REMOVEFORMS;
			oqw.clsidHandler = CLSID_DsQuery;
			oqw.pHandlerParameters = &dqip;
			oqw.clsidDefaultForm = CLSID_DsFindComputer;
 
			//
			// Now initialize the handler specific parameters, 
			// in this case, the File/Save menu item is removed
			//
			dqip.cbStruct = sizeof(dqip);
			dqip.dwFlags = DSQPF_NOSAVE;
			

			//
			// Call OpenQueryWindow, it will block until 
			// the Query Window is dismissed,
			//
			hr = pcq->OpenQueryWindow(hwnd, &oqw, &pdo);
			if (FAILED(hr)) {
				//
				// if failed we return.
				//
				pcq->Release();
				CoUninitialize();
				break;
			}

			if (!pdo) {
				//
				// if cancelled,nothing needs to be done.
				//
				pcq->Release();
				CoUninitialize();
				break;
			}

			//
			// Get the CFSTR_DSOBJECTNAMES data. For each selected, the data
			// includes the object class and an ADsPath to the selected object.
			//
			hr = pdo->GetData(&fmte, &medium);

			if(! FAILED(hr))
			{
				pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
		
				if ( pdon )
				{
					WCHAR			szName[MAX_PATH];
					LPWSTR			lpsz = NULL;
					UINT			i;

					for (i = 0; i < pdon->cItems; i++) 
					{
						if(!GetComputerNameFromPath((LPWSTR) ((PBYTE) pdon + pdon->aObjects[i].offsetName), szName))
							continue;

						//
						//	We don't add dups.
						//
						if(LB_ERR == ListBox_FindStringExact(g_wins.hwndListSelectComputers, -1, szName))
						{
							ListBox_AddString(g_wins.hwndListSelectComputers, szName);
						}
					}
 
					GlobalUnlock(medium.hGlobal);
				}
				else
				{
					DbgPrint("GlobalLock on medium failed.\n");
				}
				ReleaseStgMedium(&medium);
			}
			else
			{
				DbgPrint("pdo->GetData failed: 0x%x\n", hr);
			}
 
			//
			//	Release resources.
			//
			pdo->Release();
			pcq->Release();

			CoUninitialize();
			AdjustWindowState();
			fHandled = TRUE;
		}
        break;
	case IDC_COMBOOPTION:
		//
		//	Here is where you select shutdown reasons.
		//
        if (codeNotify == CBN_SELCHANGE)
        {  
            g_reasons.SetDesc(g_wins.hwndComboOption, g_wins.hwndStaticDesc);
			AdjustWindowState();	
			fHandled = TRUE;
		}
        break;
	case IDC_COMBOACTION:
		//
		//	Select user action here.
		//	according to the action. some item will be disabled or enabled.
		//
        if (codeNotify == CBN_SELCHANGE)
        {  
			WCHAR name[MAX_PATH];
			DWORD dwIndex;
            DWORD dwOldActionSelect = g_dwActionSelect;
            DWORD dwCheckState = 0x0;
            int   iFirst = -1;

            if (IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED)
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

			GetWindowText(g_wins.hwndComboAction, (LPWSTR)name, MAX_PATH);
			for(dwIndex = 0; dwIndex < g_nActions; dwIndex++)
			{
				if(lstrcmp(name, g_lppszActions[dwIndex]) == 0)
				{
					g_dwActionSelect = dwIndex;

                    if(g_dwActionSelect == ACTION_ANNOTATE)
                        g_bDirty = TRUE;
                    else
                        g_bDirty = FALSE;

                    //
			        //	If change from clean to dirty or vsv, repopulate the combo.
			        //
                    if (dwOldActionSelect != g_dwActionSelect
                        && (dwOldActionSelect == ACTION_ANNOTATE || g_dwActionSelect == ACTION_ANNOTATE))
                    {
                        g_reasons.FillCombo(g_wins.hwndComboOption, g_bDirty,
                            dwCheckState == SHTDN_REASON_FLAG_PLANNED, g_wins.hwndStaticDesc);
                    }
					AdjustWindowState();
					break;
				}
			}
			fHandled = TRUE;
		}
        break;
	case IDC_LISTSELECTEDCOMPUTERS:
		//
		//	When selection change, update the remove button state.
		//
        if (codeNotify == LBN_SELCHANGE)
        {  
			AdjustWindowState();
			fHandled = TRUE;
		}
		else if (codeNotify == WM_MOUSEMOVE)
		{
			MessageBox(hwnd, L"Mouse move", NULL, 0);
			fHandled = TRUE;
		}
        break;
	case IDHELP:
		//
		//	Open the .chm file.
		//
        if (codeNotify == BN_CLICKED)
		{
			if(g_lpszHelpdirChm)
				HtmlHelpW(/*hwnd*/0, g_lpszHelpdirChm, HH_DISPLAY_TOPIC,(DWORD)0);
		}
    }
    return fHandled;
}

//
//	Command handler for the addnew dialog.
//	It simply copy the text into a allocated buffer when OK is clicked.
//
BOOL AddNew_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL		fHandled = FALSE;
    DWORD		dwDlgResult = 0;
	HINSTANCE	h;

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {  
			HWND hwndEdit;
			DWORD dwTextlen = 0;

			hwndEdit = GetDlgItem(hwnd, IDC_EDIT_ADDCOMPUTERS_COMPUTERS);
			if(hwndEdit != NULL)
			{
				dwTextlen = Edit_GetTextLength(hwndEdit);
				if(dwTextlen)
				{
					g_lpszNewComputers = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (dwTextlen + 1));
					if(g_lpszNewComputers){
						Edit_GetText(hwndEdit, g_lpszNewComputers, dwTextlen + 1);
					}
				}
			}
			EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
	case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {  
			EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
	}
    return fHandled;
}
 
//
// Annotate dirty shutdown on remote machine.
BOOL
Annotate(
    LPCWSTR lpMachine, 
    LPDWORD lpdwReason, 
    LPCWSTR lpComment,
    LPDWORD lpdwErr)
{
    HKEY    hRemote = NULL;
    HKEY    hKey = NULL;
    HANDLE  hEventLog = NULL;
    PTOKEN_USER pTokenUser = NULL;
    BOOL    res = TRUE;

    if(lpMachine && wcslen(lpMachine) > 1)
    {
        WCHAR szMachine[MAX_PATH];
        szMachine[0] = '\0';
        if(lpMachine[0] != '\\')
        {
            wcscpy(szMachine, L"\\\\");
        }
        wcsncat(szMachine, lpMachine, MAX_PATH - 3);
        szMachine[MAX_PATH - 1] = '\0';

        RegConnectRegistryW(szMachine, HKEY_LOCAL_MACHINE, &hRemote);
        if(!hRemote)
        {
            *lpdwErr = GetLastError();
            ERROR_WITH_SZ(IDS_FAILED_REG_CONN, lpMachine, *lpdwErr);
            goto fail;
        }

        RegOpenKeyExW(hRemote, 
                    REGSTR_PATH_RELIABILITY, 
                    NULL,
                    KEY_ALL_ACCESS | KEY_WOW64_64KEY, 
                    &hKey);
        if(!hKey)
        {
            *lpdwErr = GetLastError();
            ERROR_WITH_SZ(IDS_FAILED_REG_OPEN, lpMachine, *lpdwErr);
            goto fail;
        }
    }
    else // local machine
    {
        lpMachine = g_lpszLocalComputerName;
        RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
            REGSTR_PATH_RELIABILITY, 
            NULL, 
            KEY_ALL_ACCESS | KEY_WOW64_64KEY,
            &hKey);
        if(!hKey)
        {
            *lpdwErr = GetLastError();
            ERROR_WITH_SZ(IDS_FAILED_REG_OPEN, lpMachine, *lpdwErr);
            goto fail;
        }
    }

    DWORD dwDirtyVal;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    static LPCWSTR lpszDirtyValName = L"DirtyShutdown";

    if( ERROR_SUCCESS != RegQueryValueExW(hKey, lpszDirtyValName, NULL, &dwType, (LPBYTE)&dwDirtyVal,&dwSize))
    {
        *lpdwErr = GetLastError();
        ERROR_WITH_SZ(IDS_NO_DIRTY_SHUTDOWN, lpMachine, *lpdwErr);
        goto fail;
    }

    if (dwDirtyVal)
    {
        PSID pUserSid = NULL;
        DWORD dwSidSize = sizeof(SID), dwEventID;
        WCHAR szReason[MAX_REASON_NAME_LEN + 10];
        LPCWSTR lpStrings[8];
        WORD wEventType, wStringCnt;
        WCHAR szMinorReason[32];
		WCHAR szName[MAX_PATH + 1];
        WCHAR szDomain[MAX_PATH + 1];
		DWORD dwNameLen = MAX_PATH + 1;
        DWORD dwDomainLen = MAX_PATH + 1;
        SID_NAME_USE eUse;

        // Get the user's SID so we can output their account name to the event log.
        if (GetUserSid(&pTokenUser)) {
            pUserSid = pTokenUser->User.Sid;
        }

        if ((hEventLog = RegisterEventSourceW(lpMachine, L"USER32")) == NULL) {
            *lpdwErr = GetLastError();
            ERROR_WITH_SZ(IDS_FAILED_EVENT_REG, lpMachine, *lpdwErr);
            goto fail;
        }

        g_reasons.GetReasonTitle(*lpdwReason, szReason, ARRAY_SIZE(szReason));

        // Get User name.
        if (!LookupAccountSidW(NULL, pUserSid, szName, &dwNameLen, szDomain,
            &dwDomainLen, &eUse)) {
            goto fail;
        }
        szName[MAX_PATH] = 0;
        szDomain[MAX_PATH] = 0;

         // We need to pack into a buffer of MAX_PATH + 1 in the form L"domain\\username"
        if (wcslen(szDomain) + wcslen(szName) > MAX_PATH - 1) {
            goto fail;
        }
        if (wcslen(szDomain) > 0) {
            wcscat(szDomain, L"\\");
        }
        wcscat(szDomain, szName);

        // The minor reason is the low-order word of the reason code.
        wsprintf(szMinorReason, L"0x%x", *lpdwReason);
        wEventType = EVENTLOG_WARNING_TYPE;
        dwEventID = WARNING_DIRTY_REBOOT;
        wStringCnt = 6;
        lpStrings[0] = szReason;
        lpStrings[1] = szMinorReason;
        lpStrings[2] = NULL;
        lpStrings[3] = NULL;
        lpStrings[4] = lpComment;
		lpStrings[5] = szDomain;


        if ( (*lpdwErr = RegDeleteValueW(hKey, lpszDirtyValName)) != ERROR_SUCCESS )
        {
            ERROR_WITH_SZ(IDS_NO_DIRTY_SHUTDOWN, lpMachine, *lpdwErr);
            goto fail;
        }

        if(! ReportEventW(hEventLog, wEventType, 1, dwEventID, pUserSid,
							wStringCnt, sizeof(DWORD),
							lpStrings, lpdwReason))
        {
            DWORD dwDirtyShutdownFlag = 1;
            *lpdwErr = GetLastError();
            ERROR_WITH_SZ(IDS_FAILED_EVENT_REPORT, lpMachine, *lpdwErr);   

            RegSetValueEx(  hKey,
                            lpszDirtyValName,
                            0,
                            REG_DWORD,
                            (PUCHAR) &dwDirtyShutdownFlag,
                            sizeof(DWORD));

            goto fail;
        }
    }
    else
    {
        RegDeleteValueW(hKey, lpszDirtyValName);
        ERROR_WITH_SZ(IDS_NO_DIRTY_SHUTDOWN, lpMachine, 0);
    }

    goto exit;
fail:
    res = FALSE;
exit:
    if (pTokenUser != NULL) {
        LocalFree(pTokenUser);
    }
    if(hEventLog)
        DeregisterEventSource(hEventLog);
    if(hKey)
        RegCloseKey(hKey);
    if(hRemote)
        RegCloseKey(hRemote);
    
    return res;
}

//
// Subclass procedure for edit box.
//
LRESULT APIENTRY EditSubclassProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam) 
{ 
    if (uMsg == WM_PASTE) 
        return TRUE; 
 
	if (uMsg == WM_CONTEXTMENU)
	{
		if(g_lpszHelpdir)
		{
			LPWSTR szHelp = new WCHAR[wcslen(g_lpszHelpdir) + 128];
			if(szHelp)
			{
				wcscpy(szHelp, g_lpszHelpdir);
				wcscat(szHelp, HELP_FILE);
				WinHelpW(hwnd, szHelp, HELP_CONTEXTMENU,(DWORD_PTR)(LPSTR)ShutdownDialogHelpIds);
				delete [] szHelp;
			}
		}
		return TRUE;
	}

    return CallWindowProc(wpOrigEditProc, hwnd, uMsg, 
        wParam, lParam); 
} 

BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser)
{
    HANDLE      TokenHandle;
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser = 0;
    DWORD       cbNeeded;
    BOOL        bRet = FALSE;

    if (!GetTokenHandle(&TokenHandle)) {
        return FALSE;
    }

    bRet = GetTokenInformation(TokenHandle,
                               TokenUser,
                               pTokenUser,
                               cbTokenUser,
                               &cbNeeded);

    /*
     * We've passed a NULL pointer and 0 for the amount of memory
     * allocated.  We expect to fail with bRet = FALSE and
     * GetLastError = ERROR_INSUFFICIENT_BUFFER. If we do not
     * have these conditions we will return FALSE.
     */

    if (!bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

        pTokenUser = (PTOKEN_USER)LocalAlloc(LPTR, cbNeeded);

        if (pTokenUser == NULL) {
            goto GetUserSidDone;
        }

        cbTokenUser = cbNeeded;

        bRet = GetTokenInformation(TokenHandle,
                                   TokenUser,
                                   pTokenUser,
                                   cbTokenUser,
                                   &cbNeeded);
    } else {
        /*
         * Any other case -- return FALSE
         */
        bRet = FALSE;
    }

GetUserSidDone:
    if (bRet == TRUE) {
        *ppTokenUser = pTokenUser;
    } else if (pTokenUser != NULL) {
        LocalFree(pTokenUser);
    }

    CloseHandle(TokenHandle);

    return bRet;
}


BOOL
GetTokenHandle(
    PHANDLE pTokenHandle)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle)) {
        if (GetLastError() == ERROR_NO_TOKEN) {
            /* This means we are not impersonating anybody.
             * Instead, lets get the token out of the process.
             */

            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                  pTokenHandle)) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

WCHAR*      
LoadWString(int resid)
{
    DWORD       len, curlen = MAX_PATH;
    LPWSTR      szBuf = NULL;

    szBuf = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * MAX_PATH);
    if(!szBuf)
        return NULL;

    len = LoadStringW( g_hDllInstance, resid, szBuf, curlen);
	while (len + 1 == curlen)
    {
        LocalFree(szBuf);
        szBuf = (LPWSTR)LocalAlloc(LMEM_FIXED,  curlen * 2 * sizeof(WCHAR));
        if(!szBuf)
            return NULL;
        curlen *= 2;
        len = LoadStringW( g_hDllInstance, resid, szBuf, curlen);
    }
		
    szBuf[len] = '\0';

    return szBuf;
}

BOOL        
IsStaticControl (HWND hwnd)
{
	WCHAR name[128];

	if (GetClassName(hwnd, name, 128) 
		&& (_wcsicmp(name, L"Static") == 0 || _wcsicmp(name, L"#32770") == 0))
	{
	//	MessageBox(NULL, name, NULL, 0);
		return TRUE;
	}
    //	MessageBox(NULL, name, NULL, 0);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\advdep.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvDep.h
//
//  Contents:   advanced deployment settings dialog
//
//  Classes:
//
//  Functions:
//
//  History:    01-28-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_)
#define AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdvDep.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAdvDep dialog

class CDeploy;

class CAdvDep : public CDialog
{
// Construction
public:
    CAdvDep(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CAdvDep)
    enum { IDD = IDD_ADVDEP };
    BOOL    m_fIgnoreLCID;
    BOOL    m_fInstallOnAlpha;
    BOOL    m_fUninstallUnmanaged;
    BOOL    m_f32On64;
    BOOL    m_fIncludeOLEInfo;
    CString m_szProductCode;
    CString m_szDeploymentCount;
    CString m_szScriptName;
    //}}AFX_DATA

    CDeploy *   m_pDeploy;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAdvDep)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAdvDep)
    virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\category.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Category.cpp
//
//  Contents:   Categories property page (for an application)
//
//  Classes:    CCategory
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCategory property page

IMPLEMENT_DYNCREATE(CCategory, CPropertyPage)

CCategory::CCategory() : CPropertyPage(CCategory::IDD)
{
        //{{AFX_DATA_INIT(CCategory)
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
    m_ppThis = NULL;
    m_fPreDeploy = FALSE;
}

CCategory::~CCategory()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CCategory::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCategory)
        DDX_Control(pDX, IDC_LIST1, m_Available);
        DDX_Control(pDX, IDC_LIST2, m_Assigned);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCategory, CPropertyPage)
        //{{AFX_MSG_MAP(CCategory)
        ON_BN_CLICKED(IDC_BUTTON1, OnAssign)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        ON_LBN_DBLCLK(IDC_LIST1, OnAssign)
        ON_LBN_DBLCLK(IDC_LIST2, OnRemove)
        ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
        ON_LBN_SELCHANGE(IDC_LIST2, OnSelchangeList2)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCategory message handlers

void CCategory::OnSelchangeList1()
{
    BOOL fOK = FALSE;
    int iSel = m_Available.GetCurSel();
    if (iSel != LB_ERR)
    {
        fOK = TRUE;
    }
    GetDlgItem(IDC_BUTTON1)->EnableWindow(fOK && (!m_fRSOP));
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CCategory::OnSelchangeList2()
{
    BOOL fOK = FALSE;
    int iSel = m_Assigned.GetCurSel();
    if (iSel != LB_ERR)
    {
        fOK = TRUE;
    }
    GetDlgItem(IDC_BUTTON2)->EnableWindow(fOK && (!m_fRSOP));
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}


void CCategory::OnAssign()
{
    if ( m_fRSOP )
    {
        return;
    }

    int i = m_Available.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Available.GetText(i, sz);
        m_Available.DeleteString(i);
        if (i > 0 && i >= m_Available.GetCount())
        {
            i = m_Available.GetCount() - 1;
        }
        GetDlgItem(IDC_BUTTON1)->EnableWindow(
            LB_ERR != m_Available.SetCurSel(i));
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        m_Assigned.AddString(sz);
        CDC * pDC = m_Assigned.GetDC();
        CSize size = pDC->GetTextExtent(sz);
        pDC->LPtoDP(&size);
        m_Assigned.ReleaseDC(pDC);
        if (m_Assigned.GetHorizontalExtent() < size.cx)
        {
            m_Assigned.SetHorizontalExtent(size.cx);
        }
        m_Assigned.SelectString(-1, sz);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
        m_fModified = TRUE;
        if (!m_fPreDeploy)
            SetModified();
    }
}

void CCategory::OnRemove()
{
    if ( m_fRSOP )
    {
        return;
    }

    int i = m_Assigned.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Assigned.GetText(i, sz);
        m_Assigned.DeleteString(i);
        if (i > 0 && i >= m_Assigned.GetCount())
        {
            i = m_Assigned.GetCount() - 1;
        }
        GetDlgItem(IDC_BUTTON2)->EnableWindow(
            LB_ERR != m_Assigned.SetCurSel(i));
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        m_Available.AddString(sz);
        m_Available.SelectString(-1, sz);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE);
        m_fModified = TRUE;
        if (!m_fPreDeploy)
            SetModified();
    }
}

BOOL CCategory::OnApply()
{
    if (m_fModified)
    {
        if (this->m_fRSOP)
        {
            return CPropertyPage::OnApply();
        }
        multimap<CString, GUID> Categories;

        // build a mapping from category names to guids
        DWORD n = m_pCatList->cCategory;
        while (n--)
        {
            Categories.insert(pair<const CString, GUID>(m_pCatList->pCategoryInfo[n].pszDescription, m_pCatList->pCategoryInfo[n].AppCategoryId));
        }

        // build the list of categories assigned to this app
        UINT cCategories = m_Assigned.GetCount();
        HRESULT hr = E_FAIL;
        GUID * rpCategory = (GUID *)OLEALLOC(sizeof(GUID) * cCategories);
        CString sz;
        if (rpCategory)
        {
            UINT index = cCategories;
            while (index--)
            {
                m_Assigned.GetText(index, sz);
                rpCategory[index] = Categories.find(sz)->second;
            }

            if (m_pIClassAdmin)
            {
                hr = m_pIClassAdmin->ChangePackageCategories(m_pData->m_pDetails->pszPackageName,
                                                             cCategories,
                                                             rpCategory);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            OLESAFE_DELETE(m_pData->m_pDetails->rpCategory);
            m_pData->m_pDetails->cCategories = cCategories;
            m_pData->m_pDetails->rpCategory = rpCategory;
            m_fModified = FALSE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageCategories failed with 0x%x"), hr));
            // apply failed
            OLESAFE_DELETE(rpCategory);
            CString sz;
            sz.LoadString(IDS_CATEGORYFAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}

BOOL CCategory::OnInitDialog()
{
        CPropertyPage::OnInitDialog();
        RefreshData();
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CCategory::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

BOOL CCategory::IsAssigned(GUID & guid)
{
    UINT n = m_pData->m_pDetails->cCategories;
    while (n--)
    {
        if (IsEqualGUID(guid, m_pData->m_pDetails->rpCategory[n]))
        {
            return TRUE;
        }
    }

    return FALSE;
}

void CCategory::RefreshData()
{
    GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
    m_Assigned.ResetContent();
    m_Available.ResetContent();
    m_Assigned.SetHorizontalExtent(0);
    m_Available.SetHorizontalExtent(0);

    // for each category available, determine if it has been assigned or not
    DWORD n = m_pCatList->cCategory;
    while (n--)
    {
        if (IsAssigned(m_pCatList->pCategoryInfo[n].AppCategoryId))
        {
            // it's assigned
            m_Assigned.AddString(m_pCatList->pCategoryInfo[n].pszDescription);
            CDC * pDC = m_Assigned.GetDC();
            CSize size = pDC->GetTextExtent(m_pCatList->pCategoryInfo[n].pszDescription);
            pDC->LPtoDP(&size);
            m_Assigned.ReleaseDC(pDC);
            if (m_Assigned.GetHorizontalExtent() < size.cx)
            {
                m_Assigned.SetHorizontalExtent(size.cx);
            }
            GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE && (!m_fRSOP));
        }
        else
        {
            // it's not assigned
            m_Available.AddString(m_pCatList->pCategoryInfo[n].pszDescription);
            CDC * pDC = m_Available.GetDC();
            CSize size = pDC->GetTextExtent(m_pCatList->pCategoryInfo[n].pszDescription);
            pDC->LPtoDP(&size);
            m_Available.ReleaseDC(pDC);
            if (m_Available.GetHorizontalExtent() < size.cx)
            {
                m_Available.SetHorizontalExtent(size.cx);
            }
            GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE && (!m_fRSOP));
        }
    }

    m_Assigned.SetCurSel(0);
    m_Available.SetCurSel(0);
    m_fModified = FALSE;
    SetModified(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}


void CCategory::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_CATEGORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\catlist.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CatList.h
//
//  Contents:   master category list property page
//
//  Classes:    CCatList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CatList.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCatList dialog

class CCatList : public CPropertyPage
{
        DECLARE_DYNCREATE(CCatList)

// Construction
public:
        CCatList();
        ~CCatList();

        CCatList ** m_ppThis;
        CScopePane * m_pScopePane;
        multimap<CString, DWORD>    m_Categories;
        CString         m_szDomainName;
        BOOL            m_fRSOP;

// Dialog Data
        //{{AFX_DATA(CCatList)
        enum { IDD = IDD_CATEGORIES };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCatList)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCatList)
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        afx_msg void OnModify();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        void RefreshData(void);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\category.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Category.h
//
//  Contents:   categories property page (for an application)
//
//  Classes:    CCategory
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Category.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCategory dialog

class CCategory : public CPropertyPage
{
        DECLARE_DYNCREATE(CCategory)

// Construction
public:
        CCategory();
        ~CCategory();

        CCategory ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CCategory)
        enum { IDD = IDD_CATEGORY };
        CListBox        m_Available;
        CListBox        m_Assigned;
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fModified;
        BOOL            m_fRSOP;
        BOOL            m_fPreDeploy;
        APPCATEGORYINFOLIST * m_pCatList;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCategory)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCategory)
        afx_msg void OnAssign();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        afx_msg void OnSelchangeList1();
        afx_msg void OnSelchangeList2();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
        BOOL IsAssigned(GUID &);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\catlist.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CatList.cpp
//
//  Contents:   main tool-wide categories list property page
//
//  Classes:    CCatList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAXCATEGORYNAME 40

/////////////////////////////////////////////////////////////////////////////
// CCatList property page

IMPLEMENT_DYNCREATE(CCatList, CPropertyPage)

CCatList::CCatList() : CPropertyPage(CCatList::IDD)
{
        //{{AFX_DATA_INIT(CCatList)
        //}}AFX_DATA_INIT
}

CCatList::~CCatList()
{
    *m_ppThis = NULL;
}
void CCatList::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCatList)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCatList, CPropertyPage)
        //{{AFX_MSG_MAP(CCatList)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        ON_LBN_DBLCLK(IDC_LIST1, OnModify)
        ON_BN_CLICKED(IDC_BUTTON3, OnModify)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCatList message handlers

void CCatList::OnAdd()
{
    CEditString dlgEditString;
    dlgEditString.m_szTitle.LoadString(IDS_NEWCATEGORY);
    if (IDOK == dlgEditString.DoModal())
    {
        if (dlgEditString.m_sz.GetLength() == 0)
        {
            // empty name
            CString szMessage;
            szMessage.LoadString(IDS_SHORTCATNAME);
            MessageBox(szMessage,
                         NULL,
                         MB_OK | MB_ICONEXCLAMATION);
            return;
        }
        if (dlgEditString.m_sz.GetLength() > MAXCATEGORYNAME)
        {
            // long name
            CString szMessage;
            szMessage.LoadString(IDS_LONGCATNAME);
            MessageBox(szMessage,
                         NULL,
                         MB_OK | MB_ICONEXCLAMATION);
            return;
        }
        // only add categories that are unique
        if (m_Categories.find(dlgEditString.m_sz) == m_Categories.end())
        {
            m_Categories.insert(pair<const CString,ULONG>(dlgEditString.m_sz, (ULONG)-1));
            m_cList.AddString(dlgEditString.m_sz);
            m_cList.SelectString(0, dlgEditString.m_sz);
            GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
            GetDlgItem(IDC_BUTTON3)->EnableWindow(TRUE);
            CDC * pDC = m_cList.GetDC();
            CSize size = pDC->GetTextExtent(dlgEditString.m_sz);
            pDC->LPtoDP(&size);
            m_cList.ReleaseDC(pDC);
            if (m_cList.GetHorizontalExtent() < size.cx)
            {
                m_cList.SetHorizontalExtent(size.cx);
            }
            SetModified();
        }
    }
}

void CCatList::OnRemove()
{
    int i = m_cList.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_cList.GetText(i, sz);
        m_Categories.erase(m_Categories.find(sz));
        m_cList.DeleteString(i);
        if (i > 0 && i >= m_cList.GetCount())
        {
            i = m_cList.GetCount() - 1;
        }
        m_cList.SetCurSel(i);
        int n = m_cList.GetCount();
        BOOL fEnable = n > 0;
        GetDlgItem(IDC_BUTTON2)->EnableWindow(fEnable);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(fEnable);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        SetModified();
    }
}

LRESULT CCatList::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CCatList::RefreshData(void)
{
    // build up m_Categories and populate the list box
    m_cList.ResetContent();
    m_cList.SetHorizontalExtent(0);
    m_Categories.erase(m_Categories.begin(), m_Categories.end());
    UINT i = m_pScopePane->m_CatList.cCategory;
    while (i--)
    {
        m_Categories.insert(pair<const CString, ULONG>(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription, i));
        m_cList.AddString(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription);
        CDC * pDC = m_cList.GetDC();
        CSize size = pDC->GetTextExtent(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription);
        pDC->LPtoDP(&size);
        m_cList.ReleaseDC(pDC);
        if (m_cList.GetHorizontalExtent() < size.cx)
        {
            m_cList.SetHorizontalExtent(size.cx);
        }
    }
    m_cList.SetCurSel(0);
    int n = m_cList.GetCount();
    BOOL fEnable = (n > 0) && (!m_fRSOP);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(fEnable);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(fEnable);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
    SetModified(FALSE);
}


BOOL CCatList::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        CWnd * pCtrl = GetDlgItem(IDC_STATIC1);
        CString sz;
        CString szNew;
        pCtrl->GetWindowText(sz);
        szNew.Format(sz, m_szDomainName);
        pCtrl->SetWindowText(szNew);

        // unmarshal the IClassAdmin interface
        RefreshData();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CCatList::OnModify()
{
    int i = m_cList.GetCurSel();
    if (i != LB_ERR)
    {
        CEditString dlgEditString;
        dlgEditString.m_szTitle.LoadString(IDS_CHANGECATEGORY);
        CString sz;
        m_cList.GetText(i, sz);
        dlgEditString.m_sz = sz;
        if (IDOK == dlgEditString.DoModal())
        {
            if (dlgEditString.m_sz.GetLength() == 0)
            {
                // empty name
                CString szMessage;
                szMessage.LoadString(IDS_SHORTCATNAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                return;
            }
            if (dlgEditString.m_sz.GetLength() > MAXCATEGORYNAME)
            {
                // long name
                CString szMessage;
                szMessage.LoadString(IDS_LONGCATNAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                return;
            }
            multimap<CString, ULONG>::iterator element = m_Categories.find(sz);
            ULONG index = element->second;
            m_Categories.erase(element);
            m_Categories.insert(pair<const CString, ULONG>(dlgEditString.m_sz, index));
            m_cList.DeleteString(i);
            m_cList.AddString(dlgEditString.m_sz);
            m_cList.SelectString(0, dlgEditString.m_sz);
            CDC * pDC = m_cList.GetDC();
            CSize size = pDC->GetTextExtent(dlgEditString.m_sz);
            pDC->LPtoDP(&size);
            m_cList.ReleaseDC(pDC);
            if (m_cList.GetHorizontalExtent() < size.cx)
            {
                m_cList.SetHorizontalExtent(size.cx);
            }
            SetModified();
        }
    }
}


BOOL CCatList::OnApply()
{
    if (this->m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    // Build up a set of indexes.  As an element is found in our private
    // list, it will be removed from this set.  Whatever is left in the set
    // are elements that are to be removed from the class store.
    set<ULONG> sIndexes;
    ULONG n = m_pScopePane->m_CatList.cCategory;
    while (n--)
    {
        sIndexes.insert(n);
    }

    // walk our list of categories modifying or adding categories on the
    // class store as necessary
    HRESULT hr = S_OK;
    multimap<CString, ULONG>::iterator element;
    for (element = m_Categories.begin(); element != m_Categories.end(); element++)
    {
        if (element->second == (ULONG)-1)
        {
            // this is a new category
            APPCATEGORYINFO AppCategory;
            AppCategory.Locale = GetUserDefaultLCID();
            AppCategory.pszDescription = (LPOLESTR)((LPCOLESTR)element->first);
            hr = CoCreateGuid(&AppCategory.AppCategoryId);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_NOCATEGORYGUID_ERROR, hr, AppCategory.pszDescription);
                goto failure;
            }
            hr = CsRegisterAppCategory(&AppCategory);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_ADDCATEGORY_ERROR, hr, AppCategory.pszDescription);
                goto failure;
            }
            LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_ADDCATEGORY, hr, AppCategory.pszDescription);
        }
        else
        {
            // this is an old category
            sIndexes.erase(element->second);

            if (0 != element->first.Compare(m_pScopePane->m_CatList.pCategoryInfo[element->second].pszDescription))
            {
                // the category has been renamed
                APPCATEGORYINFO AppCategory;
                AppCategory.Locale = GetUserDefaultLCID();
                AppCategory.pszDescription = (LPOLESTR)((LPCOLESTR)element->first);
                AppCategory.AppCategoryId = m_pScopePane->m_CatList.pCategoryInfo[element->second].AppCategoryId;
                hr = CsRegisterAppCategory(&AppCategory);
                if (FAILED(hr))
                {
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_RENAMECATEGORY_ERROR, hr, AppCategory.pszDescription);
                    goto failure;
                }
                LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_RENAMECATEGORY, hr, AppCategory.pszDescription);
            }
        }
    }

    // remove deleted categories
    {
        set<ULONG>::iterator i;
        for (i = sIndexes.begin(); i != sIndexes.end(); i++)
        {
            hr = CsUnregisterAppCategory(&m_pScopePane->m_CatList.pCategoryInfo[*i].AppCategoryId);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_REMOVECATEGORY_ERROR, hr, m_pScopePane->m_CatList.pCategoryInfo[*i].pszDescription);
                goto failure;
            }
            LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_REMOVECATEGORY, hr, m_pScopePane->m_CatList.pCategoryInfo[*i].pszDescription);
        }
    }

failure:
    // reload the list of categories from the class store
    m_pScopePane->ClearCategories();
    CsGetAppCategories(&m_pScopePane->m_CatList);

    // tell any open package category property pages to refresh
    {
        map<MMC_COOKIE, CAppData>::iterator i;
        for (i = m_pScopePane->m_AppData.begin(); i != m_pScopePane->m_AppData.end(); i++)
        {
            if (i->second.m_pCategory)
            {
                i->second.m_pCategory->SendMessage(WM_USER_REFRESH, 0, 0);
            }
        }
    }
    // refresh the data
    RefreshData();
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CATEGORYFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    return CPropertyPage::OnApply();
}


void CCatList::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_CATEGORIES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\cause.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       cause.cpp
//
//  Contents:   Digital Signitures property page
//
//  Classes:    CCause
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCause property page

IMPLEMENT_DYNCREATE(CCause, CPropertyPage)

CCause::CCause() : CPropertyPage(CCause::IDD),
    m_fRemovedView(FALSE)
{
        //{{AFX_DATA_INIT(CCause)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CCause::~CCause()
{
    *m_ppThis = NULL;
}

void CCause::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCause)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCause, CPropertyPage)
        //{{AFX_MSG_MAP(CCause)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCause message handlers

BOOL CCause::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    RefreshData();
    return TRUE;
}

BOOL CCause::OnApply()
{
    return CPropertyPage::OnApply();
}


LRESULT CCause::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD, TRUE);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CCause::RefreshData(void)
{
    CString sz;
    CString szTemp;

    sz.LoadString(IDS_RSOP_APPLY);
    sz += TEXT("\r\n\r\n");

    switch (m_pData->m_dwApplyCause)
    {
    case 1:
        szTemp.LoadString(IDS_RSOP_AC1);
        break;
    case 2:
        szTemp.LoadString(IDS_RSOP_AC2);
        break;
    case 3:
        szTemp.LoadString(IDS_RSOP_AC3);
        break;
    case 4:
        szTemp.LoadString(IDS_RSOP_AC4);
        break;
    case 5:
        szTemp.LoadString(IDS_RSOP_AC5);
        break;
    case 6:
        szTemp.LoadString(IDS_RSOP_AC6);
        break;
    case 7:
        szTemp.LoadString(IDS_RSOP_AC7);
        break;
    case 8:
        szTemp.LoadString(IDS_RSOP_AC8);
        break;
    default:
        szTemp.LoadString(IDS_NODATA);
    }
    sz += szTemp;
    if (m_pData->m_dwApplyCause >= 1)
    {
        switch (m_pData->m_dwLanguageMatch)
        {
        case 1:
            szTemp.LoadString(IDS_RSOP_LM1);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 2:
            szTemp.LoadString(IDS_RSOP_LM2);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 3:
            szTemp.LoadString(IDS_RSOP_LM3);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 4:
            szTemp.LoadString(IDS_RSOP_LM4);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 5:
            szTemp.LoadString(IDS_RSOP_LM5);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        default:
            szTemp = TEXT("");
            break;
        }
        sz += szTemp;

        switch (m_pData->m_dwApplyCause)
        {
        case 4:
            szTemp.Format(IDS_RSOP_EXTACT, m_pData->m_szOnDemandFileExtension);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 5:
            szTemp.Format(IDS_RSOP_CLSIDACT, m_pData->m_szOnDemandClsid);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 7:
            szTemp.Format(IDS_RSOP_PROGIDACT, m_pData->m_szOnDemandProgid);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        default:
            szTemp = TEXT("");
        }
        sz += szTemp;
    }

    if (m_fRemovedView)
    {
        sz += TEXT("\r\n\r\n\r\n");
        szTemp.LoadString(IDS_RSOP_REMOVAL);
        sz += szTemp;
        sz += TEXT("\r\n\r\n");

        switch (m_pData->m_dwRemovalType)
        {
        case 2:
            szTemp.LoadString(IDS_RSOP_RT2);
            break;
        case 3:
            szTemp.LoadString(IDS_RSOP_RT3);
            break;
        case 4:
            szTemp.LoadString(IDS_RSOP_RT4);
            break;
        default:
            szTemp.LoadString(IDS_NODATA);
        }
        sz += szTemp;

        if (m_pData->m_dwRemovalType >= 2 && m_pData->m_dwRemovalType <= 4)
        {
            switch (m_pData->m_dwRemovalCause)
            {
            case 2:
            {
                szTemp.Format(IDS_RSOP_RC2, m_pData->m_szRemovingApplicationName); 
                szTemp = TEXT("\r\n") + szTemp;
            }
                break;
            case 3:
                szTemp.LoadString(IDS_RSOP_RC3);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 4:
                szTemp.LoadString(IDS_RSOP_RC4);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 5:
                szTemp.LoadString(IDS_RSOP_RC5);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 6:
                szTemp.Format(IDS_RSOP_RC6, m_pData->m_szRemovingApplicationName);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 7:
                szTemp.Format(IDS_RSOP_RC7, m_pData->m_szRemovingApplicationName);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 8:
                szTemp.LoadString(IDS_RSOP_RC8);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            default:
                szTemp = TEXT("");
            }
            sz += szTemp;
        }
    }

    CEdit * pEd = (CEdit *) GetDlgItem(IDC_EDIT1);
    pEd->Clear();
    pEd->ReplaceSel(sz);
    SetModified(FALSE);
}

void CCause::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_RSOPCAUSE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\cause.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       cause.h
//
//  Contents:   RSOP's Cause property sheet
//
//  Classes:    CCause
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CCause dialog

class CCause : public CPropertyPage
{
        DECLARE_DYNCREATE(CCause)

// Construction
public:
        CCause();
        ~CCause();
        CCause ** m_ppThis;
        CAppData * m_pData;
        BOOL    m_fRemovedView;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CCause)
        enum { IDD = IDD_RSOPCAUSE};
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCause)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CCause)
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\data.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.h
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  Functions:
//
//  History:    05-27-1997   stevebl   Created
//              03-14-1998   stevebl   corrected
//
//---------------------------------------------------------------------------

#ifndef _DATA_H_
#define _DATA_H_

#define _NEW_
#include <map>
#include <set>
#include <algorithm>
using namespace std;

typedef enum DEPLOYMENT_TYPES
{
    DT_ASSIGNED = 0,
    DT_PUBLISHED
} DEPLOYMENT_TYPE;

class CScopePane;
class CProduct;
class CDeploy;
class CCategory;
class CXforms;
class CPackageDetails;
class CUpgradeList;
class CPrecedence;
class CErrorInfo;
class CCause;

class CAppData
{
public:
    CAppData();
    ~CAppData();

// data
    PACKAGEDETAIL *     m_pDetails;
    MMC_COOKIE          m_itemID;
    BOOL                m_fVisible;
    BOOL                m_fHide;
    BOOL                m_fRSoP;

    // property pages:  (NULL unless property pages are being displayed)
    CProduct *          m_pProduct;
    CDeploy *           m_pDeploy;
    CCategory *         m_pCategory;
    CUpgradeList *      m_pUpgradeList;
    CXforms *           m_pXforms;
    CPrecedence *       m_pPrecedence;
    CPackageDetails *   m_pPkgDetails;
    CErrorInfo *        m_pErrorInfo;
    CCause *            m_pCause;
    CString             m_szUpgrades;   // cache of upgrade relationships
    void                NotifyChange(void);

    // RSOP MODE data members
    CString             m_szGPOID;    // path to originating GPO
    CString             m_szGPOName;  // Friendly name of originating GPO
    CString             m_szSOMID;
    CString             m_szDeploymentGroupID;
    DWORD               m_dwApplyCause;
    DWORD               m_dwLanguageMatch;
    CString             m_szOnDemandFileExtension;
    CString             m_szOnDemandClsid;
    CString             m_szOnDemandProgid;
    DWORD               m_dwRemovalCause;
    DWORD               m_dwRemovalType;
    CString             m_szRemovingApplication;
    CString             m_szRemovingApplicationName;
    PSECURITY_DESCRIPTOR m_psd;
    set <CString>       m_setUpgradedBy;
    set <CString>       m_setUpgrade;
    set <CString>       m_setReplace;

    // failed settings data
    CString             m_szEventSource;
    CString             m_szEventLogName;
    DWORD               m_dwEventID;
    CString             m_szEventTime;
    HRESULT             m_hrErrorCode;
    int                 m_nStatus; // Values { "Unspecified", "Applied", "Ignored", "Failed", "SubsettingFailed" }
    CString             m_szEventLogText;

// methods - NOTE: all methods require a valid pDetails
    void                InitializeExtraInfo(void);
    void                GetSzDeployment(CString &);
    void                GetSzAutoInstall(CString &);
    void                GetSzLocale(CString &);
    void                GetSzPlatform(CString &);
    void                GetSzStage(CString &);
    void                GetSzUpgrades(CString &, CScopePane *);
    void                GetSzUpgradedBy(CString &, CScopePane *);
    void                GetSzVersion(CString &);
    void                GetSzMods(CString &);
    void                GetSzSource(CString &);
    void                GetSzPublisher(CString &);
    void                GetSzOOSUninstall(CString &);
    void                GetSzShowARP(CString &);
    void                GetSzUIType(CString &);
    void                GetSzIgnoreLoc(CString &);
    void                GetSzRemovePrev(CString &);
    void                GetSzProductCode(CString &);
    void                GetSzOrigin(CString &);
    void                GetSzSOM(CString &);
    int                 GetImageIndex(CScopePane *);
    static DWORD        Get64BitMsiArchFlags ( PACKAGEDETAIL* pPackageDetails );
    BOOL                Is64Bit(void);
    static BOOL         Is64Bit( PACKAGEDETAIL* pPackageDetails );
    void                GetSzX86OnWin64(CString &);
    void                GetSzFullInstall(CString &);
};


#endif // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.cpp
//
//  Contents:   implementation of IDataObject
//
//  Classes:    CDataObject
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_fMachine)
        return Create((LPVOID)&CLSID_MachineSnapin, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\dataobj.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.h
//
//  Contents:   implementation of IDataObject for the snapin objects
//
//  Classes:    CDataObject
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CResultPane;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal; // Step 3

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    BOOL    m_fMachine;

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    // Step 3
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\data.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       data.cpp
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  History:    05-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CAppData::CAppData()
{
    m_pDetails = NULL;
    m_itemID = 0;
    m_fVisible = 0;
    m_fHide = FALSE;
    m_pProduct = NULL;
    m_pDeploy = NULL;
    m_pCategory = NULL;
    m_pXforms = NULL;
    m_pPkgDetails = NULL;
    m_pUpgradeList = NULL;
    m_pErrorInfo = NULL;
    m_pCause = NULL;
    m_fRSoP = FALSE;
    m_psd = NULL;
    m_dwApplyCause = 0;
    m_dwLanguageMatch = 0;
    m_szOnDemandFileExtension = L"";
    m_szOnDemandClsid = L"";
    m_szOnDemandProgid = L"";
    m_dwRemovalCause = 0;
    m_dwRemovalType = 0;
    m_szRemovingApplication = L"";
    m_szEventSource = L"";
    m_szEventLogName = L"";
    m_dwEventID = 0;
    m_szEventTime = L"";
    m_szEventLogText = L"";
    m_hrErrorCode = 0;
    m_nStatus = 0;
}

CAppData::~CAppData()
{
    if (m_pProduct)
    {
        m_pProduct->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pDeploy)
    {
        m_pDeploy->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pCategory)
    {
        m_pCategory->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pUpgradeList)
    {
        m_pUpgradeList->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pXforms)
    {
        m_pXforms->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pPkgDetails)
    {
        m_pPkgDetails->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pErrorInfo)
    {
        m_pErrorInfo->SendMessage(WM_USER_CLOSE, 0, 0);
    }
}

void CAppData::NotifyChange(void)
{
    if (m_pProduct)
    {
        m_pProduct->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pDeploy)
    {
        m_pDeploy->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pCategory)
    {
        m_pCategory->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pUpgradeList)
    {
        m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pXforms)
    {
        m_pXforms->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pPkgDetails)
    {
        m_pPkgDetails->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pErrorInfo)
    {
        m_pErrorInfo->SendMessage(WM_USER_REFRESH, 0, 0);
    }
}

void CAppData::InitializeExtraInfo(void)
{
    // at the moment, there is no extra info
    return;
}

void CAppData::GetSzPublisher(CString &sz)
{
    sz = m_pDetails->pszPublisher;
}

void CAppData::GetSzOOSUninstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UninstallOnPolicyRemoval) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzShowARP(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UserInstall) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzUIType(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->InstallUiLevel == INSTALLUILEVEL_FULL) ? IDS_MAXIMUM : IDS_BASIC);
}

void CAppData::GetSzIgnoreLoc(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_IgnoreLanguage) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzRemovePrev(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UninstallUnmanaged) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzX86OnWin64(CString &sz)
{
    BOOL fYes = 0;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Check this only for 32-bit apps
    //
    if ( ! Is64Bit() )
    {
        fYes = 0 != (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_ExcludeX86OnWin64);
    }


    if ( ! Is64Bit() )
    {
        if (m_pDetails->pInstallInfo->PathType == SetupNamePath)
        {
            //reverse the sense for legacy apps
            // (this flag  has the opposite meaning for legacy apps)
            fYes = !fYes;
        }
    }

    sz.LoadString(fYes ? IDS_YES : IDS_NO);
}

void CAppData::GetSzFullInstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
    {
        sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_InstallUserAssign) ? IDS_YES : IDS_NO);
    }
    else
    {
        sz.LoadString(IDS_NA);
    }
}

void CAppData::GetSzProductCode(CString &sz)
{
 //   szA = dataA.m_pDetails->pInstallInfo->ProductCode
    OLECHAR szTemp[80];
    StringFromGUID2(m_pDetails->pInstallInfo->ProductCode,
                    szTemp,
                    sizeof(szTemp) / sizeof(szTemp[0]));
    sz = szTemp;
}

void CAppData::GetSzOrigin(CString &sz)
{
    sz = m_szGPOName;
}

void CAppData::GetSzSOM(CString &sz)
{
    sz = m_szSOMID;
}

void CAppData::GetSzDeployment(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int id;
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        id = IDS_ASSIGNED;
    else
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Published)
        id = IDS_PUBLISHED;
    else
        id = IDS_DISABLED;
    sz.LoadString(id);
}

void CAppData::GetSzAutoInstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_OnDemandInstall) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzLocale(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < m_pDetails->pPlatformInfo->cLocales)
    {
        if (i > 0)
        {
            sz += ", ";
        }
        if (m_pDetails->pPlatformInfo->prgLocale[i])
        {
            GetLocaleInfo(m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
            sz += szBuffer;
    #ifdef SHOWCOUNTRY
            GetLocaleInfo(m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
            sz += _T(" - ");
            sz += szBuffer;
    #endif
        }
        else
        {
            // neutral locale
            CString szNeutral;
            szNeutral.LoadString(IDS_NEUTRAL_LOCALE);
            sz += szNeutral;
        }
        i++;
    }
}

void CAppData::GetSzPlatform(CString &sz)
{
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < m_pDetails->pPlatformInfo->cPlatforms)
    {
        if (i > 0)
        {
            sz += ", ";
        }
        ::LoadString(ghInstance, IDS_HW + m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch, szBuffer, 256);
        sz += szBuffer;
        i++;
    }
}

void CAppData::GetSzUpgrades(CString &sz, CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!m_szUpgrades.IsEmpty())
    {
        sz = m_szUpgrades;
        return;
    }

    if (m_fRSoP)
    {
        switch (m_setUpgrade.size() + m_setReplace.size())
        {
        case 0:
            sz.LoadString(IDS_NONE);
            break;
        case 1:
            if (1 == m_setUpgrade.size())
            {
                sz = *m_setUpgrade.begin();
            }
            else
            {
                sz = *m_setReplace.begin();
            }
            break;
        default:
            sz.LoadString(IDS_MULTIPLE);
            break;
        }
    }
    else
    {
        sz="";
        CString szName;
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        while (n--)
        {
            if (0 == (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                HRESULT hr = pScopePane->GetPackageNameFromUpgradeInfo(szName, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                if (SUCCEEDED(hr))
                {
                    if (sz.GetLength())
                    {
                        // We'd already found one
                        sz.LoadString(IDS_MULTIPLE);
                        m_szUpgrades = sz;
                        return;
                    }
                    sz = szName;
                }
            }
        }
        if (0 == sz.GetLength())
        {
            sz.LoadString(IDS_NONE);
        }
    }
    m_szUpgrades = sz;
}

void CAppData::GetSzUpgradedBy(CString &sz, CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_fRSoP)
    {
        switch (m_setUpgradedBy.size())
        {
        case 0:
            sz.LoadString(IDS_NONE);
            break;
        case 1:
            sz = *m_setUpgradedBy.begin();
            break;
        default:
            sz.LoadString(IDS_MULTIPLE);
            break;
        }
    }
    else
    {
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        CString szName;
        sz="";
        while (n--)
        {
            if (0 != (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                HRESULT hr = pScopePane->GetPackageNameFromUpgradeInfo(szName, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                if (SUCCEEDED(hr))
                {
                    if (sz.GetLength())
                    {
                        // We'd already found one
                        sz.LoadString(IDS_MULTIPLE);
                        return;
                    }
                    sz = szName;
                }
            }
        }
        if (0 == sz.GetLength())
        {
            sz.LoadString(IDS_NONE);
        }
    }
}

void CAppData::GetSzStage(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    BOOL fUpgrades = FALSE;

    if (m_fRSoP)
    {
        fUpgrades = (m_setUpgrade.size() + m_setReplace.size()) != 0;
    }
    else
    {
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        while (n-- && !fUpgrades)
        {
            if (0 == (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                fUpgrades = TRUE;
            }
        }
    }
    if (!fUpgrades)
    {
        sz.LoadString(IDS_NONE);
    }
    else
    if (ACTFLG_ForceUpgrade & m_pDetails->pInstallInfo->dwActFlags)
        sz.LoadString(IDS_REQUIRED);
    else
        sz.LoadString(IDS_OPTIONAL);
}

void CAppData::GetSzVersion(CString &sz)
{
    TCHAR szBuffer[256];
    (void) StringCchPrintf(szBuffer,
                           sizeof(szBuffer)/sizeof(szBuffer[0]),
                           _T("%u.%u"), 
                           m_pDetails->pInstallInfo->dwVersionHi, 
                           m_pDetails->pInstallInfo->dwVersionLo);
    sz = szBuffer;
}

void CAppData::GetSzSource(CString &sz)
{
    if (1 <= m_pDetails->cSources)
    {
        sz = m_pDetails->pszSourceList[0];
    }
    else
        sz = "";
}

void CAppData::GetSzMods(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (2 < m_pDetails->cSources)
    {
        sz.LoadString(IDS_MULTIPLE);
    }
    else
    {
        if (2 == m_pDetails->cSources)
        {
            sz = m_pDetails->pszSourceList[1];
        }
        else
            sz = "";
    }
}

int CAppData::GetImageIndex(CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_nStatus == 3)
    {
        // RSoP setting failed status
        return IMG_OPEN_FAILED;
    }
    CString sz;
    GetSzUpgrades(sz, pScopePane);
    CString sz2;
    sz2.LoadString(IDS_NONE);
    // gonna use the upgrade icon but it's only gonna be used when
    // m_szUpgrades doesn't read "none"
    if (0 != sz2.Compare(sz))
    {
        // we must be upgrading something
        return IMG_UPGRADE;
    }
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        return IMG_ASSIGNED;
    else
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Published)
        return IMG_PUBLISHED;
    else
        return IMG_DISABLED;
}

DWORD CAppData::Get64BitMsiArchFlags( PACKAGEDETAIL* pPackageDetails )
{
    UINT n = pPackageDetails->pPlatformInfo->cPlatforms;
    while (n--)
    {
        if (pPackageDetails->pPlatformInfo->prgPlatform[n].dwProcessorArch == PROCESSOR_ARCHITECTURE_AMD64)
        {
            return MSIARCHITECTUREFLAGS_AMD64;
        }

        if (pPackageDetails->pPlatformInfo->prgPlatform[n].dwProcessorArch == PROCESSOR_ARCHITECTURE_IA64)
        {
            return MSIARCHITECTUREFLAGS_IA64;
        }
    }

    return 0;
}

BOOL CAppData::Is64Bit( PACKAGEDETAIL* pPackageDetails )
{
    UINT n = pPackageDetails->pPlatformInfo->cPlatforms;
    while (n--)
    {
        if ((pPackageDetails->pPlatformInfo->prgPlatform[n].dwProcessorArch == PROCESSOR_ARCHITECTURE_AMD64) ||
            (pPackageDetails->pPlatformInfo->prgPlatform[n].dwProcessorArch == PROCESSOR_ARCHITECTURE_IA64))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CAppData::Is64Bit(void)
{
    return Is64Bit( m_pDetails );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************



//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//
#if DBG

#define DebugMsg(x) _DebugMsg x
#define DebugReportFailure(x, y) if (FAILED(x)) DebugMsg(y)

#else

#define DebugMsg(x)
#define DebugReportFailure(x, y)

#endif // DBG

//
// Debug function proto-types
//

void __cdecl _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\common.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       common.h
//
//  Contents:   common definitions used by the main snapin modules
//
//  Classes:    CResultPane, CScopePane
//
//  History:    03-14-1998   stevebl   Commented
//              05-20-1998   RahulTh   Added CScopePane::DetectUpgrades
//                                     for auto-upgrade detection
//              05-10-2001   RahulTh   Added infrastructure for enabling
//                                     theme'ing of UI components.
//
//---------------------------------------------------------------------------

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include "objidl.h"
#include "data.h"
#include "gpedit.h"
#include "adeevent.h"
#include "iads.h"
#include <iadsp.h>
#include <ntdsapi.h>
#include <dssec.h>
#include <set>
#include <shfusion.h>

//
// Add theme'ing support. Since we use MFC, we need to perform some additional
// tasks in order to get all our UI elements theme'd. We need this class to
// activate the theme'ing context around any UI that we want theme'd.
//
class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};


// Uncomment the next line to re-enable the digital signatures code.
// #define DIGITAL_SIGNATURES 1
// Digital signatures have been cut in faver of the "SAFER" technology.

class CUpgrades;    //forward declaration; added RahulTh 5/19/1998.

// private notifications
#define WM_USER_REFRESH     (WM_USER + 1000)
#define WM_USER_CLOSE       (WM_USER + 1001)

// very big number to be sure that we can always squeeze a DS path into it
#define MAX_DS_PATH         1024

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern CLSID CLSID_Temp;
extern const wchar_t * szCLSID_Snapin;
extern const CLSID CLSID_MachineSnapin;
extern const wchar_t * szCLSID_MachineSnapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;
extern GUID guidExtension;
extern GUID guidUserSnapin;
extern GUID guidMachSnapin;

// RSOP GUIDS
extern const CLSID CLSID_RSOP_Snapin;
extern const wchar_t * szCLSID_RSOP_Snapin;
extern const CLSID CLSID_RSOP_MachineSnapin;
extern const wchar_t * szCLSID_RSOP_MachineSnapin;
extern GUID guidRSOPUserSnapin;
extern GUID guidRSOPMachSnapin;

typedef enum NEW_PACKAGE_BEHAVIORS
{
    NP_PUBLISHED = 0,
    NP_ASSIGNED,
    NP_DISABLED,
    NP_UPGRADE
} NEW_PACKAGE_BEHAVIOR;

typedef enum tagUPGRADE_DISPOSITION
{
    UNINSTALL_EXISTING = 0x0,
    BLOCK_INSTALL = 0x1,
    INSTALLED_GREATER = 0x2,
    INSTALLED_LOWER = 0x4,
    INSTALLED_EQUAL = 0x8,
    MIGRATE_SETTINGS = 0x10
} UPGRADE_DISPOSITION;

#define IMG_OPENBOX   0
#define IMG_CLOSEDBOX 1
#define IMG_DISABLED  2
#define IMG_PUBLISHED 3
#define IMG_ASSIGNED  4
#define IMG_UPGRADE   5
#define IMG_OPEN_FAILED 6
#define IMG_CLOSED_FAILED 7

#define CFGFILE _T("ADE.CFG")

// Uncomment the next line to return to the old way of deploying packages
// with multiple LCIDs.  With this commented only the primary (first)
// LCID gets a deployment.
//#define DEPLOY_MULTIPLE_LCIDS

// Uncomment the next line to include country names in text representations
// of LCIDs.
//#define SHOWCOUNTRY 0

//
// MACROS for allocating and freeing memory via OLE's common allocator: IMalloc.
//
// (NOTE) the Class Store API no longer use IMalloc so thes macros have been
// reverted back to using new and free.
//

//extern IMalloc * g_pIMalloc;

// UNDONE - throw exception on failure

#define OLEALLOC(x) LocalAlloc(0, x)
//#define OLEALLOC(x) g_pIMalloc->Alloc(x)

#define OLESAFE_DELETE(x) if (x) {LocalFree(x); x = NULL;}
//#define OLESAFE_DELETE(x) if (x) {g_pIMalloc->Free(x); x = NULL;}

#define OLESAFE_COPYSTRING(szO, szI) {if (szI) {int i_dontcollidewithanything = wcslen(szI); \
szO=(OLECHAR *)OLEALLOC(sizeof(OLECHAR) * (i_dontcollidewithanything+1));\
if (szO) {HRESULT hrSafeCopy = StringCchCopy(szO, i_dontcollidewithanything+1, szI);ASSERT(SUCCEEDED(hrSafeCopy));}} else szO=NULL;}

// Keys used in the CFG file.
//
// The CFG file is found in the Applications directory of the SysVol (which
// is the same directory as the script files).
//
// The format of an entry in the CFG file is:
//
//      %key%=%data%
//
// where %data% is either an integer or a string as appropriate.
//
// Order is not important and if a key is not present in the CFG file then
// the default setting will be used.  Some keys (iDebugLevel and
// fShowPkgDetails) will only be saved in the CFG file if their values are
// different from the default settings.
//
#define KEY_NPBehavior      L"Default Deployment"
#define KEY_fCustomDeployment L"Use Custom Deployment"
#define KEY_fUseWizard      L"Use Deployment Wizard"
#define KEY_UILevel         L"UI Level"
#define KEY_szStartPath     L"Start Path"
#define KEY_iDebugLevel     L"Debug Level"
#define KEY_fShowPkgDetails L"Package Details"
#define KEY_f32On64         L"Run 32b Apps on 64b"
#define KEY_fZapOn64        L"Run ZAP Apps on 64b"
#define KEY_fExtensionsOnly L"Only Deploy Extension Info"
#define KEY_nUninstallTrackingMonths L"Uninstall Tracking Months"
#define KEY_fUninstallOnPolicyRemoval L"Uninstall On Policy Removal"

typedef struct tagTOOL_DEFAULTS
{
    NEW_PACKAGE_BEHAVIOR    NPBehavior;
    BOOL                    fCustomDeployment;
    BOOL                    fUseWizard;
    INSTALLUILEVEL          UILevel;
    CString                 szStartPath;
    int                     iDebugLevel;
    BOOL                    fShowPkgDetails;
    ULONG                   nUninstallTrackingMonths;
    BOOL                    fUninstallOnPolicyRemoval;
    BOOL                    fZapOn64;
    BOOL                    f32On64;
    BOOL                    fExtensionsOnly;
} TOOL_DEFAULTS;

/////////////////////////////////////////////////////////////////////////////
// Snapin

typedef set<long> EXTLIST;

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CToolDefs;
class CToolAdvDefs;
class CTracking;
class CCatList;
class CFileExt;
class CSignatures;

class CScopePane:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public IExtendPropertySheet,
    public ISnapinAbout,
    public ISnapinHelp,
    public CComObjectRoot
{

    friend class CResultPane;
    friend class CDataObject;

public:
        CScopePane();
        ~CScopePane();

        HWND m_hwndMainWindow;
        LPRSOPINFORMATION    m_pIRSOPInformation;  // Interface pointer to the GPT
protected:
    LPGPEINFORMATION    m_pIGPEInformation;  // Interface pointer to the GPT
    BOOL                m_fRSOPEnumerate;      // OK to enumerate RSoP data
    BOOL                m_fRSOPPolicyFailed;  // TRUE if there was a failure applying SI policy

public:
    DWORD               m_dwRSOPFlags;
    virtual IUnknown * GetMyUnknown() = 0;

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// ISnapinAbout interface
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP * hSmallImage,
                                 HBITMAP * hSmallImageOpen,
                                 HBITMAP * hLargeImage,
                                 COLORREF * cMask);
    //
    // Implemented ISnapinHelp interface members
    //
public:
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);

// Notify handler declarations
private:
    HRESULT OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);
    STDMETHOD(ChangePackageState)(CAppData & data, DWORD dwNewFlags, BOOL fShowUI);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CScopePane::AddRef  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CScopePane::Release  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void DeleteList();
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    HRESULT InitializeADE();
    HRESULT GetDeploymentType(PACKAGEDETAIL * ppd, BOOL & fShowPropertySheet);
    HRESULT DeployPackage(PACKAGEDETAIL * ppd, BOOL fShowPropertySheet);
    HRESULT AddZAPPackage(LPCOLESTR szPackagePath,
                          LPCOLESTR lpFileTitle);
    HRESULT AddMSIPackage(LPCOLESTR szPackagePath,
                          LPCOLESTR lpFileTitle);
    HRESULT RemovePackage(MMC_COOKIE cookie, BOOL fForceUninstall, BOOL fRemoveNow);
    void Refresh();
    HRESULT DetectUpgrades (LPCOLESTR szPackagePath, const PACKAGEDETAIL* ppd, CUpgrades& dlgUpgrade);
    HRESULT TestForRSoPData(BOOL * pfPolicyFailed);

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    BOOL                    m_bIsDirty;
    IClassAdmin *           m_pIClassAdmin;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(MMC_COOKIE cookie);
    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    HRESULT GetClassStore(BOOL fCreateOK);
    void LoadToolDefaults();
    void SaveToolDefaults();
    set <CResultPane *> m_sResultPane;
    IPropertySheetProvider * m_pIPropertySheetProvider;

    BOOL                    m_fBlockAddPackage; // don't use a crit-sec
                                                // because all MMC UI is
                                                // always called from
                                                // the same thread

public:
    void GetUniquePackageName(CString szIn, CString &szOut, int &nHint);
    HRESULT GetClassStoreName(CString &, BOOL fCreateOK);
    void    DisplayPropSheet(CString szPackageName, int iPage);
    HRESULT PopulateUpgradeLists();
    HRESULT InsertUpgradeEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT RemoveUpgradeEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT PopulateExtensions();
    HRESULT InsertExtensionEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT RemoveExtensionEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT PrepareExtensions(PACKAGEDETAIL &pd);
    HRESULT ClearCategories();
    HRESULT GetPackageDSPath(CString &szPath, LPOLESTR szPackageName);
    HRESULT GetPackageNameFromUpgradeInfo(CString &szPackageName, GUID & PackageGuid, LPOLESTR szCSPath);
    HRESULT GetRSoPCategories(void);
    void    CScopePane::RemoveResultPane(CResultPane * pRP);

    // global property pages
    CToolDefs *             m_pToolDefs;
    CToolAdvDefs *          m_pToolAdvDefs;
    CTracking *             m_pTracking;
    CCatList *              m_pCatList;
    CFileExt *              m_pFileExt;
#ifdef DIGITAL_SIGNATURES
    CSignatures *           m_pSignatures;
#endif // DIGITAL_SIGNATURES

    CString m_szGPT_Path;
    CString m_szGPO;
    CString m_szGPODisplayName;
    CString m_szDomainName;
    CString m_szLDAP_Path;
    CString m_szFolderTitle;
    CString m_szRSOPNamespace;

    map <MMC_COOKIE, CAppData>    m_AppData;      // One entry for each
                                            // application in the class
                                            // store.  Maps cookies to
                                            // application packages.
    map <CString, EXTLIST>  m_Extensions;   // Maps extensions to the
                                            // list of apps that support
                                            // them.
    map <CString, MMC_COOKIE>     m_UpgradeIndex; // Maps upgrade GUIDs to the
                                            // apps that they belong to.
    APPCATEGORYINFOLIST     m_CatList;      // category list
    TOOL_DEFAULTS m_ToolDefaults;
    BOOL        m_fMachine;
    BOOL        m_fRSOP;
    int         m_iViewState;
    BOOL        m_fDisplayedRsopARPWarning;

    MMC_COOKIE m_lLastAllocated;
};

class CMachineComponentDataImpl:
    public CScopePane,
    public CComCoClass<CMachineComponentDataImpl, &CLSID_MachineSnapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CMachineComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CMachineComponentDataImpl()
    {
        m_fMachine = TRUE;
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CUserComponentDataImpl, &CLSID_Snapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CUserComponentDataImpl()
    {
        m_fMachine = FALSE;
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPMachineComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPMachineComponentDataImpl, &CLSID_RSOP_MachineSnapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPMachineComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPMachineComponentDataImpl()
    {
        m_fMachine = TRUE;
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPUserComponentDataImpl, &CLSID_RSOP_Snapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPUserComponentDataImpl()
    {
        m_fMachine = FALSE;
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CResultPane :
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
    BOOL _fVisible;
        CResultPane();
        ~CResultPane();

BEGIN_COM_MAP(CResultPane)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;
    LPDISPLAYHELP m_pDisplayHelp;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CResultPane
public:
    void SetIComponentData(CScopePane* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CResultPane::AddRef  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CResultPane::Release  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPARAM param);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick);
    BOOL OnFileDrop (LPDATAOBJECT lpDataObject);

public:
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

// IExtendContextMenu
public:

    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    void Construct();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    void Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);

public:
    void EnumerateResultPane(MMC_COOKIE cookie);
    HRESULT EnumerateRSoPData(void);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CScopePane * m_pScopePane;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode

public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPTOOLBAR           m_pToolbar;
    LPCONTROLBAR        m_pControlbar;

    int                 m_nSortColumn;
    DWORD               m_dwSortOptions;


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_szFolderTitle;
};

inline void CResultPane::SetIComponentData(CScopePane* pData)
{
    ASSERT(pData);
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::SetIComponentData  pData=%08x."), pData));
    ASSERT(m_pScopePane == NULL);
    LPUNKNOWN pUnk = pData->GetMyUnknown();
    pUnk->AddRef();
#if 0
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    if (SUCCEEDED(hr))
    {
        m_pScopePane = dynamic_cast<CScopePane*>(lpcd);
    }
#else
    m_pScopePane = pData;
#endif
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

class CUpgradeData
{
public:
    GUID    m_PackageGuid;
    CString m_szClassStore;
    int     m_flags;
};

LRESULT SetPropPageToDeleteOnClose(void * vpsp);

CString GetUpgradeIndex(GUID & PackageID);

#define HELP_FILE TEXT("ade.hlp")

void LogADEEvent(WORD wType, DWORD dwEventID, HRESULT hr, LPCWSTR szOptional = NULL);
void ReportGeneralPropertySheetError(HWND hwnd, LPCWSTR sz, HRESULT hr);
void ReportPolicyChangedError(HWND hwnd);
void WINAPI StandardHelp(HWND hWnd, UINT nIDD, BOOL fRsop = FALSE);
void WINAPI StandardContextMenu(HWND hWnd, UINT nIDD, BOOL fRsop = FALSE);

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)

//
// Helper function and defines for theme'ing property pages put up by the snap-in.
//
#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "precomp.hxx"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPEdit[] = TEXT("APPMGR(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPEditDebugLevel")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//              9-23-1998   stevebl    shamelessly stolen from Eric's code
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[4096];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        (void) StringCchPrintf (szDebugTitle, 
                                sizeof(szDebugTitle)/sizeof(szDebugTitle[0]),
                                c_szGPEdit, 
                                GetCurrentProcessId());

        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        (void) StringCchVPrintf(szDebugBuffer,
                               sizeof(szDebugBuffer)/sizeof(szDebugBuffer[0]),
                               pszMsg, 
                               marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("\\GPEdit.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\dplapp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       DplApp.cpp
//
//  Contents:   Application deployment dialog
//
//  Classes:    CDeployApp
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog


CDeployApp::CDeployApp(CWnd* pParent /*=NULL*/)
        : CDialog(CDeployApp::IDD, pParent)
{
        //{{AFX_DATA_INIT(CDeployApp)
        m_iDeployment = 0;
        //}}AFX_DATA_INIT
}


void CDeployApp::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeployApp)
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeployApp, CDialog)
        //{{AFX_MSG_MAP(CDeployApp)
    ON_WM_CONTEXTMENU()
    ON_BN_CLICKED(IDC_RADIO2, OnPublished)
    ON_BN_CLICKED(IDC_RADIO3, OnAssigned)
    ON_BN_CLICKED(IDC_RADIO1, OnCustom)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CDeployApp::OnPublished()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTPUB);
    SetDlgItemText(IDC_STATIC1, sz);
}

void CDeployApp::OnAssigned()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTASSIGNED);
    SetDlgItemText(IDC_STATIC1, sz);
}

void CDeployApp::OnCustom()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTCUSTOM);
    SetDlgItemText(IDC_STATIC1, sz);
}

BOOL CDeployApp::OnInitDialog()
{
    if (m_fCrappyZaw)
    {
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
    }
    if (m_fMachine)
    {
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        if (0 == m_iDeployment)
        {
            m_iDeployment++;
        }
    }
    CString sz;
    switch (m_iDeployment)
    {
    case 0:
        // Published
        sz.LoadString(IDS_DEPLOYTEXTPUB);
        break;
    case 1:
        // Assigned
        sz.LoadString(IDS_DEPLOYTEXTASSIGNED);
        break;
    case 2:
        // Custom
        sz.LoadString(IDS_DEPLOYTEXTCUSTOM);
        break;
    }
    SetDlgItemText(IDC_STATIC1, sz);
    CDialog::OnInitDialog();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CDeployApp::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CDeployApp::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_DEPLOY_APP_DIALOG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\deploy.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       deploy.cpp
//
//  Contents:   application deployment property page
//
//  Classes:    CDeploy
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Guid of appmgmt client side GP extension, and guids for snapins
//

GUID guidExtension = { 0xc6dc5466, 0x785a, 0x11d2, {0x84, 0xd0, 0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7}};
GUID guidUserSnapin = CLSID_Snapin;
GUID guidMachSnapin = CLSID_MachineSnapin;
GUID guidRSOPUserSnapin = CLSID_RSOP_Snapin;
GUID guidRSOPMachSnapin = CLSID_RSOP_MachineSnapin;


/////////////////////////////////////////////////////////////////////////////
// CDeploy property page

IMPLEMENT_DYNCREATE(CDeploy, CPropertyPage)

CDeploy::CDeploy() : CPropertyPage(CDeploy::IDD)
{
        //{{AFX_DATA_INIT(CDeploy)
        m_fAutoInst = FALSE;
        m_fFullInst = FALSE;
        m_iUI = -1;
        m_iDeployment = -1;
        m_fUninstallOnPolicyRemoval = FALSE;
        m_hConsoleHandle = NULL;
        m_fNotUserInstall = FALSE;
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
        m_dlgAdvDep.m_pDeploy = this;
}

CDeploy::~CDeploy()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    MMCFreeNotifyHandle(m_hConsoleHandle);
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CDeploy::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeploy)
        DDX_Check(pDX, IDC_CHECK2, m_fAutoInst);
        DDX_Radio(pDX, IDC_RADIO3, m_iUI);
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        DDX_Check(pDX, IDC_CHECK1, m_fUninstallOnPolicyRemoval);
        DDX_Check(pDX, IDC_CHECK3, m_fNotUserInstall);
        DDX_Check(pDX, IDC_CHECK4, m_fFullInst);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeploy, CPropertyPage)
        //{{AFX_MSG_MAP(CDeploy)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdvanced)
        ON_BN_CLICKED(IDC_RADIO2, OnPublished)
        ON_BN_CLICKED(IDC_RADIO1, OnAssigned)
        ON_BN_CLICKED(IDC_CHECK2, OnChanged)
        ON_BN_CLICKED(IDC_CHECK3, OnChanged)
        ON_BN_CLICKED(IDC_RADIO3, OnChanged)
        ON_BN_CLICKED(IDC_RADIO4, OnChanged)
        ON_BN_CLICKED(IDC_CHECK1, OnChanged)
        ON_BN_CLICKED(IDC_CHECK4, OnChanged)
        ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeploy message handlers

BOOL CDeploy::OnApply()
{
    if (m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;
    dwActFlags &= ~(ACTFLG_Assigned | ACTFLG_Published |
                    ACTFLG_OnDemandInstall | ACTFLG_UserInstall |
                    ACTFLG_OrphanOnPolicyRemoval | ACTFLG_UninstallOnPolicyRemoval |
                    ACTFLG_InstallUserAssign |
                    ACTFLG_ExcludeX86OnWin64 | ACTFLG_IgnoreLanguage | ACTFLG_UninstallUnmanaged);
    switch (m_iDeployment)
    {
    case 2:
        // Disabled
        break;
    case 0:
        // Published
        dwActFlags |= ACTFLG_Published;
        if (m_fAutoInst)
        {
            dwActFlags |= ACTFLG_OnDemandInstall;
        }
        if (!m_fNotUserInstall)
        {
            dwActFlags |= ACTFLG_UserInstall;
        }
        break;
    case 1:
        // Assigned
        dwActFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
        if (!m_fNotUserInstall)
        {
            dwActFlags |= ACTFLG_UserInstall;
        }
        if (m_fFullInst)
        {
            dwActFlags |= ACTFLG_InstallUserAssign;
        }
        break;
    default:
        break;
    }

    if (m_pData->m_pDetails->pInstallInfo->PathType == SetupNamePath)
    {
        // legacy app
        if (m_dlgAdvDep.m_f32On64)
            dwActFlags |= ACTFLG_ExcludeX86OnWin64;
    }
    else
    {
        // not a legacy app
        if (!m_dlgAdvDep.m_f32On64)
            dwActFlags |= ACTFLG_ExcludeX86OnWin64;
    }

    if (m_fUninstallOnPolicyRemoval)
    {
        dwActFlags |= ACTFLG_UninstallOnPolicyRemoval;
    }
    else
    {
        // never set this flag for legacy applications
        if (m_pData->m_pDetails->pInstallInfo->PathType != SetupNamePath)
            dwActFlags |= ACTFLG_OrphanOnPolicyRemoval;
    }

    if (m_dlgAdvDep.m_fIgnoreLCID)
    {
        dwActFlags |= ACTFLG_IgnoreLanguage;
    }

    if (m_dlgAdvDep.m_fUninstallUnmanaged)
    {
        dwActFlags |= ACTFLG_UninstallUnmanaged;
    }

    UINT UILevel;
    switch (m_iUI)
    {
    case 1:
        UILevel = INSTALLUILEVEL_FULL;
        break;
    case 0:
    default:
        UILevel = INSTALLUILEVEL_BASIC;
        break;
    }

    HRESULT hr = E_FAIL;
    if (m_pIClassAdmin)
    {
        hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                     NULL,
                                                     &dwActFlags,
                                                     NULL,
                                                     NULL,
                                                     &UILevel,
                                                     NULL);
    }
    if (SUCCEEDED(hr))
    {
        m_pData->m_pDetails->pInstallInfo->InstallUiLevel = UILevel;
        m_pData->m_pDetails->pInstallInfo->dwActFlags = dwActFlags;
#if 0
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine,
                                                    TRUE,
                                                    &guidExtension,
                                                    m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
#endif
        if (!m_fPreDeploy)
        {
            MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
        }
        else
        {
            // we're in pre-deploy mode - check to see if the fExtensionsOnly
            // flag has changed (which requires a re-deploy)
            // note that these two flags are normally the same,
            // meaning that when they're different, the user has requested a
            // change.
            if (m_dlgAdvDep.m_fIncludeOLEInfo != m_pData->m_pDetails->pActInfo->bHasClasses)
            {
                // need to redeploy
                BOOL fBuildSucceeded = FALSE;
                PACKAGEDETAIL * ppd;

                //
                // Apply the current setting for classes
                //
                m_pData->m_pDetails->pActInfo->bHasClasses = m_dlgAdvDep.m_fIncludeOLEInfo;

                if (FAILED(CopyPackageDetail(ppd, m_pData->m_pDetails)))
                {
                    return FALSE;
                }

                CString sz;

                // Create a name for the new script file.

                // set the script path
                GUID guid;
                hr = CoCreateGuid(&guid);
                if (FAILED(hr))
                {
                    // undone
                }

                //
                // For MSI packages, we must regenerate class information
                //
                if ( DrwFilePath == ppd->pInstallInfo->PathType )
                {
                    OLECHAR szGuid [256];
                    StringFromGUID2(guid, szGuid, 256);

                    CString szScriptFile  = m_pScopePane->m_szGPT_Path;
                    szScriptFile += L"\\";
                    szScriptFile += szGuid;
                    szScriptFile += L".aas";
                    OLESAFE_DELETE(ppd->pInstallInfo->pszScriptPath);
                    OLESAFE_COPYSTRING(ppd->pInstallInfo->pszScriptPath, szScriptFile);
                    CString szOldName = ppd->pszPackageName;
                    hr = BuildScriptAndGetActInfo(*ppd, !m_dlgAdvDep.m_fIncludeOLEInfo);

                    if ( SUCCEEDED( hr ) )
                    {
                        if (0 != wcscmp(m_szInitialPackageName, szOldName))
                        {
                            // The User changed the name so we have to preserve his choice.
                            // If the user hasn't changed the package name then it's ok to
                            // set the packagename to whatever is in the script file.
                            OLESAFE_DELETE(ppd->pszPackageName);
                            OLESAFE_COPYSTRING(ppd->pszPackageName, szOldName);
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    fBuildSucceeded = TRUE;
                    hr = m_pScopePane->PrepareExtensions(*ppd);
                    if (SUCCEEDED(hr))
                    {
                        CString szUniqueName;
                        int     nHint;

                        nHint = 1;

                        m_pScopePane->GetUniquePackageName(ppd->pszPackageName, szUniqueName, nHint);
                        OLESAFE_DELETE(ppd->pszPackageName);
                        OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueName);

                        if ( ppd->pszPackageName )
                        {
                            hr = m_pIClassAdmin->RedeployPackage(
                                &m_pData->m_pDetails->pInstallInfo->PackageGuid,
                                ppd);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr))
                        {
                            // delete the old script
                            DeleteFile(m_pData->m_pDetails->pInstallInfo->pszScriptPath);
                            // update indexes and property sheets
                            m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                            m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                            FreePackageDetail(m_pData->m_pDetails);
                            m_pData->m_pDetails = ppd;
                            m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                            m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                            if (m_pScopePane->m_pFileExt)
                            {
                                m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                            }
                        }
                    }
                }
                if (FAILED(hr))
                {
                    CString sz;
                    sz.LoadString(fBuildSucceeded ? IDS_REDEPLOY_FAILED_IN_CS : IDS_REDEPLOY_FAILED);
                    ReportGeneralPropertySheetError(m_hWnd, sz, hr);

                    // delete new script file (assuming it was created)
                    if ( ( DrwFilePath == ppd->pInstallInfo->PathType ) &&
                         ppd->pInstallInfo->pszScriptPath )
                    {
                        DeleteFile(ppd->pInstallInfo->pszScriptPath);
                    }

                    FreePackageDetail(ppd);
                    return FALSE;
                }

            }
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }

    return CPropertyPage::OnApply();
}

BOOL CDeploy::OnInitDialog()
{
    RefreshData();
    if (m_pData->m_pDetails->pInstallInfo->PathType == SetupNamePath)
    {
        // legacy apps can't be assigned
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        // legacy apps don't have a UI level
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
        // legacy apps can't be uninstalled
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    }

    m_szInitialPackageName = m_pData->m_pDetails->pszPackageName;

    if (m_fMachine)
    {
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        // machine deployed apps don't have a UI
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }
    if (0 != (m_pData->m_pDetails->pInstallInfo->dwActFlags & ACTFLG_MinimalInstallUI))
    {
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }
    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CDeploy::OnAdvanced()
{
    BOOL fIgnoreLCID = m_dlgAdvDep.m_fIgnoreLCID;
    BOOL fInstallOnAlpha = m_dlgAdvDep.m_fInstallOnAlpha;
    BOOL fUninstallUnmanaged = m_dlgAdvDep.m_fUninstallUnmanaged;
    BOOL f32On64 = m_dlgAdvDep.m_f32On64;
    BOOL fIncludeOLEInfo = m_dlgAdvDep.m_fIncludeOLEInfo;

    m_dlgAdvDep.m_szScriptName = m_pData->m_pDetails->pInstallInfo->pszScriptPath;

    if (IDOK == m_dlgAdvDep.DoModal())
    {
        if (fIgnoreLCID != m_dlgAdvDep.m_fIgnoreLCID
            || fInstallOnAlpha != m_dlgAdvDep.m_fInstallOnAlpha
            || fUninstallUnmanaged != m_dlgAdvDep.m_fUninstallUnmanaged
            || f32On64 != m_dlgAdvDep.m_f32On64
            || fIncludeOLEInfo != m_dlgAdvDep.m_fIncludeOLEInfo)
        {
            if (!m_fPreDeploy)
                SetModified();
        }
    }
}

void CDeploy::OnDisable()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fAutoInst = FALSE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnPublished()
{
    if (!m_fPreDeploy)
        SetModified();
    GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
    GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnAssigned()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fAutoInst = TRUE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
    GetDlgItem(IDC_CHECK4)->EnableWindow(TRUE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnChanged()
{
    if (!m_fPreDeploy)
        SetModified();
}


LRESULT CDeploy::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        m_dlgAdvDep.EndDialog(IDCANCEL);
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CDeploy::RefreshData(void)
{
    DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;
    m_fAutoInst = (0 != (dwActFlags & ACTFLG_OnDemandInstall));
    m_fNotUserInstall = (0 == (dwActFlags & ACTFLG_UserInstall));
    m_fFullInst = (0 != (dwActFlags & ACTFLG_InstallUserAssign));

    if (dwActFlags & ACTFLG_Assigned)
    {
        m_iDeployment = 1;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
        // Only enable full assign checkbox when an app is
        // assigned and not legacy.  And only enable this
        // when we're in USER mode.
        // Of course .ZAP (legacy) packages can't be assigned
        // anyway so we don't actually need to check for that.
        GetDlgItem(IDC_CHECK4)->EnableWindow( m_fMachine == FALSE);
    }
    else if (dwActFlags & ACTFLG_Published)
    {
        m_iDeployment = 0;
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    else
    {
        m_iDeployment = 2;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    if (this->m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }

    if (dwActFlags & ACTFLG_UninstallOnPolicyRemoval)
    {
        m_fUninstallOnPolicyRemoval = TRUE;
    }
    else
    {
        m_fUninstallOnPolicyRemoval = FALSE;
    }

    // initialize the state flags for the advanced dialog
    m_dlgAdvDep.m_szDeploymentCount.Format(TEXT("%u"), m_pData->m_pDetails->pInstallInfo->dwRevision);
    OLECHAR szTemp[80];
    StringFromGUID2(m_pData->m_pDetails->pInstallInfo->ProductCode,
                    szTemp,
                    sizeof(szTemp) / sizeof(szTemp[0]));
    m_dlgAdvDep.m_szProductCode = szTemp;
    m_dlgAdvDep.m_f32On64 = ((dwActFlags & ACTFLG_ExcludeX86OnWin64) == ACTFLG_ExcludeX86OnWin64);

    if (m_pData->m_pDetails->pInstallInfo->PathType != SetupNamePath)
    {
        // this is not a legacy app
        // reverse the sense of m_f32On64
        m_dlgAdvDep.m_f32On64 = !m_dlgAdvDep.m_f32On64;
    }

    if (dwActFlags & ACTFLG_UninstallUnmanaged)
    {
        m_dlgAdvDep.m_fUninstallUnmanaged = TRUE;
    }
    else
    {
        m_dlgAdvDep.m_fUninstallUnmanaged = FALSE;
    }

    m_dlgAdvDep.m_fInstallOnAlpha = FALSE;

    m_dlgAdvDep.m_fIncludeOLEInfo = m_pData->m_pDetails->pActInfo->bHasClasses;

    if (dwActFlags & ACTFLG_IgnoreLanguage)
    {
        m_dlgAdvDep.m_fIgnoreLCID = TRUE;
    }
    else
    {
        m_dlgAdvDep.m_fIgnoreLCID = FALSE;
    }

    switch (m_pData->m_pDetails->pInstallInfo->InstallUiLevel)
    {
    case INSTALLUILEVEL_FULL:
        m_iUI = 1;
        break;
    case INSTALLUILEVEL_BASIC:
    default:
        m_iUI = 0;
        break;
    }

    SetModified(FALSE);
}

void CDeploy::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_DEPLOYMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\dplapp.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       DplApp.h
//
//  Contents:   app deployment dialog
//
//  Classes:    CDeployApp
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog

class CDeployApp : public CDialog
{
// Construction
public:
        CDeployApp(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CDeployApp)
        enum { IDD = IDD_DEPLOY_APP_DIALOG };
        int             m_iDeployment;
        BOOL    m_fMachine;
        BOOL    m_fCrappyZaw;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CDeployApp)
    protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CDeployApp)
        virtual BOOL OnInitDialog();
        afx_msg void OnCustom();
        afx_msg void OnAssigned();
        afx_msg void OnPublished();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\deploy.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Deploy.h
//
//  Contents:   deployment property page
//
//  Classes:    CDeploy
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDeploy dialog

class CDeploy : public CPropertyPage
{
        DECLARE_DYNCREATE(CDeploy)

// Construction
public:
        CDeploy();
        ~CDeploy();

        CDeploy **      m_ppThis;

// Dialog Data
        //{{AFX_DATA(CDeploy)
        enum { IDD = IDD_DEPLOYMENT };
        BOOL    m_fAutoInst;
        BOOL    m_fFullInst;
        int             m_iUI;
        int             m_iDeployment;
        BOOL    m_fUninstallOnPolicyRemoval;
        BOOL    m_fNotUserInstall;
        CString         m_szInitialPackageName;
        //}}AFX_DATA
        CAppData *      m_pData;
        CScopePane *    m_pScopePane;
        IClassAdmin *   m_pIClassAdmin;
#if 0
        LPGPEINFORMATION m_pIGPEInformation;
#endif
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fPreDeploy;
        BOOL            m_fMachine;
        BOOL            m_fRSOP;
        CAdvDep         m_dlgAdvDep;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CDeploy)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CDeploy)
        virtual BOOL OnInitDialog();
        afx_msg void OnDisable();
        afx_msg void OnAdvanced();
        afx_msg void OnPublished();
        afx_msg void OnAssigned();
        afx_msg void OnChanged();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\error.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       error.h
//
//  Contents:   Faild Settings property sheet
//
//  Classes:    CErrorInfo
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CErrorInfo dialog

class CErrorInfo : public CPropertyPage
{
        DECLARE_DYNCREATE(CErrorInfo)

// Construction
public:
        CErrorInfo();
        ~CErrorInfo();
        CErrorInfo ** m_ppThis;
        CAppData * m_pData;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CErrorInfo)
        enum { IDD = IDD_ERRORINFO };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CErrorInfo)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CErrorInfo)
        afx_msg void OnSaveAs();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\error.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       error.cpp
//
//  Contents:   Digital Signitures property page
//
//  Classes:    CErrorInfo
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CErrorInfo property page

IMPLEMENT_DYNCREATE(CErrorInfo, CPropertyPage)

CErrorInfo::CErrorInfo() : CPropertyPage(CErrorInfo::IDD)
{
        //{{AFX_DATA_INIT(CErrorInfo)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CErrorInfo::~CErrorInfo()
{
    *m_ppThis = NULL;
}

void CErrorInfo::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CErrorInfo)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorInfo, CPropertyPage)
        //{{AFX_MSG_MAP(CErrorInfo)
        ON_BN_CLICKED(IDC_BUTTON1, OnSaveAs)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorInfo message handlers

void CErrorInfo::OnSaveAs()
{
    OPENFILENAME ofn;
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_TEXT_DEF_EXT);
    szFilter.LoadString(IDS_TEXT_EXT_FILT);
    LPTSTR lpTemp;
    TCHAR szFile[2*MAX_PATH];
    HANDLE hFile;
    DWORD dwSize, dwBytesWritten;

    //
    // Call the Save common dialog
    //

    szFile[0] = TEXT('\0');
    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = szFilter;
    lpTemp = (LPTSTR)ofn.lpstrFilter;
    int iBreak = 0;
    while (lpTemp[iBreak])
    {
        if (lpTemp[iBreak] == TEXT('|'))
        {
            lpTemp[iBreak] = 0;
        }
        iBreak++;
    }
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrDefExt = szExtension;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    if (!GetSaveFileName (&ofn))
    {
        return;
    }


    CHourglass hourglass;

    //
    // Create the text file
    //

    hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: CreateFile failed with %d"), GetLastError()));
        return;
    }


    //
    // Get the text out of the edit control
    //
    dwSize = (DWORD) SendDlgItemMessage (IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);

    lpTemp = (LPTSTR) LocalAlloc (LPTR, (dwSize+2) * sizeof(TCHAR));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: LocalAlloc failed with %d"), GetLastError()));
        CloseHandle (hFile);
        return;
    }

    SendDlgItemMessage (IDC_EDIT1, WM_GETTEXT, (dwSize+1), (LPARAM) lpTemp);



    //
    // Save it to the new file
    //

    if (!WriteFile (hFile, lpTemp, (dwSize * sizeof(TCHAR)), &dwBytesWritten, NULL) ||
        (dwBytesWritten != (dwSize * sizeof(TCHAR))))
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: WriteFile failed with %d"),
                 GetLastError()));
    }


    LocalFree (lpTemp);
    CloseHandle (hFile);
}

BOOL CErrorInfo::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    RefreshData();
    return TRUE;
}

BOOL CErrorInfo::OnApply()
{
    return CPropertyPage::OnApply();
}


LRESULT CErrorInfo::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CErrorInfo::RefreshData(void)
{
    CString szTime = L"";
    BSTR bstr = SysAllocString(m_pData->m_szEventTime);
    if (bstr)
    {
        CStringFromWBEMTime(szTime, bstr, FALSE);
        SysFreeString(bstr);
    }

    CEdit * pEd = (CEdit *) GetDlgItem(IDC_EDIT1);
    pEd->Clear();
    CString sz;
    sz.Format(TEXT("%s\r\n\r\n%s"),
              szTime,
              m_pData->m_szEventLogText);

    pEd->ReplaceSel(sz);
    SetModified(FALSE);
}

void CErrorInfo::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_ERRORINFO);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\edtstr.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       EdtStr.cpp
//
//  Contents:   simple string edit dialog
//
//  Classes:    CEditString
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditString dialog


CEditString::CEditString(CWnd* pParent /*=NULL*/)
        : CDialog(CEditString::IDD, pParent)
{
        //{{AFX_DATA_INIT(CEditString)
        m_sz = _T("");
        m_szTitle = _T("");
        //}}AFX_DATA_INIT
}


void CEditString::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CEditString)
        DDX_Text(pDX, IDC_EDIT1, m_sz);
	DDV_MaxChars(pDX, m_sz, 40);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditString, CDialog)
        //{{AFX_MSG_MAP(CEditString)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditString message handlers

BOOL CEditString::OnInitDialog()
{
        CDialog::OnInitDialog();

        SetWindowText(m_szTitle);
        // TODO: Add extra initialization here

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CEditString::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_EDITSTRING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\edtstr.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       EdtStr.h
//
//  Contents:   a simple string edit dialog box
//
//  Classes:    CEditString
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
#define AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CEditString dialog

class CEditString : public CDialog
{
// Construction
public:
        CEditString(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CEditString)
        enum { IDD = IDD_EDITSTRING };
        CString m_sz;
        CString m_szTitle;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CEditString)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CEditString)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\lcidpick.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       lcidpick.cpp
//
//  Contents:   locale picker dialog
//
//  Classes:    CLcidPick
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog


CLcidPick::CLcidPick(CWnd* pParent /*=NULL*/)
        : CDialog(CLcidPick::IDD, pParent)
{
        //{{AFX_DATA_INIT(CLcidPick)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CLcidPick::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLcidPick)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLcidPick, CDialog)
        //{{AFX_MSG_MAP(CLcidPick)
        ON_BN_CLICKED(IDC_BUTTON1, OnRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLcidPick message handlers

void CLcidPick::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        pList->DeleteString(iSel);
        set<LCID>::iterator i = m_psLocales->begin();
        while (iSel--)
        {
            i++;
        }
        m_psLocales->erase(*i);
    }
}

BOOL CLcidPick::OnInitDialog()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    TCHAR szBuffer[256];

    // for every item in m_psLocales
    set<LCID>::iterator i;
    for (i = m_psLocales->begin(); i != m_psLocales->end(); i++)
    {
        // UNDONE - convert to a human readable string (not a number)
        CString sz;
        GetLocaleInfo(*i, LOCALE_SLANGUAGE, szBuffer, 256);
        sz += szBuffer;
#ifdef SHOWCOUNTRY
        sz += _T(" - ");
        GetLocaleInfo(*i, LOCALE_SCOUNTRY, szBuffer, 256);
        sz += szBuffer;
#endif
        pList->AddString(sz);
    }

    CDialog::OnInitDialog();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CLcidPick::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CLcidPick::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_LOCALE_PICKER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\fileext.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FileExt.cpp
//
//  Contents:   file extension property page
//
//  Classes:    CFileExt
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileExt property page

IMPLEMENT_DYNCREATE(CFileExt, CPropertyPage)

CFileExt::CFileExt() : CPropertyPage(CFileExt::IDD)
{
        //{{AFX_DATA_INIT(CFileExt)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
}

CFileExt::~CFileExt()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CFileExt::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CFileExt)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileExt, CPropertyPage)
        //{{AFX_MSG_MAP(CFileExt)
        ON_BN_CLICKED(IDC_BUTTON1, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON2, OnMoveDown)
        ON_CBN_SELCHANGE(IDC_COMBO1, OnExtensionChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileExt message handlers

void CFileExt::OnMoveUp()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i > 0)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i-1];
        Ext.v[i-1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i, sz);
        pList->DeleteString(i);
        pList->InsertString(i-1, sz);
        pList->SetCurSel(i-1);
        SetModified();
    }
}

void CFileExt::OnMoveDown()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i < pList->GetCount()-1)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i+1];
        Ext.v[i+1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i+1, sz);
        pList->DeleteString(i+1);
        pList->InsertString(i, sz);
        pList->SetCurSel(i+1);
        SetModified();
    }
}

void CFileExt::OnExtensionChanged()
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    CString szExt;
    pCombo->GetLBText(pCombo->GetCurSel(), szExt);
    pList->ResetContent();
    pList->SetHorizontalExtent(0);
    if (szExt.IsEmpty())
    {
        return; // nothing to do if there are no entries
    }

    // First check to see if we already have set up our own data for this extension.
    if (m_Extensions.end() == m_Extensions.find(szExt))
    {
        // need to set up our list
        EXT Ext;
        Ext.fDirty = FALSE;

        EXTLIST::iterator i;
        EXTLIST & ExtList = m_pScopePane->m_Extensions[szExt];
        for (i = ExtList.begin(); i != ExtList.end(); i++)
        {
            EXTEL ExtEl;
            ExtEl.lCookie = *i;

            // look for the entry that matches this file extension
            CAppData & data = m_pScopePane->m_AppData[*i];
            UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == szExt.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            ExtEl.lPriority = data.m_pDetails->pActInfo->prgPriority[n2];
            Ext.v.push_back(ExtEl);
        }
        order_EXTEL func;
        sort(Ext.v.begin(), Ext.v.end(), func);
        m_Extensions[szExt] = Ext;
    }
    vector<EXTEL>::iterator i;
    EXT & Ext = m_Extensions[szExt];
    for (i = Ext.v.begin(); i != Ext.v.end(); i++)
    {
        CString sz = m_pScopePane->m_AppData[i->lCookie].m_pDetails->pszPackageName;
        pList->AddString(sz);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(sz);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
    }
    pList->SetCurSel(0);
    int n = pList->GetCount();
    GetDlgItem(IDC_BUTTON1)->EnableWindow(n > 1);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 1);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

BOOL CFileExt::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CFileExt::OnApply()
{
    HRESULT hr = S_OK;
    map <CString, EXT>::iterator iExt;
    // walk the list looking for dirty entries
    for (iExt = m_Extensions.begin(); iExt != m_Extensions.end(); iExt++)
    {
        if (iExt->second.fDirty)
        {
            ULONG uPriority = iExt->second.v.size();
            vector<EXTEL>::iterator i;
            for (i = iExt->second.v.begin(); i != iExt->second.v.end(); i++)
            {
                CAppData & data = m_pScopePane->m_AppData[i->lCookie];
                CString sz = data.m_pDetails->pszPackageName;
                ASSERT(m_pIClassAdmin);
                hr = m_pIClassAdmin->SetPriorityByFileExt((LPOLESTR)((LPCOLESTR)sz), (LPOLESTR)((LPCOLESTR)iExt->first), --uPriority);

                // look for the entry that matches this file extension
                UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
                while (n2--)
                {
                    if (0 == iExt->first.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                    {
                        break;
                    }
                }
                data.m_pDetails->pActInfo->prgPriority[n2] = uPriority;
            }
            iExt->second.fDirty = FALSE;
        }
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    return CPropertyPage::OnApply();
}


LRESULT CFileExt::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CFileExt::RefreshData(void)
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    pCombo->ResetContent();
    if (m_pIClassAdmin)
    {
        // only populate the extension list when we have an IClassAdmin interface
        map <CString, EXTLIST>::iterator iExt;
        for (iExt=m_pScopePane->m_Extensions.begin(); iExt != m_pScopePane->m_Extensions.end(); iExt++)
        {
            pCombo->AddString(iExt->first);
        }
    }
    pCombo->SetCurSel(0);
    // clear the record of extension changes
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // and populate the list box
    SetModified(FALSE);

    OnExtensionChanged();
}


void CFileExt::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FILE_EXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\lcidpick.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       lcidpick.h
//
//  Contents:   locale picker dialog (used to choose which of a set of
//              locales an app should be deployed in)
//
//  Classes:    CLcidPick
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog

class CLcidPick : public CDialog
{
// Construction
public:
        CLcidPick(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CLcidPick)
        enum { IDD = IDD_LOCALE_PICKER };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA
        set<LCID> * m_psLocales;


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CLcidPick)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CLcidPick)
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\locpkg.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LocPkg.cpp
//
//  Contents:   locale - platform property page
//
//  Classes:    CLocPkg
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocPkg property page

IMPLEMENT_DYNCREATE(CLocPkg, CPropertyPage)

CLocPkg::CLocPkg() : CPropertyPage(CLocPkg::IDD)
{
        //{{AFX_DATA_INIT(CLocPkg)
        m_fWin64 = FALSE;
        m_fX86 = FALSE;
        m_ProcessorArch = PROCESSOR_ARCHITECTURE_IA64;
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
}

CLocPkg::~CLocPkg()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CLocPkg::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLocPkg)
        DDX_Check(pDX, IDC_CHECK1, m_fWin64);
        DDX_Check(pDX, IDC_CHECK2, m_fX86);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLocPkg, CPropertyPage)
        //{{AFX_MSG_MAP(CLocPkg)
        ON_BN_CLICKED(IDC_CHECK1, OnChange)
        ON_BN_CLICKED(IDC_CHECK2, OnChange)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocPkg message handlers

BOOL CLocPkg::OnApply()
{
    PLATFORMINFO * pPlatformInfo = m_pData->m_pDetails->pPlatformInfo;
    UINT i = 0;
    if (m_fX86)
    {
        i++;
    }
    if (m_fWin64)
    {
        i++;
    }
    if (i == 0)
    {
        CString szTitle;
        szTitle.LoadString(IDS_BADDATA);
        CString szText;
        szText.LoadString(IDS_PLATFORMREQUIRED);
        MessageBox(szText, szTitle, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    m_pData->m_pDetails->pPlatformInfo = new PLATFORMINFO;
    m_pData->m_pDetails->pPlatformInfo->cPlatforms = i;
    m_pData->m_pDetails->pPlatformInfo->prgPlatform = new CSPLATFORM[i];
    m_pData->m_pDetails->pPlatformInfo->cLocales = pPlatformInfo->cLocales;
    m_pData->m_pDetails->pPlatformInfo->prgLocale = pPlatformInfo->prgLocale;
    i = 0;
    if (m_fX86)
    {
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = PROCESSOR_ARCHITECTURE_INTEL;
        i++;
    }
    if (m_fWin64)
    {
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = m_ProcessorArch;
    }
    HRESULT hr = S_OK;
#if 0
    hr = m_pIClassAdmin->UpgradePackage(m_pData->m_pDetails->pszPackageName,
                                                m_pData->m_pDetails);
    if (FAILED(hr))
    {
        PLATFORMINFO * pTemp = m_pData->m_pDetails->pPlatformInfo;
        m_pData->m_pDetails->pPlatformInfo = pPlatformInfo;
        pPlatformInfo = pTemp;
    }
    else
        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
#endif
    delete [] pPlatformInfo->prgPlatform;
    delete pPlatformInfo;
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(sz, hr);
        return FALSE;
    }
    SetModified(FALSE);
    return CPropertyPage::OnApply();
}

BOOL CLocPkg::OnInitDialog()
{
    UINT i;
    for (i = m_pData->m_pDetails->pPlatformInfo->cPlatforms; i--;)
    {
        switch (m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            m_fX86 = TRUE;
            break;
        case PROCESSOR_ARCHITECTURE_AMD64:
            m_ProcessorArch = PROCESSOR_ARCHITECTURE_AMD64;
            m_fWin64 = TRUE;
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            m_ProcessorArch = PROCESSOR_ARCHITECTURE_IA64;
            m_fWin64 = TRUE;
            break;
        default:
            break;
        }
    }
    TCHAR szBuffer[256];
    CString sz;
    i = 0;
    while (i < m_pData->m_pDetails->pPlatformInfo->cLocales)
    {
        GetLocaleInfo(m_pData->m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
        sz = szBuffer;
#ifdef SHOWCOUNTRY
        GetLocaleInfo(m_pData->m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
        sz += _T(" - ");
        sz += szBuffer;
#endif
        i++;
        ((CListBox *)GetDlgItem(IDC_LIST1))->AddString(sz);
    }

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CLocPkg::OnChange()
{
    SetModified();
}

LRESULT CLocPkg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CLocPkg::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_LOCALE_PACKAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\locpkg.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LocPkg.h
//
//  Contents:   local and deployment platform property page
//
//  Classes:    CLocPkg
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CLocPkg dialog

class CLocPkg : public CPropertyPage
{
        DECLARE_DYNCREATE(CLocPkg)

// Construction
public:
        CLocPkg();
        ~CLocPkg();

        CLocPkg ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CLocPkg)
        enum { IDD = IDD_LOCALE_PACKAGE };
        BOOL    m_fWin64;
        BOOL    m_fX86;
        DWORD   m_ProcessorArch;
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CLocPkg)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CLocPkg)
        virtual BOOL OnInitDialog();
        afx_msg void OnChange();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\fileext.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FileExt.h
//
//  Contents:   file extension property sheet
//
//  Classes:    CFileExt
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef struct tagEXTEL
{
    long lCookie;
    long lPriority;
} EXTEL;

typedef struct tagEXT
{
    vector<EXTEL> v;
    bool              fDirty;
} EXT;

// Comparitor used to sort the vector of EXTEL elements.
// This ensures that the item with the highest priority is put at the top of
// the list.
class order_EXTEL : public binary_function <const EXTEL&, const EXTEL&, bool>
{
public:
    bool operator () (const EXTEL& a, const EXTEL& b) const
    {
        return a.lPriority > b.lPriority;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CFileExt dialog

class CFileExt : public CPropertyPage
{
        DECLARE_DYNCREATE(CFileExt)

// Construction
public:
        CFileExt();
        ~CFileExt();
        CScopePane * m_pScopePane;
        map<CString, EXT> m_Extensions;
        IClassAdmin *   m_pIClassAdmin;

        CFileExt ** m_ppThis;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CFileExt)
        enum { IDD = IDD_FILE_EXT };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CFileExt)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CFileExt)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnExtensionChanged();
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\msiclass.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msiclass.h
//
//  Contents:   msi class collection abstraction
//
//  Classes:
//
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#if !defined(__MSICLASS_H__)
#define __MSICLASS_H__

//
// MSI Tables containing classes
//
#define TABLE_FILE_EXTENSIONS L"Extension"
#define TABLE_CLSIDS          L"Class"
#define TABLE_PROGIDS         L"ProgId"


//
// Package metadata queries
//

//
// Property table queries -- used to find out global information about the package
//

//
// This query is used to determine the package's global install level
//
#define QUERY_INSTALLLEVEL                L"SELECT DISTINCT `Value` FROM `Property` WHERE `Property`=\'INSTALLLEVEL\'"

// This query is used to determine the package's friendly name
//
#define QUERY_FRIENDLYNAME                L"SELECT DISTINCT `Value` FROM `Property` WHERE `Property`=\'ProductName\'"

//
// Feature table queries -- these are used to find out which features will be
// advertised so that we can later determine if the classes associated with the
// features should be advertised
//

//
// This query is less a query and more a modification operation.  It adds an additional
// temporary "_IsAdvertised" column to the table.  We use this to perform joins in
// subsequent queries.
//
#define QUERY_ADVERTISED_FEATURES_CREATE  L"ALTER TABLE `Feature` ADD `_IsAdvertised` INT TEMPORARY HOLD"

//
// Again, this query really serves as a modification operation.  This one initializes the
// temporary "_IsAdvertised" column to 0, which in our parlance is the same as initializing
// the column to "not advertised."
//
#define QUERY_ADVERTISED_FEATURES_INIT    L"UPDATE `Feature` SET `_IsAdvertised`=0"

//
// This is a conventional query -- this returns all the features in the package
//
#define QUERY_ADVERTISED_FEATURES_RESULT  L"SELECT `Feature`, `Level`, `Attributes` FROM `Feature`"

//
// Another modification query -- this eliminates the temporary changes (the additional
// column) we made to the table in the create query.
//
#define QUERY_ADVERTISED_FEATURES_DESTROY L"ALTER TABLE `Feature` FREE"

//
// The last modification query -- this allows us to set a particular feature's "_IsAdvertised"
// column to 1, which will indicate that the feature should be advertised.
//
#define QUERY_FEATURES_SET                L"UPDATE `Feature` SET `_IsAdvertised`=1 WHERE `Feature`=?"

//
// Classes queries -- retrieves file extensions, clsid's, and progid's of the package
//


//
// The rest of these queries are straightforward "read-only" queries.  They are all joins
// to the feature table, requiring that the feature table's "_IsAdvertised" property
// is set to the advertised state (1).  Thus, these queries will only give us classes that
// should be advertised
//

//
// File extensions query
//
#define QUERY_EXTENSIONS                  L"SELECT DISTINCT `Extension` FROM `Extension`, `Feature` WHERE `Extension` IS NOT NULL "  \
                                          L"AND `Extension`.`Feature_`=`Feature`.`Feature` AND `Feature`.`_IsAdvertised`=1"

//
// Clsid query
//
#define QUERY_CLSIDS                      L"SELECT DISTINCT `CLSID`, `Context`, `Component`.`Attributes` FROM `Class`, `Feature`, " \
                                          L"`Component` WHERE `CLSID` IS NOT NULL AND `Class`.`Feature_`=`Feature`.`Feature` "    \
                                          L"AND `Feature`.`_IsAdvertised`=1 AND `Component`.`Component`=`Class`.`Component_`"

//
// ProgId query
//
#define QUERY_VERSION_INDEPENDENT_PROGIDS L"SELECT DISTINCT `ProgId`,`CLSID` FROM `ProgId`, `Class`, `Feature` WHERE `ProgId` IS NOT NULL " \
                                          L"AND `ProgId`.`Class_`=`Class`.`CLSID` AND `Class`.`Feature_`=`Feature`.`Feature` "       \
                                          L"AND `Feature`.`_IsAdvertised`=1"

//
// COM clsctx values as they are stored in the package's class (clsid) table
//
#define COM_INPROC_CONTEXT        L"InprocServer32"
#define COM_INPROCHANDLER_CONTEXT L"InprocHandler32"
#define COM_LOCALSERVER_CONTEXT   L"LocalServer32"
#define COM_REMOTESERVER_CONTEXT  L"RemoteServer"

//
// MSI attribute flags
//
#define MSI_64BIT_CLASS      msidbComponentAttributes64bit
#define MSI_DISABLEADVERTISE msidbFeatureAttributesDisallowAdvertise

#define CLASS_ALLOC_SIZE 256

//
// Indices of colums for each read-only query
//

enum
{
    PROPERTY_COLUMN_VALUE = 1
};

enum
{
    FEATURE_COLUMN_FEATURE = 1,
    FEATURE_COLUMN_LEVEL,
    FEATURE_COLUMN_ATTRIBUTES
};

enum
{
    EXTENSION_COLUMN_EXTENSION = 1
};

enum
{
    CLSID_COLUMN_CLSID = 1,
    CLSID_COLUMN_CONTEXT,
    CLSID_COLUMN_ATTRIBUTES
};


enum
{
    PROGID_COLUMN_PROGID = 1,
    PROGID_COLUMN_CLSID
};

enum
{
    TYPE_EXTENSION,
    TYPE_CLSID,
    TYPE_PROGID,
    TYPE_COUNT
};


//
// Structure describing where to write an atom
// of class information.  It is also used as
// an intermediate scratch pad by CClassCollection
// in between private method calls to keep track
// of when and where to allocate new memory
// for retrieved classes.
//
struct DataDestination
{
    DataDestination(
        DWORD  dwType,
        void** prgpvDestination,
        UINT*  pcCurrent,
        UINT*  pcMax);

    DWORD  _cbElementSize;
    UINT*  _pcCurrent;
    UINT*  _pcMax;

    void** _ppvData;
};


//
// Class that uses queries to create a collection of
// a package's class data
//
class CClassCollection
{
public:

    CClassCollection( PACKAGEDETAIL* pPackageDetail );

    HRESULT
    GetClasses( BOOL bFileExtensionsOnly );

private:

    LONG
    GetClsids();

    LONG
    GetProgIds();

    LONG
    GetExtensions();

    LONG
    GetElements(
        DWORD            dwType,
        DataDestination* pDestination);

    LONG
    FlagAdvertisableFeatures();

    LONG
    RemoveAdvertisableFeatureFlags();

    LONG
    GetInstallLevel();

    LONG
    GetFriendlyName();

    LONG
    GetFeatureAdvertiseState(
        CMsiRecord* pFeatureRecord,
        BOOL*       pbAdvertised );


    LONG
    AddElement(
        void*            pvDataSource,
        DataDestination* pDataDestination);

    LONG
    ProcessElement(
        DWORD            dwType,
        CMsiRecord*      pRecord,
        DataDestination* pDataDestination);

    LONG
    ProcessExtension(
        CMsiRecord*      pRecord,
        WCHAR**          ppwszExtension);

    LONG
    ProcessClsid(
        CMsiRecord*      pRecord,
        CLASSDETAIL*     pClsid,
        BOOL*            pbIgnoreClsid);

    LONG
    ProcessProgId(
        CMsiRecord*      pRecord,
        DataDestination* pDataDestination,
        WCHAR**          ppwszProgId);

    LONG
    FindClass(
        WCHAR*        wszClsid,
        CLASSDETAIL** ppClass );

    void
    FreeClassDetail( CLASSDETAIL* pClass );

    CMsiDatabase    _Database;

    PACKAGEDETAIL*  _pPackageDetail;

    DWORD           _cMaxClsids;
    DWORD           _cMaxExtensions;

    UINT            _InstallLevel;

    static WCHAR*   _wszQueries[ TYPE_COUNT ];
};

#endif // __MSICLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\msibase.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msibase.h
//
//  Contents:   msi database abstractions
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#if !defined(__MSIBASE_H__)
#define __MSIBASE_H__


//
//  Module Notes
//
//  Class Relational Overview
//
//  Below we describe how the classes declared in this module
//  relate to each other -- the --> notation indicates the "yields" relation:
//
//  - A path to an MSI package --> CMsiDatabase: A path to an MSI package, along
//      with a set of transforms, can be used to instantiate a CMsiDatabase
//      object that abstracts the package with a database style view.
//
//  - CMsiDatabase --> CMsiQuery: a CMsiDatabase allows one to retrieve
//      queries against the database (MSI package).
//
//  - CMsiQuery --> CMsiRecord: a CMsiQuery allows one to retrieve or
//      alter records that are part of the results of the msi database query.
//
//  - CMsiRecord --> CMsiValue: a CMsiValue allows the retrieval of
//      individual values of an MSI database record.
//
//  -CMsiState is a base class for the classes above that maintain
//      MSI database engine state (e.g. msi handles) -- this class
//      has no direct utility to classes outside this module
//
//-------------------------------------------------------------------------------------
//
//  Class sequential Overview:
//
//  The following sequence is typical of the use of the classes envisioned
//  in the design of this module:
//
//  1.  CMsiDatabase: Instantiate a CMsiDatabase object, and call its Open method
//      in order to get a database view of a particular package.
//  2.  CMsiQuery: Use the GetQueryResults method to place the results of a query into
//      a CMsiQuery which was passed into the call as an out parameter,
//      or use the OpenQuery method to start a query without retrieving results
//      immediately (they can be retrieved later).  The latter is useful
//      when performing queries that need to update a single record -- you
//      use OpenQuery with a query string that allows the results records to be changed,
//      then call the UpdateQueryFromFilter method of CMsiQuery in order to
//      alter a record.
//  3.  CMsiRecord: Use the GetNextRecord methods of CMsiQuery to retrieve a 
//      CMsiRecord that represents a record from the query.
//  4.  CMsiValue: Use the GetValue method of CMsiRecord to retrieve a particular
//      value of the msi record.
//
//
//  For information on the individual methods of each class, please see the source
//  file where the methods are implemented.
//



#if defined(DBG)
#define DEFAULT_STRING_SIZE 16
#else // defined(DBG)
#define DEFAULT_STRING_SIZE 256
#endif // defined(DBG)


//+--------------------------------------------------------------------------
//
//  Class: CMsiState
//
//  Synopsis: class that encapsulates an msi handle.  It ensures that
//      the handle is freed when instances of the class are destroyed.
//
//  Notes: this class is generally only needed by classes in this module --
//      it has no useful methods for classes outside this module
//
//---------------------------------------------------------------------------
class CMsiState
{
public:
    
    CMsiState();
    ~CMsiState();

    void
    SetState( MSIHANDLE pMsiHandle );

    MSIHANDLE
    GetState();

private:

    MSIHANDLE _MsiHandle;
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiValue
//
//  Synopsis: Class that encapsulates values that can be returned by
//      a record of an msi database.  It ensures that resources (e.g. memory)
//      associated with instances of the class are freed when the class is
//      destroyed. It also attempts to avoid heap allocation in favor of
//      stack allocation when possible -- this is abstracted from the consumer
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the Set methods of this class.
//      4. The caller may then use Get methods to retrieve the value
//         in a useful form (such as DWORD or WCHAR*).
//
//---------------------------------------------------------------------------
class CMsiValue
{
public:
    
    enum
    {
        TYPE_NOT_SET,
        TYPE_DWORD,
        TYPE_STRING
    };
        
    CMsiValue();
    ~CMsiValue();

    DWORD
    GetDWORDValue();

    WCHAR*
    GetStringValue(); 

    DWORD
    GetStringSize();

    WCHAR*
    DuplicateString();

    void
    SetDWORDValue( DWORD dwValue );
 
    LONG
    SetStringValue( WCHAR* wszValue );
        
    LONG
    SetStringSize( DWORD cchSize );        

    void
    SetType( DWORD dwType );

private:
    
    WCHAR  _wszDefaultBuf[DEFAULT_STRING_SIZE];

    DWORD  _dwDiscriminant;

    WCHAR* _wszValue;
    DWORD  _cchSize;

    DWORD  _dwValue;
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiRecord
//
//  Synopsis: Class that encapsulates msi database records.  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the SetState method of this class.
//      4. The caller may then use the GetValue method to retrieve individual
//         values of the record, which in turn may be converted into
//         concrete data types (see the CMsiValue class).
//
//---------------------------------------------------------------------------
class CMsiRecord : public CMsiState
{
public:

    LONG        
    GetValue( 
	DWORD      dwType,
        DWORD      dwValue,
	CMsiValue* pMsiValue);
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiQuery
//
//  Synopsis: Class that encapsulates msi database queries.  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the SetState method of this class.
//      4. The caller may then use the GetNextRecord method to retrieve a
//         record from the results of the query, or use the 
//         UpdateQueryFromFilter method to alter one of the records in
//         the query.
//
//---------------------------------------------------------------------------
class CMsiQuery : public CMsiState
{
public:

    LONG
    GetNextRecord( CMsiRecord* pMsiRecord );

    LONG
    UpdateQueryFromFilter( CMsiRecord* pFilterRecord );
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiDatabase
//
//  Synopsis: Class that an msi database (package).  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//  1. Create an instance of this class
//  2. Use the Open method to gain access to a package + set of transforms
//     as a database that can be queried
//  3. To create and retrieve results of a query on an opened database,
//     Use the GetQueryResults method
//  4. To create a query (but not retrieve its results), use the OpenQuery
//     method.  This is useful with when the query's UpdateQueryFromFilter
//     method is used to change an individual record, rather than retrieving
//     a result set (a la GetQueryResults).
//
//---------------------------------------------------------------------------
class CMsiDatabase : public CMsiState
{
public:

    LONG
    Open(
        WCHAR*  wszPath,
        DWORD   cTransforms,
        WCHAR** rgwszTransforms);

    LONG
    GetQueryResults(
        WCHAR*     wszQuery,
        CMsiQuery* pQuery );

    LONG
    OpenQuery(
        WCHAR*     wszQuery,
        CMsiQuery* pQuery);

    LONG
    TableExists( 
        WCHAR* wszTableName,
        BOOL*  pbTableExists );

};


#endif // __MSIBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\msibase.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msibase.cpp
//
//  Contents:   msi database abstractions
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"


CMsiState::CMsiState() :
    _MsiHandle( NULL )
{
    //
    // The MSIHANDLE encapsulates the state for
    // all msi operations / data -- clearing this
    // member is akin to clearing the state.
    //
}

CMsiState::~CMsiState()
{
    //
    // The lifetime of the object is the lifetime
    // of the underlying state -- be sure to release it
    //
    MsiCloseHandle( _MsiHandle );
}

void
CMsiState::SetState( MSIHANDLE MsiHandle )
{
    //
    // Set the state of this object based on
    // a handle retrieved from an MSI operation --
    // note that this should only be done if this
    // object has an empty state
    //
    ASSERT( ! _MsiHandle );

    _MsiHandle = MsiHandle;
}

MSIHANDLE
CMsiState::GetState()
{
    //
    // Allow callers that need to perform explicit MSI
    // operations to retrieve state compatible with MSI
    //
    return _MsiHandle;
}


CMsiValue::CMsiValue() :
    _dwDiscriminant( TYPE_NOT_SET ),
    _wszValue( NULL ),
    _cchSize( sizeof( _wszDefaultBuf ) / sizeof( *_wszDefaultBuf ) )
{
    //
    // The goal of this initialization is to set this object to
    // an "empty" state -- consumers must explicitly invoke methods
    // on this object to alter this condition so that Get methods
    // will succeed.
    //
}

CMsiValue::~CMsiValue()
{
    //
    // Setting the type to "none" implicitly clears our state
    // (e.g. allocated memory, any other resources)
    //
    SetType( TYPE_NOT_SET );
}

DWORD
CMsiValue::GetDWORDValue()
{
    ASSERT( TYPE_DWORD == _dwDiscriminant );

    //
    // Retrieve this value as a DWORD -- note that this
    // does not coerce non-DWORD values to DWORD -- the
    // value must already be a DWORD for this to have meaning
    //
    return _dwValue;
}


WCHAR*
CMsiValue::GetStringValue()
{
    ASSERT( TYPE_STRING == _dwDiscriminant );


    //
    // Retrieve this value as a string -- note that this
    // does not coerce non-string values to string -- the
    // value must already be a string for this to have meaning.
    // Note that the value is returned as a reference to the address
    // at which this value actually stores the string -- thus, this
    // may also be used to retrieve the value's buffer so that its
    // contents may be edited outside the strictures of this class.
    //
    return _wszValue;
}

WCHAR*
CMsiValue::DuplicateString()
{
    WCHAR* wszResult;

    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // The caller requires ownership of a duplicate
    // of this string's data.
    //

    //
    // First, allocate memory for this
    //

    ULONG ulNoChars = lstrlen ( _wszValue ) + 1;
    
    wszResult = (WCHAR*) LocalAlloc(
        0,
        sizeof(WCHAR*) * ulNoChars );

    //
    // If we successfully obtained room for the string,
    // copy it
    //
    if ( wszResult )
    {
        HRESULT hr;

        hr = StringCchCopy ( wszResult, ulNoChars, _wszValue);
        ASSERT(SUCCEEDED(hr));
    }

    return wszResult;
}

void
CMsiValue::SetDWORDValue( DWORD dwValue )
{
    //
    // This operation will implicitly set the type
    // of this value to DWORD
    //
    SetType( TYPE_DWORD );

    //
    // Now we can safely set the value
    //
    _dwValue = dwValue;
}

LONG
CMsiValue::SetStringValue( WCHAR* wszValue )
{
    DWORD cchSize;
    LONG  Status;

    Status = ERROR_SUCCESS;

    //
    // This operation will implicitly set the
    // type of this value to string
    //
    SetType( TYPE_STRING );

    //
    // We need to determine the size of this string,
    // in chars, without the null terminator, in order to
    // allow this value to represent it
    //
    cchSize = lstrlen( wszValue );

    if ( cchSize > _cchSize )
    {
        //
        // Attempt to get space for this string
        // by setting its size -- if this fails,
        // our type will be implicitly set to none
        // Here, allocating one extra byte than required.
        //
        Status = SetStringSize( cchSize );

        if ( ERROR_SUCCESS != Status )
        {
            return Status;
        }

        //
        // We have room for the string, so copy it
        // into its newly allocated space
        //

        HRESULT hr;

        hr = StringCchCopy( _wszValue, cchSize+1, wszValue );
        ASSERT(SUCCEEDED(hr));
    }

    return Status;
}

DWORD
CMsiValue::GetStringSize()
{
    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // Retrieve the size of this string in chars,
    // WITHOUT the null terminator
    //
    return _cchSize;
}

LONG
CMsiValue::SetStringSize( DWORD cchSize )
{
    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // This method only makes sense if the
    // type of this object is already string
    //

    //
    // If the requested size is less than or
    // equal to our current size, we already have
    // enough space -- we can exit now.  We do
    // not "shrink" space, only expand as necessary
    //
    if ( cchSize <= _cchSize )
    {
        return ERROR_SUCCESS;
    }

    //
    // At this point, we know we don't have enough
    // space, so we'll have to allocate it. Before we
    // do so, reset our type to none so that if we fail
    // to get space, we can indicate the indeterminate
    // state.
    //
    SetType( TYPE_NOT_SET );

    //
    // Allocate space, and include the zero terminator
    //
    _wszValue = new WCHAR [ cchSize + 1 ];

    if ( ! _wszValue )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // We are successful, remember the current size
    //
    _cchSize = cchSize;

    //
    // Change the type back to string since we can
    // safely represent a string of this size
    //
    SetType( TYPE_STRING );

    return ERROR_SUCCESS;
}

void
CMsiValue::SetType( DWORD dwType )
{
    //
    // Setting the type to a new type implicitly clears
    // state associated with the new type
    //

    //
    // If the current type and requested type are the same
    // this is a no op and we are done.
    //
    if ( dwType == _dwDiscriminant )
    {
        return;
    }

    //
    // If the requested type is string, we need to
    // set this object to have appropriate state
    //
    if ( TYPE_STRING == dwType )
    {
        //
        // If we have no space for a string
        //
        if ( ! _wszValue )
        {
            //
            // Use the default buffer...
            //
            _wszValue = _wszDefaultBuf;

            //
            // ... and set the size accordingly
            //
            _cchSize = sizeof( _wszDefaultBuf ) / sizeof( *_wszDefaultBuf );
        }

        //
        // We are done -- this object can now represent a string, though
        // at this point it must be a string of size _cchSize -- the size
        // will have to be increased through SetStringSize if there's
        // a need to represent a larger string
        //
        return;
    }

    //
    // If the current type is string, we use the fact that the requested
    // type is not string as a hint to free the state associated with
    // the string.  This is a heuristic designed to ensure that we
    // do not continue to hold memory of which we are not actively making
    // use.
    //
    if ( TYPE_STRING == _dwDiscriminant )
    {
        //
        // If the string's current storage is not that of our default
        // buffer (which is part of the object itself), we
        // release that storage as it was allocated on the heap.
        //
        if ( _wszValue != _wszDefaultBuf )
        {
            delete [] _wszValue;
            _wszValue = NULL;
        }
    }

    //
    // We may now set the type to that requested by the caller
    //
    _dwDiscriminant = dwType;
}

LONG
CMsiRecord::GetValue(
    DWORD      dwType,
    DWORD      dwValue,
    CMsiValue* pMsiValue)
{
    LONG Status = ERROR_SUCCESS;

    //
    // Values are the properties of the column of an
    // msi record -- we are retrieving members of the
    // record
    //

    //
    // The value is our out parameter -- set it
    // to the type desired by the caller
    //
    pMsiValue->SetType( dwType );

    switch ( dwType )
    {
    case CMsiValue::TYPE_STRING:

        DWORD cchSize;

        //
        // We must determine the maximum size of the
        // string that can be represented by the value
        // so we can pass it to the msi api
        //
        cchSize = pMsiValue->GetStringSize();

        //
        // Attempt to retrieve the string by storing
        // it in the buffer of the value
        //
        Status = MsiRecordGetString(
            GetState(),
            dwValue,
            pMsiValue->GetStringValue(),
            &cchSize);

        //
        // Our attempt to retrieve the string data will
        // fail if the value's string buffer is not sufficiently
        // large.
        //
        if ( ERROR_MORE_DATA == Status )
        {
            //
            // In the case where the value's buffer is not large enough,
            // we explicitly set the size of the value to that of the
            // size returned by the msi api PLUS a zero terminator --
            // this is because the size returned by MSI does NOT
            // include the zero terminator.
            //
            cchSize++;

            Status = pMsiValue->SetStringSize( cchSize );

            //
            // We now retry the string retrieval since we have the
            // correct size now.
            //
            if ( ERROR_SUCCESS == Status )
            {
                Status = MsiRecordGetString(
                    GetState(),
                    dwValue,
                    pMsiValue->GetStringValue(),
                    &cchSize);
            }
        }
        break;

    case CMsiValue::TYPE_DWORD:

        Status = ERROR_INVALID_PARAMETER;

        int IntegerValue;

        //
        // Retrieve an integer by calling the msi api
        //
        IntegerValue = MsiRecordGetInteger(
            GetState(),
            dwValue);

        if ( MSI_NULL_INTEGER != IntegerValue )
        {
            //
            // We now set the value to that retrieved by the api
            //
            pMsiValue->SetDWORDValue( (DWORD) IntegerValue );

            Status = ERROR_SUCCESS;
        }

        break;

    default:
        ASSERT( FALSE );
        break;
    }

    return Status;
}

LONG
CMsiQuery::GetNextRecord( CMsiRecord* pMsiRecord)
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // The MsiViewFetch api will retrieve a record from a query --
    // it does this in an enumeration style, so we are retrieving
    // the next record in the query
    //

    Status = MsiViewFetch(
        GetState(),
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We successfully obtained an MSIHANDLE corresponding to the
        // retrieved record, so we use this to set the state of our
        // abstraction of the record
        //
        pMsiRecord->SetState( MsiHandle );
    }

    return Status;
}

LONG
CMsiQuery::UpdateQueryFromFilter( CMsiRecord* pFilterRecord )
{
    LONG       Status;

    //
    // The MsiViewExecute api causes the results of the query to
    // be computed.  The filter record passed in allows us to
    // specify a filter for the query results
    //
    Status = MsiViewExecute(
        GetState(),
        pFilterRecord ? pFilterRecord->GetState() : NULL );

    return Status;
}

LONG
CMsiDatabase::Open(
    WCHAR*  wszPath,
    DWORD   cTransforms,
    WCHAR** rgwszTransforms)
{
    MSIHANDLE  DatabaseHandle;
    LONG       Status;

    //
    // The MsiOpenDatabase api abstracts an .msi package
    //
    Status = MsiOpenDatabase(
        wszPath,
        MSIDBOPEN_READONLY,
        &DatabaseHandle);

    if ( ERROR_SUCCESS == Status )
    {
        DWORD iTransform;

        //
        // The successful open above does not include transforms --
        // we need to add each transform to generate a resultant
        // database that includes the changes of each transform
        //

        //
        // We apply the transforms in the order in which they are
        // stored in the vector -- this order conforms to that
        // specified by the administrator, and since order affects
        // the result, we must honor the administrator's ordering
        //
        for ( iTransform = 0; iTransform < cTransforms; iTransform++ )
        {
            if ( ERROR_SUCCESS == Status )
            {
                //
                // This api adds the effects of the transform to the
                // database.
                //
                Status = MsiDatabaseApplyTransform(
                    DatabaseHandle,
                    rgwszTransforms[iTransform],
                    0);
            }

            if ( ERROR_SUCCESS != Status )
            {
                //
                // If we failed to apply a transform, we bail
                //
                break;
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We have successfully created an database of the
            // package + transforms, so we allow the lifetime of its state
            // to be controlled by this object
            //
            SetState( DatabaseHandle );
        }
        else
        {
            //
            // If we failed to apply a transform, the database
            // resource is useless, so we free it
            //
            MsiCloseHandle( DatabaseHandle );
        }
    }

    return Status;
}

LONG
CMsiDatabase::OpenQuery(
    WCHAR*     wszQuery,
    CMsiQuery* pQuery )
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // This api will initialize a query without comoputing its
    // results.  This will allow the caller finer control over result
    // computation later, which distinguishes this method from GetQueryResults
    //
    Status = MsiDatabaseOpenView(
        GetState(),
        wszQuery,
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Give the caller's query object the state for the query
        // so that it can control its lifetime
        //
        pQuery->SetState( MsiHandle );
    }

    return Status;
}

LONG
CMsiDatabase::GetQueryResults(
    WCHAR*     wszQuery,
    CMsiQuery* pQuery )
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // This api will initialize a query without computing the results
    //
    Status = MsiDatabaseOpenView(
        GetState(),
        wszQuery,
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // The semantics of this method are that the caller may also
        // enumerate results after calling the method, so we must
        // now computer the results so that the caller may enumerate --
        // the api below will do this
        //
        Status = MsiViewExecute(
            MsiHandle,
            NULL);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // In the success case, we give the lifetime of the msi
            // state to the query object
            //
            pQuery->SetState( MsiHandle );
        }
        else
        {
            //
            // On failure, we must clear the msi query state
            // since it is useless now.
            //
            MsiCloseHandle( MsiHandle );
        }
    }

    return Status;
}

LONG
CMsiDatabase::TableExists(
    WCHAR* wszTableName,
    BOOL*  pbTableExists )
{
    MSICONDITION TableState;

    TableState = MsiDatabaseIsTablePersistent( GetState(), wszTableName );

    if ( MSICONDITION_ERROR == TableState )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbTableExists = MSICONDITION_TRUE == TableState;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\pkgdtl.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pkgdtl.cpp
//
//  Contents:   package details property page (normally hidden)
//
//  Classes:    CPackageDetails
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "fcntl.h"
#include "io.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails property page

IMPLEMENT_DYNCREATE(CPackageDetails, CPropertyPage)

CPackageDetails::CPackageDetails() : CPropertyPage(CPackageDetails::IDD)
{
        //{{AFX_DATA_INIT(CPackageDetails)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPackageDetails::~CPackageDetails()
{
    *m_ppThis = NULL;
}

void CPackageDetails::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPackageDetails)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPackageDetails, CPropertyPage)
        //{{AFX_MSG_MAP(CPackageDetails)
        ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails message handlers


// removes tabs and \n characters
void Convert(WCHAR * wsz, CString &sz)
{
    sz="";

    int iIn=0;
    int iOut=0;
    WCHAR ch;
    while (ch = wsz[iIn++])
    {
        switch (ch)
        {
        case L'\t':
            iOut++;
            sz += ' ';
            while (iOut % 4)
            {
                iOut++;
                sz += ' ';
            }
            break;
        case L'\n':
            break;
        default:
            iOut++;
            sz += ch;
            break;
        }
    }
}

void CPackageDetails::DumpClassDetail(FILE * stream, CLASSDETAIL * pClass)
{
    WCHAR wsz[256];
    StringFromGUID2(pClass->Clsid, wsz, 256);
    fwprintf(stream, L"\t\tClsid = %s\n",wsz); 
    StringFromGUID2(pClass->TreatAs, wsz, 256);
    fwprintf(stream, L"\t\tTreatAs = %s\n",wsz);
    fwprintf(stream, L"\t\tdwComClassContext = %u\n", pClass->dwComClassContext);
    fwprintf(stream, L"\t\tcProgId = %u\n",pClass->cProgId);
    int i;
    for (i = 0; i < pClass->cProgId; i++)
    {
        fwprintf(stream, L"\t\tprgProgId[%u] = %s\n",i, pClass->prgProgId[i]);
    }
}

void CPackageDetails::DumpDetails(FILE * stream)
{
    PACKAGEDETAIL * pDetails = m_pData->m_pDetails;
    WCHAR wsz[256];
    fwprintf(stream, L"pszPackageName = %s\n", pDetails->pszPackageName);
    fwprintf(stream, L"pszPublisher = %s\n", pDetails->pszPublisher);
    fwprintf(stream, L"cSources = %u\n",pDetails->cSources);
    int i;
    for (i = 0; i < pDetails->cSources; i++)
    {
        fwprintf(stream, L"pszSourceList[%u] = %s\n",i, pDetails->pszSourceList[i]);
    }
    fwprintf(stream, L"cCategories = %u\n",pDetails->cCategories);
    for (i = 0; i < pDetails->cCategories; i++)
    {
        StringFromGUID2(pDetails->rpCategory[i], wsz, 256);
        fwprintf(stream, L"rpCategory[%u]\n", i);
    }
    fwprintf(stream,L"pActInfo = \n{\n");

    ACTIVATIONINFO * pActInfo = pDetails->pActInfo;
    fwprintf(stream,L"\tcClasses = %u\n",pActInfo->cClasses);
    for (i = 0; i < pActInfo->cClasses; i++)
    {
        fwprintf(stream, L"\tpClasses[%u] = \n\t{\n",i);
        DumpClassDetail(stream, &pActInfo->pClasses[i]);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream,L"\tcShellFileExt = %u\n",pActInfo->cShellFileExt);
    for (i = 0; i < pActInfo->cShellFileExt; i++)
    {
        fwprintf(stream, L"\tprgShellFileExt[%u] = %s\n", i, pActInfo->prgShellFileExt[i]);
        fwprintf(stream, L"\tprgPriority[%u] = %u\n", i, pActInfo->prgPriority[i]);
    }
    fwprintf(stream, L"\tcInterfaces = %u\n", pActInfo->cInterfaces);
    for (i = 0; i < pActInfo->cInterfaces; i++)
    {
        StringFromGUID2(pActInfo->prgInterfaceId[i], wsz, 256);
        fwprintf(stream, L"\tprgInterfaceId[%u] = %s\n", i, wsz);
    }
    fwprintf(stream, L"\tcTypeLib = %u\n", pActInfo->cTypeLib);
    for (i = 0; i < pActInfo->cTypeLib; i++)
    {
        StringFromGUID2(pActInfo->prgTlbId[i], wsz, 256);
        fwprintf(stream, L"\tprgTlbId[%u] = %s\n", i, wsz);
    }

    fwprintf(stream,L"}\npPlatformInfo = \n{\n");

    PLATFORMINFO * pPlatformInfo = pDetails->pPlatformInfo;
    fwprintf(stream, L"\tcPlatforms = %u\n",pPlatformInfo->cPlatforms);
    for (i = 0; i < pPlatformInfo->cPlatforms; i++)
    {
        fwprintf(stream, L"\tprgPlatform[%u] = \n\t{\n",i);
        fwprintf(stream, L"\t\tdwPlatformId = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwPlatformId);
        fwprintf(stream, L"\t\tdwVersionHi = %u\n", pPlatformInfo->prgPlatform[i].dwVersionHi);
        fwprintf(stream, L"\t\tdwVersionLo = %u\n", pPlatformInfo->prgPlatform[i].dwVersionLo);
        fwprintf(stream, L"\t\tdwProcessorArch = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwProcessorArch);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream, L"\tcLoacles = %u\n", pPlatformInfo->cLocales);
    for (i = 0; i < pPlatformInfo->cLocales; i++)
    {
        fwprintf(stream, L"\tprgLocale[%u] = 0x%04X\n", i, pPlatformInfo->prgLocale[i]);
    }

    fwprintf(stream,L"}\npInstallInfo = \n{\n");

    INSTALLINFO * pInstallInfo = pDetails->pInstallInfo;
    fwprintf(stream, L"\tdwActFlags = 0x%04X\n", pInstallInfo->dwActFlags);
    fwprintf(stream, L"\tPathType = %u\n", pInstallInfo->PathType);
    fwprintf(stream, L"\tpszScriptPath = %s\n", pInstallInfo->pszScriptPath);
    fwprintf(stream, L"\tpszSetupCommand = %s\n",pInstallInfo->pszSetupCommand);
    fwprintf(stream, L"\tpszUrl = %s\n",pInstallInfo->pszUrl);
    fwprintf(stream, L"\tUsn = %I64u\n",pInstallInfo->Usn);
    fwprintf(stream, L"\tInstallUiLevel = %u\n", pInstallInfo->InstallUiLevel);
    wsz[0] = 0;
    if (pInstallInfo->pClsid)
    {
        StringFromGUID2(*pInstallInfo->pClsid, wsz, 256);
    }
    fwprintf(stream, L"\tpClsid = %s\n", wsz);
    StringFromGUID2(pInstallInfo->ProductCode, wsz, 256);
    fwprintf(stream, L"\tProductCode = %s\n", wsz);
    StringFromGUID2(pInstallInfo->Mvipc, wsz, 256);
    fwprintf(stream, L"\tMvipc = %s\n", wsz);
    fwprintf(stream, L"\tdwVersionHi = %u\n", pInstallInfo->dwVersionHi);
    fwprintf(stream, L"\tdwVersionLo = %u\n", pInstallInfo->dwVersionLo);
    fwprintf(stream, L"\tdwRevision = %u\n", pInstallInfo->dwRevision);
    fwprintf(stream, L"\tcUpgrades = %u\n", pInstallInfo->cUpgrades);
    if (pInstallInfo->cUpgrades > 0)
    {
        fwprintf(stream, L"\tprgUpgradeInfoList[%u] = \n\t{\n", i);
        for (i = 0; i < pInstallInfo->cUpgrades; i++)
        {
            fwprintf(stream, L"\t\tszClassStore = %s\n", pInstallInfo->prgUpgradeInfoList[i].szClassStore);
            StringFromGUID2(pInstallInfo->prgUpgradeInfoList[i].PackageGuid, wsz, 256);
            fwprintf(stream, L"\t\tPackageGuid = %s\n", wsz);
            fwprintf(stream, L"\t\tFlag = %u\n", pInstallInfo->prgUpgradeInfoList[i].Flag);
        }
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream, L"\tcScriptLen = %u\n", pInstallInfo->cScriptLen);
    fwprintf(stream,L"}\n");
}

BOOL CPackageDetails::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        RefreshData();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CPackageDetails::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CPackageDetails::RefreshData(void)
{
    m_cList.ResetContent();

    // Dump the m_pData->m_pDetails structure here

    FILE * stream = tmpfile();
    if (stream)
    {
        _setmode(_fileno(stream), _O_TEXT);

        DumpDetails(stream);

        rewind(stream);

        WCHAR wsz[256];
        CString szTemp;
        int cWidth = 0;

        while (fgetws(wsz, 256, stream))
        {
            Convert(wsz, szTemp);
            CDC * pDC = m_cList.GetDC();
            CSize csExtent = pDC->GetTextExtent(szTemp);
            pDC->LPtoDP(&csExtent);
            m_cList.ReleaseDC(pDC);
            if (cWidth < csExtent.cx)
            {
                cWidth = csExtent.cx;
            }
            m_cList.AddString(szTemp);
        }
        m_cList.SetHorizontalExtent(cWidth);
        fclose(stream);
    }
}

void CPackageDetails::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PACKAGE_DETAILS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\msiclass.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msiclass.cpp
//
//  Contents:   msi class collection abstraction
//
//  Classes:
//
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

WCHAR* CClassCollection::_wszQueries[ TYPE_COUNT ] =
{
    QUERY_EXTENSIONS,
    QUERY_CLSIDS,
    QUERY_VERSION_INDEPENDENT_PROGIDS
};

CClassCollection::CClassCollection( PACKAGEDETAIL* pPackageDetail ) :
    _pPackageDetail( pPackageDetail ),
    _cMaxClsids( 0 ),
    _cMaxExtensions( 0 ),
    _InstallLevel( 0 )
{
    //
    // All memory referenced by the pPackageDetail must be
    // freed by the caller after the GetClasses method is called,
    // even if the call fails.
    //

    //
    // We need to clear any existing class information in the
    // PACKAGEDETAIL structure since we are going to overwrite
    // it eventually anyway
    //

    //
    // First clear the clsid's
    //
    DWORD iClass;

    //
    // Free each individual class
    //
    for ( iClass = 0; iClass < _pPackageDetail->pActInfo->cClasses; iClass++ )
    {
        FreeClassDetail( &(_pPackageDetail->pActInfo->pClasses[ iClass ]) );
    }

    //
    // Now free the vector that held the classes
    //
    LocalFree( _pPackageDetail->pActInfo->pClasses );

    //
    // Set our vector reference to the initial state of none
    //
    _pPackageDetail->pActInfo->pClasses = NULL;

    //
    // Set the initial state of no clsid's since they have all been freed
    //
    _pPackageDetail->pActInfo->cClasses = 0;


    //
    // Now clear the extensions
    //
    DWORD iExtension;

    //
    // For each individual extension
    //
    for ( iExtension = 0; iExtension < _pPackageDetail->pActInfo->cShellFileExt; iExtension++ )
    {
        LocalFree( _pPackageDetail->pActInfo->prgShellFileExt[ iExtension ] );
    }

    //
    // Free the vector that held the extensions
    //
    LocalFree( _pPackageDetail->pActInfo->prgShellFileExt );

    //
    // Also destroy the vector that held extension priorities
    //
    LocalFree( _pPackageDetail->pActInfo->prgPriority );

    //
    // Set our vector references to the initial state of none
    //
    _pPackageDetail->pActInfo->prgShellFileExt = NULL;
    _pPackageDetail->pActInfo->prgPriority = NULL;

    //
    // Set the initial state of no file extensions since they have all been freed
    //
    _pPackageDetail->pActInfo->cShellFileExt = 0;
}


HRESULT
CClassCollection::GetClasses( BOOL bFileExtensionsOnly )
{
    HRESULT hr;
    LONG    Status;
    DWORD   cTransforms;

    //
    // This method obtains the class metadata from an msi package + transforms.
    // The goal is to approximate the set of class data that would be advertised
    // on any system (regardless of system configuration) if the package were
    // advertised.
    //

    //
    // The classes will all be stored in the PACKAGEDETAIL structure.  The caller
    // must free this memory after finishing with the structure, even if this
    // method fails
    //

    //
    // First, we must create a database representation of the package + transforms
    //

    //
    // The source list vector contains the package + transforms in application order --
    // we must subtract one source since the original package is included in the list
    //
    cTransforms = _pPackageDetail->cSources - 1;

    //
    // Now we create a database out of the package plus transforms.  Since the
    // first item in the source list is the package, we pass that in as the package,
    // and all other items after it in the vector are passed in as the transform vector
    //
    Status = _Database.Open(
        _pPackageDetail->pszSourceList[0],
        cTransforms,
        cTransforms ? &(_pPackageDetail->pszSourceList[1]) : NULL );

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We've successfully opened the package, now obtain its friendly name.
        //
        Status = GetFriendlyName();

        if (ERROR_SUCCESS == Status)
        {
            //
            // Now obtain its install level.
            // The install level affects whether or not a class will get advertised
            //
            Status = GetInstallLevel();

        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Now that we know the install level of the package, we have
            // enough information to flag each advertisable feature in the database.
            // We need this because a class is only advertised if its associated
            // feature is advertised.
            //
            Status = FlagAdvertisableFeatures();
        }

        //
        // We may now retrieve the set of classes that will be advertised based
        // on the set of advertised features we flagged earlier.  We care only
        // about 3 types of classes: Clsid's, ProgId's, and File Extenions.
        //
        if ( ! bFileExtensionsOnly )
        {
            if ( ERROR_SUCCESS == Status )
            {
                Status = GetClsids();
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = GetProgIds();
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = GetExtensions();
        }

        LONG StatusFree;

        //
        // We must remove the scratch flags we added to the database
        //
        StatusFree = RemoveAdvertisableFeatureFlags();

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Take care to preserve the return value -- a failure
            // before cleaning up the database takes precedence over
            // a failure in cleaning up the database.
            //
            Status = StatusFree;
        }
    }

    return HRESULT_FROM_WIN32(Status);
}

LONG
CClassCollection::GetExtensions()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have an extension table to query
    //
    Status = _Database.TableExists( TABLE_FILE_EXTENSIONS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // Set up a destination in the user's PACKAGEDETAIL structure
        // for the shell extension class data
        //
        DataDestination Destination(
            TYPE_EXTENSION,
            (void**)&(_pPackageDetail->pActInfo->prgShellFileExt),
            &(_pPackageDetail->pActInfo->cShellFileExt),
            (UINT*) &_cMaxExtensions);

        //
        // Now retrieve the shell extensions
        //
        Status = GetElements(
            TYPE_EXTENSION,
            &Destination );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully retrieved the shell extensions --
            // the caller also expects a parallel array of priorities
            // with each shell extension -- the values are unimportant
            // since the caller will fill those in, but the memory must
            // exist, so we will allocate it.
            //
            _pPackageDetail->pActInfo->prgPriority =
                (UINT*) LocalAlloc(
                    0,
                    sizeof(UINT) *
                    _pPackageDetail->pActInfo->cShellFileExt );

            if ( ! _pPackageDetail->pActInfo->prgPriority )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return Status;
}


LONG
CClassCollection::GetClsids()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have a clsid table to query
    //
    Status = _Database.TableExists( TABLE_CLSIDS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // Set the destination for the clsid's to a location
        // in the caller's PACKAGEDETAIL structure
        //
        DataDestination Destination(
            TYPE_CLSID,
            (void**)&(_pPackageDetail->pActInfo->pClasses),
            &(_pPackageDetail->pActInfo->cClasses),
            (UINT*) &_cMaxClsids);

        //
        // Now retrieve the clsid's for each package
        //
        Status = GetElements(
            TYPE_CLSID,
            &Destination );
    }

    return Status;
}

LONG
CClassCollection::GetProgIds()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have a ProgId table to query
    //
    Status = _Database.TableExists( TABLE_PROGIDS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // This method MUST be called AFTER GetClsids -- progid's
        // are stored within their associated clsid's, so we will
        // not have a place to store the progid's unless we've
        // already obtained the clsid's.
        //

        //
        // At this point, we know only that we want to retrieve ProgId's --
        // we do not know their destination because this differs for
        // each progid depending on the associated clsid -- the NULL
        // parameters indicate that some callee will need to determine
        // the location for this data.
        //
        DataDestination Destination(
            TYPE_PROGID,
            NULL,
            NULL,
            NULL);

        //
        // Retrieve the progid's into the appropriate locations in the structure
        //
        Status = GetElements(
            TYPE_PROGID,
            &Destination );
    }

    return ERROR_SUCCESS;
}

LONG
CClassCollection::GetElements(
    DWORD            dwType,
    DataDestination* pDestination )
{
    LONG      Status;

    CMsiQuery ElementQuery;

    //
    // Perform the query for the class elements
    //
    Status = _Database.GetQueryResults(
        _wszQueries[ dwType ],
        &ElementQuery);

    if ( ERROR_SUCCESS != Status )
    {
        return Status;
    }

    for (;;)
    {
        //
        // We've obtained the results -- now we enumerate them so
        // that we can persist them in the caller's PACKAGEDETAIL
        // structure.
        //

        //
        // Note that we start a new scope so that our record object
        // will automatically free its resources
        //
        {
            CMsiRecord CurrentRecord;

            //
            // Enumerate the next record in the query result set
            //
            Status = ElementQuery.GetNextRecord( &CurrentRecord );

            if ( ERROR_SUCCESS != Status )
            {
                if ( ERROR_NO_MORE_ITEMS == Status )
                {
                    Status = ERROR_SUCCESS;
                }

                break;
            }

            //
            // Now attempt to add the class data from this record into
            // the PACKAGEDETAIL structure
            //
            Status = ProcessElement(
                dwType,
                &CurrentRecord,
                pDestination);
        }

        if ( ERROR_SUCCESS != Status )
        {
            break;
        }
    }

    return Status;
}


LONG
CClassCollection::FlagAdvertisableFeatures()
{
    LONG Status;

    CMsiQuery FeatureQueryCreate;

    //
    // We will attempt to mark each feature in the database
    // with a flag indicating whether or not it will be advertised
    //

    //
    // First, add a column to the feature table of the database
    // so that we can use the column to flag whether or not the
    // feature is advertised.
    //
    Status = _Database.GetQueryResults(
        QUERY_ADVERTISED_FEATURES_CREATE,
        &FeatureQueryCreate);

    CMsiQuery FeatureQueryInit;

    //
    // Now intialize the new column's flags to 0 which
    // indicates that no features will be advertised (yet)
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.GetQueryResults(
            QUERY_ADVERTISED_FEATURES_INIT,
            &FeatureQueryInit);
    }

    CMsiQuery AllFeatures;

    //
    // Now we perform the query to retrieve all features --
    // records in this query will contain the newly added
    // flag column.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.GetQueryResults(
            QUERY_ADVERTISED_FEATURES_RESULT,
            &AllFeatures);
    }

    CMsiQuery SetAdvertised;

    //
    // Create a query that will allow us to set the flag --
    // this query is not yet computed, simply initialized
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.OpenQuery(
            QUERY_FEATURES_SET,
            &SetAdvertised);
    }

    //
    // Now we enumerate through all the features and
    // set the flag for each feature that passes the tests
    // for advertisability.
    //
    for (; ERROR_SUCCESS == Status ;)
    {
        CMsiRecord CurrentRecord;
        BOOL       bAdvertised;

        //
        // Retrieve the current feature
        //
        Status = AllFeatures.GetNextRecord(
            &CurrentRecord);

        if ( ERROR_SUCCESS != Status )
        {
            if ( ERROR_NO_MORE_ITEMS == Status )
            {
                Status = ERROR_SUCCESS;
            }

            break;
        }

        //
        // Determine whether or not this feature should be advertised
        //
        Status = GetFeatureAdvertiseState(
            &CurrentRecord,
            &bAdvertised );

        if ( ( ERROR_SUCCESS == Status ) &&
             bAdvertised )
        {
            //
            // This feature is advertisable -- use our SetAdvertised query
            // to set the advertisability flag to true.
            //
            Status = SetAdvertised.UpdateQueryFromFilter( &CurrentRecord );
        }
    }

    return Status;
}

LONG
CClassCollection::RemoveAdvertisableFeatureFlags()
{
    LONG Status;

    CMsiQuery FreeQuery;

    //
    // Retrieving the results of this query will
    // eliminate the extra flag column we added
    // to the feature table to flag advertisable
    // features.
    //
    Status = _Database.GetQueryResults(
        QUERY_ADVERTISED_FEATURES_DESTROY,
        &FreeQuery);

    return Status;
}

LONG
CClassCollection::GetInstallLevel()
{
    LONG Status;

    CMsiQuery InstallLevelQuery;

    //
    // Perform a query which retrieves the install level
    // property from the package's property table
    //
    Status = _Database.GetQueryResults(
        QUERY_INSTALLLEVEL,
        &InstallLevelQuery);

    CMsiRecord InstallLevelRecord;

    //
    // This query should only have one record in it since
    // it was targeted at the specific record for install level --
    // we now read that record
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = InstallLevelQuery.GetNextRecord(
            &InstallLevelRecord);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue InstallLevelProperty;

        //
        // We now attempt to obtain the installlevel property value
        // from the retrieved record.
        //
        Status = InstallLevelRecord.GetValue(
            CMsiValue::TYPE_DWORD,
            PROPERTY_COLUMN_VALUE,
            &InstallLevelProperty);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully obtained the value, so we set it
            //
            _InstallLevel = InstallLevelProperty.GetDWORDValue();
        }
    }
    else if ( ERROR_NO_MORE_ITEMS == Status )
    {
        //
        // This will only happen if the install level property
        // is not present.  As fundamental as this property is,
        // some packages do not specify it.  The Darwin engine
        // treats this case as an implicit install level of 1, so
        // we must do the same here
        //
        _InstallLevel = 1;

        Status = ERROR_SUCCESS;
    }


    return Status;
}

LONG
CClassCollection::GetFriendlyName()
{
    LONG Status;

    CMsiQuery FriendlyNameQuery;

    //
    // Perform a query which retrieves the install level
    // property from the package's property table
    //
    Status = _Database.GetQueryResults(
        QUERY_FRIENDLYNAME,
        &FriendlyNameQuery);

    CMsiRecord FriendlyNameRecord;

    //
    // This query should only have one record in it since
    // it was targeted at the specific record
    // we now read that record
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = FriendlyNameQuery.GetNextRecord(
            &FriendlyNameRecord);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue FriendlyNameProperty;

        //
        // We now attempt to obtain the property value
        // from the retrieved record.
        //
        Status = FriendlyNameRecord.GetValue(
            CMsiValue::TYPE_STRING,
            PROPERTY_COLUMN_VALUE,
            &FriendlyNameProperty);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully obtained the value, so we set it
            //
            CString szName = FriendlyNameProperty.GetStringValue();
            OLESAFE_DELETE(_pPackageDetail->pszPackageName);
            OLESAFE_COPYSTRING(_pPackageDetail->pszPackageName, szName);
        }
    }

    return Status;
}

LONG
CClassCollection::GetFeatureAdvertiseState(
    CMsiRecord* pFeatureRecord,
    BOOL*       pbAdvertised )
{
    LONG      Status;
    CMsiValue Attributes;
    CMsiValue InstallLevel;

    //
    // Set the out paramter's initial value to FALSE,
    // indicating that the feature is not advertised
    //
    *pbAdvertised = FALSE;

    //
    // The Attributes column of the feature table
    // contains a flag indicating that a feature
    // should be not advertised
    //
    Status = pFeatureRecord->GetValue(
        CMsiValue::TYPE_DWORD,
        FEATURE_COLUMN_ATTRIBUTES,
        &Attributes);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // If the disable advertise flag is set, this feature
        // cannot be advertised
        //
        if ( Attributes.GetDWORDValue() & MSI_DISABLEADVERTISE )
        {
            return ERROR_SUCCESS;
        }

        //
        // The disable flag was not set -- that still does not mean that
        // the feature is advertised -- we must check the install level.
        // We retrieve the install level for this feature here
        //
        Status = pFeatureRecord->GetValue(
            CMsiValue::TYPE_DWORD,
            FEATURE_COLUMN_LEVEL,
            &InstallLevel);
    }

    if ( ERROR_SUCCESS == Status )
    {
        DWORD dwInstallLevel;

        //
        // Obtain the value for the install level so
        // we can compare against the package install level
        //
        dwInstallLevel = InstallLevel.GetDWORDValue();

        //
        // An install level of 0 indicates that the package will
        // not be advertised.  The install level of the feature
        // must be no higher than the package's global install
        // level
        //
        if ( ( 0 != dwInstallLevel ) &&
             ( dwInstallLevel <= _InstallLevel ) )
        {
            //
            // This feature passes the tests -- set the out parameter
            // to TRUE to indicate that the feature should be advertised
            //
            *pbAdvertised = TRUE;
        }
    }

    return Status;
}


LONG
CClassCollection::AddElement(
    void*            pvDataSource,
    DataDestination* pDataDestination)
{
    DWORD*  pcMax;
    BYTE*   pNewResults;
    DWORD   cCurrent;

    //
    // We attempt to add an element to a vector
    //

    //
    // Set the count for how many elements are stored in the vector to
    // that specified by the caller
    //
    cCurrent = *(pDataDestination->_pcCurrent);

    //
    // Set the element count for the maximum number of elements that
    // will fit in the vector currently to that specified by the caller
    //
    pcMax = (DWORD*) pDataDestination->_pcMax;

    //
    // Set our results to point to the vector specified by the caller
    //
    pNewResults = (BYTE*) pDataDestination->_ppvData;

    //
    // If we already have the maximum number of elements in the vector,
    // we will have to make room for more
    //
    if ( *pcMax >= cCurrent)
    {
        DWORD cbSize;

        //
        // Calculate the new size in bytes so that we can ask the system
        // for memory.  We take our current size in elements and add on a fixed
        // allocation increment.  The caller has specified the size
        // of each individual element, so we use that to turn the number
        // of elements to a memory size.
        //
        cbSize = ( *pcMax + CLASS_ALLOC_SIZE ) *
            pDataDestination->_cbElementSize;

        //
        // Make the request for memory
        //
        pNewResults = (BYTE*) LocalAlloc( 0, cbSize );

        if ( ! pNewResults )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Clear the memory -- any data structures embedded in the element
        // will have NULL references and thus will be properly initialized
        //
        memset( pNewResults, 0, cbSize );

        //
        // If the original maximum size of the vector was nonzero, then we must
        // copy to original contents of the vector to the newly allocated memory
        // location.
        //
        if ( *pcMax )
        {
            memcpy(
                pNewResults,
                *(pDataDestination->_ppvData),
                *pcMax * pDataDestination->_cbElementSize);
        }

        //
        // Free the original vector as it is no longer needed
        //
        LocalFree( *(pDataDestination->_ppvData) );

        //
        // Change the caller's reference to point to the new vector
        //
        *(pDataDestination->_ppvData) = pNewResults;

        //
        // Set the new maximum size (in elements) to that of the newly allocated vector
        //
        *pcMax += CLASS_ALLOC_SIZE;
    }

    //
    // At this point, we know we have a memory location in the vector into
    // which we can safely copy the new element
    //
    memcpy(
        pNewResults + ( cCurrent * pDataDestination->_cbElementSize ),
        pvDataSource,
        pDataDestination->_cbElementSize);

    //
    // Update the count of elements currently stored in the vector
    //
    *(pDataDestination->_pcCurrent) = cCurrent + 1;

    return ERROR_SUCCESS;
}


LONG
CClassCollection::ProcessElement(
    DWORD            dwType,
    CMsiRecord*      pRecord,
    DataDestination* pDataDestination)
{
    LONG        Status = ERROR_SUCCESS;
    void*       pvData;
    WCHAR*      wszData;
    CLASSDETAIL ClassDetail;

    pvData = NULL;
    wszData = NULL;

    //
    // We attempt to create a new class element based
    // on the record passed in by the caller, and then
    // add that element to the caller's PACKAGEDETAIL structure
    //

    //
    // The type of element to be added depends on the type
    // of class requested by the caller.  The pvData variable
    // will point to the element to be added if we can successfully
    // create a representation for it.
    //
    switch ( dwType )
    {
    case TYPE_EXTENSION:

        //
        // Get a file extension representation from the record --
        // note that wszData points to memory allocated by the callee
        // on success, so it must be freed by this function.
        //
        Status = ProcessExtension(
            pRecord,
            &wszData);

        if ( ERROR_SUCCESS == Status )
        {
            pvData = &wszData;
        }

        break;

    case TYPE_CLSID:

        //
        // Get a clsid representation from the record --
        // in this case, the ClassDetail itself does not
        // need to be freed since it does not contain any references
        // to memory after this call
        //
        BOOL bIgnoreClsid;

        Status = ProcessClsid(
            pRecord,
            &ClassDetail,
            &bIgnoreClsid);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Check to see if we should add this clsid -- we may be prohibited from
            // this because it is a duplicate of an exsting clsid, which would be
            // redundant and furthermore the PACKAGEDETAIL format requires
            // that all (clsid, clsctx) pairs be unique. Or the clsid itself
            // may have an unsupported clsctx.  This is not a failure
            // case, so we return success here and simply avoid addding this
            // class
            //
            if ( bIgnoreClsid )
            {
                return ERROR_SUCCESS;
            }

            pvData = &ClassDetail;
        }

        break;

    case TYPE_PROGID:

        //
        // Get a progid representation from the record.  In addition
        // to retrieving the progid in the form of an allocated string
        // which must be freed by this funciton, we also retrieve the
        // location at which to add the progid to the caller's
        // PACKAGEDETAIL structure. This is necessary since the
        // ProgId must be part of the CLASSDETAIL structure with which
        // it is associated.
        //
        Status = ProcessProgId(
            pRecord,
            pDataDestination,
            &wszData);

        if ( ( ERROR_SUCCESS == Status ) &&
             wszData )
        {
            pvData = &wszData;
        }

        break;

    default:
        ASSERT(FALSE);
        break;
    }

    //
    // If we were successful in obtaining a representation of the record
    // that can be stored in the caller's PACKAGEDETAIL structure, attempt
    // to add it to the structure
    //
    if ( pvData )
    {
        Status = AddElement(
            pvData,
            pDataDestination);
    }

    //
    // Be sure that in the failure case, we free any memory
    // that may have been allocated.
    //
    if ( ERROR_SUCCESS != Status )
    {
        if (wszData )
        {
            LocalFree( wszData );
        }
    }

    return Status;
}

LONG
CClassCollection::ProcessExtension(
    CMsiRecord*      pRecord,
    WCHAR**          ppwszExtension)
{
    LONG      Status;
    CMsiValue FileExtension;

    *ppwszExtension = NULL;

    //
    // We retrieve the actual file extension string
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        EXTENSION_COLUMN_EXTENSION,
        &FileExtension);

    if ( ERROR_SUCCESS == Status )
    {
        ULONG   ulNoChars;
        HRESULT hr;

        //
        // We have the value.  Note that it does not contain
        // an initial '.', but the usage of the PACKAGEDETAIL
        // structure mandates that file extensions begin with the '.'
        // char, so we will have to prepend the '.' here.
        //

        //
        // First, get space for a copy of the string that includes
        // the '.' as well as the zero terminator.
        //

        ulNoChars = FileExtension.GetStringSize() + 1 + 1;
        *ppwszExtension = (WCHAR*) LocalAlloc(
            0,
            ulNoChars * sizeof(WCHAR) );

        if ( ! *ppwszExtension )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            return Status;
        }

        //
        // Set the first char to be '.'
        //
        **ppwszExtension = L'.';

        //
        // Now append the actual extension to the '.'
        //

        hr = StringCchCopy( *ppwszExtension + 1, ulNoChars - 1, FileExtension.GetStringValue() );
        ASSERT(SUCCEEDED(hr));
    }

    return Status;
}


LONG
CClassCollection::ProcessClsid(
    CMsiRecord*      pRecord,
    CLASSDETAIL*     pClsid,
    BOOL*            pbIgnoreClsid)
{
    LONG  Status;
    DWORD dwClsCtx;
    
    CMsiValue GuidString;
    CMsiValue ClassContext;

    //
    // Clear the clsid to a safe state
    //
    memset( pClsid, 0, sizeof( *pClsid ) );

    //
    // Reset out parameters
    //
    *pbIgnoreClsid = FALSE;

    dwClsCtx = 0;

    //
    // Retrieve the actual clsid
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        CLSID_COLUMN_CLSID,
        &GuidString);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Get the clsctx for this clsid
        //
        Status = pRecord->GetValue(
            CMsiValue::TYPE_STRING,
            CLSID_COLUMN_CONTEXT,
            &ClassContext);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue Attribute;
        WCHAR*    wszClassContext;
        DWORD     dwInprocClsCtx;

        dwInprocClsCtx = 0;

        //
        // Retrieve a string representation of the clsctx for this clsid
        //
        wszClassContext = ClassContext.GetStringValue();

        //
        // Now map the clsctx strings to COM CLSCTX_* values
        //
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, wszClassContext, -1, COM_INPROC_CONTEXT, -1) == CSTR_EQUAL) 
        {
            dwInprocClsCtx |= CLSCTX_INPROC_SERVER;
        }
        else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, wszClassContext, -1, COM_INPROCHANDLER_CONTEXT, -1) == CSTR_EQUAL) 
        {
            dwInprocClsCtx |= CLSCTX_INPROC_HANDLER;
        }
        else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, wszClassContext, -1, COM_LOCALSERVER_CONTEXT, -1) == CSTR_EQUAL) 
        {
            dwClsCtx |= CLSCTX_LOCAL_SERVER;
        }
        else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, wszClassContext, -1, COM_REMOTESERVER_CONTEXT, -1) == CSTR_EQUAL) 
        {
            dwClsCtx |= CLSCTX_REMOTE_SERVER;
        }
        else
        {
            //
            // If the clsctx is one we do not support, we will ignore it
            //
            *pbIgnoreClsid = TRUE;

            return ERROR_SUCCESS;
        }

        BOOL b64Bit;

        b64Bit = FALSE;

        //
        // We must disginguish between 32-bit and 64-bit in-process servers, since
        // 64-bit Windows does not allows modules of different bitness to coexist in the
        // same process.  If this is an in-process component, we will also check to see
        // whether it is 64-bit or not.
        //
        if ( ( dwInprocClsCtx & CLSCTX_INPROC_HANDLER ) ||
             ( dwInprocClsCtx & CLSCTX_INPROC_SERVER ) )
        {
            //
            // The Attributes column of the record has a flag indicating bitness -- this
            // will only fail if the property is NULL
            //
            Status = pRecord->GetValue(
                CMsiValue::TYPE_DWORD,
                CLSID_COLUMN_ATTRIBUTES,
                &Attribute);

            //
            // Check the flag to see if this is 64-bit
            //
            if ( ERROR_SUCCESS == Status )
            {
                b64Bit = Attribute.GetDWORDValue() & MSI_64BIT_CLASS;
            }
            else
            {
                //
                // This means the property is NULL, so we interpret that as
                // meaning the application is not 64 bit
                //
                Status = ERROR_SUCCESS;
            }

            //
            // Map this 64-bit clsctx to a custom (non-COM) CLSCTX that
            // indicates that this is a 64-bit-only in-process class.
            //
            if ( ( ERROR_SUCCESS == Status ) && b64Bit )
            {
                if ( dwInprocClsCtx & CLSCTX_INPROC_SERVER )
                {
                    dwClsCtx |= CLSCTX64_INPROC_SERVER;
                }

                if ( dwInprocClsCtx & CLSCTX_INPROC_HANDLER )
                {
                    dwClsCtx |= CLSCTX64_INPROC_HANDLER;
                }
            }
        }

        //
        // In the 32-bit case, just or in the values we already computed for
        // inproc case
        //
        if ( ! b64Bit )
        {
            dwClsCtx |= dwInprocClsCtx;
        }
    }
    
    //
    // Check to see if this is a duplicate -- we do this because our query
    // returned results distinct in (clsid, clsctx, attribute).  Since we
    // are mapping attribute to clsctx above and we only support 1 attribute
    // flag (the 64-bit flag) out of several, we may end up with duplicate
    // (clsid, clsctx) pairs, and the PACKAGEDETAIL format requires that
    // we have unique (clsid, clsctx) pairs.  Another way to get this would
    // be if COM introduced new clsctx types which we did not support -- these
    // would map to zero, and again we could have duplicates
    //
    if ( ERROR_SUCCESS == Status )
    {
        CLASSDETAIL* pClassDetail;

        pClassDetail = NULL;

        Status = FindClass(
            GuidString.GetStringValue(),
            &pClassDetail);

        //
        // If we already have an entry for this clsid, check to see if
        // it has the same clsctx bits -- if so it is a duplicate entry
        // and we will cease processing it
        //
        if ( ( ERROR_SUCCESS == Status ) && pClassDetail )
        {
            *pbIgnoreClsid = ( dwClsCtx & pClassDetail->dwComClassContext );

            if ( *pbIgnoreClsid )
            {
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Convert the clsid string to a guid as mandated by the
    // CLASSDETAIL structure
    //
    if ( ERROR_SUCCESS == Status )
    {
        HRESULT hr;

        hr = CLSIDFromString(
            GuidString.GetStringValue(),
            &(pClsid->Clsid));

        if ( FAILED(hr) )
        {
            Status = ERROR_GEN_FAILURE;
        }
    }

    //
    // Set the clsctx we computed above.
    //
    if ( ERROR_SUCCESS == Status )
    {
        pClsid->dwComClassContext = dwClsCtx;
    }

    return Status;
}

LONG
CClassCollection::ProcessProgId(
    CMsiRecord*      pRecord,
    DataDestination* pDataDestination,
    WCHAR**          ppwszProgId)
{
    LONG  Status;

    CMsiValue    ProgIdString;
    CMsiValue    ClsidString;

    CLASSDETAIL* pClassDetail;

    //
    // We attempt to map a progid record to a
    // clsid that we've already processed, since
    // the progid will eventually need to go
    // inside the clsid's structure.
    //

    *ppwszProgId = NULL;

    pClassDetail = NULL;

    //
    // Retrieve the value for the progid itself
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        PROGID_COLUMN_PROGID,
        &ProgIdString);

    //
    // Retrieve the value of the clsid associated with
    // the progid
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = pRecord->GetValue(
            CMsiValue::TYPE_STRING,
            PROGID_COLUMN_CLSID,
            &ClsidString);
    }

    //
    // We must find the existing CLASSDETAIL structure
    // that we are maintaining for the progid since the
    // progid must eventually be referenced in that structure.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = FindClass(
            ClsidString.GetStringValue(),
            &pClassDetail);
    }

    if ( ERROR_SUCCESS == Status )
    {
        //
        // If we have successfully found the class,
        //
        if ( pClassDetail )
        {
            //
            // Give the caller the progid string since
            // we know that we have a class in which
            // to place it
            //
            *ppwszProgId = ProgIdString.DuplicateString();

            if ( ! *ppwszProgId )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // Set the caller's data destination to that of the
                // progid vector within the clsid associated with this progid
                //
                pDataDestination->_ppvData = (void**) &( pClassDetail->prgProgId );

                pDataDestination->_pcCurrent = (UINT*) &( pClassDetail->cProgId );

                pDataDestination->_pcMax = (UINT*) &( pClassDetail->cMaxProgId );
            }
        }
    }

    //
    // On failure, free any resources we've allocated
    //
    if ( ( ERROR_SUCCESS != Status ) &&
         *ppwszProgId )
    {
        LocalFree( *ppwszProgId );
    }

    return Status;
}


LONG
CClassCollection::FindClass(
    WCHAR*        wszClsid,
    CLASSDETAIL** ppClass)
{
    CLSID   Clsid;
    HRESULT hr;

    //
    // Attempt to find a CLASSDETAIL structure in the PACKAGEDETAIL structure
    // for the clsid given in string form in wszClsid
    //

    *ppClass = NULL;

    //
    // The PACKAGEDETAIL structure stores the clsid in guid form,
    // so we must convert the string to that form before searching
    //
    hr = CLSIDFromString(
        wszClsid,
        &Clsid);

    if ( FAILED(hr) )
    {
        return ERROR_GEN_FAILURE;
    }

    UINT iClsid;

    //
    // We now perform a simple linear search for the clsid
    //
    for (
        iClsid = 0;
        iClsid < _pPackageDetail->pActInfo->cClasses;
        iClsid++)
    {
        if ( IsEqualGUID(
            _pPackageDetail->pActInfo->pClasses[iClsid].Clsid,
            Clsid) )
        {
            *ppClass = &(_pPackageDetail->pActInfo->pClasses[iClsid]);
            return ERROR_SUCCESS;
        }
    }

    return ERROR_SUCCESS;
}

void
CClassCollection::FreeClassDetail( CLASSDETAIL* pClass )
{
    DWORD iProgId;

    //
    // Free each individual progid string
    //
    for ( iProgId = 0; iProgId < pClass->cProgId; iProgId++ )
    {
        LocalFree( pClass->prgProgId[ iProgId ] );
    }

    //
    // Free the array of progid strings
    //
    LocalFree( pClass->prgProgId );
}


DataDestination::DataDestination(
    DWORD        dwType,
    void**       prgpvDestination,
    UINT*        pcCurrent,
    UINT*        pcMax ) :
    _pcCurrent( pcCurrent ),
    _ppvData( prgpvDestination ),
    _pcMax ( pcMax )
{
    //
    // The size of the elements stored by
    // the vector referenced from this class
    // depend on the type of element --
    // clsid, file extension, or progid
    //

    switch ( dwType )
    {
    case TYPE_EXTENSION:
        _cbElementSize = sizeof( WCHAR* );
        break;

    case TYPE_CLSID:
        _cbElementSize = sizeof( CLASSDETAIL );
        break;

    case TYPE_PROGID:
        _cbElementSize = sizeof( WCHAR* );
        break;

    default:
        ASSERT(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\packages.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       packages.cpp
//
//  Contents:   Methods on CScopePane related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:  CopyPackageDetail
//              FreePackageDetail
//              GetMsiProperty
//
//  History:    2-03-1998   stevebl   Created
//              3-25-1998   stevebl   Added GetMsiProperty
//              5-20-1998   RahulTh   - Added DetectUpgrades for automatic upgrade
//                                      detection
//                                    - Added GetCapitalizedExt
//
//---------------------------------------------------------------------------

// UNDONE - put in exception handling for low memory conditions

#include "precomp.hxx"

// uncomment this line to get the old behavior of putting up an upgrade
// dialog for auto-detected upgrades
//#define SHOWDETECTEDUPGRADEDIALOG

//IMalloc * g_pIMalloc = NULL;

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

void FreePlatformInfo(PLATFORMINFO * &ppiOut)
{
    if (ppiOut)
    {
        OLESAFE_DELETE(ppiOut->prgPlatform);
        OLESAFE_DELETE(ppiOut->prgLocale);
        OLESAFE_DELETE(ppiOut);
    }
}

HRESULT CopyPlatformInfo(PLATFORMINFO * &ppiOut, PLATFORMINFO * & ppiIn)
{
    if (NULL == ppiIn)
    {
        ppiOut = NULL;
        return S_OK;
    }
    UINT n;
    ppiOut = (PLATFORMINFO *)OLEALLOC(sizeof(PLATFORMINFO));
    if (!ppiOut)
    {
        goto out_of_memory;
    }
    memcpy(ppiOut, ppiIn, sizeof(PLATFORMINFO));
    ppiOut->prgPlatform = NULL;
    ppiOut->prgLocale = NULL;
    n = ppiIn->cPlatforms;
    if (n)
    {
        ppiOut->prgPlatform = (CSPLATFORM*) OLEALLOC(sizeof(CSPLATFORM) * n);
        if (!ppiOut->prgPlatform)
        {
            goto out_of_memory;
        }

        memcpy(ppiOut->prgPlatform, ppiIn->prgPlatform, sizeof(CSPLATFORM) * n);
    }
    n = ppiIn->cLocales;
    if (n)
    {
        ppiOut->prgLocale = (LCID *) OLEALLOC(sizeof(LCID) * n);
        if (!ppiOut->prgLocale)
        {
            goto out_of_memory;
        }
        memcpy(ppiOut->prgLocale, ppiIn->prgLocale, sizeof(LCID) * n);
    }
    return S_OK;
out_of_memory:
    FreePlatformInfo(ppiOut);
    return E_OUTOFMEMORY;
}

void FreeActInfo(ACTIVATIONINFO * &paiOut)
{
    if (paiOut)
    {
        if (paiOut->pClasses)
        {
            UINT n = paiOut->cClasses;
            while (n--)
            {
                OLESAFE_DELETE(paiOut->pClasses[n].prgProgId);
            }
            OLESAFE_DELETE(paiOut->pClasses);
        }
        OLESAFE_DELETE(paiOut->prgInterfaceId);
        OLESAFE_DELETE(paiOut->prgPriority);
        if (paiOut->prgShellFileExt)
        {
            UINT n = paiOut->cShellFileExt;
            while (n--)
            {
                OLESAFE_DELETE(paiOut->prgShellFileExt[n])
            }
            OLESAFE_DELETE(paiOut->prgShellFileExt);
        }
        OLESAFE_DELETE(paiOut->prgTlbId);
        OLESAFE_DELETE(paiOut);
    }
}

HRESULT CopyActInfo(ACTIVATIONINFO * & paiOut, ACTIVATIONINFO * & paiIn)
{
    if (NULL == paiIn)
    {
        paiOut = NULL;
        return S_OK;
    }
    UINT n;
    paiOut = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
    if (!paiOut)
    {
        goto out_of_memory;
    }
    memcpy(paiOut, paiIn, sizeof(ACTIVATIONINFO));
    paiOut->prgInterfaceId = NULL;
    paiOut->prgPriority = NULL;
    paiOut->prgShellFileExt = NULL;
    paiOut->prgTlbId = NULL;
    paiOut->pClasses = NULL;
    n = paiIn->cClasses;

    paiOut->bHasClasses = paiIn->bHasClasses;

    if (n)
    {
        paiOut->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
        if (!paiOut->pClasses)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->pClasses, paiIn->pClasses, sizeof(CLASSDETAIL) * n);
        while (n--)
        {
            UINT n2 = paiIn->pClasses[n].cProgId;
            if (n2)
            {
                paiOut->pClasses[n].prgProgId = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n2);
                if (!paiOut->pClasses[n].prgProgId)
                {
                    goto out_of_memory;
                }
                while (n2--)
                {
                    OLESAFE_COPYSTRING(paiOut->pClasses[n].prgProgId[n2], paiIn->pClasses[n].prgProgId[n2]);
                }
            }
        }
    }
    n = paiIn->cShellFileExt;
    if (n)
    {
        paiOut->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
        if (!paiOut->prgPriority)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgPriority, paiIn->prgPriority, sizeof(UINT) * n);
        paiOut->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        if (!paiOut->prgShellFileExt)
        {
            goto out_of_memory;
        }
        while (n--)
        {
            OLESAFE_COPYSTRING(paiOut->prgShellFileExt[n], paiIn->prgShellFileExt[n]);
        }
    }
    n = paiIn->cInterfaces;
    if (n)
    {
        paiOut->prgInterfaceId = (IID *) OLEALLOC(sizeof(IID) * n);
        if (!paiOut->prgInterfaceId)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgInterfaceId, paiIn->prgInterfaceId, sizeof(IID) * n);
    }
    n = paiIn->cTypeLib;
    if (n)
    {
        paiOut->prgTlbId = (GUID *) OLEALLOC(sizeof(GUID) * n);
        if (!paiOut->prgTlbId)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgTlbId, paiIn->prgTlbId, sizeof(GUID) * n);
    }
    return S_OK;
out_of_memory:
    FreeActInfo(paiOut);
    return E_OUTOFMEMORY;
}

void FreeInstallInfo(INSTALLINFO * &piiOut)
{
    if (piiOut)
    {
        if (piiOut->prgUpgradeInfoList)
        {
            UINT n = piiOut->cUpgrades;
            while (n--)
            {
                OLESAFE_DELETE(piiOut->prgUpgradeInfoList[n].szClassStore);
            }
            OLESAFE_DELETE(piiOut->prgUpgradeInfoList);
        }
        OLESAFE_DELETE(piiOut->pClsid);
        OLESAFE_DELETE(piiOut->pszScriptPath);
        OLESAFE_DELETE(piiOut->pszSetupCommand);
        OLESAFE_DELETE(piiOut->pszUrl);
        OLESAFE_DELETE(piiOut);
    }
}

HRESULT CopyInstallInfo(INSTALLINFO * & piiOut, INSTALLINFO * & piiIn)
{
    ULONG n;
    if (NULL == piiIn)
    {
        piiOut = NULL;
        return S_OK;
    }
    piiOut = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
    if (!piiOut)
    {
        goto out_of_memory;
    }
    memcpy(piiOut, piiIn, sizeof(INSTALLINFO));
    piiOut->pClsid = NULL;
    piiOut->prgUpgradeInfoList = NULL;
    piiOut->pszScriptPath = NULL;
    piiOut->pszSetupCommand = NULL;
    piiOut->pszUrl = NULL;
    OLESAFE_COPYSTRING(piiOut->pszScriptPath, piiIn->pszScriptPath);
    OLESAFE_COPYSTRING(piiOut->pszSetupCommand, piiIn->pszSetupCommand);
    OLESAFE_COPYSTRING(piiOut->pszUrl, piiIn->pszUrl);
    if (piiIn->pClsid)
    {
        piiOut->pClsid = (GUID *) OLEALLOC(sizeof(GUID));
        if (!piiOut->pClsid)
        {
            goto out_of_memory;
        }
        memcpy(piiOut->pClsid, piiIn->pClsid, sizeof(GUID));
    }
    n = piiIn->cUpgrades;
    if (n)
    {
        piiOut->prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);
        if (!piiOut->prgUpgradeInfoList)
        {
            goto out_of_memory;
        }
        memcpy(piiOut->prgUpgradeInfoList, piiIn->prgUpgradeInfoList, sizeof(UPGRADEINFO) * n);
        while (n--)
        {
            OLESAFE_COPYSTRING(piiOut->prgUpgradeInfoList[n].szClassStore, piiIn->prgUpgradeInfoList[n].szClassStore);
        }
    }
    return S_OK;
out_of_memory:
    FreeInstallInfo(piiOut);
    return E_OUTOFMEMORY;
}

void InternalFreePackageDetail(PACKAGEDETAIL * &ppdOut)
{
    if (ppdOut)
    {
        FreeActInfo(ppdOut->pActInfo);
        FreePlatformInfo(ppdOut->pPlatformInfo);
        FreeInstallInfo(ppdOut->pInstallInfo);
        OLESAFE_DELETE(ppdOut->pszPackageName);
        OLESAFE_DELETE(ppdOut->pszPublisher);
        if (ppdOut->pszSourceList)
        {
            UINT n = ppdOut->cSources;
            while (n--)
            {
                OLESAFE_DELETE(ppdOut->pszSourceList[n]);
            }
            OLESAFE_DELETE(ppdOut->pszSourceList);
        }
        OLESAFE_DELETE(ppdOut->rpCategory);
    }
}

HRESULT CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn)
{
    ULONG n;
    if (NULL == ppdIn)
    {
        ppdOut = NULL;
        return S_OK;
    }
    ppdOut = new PACKAGEDETAIL;
    if (!ppdOut)
    {
        goto out_of_memory;
    }
    memcpy(ppdOut, ppdIn, sizeof(PACKAGEDETAIL));
    ppdOut->pActInfo = NULL;
    ppdOut->pInstallInfo = NULL;
    ppdOut->pPlatformInfo = NULL;
    ppdOut->pszPackageName = NULL;
    ppdOut->pszPublisher = NULL;
    ppdOut->pszSourceList = NULL;
    ppdOut->rpCategory = NULL;
    OLESAFE_COPYSTRING(ppdOut->pszPackageName, ppdIn->pszPackageName);
    n = ppdIn->cSources;
    if (n)
    {
        ppdOut->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        if (!ppdOut->pszSourceList)
        {
            goto out_of_memory;
        }
        while (n--)
        {
            OLESAFE_COPYSTRING(ppdOut->pszSourceList[n], ppdIn->pszSourceList[n]);
        }
    }
    n = ppdIn->cCategories;
    if (n)
    {
        ppdOut->rpCategory = (GUID *)OLEALLOC(sizeof(GUID) * n);
        if (!ppdOut->rpCategory)
        {
            goto out_of_memory;
        }
        memcpy(ppdOut->rpCategory, ppdIn->rpCategory, sizeof(GUID) * n);
    }
    if FAILED(CopyActInfo(ppdOut->pActInfo, ppdIn->pActInfo))
        goto out_of_memory;
    if FAILED(CopyPlatformInfo(ppdOut->pPlatformInfo, ppdIn->pPlatformInfo))
        goto out_of_memory;
    if FAILED(CopyInstallInfo(ppdOut->pInstallInfo, ppdIn->pInstallInfo))
        goto out_of_memory;
    return S_OK;
out_of_memory:
    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
    InternalFreePackageDetail(ppdOut);
    if (ppdOut)
        delete ppdOut;
    return E_OUTOFMEMORY;
}

void FreePackageDetail(PACKAGEDETAIL * & ppd)
{
    if (ppd)
    {
        ReleasePackageDetail(ppd);
        delete ppd;
        ppd = NULL;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetUniquePackageName
//
//  Synopsis:   Returns a unique package name.
//
//  Arguments:  [sz] - [in]  the name of the package
//                     [out] the new name, guaranteed unique on this cs
//
//  History:    1-23-1998   stevebl   Created
//
//  Notes:      First the input name is checked for uniqueness.  If it is
//              already unique it is returned unchanged.  If it is not
//              unique then a new name is formed by adding " (2)" to the end
//              of the string, then " (3)" and " (4)" and so on until a
//              unique name is found.
//
//              If you don't want a number appended to the name, nHint must
//              be 1.
//
//              The value passed back in nHint will be the seed for the
//              next try.
//
//---------------------------------------------------------------------------

void CScopePane::GetUniquePackageName(CString szRoot, CString &szOut, int &nHint)
{
    map<MMC_COOKIE, CAppData>::iterator i;
    set<CString> sNames;
    int cch = szRoot.GetLength();
    for (i=m_AppData.begin(); i != m_AppData.end(); i++)
    {
        // As an optimization, I'm only going to add names that might match
        // this one to the set.
        LPOLESTR szName = i->second.m_pDetails->pszPackageName;
        if ((0 == wcsncmp(szRoot, szName, cch)) && (i->second.m_fVisible))
            sNames.insert(szName);
    }
    szOut = szRoot;
    if (nHint++ == 1) // try the first name
    {
        if (sNames.end() == sNames.find(szOut))
            return;
    }
    // now check for a match
    do
    {
        szOut.Format(L"%s (%i)", (LPCTSTR)szRoot, nHint++);
        if (sNames.end() == sNames.find(szOut))
        {
            // we are unique
            return;
        }
        // try a different name
    } while (TRUE);
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePand::GetDeploymentType
//
//  Synopsis:
//
//  Arguments:  [szPackagePath] -
//              [lpFileTitle]   -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetDeploymentType(PACKAGEDETAIL * ppd, BOOL & fShowPropertySheet)
{
    INSTALLINFO * pii = ppd->pInstallInfo;
    if (m_ToolDefaults.fUseWizard)
    {
        CDeployApp dlgDeployApp;
        // Turn on theme'ing for the dialog by activating the theme context
        CThemeContextActivator themer;
        
        dlgDeployApp.m_fMachine = m_fMachine;
        dlgDeployApp.m_fCrappyZaw = pii->PathType == SetupNamePath;
        if (IDCANCEL == dlgDeployApp.DoModal())
        {
            return E_FAIL;
        }
        switch (dlgDeployApp.m_iDeployment)
        {
        default:
        case 0: //published
            pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            break;
        case 1: // assigned
            pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            break;
        case 3: // disabled
            pii->dwActFlags = 0;
            break;
        case 2: // custom
            if (m_fMachine)
            {
                pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            else
            {
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            fShowPropertySheet = TRUE;
        }
    }
    else
    {
        switch (m_ToolDefaults.NPBehavior)
        {
        default:
        case NP_PUBLISHED:
            if (!m_fMachine)
            {
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                break;
            }
        case NP_ASSIGNED:
            if (pii->PathType != SetupNamePath)
            {
                pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            else
            {
                // Crappy ZAW app.. force it to be published.
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            break;
        case NP_DISABLED:
            pii->dwActFlags = 0;
            break;
        }
        if (m_ToolDefaults.fCustomDeployment)
        {
            fShowPropertySheet = TRUE;
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DeployPackage
//
//  Synopsis:
//
//  Arguments:  [hr] -
//              [hr] -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::DeployPackage(PACKAGEDETAIL * ppd, BOOL fShowPropertySheet)
{
    CHourglass hourglass;
    INSTALLINFO * pii = ppd->pInstallInfo;
    HRESULT hrDeploy = S_OK;
    hrDeploy = PrepareExtensions(*ppd);
    if (SUCCEEDED(hrDeploy))
    {
        DWORD dwRememberFlags;
        // put the entry in the class store
        if (fShowPropertySheet)
        {
            dwRememberFlags = pii->dwActFlags;
            pii->dwActFlags = 0; // disabled state
        }
        if (!m_pIClassAdmin)
        {
            hrDeploy = GetClassStore(TRUE);
            if (FAILED(hrDeploy))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_NOCLASSSTORE_ERROR, hrDeploy);
                DebugMsg((DM_WARNING, TEXT("GetClassStore failed with 0x%x"), hrDeploy));
            }
        }
        if (SUCCEEDED(hrDeploy))
        {
            hrDeploy = m_pIClassAdmin->AddPackage(ppd, &ppd->pInstallInfo->PackageGuid);
            if (FAILED(hrDeploy))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_ADDPACKAGE_ERROR, hrDeploy, ppd->pszPackageName);
                DebugMsg((DM_WARNING, TEXT("AddPackage failed with 0x%x"), hrDeploy));
            }
        }
        if (FAILED(hrDeploy))
        {
            return hrDeploy;
        }
        if (fShowPropertySheet)
        {
            pii->dwActFlags = dwRememberFlags; // restore state
        }
    }

    if (SUCCEEDED(hrDeploy))
    {
        CString szCSPath;
        hrDeploy = GetClassStoreName(szCSPath, FALSE);
        if (FAILED(hrDeploy))
        {
            DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hrDeploy));
            return hrDeploy;
        }

        CAppData data;

        hrDeploy = CopyPackageDetail(data.m_pDetails, ppd);
        if (FAILED(hrDeploy))
        {
            DebugMsg((DM_WARNING, TEXT("CopyPackageDetail failed with 0x%x"), hrDeploy));
            return hrDeploy;
        }

        data.InitializeExtraInfo();

        m_lLastAllocated++;

        // make sure that m_lLastAllocated hasn't already been used
        while (m_AppData.end() != m_AppData.find(m_lLastAllocated))
        {
            m_lLastAllocated++;
        }

        data.m_fVisible = FALSE;
        m_AppData[m_lLastAllocated] = data;

        BOOL fAddOk = TRUE;

        // The admin has said he wants to do a "custom" deployment.
        if (fShowPropertySheet)
        {
            HRESULT hr;     // errors that happen while setting up
                            // the property sheets are NOT to be
                            // reported as deployment errors.

            MMC_COOKIE cookie = m_lLastAllocated;

            PROPSHEETHEADER psh;
            memset(&psh, 0, sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_NOAPPLYNOW | PSH_PROPTITLE;
            psh.pszCaption = m_AppData[m_lLastAllocated].m_pDetails->pszPackageName;
            int nPage = 0;
            HPROPSHEETPAGE rgPages[6];
            psh.phpage = rgPages;

            //
            // Create the Product property page
            //
            CProduct prpProduct;
            prpProduct.m_fPreDeploy = TRUE;
            prpProduct.m_pData = &m_AppData[m_lLastAllocated];
            prpProduct.m_cookie = cookie;
            prpProduct.m_pScopePane = this;
            prpProduct.m_pAppData = &m_AppData;
            prpProduct.m_pIGPEInformation = m_pIGPEInformation;
            prpProduct.m_fMachine = m_fMachine;
            prpProduct.m_fRSOP = m_fRSOP;
            // no longer need to marshal this interface, just set it

            prpProduct.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpProduct.m_psp);

            //
            // Create the Depeployment property page
            //
            CDeploy prpDeploy;
            prpDeploy.m_fPreDeploy = TRUE;
            prpDeploy.m_pData = &m_AppData[m_lLastAllocated];
            prpDeploy.m_cookie = cookie;
            prpDeploy.m_fMachine = m_fMachine;
            prpDeploy.m_fRSOP = m_fRSOP;
            prpDeploy.m_pScopePane = this;
#if 0
            prpDeploy.m_pIGPEInformation = m_pIGPEInformation;
#endif

            // no longer need to marshal this interface, just set it
            prpDeploy.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpDeploy.m_psp);

            CUpgradeList prpUpgradeList;
            if (pii->PathType != SetupNamePath)
            {
                //
                // Create the upgrades property page
                //
                prpUpgradeList.m_pData = &m_AppData[m_lLastAllocated];
                prpUpgradeList.m_cookie = cookie;
                prpUpgradeList.m_pScopePane = this;
                prpUpgradeList.m_fPreDeploy = TRUE;
                prpUpgradeList.m_fMachine = m_fMachine;
                prpUpgradeList.m_fRSOP = m_fRSOP;
#if 0
                prpUpgradeList.m_pIGPEInformation = m_pIGPEInformation;
#endif

                // no longer need to marshal the interface, just set it
                prpUpgradeList.m_pIClassAdmin = m_pIClassAdmin;
                m_pIClassAdmin->AddRef();

                rgPages[nPage++] = CreateThemedPropertySheetPage(&prpUpgradeList.m_psp);
            }

            //
            // make sure we have an up-to-date categories list
            //
            ClearCategories();
            hr = CsGetAppCategories(&m_CatList);
            if (FAILED(hr))
            {
                // report it
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

                // Since failure only means the categories list will be
                // empty, we'll proceed as if nothing happened.

                hr = S_OK;
            }

            //
            // Create the Category property page
            //
            CCategory prpCategory;
            prpCategory.m_pData = &m_AppData[m_lLastAllocated];
            prpCategory.m_cookie = cookie;
            prpCategory.m_pCatList = &m_CatList;
            prpCategory.m_fRSOP = m_fRSOP;
            prpCategory.m_fPreDeploy = TRUE;

            // no longer need to marshal this interface, just set it
            prpCategory.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpCategory.m_psp);

            CXforms prpXforms;
            if (pii->PathType != SetupNamePath)
            {
                //
                // Create the Xforms property page
                //
                prpXforms.m_fPreDeploy = TRUE;
                prpXforms.m_pData = &m_AppData[m_lLastAllocated];
                prpXforms.m_cookie = cookie;
                prpXforms.m_pScopePane = this;

                // no longer need to marshal the interface, just set it
                prpXforms.m_pIClassAdmin = m_pIClassAdmin;
                m_pIClassAdmin->AddRef();

                rgPages[nPage++] = CreateThemedPropertySheetPage(&prpXforms.m_psp);
            }

            //
            // Create the security property page
            //

            CString szPath;
            hr = GetPackageDSPath(szPath, m_AppData[m_lLastAllocated].m_pDetails->pszPackageName);
            if (SUCCEEDED(hr))
            {
                LPSECURITYINFO pSI;
                hr = DSCreateISecurityInfoObject(szPath,
                                                 NULL,
                                                 0,
                                                 &pSI,
                                                 NULL,
                                                 NULL,
                                                 0);
                if (SUCCEEDED(hr))
                {
                    rgPages[nPage++] = CreateSecurityPage(pSI);
                    pSI->Release();
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("DSCreateISecurityInfoObject failed with 0x%x"), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetPackageDSPath failed with 0x%x"), hr));
            }
            psh.nPages = nPage;
            psh.hwndParent = m_hwndMainWindow;

            if (IDOK != PropertySheet(&psh))
            {
                fAddOk = FALSE;
                RemovePackage(cookie, FALSE, TRUE);
            }
            else
            {
                // Make sure that the package is deployed with the proper
                // deployment type
                hr = m_pIClassAdmin->ChangePackageProperties(m_AppData[m_lLastAllocated].m_pDetails->pszPackageName,
                                                             NULL,
                                                             &m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->dwActFlags,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL);
                if (SUCCEEDED(hr))
                {
                    if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                      m_fMachine ? &guidMachSnapin
                                                                 : &guidUserSnapin )))
                    {
                        ReportPolicyChangedError(m_hwndMainWindow);
                    }
                }

            }
        }

        if (fAddOk)
        {
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                RESULTDATAITEM resultItem;
                memset(&resultItem, 0, sizeof(resultItem));

                if ((*i)->_fVisible)
                {
                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = m_AppData[m_lLastAllocated].GetImageIndex(this);
                    resultItem.lParam = m_lLastAllocated;
                    hrDeploy = (*i)->m_pResult->InsertItem(&resultItem);
                }

                // The following code must be excecuted wheather the InsertItem
                // call succeeds or not.
                // There are legitimate cases when InsertItem will fail.  For
                // instance, if the scope pane is being shown, but not the
                // result pane.

                m_AppData[m_lLastAllocated].m_fVisible = TRUE;
                m_AppData[m_lLastAllocated].m_itemID = resultItem.itemID;
                InsertExtensionEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                if (m_pFileExt)
                {
                    m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                }
                InsertUpgradeEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                m_UpgradeIndex[GetUpgradeIndex(m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->PackageGuid)] = m_lLastAllocated;
                // if this is an upgrade, set icons for upgraded apps to
                // the proper icon and refresh any open property sheets
                UINT n = m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->cUpgrades;
                while (n--)
                {
                    map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
                    if (i != m_UpgradeIndex.end())
                    {
                        if (m_AppData[i->second].m_pUpgradeList)
                        {
                            m_AppData[i->second].m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
                        }
                    }
                }


                if ((*i)->_fVisible)
                {
                    if (SUCCEEDED(hrDeploy))
                    {
                        (*i)->m_pResult->SetItem(&resultItem);
                        (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("InsertItem failed with 0x%x"), hrDeploy));
                        hrDeploy = S_OK;
                    }
                }
            }
        }
    }
    return hrDeploy;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::AddZAPPackage
//
//  Synopsis:
//
//  Arguments:  [szPackagePath] -
//              [lpFileTitle]   -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::AddZAPPackage(LPCOLESTR szPackagePath, LPCOLESTR lpFileTitle)
{
    CHourglass hourglass;
    HRESULT hr = E_FAIL;

    OLECHAR szBuffer[1024];
    OLECHAR * sz = szBuffer;
    CString szFriendlyName;
    CString szUniqueFriendlyName;
    int nHint = 1;
    DWORD dw = GetPrivateProfileString(
                    L"Application",
                    L"FriendlyName",
                    NULL,
                    sz,
                    sizeof(szBuffer) / sizeof(szBuffer[0]),
                    szPackagePath);
    if (0 == dw)
    {
        // either bogus FriendlyName or no setup command, both of which are fatal
        goto bad_script;
    }
    szFriendlyName = sz;    // save this for later

    dw = GetPrivateProfileString(
                    L"Application",
                    L"SetupCommand",
                    NULL,
                    sz,
                    sizeof(szBuffer) / sizeof(szBuffer[0]),
                    szPackagePath);
    if (0 == dw)
    {
        // either bogus file or no setup command, both of which are fatal
bad_script:
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADZAP_ERROR, HRESULT_FROM_WIN32(dw), lpFileTitle);
            TCHAR szBadScriptBuffer[256];
            ::LoadString(ghInstance, IDS_ADDFAILED_ZAP, szBadScriptBuffer, 256);
            m_pConsole->MessageBox(szBadScriptBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);
        }
        return E_FAIL;
    }
    INSTALLINFO * pii = NULL;
    PLATFORMINFO * ppi = NULL;
    ACTIVATIONINFO * pai = NULL;
    PACKAGEDETAIL  *ppd = new PACKAGEDETAIL;
    if (!ppd)
    {
        goto out_of_memory;
    }
    memset(ppd, 0, sizeof(PACKAGEDETAIL));
    pii = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
    ppd->pInstallInfo = pii;
    if (!pii)
    {
        goto out_of_memory;
    }
    memset(pii, 0, sizeof(INSTALLINFO));
    ppi = (PLATFORMINFO *) OLEALLOC(sizeof(PLATFORMINFO));
    ppd->pPlatformInfo = ppi;
    if (!ppi)
    {
        goto out_of_memory;
    }
    memset(ppi, 0, sizeof(PLATFORMINFO));
    pai = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
    ppd->pActInfo = pai;
    if (!pai)
    {
        goto out_of_memory;
    }
    else
    {
        memset(pai, 0, sizeof(ACTIVATIONINFO));

        pai->bHasClasses = ! m_ToolDefaults.fExtensionsOnly;

        // Munge the setup path.
        // surround the path in quotes to be sure that spaces are dealt
        // with properly
        CString szPath = L'"';
        szPath += szPackagePath;
        // strip off the package name
        int ich = szPath.ReverseFind(L'\\');
        // check for either slash symbol (just in case)
        int ich2 = szPath.ReverseFind(L'/');
        if (ich2 > ich)
        {
            ich = ich2;
        }
        if (ich >= 0)
        {
            szPath = szPath.Left(ich + 1); // keep the path separator
        }

        // merge it with the setup command string
        BOOL fNeedQuote = TRUE;
        if (sz[0] == L'"')
        {
            // remember that we had a leading quote (no need to insert a quote)
            // and strip it off
            sz++;
            fNeedQuote = FALSE;
        }
        while (sz[0])
        {
            if (sz[0] == L'.' && sz[1] == L'.' && (sz[2] == L'/' || sz[2] == L'\\'))
            {
                // strip off the last path element
                // First strip off the path separator (the one we kept previously)
                szPath = szPath.Left(ich);
                // now find the symbol
                ich = szPath.ReverseFind(L'\\');
                // check for either slash symbol (just in case)
                ich2 = szPath.ReverseFind(L'/');
                if (ich2 > ich)
                {
                    ich = ich2;
                }
                if (ich >= 0)
                {
                    szPath = szPath.Left(ich + 1); // keep the path separator
                }
                // skip the "..\"
                sz += 3;
            }
            else
            {
                if ((0 != sz[0] && L':' == sz[1])
                    ||
                    ((L'\\' == sz[0] || L'/' == sz[0]) && (L'\\' == sz[1] || L'/' == sz[1]))
                    ||
                    (0 == wcsncmp(L"http:",sz,5)))
                {
                    // hard path
                    // throw away szPath;
                    szPath = L"";
                    if (!fNeedQuote)
                    {
                        // make sure we don't drop that quote
                        szPath += L'"';
                    }
                    // and make sure we don't insert quotes where they're not wanted
                    fNeedQuote = FALSE;
                }
                // break the loop on anything other than "..\"
                break;
            }
        }

        if (fNeedQuote)
        {
            CString szTemp = sz;
            // copy everything up to the first space
            ich = szTemp.Find(L' ');
            szPath += szTemp.Left(ich);
            // then add a quote
            szPath += L'"';
            szPath += szTemp.Mid(ich);
        }
        else
        {
            szPath += sz;
        }

        OLESAFE_COPYSTRING(pii->pszScriptPath, szPath);

        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"Application",
                        L"DisplayVersion",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            // parse product version
            CString szProdVersion = szBuffer;
            szProdVersion.TrimLeft();
            CString szTemp = szProdVersion.SpanIncluding(L"0123456789");
            (void) swscanf(szTemp, L"%u", &pii->dwVersionHi);
            szProdVersion = szProdVersion.Mid(szTemp.GetLength());
            szTemp = szProdVersion.SpanExcluding(L"0123456789");
            szProdVersion = szProdVersion.Mid(szTemp.GetLength());
            (void) swscanf(szProdVersion, L"%u", &pii->dwVersionLo);
        }

        dw = GetPrivateProfileString(
                        L"Application",
                        L"Publisher",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            OLESAFE_COPYSTRING(ppd->pszPublisher, sz);
        }

        dw = GetPrivateProfileString(
                        L"Application",
                        L"URL",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            OLESAFE_COPYSTRING(pii->pszUrl, sz);
        }

        set<DWORD> sPlatforms;
        dw = GetPrivateProfileString(
                        L"Application",
                        L"Architecture",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);

        BOOL fValidPlatform;

        fValidPlatform = FALSE;

        if (dw)
        {
            CString szPlatforms = szBuffer;
            CString szTemp;
            while (szPlatforms.GetLength())
            {
                szTemp = szPlatforms.SpanExcluding(L",");
                if (0 == szTemp.CompareNoCase(L"intel"))
                {
                    sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                    fValidPlatform = TRUE;
                }
                else if (0 == szTemp.CompareNoCase(L"amd64"))
                {
                    sPlatforms.insert(PROCESSOR_ARCHITECTURE_AMD64);
                    fValidPlatform = TRUE;
                }
                else if (0 == szTemp.CompareNoCase(L"intel64"))
                {
                    sPlatforms.insert(PROCESSOR_ARCHITECTURE_IA64);
                    fValidPlatform = TRUE;
                }
                szPlatforms = szPlatforms.Mid(szTemp.GetLength()+1);
            }
        }

        //
        // Ensure that if we saw any platforms, at least one of them
        // was a supported platform
        //
        if ( dw && ! fValidPlatform )
        {
            ::LoadString(ghInstance, IDS_ILLEGAL_PLATFORM, szBuffer, 256);
            m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);

            delete ppd;

            return E_FAIL;
        }

        if (0 == sPlatforms.size())
        {
            // If the ZAP file doesn't specify an architecture
            // then we'll treat is as an x86 package
            sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
            DebugMsg((DL_VERBOSE, TEXT("No platform detected, assuming x86.")));
        }
        ppi->cPlatforms = sPlatforms.size();
        ppi->prgPlatform = (CSPLATFORM *) OLEALLOC(sizeof(CSPLATFORM) * (ppi->cPlatforms));;
        if (!ppi->prgPlatform)
        {
            ppi->cPlatforms = 0;
            goto out_of_memory;
        }

        INT iIndex=0;
        set<DWORD>::iterator iPlatform;

        for (iPlatform = sPlatforms.begin(); iPlatform != sPlatforms.end(); iPlatform++, iIndex++)
        {
            ppi->prgPlatform[iIndex].dwPlatformId = VER_PLATFORM_WIN32_NT;
            ppi->prgPlatform[iIndex].dwVersionHi = 5;
            ppi->prgPlatform[iIndex].dwVersionLo = 0;
            ppi->prgPlatform[iIndex].dwProcessorArch = *iPlatform;
        }


        ppi->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
        if (!ppi->prgLocale)
        {
            goto out_of_memory;
        }
        ppi->cLocales = 1;
        ppi->prgLocale[0] = 0; // if none is supplied we assume language neutral

        dw = GetPrivateProfileString(
                        L"Application",
                        L"LCID",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            (void) swscanf(szBuffer, L"%i", &ppi->prgLocale[0]);
            // we only deploy one LCID (the primary one)
        }

        // Get the list of extensions
        dw = GetPrivateProfileString(
                        L"ext",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            vector<CString> v;
            TCHAR szName[256];
            while (sz < &szBuffer[dw])
            {
                while ('.' == sz[0])
                    sz++;
                CString szExt = ".";
                szExt += sz;
                v.push_back(szExt);
                sz += (wcslen(sz) + 1);
            }
            // build the new list
            UINT n = v.size();
            if (n > 0)
            {
                pai->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
                if (!pai->prgShellFileExt)
                {
                    goto out_of_memory;
                }
                pai->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
                if (!pai->prgPriority)
                {
                    goto out_of_memory;
                }
                pai->cShellFileExt = n;
                while (n--)
                {
                    CString &szLower = v[n];
                    szLower.MakeLower();
                    OLESAFE_COPYSTRING(pai->prgShellFileExt[n], szLower);
                    pai->prgPriority[n] = 0;
                }
            }
        }

        // get the list of CLSIDs
        vector<CLASSDETAIL> v;
        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"CLSIDs",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            while (sz < &szBuffer[dw])
            {
                OLECHAR szType[256];
                DWORD dwSubKey = GetPrivateProfileString(
                        L"CLSIDs",
                        sz,
                        NULL,
                        szType,
                        sizeof(szType) / sizeof(szType[0]),
                        szPackagePath);
                CLASSDETAIL cd;
                memset(&cd, 0, sizeof(CLASSDETAIL));
                hr = CLSIDFromString(sz, &cd.Clsid);
                if (SUCCEEDED(hr))
                {
                    CString szTypes = szType;
                    szTypes.MakeLower();
                    if (szTypes.Find(L"inprocserver32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_INPROC_SERVER;
                    }
                    if (szTypes.Find(L"localserver32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_LOCAL_SERVER;
                    }
                    if (szTypes.Find(L"inprochandler32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_INPROC_HANDLER;
                    }
                    v.push_back(cd);
                }
                sz += (wcslen(sz) + 1);
            }
        }

        // get the list of ProgIDs
        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"ProgIDs",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            while (sz < &szBuffer[dw])
            {
                OLECHAR szType[256];
                DWORD dwSubKey = GetPrivateProfileString(
                        L"ProgIDs",
                        sz,
                        NULL,
                        szType,
                        sizeof(szType) / sizeof(szType[0]),
                        szPackagePath);
                CLSID cid;
                hr = CLSIDFromString(sz, &cid);
                if (SUCCEEDED(hr))
                {
                    // Match it to its CLASSDETAIL structure and insert it into the
                    // ProgID list.
                    // (fat and slow method)
                    vector<CLASSDETAIL>::iterator i;
                    for (i = v.begin(); i != v.end(); i++)
                    {
                        if (0 == memcmp(&i->Clsid, &cid, sizeof(CLSID)))
                        {
                            // found a match
                            // hereiam
                            vector <CString> vIds;
                            CString szAppIds = szType;
                            CString szTemp;
                            while (szAppIds.GetLength())
                            {
                                szTemp = szAppIds.SpanExcluding(L",");
                                szTemp.TrimLeft();
                                vIds.push_back(szTemp);
                                szAppIds = szAppIds.Mid(szTemp.GetLength()+1);
                            }
                            while (i->cProgId--)
                            {
                                OLESAFE_DELETE(i->prgProgId[i->cProgId]);
                            }
                            OLESAFE_DELETE(i->prgProgId);
                            DWORD cProgId = vIds.size();
                            LPOLESTR * prgProgId = (LPOLESTR *)
                                OLEALLOC(sizeof(LPOLESTR) * (cProgId));
                            if (!prgProgId)
                            {
                                goto out_of_memory;
                            }
                            i->cProgId = cProgId;
                            while (cProgId--)
                            {
                                OLESAFE_COPYSTRING(prgProgId[cProgId], vIds[cProgId]);
                            }
                            i->prgProgId = prgProgId;
                        }
                    }
                }
                sz += (wcslen(sz) + 1);
            }
        }

        // create the list of CLASSDETAIL structures
        {
            UINT n = v.size();
            if (n > 0)
            {
                pai->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
                if (!pai->pClasses)
                {
                    goto out_of_memory;
                }
                pai->cClasses = n;
                while (n--)
                {
                    pai->pClasses[n] = v[n];
                }
            }
        }

        ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR));
        if (!ppd->pszSourceList)
        {
            goto out_of_memory;
        }
        ppd->cSources = 1;
        OLESAFE_COPYSTRING(ppd->pszSourceList[0], szPackagePath);

        GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
        OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);

        // Popup UI
        pii->PathType = SetupNamePath;

        BOOL fShowPropertyPage = FALSE;

        hr = GetDeploymentType(ppd, fShowPropertyPage);

        if (SUCCEEDED(hr))
        {
            CHourglass hourglass;
            if (m_ToolDefaults.fZapOn64)
            {
                pii->dwActFlags |= ACTFLG_ExcludeX86OnWin64; // same as ACTFLG_ZAP_IncludeX86OfWin64
            }
            do
            {
                hr = DeployPackage(ppd, fShowPropertyPage);
                if (hr == CS_E_OBJECT_ALREADY_EXISTS)
                {
                    OLESAFE_DELETE(ppd->pszPackageName);
                    GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                    OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);
                }
            } while (hr == CS_E_OBJECT_ALREADY_EXISTS);
        }

        if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
                                        // because it's a benign error
                                        // (probably a dialog cancellation)
        {
            // report the error in the event log
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_DEPLOYMENT_ERROR, hr, lpFileTitle);

            // now try to come up with a meaningful message for the user

            if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
            {
                // access permission failure
                ::LoadString(ghInstance, IDS_ADDFAILED_ACCESS_DENIED, szBuffer, 256);
            }
            else
            {
                switch (hr)
                {
                // For these errors, we'll report the party line:
                case CS_E_CLASS_NOTFOUND:
                case CS_E_INVALID_VERSION:
                case CS_E_NO_CLASSSTORE:
                case CS_E_OBJECT_NOTFOUND:
                case CS_E_OBJECT_ALREADY_EXISTS:
                case CS_E_INVALID_PATH:
                case CS_E_NETWORK_ERROR:
                case CS_E_ADMIN_LIMIT_EXCEEDED:
                case CS_E_SCHEMA_MISMATCH:
                case CS_E_PACKAGE_NOTFOUND:
                case CS_E_INTERNAL_ERROR:
                    {
                        dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                           NULL,
                                           hr,
                                           0,
                                           szBuffer,
                                           sizeof(szBuffer) / sizeof(szBuffer[0]),
                                           NULL);
                        if (0 != dw)
                        {
                            // got a valid message string
                            break;
                        }
                        // otherwise fall through and give the generic message
                    }
                // Either these CS errors don't apply or an admin
                // wouldn't know what they mean:
                case CS_E_NOT_DELETABLE:
                default:
                    // generic class store problem
                    ::LoadString(ghInstance, IDS_ADDFAILED_CSFAILURE, szBuffer, 256);
                    break;
                }
            }
    #if DBG
            TCHAR szDebugBuffer[256];
            dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               hr,
                               0,
                               szDebugBuffer,
                               sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                               NULL);
            if (0 == dw)
            {
                (void) StringCchPrintf(szDebugBuffer, 
                                       sizeof(szDebugBuffer)/sizeof(szDebugBuffer[0]),
                                       TEXT("(HRESULT: 0x%lX)"), 
                                       hr);
            }
            (void) StringCchCat(szBuffer, 
                                sizeof(szBuffer) / sizeof(szBuffer[0]),
                                szDebugBuffer);
    #endif
            m_pConsole->MessageBox(szBuffer,
                               lpFileTitle,
                               MB_OK | MB_ICONEXCLAMATION, NULL);
        }
        FreePackageDetail(ppd);
    }

    return hr;
out_of_memory:
    if (ppd)
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
        InternalFreePackageDetail(ppd);
        delete ppd;
    }
    return E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::AddMSIPackage
//
//  Synopsis:   Add's one or more packages to the class store and adds the
//              appropriate entries to the result pane.
//
//  Arguments:  [szPackagePath] - Full path to the Darwin package.
//              [lpFileTitle]   - file title from the open file dialog (used
//                                 for UI)
//
//  Returns:    S_OK    - succeeded
//              E_FAIL  - benign failure (probably a cancellation or something)
//              other   - significant failure
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::AddMSIPackage(LPCOLESTR szPackagePath, LPCOLESTR lpFileTitle)
{
    CHourglass hourglass;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = E_FAIL;
    BOOL fPreparationDone = FALSE;  // Used to identify if the routine has
                                    // progressed passed the "prep" stage
                                    // and is now in the deployment stage.
                                    // Errors in the earlier part are most
                                    // likely due to Darwin problems.
                                    // Errors in teh latter part are most
                                    // likely due to Class Store problems.
    set<LCID> sLocales;
    CUpgrades dlgUpgrade;
    int nLocales;
    set<LCID>::iterator iLocale;
    PACKAGEDETAIL  *ppd = NULL;
    CString szFriendlyName;
    CString szUniqueFriendlyName;
    int nHint = 1;

    ASSERT(m_pConsole);
    {
        BOOL fShowPropertySheet = FALSE;
        GUID guid;
        INSTALLINFO *pii = NULL;
        PLATFORMINFO *ppi = NULL;
        ACTIVATIONINFO *pai = NULL;
        ppd = new PACKAGEDETAIL;
        if (!ppd)
        {
            goto out_of_memory;
        }
        memset(ppd, 0, sizeof(PACKAGEDETAIL));
        pii = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
        if (!pii)
        {
            goto out_of_memory;
        }
        memset(pii, 0, sizeof(INSTALLINFO));
        ppi = (PLATFORMINFO *) OLEALLOC(sizeof(PLATFORMINFO));
        ppd->pPlatformInfo = ppi;
        if (!ppi)
        {
            goto out_of_memory;
        }
        ppd->pInstallInfo = pii;
        memset(ppi, 0, sizeof(PLATFORMINFO));
        pai = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
        ppd->pActInfo = pai;
        if (!pai)
        {
            goto out_of_memory;
        }
        else
        {
            memset(pai, 0, sizeof(ACTIVATIONINFO));

            pai->bHasClasses = ! m_ToolDefaults.fExtensionsOnly;

            pii->PathType = DrwFilePath;

            hr = GetDeploymentType(ppd, fShowPropertySheet);
            CHourglass hourglass;
            if (FAILED(hr))
            {
                goto done;
            }
            if (!m_ToolDefaults.f32On64)
            {
                pii->dwActFlags |= ACTFLG_ExcludeX86OnWin64; // same as ACTFLG_ZAP_IncludeX86OfWin64
            }
            if (m_ToolDefaults.fUninstallOnPolicyRemoval)
            {
                pii->dwActFlags |= ACTFLG_UninstallOnPolicyRemoval;
            }
            else
            {
                pii->dwActFlags |= ACTFLG_OrphanOnPolicyRemoval;
            }
            if (m_fMachine)
            {
                pii->dwActFlags |= ACTFLG_ForceUpgrade;
            }
            pii->InstallUiLevel = m_ToolDefaults.UILevel;

            // disable MSI ui
            MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

            // Use MsiSummaryInfoGetProperty to get platform and locale info.
            {
                MSIHANDLE hSummaryInfo;
                UINT msiReturn = MsiGetSummaryInformation(0, szPackagePath, 0, &hSummaryInfo);
                if (ERROR_SUCCESS == msiReturn)
                {
                    TCHAR szBuffer[256];
                    DWORD dwSize = 256;
                    msiReturn = MsiSummaryInfoGetProperty(hSummaryInfo,
                                                          7, // PID_TEMPLATE
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          szBuffer,
                                                          &dwSize);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        // break out the locale and platform properties
                        CString szLocales = szBuffer;
                        CString szPlatforms = szLocales.SpanExcluding(L";");
                        szLocales = szLocales.Mid(szPlatforms.GetLength()+1);
                        CString szTemp;
                        set<DWORD> sPlatforms;
                        BOOL       fValidPlatform;
                        BOOL       fPlatformsSpecified;

                        fValidPlatform = FALSE;

                        fPlatformsSpecified = 0 != szPlatforms.GetLength();

                        while (szPlatforms.GetLength())
                        {
                            szTemp = szPlatforms.SpanExcluding(L",");
                            if (0 == szTemp.CompareNoCase(L"intel"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                                fValidPlatform = TRUE;
                            }
                            else if (0 == szTemp.CompareNoCase(L"amd64"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_AMD64);
                                fValidPlatform = TRUE;
                            }
                            else if (0 == szTemp.CompareNoCase(L"intel64"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_IA64);
                                fValidPlatform = TRUE;
                            }
                            szPlatforms = szPlatforms.Mid(szTemp.GetLength()+1);
                        }

                        //
                        // If platforms have been specified, at least one of them
                        // must be valid
                        //
                        if ( fPlatformsSpecified && ! fValidPlatform )
                        {
                            hr = HRESULT_FROM_WIN32( ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                            ppi->cPlatforms = 0;
                            goto done;
                        }

                        while (szLocales.GetLength())
                        {
                            szTemp = szLocales.SpanExcluding(L",");
                            LCID lcid;
                            
                            if (swscanf(szTemp, L"%i", &lcid) != EOF) 
                            {
                                sLocales.insert(lcid);
                                szLocales = szLocales.Mid(szTemp.GetLength()+1);
                            }
                        }
                        if (0 == sPlatforms.size())
                        {
                            // If the MSI file doesn't specify an architecture
                            // then we'll mark it X86-allow on Win64.
                            sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                            pii->dwActFlags &= ~ACTFLG_ExcludeX86OnWin64;
                            DebugMsg((DL_VERBOSE, TEXT("No platform detected, setting to X86 - allow on Win64.")));
                        }
                        if (0 == sLocales.size())
                        {
                            // If the MSI file doesn't specify a locale then
                            // we'll just assume it's language neutral.
                            DebugMsg((DL_VERBOSE, TEXT("No locale detected, assuming neutral.")));
                            sLocales.insert(0);
                        }
                        ppi->cPlatforms = sPlatforms.size();
                        ppi->prgPlatform = (CSPLATFORM *) OLEALLOC(sizeof(CSPLATFORM) * (ppi->cPlatforms));;
                        if (!ppi->prgPlatform)
                        {
                            ppi->cPlatforms = 0;
                            goto out_of_memory;
                        }
                        set<DWORD>::iterator iPlatform;
                        INT n = 0;
                        for (iPlatform = sPlatforms.begin(); iPlatform != sPlatforms.end(); iPlatform++, n++)
                        {
                            ppi->prgPlatform[n].dwPlatformId = VER_PLATFORM_WIN32_NT;
                            ppi->prgPlatform[n].dwVersionHi = 5;
                            ppi->prgPlatform[n].dwVersionLo = 0;
                            ppi->prgPlatform[n].dwProcessorArch = *iPlatform;
                        }
                    }
                    MsiCloseHandle(hSummaryInfo);
                }
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
            }
            {
                // Grovel through the database to get additional information
                // that for some reason MSI won't give us any other way.
                TCHAR szBuffer[256];
                DWORD cch = 256;
                UINT msiReturn = GetMsiProperty(szPackagePath, L"ProductVersion", szBuffer, &cch);
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
                if (ERROR_SUCCESS == msiReturn)
                {
                    // Parse Product Version
                    CString sz = szBuffer;
                    sz.TrimLeft();
                    CString szTemp = sz.SpanIncluding(L"0123456789");
                    
                    if (swscanf(szTemp, L"%u", &pii->dwVersionHi) == EOF) 
                    {
                        hr =  HRESULT_FROM_WIN32(GetLastError());
                        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                        goto done;
                    }

                    sz = sz.Mid(szTemp.GetLength());
                    szTemp = sz.SpanExcluding(L"0123456789");
                    sz = sz.Mid(szTemp.GetLength());
                    
                    if (swscanf(sz, L"%u", &pii->dwVersionLo) == EOF) 
                    {
                        hr =  HRESULT_FROM_WIN32(GetLastError());
                        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                        goto done;
                    }
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"ProductCode", szBuffer, &cch);
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
                if (ERROR_SUCCESS == msiReturn)
                {
                    // Parse Product Code
                    CLSIDFromString(szBuffer, &pii->ProductCode);
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"ARPHELPLINK", szBuffer, &cch);
                if (ERROR_SUCCESS == msiReturn)
                {
                    OLESAFE_COPYSTRING(pii->pszUrl, szBuffer);
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"LIMITUI", szBuffer, &cch);
                if (ERROR_SUCCESS == msiReturn)
                {
                    pii->dwActFlags |= ACTFLG_MinimalInstallUI;
                    pii->InstallUiLevel = INSTALLUILEVEL_BASIC;
                }
            }
            ppi->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
            if (!ppi->prgLocale)
            {
                goto out_of_memory;
            }
            ppi->cLocales = 1;
            ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR));
            if (!ppd->pszSourceList)
            {
                goto out_of_memory;
            }
            ppd->cSources = 1;
            OLESAFE_COPYSTRING(ppd->pszSourceList[0], szPackagePath);

            if (S_OK == DetectUpgrades(szPackagePath, ppd, dlgUpgrade))
            {
                UINT n = dlgUpgrade.m_UpgradeList.size();
                if (n)
                {
                    pii->prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);
                    if (!pii->prgUpgradeInfoList)
                    {
                        goto out_of_memory;
                    }
                    pii->cUpgrades = n;
                    map<CString, CUpgradeData>::iterator i = dlgUpgrade.m_UpgradeList.begin();
                    while (n--)
                    {
                        pii->prgUpgradeInfoList[n].Flag = i->second.m_flags;
                        OLESAFE_COPYSTRING(pii->prgUpgradeInfoList[n].szClassStore, i->second.m_szClassStore);
                        memcpy(&pii->prgUpgradeInfoList[n].PackageGuid, &i->second.m_PackageGuid, sizeof(GUID));
                        i++;
                    }
                }
            }

            //
            // Only one locale may be specified for this package
            //
            nLocales = 1;
            iLocale = sLocales.begin();

            {
                ppi->prgLocale[0] = *iLocale;

                // set the script path
                hr = CoCreateGuid(&guid);
                if (FAILED(hr))
                {
                    goto done;
                }
                OLECHAR sz [256];
                StringFromGUID2(guid, sz, 256);
                CString szScriptPath = m_szGPT_Path;
                szScriptPath += L"\\";
                szScriptPath += sz;
                szScriptPath += L".aas";
                OLESAFE_DELETE(pii->pszScriptPath);
                OLESAFE_COPYSTRING(pii->pszScriptPath, szScriptPath);

                HWND hwnd;
                m_pConsole->GetMainWindow(&hwnd);
                hr = BuildScriptAndGetActInfo(*ppd, m_ToolDefaults.fExtensionsOnly);

                // make sure the name is unique
                szFriendlyName = ppd->pszPackageName;
                GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);

                if (SUCCEEDED(hr))
                {
                    fPreparationDone = TRUE;
                    do
                    {
                        hr = DeployPackage(ppd, fShowPropertySheet);
                        if (hr == CS_E_OBJECT_ALREADY_EXISTS)
                        {
                            GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                            OLESAFE_DELETE(ppd->pszPackageName);
                            OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);
                        }
                    } while (hr == CS_E_OBJECT_ALREADY_EXISTS);
                }
                if (FAILED(hr))
                {
                    // clean up script file if deployment fails
                    DeleteFile(pii->pszScriptPath);
                }
            }
        done:
            if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
                                            // because it's a benign error
                                            // (probably a dialog cancellation)
            {
                // report the error in the event log
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_DEPLOYMENT_ERROR, hr, lpFileTitle);

                TCHAR szBuffer[256];
                if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                {
                    // access permission failure
                    ::LoadString(ghInstance, IDS_ADDFAILED_ACCESS_DENIED, szBuffer, 256);
                }
                else if ( HRESULT_FROM_WIN32( ERROR_INSTALL_PLATFORM_UNSUPPORTED ) == hr )
                {
                    ::LoadString(ghInstance, IDS_ILLEGAL_PLATFORM, szBuffer, 256);
                }
                else if ( HRESULT_FROM_WIN32( CS_E_ADMIN_LIMIT_EXCEEDED ) == hr )
                {
                    ::LoadString(ghInstance, IDS_ADDFAILED_METADATA_OVERFLOW, szBuffer, 256);
                }
                else
                {
                    if (fPreparationDone)
                    {
                        switch (hr)
                        {
                        // For these errors, we'll report the party line:
                        case CS_E_CLASS_NOTFOUND:
                        case CS_E_INVALID_VERSION:
                        case CS_E_NO_CLASSSTORE:
                        case CS_E_OBJECT_NOTFOUND:
                        case CS_E_OBJECT_ALREADY_EXISTS:
                        case CS_E_INVALID_PATH:
                        case CS_E_NETWORK_ERROR:
                        case CS_E_SCHEMA_MISMATCH:
                        case CS_E_PACKAGE_NOTFOUND:
                        case CS_E_INTERNAL_ERROR:
                            {
                                DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                                         NULL,
                                                         hr,
                                                         0,
                                                         szBuffer,
                                                         sizeof(szBuffer) / sizeof(szBuffer[0]),
                                                         NULL);
                                if (0 != dw)
                                {
                                    // got a valid message string
                                    break;
                                }
                                // otherwise fall through and give the generic message
                            }
                        // Either these CS errors don't apply or an admin
                        // wouldn't know what they mean:
                        case CS_E_NOT_DELETABLE:
                        default:
                            // generic class store problem
                            ::LoadString(ghInstance, IDS_ADDFAILED_CSFAILURE, szBuffer, 256);
                            break;
                        }
                    }
                    else
                    {
                        // probably some error with the package itself
                        ::LoadString(ghInstance, IDS_ADDFAILED, szBuffer, 256);
                    }
                }
    #if DBG
                TCHAR szDebugBuffer[256];
                DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                         NULL,
                                         hr,
                                         0,
                                         szDebugBuffer,
                                         sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                         NULL);
                if (0 == dw)
                {
                    (void) StringCchPrintf(szDebugBuffer, 
                                           sizeof(szDebugBuffer)/sizeof(szDebugBuffer[0]),
                                           TEXT("(HRESULT: 0x%lX)"), 
                                           hr);
                }
                (void) StringCchCat(szBuffer, 
                                    sizeof(szBuffer) / sizeof(szBuffer[0]),
                                    szDebugBuffer);
    #endif
                m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);
            }
            InternalFreePackageDetail(ppd);
            delete ppd;
        }
    }
    return hr;
out_of_memory:
    if (ppd)
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
        InternalFreePackageDetail(ppd);
        delete ppd;
    }
    return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DetectUpgrades
//
//  Synopsis:   This functions checks if any of the existing packages in the
//              class store can be upgraded by a given package. If any such
//              packages exist, then this function populates the m_UpgradeList
//              member of the dlgUpgrade parameter passed to it. This function
//              also adds the upgrade code GUID to the PACKAGEDETAIL structure
//              passed to it.
//
//  Arguments:
//              szPackagePath - the path of the given package
//              ppd           - pointer to the PACKAGEDETAIL structure of the
//                              given package
//              dlgUpgrade    - the dialog whose member m_UpgradeList needs to be
//                              populated
//
//  Returns:
//              S_OK        the function succeeded in finding upgradeable packages
//              S_FALSE     the function did not encounter any errors, but no
//                          upgradeable packages were found
//    other failure codes   the function encountered errors
//
//  History:    5/19/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT CScopePane::DetectUpgrades (LPCOLESTR szPackagePath, const PACKAGEDETAIL* ppd, CUpgrades& dlgUpgrade)
{
    DWORD dwBufSize = 50;
    TCHAR szUpgradeCode[50];    //the upgrade GUID
    GUID guidUpgradeCode;
    TCHAR szData[50];
    DWORD dwOperator;
    HRESULT hr;
    HRESULT hres;
    MSIHANDLE hDatabase;
    UINT msiReturn;
    map<MMC_COOKIE, CAppData>::iterator i;
    INSTALLINFO* pii;
    BOOL fUpgradeable;
    LARGE_INTEGER verNew, verExisting;
    CString szCSPath;
    hr = GetClassStoreName(szCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }

    msiReturn = GetMsiProperty(szPackagePath, TEXT("UpgradeCode"), szUpgradeCode, &dwBufSize);
    if (ERROR_SUCCESS != msiReturn)
        return HRESULT_FROM_WIN32(msiReturn);     //no upgrade code was found

    hr = CLSIDFromString(szUpgradeCode, &guidUpgradeCode);
    if (FAILED(hr))
        return hr;

    //insert the upgrade code GUID into the packagedetail structure.
    memcpy((LPVOID)&(ppd->pInstallInfo->Mvipc), (LPVOID)&guidUpgradeCode, sizeof(GUID));

    verNew.LowPart = ppd->pInstallInfo->dwVersionLo;
    verNew.HighPart = ppd->pInstallInfo->dwVersionHi;
    hr = S_FALSE;   //this will get set to S_OK only if we find any upgradeable packages

    msiReturn = MsiOpenDatabase (szPackagePath, MSIDBOPEN_READONLY, &hDatabase);
    if (ERROR_SUCCESS == msiReturn)
    {
        CString szQuery;
        szQuery.Format (TEXT("SELECT `UpgradeCode`, `Attributes`, `VersionMin`, `VersionMax`, `Language` FROM `Upgrade`"));
        MSIHANDLE hView;
        msiReturn = MsiDatabaseOpenView(hDatabase, szQuery, &hView);
        if (ERROR_SUCCESS == msiReturn)
        {
            msiReturn = MsiViewExecute (hView, 0);
            if (ERROR_SUCCESS == msiReturn)
            {
                MSIHANDLE hRecord;
                //for each operator value returned by the query, if an operator is found that permits
                //upgrades, iterate through the list of existing packages to see if any of those are
                //upgradeable by the supplied package. If any such package is found, add it to the
                //m_UpgradeList member of the upgrade dialog dlgUpgrade.
                do
                {
                    msiReturn = MsiViewFetch (hView, &hRecord);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        //reset dwBufSize since it is modified by MsiRecordString during every iteration
                        //of the loop.
                        dwBufSize = 50;
                        //get the upgrade code for this upgrade table entry
                        msiReturn = MsiRecordGetString (hRecord, 1, szData, &dwBufSize);
                        hres = CLSIDFromString (szData, &guidUpgradeCode);
                        if (FAILED(hres))
                        {
                            MsiCloseHandle(hRecord);
                            continue;   //ignore this package and move on to the next
                        }
                        dwBufSize = 50; //must reset to reflect the correct buffer size
                        //get the operator for this upgrade table entry
                        msiReturn = MsiRecordGetString (hRecord, 2, szData, &dwBufSize);
                        
                        int iRetVal;
                        iRetVal = swscanf(szData, TEXT("%d"), &dwOperator);
                        if ((iRetVal != EOF) && (0 == (dwOperator & 0x002)))
                        {
                            // we have a potential hit
                            LARGE_INTEGER verMin;
                            LARGE_INTEGER verMax;

                            // get min version
                            dwBufSize = 50; //must reset to reflect the correct buffer size
                            BOOL fMin = FALSE;
                            msiReturn = MsiRecordGetString (hRecord, 3, szData, &dwBufSize);
                            if (ERROR_SUCCESS == msiReturn && 0 != szData[0])
                            {
                                fMin = TRUE;
                                // Parse Product Version
                                CString sz = szData;
                                sz.TrimLeft();
                                CString szTemp = sz.SpanIncluding(L"0123456789");

                                if (swscanf(szTemp, L"%u", &verMin.HighPart) != EOF) 
                                {
                                    sz = sz.Mid(szTemp.GetLength());
                                    szTemp = sz.SpanExcluding(L"0123456789");
                                    sz = sz.Mid(szTemp.GetLength());
                                    if (swscanf(sz, L"%u", &verMin.LowPart) == EOF) 
                                    {
                                        LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(GetLastError()), szPackagePath);
                                    }
                                }
                                else
                                {
                                    LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(GetLastError()), szPackagePath);
                                }
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }

                            // get max version
                            dwBufSize = 50; //must reset to reflect the correct buffer size
                            BOOL fMax = FALSE;
                            msiReturn = MsiRecordGetString (hRecord, 4, szData, &dwBufSize);
                            if (ERROR_SUCCESS == msiReturn && 0 != szData[0])
                            {
                                fMax = TRUE;
                                // Parse Product Version
                                CString sz = szData;
                                sz.TrimLeft();
                                CString szTemp = sz.SpanIncluding(L"0123456789");
                                
                                if (swscanf(szTemp, L"%u", &verMax.HighPart) != EOF) 
                                {
                                    sz = sz.Mid(szTemp.GetLength());
                                    szTemp = sz.SpanExcluding(L"0123456789");
                                    sz = sz.Mid(szTemp.GetLength());
                                    
                                    if (swscanf(sz, L"%u", &verMax.LowPart) == EOF) 
                                    {
                                        LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(GetLastError()), szPackagePath);
                                    }
                                }
                                else
                                {
                                    LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(GetLastError()), szPackagePath);
                                }
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }
                            // get lcid list
                            dwBufSize = 0; //must reset to reflect the correct buffer size
                            BOOL fLcids = FALSE;
                            set<LCID> sLCID;
                            msiReturn = MsiRecordGetString (hRecord, 5, szData, &dwBufSize);
                            if (ERROR_MORE_DATA == msiReturn)
                            {
                                dwBufSize++;
                                TCHAR * szLanguages = new TCHAR[dwBufSize];
                                if (szLanguages)
                                {
                                    msiReturn = MsiRecordGetString (hRecord, 5, szLanguages, &dwBufSize);
                                    if (ERROR_SUCCESS == msiReturn)
                                    {
                                        // build set of LCIDs

                                        CString sz = szLanguages;
                                        sz.TrimLeft();
                                        while (!sz.IsEmpty())
                                        {
                                            fLcids = TRUE;
                                            LCID lcid;
                                            CString szTemp = sz.SpanIncluding(L"0123456789");
                                            
                                            if (swscanf(szTemp, L"%u", &lcid) != EOF) 
                                            {
                                                sz = sz.Mid(szTemp.GetLength());
                                                szTemp = sz.SpanExcluding(L"0123456789");
                                                sz = sz.Mid(szTemp.GetLength());
                                                sLCID.insert(lcid);
                                            }
                                            else
                                            {
                                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(GetLastError()), szPackagePath);

                                            }
                                        }
                                    }
                                    else
                                    {
                                        LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                                    }
                                    delete [] szLanguages;
                                }
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }

                            //if an operator is found that that does not block installs and
                            //does not force uninstalling of existing apps, then search
                            //for any packages that can be upgraded
                            for (i = m_AppData.begin(); i != m_AppData.end(); i++)
                            {
                                //get the install info. for the app.
                                pii = (i->second.m_pDetails)->pInstallInfo;
                                //process this only if it has the same upgrade code
                                if ( (guidUpgradeCode == pii->Mvipc) && ! IsNullGUID(&guidUpgradeCode) )
                                {
                                    //check if other conditions for the operator are satisfied.
                                    verExisting.LowPart = pii->dwVersionLo;
                                    verExisting.HighPart = pii->dwVersionHi;

                                    // don't even bother to upgrade unless the
                                    // new version is greater or equal to the
                                    // old version
                                    fUpgradeable = (verNew.QuadPart >= verExisting.QuadPart);

                                    if (fMin && fUpgradeable)
                                    {
                                        // check minimum
                                        if (0 != (dwOperator & 0x100))
                                        {
                                            // inclusive
                                            fUpgradeable = verExisting.QuadPart >= verMin.QuadPart;
                                        }
                                        else
                                        {
                                            // exclusive
                                            fUpgradeable = verExisting.QuadPart > verMin.QuadPart;
                                        }
                                    }

                                    if (fMax && fUpgradeable)
                                    {
                                        // check maximum
                                        if (0 != (dwOperator & 0x200))
                                        {
                                            // inclusive
                                            fUpgradeable = verExisting.QuadPart <= verMax.QuadPart;
                                        }
                                        else
                                        {
                                            // exclusive
                                            fUpgradeable = verExisting.QuadPart < verMax.QuadPart;
                                        }
                                    }

                                    if (fLcids && fUpgradeable)
                                    {
                                        // check the lcid
                                        BOOL fMatch = FALSE;

                                        // look for a match
                                        PLATFORMINFO * ppi = (i->second.m_pDetails)->pPlatformInfo;

                                        UINT n = ppi->cLocales;
                                        while ((n--) && !fMatch)
                                        {
                                            if (sLCID.end() != sLCID.find(ppi->prgLocale[n]))
                                            {
                                                fMatch = TRUE;
                                            }
                                        }

                                        // set the upgradeable flag
                                        if (0 != (dwOperator & 0x400))
                                        {
                                            // exclusive
                                            fUpgradeable = !fMatch;
                                        }
                                        else
                                        {
                                            // inclusive
                                            fUpgradeable = fMatch;
                                        }
                                    }

                                    if (fUpgradeable)   //the package in question can be upgraded
                                    {
                                        CUpgradeData data;
                                        data.m_szClassStore = szCSPath;
                                        memcpy(&data.m_PackageGuid, &pii->PackageGuid, sizeof(GUID));
                                        data.m_flags = UPGFLG_NoUninstall | UPGFLG_Enforced;
                                        dlgUpgrade.m_UpgradeList.insert(pair<const CString, CUpgradeData>(GetUpgradeIndex(data.m_PackageGuid), data));
                                        hr = S_OK;
                                    }
                                }
                            }
                        }
                        MsiCloseHandle(hRecord);
                    }
                } while (NULL != hRecord && ERROR_SUCCESS == msiReturn);
                MsiViewClose (hView);   //close the view to be on the safe side, though it is not absolutely essential
            }
            else
                hr = HRESULT_FROM_WIN32(msiReturn);

            MsiCloseHandle(hView);
        }
        else
            hr = HRESULT_FROM_WIN32(msiReturn);

        MsiCloseHandle (hDatabase);
    }
    else
        hr = HRESULT_FROM_WIN32(msiReturn);

    if (FAILED(hr))
    {
        if (msiReturn != ERROR_SUCCESS)
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, szPackagePath);
        }
        else
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, hr);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DisplayPropSheet
//
//  Synopsis:   a generic routine for showing the property sheet for a package
//
//  Arguments:  [szPackeName] - name of the package to show properties for
//              [iPage]       - index of the preferred page to display
//
//  Returns:    nothing
//
//  History:    3-11-1998   stevebl   Created
//
//  Notes:      The property sheet will be started on the preferred page
//              only if it isn't already being displayed, in which case
//              whatever page was being displayed will retain the focus.
//
//---------------------------------------------------------------------------

void CScopePane::DisplayPropSheet(CString szPackageName, int iPage)
{
    map <MMC_COOKIE, CAppData>::iterator i = m_AppData.begin();
    while (i != m_AppData.end())
    {
        if (0 == szPackageName.Compare(i->second.m_pDetails->pszPackageName))
        {
            IDataObject * pDataObject;
            HRESULT hr = QueryDataObject(i->first, CCT_RESULT, &pDataObject);
            if (SUCCEEDED(hr))
            {
                set <CResultPane *>::iterator i2;
                for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
                {
                    hr = m_pIPropertySheetProvider->FindPropertySheet(i->first, (*i2), pDataObject);
                    if (S_FALSE == hr)
                    {
                        m_pIPropertySheetProvider->CreatePropertySheet(i->second.m_pDetails->pszPackageName, TRUE, i->first, pDataObject, 0);
                        m_pIPropertySheetProvider->AddPrimaryPages((*i2)->GetUnknown(), FALSE, NULL, FALSE);
                        m_pIPropertySheetProvider->AddExtensionPages();
                        m_pIPropertySheetProvider->Show(NULL, iPage);
                    }
                }
            }
            return;
        }
        i++;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemovePackage
//
//  Synopsis:   Removes a package from the class store and the result pane.
//
//  Arguments:  [pDataObject] - data object for this result pane item
//              [fForceUninstall] - TRUE -  force app to be uninstalled on
//                                          client machines
//                                  FALSE - orphan any installations
//
//  Returns:    S_OK - success
//
//  History:    2-03-1998   stevebl   Created
//              3-30-1998   stevebl   adde fForceUninstall
//
//  Notes:      bAssigned is used
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemovePackage(MMC_COOKIE cookie, BOOL fForceUninstall, BOOL fRemoveNow)
{
    BOOL fAssigned;
    HRESULT hr = E_FAIL;
    // put up an hourglass (this could take a while)
    CHourglass hourglass;
    CAppData & data = m_AppData[cookie];
    CString szPackageName = data.m_pDetails->pszPackageName;

    // We are now not removing script files here; instead the script
    // file will be removed by the class store code when the package
    // is actually removed from the DS.
#if 0
    // only remove script files for packages that have script files
    if (data.m_pDetails->pInstallInfo->PathType == DrwFilePath)
    {
        // We need to make sure it gets removed from
        // the GPT before we delete it from the class store.
        // check to see if it's an old style relative path
        if (L'\\' != data.m_pDetails->pInstallInfo->pszScriptPath[0])
        {
            // find the last element in the path
            int iBreak = m_szGPT_Path.ReverseFind(L'{');
            CString sz = m_szGPT_Path.Left(iBreak-1);
            sz += L"\\";
            sz += data.m_pDetails->pInstallInfo->pszScriptPath;
            DeleteFile(sz);
        }
        else
        DeleteFile(data.m_pDetails->pInstallInfo->pszScriptPath);
    }
#endif

    if (0 != (data.m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
    {
        fAssigned = TRUE;
    }
    else
    {
        fAssigned = FALSE;
    }
    hr = m_pIClassAdmin->RemovePackage((LPOLESTR)((LPCOLESTR)(data.m_pDetails->pszPackageName)),
                                       fRemoveNow ? 0 :
                                       ((fForceUninstall ? ACTFLG_Uninstall : ACTFLG_Orphan) |
                                        (data.m_pDetails->pInstallInfo->dwActFlags &
                                         (ACTFLG_ExcludeX86OnWin64 | ACTFLG_IgnoreLanguage))) );

    if (SUCCEEDED(hr))
    {
        // Notify clients of change
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                          m_fMachine ? &guidMachSnapin
                                                     : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hwndMainWindow);
        }

#if 0
        if (data.m_fVisible)
        {
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                (*i)->m_pResult->DeleteItem(data.m_itemID, 0);
            }
        }
        if (SUCCEEDED(hr))
        {
            CString szCSPath;
            hr = GetClassStoreName(szCSPath, FALSE);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
            }

            // remove its entries in the extension table
            RemoveExtensionEntry(cookie, data);
            if (m_pFileExt)
            {
                m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
            }
            RemoveUpgradeEntry(cookie, data);
            m_UpgradeIndex.erase(GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid));
            // If this thing upgraded other apps or had apps that were
            // upgrading, make sure that they get the proper icons and any
            // property sheets get updated.
            UINT n = data.m_pDetails->pInstallInfo->cUpgrades;
            while (n--)
            {
                map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
                if (i != m_UpgradeIndex.end())
                {
                    RESULTDATAITEM rd;
                    memset(&rd, 0, sizeof(rd));
                    rd.mask = RDI_IMAGE;
                    rd.itemID = m_AppData[i->second].m_itemID;
                    rd.nImage = m_AppData[i->second].GetImageIndex(this);
                    set <CResultPane *>::iterator i2;
                    for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
                    {
                        (*i2)->m_pResult->SetItem(&rd);
                    }
                    if (m_AppData[i->second].m_pUpgradeList)
                    {
                        m_AppData[i->second].m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
                    }
                }
            }
            FreePackageDetail(data.m_pDetails);
            m_AppData.erase(cookie);
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
            }
        }
#else
        // just force a refresh
        Refresh();
    }
#endif
    else
    {
        DebugMsg((DM_WARNING, TEXT("RemovePackage failed with 0x%x"), hr));
    }

    if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_REMOVE_ERROR, hr, data.m_pDetails->pszPackageName);
        TCHAR szBuffer[256];
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
        {
            // access permission failure
            ::LoadString(ghInstance, IDS_DELFAILED_ACCESS_DENIED, szBuffer, 256);
        }
        else
        {
            switch (hr)
            {
            // For these errors, we'll report the party line:
            case CS_E_CLASS_NOTFOUND:
            case CS_E_INVALID_VERSION:
            case CS_E_NO_CLASSSTORE:
            case CS_E_OBJECT_NOTFOUND:
            case CS_E_OBJECT_ALREADY_EXISTS:
            case CS_E_INVALID_PATH:
            case CS_E_NETWORK_ERROR:
            case CS_E_ADMIN_LIMIT_EXCEEDED:
            case CS_E_SCHEMA_MISMATCH:
            case CS_E_PACKAGE_NOTFOUND:
            case CS_E_INTERNAL_ERROR:
            case CS_E_NOT_DELETABLE:
                {
                    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                             NULL,
                                             hr,
                                             0,
                                             szBuffer,
                                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                                             NULL);
                    if (0 != dw)
                    {
                        // got a valid message string
                        break;
                    }
                    // otherwise fall through and give the generic message
                }
            // Either these CS errors don't apply or an admin
            // wouldn't know what they mean:
            default:
                // generic class store problem
                ::LoadString(ghInstance, IDS_DELFAILED_CSFAILURE, szBuffer, 256);
                break;
            }
        }
#if DBG
        TCHAR szDebugBuffer[256];
        DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 hr,
                                 0,
                                 szDebugBuffer,
                                 sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                 NULL);
        if (0 == dw)
        {
            (void) StringCchPrintf(szDebugBuffer, 
                                   sizeof(szDebugBuffer)/sizeof(szDebugBuffer[0]),
                                   TEXT("(HRESULT: 0x%lX)"), 
                                   hr);
        }

        (void) StringCchCat(szBuffer, 
                            sizeof(szBuffer) / sizeof(szBuffer[0]),
                            szDebugBuffer);
#endif
        m_pConsole->MessageBox(szBuffer,
                           szPackageName,
                           MB_OK | MB_ICONEXCLAMATION, NULL);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PopulateUpgradeLists
//
//  Synopsis:   Walks the list of apps, making sure that all the upgrade
//              tables are complete.
//
//  Arguments:  none
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PopulateUpgradeLists()
{
    HRESULT hr = S_OK;
    // For each app in the list, insert an entry in the upgrade tables of
    // the apps it upgrades.
    map <MMC_COOKIE, CAppData>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertUpgradeEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::InsertUpgradeEntry
//
//  Synopsis:   For every app that this app upgrades, place an entry in its
//              upgrades set so that it points back to this one.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::InsertUpgradeEntry(MMC_COOKIE cookie, CAppData & data)
{
    CString szCSPath;
    HRESULT hr = GetClassStoreName(szCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }
    UINT uUpgrades = data.m_pDetails->pInstallInfo->cUpgrades;
    while (uUpgrades--)
    {
        map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[uUpgrades].PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            // Make sure the entry isn't already added:
            INSTALLINFO * pii = m_AppData[i->second].m_pDetails->pInstallInfo;
            BOOL fExists = FALSE;
            UINT uCount = pii->cUpgrades;
            while (uCount--)
            {
                if (0 == memcmp(&data.m_pDetails->pInstallInfo->PackageGuid, &pii->prgUpgradeInfoList[uCount].PackageGuid, sizeof(GUID)))
                {
                    // it already exists
                    fExists = TRUE;
                    break;
                }
            }
            if (!fExists)
            {
                // Add the entry to this app.
                // We don't need to update the class store because it should
                // maintain referential integrity for us.  But we do need to
                // update our own internal structures so we're consistent with
                // what's in the class store.
                UINT n = ++(pii->cUpgrades);
                UPGRADEINFO * prgUpgradeInfoList = (UPGRADEINFO *)OLEALLOC(sizeof(UPGRADEINFO) * n);
                if (!prgUpgradeInfoList)
                {
                    // out of memory
                    // back out the change (this would be unfortunate but not fatal)
                    pii->cUpgrades--;
                }
                else
                {
                    if (n > 1)
                    {
                        memcpy(prgUpgradeInfoList, pii->prgUpgradeInfoList, sizeof(UPGRADEINFO) * (n-1));
                        OLESAFE_DELETE(pii->prgUpgradeInfoList);
                    }
                    OLESAFE_COPYSTRING(prgUpgradeInfoList[n-1].szClassStore, (LPOLESTR)((LPCWSTR)szCSPath));
                    memcpy(&prgUpgradeInfoList[n-1].PackageGuid, &data.m_pDetails->pInstallInfo->PackageGuid, sizeof(GUID));
                    prgUpgradeInfoList[n-1].Flag = UPGFLG_UpgradedBy;
                    pii->prgUpgradeInfoList = prgUpgradeInfoList;
                }
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemoveUpgradeEntry
//
//  Synopsis:   For every app that this app upgraded, remove the entry from
//              its upgrades set.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemoveUpgradeEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT uUpgradeIndex = data.m_pDetails->pInstallInfo->cUpgrades;
    while (uUpgradeIndex--)
    {
        map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[uUpgradeIndex].PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            // Find which entry needs to be erased.
            INSTALLINFO * pii = m_AppData[i->second].m_pDetails->pInstallInfo;
            UINT n = pii->cUpgrades;
            while (n--)
            {
                if (0 == memcmp(&data.m_pDetails->pInstallInfo->PackageGuid, &pii->prgUpgradeInfoList[n].PackageGuid, sizeof(GUID)))
                {
                    // Now free this entry, copy the last entry over this
                    // one and decrement cUpgrades.  Don't need to actually
                    // reallocate the array because it will be freed later.
                    OLESAFE_DELETE(pii->prgUpgradeInfoList[n].szClassStore);
                    if (--(pii->cUpgrades))
                    {
                        memcpy(&pii->prgUpgradeInfoList[n], &pii->prgUpgradeInfoList[pii->cUpgrades], sizeof(UPGRADEINFO));
                    }
                    else
                    {
                        OLESAFE_DELETE(pii->prgUpgradeInfoList);
                    }
                    // If we ever were to need to update the class store,
                    // this is where we would do it.
                    break;
                }
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PopulateExtensions
//
//  Synopsis:   Builds the file extension table from the list of applications.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PopulateExtensions()
{
    HRESULT hr = S_OK;
    // first erase the old extension list
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // now add each app's extensions to the table
    map <MMC_COOKIE, CAppData>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertExtensionEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    if (m_pFileExt)
    {
        m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::InsertExtensionEntry
//
//  Synopsis:   Adds a single entry to the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::InsertExtensionEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT n = data.m_pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].insert(cookie);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemoveExtensionEntry
//
//  Synopsis:   Removes ane entry from the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemoveExtensionEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT n = data.m_pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].erase(cookie);
        if (m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].empty())
        {
            m_Extensions.erase(data.m_pDetails->pActInfo->prgShellFileExt[n]);
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PrepareExtensions
//
//  Synopsis:   Sets extension priorities so that this data can be inserted
//              into the extension list with the proper priority.
//
//  Arguments:  [pd] -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PrepareExtensions(PACKAGEDETAIL &pd)
{
    UINT n = pd.pActInfo->cShellFileExt;
    while (n--)
    {
        // For each extension that is going to be added, we need to assign
        // it a priority that is one larger than the largest priority
        // already added.

        // NOTE: The odds of this number rolling over to 0 are so
        // unlikely that it would be pointless to check for it.  In any case
        // the results of such a bug would be easy for the admin to remedy
        // via the file extension priority dialog.

        pd.pActInfo->prgPriority[n] = 0;
        EXTLIST::iterator i;
        CString sz = pd.pActInfo->prgShellFileExt[n];
        for (i= m_Extensions[sz].begin(); i != m_Extensions[sz].end(); i++)
        {
            // look for the entry that matches this file extension
            CAppData & data = m_AppData[*i];
            UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == sz.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            if (data.m_pDetails->pActInfo->prgPriority[n2] >= pd.pActInfo->prgPriority[n])
            {
                pd.pActInfo->prgPriority[n] = data.m_pDetails->pActInfo->prgPriority[n2] + 1;
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::ChangePackageState
//
//  Synopsis:   Changes the state of a package and puts up advisory message
//              boxes informing the admin about the effects of the change.
//
//  Arguments:  [data]       - entry to change
//              [dwNewState] - new state
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP CScopePane::ChangePackageState(CAppData &data, DWORD dwNewState, BOOL fShowUI)
{
    HRESULT hr = S_OK;

    // first detect what's changed
    DWORD dwOldState = data.m_pDetails->pInstallInfo->dwActFlags;
    DWORD dwChange = dwOldState ^ dwNewState;

    if (dwChange)
    {
        // commit changes
        hr = m_pIClassAdmin->ChangePackageProperties(data.m_pDetails->pszPackageName, NULL, &dwNewState, NULL, NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (data.m_fVisible)
            {
                data.m_pDetails->pInstallInfo->dwActFlags = dwNewState;
                RESULTDATAITEM rd;
                memset(&rd, 0, sizeof(rd));
                rd.mask = RDI_IMAGE;
                rd.itemID = data.m_itemID;
                rd.nImage = data.GetImageIndex(this);
                set <CResultPane *>::iterator i;
                for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
                {
                    (*i)->m_pResult->SetItem(&rd);
                    (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
                }
            }
            data.NotifyChange();
            if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                              m_fMachine ? &guidMachSnapin
                                                         : &guidUserSnapin)))
            {
                ReportPolicyChangedError(m_hwndMainWindow);
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        }
    }

    return hr;
}

HRESULT CScopePane::ClearCategories()
{
    while (m_CatList.cCategory)
    {
        m_CatList.cCategory--;
        OLESAFE_DELETE(m_CatList.pCategoryInfo[m_CatList.cCategory].pszDescription);
    }
    OLESAFE_DELETE(m_CatList.pCategoryInfo);
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetUpgradeIndex
//
//  Synopsis:   utility function that returns an upgrade index entry for a package.
//
//  Arguments:  [PackageID]    - the PackageID guid
//
//  Returns:    S_OK on success
//
//  History:    8-12-1998   stevebl   Created
//
//  Notes:      Pretty simple really, the index is just the string form of
//              the GUID.
//
//---------------------------------------------------------------------------

CString GetUpgradeIndex(GUID & PackageID)
{
    CString szIndex;
    WCHAR wsz[256];
    StringFromGUID2(PackageID, wsz, 256);
    return wsz;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetPackageNameFromUpgradeInfo
//
//  Synopsis:   returns the name of a package given its PackageGuid and CSPath
//
//  Arguments:  [szPackageName] - [out] name of the package associated with
//                                 this script
//              [szScript]      - [in] path to the script
//
//  Returns:    S_OK - found a package associated with this script
//              (other) - failed to find a package (could be for any number
//              of reasons)
//
//  History:    4-07-1998   stevebl   Created
//
//  Notes:      In cases where the package does not reside in this
//              container, the package name will be returned as
//                  "Package Name (container name)"
//              Note that this does not return the friendly name of the
//              MSI package, it returns the name of the package entry in the
//              class store.  The two are not always the same.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetPackageNameFromUpgradeInfo(CString & szPackageName, GUID &PackageGuid, LPOLESTR szCSPath)
{
    HRESULT hr;
    IEnumPackage * pIPE = NULL;

    CString szMyCSPath;
    hr = GetClassStoreName(szMyCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }

    // see if it's in our container
    if (0 == _wcsicmp((LPOLESTR)((LPCWSTR)szMyCSPath), szCSPath))
    {
        hr = E_FAIL;
        map <CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            szPackageName = m_AppData[i->second].m_pDetails->pszPackageName;
            hr = S_OK;
        }
    }
    else
    {
        IClassAdmin * pIClassAdmin;
        hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&pIClassAdmin);
        if (SUCCEEDED(hr))
        {
            PACKAGEDETAIL pd;
            hr = pIClassAdmin->GetPackageDetailsFromGuid(PackageGuid,
                                                         &pd);
            if (SUCCEEDED(hr))
            {
                if (0 == (pd.pInstallInfo->dwActFlags & (ACTFLG_Orphan | ACTFLG_Uninstall)))
                {
                    GUID guid;
                    LPOLESTR pszPolicyName;

                    hr = pIClassAdmin->GetGPOInfo(&guid,
                                                  &pszPolicyName);
                    if (SUCCEEDED(hr))
                    {
                        szPackageName = pd.pszPackageName;
                        szPackageName += L" (";
                        szPackageName += pszPolicyName;
                        szPackageName += L")";
                        OLESAFE_DELETE(pszPolicyName);
                    }
                }
                else
                {
                    // this app is marked as deleted
                    hr = E_FAIL;
                }
                ReleasePackageDetail(&pd);
            }
            pIClassAdmin->Release();
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetMsiProperty
//
//  Synopsis:   Retrieves a property from the Property table of an MSI package.
//
//  Arguments:  [szPackagePath] - path to the MSI package
//              [szProperty]    - property to fetch
//              [szValue]       - buffer to contain the value
//              [puiSize]       - size of the buffer
//
//  Returns:    ERROR_SUCCESS if successful
//
//  History:    3-25-1998   stevebl   Created
//
//---------------------------------------------------------------------------

UINT GetMsiProperty(const TCHAR * szPackagePath, const TCHAR* szProperty, TCHAR* szValue, DWORD* puiSize)
{
    MSIHANDLE hDatabase;
    UINT msiReturn = MsiOpenDatabase(szPackagePath, MSIDBOPEN_READONLY, &hDatabase);
    if (ERROR_SUCCESS == msiReturn)
    {
        CString szQuery;
        szQuery.Format(L"SELECT `Value` FROM `Property` WHERE `Property`='%s'", szProperty);
        MSIHANDLE hView;
        msiReturn = MsiDatabaseOpenView(hDatabase, szQuery, &hView);
        if (ERROR_SUCCESS == msiReturn)
        {
            msiReturn = MsiViewExecute(hView, 0);
            if (ERROR_SUCCESS == msiReturn)
            {
                MSIHANDLE hRecord;
                msiReturn = MsiViewFetch(hView, &hRecord);
                if (ERROR_SUCCESS == msiReturn)
                {
                    msiReturn = MsiRecordGetString(hRecord, 1, szValue, puiSize);
                    MsiCloseHandle(hRecord);
                }
            }
            MsiCloseHandle(hView);
        }
        MsiCloseHandle(hDatabase);
    }
    return msiReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCapitalizedExt
//
//  Synopsis:   Given a file name, this function finds the filename
//              extension, and returns it capitalized.
//
//  Arguments:
//          [in] [szName] The file name
//          [out][szExt]  The capitalized extension
//
//  Returns:
//          TRUE  - an extension was found
//          FALSE - an extension could not be found
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes:      If an extension cannot be found, then this function makes
//              szExt an empty string
//
//---------------------------------------------------------------------------
BOOL GetCapitalizedExt (LPCOLESTR szName, CString& szExt)
{
    int slashpos, dotpos;
    BOOL fRetVal = FALSE;
    CString szFileName = szName;

    szExt.Empty(); //to be on the safe side

    //get the positions of the last . and last backslash
    dotpos = szFileName.ReverseFind('.');
    slashpos = szFileName.ReverseFind('\\');

    //if the last dot occurs after the last slash, this file has an extension
    if (dotpos > slashpos)
    {
        szExt = szFileName.Mid(dotpos + 1);
        szExt.MakeUpper();
        fRetVal = TRUE;
    }

    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\packages.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       packages.h
//
//  Contents:   Methods on CScopePane related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:  CopyPackageDetail
//              FreePackageDetail
//              GetPackageProperty
//
//  History:    2-03-1998   stevebl   Created
//              3-25-1998   stevebl   Added GetMsiProperty
//              5-20-1998   RahulTh   Added GetUNCPath
//                                    Added GetCapitalizedExt
//
//---------------------------------------------------------------------------

HRESULT CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn);

void FreePackageDetail(PACKAGEDETAIL * & ppd);

UINT GetMsiProperty(const TCHAR * szPackagePath, const TCHAR* szProperty, TCHAR* szValue, DWORD* puiSize);
HRESULT GetUNCPath (LPCOLESTR szPath, CString& szUNCPath);
BOOL GetCapitalizedExt (LPCOLESTR szName, CString& szExt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\pkgdtl.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pkgdtl.h
//
//  Contents:   package details property page (not normally visible)
//
//  Classes:    CPackageDetails
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// pkgdtl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails dialog

class CPackageDetails : public CPropertyPage
{
        DECLARE_DYNCREATE(CPackageDetails)

// Construction
public:
        CPackageDetails();
        ~CPackageDetails();

        CPackageDetails ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CPackageDetails)
        enum { IDD = IDD_PACKAGE_DETAILS };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPackageDetails)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CPackageDetails)
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        void DumpDetails(FILE *);
        void DumpClassDetail(FILE *, CLASSDETAIL *);

        public:
            LONG_PTR   m_hConsoleHandle; // Handle given to the snap-in by the console
            CAppData * m_pData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\prec.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       prec.h
//
//  Contents:   precedence property pane (RSOP mode only)
//
//  Classes:
//
//  Functions:
//
//  History:    02-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// CPrecedence dialog

class CPrecedence : public CPropertyPage
{
    DECLARE_DYNCREATE(CPrecedence)

// Construction
public:
    CPrecedence();
    ~CPrecedence();

    CPrecedence ** m_ppThis;

// Dialog Data
    //{{AFX_DATA(CPrecedence)
    enum { IDD = IDD_PRECEDENCE };
    CListCtrl   m_list;
    CString m_szTitle;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrecedence)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrecedence)
    virtual BOOL OnInitDialog();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LONG_PTR   m_hConsoleHandle; // Handle given to the snap-in by the console
    CAppData * m_pData;
    int         m_iViewState;
    CString m_szRSOPNamespace;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\product.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Product.h
//
//  Contents:   product info property page
//
//  Classes:    CProduct
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CProduct dialog

class CProduct : public CPropertyPage
{
        DECLARE_DYNCREATE(CProduct)

// Construction
public:
        CProduct();
        ~CProduct();

        CProduct ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CProduct)
        enum { IDD = IDD_PRODUCT };
        CString m_szVersion;
        CString m_szPublisher;
        CString m_szLanguage;
        CString m_szContact;
        CString m_szPhone;
        CString m_szURL;
        CString m_szName;
        CString m_szPlatform;
        CString m_szRevision;
        //}}AFX_DATA

        CAppData * m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        CScopePane * m_pScopePane;
        map<MMC_COOKIE, CAppData> * m_pAppData;
        BOOL            m_fPreDeploy;
        LPGPEINFORMATION m_pIGPEInformation;
        BOOL            m_fMachine;
        BOOL            m_fRSOP;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CProduct)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CProduct)
        afx_msg void OnChangeName();
        afx_msg void OnChange();
        virtual BOOL OnInitDialog();
        afx_msg void OnKillfocusEdit1();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\prec.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       prec.cpp
//
//  Contents:   precedence property pane (RSOP mode only)
//
//  Classes:
//
//  Functions:
//
//  History:    02-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include <wbemcli.h>
#include "rsoputil.h"

/////////////////////////////////////////////////////////////////////////////
// CPrecedence property page

IMPLEMENT_DYNCREATE(CPrecedence, CPropertyPage)

CPrecedence::CPrecedence() : CPropertyPage(CPrecedence::IDD)
{
    //{{AFX_DATA_INIT(CPrecedence)
    m_szTitle = _T("");
    //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPrecedence::~CPrecedence()
{
    *m_ppThis = NULL;
}

void CPrecedence::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrecedence)
    DDX_Control(pDX, IDC_LIST1, m_list);
    DDX_Text(pDX, IDC_TITLE, m_szTitle);
    //}}AFX_DATA_MAP
}

int CALLBACK ComparePrecedenceItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CListCtrl * pList = (CListCtrl *)lParamSort;
    DWORD dw1, dw2;
    return lParam1 - lParam2;
}

BEGIN_MESSAGE_MAP(CPrecedence, CPropertyPage)
    //{{AFX_MSG_MAP(CPrecedence)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrecedence message handlers

LRESULT CPrecedence::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // TODO: Add your specialized code here and/or call the base class
    switch (message )
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD, TRUE);
        return 0;
    }

    return CPropertyPage::WindowProc(message, wParam, lParam);
}

BOOL CPrecedence::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // TODO: Add extra initialization here

    RECT rect;
    m_list.GetClientRect(&rect);

    // add columns to the precedence pane
    CString szTemp;
    szTemp.LoadString(IDS_PRECEDENCE_COL1);
    m_list.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.125);
    szTemp.LoadString(IDS_PRECEDENCE_COL2);
    m_list.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);
    szTemp.LoadString(IDS_PRECEDENCE_COL3);
    m_list.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);
    szTemp.LoadString(IDS_PRECEDENCE_COL4);
    m_list.InsertColumn(3, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);

    int i = 0;

    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));

    szTemp = TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE Id=\"")
             + m_pData->m_szDeploymentGroupID + TEXT("\"");
    switch (m_iViewState)
    {
    case IDM_WINNER:
        szTemp += TEXT(" AND EntryType=1");
        break;
    case IDM_FAILED:
        szTemp += TEXT(" AND EntryType=4");
        break;
    case IDM_REMOVED:
        szTemp += TEXT(" AND EntryType=2");
        break;
    case IDM_ARP:
        szTemp += TEXT(" AND EntryType=3");
        break;
    }

    BSTR strQuery = SysAllocString(szTemp);
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    do
    {
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (n > 0)
        {
            // prepare the data entry and populate all the fields
            CString szPackageName;
            CString szGPOID;
            CString szGPOName;
            CString szCreation;
            BSTR bstrCreation = NULL;
            ULONG ulPrecedence;
            hr = GetParameter(pObj,
                              TEXT("precedence"),
                              ulPrecedence);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"precedence\") failed with 0x%x"), hr));
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              szPackageName);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"Name\") failed with 0x%x"), hr));
            hr = GetParameter(pObj,
                              TEXT("GPOID"),
                              szGPOID);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"GPOID\") failed with 0x%x"), hr));
            hr = GetParameterBSTR(pObj,
                                  TEXT("creationtime"),
                                  bstrCreation);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameterBSTR(\"creationtime\") failed with 0x%x"), hr));
            hr = CStringFromWBEMTime(szCreation, bstrCreation, TRUE);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: CStringFromWBEMTime failed with 0x%x"), hr));
            LPTSTR pszGPOName = NULL;
            hr = GetGPOFriendlyName(pNamespace,
                                    (LPTSTR)((LPCTSTR) szGPOID),
                                    strQueryLanguage,
                                    &pszGPOName);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetGPOFriendlyName failed with 0x%x"), hr));
            if (SUCCEEDED(hr))
            {
                szGPOName = pszGPOName;
                OLESAFE_DELETE(pszGPOName);
            }

            // insert the entry in the list
            CString szPrecedence;
            szPrecedence.Format(TEXT("%lu"), ulPrecedence);
            i = m_list.InsertItem(i, szPrecedence);
            m_list.SetItemText(i, 1, szPackageName);
            m_list.SetItemText(i, 2, szGPOName);
            m_list.SetItemText(i, 3, szCreation);
            m_list.SetItemData(i, ulPrecedence);
            ulPrecedence = m_list.GetItemData(i);
            i++;

            if (bstrCreation)
            {
                SysFreeString(bstrCreation);
            }
        }
    } while (n > 0);
    m_list.SortItems(ComparePrecedenceItems, (LPARAM)&m_list);
cleanup:
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPrecedence::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PRECEDENCE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appdeped.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_VERSION                     3
#define IDS_STAGE                       4
#define IDS_RELATION                    5
#define IDS_STATE                       6
#define IDS_AUTOINST                    7
#define IDS_LOC                         8
#define IDS_MACH                        9
#define IDS_MODS                        10
#define IDS_PUB                         11
#define IDS_SOURCE                      12
#define IDS_NODENAME                    13
#define IDS_ADD_APP_DESC                14
#define IDS_DEL_APP_DESC                15
#define IDS_REFRESH_DESC                16
#define IDS_AUTOINST_DESC               17
#define IDS_ASSIGN_DESC                 18
#define IDS_PUBLISH_DESC                19
#define IDS_DISABLE_DESC                20
#define IDS_REDEPLOY_DESC               21
#define IDS_REDEPLOYERROR               22
#define IDS_X86ONWIN64                  23
#define IDS_FULLINSTALL                 24
#define IDS_FOLDER_TITLE                30
#define IDS_ASSIGNED                    31
#define IDS_PUBLISHED                   32
#define IDS_DISABLED                    33
#define IDS_ORIGIN                      42
#define IDS_SOM                         43
#define IDS_WINNER_DESC                 44
#define IDS_REMOVED_DESC                45
#define IDS_ARP_DESC                    47
#define IDS_SNAPIN_NAME_USER            50
#define IDS_SNAPIN_NAME_MACHINE         51
#define IDD_UPGRADE                     101
#define IDD_DEPLOY_APP_DIALOG           102
#define IDD_PRODUCT                     106
#define IDD_GENERAL                     107
#define IDD_UPGRADES                    107
#define IDD_INSTALLATION                108
#define IDD_ENVIRONMENT                 109
#define IDD_DEPLOYMENT                  110
#define IDD_MODIFICATIONS               111
#define IDD_AUTO_INSTALL                112
#define IDD_CATEGORY                    113
#define IDD_SECURITY                    114
#define IDD_TOOL_DEFAULTS               115
#define IDD_LOCALE_PLATFORM             116
#define IDD_CATEGORIES                  117
#define IDD_FILE_EXT                    118
#define IDD_LOCALE_PACKAGE              119
#define IDD_FIND_UPGRADE                120
#define IDD_FIND_PACKAGE_UPGRADE        121
#define IDC_NAME                        201
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDC_EDIT2                       203
#define IDC_DEPLOY                      204
#define IDI_FOLDER                      205
#define IDC_CPU                         205
#define IDC_DESCRIPTION                 206
#define IDB_TOOLBAR1                    207
#define IDC_PATH                        207
#define IDC_LOCALE                      208
#define IDC_BROWSE                      209
#define IDD_PACKAGE_DETAILS             210
#define IDC_OS                          211
#define IDD_REMOVE                      211
#define IDC_VERSION                     212
#define IDD_LOCALE_PICKER               213
#define IDD_UNINSTALLTRACKING           214
#define IDD_EDITSTRING                  215
#define IDD_DIALOG1                     217
#define IDD_ADVDEP                      217
#define IDI_ZAPFILE                     218
#define IDD_SIGNATURES                  218
#define IDD_PRECEDENCE                  219
#define IDB_CERTIFICATE                 219
#define IDD_ERRORINFO                   220
#define IDD_TOOL_ADVANCEDDEFAULTS       221
#define IDD_RSOPCAUSE                   222
#define IDM_ADD_APP                     300
#define IDM_REFRESH                     301
#define IDM_DEL_APP                     302
#define IDM_AUTOINST                    303
#define IDM_ASSIGN                      304
#define IDM_PUBLISH                     305
#define IDM_DISABLE                     306
#define IDM_REDEPLOY                    307
#define IDS_REDEPLOYWARNING             308
#define IDS_DEF_EXTENSION               309
#define IDS_EXTENSION_FILTER_M          310
#define IDS_EXTENSION_FILTER            311
#define IDS_GPTFAILED                   313
#define IDS_ADDFAILED                   314
#define IDS_ADDFAILED_ACCESS_DENIED     315
#define IDS_ADDFAILED_CSFAILURE         316
#define IDS_DEF_TRANSFORM_EXTENSION     317
#define IDS_TRANSFORM_EXTENSION_FILTER  318
#define IDS_TRANSFORM_FAILED            319
#define IDS_BROWSEFOLDERS               320
#define IDS_TRANSFORM_FAILED_IN_CS      321
#define IDS_ADDEXISTSALREADY            322
#define IDS_CLSIDCONFLICT1              323
#define IDS_CLSIDCONFLICT2              324
#define IDS_BOGUS_EXTENSION             325
#define IDS_NO                          326
#define IDS_YES                         327
#define IDS_MULTIPLE                    328
#define IDS_NONE                        329
#define IDS_OPTIONAL                    330
#define IDS_REQUIRED                    331
#define IDS_NO_UNIVERSAL_NAME           332
#define IDS_DELFAILED_ACCESS_DENIED     333
#define IDS_DELFAILED_CSFAILURE         334
#define IDS_REMOVE_LEGACY_TITLE         335
#define IDS_REMOVE_LEGACY_TEXT          336
#define IDS_NO_ZAPS_ALLOWED             337
#define IDS_ADDFAILED_ZAP               338
#define IDM_WINNER                      339
#define IDM_REMOVED                     340
#define IDM_FAILED                      341
#define IDM_ARP                         342
#define IDS_ILLEGAL_PATH                343
#define IDS_ILLEGAL_PLATFORM            344
#define IDS_CERT_DEF_EXT                345
#define IDS_CERT_EXT_FILT               346
#define IDS_TEXT_DEF_EXT                347
#define IDS_TEXT_EXT_FILT               348
#define IDS_ADDFAILED_METADATA_OVERFLOW 349
#define IDS_REDEPLOY_FAILED             350
#define IDS_REDEPLOY_FAILED_IN_CS       351
#define IDS_OS                          400
#define IDS_HW                          410
#define IDM_ASSIGN_T                    504
#define IDM_PUBLISH_T                   505
#define IDM_DISABLE_T                   506
#define IDS_AUTOINSTALL_ON              600
#define IDS_AUTOINSTALL_OFF             601
#define IDS_ASK_AUTOINSTALL             602
#define IDS_USERINSTALL_ON              603
#define IDS_USERINSTALL_OFF             604
#define IDS_TO_PUBLISHED                605
#define IDS_TO_ASSIGNED                 606
#define IDS_BADDATA                     607
#define IDS_PLATFORMREQUIRED            608
#define IDS_CHANGECATEGORY              609
#define IDS_NEWCATEGORY                 610
#define IDS_CATEGORYFAILED              611
#define IDS_REPLACE                     612
#define IDS_UPGRADE                     613
#define IDS_INVALIDUPGRADE              614
#define IDS_COMPUTER                    615
#define IDS_USER                        616
#define IDS_CHANGEFAILED                617
#define IDS_DUPLICATENAME               618
#define IDS_SHORTNAME                   619
#define IDS_LONGNAME                    620
#define IDS_GENERALERROR                621
#define IDS_ERRORPOLICYCHANGED          622
#define IDS_SHORTCATNAME                623
#define IDS_LONGCATNAME                 624
#define IDS_DEPLOYTEXTPUB               625
#define IDS_DEPLOYTEXTASSIGNED          626
#define IDS_DEPLOYTEXTCUSTOM            627
#define IDS_ADVANCEDUSERS               628
#define IDS_ADVANCEDMACHINES            629
#define IDS_OOSUNINST                   630
#define IDS_SHOWARP                     631
#define IDS_UITYPE                      632
#define IDS_IGNORELOC                   633
#define IDS_REMPREV                     634
#define IDS_PRODCODE                    635
#define IDS_UPGRADEDBY                  636
#define IDS_SCRIPT                      637
#define IDS_BASIC                       638
#define IDS_MAXIMUM                     639
#define IDS_ACTRL_READ_CONTROL          640
#define IDS_ACTRL_CHANGE_ACCESS         641
#define IDS_ACTRL_CHANGE_OWNER          642
#define IDS_ACTRL_DS_CREATE_CHILD       643
#define IDS_ACTRL_DS_DELETE_CHILD       644
#define IDS_ACTRL_DS_LIST               645
#define IDS_ACTRL_DS_SELF               646
#define IDS_ACTRL_DS_READ_PROP          647
#define IDS_ACTRL_DS_WRITE_PROP         648
#define IDS_ACTRL_DS_DELETE_TREE        649
#define IDS_ACTRL_DS_LIST_OBJECT        650
#define IDS_ACTRL_DS_CONTROL_ACCESS     651
#define IDS_DS_GENERIC_READ             652
#define IDS_DS_GENERIC_WRITE            653
#define IDS_DS_GENERIC_EXECUTE          654
#define IDS_DS_GENERIC_ALL              655
#define IDS_ACTRL_DELETE                656
#define IDS_NO_ACCESS                   657
#define IDS_PRECEDENCE_COL1             658
#define IDS_PRECEDENCE_COL2             659
#define IDS_PRECEDENCE_COL3             660
#define IDS_PRECEDENCE_COL4             661
#define IDS_NEUTRAL_LOCALE              662
#define IDS_SIGS_COL1                   663
#define IDS_SIGS_COL2                   664
#define IDS_SIGS_COL3                   665
#define IDS_WIN_TEXT                    666
#define IDS_WIN_TOOLTEXT                667
#define IDS_ARP_TEXT                    668
#define IDS_ARP_TOOLTEXT                669
#define IDS_REM_TEXT                    670
#define IDS_REM_TOOLTEXT                671
#define IDS_CERTFROMMSIFAILED           672
#define IDS_ADDCERTFAILED               673
#define IDS_RSOPUPGRADEDTEXT            674
#define IDS_NA                          675
#define IDS_NODATA                      676
#define IDS_RSOP_APPLY                  677
#define IDS_RSOP_AC1                    678
#define IDS_RSOP_AC2                    679
#define IDS_RSOP_AC3                    680
#define IDS_RSOP_AC4                    681
#define IDS_RSOP_AC5                    682
#define IDS_RSOP_AC6                    683
#define IDS_RSOP_AC7                    684
#define IDS_RSOP_AC8                    703
#define IDS_RSOP_LM1                    685
#define IDS_RSOP_LM2                    686
#define IDS_RSOP_LM3                    687
#define IDS_RSOP_LM4                    688
#define IDS_RSOP_LM5                    689
#define IDS_RSOP_EXTACT                 690
#define IDS_RSOP_CLSIDACT               691
#define IDS_RSOP_PROGIDACT              692
#define IDS_RSOP_REMOVAL                693
#define IDS_RSOP_RT2                    694
#define IDS_RSOP_RT3                    695
#define IDS_RSOP_RT4                    696
#define IDS_RSOP_RC2                    697
#define IDS_RSOP_RC3                    698
#define IDS_RSOP_RC4                    699
#define IDS_RSOP_RC5                    700
#define IDS_RSOP_RC6                    701
#define IDS_RSOP_RC7                    702
#define IDS_RSOP_RC8                    704
#define IDS_RSOP_ARP_WARNING            705
#define IDS_RSOP_ARP_WARNING_TITLE      706
#define IDC_LIST1                       1000
#define IDC_LIST3                       1001
#define IDC_EDIT1                       1002
#define IDC_RADIO1                      1003
#define IDC_RADIO2                      1004
#define IDC_CHECK1                      1005
#define IDC_RADIO10                     1005
#define IDC_CHECK2                      1006
#define IDC_RADIO3                      1007
#define IDC_RADIO4                      1008
#define IDC_BUTTON1                     1009
#define IDC_BUTTON2                     1010
#define IDC_BUTTON3                     1011
#define IDC_BUTTON4                     1012
#define IDC_RADIO5                      1013
#define IDC_BUTTON5                     1013
#define IDC_RADIO6                      1014
#define IDC_BUTTON6                     1014
#define IDC_RADIO7                      1015
#define IDC_RADIO8                      1016
#define IDC_RADIO9                      1017
#define IDC_LIST2                       1018
#define IDC_RADIO11                     1018
#define IDC_COMBO1                      1019
#define IDC_STATIC1                     1020
#define IDC_STATIC2                     1021
#define IDC_STATIC3                     1022
#define IDC_STATIC4                     1023
#define IDC_STATIC5                     1024
#define IDC_CN                          1025
#define IDC_STATIC9                     1025
#define IDC_STATIC6                     1026
#define IDC_STATIC7                     1027
#define IDC_STATIC8                     1028
#define IDC_SPIN1                       1030
#define IDC_TITLE                       1034
#define IDC_CHECK3                      1035
#define IDC_CHECK4                      1036
#define IDC_CHECK5                      1037
#define IDC_CHECK6                      1038
#define IDC_RICHEDIT1                   1039
#define IDC_CHECK7                      1039
#define IDC_STATICNOHELP1               1501
#define IDC_STATICNOHELP2               1502
#define IDC_STATICNOHELP3               1503
#define IDC_STATICNOHELP4               1504
#define IDC_STATICNOHELP5               1505
#define IDC_STATICNOHELP6               1506
#define IDC_STATICNOHELP7               1507
#define IDC_STATICNOHELP8               1508
#define IDC_STATICNOHELP9               1509
#define IDC_STATICNOHELP10              1510
#define IDC_STATICNOHELP11              1511
#define IDC_STATICNOHELP12              1512
#define IDC_STATICNOHELP13              1513
#define IDC_STATICNOHELP14              1514
#define IDC_STATICNOHELP15              1515
#define IDC_STATICNOHELP16              1516
#define RT_HELPINFO                     5000
#define IDH_NOCONTEXTHELP              -1L

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\product.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Product.cpp
//
//  Contents:   product information property sheet
//
//  Classes:    CProduct
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProduct property page

IMPLEMENT_DYNCREATE(CProduct, CPropertyPage)

CProduct::CProduct() : CPropertyPage(CProduct::IDD)
{
        //{{AFX_DATA_INIT(CProduct)
        m_szVersion = _T("");
        m_szPublisher = _T("");
        m_szLanguage = _T("");
        m_szContact = _T("");
        m_szPhone = _T("");
        m_szURL = _T("");
        m_szName = _T("");
        m_szPlatform = _T("");
        m_szRevision = _T("");
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
}

CProduct::~CProduct()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CProduct::DoDataExchange(CDataExchange* pDX)
{
    // Make sure the variables have the correct info
    m_pData->GetSzVersion(m_szVersion);
    m_pData->GetSzPublisher(m_szPublisher);
    m_pData->GetSzLocale(m_szLanguage);
    m_pData->GetSzPlatform(m_szPlatform);
    TCHAR szBuffer[256];
    DWORD cch = 256;
    UINT msiReturn = 0;
    if (m_pData->m_pDetails->pszSourceList)
    {
        msiReturn = GetMsiProperty(m_pData->m_pDetails->pszSourceList[0], L"ARPHELPTELEPHONE", szBuffer, &cch);
        if (ERROR_SUCCESS == msiReturn)
        {
            m_szPhone = szBuffer;
        }
        cch = 256;
        msiReturn = GetMsiProperty(m_pData->m_pDetails->pszSourceList[0], L"ARPCONTACT", szBuffer, &cch);
        if (ERROR_SUCCESS == msiReturn)
        {
            m_szContact = szBuffer;
        }
    }
    else
    {
        m_szPhone = "";
        m_szContact = "";
    }

        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CProduct)
        DDX_Text(pDX, IDC_STATIC2, m_szVersion);
        DDX_Text(pDX, IDC_STATIC3, m_szPublisher);
        DDX_Text(pDX, IDC_STATIC4, m_szLanguage);
        DDX_Text(pDX, IDC_STATIC5, m_szContact);
        DDX_Text(pDX, IDC_STATIC6, m_szPhone);
        DDX_Text(pDX, IDC_STATIC7, m_szURL);
        DDX_Text(pDX, IDC_EDIT1, m_szName);
        DDX_Text(pDX, IDC_STATIC9, m_szPlatform);
        DDX_Text(pDX, IDC_STATIC8, m_szRevision);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProduct, CPropertyPage)
        //{{AFX_MSG_MAP(CProduct)
        ON_EN_CHANGE(IDC_EDIT1, OnChangeName)
        ON_EN_CHANGE(IDC_STATIC7, OnChange)
        ON_EN_KILLFOCUS(IDC_EDIT1, OnKillfocusEdit1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CProduct::OnApply()
{
    if (m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    HRESULT hr = S_OK;
    CString szOldURL = m_pData->m_pDetails->pInstallInfo->pszUrl;
    if (0 != szOldURL.Compare(m_szURL))
    {
        hr = E_FAIL;
        if (m_pIClassAdmin)
        {
            hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                                 NULL,
                                                                 NULL,
                                                                 (LPOLESTR)((LPCOLESTR)m_szURL),
                                                                 NULL,
                                                                 NULL,
                                                                 NULL);
            if (SUCCEEDED(hr))
            {
                OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->pszUrl);
                OLESAFE_COPYSTRING(m_pData->m_pDetails->pInstallInfo->pszUrl, m_szURL);
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        CString szOldName = m_pData->m_pDetails->pszPackageName;
        if (0 != szOldName.Compare(m_szName))
        {
            hr = E_FAIL;
            if (m_pIClassAdmin)
            {
                hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                                     (LPOLESTR)((LPCOLESTR)m_szName),
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL);
            }
            if (SUCCEEDED(hr))
            {
                OLESAFE_DELETE(m_pData->m_pDetails->pszPackageName);
                OLESAFE_COPYSTRING(m_pData->m_pDetails->pszPackageName, m_szName);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
            }
        }
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine,
                                                TRUE,
                                                &guidExtension,
                                                m_fMachine ? &guidMachSnapin
                                                    : &guidUserSnapin)))
    {
        ReportPolicyChangedError(m_hWnd);
    }
    if (m_pScopePane->m_pFileExt)
    {
        m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (!m_fPreDeploy)
    {
        MMCPropertyChangeNotify(m_hConsoleHandle, (LPARAM) m_cookie);
    }
    return CPropertyPage::OnApply();
}

void CProduct::OnChange()
{
    SetModified(TRUE);
}

void CProduct::OnChangeName()
{
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (!m_fPreDeploy)
    {
        if (0 != sz.Compare(m_pData->m_pDetails->pszPackageName))
            SetModified();
        else
            SetModified(FALSE);
    }
}

BOOL CProduct::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProduct::OnKillfocusEdit1()
{
    // check that the new name is legitimate
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (sz.GetLength() == 0)
    {
        // empty name
        CString szMessage;
        szMessage.LoadString(IDS_SHORTNAME);
        MessageBox(  szMessage,
                     NULL,
                     MB_OK | MB_ICONEXCLAMATION);
        pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
        SetModified(FALSE);
        return;
    }
    if (sz.GetLength() > 200)  // gonna disallow names longer than 200 chars
    {
        // long name
        CString szMessage;
        szMessage.LoadString(IDS_LONGNAME);
        MessageBox(  szMessage,
                     NULL,
                     MB_OK | MB_ICONEXCLAMATION);
        pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
        SetModified(FALSE);
        return;
    }
    if (0 != sz.Compare(m_pData->m_pDetails->pszPackageName))
    {
        map<MMC_COOKIE, CAppData>::iterator i;
        for (i = m_pAppData->begin(); i != m_pAppData->end(); i++)
        {
            if (0 == sz.Compare(i->second.m_pDetails->pszPackageName))
            {
                // another package has the same name
                CString szMessage;
                szMessage.LoadString(IDS_DUPLICATENAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
                SetModified(FALSE);
                return;
            }
        }
    }
}

LRESULT CProduct::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CProduct::RefreshData(void)
{
    if (m_fRSOP)
    {
        // make the package name edit control read only
        ( (CEdit*) GetDlgItem(IDC_EDIT1) )->SetReadOnly();

        // remove focus from read-only edit controls
        // by setting it to the ok button

        // make the support url edit control read-only
        ( (CEdit*) GetDlgItem(IDC_STATIC7) )->SetReadOnly();

        // disable EVERYTHING else

        // hide the phone and contact fields
        GetDlgItem(IDC_STATICNOHELP6)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATICNOHELP7)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC5)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC6)->ShowWindow(SW_HIDE);
    }
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
    m_szName = m_pData->m_pDetails->pszPackageName;
    m_szURL = m_pData->m_pDetails->pInstallInfo->pszUrl;
    m_szRevision.Format(TEXT("%u"), m_pData->m_pDetails->pInstallInfo->dwRevision);
}


void CProduct::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PRODUCT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\remove.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       remove.cpp
//
//  Contents:   remove application dialog
//
//  Classes:    CRemove
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog


CRemove::CRemove(CWnd* pParent /*=NULL*/)
        : CDialog(CRemove::IDD, pParent)
{
        //{{AFX_DATA_INIT(CRemove)
        m_iState = 0;
        //}}AFX_DATA_INIT
}


void CRemove::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CRemove)
        DDX_Radio(pDX, IDC_RADIO1, m_iState);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemove, CDialog)
        //{{AFX_MSG_MAP(CRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRemove::OnInitDialog()
{
        CDialog::OnInitDialog();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CRemove::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CRemove::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_REMOVE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\remove.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       remove.h
//
//  Contents:   remove application dialog
//
//  Classes:    CRemove
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog

class CRemove : public CDialog
{
// Construction
public:
        CRemove(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
        //{{AFX_DATA(CRemove)
        enum { IDD = IDD_REMOVE };
        int             m_iState;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CRemove)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CRemove)
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\result.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       result.cpp
//
//  Contents:   implementation of the result pane
//
//  Classes:    CResultPane
//
//  History:    03-14-1998   stevebl   Created
//              05-20-1998   RahulTh   Added drag-n-drop support for adding
//                                     packages
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include <atlimpl.cpp>
#include <wbemcli.h>
#include "rsoputil.h"
#include <list>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long CResultPane::lDataObjectRefCount = 0;

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"APPMGR_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

//+--------------------------------------------------------------------------
//
//  Function:   ExtractInternalFormat
//
//  Synopsis:   Returns a pointer to our private object format given an
//              LPDATAOBJECT
//
//  Arguments:  [lpDataObject] - pointer to a DATAOBJECT, generally from a
//                                MMC call.
//
//  Returns:    A pointer to INTERNAL, our internal object structure.
//              NULL - if the object doesn't contain one of our objects
//              (wasn't created by us)
//
//  History:    3-13-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's IComponent implementation

STDMETHODIMP CResultPane::GetResultViewType(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CResultPane::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CResultPane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        //kluge for drag-n-drop through explorer. To enable drag-n-drop
        //through explorer, the paste verb is always enabled. since
        //it is also hidden (see OnSelect), the user cannot use the
        //standard toolbar to paste. However, if the user uses CTRL-V
        //to paste when nothing has been cut, Notify gets invoked with
        //a negative lpDataObject value, therefore, in that particular
        //case, we simply return with an S_OK  -RahulTh 5/20/1998
        if ((LONG_PTR)lpDataObject <= 0)
            return S_OK;

        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            return E_UNEXPECTED;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }
        switch(event)
        {
        case MMCN_COLUMNS_CHANGED:
            break;
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_SELECT:
            hr = OnSelect(pInternal->m_type, cookie, arg, param);
            break;

        case MMCN_COLUMN_CLICK:
            // retain column number and sort option flags so we can pass
            // them in to sort in the event we need to trigger a resort of
            // the result pane
            m_nSortColumn = arg;
            m_dwSortOptions = param;
            break;

        case MMCN_DELETE:
            hr = Command(IDM_DEL_APP, lpDataObject);
            break;

        case MMCN_REFRESH:
            hr = Command(IDM_REFRESH, lpDataObject);
            break;

        case MMCN_QUERY_PASTE:
            //always return S_OK here because there is no way we can check
            //for the validity of the dragged objects here, so we simply
            //give the green signal and wait for the MMCN_PASTE notification
            //to see if the objects being dragged are valid at all.
            hr = S_OK;
            break;

        case MMCN_PASTE:
            if (arg > 0)    //better be safe than sorry
                OnFileDrop ((LPDATAOBJECT)arg);
            hr = S_OK;
            break;

        case MMCN_CONTEXTHELP:
            if (m_pDisplayHelp)
            {
                if (m_pScopePane->m_fRSOP)
                {
                    SHELLEXECUTEINFO ShellInfo;
                    WCHAR            pszHelpFilePath[ MAX_PATH ];

                    memset( &ShellInfo, 0, sizeof( ShellInfo ) );

                    ExpandEnvironmentStringsW (
                        L"%SystemRoot%\\Help\\RSOPsnp.chm",
                        pszHelpFilePath, MAX_PATH);

                    ShellInfo.cbSize = sizeof( ShellInfo );
                    ShellInfo.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_DOENVSUBST;
                    ShellInfo.lpVerb = L"open";
                    ShellInfo.lpFile = L"%SystemRoot%\\hh.exe";
                    ShellInfo.lpParameters = pszHelpFilePath;
                    ShellInfo.nShow = SW_SHOWNORMAL;
                    
                    (void) ShellExecuteEx( &ShellInfo );
                }
                else
                {
                    m_pDisplayHelp->ShowTopic (L"gpedit.chm::/ADE.htm");
                }
            }
            break;

        // Note - Future expansion of notify types possible
        default:
            hr = E_UNEXPECTED;
            break;
        }

        FREE_INTERNAL(pInternal);
    }

    return hr;
}

STDMETHODIMP CResultPane::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::Destroy  this=%08x cookie=%u"), this, cookie));

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pConsoleVerb);
        SAFE_RELEASE(m_pDisplayHelp);
        SAFE_RELEASE(m_pToolbar);
        SAFE_RELEASE(m_pControlbar);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pScopePane)
        {
            m_pScopePane->RemoveResultPane(this);
            ((IComponentData*)m_pScopePane)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
            m_pScopePane = NULL;
        }
    }

    return S_OK;
}

STDMETHODIMP CResultPane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pScopePane != NULL);
    return m_pScopePane->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CResultPane);

CResultPane::CResultPane()
{
#if DBG
    dbg_cRef = 0;
#endif
    DEBUG_INCREMENT_INSTANCE_COUNTER(CResultPane);
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::CResultPane  this=%08x ref=%u"), this, dbg_cRef));
    CResultPane::lDataObjectRefCount = 0;
    m_pDisplayHelp = NULL;
    m_lViewMode = LVS_REPORT;
    BOOL _fVisible = FALSE;
    m_nSortColumn = 0;
    m_dwSortOptions = 0;
    Construct();
}

CResultPane::~CResultPane()
{
#if DBG
    ASSERT(dbg_cRef == 0);
#endif
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::~CResultPane  this=%08x ref=%u"), this, dbg_cRef));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CResultPane);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);

    Construct();

    ASSERT(CResultPane::lDataObjectRefCount == 0);
}

void CResultPane::Construct()
{
#if DBG
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pScopePane = NULL;
    m_pControlbar = NULL;
    m_pToolbar = NULL;
}

CString szExtension;
CString szFilter;

HRESULT CResultPane::InitializeHeaders(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);

    CString sz;
    sz.LoadString(IDS_NAME);
    if (m_pScopePane->m_fRSOP)
    {
        // in RSOP mode the name follows the name for the view

    }
    int n = 0;
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 150);    // name
    sz.LoadString(IDS_VERSION);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 50);     // version
    sz.LoadString(IDS_STATE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 100);    // state
    sz.LoadString(IDS_AUTOINST);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN /*75*/); // auto-inst
    sz.LoadString(IDS_SOURCE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 200);    // source
    sz.LoadString(IDS_MODS);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);    // mods
    sz.LoadString(IDS_LOC);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);     // loc
    sz.LoadString(IDS_OOSUNINST);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_SHOWARP);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_UITYPE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_IGNORELOC);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_REMPREV);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_PRODCODE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_STAGE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);     // stage
    sz.LoadString(IDS_RELATION);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);    // Upgrading
    sz.LoadString(IDS_UPGRADEDBY);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_SCRIPT);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_MACH);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_X86ONWIN64);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_FULLINSTALL);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    if (m_pScopePane->m_fRSOP)
    {
        sz.LoadString(IDS_ORIGIN);
        m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 150);   // origin
        sz.LoadString(IDS_SOM);
        m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);   // origin
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CResultPane::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    return m_pScopePane->
        AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CResultPane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    if (m_pScopePane)
        return m_pScopePane->
            Command(nCommandID, pDataObject);
    else
        return S_OK;
}

HRESULT CResultPane::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

// Result item property pages:
STDMETHODIMP CResultPane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal && (m_pScopePane->m_fRSOP || m_pScopePane->m_pIClassAdmin))
    {
        HRESULT hr = S_OK;
        MMC_COOKIE cookie = pInternal->m_cookie;
        CAppData & data = m_pScopePane->m_AppData[cookie];
        FREE_INTERNAL(pInternal);
        HPROPSHEETPAGE hSecurity = NULL;
        LPSECURITYINFO pSI = NULL;

        //
        // make sure we have an up-to-date categories list
        //
        m_pScopePane->ClearCategories();
        if (m_pScopePane->m_fRSOP)
        {
            m_pScopePane->GetRSoPCategories();
        }
        else
        {
            hr = CsGetAppCategories(&m_pScopePane->m_CatList);
            if (FAILED(hr))
            {
                // report it
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

                // Since failure only means the categories list will be
                // empty, we'll proceed as if nothing happened.

                hr = S_OK;
            }
        }

        //
        // prepare the security property page
        //

        // check to make sure that we have access to this object
        if (m_pScopePane->m_fRSOP)
        {
            pSI = new CRSOPSecurityInfo(&data);
        }
        else
        {
            CString szPath;
            hr = m_pScopePane->GetPackageDSPath(szPath, data.m_pDetails->pszPackageName);
            if (SUCCEEDED(hr))
            {
                hr = DSCreateISecurityInfoObject(szPath,
                                                 NULL,
                                                 0,
                                                 &pSI,
                                                 NULL,
                                                 NULL,
                                                 0);
            }
        }
        if (FAILED(hr))
        {
            // we don't have access to this object (probably due to permissions)
            DebugMsg((DM_WARNING, TEXT("DSCreateISecurityInfoObject failed with 0x%x"), hr));
            // force a refresh
            hr = Command(IDM_REFRESH, lpIDataObject);
            // DON'T quit just because we couldn't create the security page!
            // return S_FALSE;
        }
        if (pSI)
        {
            hSecurity = CreateSecurityPage(pSI);
            pSI->Release();
            if (hSecurity == NULL)
                return E_UNEXPECTED;
        }

        // we have access

        //
        // Create the Product property page
        //
        data.m_pProduct = new CProduct();
        data.m_pProduct->m_ppThis = &data.m_pProduct;
        data.m_pProduct->m_pData = &data;
        data.m_pProduct->m_cookie = cookie;
        data.m_pProduct->m_hConsoleHandle = handle;
        data.m_pProduct->m_pScopePane = m_pScopePane;
        data.m_pProduct->m_pAppData = &m_pScopePane->m_AppData;
        data.m_pProduct->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
        data.m_pProduct->m_fMachine = m_pScopePane->m_fMachine;
        data.m_pProduct->m_fRSOP = m_pScopePane->m_fRSOP;
        // no longer need to marshal, just set it
        if (!m_pScopePane->m_fRSOP)
        {
            data.m_pProduct->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
            data.m_pProduct->m_pIClassAdmin->AddRef();
        }
        else
            data.m_pProduct->m_pIClassAdmin = NULL;

        hr = SetPropPageToDeleteOnClose(&data.m_pProduct->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProduct = CreateThemedPropertySheetPage(&data.m_pProduct->m_psp);
            if (hProduct == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hProduct);
        }

        //
        // Create the Depeployment property page
        //
        data.m_pDeploy = new CDeploy();
        data.m_pDeploy->m_ppThis = &data.m_pDeploy;
        data.m_pDeploy->m_pData = &data;
        data.m_pDeploy->m_cookie = cookie;
        data.m_pDeploy->m_hConsoleHandle = handle;
        data.m_pDeploy->m_fMachine = m_pScopePane->m_fMachine;
        data.m_pDeploy->m_fRSOP = m_pScopePane->m_fRSOP;
        data.m_pDeploy->m_pScopePane = m_pScopePane;
#if 0
        data.m_pDeploy->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
#endif

        // no longer need to marsahl this interface, just set it
        if (!m_pScopePane->m_fRSOP)
        {
            data.m_pDeploy->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
            data.m_pDeploy->m_pIClassAdmin->AddRef();
        }
        else
            data.m_pDeploy->m_pIClassAdmin = NULL;

        hr = SetPropPageToDeleteOnClose(&data.m_pDeploy->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hDeploy = CreateThemedPropertySheetPage(&data.m_pDeploy->m_psp);
            if (hDeploy == NULL)
            {
                return E_UNEXPECTED;
                }
            lpProvider->AddPage(hDeploy);
        }

        if (data.m_pDetails->pInstallInfo->PathType != SetupNamePath)
        {
            //
            // Create the upgrades property page
            //
            data.m_pUpgradeList = new CUpgradeList();
            data.m_pUpgradeList->m_ppThis = &data.m_pUpgradeList;
            data.m_pUpgradeList->m_pData = &data;
            data.m_pUpgradeList->m_cookie = cookie;
            data.m_pUpgradeList->m_hConsoleHandle = handle;
            data.m_pUpgradeList->m_pScopePane = m_pScopePane;
            data.m_pUpgradeList->m_fMachine = m_pScopePane->m_fMachine;
            data.m_pUpgradeList->m_fRSOP = m_pScopePane->m_fRSOP;
#if 0
            data.m_pUpgradeList->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
#endif

            // no longer need to marshal this interface, just set it
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pUpgradeList->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pUpgradeList->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pUpgradeList->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pUpgradeList->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hUpgradeList = CreateThemedPropertySheetPage(&data.m_pUpgradeList->m_psp);
                if (hUpgradeList == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hUpgradeList);
            }
        }

        //
        // Create the Category property page
        //
        if ( ! m_pScopePane->m_fRSOP || ( IDM_ARP == m_pScopePane->m_iViewState ) )
        {
            data.m_pCategory = new CCategory();
            data.m_pCategory->m_ppThis = &data.m_pCategory;
            data.m_pCategory->m_pData = &data;
            data.m_pCategory->m_cookie = cookie;
            data.m_pCategory->m_hConsoleHandle = handle;
            data.m_pCategory->m_pCatList = &m_pScopePane->m_CatList;
            data.m_pCategory->m_fRSOP = m_pScopePane->m_fRSOP;

            // no longer need to marshal this interface, just set it
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pCategory->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pCategory->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pCategory->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pCategory->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hCategory = CreateThemedPropertySheetPage(&data.m_pCategory->m_psp);
                if (hCategory == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hCategory);
            }
        }

        if (data.m_pDetails->pInstallInfo->PathType != SetupNamePath)
        {
            //
            // Create the Xforms property page
            //
            data.m_pXforms = new CXforms();
            data.m_pXforms->m_ppThis = &data.m_pXforms;
            data.m_pXforms->m_pData = &data;
            data.m_pXforms->m_cookie = cookie;
            data.m_pXforms->m_hConsoleHandle = handle;
            data.m_pXforms->m_pScopePane = m_pScopePane;

            // marshal the IClassAdmin interface to the page
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pXforms->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pXforms->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pXforms->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pXforms->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hXforms = CreateThemedPropertySheetPage(&data.m_pXforms->m_psp);
                if (hXforms == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hXforms);
            }
        }

        //
        // Add the security property page
        //
        if (hSecurity)
        {
            lpProvider->AddPage(hSecurity);
        }

        if (m_pScopePane->m_fRSOP)
        {
            // add precedence pane
            data.m_pPrecedence = new CPrecedence();
            data.m_pPrecedence->m_ppThis = &data.m_pPrecedence;
            data.m_pPrecedence->m_szRSOPNamespace = m_pScopePane->m_szRSOPNamespace;
            data.m_pPrecedence->m_pData = &data;
            data.m_pPrecedence->m_iViewState = m_pScopePane->m_iViewState;
            hr = SetPropPageToDeleteOnClose(&data.m_pPrecedence->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hPrecedence = CreateThemedPropertySheetPage(&data.m_pPrecedence->m_psp);
                if (hPrecedence == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hPrecedence);
            }

            if (m_pScopePane->m_iViewState != IDM_ARP)
            {
                // add Cause pane
                data.m_pCause = new CCause();
                data.m_pCause->m_ppThis = &data.m_pCause;
                data.m_pCause->m_pData = &data;
                data.m_pCause->m_fRemovedView = IDM_REMOVED == m_pScopePane->m_iViewState;
                hr = SetPropPageToDeleteOnClose(&data.m_pCause->m_psp);
                if (SUCCEEDED(hr))
                {
                    HPROPSHEETPAGE hCause = CreateThemedPropertySheetPage(&data.m_pCause->m_psp);
                    if (hCause == NULL)
                    {
                        return E_UNEXPECTED;
                    }
                    lpProvider->AddPage(hCause);
                }
            }

            // check for failed settings and add the error pane if necessary
            if (data.m_nStatus == 3)
            {
                data.m_pErrorInfo = new CErrorInfo();
                data.m_pErrorInfo->m_ppThis = &data.m_pErrorInfo;
                data.m_pErrorInfo->m_pData = &data;
                hr = SetPropPageToDeleteOnClose(&data.m_pErrorInfo->m_psp);
                if (SUCCEEDED(hr))
                {
                    HPROPSHEETPAGE hErrorInfo = CreateThemedPropertySheetPage(&data.m_pErrorInfo->m_psp);
                    if (hErrorInfo == NULL)
                    {
                        return E_UNEXPECTED;
                    }
                    lpProvider->AddPage(hErrorInfo);
                }
            }
        }

        if (m_pScopePane->m_ToolDefaults.fShowPkgDetails)
        {
            //
            // Create the Package Details page (debug only)
            //
            data.m_pPkgDetails = new CPackageDetails();
            data.m_pPkgDetails->m_ppThis = &data.m_pPkgDetails;
            data.m_pPkgDetails->m_hConsoleHandle = handle;
            data.m_pPkgDetails->m_pData = &data;
            hr = SetPropPageToDeleteOnClose(&data.m_pPkgDetails->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hDetails = CreateThemedPropertySheetPage(&data.m_pPkgDetails->m_psp);

                if (hDetails == NULL)
                    return E_UNEXPECTED;
                lpProvider->AddPage(hDetails);
            }
        }
    }
    else
        return S_FALSE;

    return S_OK;
}

// Result items property pages:
STDMETHODIMP CResultPane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        if (CCT_RESULT == pInternal->m_type)
        {
            FREE_INTERNAL(pInternal);
            return S_OK;
        }

        FREE_INTERNAL(pInternal);
    }
    return S_FALSE;
}

STDMETHODIMP CResultPane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CResultPane::SetControlbar(LPCONTROLBAR pControlbar)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    if (m_pToolbar)
    {
        SAFE_RELEASE(m_pToolbar);
    }

    if (m_pControlbar)
    {
        SAFE_RELEASE(m_pControlbar);
    }

    if (pControlbar && m_pScopePane->m_fRSOP)
    {
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        hr = m_pControlbar->Create(TOOLBAR,
                                   dynamic_cast<IExtendControlbar *>(this),
                                   reinterpret_cast<IUnknown **>(&m_pToolbar));
        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: Create failed with 0x%x"), hr));
        if (FAILED(hr))
        {
            return hr;
        }

        m_pToolbar->AddRef();

        // add the bitmap

        CBitmap bmp;
        if (!bmp.LoadBitmap(IDB_TOOLBAR1))
        {
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: LoadBitmap failed with 0x%x"), GetLastError()));
            return E_FAIL;
        }

        hr = m_pToolbar->AddBitmap(3,
                                   bmp,
                                   16,
                                   16,
                                   RGB(255, 0, 255));

        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: AddBitmap failed with 0x%x"), hr));
        if (FAILED(hr))
        {
            return hr;
        }

        // add the buttons depending upon our state

        CString szText;
        CString szTooltipText;
        int i = 0;

        MMCBUTTON stButton;
        stButton.nBitmap = 0;
        stButton.idCommand = IDM_WINNER;
        stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_WINNER ? TBSTATE_PRESSED : 0 );
        stButton.fsType = BTNS_GROUP;
        szText.LoadString(IDS_WIN_TEXT);
        szTooltipText.LoadString(IDS_WIN_TOOLTEXT);
        stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
        stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
        hr = m_pToolbar->InsertButton(i++, &stButton);
        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));

        if ((m_pScopePane->m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE) == RSOP_INFO_FLAG_DIAGNOSTIC_MODE)
        {
            // removed packages only apply in diagnostic mode
            stButton.nBitmap = 1;
            stButton.idCommand = IDM_REMOVED;
            stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_REMOVED ? TBSTATE_PRESSED : 0 );;
            szText.LoadString(IDS_REM_TEXT);
            szTooltipText.LoadString(IDS_REM_TOOLTEXT);
            stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
            stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
            hr = m_pToolbar->InsertButton(i++, &stButton);
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));
        }

        if (!m_pScopePane->m_fMachine)
        {
            // ARP packages only apply to users
            stButton.nBitmap = 2;
            stButton.idCommand = IDM_ARP;
            stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_ARP ? TBSTATE_PRESSED : 0 );;
            szText.LoadString(IDS_ARP_TEXT);
            szTooltipText.LoadString(IDS_ARP_TOOLTEXT);
            stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
            stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
            hr = m_pToolbar->InsertButton(i++, &stButton);
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));
        }

    }

    return hr;
}

STDMETHODIMP CResultPane::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    if (m_pControlbar)
    {
        if (event == MMCN_SELECT)
        {
            if (HIWORD(arg))    // is it selected or not
            {
                hr = m_pControlbar->Attach(TOOLBAR,
                                           m_pToolbar);
                DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Attach failed with 0x%x"), hr));
            }
            else if ( (BOOL) LOWORD(arg) )
            {
                hr = m_pControlbar->Detach(m_pToolbar);
                DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Detach failed with 0x%x"), hr));
            }
        }
        else if (event == MMCN_BTN_CLICK)
        {
            hr = Command(param, reinterpret_cast<IDataObject *>(arg));
            DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Command failed with 0x%x"), hr));
        }
    }
    return hr;
}

STDMETHODIMP CResultPane::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    CAppData & dataA = m_pScopePane->m_AppData[cookieA];
    CAppData & dataB = m_pScopePane->m_AppData[cookieB];
    // compare the two based on column and the cookies
    CString szA, szB;

    switch (nCol)
    {
    case 0:
        szA = dataA.m_pDetails->pszPackageName;
        szB = dataB.m_pDetails->pszPackageName;
        break;
    case 1:
        dataA.GetSzVersion(szA);
        dataB.GetSzVersion(szB);
        break;
    case 2:
        dataA.GetSzDeployment(szA);
        dataB.GetSzDeployment(szB);
        break;
    case 3:
        dataA.GetSzAutoInstall(szA);
        dataB.GetSzAutoInstall(szB);
        break;
    case 4:
        dataA.GetSzSource(szA);
        dataB.GetSzSource(szB);
        break;
    case 5:
        dataA.GetSzMods(szA);
        dataB.GetSzMods(szB);
        break;
    case 6:
        dataA.GetSzLocale(szA);
        dataB.GetSzLocale(szB);
        break;
    case 7:
        dataA.GetSzOOSUninstall(szA);
        dataB.GetSzOOSUninstall(szB);
        break;
    case 8:
        dataA.GetSzShowARP(szA);
        dataB.GetSzShowARP(szB);
        break;
    case 9:
        dataA.GetSzUIType(szA);
        dataB.GetSzUIType(szB);
        break;
    case 10:
        dataA.GetSzIgnoreLoc(szA);
        dataB.GetSzIgnoreLoc(szB);
        break;
    case 11:
        dataA.GetSzRemovePrev(szA);
        dataB.GetSzRemovePrev(szB);
        break;
    case 12:
        dataA.GetSzProductCode(szA);
        dataB.GetSzProductCode(szB);
        break;
    case 13:
        dataA.GetSzStage(szA);
        dataB.GetSzStage(szB);
        break;
    case 14:
        dataA.GetSzUpgrades(szA, m_pScopePane);
        dataB.GetSzUpgrades(szB, m_pScopePane);
        break;
    case 15:
        dataA.GetSzUpgradedBy(szA, m_pScopePane);
        dataB.GetSzUpgradedBy(szB, m_pScopePane);
        break;
    case 16:
        szA = dataA.m_pDetails->pInstallInfo->pszScriptPath;
        szB = dataB.m_pDetails->pInstallInfo->pszScriptPath;
        break;
    case 17:
        dataA.GetSzPlatform(szA);
        dataB.GetSzPlatform(szB);
        break;
    case 18:
        dataA.GetSzX86OnWin64(szA);
        dataB.GetSzX86OnWin64(szB);
        break;
    case 19:
        dataA.GetSzFullInstall(szA);
        dataB.GetSzFullInstall(szB);
        break;
    case 20: // only valid in rsop
        dataA.GetSzOrigin(szA);
        dataB.GetSzOrigin(szB);
        break;
    case 21: // only valid in rsop
        dataA.GetSzSOM(szA);
        dataB.GetSzSOM(szB);
        break;
    }
    *pnResult = szA.CompareNoCase(szB);
    return S_OK;
}


STDMETHODIMP CResultPane::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static CString sz;
    ASSERT(pResult != NULL);
    if (pResult)
    {
        if (pResult->lParam == -1)
        {
            switch (pResult->nCol)
            {
            case 0:
                pResult->str = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
                break;
            default:
                pResult->str = (BSTR)_T("");
                break;
            }
        }
        else
        {
            map<MMC_COOKIE, CAppData>::iterator i = m_pScopePane->m_AppData.find(pResult->lParam);
            if (i != m_pScopePane->m_AppData.end())
            {
                CAppData & data = i->second;
                switch (pResult->nCol)
                {
                case 0:
                    sz = data.m_pDetails->pszPackageName;
                    break;
                case 1:
                    data.GetSzVersion(sz);
                    break;
                case 2:
                    data.GetSzDeployment(sz);
                    break;
                case 3:
                    data.GetSzAutoInstall(sz);
                    break;
                case 4:
                    data.GetSzSource(sz);
                    break;
                case 5:
                    data.GetSzMods(sz);
                    break;
                case 6:
                    data.GetSzLocale(sz);
                    break;
                case 7:
                    data.GetSzOOSUninstall(sz);
                    break;
                case 8:
                    data.GetSzShowARP(sz);
                    break;
                case 9:
                    data.GetSzUIType(sz);
                    break;
                case 10:
                    data.GetSzIgnoreLoc(sz);
                    break;
                case 11:
                    data.GetSzRemovePrev(sz);
                    break;
                case 12:
                    data.GetSzProductCode(sz);
                    break;
                case 13:
                    data.GetSzStage(sz);
                    break;
                case 14:
                    data.GetSzUpgrades(sz, m_pScopePane);
                    break;
                case 15:
                    data.GetSzUpgradedBy(sz, m_pScopePane);
                    break;
                case 16:
                    sz = data.m_pDetails->pInstallInfo->pszScriptPath;
                    break;
                case 17:
                    data.GetSzPlatform(sz);
                    break;
                case 18:
                    data.GetSzX86OnWin64(sz);
                    break;
                case 19:
                    data.GetSzFullInstall(sz);
                    break;
                case 20:
                    data.GetSzOrigin(sz);
                    break;
                case 21:
                    data.GetSzSOM(sz);
                    break;
                default:
                    sz = "";
                    break;
                }
                pResult->str = (unsigned short *)((LPCOLESTR)sz);
            }
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CResultPane::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    _fVisible = (BOOL)arg;

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pScopePane != NULL);
        InitializeHeaders(cookie);
        m_pResult->SetViewMode(m_lViewMode);

        if (m_pScopePane->m_fRSOP || m_pScopePane->m_pIClassAdmin)
        {
            // if there's no IClassAdmin then there's nothing to enumerate
            // unless we're in RSOP mode
            Enumerate(cookie, param);
        }
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);
    }

    return hr;
}

HRESULT CResultPane::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick)
{
    return S_FALSE;
}

HRESULT CResultPane::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (m_pConsoleVerb)
    {
        // If it's in the result pane then "properties" should be the
        // default action.  Otherwise "open" should be the default action.
        if (type == CCT_RESULT)
        {
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            // Enable the delete verb.
            // (UI review - we're NOT going to enable
            // the delete verb after all.)
            // m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

            // Enable the properties verb.
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        }
        else
        {
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            if (!m_pScopePane->m_fRSOP)
            {
                // Enable the properties verb.
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            }
        }
        // Set the default verb to open

        // Enable the refresh verb.
        if (!m_pScopePane->m_fRSOP)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
        }
        // Enable the paste verb and hide. due to the weird way in which
        // MMC handles drag-n-drop scenarios, the only way to enable drag-n-drop
        // from explorer is to keep the paste verb enabled forever.
        // But do this only if we are not in RSoP because PASTE is meaningless
        // for RSoP which is Read-Only.
        if (!m_pScopePane->m_fRSOP)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        }
        else
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnPropertyChange(LPARAM param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    if(m_pScopePane->m_AppData[param].m_fVisible)
    {
        RESULTDATAITEM rd;
        memset(&rd, 0, sizeof(rd));
        rd.mask = RDI_IMAGE;
        rd.itemID = m_pScopePane->m_AppData[param].m_itemID;
        rd.nImage = m_pScopePane->m_AppData[param].GetImageIndex(m_pScopePane);
        m_pResult->SetItem(&rd);
        m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
    }
    return hr;
}

HRESULT CResultPane::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CResultPane::Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    EnumerateResultPane(cookie);
}


HRESULT GetFailedSettings(IWbemServices * pNamespace,
                          CAppData &data,
                          IWbemClassObject * pInst)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    BSTR strLanguage = SysAllocString(TEXT("WQL"));
    if (strLanguage)
    {
        CString szRelPath;
        hr = GetParameter(pInst,
                          TEXT("__RELPATH"),
                          szRelPath);
        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"__RELPATH\") failed with 0x%x", hr));
        if (SUCCEEDED(hr))
        {
            // build the proper query
            CString szQuery = TEXT("ASSOCIATORS OF {");
            szQuery += szRelPath;
            szQuery += TEXT("} WHERE ResultClass=RSOP_PolicySettingStatus");

            BSTR strQuery = SysAllocString(szQuery);
            if (strQuery)
            {
                IEnumWbemClassObject * pEnum = NULL;
                // execute the query
                hr = pNamespace->ExecQuery(strLanguage,
                                           strQuery,
                                           WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pEnum);
                DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  pNamespace->ExecQuery failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject * pObj = NULL;
                    ULONG n = 0;
                    // get the result (only care about the first entry)
                    hr = pEnum->Next(WBEM_INFINITE,
                                     1,
                                     &pObj,
                                     &n);
                    DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  pEnum->Next failed with 0x%x", hr));
                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj, TEXT("EventSource"), data.m_szEventSource);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventSource\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("EventLogName"), data.m_szEventLogName);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventLogName\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("EventID"), data.m_dwEventID);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventId\") failed with 0x%x", hr));
                        BSTR bstrTime = NULL;
                        hr = GetParameterBSTR(pObj, TEXT("EventTime"),bstrTime);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventTime\") failed with 0x%x", hr));
                        if (SUCCEEDED(hr))
                        {
                            data.m_szEventTime = bstrTime;
                            if (bstrTime)
                                SysFreeString(bstrTime);
                        }
                        hr = GetParameter(pObj, TEXT("ErrorCode"), data.m_hrErrorCode);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"ErrorCode\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("Status"), data.m_nStatus);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"Status\") failed with 0x%x", hr));
                    }
                    pEnum->Release();
                }
                SysFreeString(strQuery);
            }
            else
            {
                DebugMsg((DM_WARNING, L"GetFailedSettings:  SysAllocString failed with %u", GetLastError()));
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}


HRESULT
GetUniqueUpgradeName(
    IWbemServices * pNamespace,
    BSTR            strLanguage,
    CString&        szGPOID,
    CString         szGPOName,
    CString&        szUpgradeName)
{
    HRESULT hr;
    CString GpoName;

    hr = S_OK;

    if ( pNamespace )
    {
        LPTSTR pszGPOName = NULL;

        hr = GetGPOFriendlyName(pNamespace,
                                (LPTSTR)((LPCTSTR) szGPOID),
                                strLanguage,
                                &pszGPOName);

        GpoName = pszGPOName;

        DebugReportFailure(hr, (DM_WARNING, L"GetUniqueUpgradeName:  GetGPOFriendlyName failed with 0x%x", hr));

        OLESAFE_DELETE(pszGPOName);
    }
    else
    {
        GpoName = szGPOName;
    }

    if (SUCCEEDED(hr))
    {
        szUpgradeName += TEXT(" (");
        szUpgradeName += GpoName;
        szUpgradeName += TEXT(")");
    }

    return hr;
}


HRESULT GetRsopFriendlyAppName(
    IWbemServices * pNamespace,
    CAppData &data)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    CString szGPO;

    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if (strLanguage)
    {
        if (SUCCEEDED(hr))
        {
            // build the proper query
            CString szQuery = TEXT("SELECT Name, GPOID FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=1");
            szQuery += TEXT(" AND ApplicationId=\"");
            szQuery += data.m_szRemovingApplication;
            szQuery +=L'\"';

            BSTR strQuery = SysAllocString(szQuery);
            if (strQuery)
            {
                IEnumWbemClassObject * pEnum = NULL;
                // execute the query
                hr = pNamespace->ExecQuery(strLanguage,
                                           strQuery,
                                           WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pEnum);
                DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  pNamespace->ExecQuery failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject * pObj = NULL;
                    ULONG n = 0;
                    // get the result (only care about the first entry)
                    hr = pEnum->Next(WBEM_INFINITE,
                                     1,
                                     &pObj,
                                     &n);
                    DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  pEnum->Next failed with 0x%x", hr));
                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj, TEXT("Name"), data.m_szRemovingApplicationName);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetParameter(\"Name\") failed with 0x%x", hr));
                    }

                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj,
                                          TEXT("GPOID"),
                                          szGPO);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetParameter(\"GPOID\") failed with 0x%x", hr));
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        hr = GetUniqueUpgradeName(
                            pNamespace,
                            strLanguage,
                            szGPO,
                            TEXT(""),
                            data.m_szRemovingApplicationName);
                    }

                    pEnum->Release();
                }

                DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetUniqueUpgradeName failed with 0x%x", hr));

                SysFreeString(strQuery);
            }
            else
            {
                DebugMsg((DM_WARNING, L"GetRsopFriendlyAppName:  SysAllocString failed with %u", GetLastError()));
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}


HRESULT GetRSOPUpgrades(IWbemServices * pNamespace,
                        TCHAR * szGPOID,
                        IWbemClassObject * pInst,
                        TCHAR * szParam,
                        set <CString> &s)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if (strLanguage)
    {
        CString EntryType;

        hr = pInst->Get(szParam, 0, &var, 0, 0);
        DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pInst->Get(\"%s\") failed with 0x%x", szParam, hr));

        if ( SUCCEEDED(hr) )
        {
            VARIANT varEntryType;

            VariantInit( &varEntryType );

            hr = pInst->Get( L"EntryType", 0, &varEntryType, 0, 0 );

            if ( SUCCEEDED(hr) )
            {
                if ( VT_I4 == varEntryType.vt )
                {
                    EntryType.Format( TEXT("%d"), varEntryType.lVal );
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }

            VariantClear( &varEntryType );
        }

        if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
        {
            CString sz;
            SAFEARRAY * parray = var.parray;
            BSTR * rgData = (BSTR *)parray->pvData;
            UINT ui = parray->rgsabound[0].cElements;
            while (ui--)
            {
                sz = rgData[ui];

                // Find the app that this guid matches

                // first build the proper query
                CString szQuery = TEXT("SELECT Name, GPOID FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=");

                szQuery += EntryType;
                szQuery += TEXT(" AND ApplicationId=");
                szQuery +=L'\"';
                szQuery += sz;
                szQuery +=L'\"';

                BSTR strQuery = SysAllocString(szQuery);
                if (strQuery)
                {
                    IEnumWbemClassObject * pEnum = NULL;
                    // execute the query
                    hr = pNamespace->ExecQuery(strLanguage,
                                               strQuery,
                                               WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                               NULL,
                                               &pEnum);
                    DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pNamespace->ExecQuery failed with 0x%x", hr));
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject * pObj = NULL;
                        ULONG n;
                        // get the result (only care about the first entry)
                        hr = pEnum->Next(WBEM_INFINITE,
                                         1,
                                         &pObj,
                                         &n);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pEnum->Next failed with 0x%x", hr));
                        if (SUCCEEDED(hr) && n > 0)
                        {
                            // get the PackageName
                            hr = GetParameter(pObj,
                                              TEXT("Name"),
                                              sz);
                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetParameter(\"Name\") failed with 0x%x", hr));

                            // get the GPOID
                            CString szGPO;
                            hr = GetParameter(pObj,
                                              TEXT("GPOID"),
                                              szGPO);
                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetParameter(\"GPOID\") failed with 0x%x", hr));

                            hr = GetUniqueUpgradeName(pNamespace,
                                                strLanguage,
                                                szGPO,
                                                TEXT(""),
                                                sz);

                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetUniqueUpgradeName failed with 0x%x", hr));

                            // insert the name
                            s.insert(sz);
                            pObj->Release();
                        }
                        pEnum->Release();
                    }
                    SysFreeString(strQuery);
                }
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}

HRESULT
GetRSOPUpgradedBy( map<MMC_COOKIE, CAppData>* pAppData )
{
    map<MMC_COOKIE, CAppData>::iterator AppIterator;
    CString UpgradeId;
    CString AppId;

    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if ( ! strLanguage )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr;

    hr = S_OK;

    //
    // For each app, retrieve the set of apps that it upgrades
    //
    for ( AppIterator = pAppData->begin(); AppIterator != pAppData->end(); AppIterator++)
    {
        {
            CAppData& AppData = AppIterator->second;

            AppId = AppData.m_pDetails->pszPackageName;

            hr = GetUniqueUpgradeName(
                NULL,
                strLanguage,
                AppData.m_szGPOID,
                AppData.m_szGPOName,
                AppId);

            if ( FAILED(hr) )
            {
                break;
            }

            //
            // Iterate through each upgrade to see if
            // we can find the upgrade in the list of apps
            //
            set <CString>::iterator CurrentUpgrade;

            for (
                CurrentUpgrade = AppData.m_setUpgrade.begin();
                CurrentUpgrade != AppData.m_setUpgrade.end();
                CurrentUpgrade++)
            {
                map<MMC_COOKIE, CAppData>::iterator UpgradeIterator;

                for (
                    UpgradeIterator = pAppData->begin();
                    pAppData->end() != UpgradeIterator;
                    UpgradeIterator++)
                {
                    UpgradeId = UpgradeIterator->second.m_pDetails->pszPackageName;

                    hr = GetUniqueUpgradeName(
                        NULL,
                        strLanguage,
                        UpgradeIterator->second.m_szGPOID,
                        UpgradeIterator->second.m_szGPOName,
                        UpgradeId);

                    if ( FAILED(hr) )
                    {
                        break;
                    }

                    //
                    // See if this potential upgrade corresponds to the current upgrade
                    // listed in the current app -- if so, mark the upgraded app as being
                    // upgraded by the current app
                    //
                    if ( *CurrentUpgrade == UpgradeId )
                    {
                        UpgradeIterator->second.m_setUpgradedBy.insert( AppId );
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                for (
                    CurrentUpgrade = AppData.m_setReplace.begin();
                    CurrentUpgrade != AppData.m_setReplace.end();
                    CurrentUpgrade++)
                {
                    map<MMC_COOKIE, CAppData>::iterator UpgradeIterator;

                    for (
                        UpgradeIterator = pAppData->begin();
                        pAppData->end() != UpgradeIterator;
                        UpgradeIterator++)
                    {
                        UpgradeId = UpgradeIterator->second.m_pDetails->pszPackageName;

                        hr = GetUniqueUpgradeName(
                            NULL,
                            strLanguage,
                            UpgradeIterator->second.m_szGPOID,
                            UpgradeIterator->second.m_szGPOName,
                            UpgradeId);

                        if ( FAILED(hr) )
                        {
                            break;
                        }

                        //
                        // See if this potential upgrade corresponds to the current upgrade
                        // listed in the current app -- if so, mark the upgraded app as being
                        // upgraded by the current app
                        //
                        if ( *CurrentUpgrade == UpgradeId )
                        {
                            UpgradeIterator->second.m_setUpgradedBy.insert( AppId );
                        }
                    }
                }
            }

            if ( FAILED(hr) )
            {
                break;
            }
        }

        if ( FAILED( hr) )
        {
            break;
        }
    }

    SysFreeString(strLanguage);

    return hr;
}

HRESULT CResultPane::EnumerateRSoPData(void)
{
    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = NULL;
    CString szText;

    m_pScopePane->m_AppData.erase(m_pScopePane->m_AppData.begin(), m_pScopePane->m_AppData.end());

    switch (m_pScopePane->m_iViewState)
    {
    case IDM_WINNER:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=1"));
        szText.LoadString(IDS_WIN_TEXT);
        break;
    case IDM_REMOVED:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=2"));
        szText.LoadString(IDS_REM_TEXT);
        break;
    case IDM_ARP:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=3"));
        szText.LoadString(IDS_ARP_TEXT);
        break;
    }
    // set text of first column to match the view state
    m_pHeader->SetColumnText(0, szText);

    BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  CoCreateInstance failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pLocator->ConnectServer failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  CoSetProxyBlanket failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pNamespace->ExecQuery failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    ULONG uEnumIndex = 0;
    do
    {    
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &uEnumIndex);
        DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pEnum->Next failed with 0x%x", hr));
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (uEnumIndex > 0)
        {
            // prepare the data entry and populate all the fields
            CAppData data;
            data.m_fRSoP = TRUE;
            BOOL fDemandInstallable = FALSE;
            int iLossOfScopeAction = 0;
            BOOL fDisplayInARP = FALSE;
            BOOL fIgnoreLanguage = FALSE;
            BOOL fUpgradeSettingsMandatory = FALSE;
            BOOL fUninstallUnmanaged = FALSE;
            BOOL fAllowX86OnWin64 = FALSE;
            int iAssignmentType = 0;
            UINT uiDeploymentType = 0;
            WCHAR * szPackageLocation = NULL;
            UINT nTransforms = 0;
            WCHAR ** rgszTransforms = NULL;
            PACKAGEDETAIL * pd = new PACKAGEDETAIL;
            ACTIVATIONINFO * pa = (ACTIVATIONINFO *)OLEALLOC(sizeof(ACTIVATIONINFO));
            PLATFORMINFO * pp = (PLATFORMINFO *)OLEALLOC(sizeof(PLATFORMINFO));
            INSTALLINFO * pi = (INSTALLINFO *)OLEALLOC(sizeof(INSTALLINFO));
            if (pd && pa && pi && pp)
            {
                memset(pi, 0, sizeof(INSTALLINFO));
                memset(pp, 0, sizeof(PLATFORMINFO));
                memset(pa, 0, sizeof(ACTIVATIONINFO));
                memset(pd, 0, sizeof(PACKAGEDETAIL));
                pd->pActInfo = pa;
                pd->pPlatformInfo = pp;
                pd->pInstallInfo = pi;
            }
            else
            {
                // out of memory
                if (pd)
                {
                    delete pd;
                }
                if (pa)
                {
                    OLESAFE_DELETE(pa);
                }
                if (pi)
                {
                    OLESAFE_DELETE(pi);
                }
                if (pp)
                {
                    OLESAFE_DELETE(pp);
                }
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              pd->pszPackageName);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Name\") failed with 0x%x", hr));
            DWORD dwPrecedence;
            hr = GetParameter(pObj,
                              TEXT("Precedence"),
                              dwPrecedence);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Precedence\") failed with 0x%x", hr));
            if ((1 != dwPrecedence) &&  (IDM_REMOVED != m_pScopePane->m_iViewState))
            {
                data.m_fHide = TRUE;
            }
            hr = GetParameter(pObj,
                              TEXT("VersionNumberLo"),
                              pi->dwVersionLo);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"VersionNumberLo\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("VersionNumberHi"),
                              pi->dwVersionHi);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"VersionNumberHi\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("Publisher"),
                              pd->pszPublisher);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Publisher\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("ProductId"),
                              pi->ProductCode);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ProductId\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("ScriptFile"),
                              pi->pszScriptPath);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ScriptFile\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SupportURL"),
                              pi->pszUrl);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SupportURL\") failed with 0x%x", hr));
            pp->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
            if (!pp->prgLocale)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            pp->cLocales = 1;
            hr = GetParameter(pObj,
                              TEXT("LanguageID"),
                              pp->prgLocale[0]);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LanguageID\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("MachineArchitectures"),
                              pp->cPlatforms,
                              pp->prgPlatform);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"MachineArchitectures\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DeploymentType"),
                              uiDeploymentType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DeploymentType\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("InstallationUI"),
                              pi->InstallUiLevel);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"InstallationUI\") failed with 0x%x", hr));
            if (pi->InstallUiLevel == 2)
            {
                pi->InstallUiLevel = INSTALLUILEVEL_FULL;
            }
            else
            {
                pi->InstallUiLevel = INSTALLUILEVEL_BASIC;
            }
            hr = GetParameter(pObj,
                              TEXT("RedeployCount"),
                              pi->dwRevision);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RedeployCount\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DemandInstallable"),
                              fDemandInstallable);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DemandInstallable\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("LossOfScopeAction"),
                              iLossOfScopeAction);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LossOfScopeAction\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DisplayInARP"),
                              fDisplayInARP);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DisplayInARP\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("IgnoreLanguage"),
                              fIgnoreLanguage);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"IgnoreLanguage\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("UninstallUnmanaged"),
                              fUninstallUnmanaged);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"UninstallUnmanaged\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("AssignmentType"),
                              iAssignmentType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"AssignmentType\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("AllowX86OnIA64"),
                              fAllowX86OnWin64);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"AllowX86OnIA64\") failed with 0x%x", hr));

            // build proper flags
            pi->dwActFlags = (uiDeploymentType == 2 ? ACTFLG_Published : ACTFLG_Assigned)
                | (fDemandInstallable ? ACTFLG_OnDemandInstall : 0)
                | (iLossOfScopeAction == 1 ? ACTFLG_UninstallOnPolicyRemoval : ACTFLG_OrphanOnPolicyRemoval)
                | (fDisplayInARP ? ACTFLG_UserInstall : 0)
                | (fUninstallUnmanaged ? ACTFLG_UninstallUnmanaged : 0)
                | (fIgnoreLanguage ? ACTFLG_IgnoreLanguage : 0)
                | (iAssignmentType == 3 ? ACTFLG_InstallUserAssign : 0);
            {
                int nArch = pp->cPlatforms;
                while (nArch--)
                {
                    if (pp->prgPlatform[nArch].dwProcessorArch == PROCESSOR_ARCHITECTURE_INTEL)
                    {
                        if (!fAllowX86OnWin64)
                        {
                            pi->dwActFlags |= ACTFLG_ExcludeX86OnWin64;
                        }
                    }
                }
            }

            hr = GetParameter(pObj,
                              TEXT("UpgradeSettingsMandatory"),
                              fUpgradeSettingsMandatory);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"UpgradeSettingsMandatory\") failed with 0x%x", hr));
            if (fUpgradeSettingsMandatory)
            {
                pi->dwActFlags |= ACTFLG_ForceUpgrade;
            }
            hr = GetParameter(pObj,
                              TEXT("PackageLocation"),
                              szPackageLocation);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"PackageLocation\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("transforms"),
                              nTransforms,
                              rgszTransforms
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"transforms\") failed with 0x%x", hr));
            pd->pszSourceList = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * (nTransforms + 1));
            if (!pd->pszSourceList)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            pd->cSources = nTransforms + 1;
            if (NULL != pd->pszSourceList)
            {
                pd->pszSourceList[0] = szPackageLocation;
                UINT n = nTransforms;
                while (n--)
                {
                    pd->pszSourceList[1 + n] = rgszTransforms[n];
                }
                OLESAFE_DELETE(rgszTransforms);
            }
            /* UNDONE
            hr = GetParameter(pObj,
                              TEXT("localeMatchType"),
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LocaleMatchType\") failed with 0x%x", hr));
                     */
            hr = GetParameter(pObj,
                              TEXT("categories"),
                              pd->cCategories,
                              pd->rpCategory
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"categories\") failed with 0x%x", hr));
            data.m_pDetails = pd;
            data.InitializeExtraInfo();

            hr = GetParameter(pObj,
                              TEXT("GPOID"),
                              data.m_szGPOID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"GPOID\") failed with 0x%x", hr));
            LPTSTR pszGPOName = NULL;
            hr = GetGPOFriendlyName(pNamespace,
                                    (LPTSTR)((LPCTSTR) data.m_szGPOID),
                                    strQueryLanguage,
                                    &pszGPOName);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetGPOFriendlyName failed with 0x%x", hr));
            if (SUCCEEDED(hr))
            {
                data.m_szGPOName = pszGPOName;
                OLESAFE_DELETE(pszGPOName);
            }

            hr = GetParameter(pObj,
                              TEXT("Id"),
                              data.m_szDeploymentGroupID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Id\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SOMID"),
                              data.m_szSOMID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SOMID\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SecurityDescriptor"),
                              data.m_psd);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SecurityDescriptor\") failed with 0x%x", hr));
            hr = GetRSOPUpgrades(pNamespace,
                                 0,
                                 pObj,
                                 TEXT("UpgradeableApplications"),
                                 data.m_setUpgrade);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetRSOPUpgrades(\"UpgradeableApplications\") failed with 0x%x", hr));
            hr = GetRSOPUpgrades(pNamespace,
                                 0,
                                 pObj,
                                 TEXT("ReplaceableApplications"),
                                 data.m_setReplace);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetRSOPUpgrades(\"ReplaceableApplications\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("ApplyCause"),
                              data.m_dwApplyCause);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ApplyCause\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("LanguageMatch"),
                              data.m_dwLanguageMatch);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LanguageMatch\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandFileExtension"),
                              data.m_szOnDemandFileExtension);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandFileExtension\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandClsid"),
                              data.m_szOnDemandClsid);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandClsid\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandProgid"),
                              data.m_szOnDemandProgid);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandProgid\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovalCause"),
                              data.m_dwRemovalCause);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovalCause\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovalType"),
                              data.m_dwRemovalType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovalType\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovingApplication"),
                              data.m_szRemovingApplication);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovingType\") failed with 0x%x", hr));

            if ( SUCCEEDED(hr) )
            {
                hr = GetRsopFriendlyAppName(
                    pNamespace,
                    data);
            }

            hr = GetFailedSettings(pNamespace,
                                   data,
                                   pObj);
            if (SUCCEEDED(hr))
            {
                LPOLESTR lpText;
                hr = this->m_pScopePane->m_pIRSOPInformation->GetEventLogEntryText((LPOLESTR)(LPCOLESTR)data.m_szEventSource,
                                                                                   (LPOLESTR)(LPCOLESTR)data.m_szEventLogName,
                                                                                   (LPOLESTR)(LPCOLESTR)data.m_szEventTime,
                                                                                   data.m_dwEventID,
                                                                                   &lpText);
                DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetEventLogEntryText failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    data.m_szEventLogText = lpText;
                    CoTaskMemFree(lpText);
                }
            }

            // insert the entry in the list
            m_pScopePane->m_AppData[++m_pScopePane->m_lLastAllocated] = data;
            m_pScopePane->m_UpgradeIndex[GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid)] = m_pScopePane->m_lLastAllocated;
            // prepare for the next itteration
            if (pObj)
            {
                pObj->Release();
                pObj = NULL;
            }
        }
    } while (uEnumIndex > 0);

    hr = GetRSOPUpgradedBy( &(m_pScopePane->m_AppData) );

cleanup:
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}

void CResultPane::EnumerateResultPane(MMC_COOKIE cookie)
{
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    if (m_pScopePane) // make sure we've been initialized before we do any of this.
    {
        ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
        RESULTDATAITEM resultItem;
        memset(&resultItem, 0, sizeof(RESULTDATAITEM));

        // Right now we only have one folder and it only
        // contains a list of application packages so this is really simple.

        if ( ( m_pScopePane->m_AppData.begin() == m_pScopePane->m_AppData.end() ) ||
            m_pScopePane->m_fRSOP )  // test to see if the data has been initialized
        {
            HRESULT hr = S_OK;
            if (m_pScopePane->m_fRSOP)
            {
                // get the data from RSOP database
                hr = EnumerateRSoPData();
            }
            else
            {
                // get the data from ClassStore
                ASSERT(m_pScopePane->m_pIClassAdmin != NULL);
                IClassAdmin * pICA = m_pScopePane->m_pIClassAdmin;
                CSPLATFORM csPlatform;
                memset(&csPlatform, 0, sizeof(CSPLATFORM));

                IEnumPackage * pIPE = NULL;

                hr = pICA->EnumPackages(
                                    NULL,
                                    NULL,
                                    APPQUERY_ADMINISTRATIVE,
                                    NULL,
                                    NULL,
                                    &pIPE);
                if (SUCCEEDED(hr))
                {
                    PACKAGEDISPINFO * pi = new PACKAGEDISPINFO;
                    if (pi)
                    {
                        hr = pIPE->Reset();
                        while (SUCCEEDED(hr))
                        {
                            ULONG nceltFetched;

                            hr = pIPE->Next(1, pi, &nceltFetched);
                            if (nceltFetched)
                            {
                                PACKAGEDETAIL * pd = new PACKAGEDETAIL;
                                HRESULT hrPackageDetail = pICA->GetPackageDetails(pi->pszPackageName, pd);
                                _DebugMsg(DM_VERBOSE, TEXT("EnumerateResultPane: GetPackageDetails returned with 0x%x"), hrPackageDetail);                                
                                if (SUCCEEDED(hrPackageDetail))
                                {
                                    _DebugMsg(DM_VERBOSE, TEXT("EnumerateResultPane: GetPackageDetails succeeded with installinfo pointer value with 0x%x"), pd->pInstallInfo);
                                    CAppData data;
                                    data.m_pDetails = pd;

                                    data.InitializeExtraInfo();

                                    m_pScopePane->m_AppData[++m_pScopePane->m_lLastAllocated] = data;
                                    m_pScopePane->m_UpgradeIndex[GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid)] = m_pScopePane->m_lLastAllocated;
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("GetPackageDetails failed with 0x%x"), hrPackageDetail));
                                    delete pd;
                                }
                            }
                            else
                            {
                                break;
                            }
                            ReleasePackageInfo(pi);
                        }
                        delete pi;
                    }
                    SAFE_RELEASE(pIPE);
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = m_pScopePane->PopulateExtensions();
                if (SUCCEEDED(hr))
                {
                    hr = m_pScopePane->PopulateUpgradeLists();
                }
            }
        }
        if (_fVisible)
        {
            map<MMC_COOKIE, CAppData>::iterator i = m_pScopePane->m_AppData.begin();
            while (i != m_pScopePane->m_AppData.end())
            {
                if (!i->second.m_fHide)
                {
                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = i->second.GetImageIndex(m_pScopePane);
                    resultItem.lParam = i->first;
                    m_pResult->InsertItem(&resultItem);
                    i->second.m_fVisible = TRUE;
                    i->second.m_itemID = resultItem.itemID;
                }
                i++;
            }
            m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
        }

    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CResultPane::OnFileDrop
//
//  Synopsis:   this functions handles files dropped into the MMC snapin
//
//  Arguments:
//          [in] lpDataObject : the data object being dropped
//
//  Returns:
//          TRUE  - all the dropped objects were successfully added
//          FALSE - at least some of the dropped objects could not be added
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes: The dropped files are required to have a .msi extension
//
//---------------------------------------------------------------------------
BOOL CResultPane::OnFileDrop (LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    ASSERT (lpDataObject);

    int nFiles, index, nRequired, iSlashPos;
    STGMEDIUM medium;
    HDROP hDrop;
    TCHAR* szFileName;
    UINT cbSize;
    FORMATETC fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    CString szDisplayName;
    CString szSource;
    CString szExt;
    BOOL fRetVal = TRUE;
    BOOL fOneDropSucceeded = FALSE; //at least one file drop succeeded
    HRESULT hr;

    // always fail if we're in RSOP mode (we're read-only in this mode)
    if (m_pScopePane->m_fRSOP)
    {
        return FALSE;
    }

    //check if the dropped items support HDROP
    //for files dragged from explorer, this is always supported
    if (FAILED(hr = lpDataObject->GetData(&fe, &medium)))
    {
        return FALSE;
    }

    //the data object supports HDROP.
    //this means that files are being dragged & dropped from explorer.

    //crack open the data object to get the names of the files being dropped.
    hDrop = (HDROP)medium.hGlobal;
    //start with MAX_PATH, will work for most cases.
    //if not, we will increase buffer size based on need.
    //but we start with MAX_PATH in an attempt to minimize re-allocations
    szFileName = new TCHAR [cbSize = MAX_PATH];
    nFiles = ::DragQueryFile (hDrop, 0xFFFFFFFF, NULL, 0);

    for (index = 0; index < nFiles; index++)
    {
        //find out the size of the buffer required (including the terminating
        //NULL)
        nRequired = ::DragQueryFile (hDrop, index, NULL, 0) + 1;

        //expand the buffer if necessary. Note that we never contract it.
        //Saves code and time
        if (nRequired > cbSize)
        {
            delete [] szFileName;
            szFileName = new TCHAR [cbSize = nRequired];
        }
        //get the full filename of the file being dropped.
        ::DragQueryFile (hDrop, index, szFileName, cbSize);
#if 0
        // stevebl - gonna let any file through at this point.  If it isn't
        // a valid darwin file, AddMSIPackage will catch it and display an
        // appropriate error.

        //check the file extension
        if (!(GetCapitalizedExt(szFileName, szExt) && TEXT("MSI") == szExt))
        {
            //do we put up an error message here?
            fRetVal = FALSE;    //failed for this file. wrong extension
            continue;
        }
#endif
        //try to get a UNC path
        hr = GetUNCPath (szFileName, szSource);

        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString (IDS_NO_UNIVERSAL_NAME);
            if (IDYES != ::MessageBox (m_pScopePane->m_hwndMainWindow, sz, szSource, MB_YESNO | MB_ICONEXCLAMATION))
                continue;
        }

        //now get the display name for the file.
        iSlashPos = szSource.ReverseFind ('\\');
        if (-1 == iSlashPos)
            szDisplayName = szSource;
        else
            szDisplayName = szSource.Mid (iSlashPos + 1);

        //check the file extension to see if it's a ZAP file
        if (GetCapitalizedExt(szFileName, szExt) && TEXT("ZAP") == szExt)
        {
            if (m_pScopePane->m_fMachine)
            {
                CString szText;
                CString szTitle;
                szText.LoadString(IDS_NO_ZAPS_ALLOWED);
                // only allow ZAP files to be deployed to users
                ::MessageBox(m_pScopePane->m_hwndMainWindow,
                             szText,
                             szTitle,
                             MB_OK | MB_ICONEXCLAMATION);
                hr = E_FAIL;
            }
            else
            {
                hr = m_pScopePane->AddZAPPackage (szSource, szDisplayName);
            }
        }
        else
        {
            hr = m_pScopePane->AddMSIPackage (szSource, szDisplayName);
        }
        if (SUCCEEDED(hr))
            fOneDropSucceeded = TRUE;
    }

    //notify the clients
    if (fOneDropSucceeded && m_pScopePane->m_pIGPEInformation)
    {
        if (FAILED(m_pScopePane->m_pIGPEInformation->PolicyChanged (m_pScopePane->m_fMachine,
                                                         TRUE, &guidExtension,
                                                         m_pScopePane->m_fMachine ? &guidMachSnapin
                                                                                  : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_pScopePane->m_hwndMainWindow);
        }
    }
    //keep the environment clean. Pick up your litter.
    delete [] szFileName;

    return fRetVal;
}

// This code is needed to ensure that property pages get cleaned up properly.
// This ensures that when the property sheet is closed all my of property
// pages that are associated with that property sheet will get deleted.
LPFNPSPCALLBACK _MMCHookProp;

UINT CALLBACK HookPropertySheetProp(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookProp(hwnd, uMsg, ppsp);
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        delete (CPropertyPage *) ppsp->lParam;
        return TRUE;
    default:
        break;
    }
    return i;
}

LRESULT SetPropPageToDeleteOnClose(void * vpsp)
{
    HRESULT hr = MMCPropPageCallback(vpsp);
    if (SUCCEEDED(hr))
    {
        if (vpsp == NULL)
            return E_POINTER;

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

        if ((void*)psp->pfnCallback == (void*)HookPropertySheetProp)
            return E_UNEXPECTED;

        _MMCHookProp = psp->pfnCallback;

        psp->pfnCallback = HookPropertySheetProp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "sddl.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        delete [] szData;
        szData = NULL;
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            ULONG ulNoChars = _tcslen(var.bstrVal) + 1;

            szData = (TCHAR *) OLEALLOC(sizeof(TCHAR) * ulNoChars);
            if (szData)
            {
                hr = StringCchCopy(szData, ulNoChars, var.bstrVal);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        szData = "";
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = var.bstrVal;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (bstrData)
    {
        SysFreeString(bstrData);
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
        if (NULL == bstrData)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        fData = var.bVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        hrData = (HRESULT) var.lVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ulData = var.ulVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid)
{
    TCHAR * sz = NULL;
    memset(&guid, 0, sizeof(GUID));
    HRESULT hr = GetParameter(pInst, szParam, sz);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(sz, &guid);
    }
    if (sz)
    {
        OLESAFE_DELETE(sz);
    }
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    ui = 0;
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ui = (HRESULT) var.uiVal;
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of guids and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, GUID * &rgGuid)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgGuid = (GUID *)OLEALLOC(sizeof(GUID) * uiCount);
            if (rgGuid)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    hr = CLSIDFromString(rgData[ui], &rgGuid[ui]);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of strings and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, TCHAR ** &rgszData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgszData = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * uiCount);
            if (rgszData)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    OLESAFE_COPYSTRING(rgszData[ui], rgData[ui]);
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of CSPLATFORM objects and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, CSPLATFORM * &rgData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_I4))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgData = (CSPLATFORM *)OLEALLOC(sizeof(CSPLATFORM) * uiCount);
            if (rgData)
            {
                ULONG * rgulData = (ULONG *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    rgData[ui].dwPlatformId = VER_PLATFORM_WIN32_NT;
                    rgData[ui].dwVersionHi = 5;
                    rgData[ui].dwVersionLo = 0;
                    rgData[ui].dwProcessorArch = rgulData[ui];
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd)
{
    VARIANT var;
    HRESULT hr = S_OK;
    if (psd)
    {
        LocalFree(psd);
        psd = NULL;
    }
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        psd = (PSECURITY_DESCRIPTOR) LocalAlloc( LPTR, var.parray->rgsabound[0].cElements * sizeof( BYTE ) );

        if ( psd )
        {
            memcpy( psd, var.parray->pvData, var.parray->rgsabound[0].cElements * sizeof( BYTE ) );

            if (!IsValidSecurityDescriptor(psd))
            {
                LocalFree(psd);
                psd = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID, BSTR pLanguage,
                           LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    ULONG ulQueryNoChars = lstrlen(lpGPOID) + 50;
    lpQuery = (LPTSTR) LocalAlloc (LPTR, ulQueryNoChars * sizeof(TCHAR));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    WCHAR szQueryFormat[] = TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\"");

    hr = StringCchPrintf (lpQuery, ulQueryNoChars, szQueryFormat, lpGPOID);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: StringCchPrintf returned error")));
        goto Exit;
    }

    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        ULONG ulNoChars = lstrlen(lpGPOID) + 1;
        //
        // In this case, we cannot find the gpo -- it has most likely been deleted.  To give the user some
        // useful information, we will fall back to the guid.
        //
        *pGPOName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

        if ( *pGPOName )
        {
            DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Using GPO guid for friendly name because GPO can't be found")));
            hr = StringCchCopy( *pGPOName, ulNoChars, lpGPOID );
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for GPO Name in GUID form")));
            hr = E_OUTOFMEMORY;
        }

        goto Exit;
    }

    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    ULONG ulNoChars = lstrlen(varGPOName.bstrVal) + 1;
    
    *pGPOName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hr = StringCchCopy (*pGPOName, ulNoChars, varGPOName.bstrVal);
    ASSERT(SUCCEEDED(hr));

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

HRESULT CStringFromWBEMTime(CString &szOut, BSTR bstrIn, BOOL fShortFormat)
{
    HRESULT hr = E_FAIL;
    WBEMTime wt(bstrIn);
    FILETIME ft;
    if (wt.GetFILETIME(&ft))
    {
        CTime t(ft);
        if (fShortFormat)
        {
            szOut = t.Format(TEXT("%x"));
        }
        else
        {
            szOut = t.Format(TEXT("%#c"));
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = StringCchCopy(pwszPathBuf, cchPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\rsopsec.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rsopsec.cpp
//
//  Contents:   implementation used by the RSOP mode security pane
//
//  Classes:    CRSOPSecurityInfo
//
//  Functions:
//
//  History:    02-15-2000   stevebl   Created
//
//---------------------------------------------------------------------------


#include "precomp.hxx"

const
ACCESS_MASK
GENERIC_READ_MAPPING =    ((STANDARD_RIGHTS_READ)     | \
                           (ACTRL_DS_LIST)            | \
                           (ACTRL_DS_READ_PROP)       | \
                           (ACTRL_DS_LIST_OBJECT));

const
ACCESS_MASK
GENERIC_EXECUTE_MAPPING = ((STANDARD_RIGHTS_EXECUTE)  | \
                           (ACTRL_DS_LIST));

const
ACCESS_MASK
GENERIC_WRITE_MAPPING =   ((STANDARD_RIGHTS_WRITE)    | \
                           (ACTRL_DS_SELF)            | \
                           (ACTRL_DS_WRITE_PROP));

const
ACCESS_MASK
GENERIC_ALL_MAPPING =     ((STANDARD_RIGHTS_REQUIRED) | \
                           (ACTRL_DS_CREATE_CHILD)    | \
                           (ACTRL_DS_DELETE_CHILD)    | \
                           (ACTRL_DS_DELETE_TREE)     | \
                           (ACTRL_DS_READ_PROP)       | \
                           (ACTRL_DS_WRITE_PROP)      | \
                           (ACTRL_DS_LIST)            | \
                           (ACTRL_DS_LIST_OBJECT)     | \
                           (ACTRL_DS_CONTROL_ACCESS)  | \
                           (ACTRL_DS_SELF));

//The Following array defines the permission names for DS Key Objects
SI_ACCESS siDSAccesses[] =
{
    { NULL, DS_GENERIC_ALL,           MAKEINTRESOURCE(IDS_DS_GENERIC_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { NULL, DS_GENERIC_READ,          MAKEINTRESOURCE(IDS_DS_GENERIC_READ),       SI_ACCESS_GENERAL },
    { NULL, DS_GENERIC_WRITE,         MAKEINTRESOURCE(IDS_DS_GENERIC_WRITE),      SI_ACCESS_GENERAL },
    { NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_ACTRL_DS_LIST),         SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_LIST_OBJECT,     MAKEINTRESOURCE(IDS_ACTRL_DS_LIST_OBJECT),  SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_ACTRL_DS_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_ACTRL_DS_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { NULL, DELETE,                   MAKEINTRESOURCE(IDS_ACTRL_DELETE),          SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_DELETE_TREE,     MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_TREE),  SI_ACCESS_SPECIFIC },
    { NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_ACTRL_READ_CONTROL),    SI_ACCESS_SPECIFIC },
    { NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_ACTRL_CHANGE_ACCESS),   SI_ACCESS_SPECIFIC },
    { NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_ACTRL_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { NULL, 0,                        MAKEINTRESOURCE(IDS_NO_ACCESS),             0 },
    { NULL, ACTRL_DS_SELF,            MAKEINTRESOURCE(IDS_ACTRL_DS_SELF),         SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_CONTROL_ACCESS,  MAKEINTRESOURCE(IDS_ACTRL_DS_CONTROL_ACCESS),SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
};

/*
SI_INHERIT_TYPE siDSInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_CONTAINER_ONLY)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_CONTAINER_SUBITEMS) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBITEMS_ONLY)      },
};
*/

STDMETHODIMP CRSOPSecurityInfo::QueryInterface(REFIID riid,
                                               LPVOID *ppv)
{
    if (IsEqualIID(riid, IID_ISecurityInformation) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CRSOPSecurityInfo::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRSOPSecurityInfo::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRSOPSecurityInfo::MapGeneric(const GUID *pguidObjectType,
                                           UCHAR *pAceFlags,
                                           ACCESS_MASK *pMask)
{
    GENERIC_MAPPING gm;
    gm.GenericRead = GENERIC_READ_MAPPING;
    gm.GenericWrite = GENERIC_WRITE_MAPPING;
    gm.GenericExecute = GENERIC_EXECUTE_MAPPING;
    gm.GenericAll = GENERIC_ALL_MAPPING;
    MapGenericMask(pMask, &gm);
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    pObjectInfo->dwFlags = SI_READONLY | SI_ADVANCED | SI_SERVER_IS_DC;
    pObjectInfo->hInstance = ghInstance;
    pObjectInfo->pszServerName = NULL;
    pObjectInfo->pszObjectName = m_pData->m_pDetails->pszPackageName;
    pObjectInfo->pszPageTitle = NULL;
    memset(&pObjectInfo->guidObjectType, 0, sizeof(GUID));
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetSecurity(SECURITY_INFORMATION RequestedInformation,
                                            PSECURITY_DESCRIPTOR *ppSD,
                                            BOOL fDefault)
{
    HRESULT hr = S_OK;
    if (IsValidSecurityDescriptor(m_pData->m_psd))
    {
        ULONG nLength = GetSecurityDescriptorLength(m_pData->m_psd);

        *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
        if (*ppSD != NULL)
            CopyMemory(*ppSD, m_pData->m_psd, nLength);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppSD = NULL;
    }
    return hr;
}

STDMETHODIMP CRSOPSecurityInfo::SetSecurity(SECURITY_INFORMATION SecurityInformation,
                                            PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    return E_ACCESSDENIED;
}

STDMETHODIMP CRSOPSecurityInfo::GetAccessRights(const GUID * pguidObjectType,
                                                DWORD dwFlags,
                                                PSI_ACCESS * ppAccess,
                                                ULONG *pcAccesses,
                                                ULONG *piDefaultAccess)
{
    *ppAccess = siDSAccesses;
    *pcAccesses = sizeof(siDSAccesses)/sizeof(siDSAccesses[0]);
    *piDefaultAccess = 0;
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE * ppInheritTypes,
                                                ULONG *pcInheritTypes)
{
    *ppInheritTypes = NULL;
    *pcInheritTypes = 0;
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::PropertySheetPageCallback(HWND hwnd,
                                                          UINT uMsg,
                                                          SI_PAGE_TYPE uPage)
{
    return S_FALSE; // prevents UI from displaying pop-ups
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData);
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, GUID * &rgGuid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, TCHAR ** &rgszData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, CSPLATFORM * &rgPlatform);
HRESULT CStringFromWBEMTime(CString &szOut, BSTR bstrIn, BOOL fShortFormat);

//+--------------------------------------------------------------------------
//
//  Function:   GetGPOFriendlyName
//
//  Synopsis:
//
//  Arguments:  [pIWbemServices] -
//              [lpGPOID]        -
//              [pLanguage]      -
//              [pGPOName]       -
//              [pGPOPath]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    01-26-2000   stevebl   Stolen from code written by EricFlo
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID,
                           BSTR pLanguage,
                           LPTSTR *pGPOName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\rsopsec.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rsopsec.h
//
//  Contents:   used in RSOP mode security pane
//
//  Classes:    CRSOPSecurityInfo
//
//  Functions:
//
//  History:    02-15-2000   stevebl   Created
//
//---------------------------------------------------------------------------


class CRSOPSecurityInfo : public ISecurityInformation
{
private:
    ULONG       m_cRef;
    CAppData *  m_pData;
public:
    CRSOPSecurityInfo(CAppData * pData) {m_pData = pData; m_cRef = 1;}
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
                                                     LPVOID *ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE MapGeneric(const GUID *pguidObjectType,
                                                 UCHAR *pAceFlags,
                                                 ACCESS_MASK *pMask);
    // *** ISecurityInformation methods ***
    virtual HRESULT STDMETHODCALLTYPE GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    virtual HRESULT STDMETHODCALLTYPE GetSecurity(SECURITY_INFORMATION RequestedInformation,
                                                  PSECURITY_DESCRIPTOR *ppSecurityDescriptor, BOOL fDefault);
    virtual HRESULT STDMETHODCALLTYPE SetSecurity(SECURITY_INFORMATION SecurityInformation,
                                                  PSECURITY_DESCRIPTOR pSecurityDescriptor);
    virtual HRESULT STDMETHODCALLTYPE GetAccessRights(const GUID *pguidObjectType,
                                                      DWORD dwFlags, PSI_ACCESS *ppAccess,
                                                      ULONG *pcAccesses,
                                                      ULONG *piDefaultAccess);
    virtual HRESULT STDMETHODCALLTYPE GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                                      ULONG *pcInheritTypes);
    virtual HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(HWND hwnd,
                                                                UINT uMsg,
                                                                SI_PAGE_TYPE uPage);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\script.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       script.h
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#define _NEW_
#include <vector>
using namespace std;

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey);
HRESULT BuildScriptAndGetActInfo(PACKAGEDETAIL & pd, BOOL bFileExtensionsOnly, BOOL bGenerateClasses = TRUE, WCHAR* wszScriptPath = NULL);

#include "scriptgen.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\scope.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cpp
//
//  Contents:   implementation of the scope pane
//
//  Classes:    CScopePane
//
//  History:    03-14-1998   stevebl   Created
//              05-20-1998   RahulTh   added GetUNCPath and modified Command to
//                                     use this function
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <wbemcli.h>
#include "rsoputil.h"
#include <list>

// Comment this line to stop trying to set the main snapin icon in the
// scope pane.
#define SET_SCOPE_ICONS 1

// Un-comment the next line to persist snap-in related data.  (This really
// shouldn't be necessary since I get all my info from my parent anyway.)
// #define PERSIST_DATA 1

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CScopePane);

CScopePane::CScopePane()
{
#if DBG
    dbg_cRef = 0;
#endif
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopePane);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CScopePane  this=%08x ref=%u"), this, dbg_cRef));

    m_pToolDefs = NULL;
    m_pTracking = NULL;
    m_pCatList = NULL;
    m_pFileExt = NULL;
    m_bIsDirty = FALSE;

    m_hwndMainWindow = NULL;
    m_fMachine = FALSE;
    m_fRSOP = FALSE;
    m_iViewState = IDM_WINNER;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIClassAdmin = NULL;
    m_pIPropertySheetProvider = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPEInformation = NULL;
    m_pIRSOPInformation = NULL;
    m_dwRSOPFlags = 0;
    m_lLastAllocated = 0;
    m_ToolDefaults.NPBehavior = NP_PUBLISHED;
    m_ToolDefaults.fUseWizard = TRUE;
    m_ToolDefaults.fCustomDeployment = FALSE;
    m_ToolDefaults.UILevel = INSTALLUILEVEL_FULL;
    m_ToolDefaults.szStartPath = L"";   // UNDONE - need to come up with a
                                        // good default setting for this
    m_ToolDefaults.iDebugLevel = 0;
    m_ToolDefaults.fShowPkgDetails = 0;
    m_ToolDefaults.nUninstallTrackingMonths = 12;
    m_ToolDefaults.fUninstallOnPolicyRemoval = FALSE;
    m_ToolDefaults.fZapOn64 = FALSE;
    m_ToolDefaults.f32On64 = TRUE;
    m_ToolDefaults.fExtensionsOnly = TRUE;
    m_CatList.cCategory = 0;
    m_CatList.pCategoryInfo = NULL;
    m_fBlockAddPackage = FALSE;
    m_fDisplayedRsopARPWarning = FALSE;
    
}

CScopePane::~CScopePane()
{

    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopePane);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::~CScopePane  this=%08x ref=%u"), this, dbg_cRef));
    ClearCategories();
    ASSERT(m_pScope == NULL);
    ASSERT(CResultPane::lDataObjectRefCount == 0);
}
#include <msi.h>

STDMETHODIMP CScopePane::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);


#ifdef SET_SCOPE_ICONS
    LPIMAGELIST lpScopeImage;
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));
    SAFE_RELEASE(lpScopeImage);
#endif

    // get the main window
    hr = m_pConsole->GetMainWindow(&m_hwndMainWindow);
    ASSERT(hr == S_OK);
    return S_OK;
}

void CScopePane::RemoveResultPane(CResultPane * pRP)
{
    m_sResultPane.erase(pRP);
}

STDMETHODIMP CScopePane::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CreateComponent  this=%08x ppComponent=%08x."), this, ppComponent));

    CComObject<CResultPane>* pObject;
    CComObject<CResultPane>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CreateComponent  pObject=%08x."), pObject));

    m_sResultPane.insert(pObject);

    // Store IComponentData
    pObject->SetIComponentData(this);
    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

HRESULT CScopePane::TestForRSoPData(BOOL * pfPolicyFailed)
{
    *pfPolicyFailed = FALSE;
    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    BSTR strObject = SysAllocString(TEXT("RSOP_ExtensionStatus.extensionGuid=\"{c6dc5466-785a-11d2-84d0-00c04fb169f7}\""));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting"));
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: CoCreateInstance failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pLocator->ConnectServer failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: CoSetProxyBlanket failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pNamespace->ExecQuery failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pEnum->Next failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    if (n == 0)
    {
        // there's no data here
        hr = E_FAIL;
        goto cleanup;
    }
    if (pObj)
    {
        pObj->Release();
        pObj=NULL;
    }

    // check for failed settings
    hr = pNamespace->GetObject(strObject,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObj,
                          NULL);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pNamespace->GetObject failed with 0x%x"), hr));
    if (SUCCEEDED(hr))
    {
        HRESULT hrStatus;
        hr = GetParameter(pObj,
                          TEXT("error"),
                          hrStatus);
        DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: GetParameter(\"error\") failed with 0x%x"), hr));
        if (SUCCEEDED(hr))
        {
            *pfPolicyFailed = hrStatus != 0;
        }
    }
cleanup:
    SysFreeString(strObject);
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}


STDMETHODIMP CScopePane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        SaveToolDefaults();
        hr = OnProperties(param);
    }
    else if ( event == MMCN_REMOVE_CHILDREN )
    {
        //
        // In RSoP, we may get called to refresh the scope pane when the query
        // is re-executed -- if this happens, current nodes will be removed and
        // we must reset all of our cached information.  We reset the relevant
        // information below
        //

        if ( ((HSCOPEITEM)arg != NULL) && m_fRSOP && (m_pIRSOPInformation != NULL) )
        {
            m_pIRSOPInformation->Release();
                    
            m_pIRSOPInformation = NULL;

            m_iViewState = IDM_WINNER;
                
            m_fDisplayedRsopARPWarning = FALSE;

            m_dwRSOPFlags = 0;
        }
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        MMC_COOKIE cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_fRSOP)
        {
            if (m_pIRSOPInformation == NULL)
            {
                WCHAR szBuffer[MAX_DS_PATH];
                m_fRSOPEnumerate = FALSE;
                IRSOPInformation * pIRSOPInformation;
                hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                reinterpret_cast<void**>(&pIRSOPInformation));
                if (SUCCEEDED(hr))
                {
                    m_pIRSOPInformation = pIRSOPInformation;
                    m_pIRSOPInformation->AddRef();

                    hr = m_pIRSOPInformation->GetFlags(&m_dwRSOPFlags);
                    if (SUCCEEDED(hr))
                    {
                        /*  extract the namespace here */
                        hr = m_pIRSOPInformation->GetNamespace(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                        if (SUCCEEDED(hr))
                        {
                            m_szRSOPNamespace = szBuffer;
                            // check to be sure that there is data to show in the RSoP database
                            if SUCCEEDED(TestForRSoPData(&m_fRSOPPolicyFailed))
                                m_fRSOPEnumerate = TRUE;
                        }
                        pIRSOPInformation->Release();
                    }
                }
            }
        }
        else
        {
            if (m_pIGPEInformation == NULL)
            {
                IGPEInformation * pIGPEInformation;
                hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                reinterpret_cast<void**>(&pIGPEInformation));
                if (SUCCEEDED(hr))
                {
                    GROUP_POLICY_OBJECT_TYPE gpoType;
                    hr = pIGPEInformation->GetType(&gpoType);
                    if (SUCCEEDED(hr))
                    {
                        if (gpoType == GPOTypeDS)
                        {
                            WCHAR szBuffer[MAX_DS_PATH];
                            do
                            {
                                hr = pIGPEInformation->GetDSPath(GPO_SECTION_ROOT, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_szGPO = szBuffer;
                                hr = pIGPEInformation->GetDisplayName(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_szGPODisplayName = szBuffer;
                                hr = pIGPEInformation->GetDSPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_pIGPEInformation = pIGPEInformation;
                                m_pIGPEInformation->AddRef();
                                m_szLDAP_Path = szBuffer;
                                hr = pIGPEInformation->GetFileSysPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));

                                if (FAILED(hr)) break;
                                m_szGPT_Path = szBuffer;

                                // Here we get the domain name from the GPT_Path.
                                // The domain name is the very first element in
                                // the path so this is quite trivial.
                                m_szDomainName = &((LPCTSTR)m_szGPT_Path)[2]; // skip the "\\"
                                m_szDomainName = m_szDomainName.SpanExcluding(L"\\");

                                m_szGPT_Path += L"\\Applications";
                                hr = InitializeADE();
                                LoadToolDefaults();
                                if (SUCCEEDED(hr))
                                {
                                    // cleanup archived records in the class store
                                    FILETIME ft;
                                    SYSTEMTIME st;
                                    // get current time
                                    GetSystemTime(&st);
                                    // convert it to a FILETIME value
                                    SystemTimeToFileTime(&st, &ft);
                                    // subtract the right number of days
                                    LARGE_INTEGER li;
                                    li.LowPart = ft.dwLowDateTime;
                                    li.HighPart = ft.dwHighDateTime;
                                    li.QuadPart -= ONE_FILETIME_DAY * (((LONGLONG)m_ToolDefaults.nUninstallTrackingMonths * 365)/12);
                                    ft.dwLowDateTime = li.LowPart;
                                    ft.dwHighDateTime = li.HighPart;
                                    // tell the CS to clean up anything older
                                    m_pIClassAdmin->Cleanup(&ft);
                                }
                                else
                                {
                                    // we can still continue even if
                                    // initialization failed provided
                                    // that the reason it failed is that
                                    // the ClassStore object doesn't exist.
                                    if (CS_E_OBJECT_NOTFOUND == hr)
                                    {
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        // report error
                                        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_INIT_FAILED, hr);
                                    }
                                }
                            } while (0);
                        }
                        else
                        {
                            // force this to fail
                            hr = E_FAIL;
                        }
                    }
                    pIGPEInformation->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_EXPAND:
                {
                    hr = OnExpand(cookie, arg, param);
                }
                break;

            case MMCN_SELECT:
                hr = OnSelect(cookie, arg, param);
                break;

            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(cookie, arg, param);
                break;

            case MMCN_REFRESH:
                hr = Command(IDM_REFRESH, lpDataObject);
                break;

            default:
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CScopePane::Destroy()
{
    // Delete enumerated scope items
    DeleteList();

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIClassAdmin);
    SAFE_RELEASE(m_pIPropertySheetProvider);
    SAFE_RELEASE(m_pIGPEInformation);
    SAFE_RELEASE(m_pIRSOPInformation);

    return S_OK;
}

STDMETHODIMP CScopePane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);

    CComObject<CDataObject>* pObject;

    HRESULT hr = CComObject<CDataObject>::CreateInstance(&pObject);
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    pObject->m_fMachine = m_fMachine;
    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CScopePane::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    if (m_fRSOP)
    {
        if (m_fMachine)
            *pClassID = CLSID_RSOP_MachineSnapin;
        else
            *pClassID = CLSID_RSOP_Snapin;
    }
    else
    {
        if (m_fMachine)
            *pClassID = CLSID_MachineSnapin;
        else
            *pClassID = CLSID_Snapin;
    }

    return S_OK;
}

STDMETHODIMP CScopePane::IsDirty()
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CScopePane::Load(IStream *pStm)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // Read the string
    TCHAR psz[MAX_DS_PATH];
    ULONG nBytesRead;
    ULONG cb;
    HRESULT hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
    if (SUCCEEDED(hr))
    {
        hr = pStm->Read(psz, cb, &nBytesRead);
        if (SUCCEEDED(hr))
        {
            if (cb > MAX_DS_PATH * sizeof(TCHAR))
            {
                return E_FAIL;
            }
            m_szLDAP_Path = psz;

            hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
            if (SUCCEEDED(hr))
            {
                if (cb > MAX_DS_PATH * sizeof(TCHAR))
                {
                    return E_FAIL;
                }
                hr = pStm->Read(psz, cb, &nBytesRead);

                if (SUCCEEDED(hr))
                {
                    m_szGPT_Path = psz;
                    m_fLoaded = TRUE;
                    ClearDirty();
                    LoadToolDefaults();
                }
            }
        }
    }
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
#else
    return S_OK;
#endif
}

STDMETHODIMP CScopePane::Save(IStream *pStm, BOOL fClearDirty)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    ULONG cb = (m_szLDAP_Path.GetLength() + 1) * sizeof(TCHAR);
    HRESULT hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szLDAP_Path, cb, &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    cb = (m_szGPT_Path.GetLength() + 1) * sizeof(TCHAR);
    hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szGPT_Path, cb, &nBytesWritten);

    if (FAILED(hr))
        return STG_E_CANTSAVE;
#endif
    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CScopePane::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
#ifdef PERSIST_DATA
    ASSERT(pcbSize);

    ULONG cb = (m_szLDAP_Path.GetLength() + m_szGPT_Path.GetLength() + 2) * sizeof(TCHAR) + 2 * sizeof(ULONG);
    // Set the size of the string to be saved
#else
    ULONG cb = 0;
#endif
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CScopePane::InitNew(void)
{
    return S_OK;
}

void CScopePane::LoadToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"rt");
    if (f)
    {
        WCHAR sz[256];
        CString szData;
        CString szKey;
        while (fgetws(sz, 256, f))
        {
            szData = sz;
            szKey = szData.SpanExcluding(L"=");
            szData = szData.Mid(szKey.GetLength()+1);
            szData.TrimRight();
            szData.TrimLeft();
            szKey.TrimRight();
            if (0 == szKey.CompareNoCase(KEY_NPBehavior))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.NPBehavior);
            }
            else if (0 == szKey.CompareNoCase(KEY_fUseWizard))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fUseWizard);
            }
            else if (0 == szKey.CompareNoCase(KEY_fCustomDeployment))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fCustomDeployment);
            }
            else if (0 == szKey.CompareNoCase(KEY_UILevel))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.UILevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_szStartPath))
            {
                m_ToolDefaults.szStartPath = szData;
            }
            else if (0 == szKey.CompareNoCase(KEY_nUninstallTrackingMonths))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.nUninstallTrackingMonths);
            }
            else if (0 == szKey.CompareNoCase(KEY_iDebugLevel))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.iDebugLevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_fShowPkgDetails))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fShowPkgDetails);
            }
            else if (0 == szKey.CompareNoCase(KEY_fUninstallOnPolicyRemoval))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fUninstallOnPolicyRemoval);
            }
            else if (0 == szKey.CompareNoCase(KEY_f32On64))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.f32On64);
            }
            else if (0 == szKey.CompareNoCase(KEY_fZapOn64))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fZapOn64);
            }
            else if (0 == szKey.CompareNoCase(KEY_fExtensionsOnly))
            {
                (void) swscanf(szData, L"%i", &m_ToolDefaults.fExtensionsOnly);
            }
        }
        fclose(f);
    }
}

void CScopePane::SaveToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"wt");
    if (f)
    {
        fwprintf(f, L"%s=%i\n", KEY_NPBehavior, m_ToolDefaults.NPBehavior);
        fwprintf(f, L"%s=%i\n", KEY_fUseWizard, m_ToolDefaults.fUseWizard);
        fwprintf(f, L"%s=%i\n", KEY_fCustomDeployment, m_ToolDefaults.fCustomDeployment);
        fwprintf(f, L"%s=%i\n", KEY_UILevel, m_ToolDefaults.UILevel);
        fwprintf(f, L"%s=%s\n", KEY_szStartPath, (LPCWSTR) (m_ToolDefaults.szStartPath));
        fwprintf(f, L"%s=%i\n", KEY_nUninstallTrackingMonths, m_ToolDefaults.nUninstallTrackingMonths);
        fwprintf(f, L"%s=%i\n", KEY_fUninstallOnPolicyRemoval, m_ToolDefaults.fUninstallOnPolicyRemoval);
        fwprintf(f, L"%s=%i\n", KEY_f32On64, m_ToolDefaults.f32On64);
        fwprintf(f, L"%s=%i\n", KEY_fZapOn64, m_ToolDefaults.fZapOn64);
        fwprintf(f, L"%s=%i\n", KEY_fExtensionsOnly, m_ToolDefaults.fExtensionsOnly);
        if (m_ToolDefaults.iDebugLevel > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_iDebugLevel, m_ToolDefaults.iDebugLevel);
        }
        if (m_ToolDefaults.fShowPkgDetails > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_fShowPkgDetails, m_ToolDefaults.fShowPkgDetails);
        }
        fclose(f);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetClassStoreName
//
//  Synopsis:   Gets the name of the class store from the DS.
//              If the name isn't stored under the "defaultClassStore"
//              property then the name "CN = Class Store" is used and the
//              property is set.
//
//  Arguments:  [sz]        - [out] name of the class store
//              [fCreateOK] - [in] TRUE if the class store is to be created
//                             if it doesn't already exist.  Otherwise this
//                             routine fails if the class store isn't found.
//
//  Returns:    S_OK on success
//
//  History:    2-17-1998   stevebl   Created
//
//  Notes:      Assumes m_szLDAP_Path contains the path to the DS object.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetClassStoreName(CString &sz, BOOL fCreateOK)
{
    if (m_fRSOP)
    {
        return E_UNEXPECTED;
    }
    HRESULT hr;
    LPOLESTR szCSPath;
    hr = CsGetClassStorePath((LPOLESTR)((LPCOLESTR)m_szLDAP_Path), &szCSPath);
    if (SUCCEEDED(hr))
    {
        sz = szCSPath;
        OLESAFE_DELETE(szCSPath);
    }
    else
    {
        if (fCreateOK)
        {
            // set sz to the default setting and save the path
            IADsPathname * pADsPathname = NULL;
            hr = CoCreateInstance(CLSID_Pathname,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname,
                                  (LPVOID*)&pADsPathname);

            if (FAILED(hr))
            {
                return hr;
            }

            BSTR bstr = SysAllocString((LPCOLESTR)m_szLDAP_Path);
            if (NULL == bstr) 
            {
                pADsPathname->Release();
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }

            hr = pADsPathname->Set(bstr, ADS_SETTYPE_FULL);
            SysFreeString(bstr);
            if (FAILED(hr))
            {
                pADsPathname->Release();
                return hr;
            }

            bstr = SysAllocString(L"CN=Class Store");
            if (NULL == bstr) 
            {
                pADsPathname->Release();
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }

            hr = pADsPathname->AddLeafElement(bstr);
            SysFreeString(bstr);
            if (FAILED(hr))
            {
                pADsPathname->Release();
                return hr;
            }

            hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);

            pADsPathname->Release();
            if (FAILED(hr))
            {
                return hr;
            }

            sz = bstr;
            SysFreeString(bstr);

            // This has to be here becuase CsSetClassStorePath will fail if the
            // class store doesn't already exist.
            hr = CsCreateClassStore(NULL, (LPOLESTR)((LPCOLESTR)sz));
            if (FAILED(hr))
            {
                // Changed to CS_E_OBJECT_ALREADY_EXISTS.
                // I check for both ERROR_ALREAD_EXISTS and CS_E_OBJECT_ALREADY_EXISTS
                // just to be safe.
                if ((hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) && (hr != CS_E_OBJECT_ALREADY_EXISTS))
                {
                    return hr;
                }
            }
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetPackageDSPath
//
//  Synopsis:   gets the path to an individual package's DS object
//
//  Arguments:  [szPath]        - [out] LDAP path to the package
//              [szPackageName] - [in] name of the package
//
//  Returns:    S_OK on success
//
//  History:    3-26-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetPackageDSPath(CString &szPath, LPOLESTR szPackageName)
{
#if 1
    LPOLESTR sz;
    HRESULT hr = m_pIClassAdmin->GetDNFromPackageName(szPackageName, &sz);

    if (FAILED(hr))
    {
        return hr;
    }

    szPath = sz;
    OLESAFE_DELETE(sz);
#else
    HRESULT hr = GetClassStoreName(szPath, FALSE);

    if (FAILED(hr))
    {
        return hr;
    }

    // set sz to the default setting and save the path
    IADsPathname * pADsPathname = NULL;
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pADsPathname->Set((LPOLESTR)((LPCOLESTR)szPath), ADS_SETTYPE_FULL);
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    hr = pADsPathname->AddLeafElement(L"CN=Packages");
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    CString sz = L"CN=";
    sz+= szPackageName;
    hr = pADsPathname->AddLeafElement((LPOLESTR)((LPCOLESTR)sz));
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    BSTR bstr;

    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);

    pADsPathname->Release();
    if (FAILED(hr))
    {
        return hr;
    }

    szPath = bstr;
    SysFreeString(bstr);
#endif
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetClassStore
//
//  Synopsis:   gets the IClassAdmin interface and creates a class store if
//              it doesn't already exist.
//
//  Arguments:  [fCreateOK] - TRUE if the Class Store should be created if
//                             it doesn't already exist.
//
//  Returns:
//
//  Modifies:   m_pIClassAdmin
//
//  Derivation:
//
//  History:    2-11-1998   stevebl   Created
//
//  Notes:      Assumes m_szLDAP_Path contains the path to the DS object
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetClassStore(BOOL fCreateOK)
{
    HRESULT hr;
    CString szCSPath;
    hr = GetClassStoreName(szCSPath, fCreateOK);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
    if (FAILED(hr) && fCreateOK)
    {
        // Sometimes we can get into this wierd state where
        // GetClassStoreName was able to create a entry for the class store
        // name but it wasn't able to actually create the class store.  This
        // should handle that special case.
        // Try and create it here and then bind to it again.
        hr = CsCreateClassStore(NULL, (LPOLESTR)((LPCOLESTR)szCSPath));
        if (FAILED(hr))
        {
            // Changed to CS_E_OBJECT_ALREADY_EXISTS.
            // I check for both ERROR_ALREAD_EXISTS and CS_E_OBJECT_ALREADY_EXISTS
            // just to be safe.
            // I'll check for both just to be safe.
            if ((hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) && (hr != CS_E_OBJECT_ALREADY_EXISTS))
            {
                return hr;
            }
        }
        hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
    }
    return hr;
}

UINT CScopePane::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //
    HRESULT hr;

    hr = StringCchCopy (szDirectory, sizeof(szDirectory)/sizeof(szDirectory[0]), lpDirectory);
    if (FAILED(hr)) 
    {
        SetLastError(HRESULT_CODE(hr));
        return 0;
    }

    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CScopePane::OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}


HRESULT CScopePane::OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
            param);
    }

    return S_OK;
}

HRESULT CScopePane::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CScopePane::OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CScopePane::OnProperties(LPARAM param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CScopePane::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    if (m_fRSOP && !m_fRSOPEnumerate)
    {
        // don't allow an empty RSOP database to enumerate the snapin
        
        if (m_pIRSOPInformation)
        {
            m_pIRSOPInformation->Release();
            m_pIRSOPInformation = NULL;
        }
        return;
    }
    // make sure that the result pane gets enumerated once
    // so that internal structures get initialized.

    // We only have one folder so this is really easy.
    if (cookie != NULL)
        return ;

    if (m_fExtension)
    {
        // if we're an extension then add a root folder to hang everything off of
        SCOPEDATAITEM * m_pScopeItem = new SCOPEDATAITEM;

        if ( ! m_pScopeItem )
        {
            return;
        }

        memset(m_pScopeItem, 0, sizeof(SCOPEDATAITEM));
        m_pScopeItem->mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;
#ifdef SET_SCOPE_ICONS
        m_pScopeItem->mask |= SDI_IMAGE | SDI_OPENIMAGE;
        if (m_fRSOP && m_fRSOPPolicyFailed)
        {
            m_pScopeItem->nImage = IMG_CLOSED_FAILED;
            m_pScopeItem->nOpenImage = IMG_OPEN_FAILED;
        }
        else
        {
            m_pScopeItem->nImage = IMG_CLOSEDBOX;
            m_pScopeItem->nOpenImage = IMG_OPENBOX;
        }
#endif
        m_pScopeItem->relativeID = pParent;
        m_pScopeItem->displayname = (unsigned short *)-1;
        m_pScopeItem->lParam = -1; // made up cookie for my main folder
        m_pScope->InsertItem(m_pScopeItem);

        delete m_pScopeItem;
    }
    if (m_pIClassAdmin)
    {
        // if there's no IClassAdmin then there's nothing to enumerate
        set <CResultPane *>::iterator i;
        for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
        {
            (*i)->EnumerateResultPane(cookie);
        }
    }
}

STDMETHODIMP CScopePane::GetSnapinDescription(LPOLESTR * lpDescription)
{
    OLESAFE_COPYSTRING(*lpDescription, L"description");
    return S_OK;
}

STDMETHODIMP CScopePane::GetProvider(LPOLESTR * lpName)
{
    OLESAFE_COPYSTRING(*lpName, L"provider");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinVersion(LPOLESTR * lpVersion)
{
    OLESAFE_COPYSTRING(*lpVersion, L"version");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinImage(HICON * hAppIcon)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetStaticFolderImage(HBITMAP * hSmallImage,
                             HBITMAP * hSmallImageOpen,
                             HBITMAP * hLargeImage,
                             COLORREF * cMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CScopePane::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    if (m_fRSOP)
    {
        ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\RSOP.chm::/RSPintro.htm",
                                   lpHelpFile, MAX_PATH);
    }
    else
    {
        ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm::/ADE.htm",
                                   lpHelpFile, MAX_PATH);
    }

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

void CScopePane::DeleteList()
{
    return;
}

STDMETHODIMP CScopePane::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (pScopeDataItem->lParam == -1)
    {
        m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        ASSERT(pScopeDataItem->mask == TVIF_TEXT);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_AppData[pScopeDataItem->lParam].m_pDetails->pszPackageName);
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CScopePane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    HRESULT hr;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    MMC_COOKIE cookie = pInternal->m_cookie;
    FREE_INTERNAL(pInternal);

    //
    // make sure we have an up-to-date categories list
    //
    ClearCategories();
    if (m_fRSOP)
    {
        GetRSoPCategories();
    }
    else
    {
        hr = CsGetAppCategories(&m_CatList);
        if (FAILED(hr))
        {
            // report it
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

            // Since failure only means the categories list will be
            // empty, we'll proceed as if nothing happened.

            hr = S_OK;
        }
    }

    //
    // Create the ToolDefs property page
    //
    m_pToolDefs = new CToolDefs();
    m_pToolDefs->m_ppThis = &m_pToolDefs;
    m_pToolDefs->m_pToolDefaults = & m_ToolDefaults;
    m_pToolDefs->m_cookie = cookie;
    m_pToolDefs->m_hConsoleHandle = handle;
    m_pToolDefs->m_fMachine = m_fMachine;
    hr = SetPropPageToDeleteOnClose(&m_pToolDefs->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hToolDefs = CreateThemedPropertySheetPage(&m_pToolDefs->m_psp);
        if (hToolDefs == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hToolDefs);
    }


    //
    // Create the ToolAdvDefs property page
    //
    m_pToolAdvDefs = new CToolAdvDefs();
    m_pToolAdvDefs->m_ppThis = &m_pToolAdvDefs;
    m_pToolAdvDefs->m_pToolDefaults = & m_ToolDefaults;
    m_pToolAdvDefs->m_cookie = cookie;
    m_pToolAdvDefs->m_hConsoleHandle = handle;
    m_pToolAdvDefs->m_fMachine = m_fMachine;
    hr = SetPropPageToDeleteOnClose(&m_pToolAdvDefs->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hToolAdvDefs = CreateThemedPropertySheetPage(&m_pToolAdvDefs->m_psp);
        if (hToolAdvDefs == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hToolAdvDefs);
    }

    CString szCSPath;
    hr = GetClassStoreName(szCSPath, FALSE);
    if (SUCCEEDED(hr) && m_pIClassAdmin)
    {
        //
        // Create the FileExt property page
        //
        m_pFileExt = new CFileExt();
        m_pFileExt->m_ppThis = &m_pFileExt;
        m_pFileExt->m_pScopePane = this;

        // no longer need to marshal this, just set it
        m_pFileExt->m_pIClassAdmin = m_pIClassAdmin;
        m_pIClassAdmin->AddRef();

        hr = SetPropPageToDeleteOnClose(&m_pFileExt->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hFileExt = CreateThemedPropertySheetPage(&m_pFileExt->m_psp);
            if (hFileExt == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hFileExt);
        }
    }
    else
    {
        //
        // Create the FileExt property page without an IClassAdmin
        //
        m_pFileExt = new CFileExt();
        m_pFileExt->m_ppThis = &m_pFileExt;
        m_pFileExt->m_pScopePane = this;
        hr = SetPropPageToDeleteOnClose(&m_pFileExt->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hFileExt = CreateThemedPropertySheetPage(&m_pFileExt->m_psp);
            if (hFileExt == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hFileExt);
        }
    }

    //
    // Create the CatList property page
    //

    m_pCatList = new CCatList();
    m_pCatList->m_szDomainName = m_szDomainName;
    m_pCatList->m_ppThis = &m_pCatList;
    m_pCatList->m_pScopePane = this;
    m_pCatList->m_fRSOP = m_fRSOP;
    hr = SetPropPageToDeleteOnClose(&m_pCatList->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hCatList = CreateThemedPropertySheetPage(&m_pCatList->m_psp);
        if (hCatList == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hCatList);
    }
#ifdef DIGITAL_SIGNATURES
    //
    // Create the Digital Signatures property page
    //
    m_pSignatures = new CSignatures();
    m_pSignatures->m_ppThis = &m_pSignatures;
    m_pSignatures->m_pScopePane = this;
    m_pSignatures->m_fRSOP = m_fRSOP;
    m_pSignatures->m_pIGPEInformation = m_pIGPEInformation;
    hr = SetPropPageToDeleteOnClose(&m_pSignatures->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hSignatures = CreateThemedPropertySheetPage(&m_pSignatures->m_psp);
        if (hSignatures == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hSignatures);
    }
#endif // DIGITAL_SIGNATURES

    return S_OK;
}

// Scope item property pages:
STDMETHODIMP CScopePane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        // The main Software Installation node only has a property sheet if
        // we are not in RSOP mode.
        if ((m_fRSOP != TRUE) && (CCT_SCOPE == pInternal->m_type))
        {
            FREE_INTERNAL(pInternal);
            return S_OK;
        }

        FREE_INTERNAL(pInternal);
    }
    return S_FALSE;
}

BOOL CScopePane::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        if (pInternal->m_type == CCT_SCOPE)
            bResult = TRUE;

        FREE_INTERNAL(pInternal);
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CScopePane::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG * pInsertionAllowed)
{
    HRESULT hr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    CONTEXTMENUITEM menuitem;
    WCHAR szName[256];
    WCHAR szStatus[256];
    menuitem.strName = szName;
    menuitem.strStatusBarText = szStatus;
    menuitem.fFlags = 0;
    menuitem.fSpecialFlags = 0;

    do {

        if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_NEW))
        {
            //
            // Add Application menu item
            //
            ::LoadString(ghInstance, IDM_ADD_APP, szName, 256);
            ::LoadString(ghInstance, IDS_ADD_APP_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_ADD_APP;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;

            hr = pContextMenuCallback->AddItem(&menuitem);

            if (FAILED(hr))
                    break;
        }

        if ((m_fRSOP == TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_VIEW))
        {
            menuitem.lCommandID = 0;
            menuitem.fFlags = MFT_SEPARATOR;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
            hr = pContextMenuCallback->AddItem(&menuitem);
            if (FAILED(hr))
                    break;
            ::LoadString(ghInstance, IDM_WINNER, szName, 256);
            ::LoadString(ghInstance, IDS_WINNER_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_WINNER;
            menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
            menuitem.fSpecialFlags = 0;
            hr = pContextMenuCallback->AddItem(&menuitem);
            if (FAILED(hr))
                    break;

            if ((m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE) == RSOP_INFO_FLAG_DIAGNOSTIC_MODE)
            {
                // removed packages should only apply when I'm in diagnostic mode
                ::LoadString(ghInstance, IDM_REMOVED, szName, 256);
                ::LoadString(ghInstance, IDS_REMOVED_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_REMOVED;
                menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }

            if (!m_fMachine)
            {
                ::LoadString(ghInstance, IDM_ARP, szName, 256);
                ::LoadString(ghInstance, IDS_ARP_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ARP;
                menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
        }

        //
        // Update & Remove application if this is a result pane item
        //

        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData & data = m_AppData[pInternal->m_cookie];
            DWORD dwFlags = data.m_pDetails->pInstallInfo->dwActFlags;

            if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TOP))
            {
                ::LoadString(ghInstance, IDM_AUTOINST, szName, 256);
                ::LoadString(ghInstance, IDS_AUTOINST_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_AUTOINST;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;

                // only enable for published apps
                if (dwFlags & ACTFLG_Published)
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                if (dwFlags & ACTFLG_OnDemandInstall)
                    menuitem.fFlags += MFS_CHECKED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN;
                if ((dwFlags & ACTFLG_Assigned) || (data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH;
                if ((dwFlags & ACTFLG_Published) || m_fMachine)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#if 0
                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);

                if (dwFlags & (ACTFLG_Published | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                menuitem.lCommandID = IDM_DISABLE;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#endif
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
            if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK))
            {
                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN_T;
                menuitem.fSpecialFlags = 0;
                if ((dwFlags & ACTFLG_Assigned) || (data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH_T;
                if ((dwFlags & ACTFLG_Published) || m_fMachine)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#if 0
                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DISABLE_T;
                if (dwFlags & (ACTFLG_Published | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#endif
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_DEL_APP, szName, 256);
                ::LoadString(ghInstance, IDS_DEL_APP_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DEL_APP;
                menuitem.fFlags = 0;
                menuitem.fSpecialFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_REDEPLOY, szName, 256);
                ::LoadString(ghInstance, IDS_REDEPLOY_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_REDEPLOY;
                if (data.m_pDetails->pInstallInfo->PathType == SetupNamePath)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
        }
    } while (FALSE);


    FREE_INTERNAL(pInternal);
    return hr;
}

HRESULT CScopePane::GetRSoPCategories(void)
{
    HRESULT hr = S_OK;
    list <APPCATEGORYINFO> CatList;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQueryCategories = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementCategory"));
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  CoCreateInstance failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  pLocator->ConnectServer failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  CoSetProxyBlanket failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // First perform the query to get the list of categories

    // erase any existing list
    ClearCategories();

    // create a new one
    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQueryCategories,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  pNamespace->ExecQuery failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    do
    {
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (n > 0)
        {
            APPCATEGORYINFO ci;
            memset(&ci, 0, sizeof(APPCATEGORYINFO));
            ci.Locale = 0;
            hr = GetParameter(pObj,
                              TEXT("CategoryId"),
                              ci.AppCategoryId);
            DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories: GetParameter(\"CategoryId\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              ci.pszDescription);
            DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories: GetParameter(\"Name\") failed with 0x%x", hr));
            CatList.push_back(ci);
        }
    } while (n > 0);

    // put the list of categories into the proper format so it matches
    // what we would get from the class store
    n = CatList.size();
    if (n > 0)
    {
        m_CatList.pCategoryInfo =
            (APPCATEGORYINFO *)OLEALLOC(sizeof(APPCATEGORYINFO) * n);
        if (m_CatList.pCategoryInfo)
        {
            m_CatList.cCategory = n;
            while (n--)
            {
                m_CatList.pCategoryInfo[n] = *CatList.begin();
                CatList.erase(CatList.begin());
            }
        }
    }
cleanup:
    SysFreeString(strQueryLanguage);
    SysFreeString(strQueryCategories);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}



HRESULT CScopePane::InitializeADE()
{
    HRESULT hr = S_OK;

    if ((!m_fRSOP) && (!m_pIClassAdmin))
    {
        // make sure directories are created:
        CreateNestedDirectory ((LPOLESTR)((LPCOLESTR)m_szGPT_Path), NULL);

        // try and get IClassAdmin
        hr = GetClassStore(FALSE);
    }
    return hr;
}

void CScopePane::Refresh()
{
    if (m_fRSOP || ((!m_fBlockAddPackage) && (m_pIClassAdmin)))
    {

        map <MMC_COOKIE, CAppData>::iterator i;
        set <CResultPane *>::iterator i2;
        for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
        {
            (*i2)->m_pResult->DeleteAllRsltItems();
        }
        for (i=m_AppData.begin(); i != m_AppData.end(); i++)
        {
         //   if (i->second.m_fVisible)
         //   {
         //   }
            OLESAFE_DELETE(i->second.m_psd);
            FreePackageDetail(i->second.m_pDetails);
        }
        m_AppData.erase(m_AppData.begin(), m_AppData.end());
        m_UpgradeIndex.erase(m_UpgradeIndex.begin(), m_UpgradeIndex.end());
        m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
        m_lLastAllocated = 0;
        for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
        {
            (*i2)->EnumerateResultPane(0);
        }
    }
}

STDMETHODIMP CScopePane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    MMC_COOKIE cookie = pInternal->m_cookie;

    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_AUTOINST:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags ^ ACTFLG_OnDemandInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_ASSIGN:
    case IDM_ASSIGN_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_Published);
            dwNewFlags |= (ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall);
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_PUBLISH:
    case IDM_PUBLISH_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~ACTFLG_Assigned;
            dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_DISABLE:
    case IDM_DISABLE_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_OnDemandInstall | ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_Published);
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_REDEPLOY:
        {
            CAppData &data = m_AppData[cookie];
            CString sz;
            sz.LoadString(IDS_REDEPLOYWARNING);
            int iReturn = IDNO;
            m_pConsole->MessageBox(    sz,
                                       data.m_pDetails->pszPackageName,
                                       MB_YESNO,
                                       &iReturn);
            if (IDYES == iReturn)
            {
                CHourglass hourglass;
                //CString szScriptPath = data.m_pDetails->pInstallInfo->pszScriptPath;
                CString szScriptPath = m_szGPT_Path;
                DWORD dwRevision;
                HRESULT hr = S_OK;
                BOOL bStatus;

                szScriptPath += L"\\temp.aas";
                CString szTransformList = L"";
                int i;
                if (data.m_pDetails->cSources > 1)
                {
                    CString szSource = data.m_pDetails->pszSourceList[0];
                    int nChars = 1 + szSource.ReverseFind(L'\\');
                    BOOL fTransformsAtSource = TRUE;
                    for (i = 1; i < data.m_pDetails->cSources && TRUE == fTransformsAtSource; i++)
                    {
                        if (0 == wcsncmp(szSource, data.m_pDetails->pszSourceList[i], nChars))
                        {
                            // make sure there isn't a sub-path
                            int n = nChars;
                            while (0 != data.m_pDetails->pszSourceList[i][n] && TRUE == fTransformsAtSource)
                            {
                                if (data.m_pDetails->pszSourceList[i][n] == L'\\')
                                {
                                    fTransformsAtSource = FALSE;
                                }
                                n++;
                            }
                        }
                        else
                        {
                            fTransformsAtSource = FALSE;
                        }
                    }
                    if (fTransformsAtSource)
                    {
                        szTransformList = L"@";
                    }
                    else
                    {
                        szTransformList = L"|";
                        nChars = 0;
                    }
                    for (i = 1; i < data.m_pDetails->cSources; i++)
                    {
                        if (i > 1)
                        {
                            szTransformList += L";";
                        }
                        szTransformList += &data.m_pDetails->pszSourceList[i][nChars];
                    }
                }

                // disable MSI ui
                MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                // build the script file

                DWORD dwPlatform;

                if ( CAppData::Is64Bit( data.m_pDetails ) )
                {
                    dwPlatform = CAppData::Get64BitMsiArchFlags( data.m_pDetails );
                }
                else
                {
                    dwPlatform = MSIARCHITECTUREFLAGS_X86;
                }

                UINT uMsiStatus = MsiAdvertiseProductEx(
                    data.m_pDetails->pszSourceList[0],
                    szScriptPath,
                    szTransformList,
                    LANGIDFROMLCID(data.m_pDetails->pPlatformInfo->prgLocale[0]),
                    dwPlatform,
                    0);

                if (uMsiStatus)
                {
                    DebugMsg((DM_WARNING, TEXT("MsiAdvertiseProduct failed with %u"), uMsiStatus));
                    hr = HRESULT_FROM_WIN32(uMsiStatus);
                }

                if (SUCCEEDED(hr))
                {
                    dwRevision = data.m_pDetails->pInstallInfo->dwRevision + 1;
                    hr = m_pIClassAdmin->ChangePackageProperties(data.m_pDetails->pszPackageName,
                                                                         NULL,
                                                                         NULL,
                                                                         NULL,
                                                                         NULL,  
                                                                         NULL,
                                                                         &dwRevision);
                }

                if (SUCCEEDED(hr))
                {
                    // delete the old script
                    bStatus = DeleteFile(data.m_pDetails->pInstallInfo->pszScriptPath);

                    // rename the new one
                    if ( bStatus )
                        bStatus = MoveFile(szScriptPath, data.m_pDetails->pInstallInfo->pszScriptPath);

                    data.m_pDetails->pInstallInfo->dwRevision = dwRevision;

                    if ( bStatus )
                    {
                        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                          m_fMachine ? &guidMachSnapin
                                                                     : &guidUserSnapin)))
                        {
                            ReportPolicyChangedError(m_hwndMainWindow);
                        }
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());
                }

                if ( ! SUCCEEDED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
                    // display failure message
                    sz.LoadString(IDS_REDEPLOYERROR);
                    m_pConsole->MessageBox(sz,
                                       data.m_pDetails->pszPackageName,
                                       MB_OK | MB_ICONEXCLAMATION, NULL);
                }
            }
        }
        break;
    case IDM_ADD_APP:
        {
            if (!m_fBlockAddPackage)
            {
                m_fBlockAddPackage=TRUE;
                CString szExtension;
                CString szFilter;
                szExtension.LoadString(IDS_DEF_EXTENSION);
                if (m_fMachine)
                {
                    szFilter.LoadString(IDS_EXTENSION_FILTER_M);
                }
                else
                    szFilter.LoadString(IDS_EXTENSION_FILTER);
                OPENFILENAME ofn;
                memset(&ofn, 0, sizeof(ofn));
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = GetActiveWindow();
                ofn.hInstance = ghInstance;
                TCHAR lpstrFilter[MAX_PATH];
                wcsncpy(lpstrFilter, szFilter, MAX_PATH);
                ofn.lpstrFilter = lpstrFilter;
                TCHAR szOpenFileTitle[MAX_PATH];
                TCHAR szOpenFile[MAX_PATH];
                szOpenFile[0] = NULL;
                ofn.lpstrFile = szOpenFile;
                ofn.nMaxFile = MAX_PATH;
                ofn.lpstrFileTitle = szOpenFileTitle;
                ofn.nMaxFileTitle = MAX_PATH;
                ofn.lpstrInitialDir = m_ToolDefaults.szStartPath;
                ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
                ofn.lpstrDefExt = szExtension;
                int iBreak = 0;
                while (lpstrFilter[iBreak])
                {
                    if (lpstrFilter[iBreak] == TEXT('|'))
                    {
                        lpstrFilter[iBreak] = 0;
                    }
                    iBreak++;
                }
                if (GetOpenFileName(&ofn))
                {
                    CHourglass hourglass;
                    CString szPackagePath;
                    HRESULT hr = E_FAIL;
                    TCHAR szFile[MAX_PATH];
                    TCHAR * szNextFile = ofn.lpstrFile + ofn.nFileOffset;
                    TCHAR * szFileTitle = szFile + ofn.nFileOffset;

                    hr = StringCchCopy(szFile, sizeof(szFile)/sizeof(szFile[0]), ofn.lpstrFile);
                    if (FAILED(hr)) 
                    {
    /*      
                              LPWSTR lpErrorString;
                                DWORD  dwRetVal;
    
                            dwRetVal = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                                     NULL,
                                                     HRESULT_CODE(hr),
                                                     MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                     &lpErrorString,
                                                     0,
                                                     NULL);
    
                            if (dwRetVal != 0) 
                            {
                                int iReturn;

                                m_pConsole->MessageBox(sz, szPackagePath,
                                                       MB_OK | MB_ICONEXCLAMATION,
                                                       &iReturn)
                                LocalFree(lpErrorString);
                        }       
     */
                        goto skip_deployment;
                    }

                    if (0 == szFile[ofn.nFileOffset - 1])
                    {
                        // this is a list of files (not just one)
                        // need to put a slash here so it will work
                        szFile[ofn.nFileOffset - 1] = TEXT('\\');
                    }
                    TCHAR * szFileExtension;

                    // don't allow deployment over http or ftp
                    if (_wcsnicmp(ofn.lpstrFile, TEXT("http:"), 5) == 0
                        ||
                        _wcsnicmp(ofn.lpstrFile, TEXT("ftp:"), 4) == 0)
                    {
                        CString sz;
                        sz.LoadString(IDS_ILLEGAL_PATH);
                        int iReturn = IDNO;
                        m_pConsole->MessageBox(sz, szPackagePath,
                                               MB_OK | MB_ICONEXCLAMATION,
                                               &iReturn);
                        goto skip_deployment;
                    }

                    // at this point I have a path and I have a list of file names

                    do
                    {
                        hr = StringCchCopy(szFileTitle, 
                                           sizeof(szFile)/sizeof(szFile[0]) - ofn.nFileOffset ,
                                           szNextFile);
                        if (SUCCEEDED(hr)) 
                        {
                            hr = GetUNCPath (szFile, szPackagePath);
                            DebugMsg((DM_VERBOSE, TEXT("GetUNCPath(%s) returned %s"), szFile, szPackagePath));
                        }

                        if (FAILED(hr))
                        {
                            CString sz;
                            sz.LoadString(IDS_NO_UNIVERSAL_NAME);
                            int iReturn = IDNO;
                            m_pConsole->MessageBox(sz, szPackagePath,
                                                   MB_YESNO | MB_ICONEXCLAMATION,
                                                   &iReturn);
                            if (IDYES != iReturn)
                            {
                                goto skip_deployment;
                            }
                        }

                        szFileExtension = _tcsrchr(szFile, TEXT('.'));


                        if ((szFileExtension) &&
                            (0 == _wcsicmp(szFileExtension, L".zap")))
                        {
                            if (m_fMachine)
                            {
                                CString szText;
                                CString szTitle;
                                szText.LoadString(IDS_NO_ZAPS_ALLOWED);
                                // only allow ZAP files to be deployed to users
                                m_pConsole->MessageBox(
                                             szText,
                                             szTitle,
                                             MB_OK | MB_ICONEXCLAMATION,
                                             NULL);
                                hr = E_FAIL;
                            }
                            else
                            {
                                hr = AddZAPPackage(szPackagePath, szFileTitle);
                            }
                        }
                        else
                        {
                            hr = AddMSIPackage(szPackagePath, szFileTitle);
                        }
                        szNextFile += _tcslen(szNextFile) + 1;
                    } while (szNextFile[0]);

           skip_deployment:
                    // Notify clients of change
                    if (SUCCEEDED(hr) && m_pIGPEInformation)
                    {
                        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                          m_fMachine ? &guidMachSnapin
                                                                     : &guidUserSnapin)))
                        {
                            ReportPolicyChangedError(m_hwndMainWindow);
                        }
                    }
                }
                m_fBlockAddPackage = FALSE;
            }
            else
            {
                // consider a message here
            }

        }
        break;
    case IDM_WINNER:
    case IDM_REMOVED:
    case IDM_FAILED:
    case IDM_ARP:
        m_iViewState = nCommandID;
        {
            // change toolbar state
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                if ((*i)->m_pToolbar)
                {
                    (*i)->m_pToolbar->SetButtonState(IDM_WINNER,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(IDM_REMOVED,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(IDM_ARP,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(nCommandID,
                                                     BUTTONPRESSED,
                                                     TRUE);
                }
            }
        }
        // deliberately fall through to REFRESH
    case IDM_REFRESH:
        Refresh();

        //
        // In logging mode, we need to show a message box to the user
        // in the case that ARP view is empty so that users are clear
        // that this may be because ARP has not been run yet
        //
        if ( m_fRSOP && 
             ( IDM_ARP == nCommandID ) && 
             ( m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE ) && 
             ! m_fDisplayedRsopARPWarning  &&
             ( m_AppData.end() == m_AppData.begin() ) )
        {
            CString szTitle;
            CString szText;
            szTitle.LoadString(IDS_RSOP_ARP_WARNING_TITLE);
            szText.LoadString(IDS_RSOP_ARP_WARNING);
            int iReturn;
            m_pConsole->MessageBox(szText,
                                   szTitle,
                                   MB_OK,
                                   &iReturn);

            m_fDisplayedRsopARPWarning = TRUE;
        }
        break;
    case IDM_DEL_APP:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData & data = m_AppData[pInternal->m_cookie];
            if ((data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
            {
                // this is a legacy app it can't be uninstalled
                CString szTitle;
                CString szText;
                szTitle.LoadString(IDS_REMOVE_LEGACY_TITLE);
                szText.LoadString(IDS_REMOVE_LEGACY_TEXT);
                int iReturn = IDNO;
                m_pConsole->MessageBox(szText,
                                       szTitle,
                                       MB_YESNO,
                                       &iReturn);
                if (IDYES == iReturn)
                {
                    RemovePackage(pInternal->m_cookie, FALSE, FALSE);
                }
            }
            else
            {
                CRemove dlg;
                // Activate the theme context in order to theme this dialog
                CThemeContextActivator themer;
                
                int iReturn = dlg.DoModal();

                if (IDOK == iReturn)
                {
                    switch (dlg.m_iState)
                    {
                    case 0:
                        RemovePackage(pInternal->m_cookie, TRUE, FALSE);
                        break;
                    case 1:
                        RemovePackage(pInternal->m_cookie, FALSE, FALSE);
                        break;
                    }
                }
            }
        }
        break;

    default:
        break;
    }
    return S_OK;
}

static PFNDSCREATEISECINFO pDSCreateISecurityInfoObject = NULL;
static HINSTANCE hInst_dssec = NULL;
STDAPI DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                                   LPCWSTR pwszObjectClass,
                                   DWORD dwFlags,
                                   LPSECURITYINFO * ppSI,
                                   PFNREADOBJECTSECURITY pfnReadSD,
                                   PFNWRITEOBJECTSECURITY pfnWriteSD,
                                   LPARAM lpContext)
{
    if (NULL == pDSCreateISecurityInfoObject)
    {
        if (NULL == hInst_dssec)
        {
            hInst_dssec = LoadLibrary(L"dssec.dll");
            if (NULL == hInst_dssec)
            {
                return E_UNEXPECTED;
            }
        }
        pDSCreateISecurityInfoObject = (PFNDSCREATEISECINFO)
            GetProcAddress(hInst_dssec, "DSCreateISecurityInfoObject");
        if (NULL == pDSCreateISecurityInfoObject)
        {
            return E_UNEXPECTED;
        }
    }
    return pDSCreateISecurityInfoObject(pwszObjectPath, pwszObjectClass, dwFlags, ppSI, pfnReadSD, pfnWriteSD, lpContext);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetUNCPath
//
//  Synopsis:   This function takes in a driver based path and converts
//              it to a UNC path
//
//  Arguments:
//          [in] [szPath]    - The drive based path
//          [out][szUNCPath] - The UNC path
//
//  Returns:
//          S_OK    - If the function succeeds in obtaining a UNC path
//          E_FAIL  - If the function cannot obtain a UNC path
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes: If the function cannot obtain a UNC path, it simply copies szPath
//         into szUNCPath on return.
//
//---------------------------------------------------------------------------
HRESULT GetUNCPath (LPCOLESTR szPath, CString& szUNCPath)
{
    TCHAR* lpszUNCName;
    UNIVERSAL_NAME_INFO * pUni;
    ULONG cbSize;
    HRESULT hr;
    DWORD retVal;

    szUNCPath.Empty();  //safety measure
    lpszUNCName = new TCHAR[MAX_PATH];
    pUni = (UNIVERSAL_NAME_INFO*) lpszUNCName;
    cbSize = MAX_PATH * sizeof(TCHAR);

    retVal = WNetGetUniversalName(szPath,
                                  UNIVERSAL_NAME_INFO_LEVEL,
                                  (LPVOID) pUni,
                                  &cbSize);
    if (ERROR_MORE_DATA == retVal)  //if the buffer was not large enough
    {
        delete [] pUni;
        pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
        retVal = WNetGetUniversalName(szPath,
                                      UNIVERSAL_NAME_INFO_LEVEL,
                                      pUni,
                                      &cbSize);
    }

    if (NO_ERROR == retVal)
    {
        szUNCPath = pUni->lpUniversalName;
        hr = S_OK;
    }
    else
    {
        szUNCPath = szPath;
        if (0 != wcsncmp(szPath, L"\\\\", 2))
            hr = E_FAIL;    //probably not a remote share.
        else
            hr = S_OK;  //probably a remote share.
    }
    delete[] pUni;

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   LogADEEvent
//
//  Synopsis:   logs an ADE event in the event log
//
//  Arguments:  [wType]      - type of event
//              [dwEventID]  - event ID
//              [hr]         - HRESULT that triggered the event to be logged
//              [szOptional] - additional descriptive text used by some events
//
//  Returns:    nothing
//
//  Modifies:   nothing
//
//  History:    05-27-1999   stevebl   Created
//              04-28-2000   stevebl   Modified to allow more complex logging
//
//  Notes:      We attempt to use FormatMessage to craft a legible message
//              but in the case that it fails, we just log the HRESULT.
//
//---------------------------------------------------------------------------

void LogADEEvent(WORD wType, DWORD dwEventID, HRESULT hr, LPCWSTR szOptional)
{
    TCHAR szBuffer[256];
    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             hr,
                             0,
                             szBuffer,
                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                             NULL);
    if (0 == dw)
    {
        HRESULT hrString;

        // FormatMessage failed.
        // We'll have to come up with some sort of reasonable message.
        hrString = StringCchPrintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), TEXT("(HRESULT: 0x%lX)"), hr);
        if (FAILED(hrString)) 
        {
            return;
        }


    }
    HANDLE hEventLog = OpenEventLog( NULL, ADE_EVENT_SOURCE );

    if (hEventLog)
    {
        LPCWSTR rgsz[2];
        rgsz[0] = szBuffer;
        rgsz[1] = szOptional;
        ReportEvent(hEventLog,
                    wType,
                    0,
                    dwEventID,
                    NULL,
                    NULL == szOptional ? 1 : 2,
                    sizeof(hr),
                    rgsz,
                    &hr);

        CloseEventLog(hEventLog);
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   ReportGeneralPropertySheetError
//
//  Synopsis:   Pops up a message box indicating why changes to a property
//              page could not be applies and logs the error in the event log.
//
//  Arguments:  [sz] - Title bar text
//              [hr] - hresult of the error
//
//  Returns:    nothing
//
//  History:    9-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void ReportGeneralPropertySheetError(HWND hwnd, LPCWSTR sz, HRESULT hr)
{
    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, hr);

    CString szMessage;
    szMessage.LoadString(IDS_GENERALERROR);

    MessageBox(  hwnd,
                 szMessage,
                 sz,
                 MB_OK | MB_ICONEXCLAMATION);
}

void ReportPolicyChangedError(HWND hwnd)
{
    CString szMessage;
    szMessage.LoadString(IDS_ERRORPOLICYCHANGED);
    MessageBox(hwnd,
               szMessage,
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadHelpInfo
//
//  Synopsis:   routine that loads and locks the help mapping resources
//
//  Arguments:  [nIDD] - ID of the dialog making the help request
//
//  Returns:    handle to the locked and loaded mapping table
//
//  History:    10-22-1998   stevebl   Created
//
//---------------------------------------------------------------------------

LPDWORD LoadHelpInfo(UINT nIDD)
{
    HRSRC hrsrc = FindResource(ghInstance, MAKEINTRESOURCE(nIDD),
        MAKEINTRESOURCE(RT_HELPINFO));
    if (hrsrc == NULL)
        return NULL;

    HGLOBAL hHelpInfo = LoadResource(ghInstance, hrsrc);
    if (hHelpInfo == NULL)
        return NULL;

    LPDWORD lpdwHelpInfo = (LPDWORD)LockResource(hHelpInfo);
    return lpdwHelpInfo;
}

#define RSOP_HELP_FILE TEXT("gpedit.hlp")

//+--------------------------------------------------------------------------
//
//  Function:   StandardHelp
//
//  Synopsis:   Standardized routine for bringing up context sensitive help.
//
//  Arguments:  [hWnd] - window that needs help
//              [nIDD] - ID of the dialog making the request
//  Notes:
//
//
//  History:    10-22-1998   stevebl   modified from the OLEDLG sources
//
//---------------------------------------------------------------------------

void WINAPI StandardHelp(HWND hWnd, UINT nIDD, BOOL fRsop /* = FALSE */ )
{
    LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
    if (lpdwHelpInfo == NULL)
    {
        DebugMsg((DL_VERBOSE, TEXT("Warning: unable to load help information (RT_HELPINFO)\n")));
        return;
    }
    WinHelp(hWnd, fRsop ? RSOP_HELP_FILE : HELP_FILE, HELP_WM_HELP, (DWORD_PTR)lpdwHelpInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   StandardContextMenu
//
//  Synopsis:   Standardized routine for bringing up context menu based help.
//
//  Arguments:  [hWnd] -
//              [nIDD]   - ID of the dialog making the request
//
//  History:    10-22-1998   stevebl   modified from the OLEDLG sources
//
//---------------------------------------------------------------------------

void WINAPI StandardContextMenu(HWND hWnd,  UINT nIDD, BOOL fRsop /* = FALSE */ )
{
    LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
    if (lpdwHelpInfo == NULL)
    {
        DebugMsg((DL_VERBOSE, TEXT("Warning: unable to load help information (RT_HELPINFO)\n")));
        return;
    }
    WinHelp(hWnd, fRsop ? RSOP_HELP_FILE : HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR)lpdwHelpInfo);
}


//+--------------------------------------------------------------------------
//
//  Function:   CreateThemedPropertyPage
//
//  Synopsis:   Helper function to make sure that property pages put up
//              by the snap-in are themed.
//
//  Arguments:
//
//  Returns:
//
//  History:    4/20/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\script.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       script.cpp
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Function:   RegDeleteTree
//
//  Synopsis:   deletes a registry key and all of its children
//
//  Arguments:  [hKey]     - handle to the key's parent
//              [szSubKey] - name of the key to be deleted
//
//  Returns:    ERROR_SUCCESS
//
//  History:    1-14-1998   stevebl   Moved from old project
//
//---------------------------------------------------------------------------

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, szSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    szName[0] = 0;
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, szSubKey);
}

extern "C"
HRESULT
GenerateScript( PACKAGEDETAIL* pd, WCHAR* wszScriptPath )
{
    return BuildScriptAndGetActInfo( *pd, FALSE, FALSE, wszScriptPath );
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildScriptAndGetActInfo
//
//  Synopsis:   Builds the script file and fills in the ACTINFO structure
//              member in the PACKAGEDETAIL structure.
//
//  Arguments:  [szScriptRoot] - [in] the subdirectory that the script file
//                                should be place in.
//              [pd]           - [in/out] package detail structure - see
//                                notes for complete list of fields that
//                                should be filled in and the list of fields
//                                that are set on return
//
//  Returns:    S_OK - success
//              <other> - error
//
//  Modifies:   all fields under pd.pActInfo (only on success)
//              also modifies pd.pInstallInfo->cScriptLen
//
//  History:    1-14-1998   stevebl   Created
//
//  Notes:      On input:
//              pd.cSources must be >= 1.
//              pd.pszSourceList[] contains the MSI package and the list of
//              (if any) transforms to be applied.
//              pd.pPlatformInfo should be completely filled in (only one
//              locale).
//              pd.pInstallInfo->pszScriptFile contains the name of the
//              script file to be generated.
//
//              On output:
//              The script file will be generated under the appropriate name
//              and in the appropriate directory.
//              pd.pActInfo will be completely filled in.
//
//---------------------------------------------------------------------------

HRESULT BuildScriptAndGetActInfo(PACKAGEDETAIL & pd, BOOL bFileExtensionsOnly, BOOL bGenerateClasses /* =TRUE */, WCHAR* wszScriptPath /* = NULL */ )
{
    DebugMsg((DM_VERBOSE, TEXT("BuldScriptAndGetActInfo called with bFileExtensionsOnly == %u"), bFileExtensionsOnly));
    CHourglass hourglass;
    HRESULT hr;
    UINT uMsiStatus;
    LONG error;
    int i;
    WCHAR* szScriptPath = pd.pInstallInfo->pszScriptPath;

    if ( wszScriptPath )
    {
        szScriptPath = wszScriptPath;
    }

    CString szTransformList = L"";

    CClassCollection Classes( &pd );

    if (pd.cSources > 1)
    {
        CString szSource = pd.pszSourceList[0];
        int nChars = 1 + szSource.ReverseFind(L'\\');
        BOOL fTransformsAtSource = TRUE;
        for (i = 1; i < pd.cSources && TRUE == fTransformsAtSource; i++)
        {
            if (0 == wcsncmp(szSource, pd.pszSourceList[i], nChars))
            {
                // make sure there isn't a sub-path
                int n = nChars;
                while (0 != pd.pszSourceList[i][n] && TRUE == fTransformsAtSource)
                {
                    if (pd.pszSourceList[i][n] == L'\\')
                    {
                        fTransformsAtSource = FALSE;
                    }
                    n++;
                }
            }
            else
            {
                fTransformsAtSource = FALSE;
            }
        }
        if (fTransformsAtSource)
        {
            szTransformList = L"@";
        }
        else
        {
            szTransformList = L"|";
            nChars = 0;
        }
        for (i = 1; i < pd.cSources; i++)
        {
            if (i > 1)
            {
                szTransformList += L";";
            }
            szTransformList += &pd.pszSourceList[i][nChars];
        }
    }

    // disable MSI ui
    MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

    // build the script file

    TCHAR szTempPath[MAX_PATH];
    TCHAR szTempFileName[MAX_PATH];
    if (0 != GetTempPath(sizeof(szTempPath) / sizeof(szTempPath[0]), szTempPath))
    {
        if (0 == GetTempFileName(szTempPath, TEXT("ADE"), 0, szTempFileName))
        {
            goto Failure;
        }

        DWORD dwPlatform;

        if ( CAppData::Is64Bit( &pd ) )
        {
            dwPlatform = CAppData::Get64BitMsiArchFlags( &pd );
        }
        else
        {
            dwPlatform = MSIARCHITECTUREFLAGS_X86;
        }

        uMsiStatus = MsiAdvertiseProductEx(
            pd.pszSourceList[0],
            szTempFileName,
            szTransformList,
            LANGIDFROMLCID(pd.pPlatformInfo->prgLocale[0]),
            dwPlatform,
            0);

        if (uMsiStatus)
        {
            DeleteFile(szTempFileName);
            DebugMsg((DM_WARNING, TEXT("MsiAdvertiseProduct failed with %u"), uMsiStatus));
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERATESCRIPT_ERROR, HRESULT_FROM_WIN32(uMsiStatus), pd.pszSourceList[0]);
            // an error occurred
            return HRESULT_FROM_WIN32((long)uMsiStatus);
        }

        // fill in the ActInfo
        
        if ( bGenerateClasses )
        {
            hr = Classes.GetClasses( bFileExtensionsOnly );
        }
        else
        {
            hr = S_OK;
        }

        if ( SUCCEEDED( hr ) )
        {
            if (!CopyFile(szTempFileName, szScriptPath, FALSE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DeleteFile(szTempFileName);
                return hr;
            }

            DeleteFile(szTempFileName);
        }
    }
    else
    {
Failure:
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\scriptgen.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scriptgen.h
//
//  Contents:   Exported functions for generating advertisement scripts
//
//
//  Classes:
//
//
//  History:    9-14-2001   adamed   Created
//
//---------------------------------------------------------------------------

extern "C"
HRESULT
GenerateScript( PACKAGEDETAIL* pd, WCHAR* wszScriptPath );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\sigs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Sigs.cpp
//
//  Contents:   Digital Signatures property page
//
//  Classes:    CSignatures
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#ifdef DIGITAL_SIGNATURES

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSignatures property page

IMPLEMENT_DYNCREATE(CSignatures, CPropertyPage)

CSignatures::CSignatures() : CPropertyPage(CSignatures::IDD)
{
        //{{AFX_DATA_INIT(CSignatures)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_fAllow = FALSE;
    m_fIgnoreForAdmins = FALSE;
    m_pIClassAdmin = NULL;
    m_nSortedColumn = 0;
}

CSignatures::~CSignatures()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
    // delete temporary stores
    m_list1.DeleteAllItems();
    m_list2.DeleteAllItems();

    DeleteFile(m_szTempInstallableStore);
    DeleteFile(m_szTempNonInstallableStore);
}

void CSignatures::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSignatures)
        DDX_Check(pDX, IDC_CHECK1, m_fAllow);
        DDX_Check(pDX, IDC_CHECK2, m_fIgnoreForAdmins);
        DDX_Control(pDX, IDC_LIST1, m_list1);
        DDX_Control(pDX, IDC_LIST2, m_list2);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSignatures, CPropertyPage)
        //{{AFX_MSG_MAP(CSignatures)
        ON_BN_CLICKED(IDC_BUTTON1, OnAddAllow)
        ON_BN_CLICKED(IDC_BUTTON2, OnDeleteAllow)
        ON_BN_CLICKED(IDC_BUTTON3, OnPropertiesAllow)
        ON_BN_CLICKED(IDC_BUTTON4, OnAddDisallow)
        ON_BN_CLICKED(IDC_BUTTON5, OnDeleteDisallow)
        ON_BN_CLICKED(IDC_BUTTON6, OnPropertiesDisallow)
        ON_BN_CLICKED(IDC_CHECK1, OnAllowChanged)
        ON_BN_CLICKED(IDC_CHECK2, OnIgnoreChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSignatures message handlers

void CSignatures::RemoveCertificate(CString &szStore, CListCtrl &List)
{
    int nItem = -1;

    for (;;)
    {
        nItem = List.GetNextItem(nItem, LVNI_SELECTED);
        if (-1 == nItem)
        {
            break;
        }

        //
        // Open the certificate store
        //

        PCCERT_CONTEXT pcLocalCert = NULL;
        PCCERT_CONTEXT pcItemCert = (PCCERT_CONTEXT) List.GetItemData(nItem);
        HCERTSTORE hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                               NULL,
                                               CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                               szStore);

        if (hCertStore)
        {
            //
            // Enumerate the cert store looking for the match
            //

            int i = 0;

            for (;;) {
                pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

                if (!pcLocalCert) {
                    if (GetLastError() != CRYPT_E_NOT_FOUND )
                    {
                        DebugMsg((DM_WARNING, TEXT("CSignatures::RemoveCertificate: Failed to find certificate to delete.")));
                    }
                    break;
                }

                if (CertCompareCertificate(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                           pcLocalCert->pCertInfo ,
                                           pcItemCert->pCertInfo))
                {
                    CertDeleteCertificateFromStore(pcLocalCert);
                    break;
                }

                //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
            }
            CertCloseStore(hCertStore, 0);
        }
    }

    RefreshData();
    SetModified();
}

void CSignatures::CertificateProperties(CString &szStore, CListCtrl &List)
{
    int nItem = -1;

    for (;;)
    {
        nItem = List.GetNextItem(nItem, LVNI_SELECTED);
        if (-1 == nItem)
        {
            break;
        }

        PCCERT_CONTEXT pcc = (PCCERT_CONTEXT) List.GetItemData(nItem);

        // display the property sheet for this item
        CRYPTUI_VIEWCERTIFICATE_STRUCT cvs;
        memset(&cvs, 0, sizeof(cvs));
        cvs.dwSize = sizeof(cvs);
        cvs.hwndParent = m_hWnd;
        cvs.pCertContext = pcc;
        cvs.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
                      CRYPTUI_DISABLE_ADDTOSTORE;

        BOOL fChanged = FALSE;
        CryptUIDlgViewCertificate(&cvs, &fChanged);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CSignatures::ReportFailure
//
//  Synopsis:   General failure reporting mechanism.
//
//  Arguments:  [dwMessage] - resource ID of the root message string
//              [hr]        - HRESULT encountered
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    07-26-2000   stevebl   Created
//
//  Notes:      Builds an error message with a line of text determined by
//              dwMessage, and followed by text returned by Format Message
//              string.
//              The error message is then displayed in a message box.
//
//---------------------------------------------------------------------------

void CSignatures::ReportFailure(DWORD dwMessage, HRESULT hr)
{
    CString szMessage;
    szMessage.LoadString(dwMessage);
    szMessage += TEXT("\n");
    TCHAR szBuffer[256];
    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             hr,
                             0,
                             szBuffer,
                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                             NULL);
    if (0 == dw)
    {
        // FormatMessage failed.
        // We'll have to come up with some sort of reasonable message.
        (void) StringCchPrintf(szBuffer, 
                               sizeof(szBuffer) / sizeof(szBuffer[0]),
                               TEXT("(HRESULT: 0x%lX)"), 
                               hr);

    }
    szMessage += szBuffer;
    MessageBox(szMessage,
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
}

//+--------------------------------------------------------------------------
//
//  Function:   AddMSIToCertStore
//
//  Synopsis:   Gets a certificate from an MSI file and adds it to the
//              certificate store.
//
//  Arguments:  [lpFileName]  - path to the MSI file
//              [lpFileStore] - path to the certificate store
//
//  Returns:
//
//  Modifies:
//
//  History:    07-26-2000   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CSignatures::AddMSIToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore)
{
    PCCERT_CONTEXT pcc = NULL;
    HCERTSTORE hCertStore = NULL;
    BOOL bRet;
    HRESULT hrRet = MsiGetFileSignatureInformation(lpFileName,
                                                0,
                                                &pcc,
                                                NULL,
                                                NULL);
    if (SUCCEEDED(hrRet))
    {
        //
        // Open the certificate store
        //
        hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                    lpFileStore);

        if (hCertStore == NULL) {
            DebugMsg((DM_WARNING, L"AddMSIToCertStore: CertOpenStore failed with %u",GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // add the given certificate to the store
        //

        bRet = CertAddCertificateContextToStore(hCertStore,
                                                pcc,
                                                CERT_STORE_ADD_NEW,
                                                NULL);

        if (!bRet) {
            DebugMsg((DM_WARNING, L"AddToCertStore: CertAddCertificateContextToStore failed with %u", GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Save the store
        //

        bRet = CertCloseStore(hCertStore, 0);
        hCertStore = NULL; // Make the store handle NULL, Nothing more we can do

        if (!bRet) {
            DebugMsg((DM_WARNING, L"AddToCertStore: CertCloseStore failed with %u", GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
        }

        hrRet = S_OK;


    Exit:

        if (hCertStore) {

            //
            // No need to get the error code
            //

            CertCloseStore(hCertStore, 0);
        }
        CertFreeCertificateContext(pcc);
        if (FAILED(hrRet))
        {
            ReportFailure(IDS_ADDCERTFAILED, hrRet);
        }
    }
    else
    {
        ReportFailure(IDS_CERTFROMMSIFAILED, hrRet);
        DebugMsg((DM_WARNING, L"AddMSIToCertStore: MsiGetFileSignatureInformation failed with 0x%x", hrRet));
    }

    return hrRet;
}

//+-------------------------------------------------------------------------
// AddToCertStore
//
// Purpose:
//      Adds the certificate from the given filename to the certificate store
//      and saves it to the given location
//
//
// Parameters
//          lpFIleName  - Location of the certificate file
//          lpFileStore - Location where the resultant cetrtficate path should
//                        be stored
//
//
// Return Value:
//      S_OK if successful or the corresponding error code
//
// Comments:    Shamefully stolen from Shaji's code.
//+-------------------------------------------------------------------------


HRESULT CSignatures::AddToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore)
{
    CRYPTUI_WIZ_IMPORT_SRC_INFO cui_src;
    HCERTSTORE hCertStore = NULL;
    BOOL       bRet = FALSE;
    HRESULT    hrRet = S_OK;


    //
    // Need to make the store usable and saveable from
    // multiple admin consoles..
    //
    // For that the file has to be saved and kept on a temp file
    // and then modified..
    //

    if (!lpFileName || !lpFileName[0] || !lpFileStore || !lpFileStore[0]) {
        return E_INVALIDARG;
    }


    //
    // Open the certificate store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                lpFileStore);

    if (hCertStore == NULL) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CertOpenStore failed with %u",GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // add the given certificate to the store
    //

    cui_src.dwFlags = 0;
    cui_src.dwSize = sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
    cui_src.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
    cui_src.pwszFileName = lpFileName;
    cui_src.pwszPassword = NULL;

    bRet = CryptUIWizImport(CRYPTUI_WIZ_NO_UI, NULL, NULL, &cui_src, hCertStore);

    if (!bRet) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CryptUIWizImport failed with %u", GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Save the store
    //

    bRet = CertCloseStore(hCertStore, 0);
    hCertStore = NULL; // Make the store handle NULL, Nothing more we can do

    if (!bRet) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CertCloseStore failed with %u", GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
    }

    hrRet = S_OK;


Exit:

    if (hCertStore) {

        //
        // No need to get the error code
        //

        CertCloseStore(hCertStore, 0);
    }

    if (FAILED(hrRet))
    {
        ReportFailure(IDS_ADDCERTFAILED, hrRet);
    }
    return hrRet;
}


void CSignatures::AddCertificate(CString &szStore)
{
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_CERT_DEF_EXT);
    szFilter.LoadString(IDS_CERT_EXT_FILT);
    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = ghInstance;
    TCHAR lpstrFilter[MAX_PATH];
    wcsncpy(lpstrFilter, szFilter, MAX_PATH);
    ofn.lpstrFilter = lpstrFilter;
    TCHAR szFileTitle[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    szFile[0] = NULL;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = MAX_PATH;
    ofn.lpstrInitialDir = m_pScopePane->m_ToolDefaults.szStartPath;
    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST | OFN_EXPLORER;
    ofn.lpstrDefExt = szExtension;
    int iBreak = 0;
    while (lpstrFilter[iBreak])
    {
        if (lpstrFilter[iBreak] == TEXT('|'))
        {
            lpstrFilter[iBreak] = 0;
        }
        iBreak++;
    }
    if (GetOpenFileName(&ofn))
    {
        CHourglass hourglass;
        CString szPackagePath;
        HRESULT hr = E_FAIL;
        if ((ofn.nFileExtension > 0) &&
            (0 == _wcsicmp(ofn.lpstrFile + ofn.nFileExtension, L"msi")))
        {
            // this is an MSI package

            HRESULT hr = AddMSIToCertStore(ofn.lpstrFile, (LPWSTR)((LPCWSTR)szStore));
            if (SUCCEEDED(hr))
            {
                RefreshData();
                SetModified();
            }
        }
        else
        {
            // this is a simple certificate
            HRESULT hr = AddToCertStore(ofn.lpstrFile, (LPWSTR)((LPCWSTR)szStore));
            if (SUCCEEDED(hr))
            {
                RefreshData();
                SetModified();
            }
        }
    }
}

void CSignatures::OnAddAllow()
{
    AddCertificate(m_szTempInstallableStore);
}

void CSignatures::OnDeleteAllow()
{
    RemoveCertificate(m_szTempInstallableStore, m_list1);
}

void CSignatures::OnPropertiesAllow()
{
    CertificateProperties(m_szTempInstallableStore, m_list1);
}

void CSignatures::OnAddDisallow()
{
    AddCertificate(m_szTempNonInstallableStore);
}

void CSignatures::OnDeleteDisallow()
{
    RemoveCertificate(m_szTempNonInstallableStore, m_list2);
}

void CSignatures::OnPropertiesDisallow()
{
    CertificateProperties(m_szTempNonInstallableStore, m_list2);
}

void CSignatures::OnAllowChanged()
{
    BOOL fAllow = IsDlgButtonChecked(IDC_CHECK1);
    if (m_fAllow != fAllow)
    {
        SetModified();
    }
    m_fAllow = fAllow;
    GetDlgItem(IDC_BUTTON1)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_LIST1)->EnableWindow(m_fAllow);
}
void CSignatures::OnIgnoreChanged()
{
    BOOL fIgnoreForAdmins = IsDlgButtonChecked(IDC_CHECK2);
    if (m_fIgnoreForAdmins != fIgnoreForAdmins)
    {
        SetModified();
    }
    m_fIgnoreForAdmins = fIgnoreForAdmins;
}

BOOL CSignatures::OnInitDialog()
{
    // create temporary store files
    BOOL fFilesCreated = FALSE;
    TCHAR szTempPath[MAX_PATH];
    if (GetTempPath(MAX_PATH, szTempPath))
    {
        TCHAR szTempFile[MAX_PATH];
        if (GetTempFileName(szTempPath,
                            NULL,
                            0,
                            szTempFile))
        {
            m_szTempInstallableStore = szTempFile;
            if (GetTempFileName(szTempPath,
                            NULL,
                            0,
                            szTempFile))
            {
                m_szTempNonInstallableStore = szTempFile;
                fFilesCreated = TRUE;
            }
        }
    }
    if (fFilesCreated)
    {
        CString szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_installable_certs");
        CopyFile(szPath, m_szTempInstallableStore, FALSE);
         szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_non_installable_certs");
        CopyFile(szPath, m_szTempNonInstallableStore, FALSE);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CSignatures::OnInitDialog : Failed to create temporary certificate stores.")));
    }

    CPropertyPage::OnInitDialog();

    // add columns to the lists
    RECT rect;
    m_list1.GetClientRect(&rect);

    CString szTemp;
    szTemp.LoadString(IDS_SIGS_COL1);
    m_list1.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    m_list2.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    szTemp.LoadString(IDS_SIGS_COL2);
    m_list1.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    m_list2.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    szTemp.LoadString(IDS_SIGS_COL3);
    m_list1.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.25);
    m_list2.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.25);

    // add image lists
    CImageList * pil = NULL;
    pil =  new CImageList;
    if (pil)
    {
        pil->Create(IDB_CERTIFICATE, 16, 0, RGB(255, 0, 255));
        m_list1.SetImageList(pil, LVSIL_SMALL);
    }

    pil =  new CImageList;
    if (pil)
    {
        pil->Create(IDB_CERTIFICATE, 16, 0, RGB(255, 0, 255));
        m_list2.SetImageList(pil, LVSIL_SMALL);
    }

    // retrieve initial registry key setting
    HKEY hKey;
    HRESULT hr = m_pIGPEInformation->GetRegistryKey(m_pScopePane->m_fMachine ?
                                                    GPO_SECTION_MACHINE :
                                                    GPO_SECTION_USER, &hKey);
    if (SUCCEEDED(hr))
    {
        HKEY hSubKey;
        if(ERROR_SUCCESS == RegOpenKeyEx(hKey,
                                      TEXT("Microsoft\\Windows\\Installer"),
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hSubKey))
        {
            DWORD dw;
            DWORD dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hSubKey,
                                                 TEXT("InstallKnownPackagesOnly"),
                                                 NULL,
                                                 NULL,
                                                 (BYTE *)&dw,
                                                 &dwSize))
            {
                m_fAllow = (dw == 1) ? TRUE : FALSE;
                CheckDlgButton(IDC_CHECK1, m_fAllow);
            }
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hSubKey,
                                                 TEXT("IgnoreSignaturePolicyForAdmins"),
                                                 NULL,
                                                 NULL,
                                                 (BYTE *)&dw,
                                                 &dwSize))
            {
                m_fIgnoreForAdmins = (dw == 1) ? TRUE : FALSE;
                CheckDlgButton(IDC_CHECK2, m_fIgnoreForAdmins);
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    RefreshData();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSignatures::OnApply()
{
    HRESULT hr = E_NOTIMPL;
    HKEY hKey;
    hr = m_pIGPEInformation->GetRegistryKey(m_pScopePane->m_fMachine ?
                                                    GPO_SECTION_MACHINE :
                                                    GPO_SECTION_USER, &hKey);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        HKEY hSubKey;
        if(ERROR_SUCCESS == RegCreateKeyEx(hKey,
                                           TEXT("Microsoft\\Windows\\Installer"),
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hSubKey,
                                           NULL))
        {
            DWORD dw = m_fAllow ? 1 : 0;
            DWORD dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegSetValueEx(hSubKey,
                                               TEXT("InstallKnownPackagesOnly"),
                                               0,
                                               REG_DWORD,
                                               (BYTE *)&dw,
                                               dwSize))
            {
                hr = S_OK;
            }
            dw = m_fIgnoreForAdmins ? 1 : 0;
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegSetValueEx(hSubKey,
                                               TEXT("IgnoreSignaturePolicyForAdmins"),
                                               0,
                                               REG_DWORD,
                                               (BYTE *)&dw,
                                               dwSize))
            {
                hr = S_OK;
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    // copy back the certificate stores
    if (SUCCEEDED(hr))
    {
        m_list1.DeleteAllItems();
        m_list2.DeleteAllItems();

        CString szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_installable_certs");
        CopyFile(m_szTempInstallableStore, szPath, FALSE);
        szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_non_installable_certs");
        CopyFile(m_szTempNonInstallableStore, szPath, FALSE);

        RefreshData();
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    else
    {
        GUID guid = REGISTRY_EXTENSION_GUID;
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_pScopePane->m_fMachine,
                                                    TRUE,
                                                    &guid,
                                                    m_pScopePane->m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
        // need to call PolicyChanged for Shaji's extension too.

// REMOVE THIS LINE WHEN SHAJI CHECKS IN HIS GUID
#define GUID_MSICERT_CSE  { 0x000c10f4, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }

        GUID guid2 = GUID_MSICERT_CSE;
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_pScopePane->m_fMachine,
                                                    TRUE,
                                                    &guid2,
                                                    m_pScopePane->m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
    }
    return CPropertyPage::OnApply();
}


LRESULT CSignatures::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    case WM_NOTIFY:
        {
            LPNMLISTVIEW pnmh = (LPNMLISTVIEW) lParam;
            if (pnmh->hdr.code == LVN_DELETEITEM)
            {
                switch(wParam)
                {
                case IDC_LIST1:
                    CertFreeCertificateContext((PCCERT_CONTEXT)m_list1.GetItemData(pnmh->iItem));
                    break;
                case IDC_LIST2:
                    CertFreeCertificateContext((PCCERT_CONTEXT)m_list2.GetItemData(pnmh->iItem));
                    break;
                }
            }
        }
        return CPropertyPage::WindowProc(message, wParam, lParam);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CSignatures::RefreshData(void)
{
    // populate the listview controls

    m_list1.DeleteAllItems();
    m_list2.DeleteAllItems();

    HCERTSTORE hCertStore = NULL;;
    PCCERT_CONTEXT pcLocalCert = NULL;

    //
    // open the local cert store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
//                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                CERT_STORE_READONLY_FLAG,
                                m_szTempInstallableStore);

    if (hCertStore)
    {
        //
        // Enumerate the cert store
        //

        int i = 0;

        for (;;) {
            pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

            if (!pcLocalCert) {
                if (GetLastError() != CRYPT_E_NOT_FOUND )
                {
                    DebugMsg((DM_WARNING, TEXT("CSignatures::RefreshData : Failed to enumerate certificate store.")));
                }
                break;
            }

            TCHAR szCertName[1024];
            TCHAR szIssuerName[1024];
            // crack open the returned certificate and display the data
            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              0,
                              NULL,
                              szCertName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              CERT_NAME_ISSUER_FLAG,
                              NULL,
                              szIssuerName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CTime tExpires(pcLocalCert->pCertInfo->NotAfter);
            CString szExpires = tExpires.Format(TEXT("%x"));

            i = m_list1.InsertItem(i, szCertName, 0);
            m_list1.SetItem(i, 1, LVIF_TEXT, szIssuerName, 0, 0, 0, 0);
            m_list1.SetItem(i, 2, LVIF_TEXT, szExpires, 0, 0, 0, 0);
            m_list1.SetItemData(i, (DWORD_PTR)CertDuplicateCertificateContext(pcLocalCert));

            //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
        }
        CertCloseStore(hCertStore, 0);
    }

    //
    // open the local cert store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
//                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                CERT_STORE_READONLY_FLAG,
                                m_szTempNonInstallableStore);

    if (hCertStore)
    {
        //
        // Enumerate the cert store
        //

        int i = 0;

        for (;;) {
            pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

            if (!pcLocalCert) {
                if (GetLastError() != CRYPT_E_NOT_FOUND )
                {
                    DebugMsg((DM_WARNING, TEXT("CSignatures::RefreshData : Failed to enumerate certificate store.")));
                }
                break;
            }

            TCHAR szCertName[1024];
            TCHAR szIssuerName[1024];
            // crack open the returned certificate and display the data
            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              0,
                              NULL,
                              szCertName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              CERT_NAME_ISSUER_FLAG,
                              NULL,
                              szIssuerName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CTime tExpires(pcLocalCert->pCertInfo->NotAfter);
            CString szExpires = tExpires.Format(TEXT("%x"));

            i = m_list2.InsertItem(i, szCertName, 0);
            m_list2.SetItem(i, 1, LVIF_TEXT, szIssuerName, 0, 0, 0, 0);
            m_list2.SetItem(i, 2, LVIF_TEXT, szExpires, 0, 0, 0, 0);
            m_list2.SetItemData(i, (DWORD_PTR)CertDuplicateCertificateContext(pcLocalCert));

            //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
        }
        CertCloseStore(hCertStore, 0);
    }

    OnAllowChanged();

    SetModified(FALSE);
}


void CSignatures::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FILE_EXT);
}
#endif // DIGITAL_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tooladv.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolAdv.cpp
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolAdvDefs
//
//  History:    09-12-2000   stevebl   Split from General property page
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs dialog


CToolAdvDefs::CToolAdvDefs(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CToolAdvDefs::IDD)
{
    //{{AFX_DATA_INIT(CToolAdvDefs)
        m_fUninstallOnPolicyRemoval = FALSE;
        m_fShowPackageDetails = FALSE;
        m_fZapOn64 = FALSE;
        m_f32On64=FALSE;
        m_fIncludeOLEInfo = FALSE;
        //}}AFX_DATA_INIT
}

CToolAdvDefs::~CToolAdvDefs()
{
    *m_ppThis = NULL;
}

void CToolAdvDefs::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CToolAdvDefs)
        DDX_Check(pDX, IDC_CHECK4, m_fUninstallOnPolicyRemoval);
        DDX_Check(pDX, IDC_CHECK2, m_fShowPackageDetails);
        DDX_Check(pDX, IDC_CHECK5, m_f32On64);
        DDX_Check(pDX, IDC_CHECK6, m_fZapOn64);
        DDX_Check(pDX, IDC_CHECK7, m_fIncludeOLEInfo);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolAdvDefs, CDialog)
    //{{AFX_MSG_MAP(CToolAdvDefs)
    ON_BN_CLICKED(IDC_CHECK2, OnChanged)
    ON_BN_CLICKED(IDC_CHECK4, OnChanged)
    ON_BN_CLICKED(IDC_CHECK5, OnChanged)
    ON_BN_CLICKED(IDC_CHECK6, OnChanged)
    ON_BN_CLICKED(IDC_CHECK7, OnChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs message handlers

BOOL CToolAdvDefs::OnInitDialog()
{
#if DBG
    GetDlgItem(IDC_CHECK2)->ShowWindow(SW_SHOW);
    GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
#endif
    m_fUninstallOnPolicyRemoval = m_pToolDefaults->fUninstallOnPolicyRemoval;
    m_fShowPackageDetails = m_pToolDefaults->fShowPkgDetails;
    m_fZapOn64 = m_pToolDefaults->fZapOn64;
    m_f32On64 = m_pToolDefaults->f32On64;
    m_fIncludeOLEInfo = !m_pToolDefaults->fExtensionsOnly;

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

#include <shlobj.h>

BOOL CToolAdvDefs::OnApply()
{
    m_pToolDefaults->fShowPkgDetails = m_fShowPackageDetails;
    m_pToolDefaults->fUninstallOnPolicyRemoval = m_fUninstallOnPolicyRemoval;
    m_pToolDefaults->f32On64 = m_f32On64;
    m_pToolDefaults->fZapOn64 = m_fZapOn64;
    m_pToolDefaults->fExtensionsOnly = !m_fIncludeOLEInfo;

    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);

    return CPropertyPage::OnApply();
}


void CToolAdvDefs::OnChanged()
{
    SetModified();
}

LRESULT CToolAdvDefs::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CToolAdvDefs::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_TOOL_ADVANCEDDEFAULTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\sigs.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Sigs.h
//
//  Contents:   Digital Signatures property sheet
//
//  Classes:    CSignatures
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#ifdef DIGITAL_SIGNATURES

#if !defined(AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CSignatures dialog

class CSignatures : public CPropertyPage
{
        DECLARE_DYNCREATE(CSignatures)

// Construction
public:
        CSignatures();
        ~CSignatures();
        CScopePane * m_pScopePane;
        IClassAdmin *   m_pIClassAdmin;
        BOOL m_fAllow;
        BOOL m_fIgnoreForAdmins;
        BOOL m_fRSOP;
        LPGPEINFORMATION    m_pIGPEInformation;
        CListCtrl   m_list1;
        CListCtrl   m_list2;
        CString     m_szTempInstallableStore;
        CString     m_szTempNonInstallableStore;
        CSignatures ** m_ppThis;
        int         m_nSortedColumn;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CSignatures)
        enum { IDD = IDD_SIGNATURES };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CSignatures)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CSignatures)
        afx_msg void OnAddAllow();
        afx_msg void OnDeleteAllow();
        afx_msg void OnPropertiesAllow();
        afx_msg void OnAddDisallow();
        afx_msg void OnDeleteDisallow();
        afx_msg void OnPropertiesDisallow();
        afx_msg void OnAllowChanged();
        afx_msg void OnIgnoreChanged();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        void AddCertificate(CString &szStore);
        void RemoveCertificate(CString &szStore, CListCtrl &list);
        void CertificateProperties(CString &szStore, CListCtrl &list);
        HRESULT AddToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore);
        HRESULT AddMSIToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore);
        void ReportFailure(DWORD dwMessage, HRESULT hr);

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#endif DIGITAL_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tooldefs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolDefs.cpp
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolDefs
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog


CToolDefs::CToolDefs(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CToolDefs::IDD)
{
    //{{AFX_DATA_INIT(CToolDefs)
    m_szStartPath = _T("");
    m_iUI = -1;
        m_iDeployment = -1;
        //}}AFX_DATA_INIT
}

CToolDefs::~CToolDefs()
{
    *m_ppThis = NULL;
}

void CToolDefs::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CToolDefs)
    DDX_Text(pDX, IDC_EDIT1, m_szStartPath);
    DDX_Radio(pDX, IDC_RADIO8, m_iUI);
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolDefs, CDialog)
    //{{AFX_MSG_MAP(CToolDefs)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_BN_CLICKED(IDC_RADIO1, OnChanged)
    ON_BN_CLICKED(IDC_RADIO2, OnChanged)
    ON_BN_CLICKED(IDC_RADIO4, OnChanged)
    ON_BN_CLICKED(IDC_RADIO5, OnChanged)
    ON_BN_CLICKED(IDC_RADIO6, OnChanged)
    ON_BN_CLICKED(IDC_RADIO8, OnChanged)
    ON_BN_CLICKED(IDC_RADIO7, OnChanged)
    ON_EN_CHANGE(IDC_EDIT1, OnChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolDefs message handlers

BOOL CToolDefs::OnInitDialog()
{
    GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE==m_fMachine);
    m_szStartPath = m_pToolDefaults->szStartPath;
    if (m_pToolDefaults->fUseWizard)
    {
        m_iDeployment = 0;
    }
    else
    {
        if (m_pToolDefaults->fCustomDeployment)
        {
            m_iDeployment = 3;
        }
        else
        {
            switch (m_pToolDefaults->NPBehavior)
            {
            default:
            case NP_PUBLISHED:
                m_iDeployment = 1;
                if (m_fMachine)
                {
                    m_iDeployment = 0;
                }
                break;
            case NP_ASSIGNED:
                m_iDeployment = 2;
                break;
            case NP_DISABLED:
                m_iDeployment = 4;
                break;
            }
        }
    }

    switch (m_pToolDefaults->UILevel)
    {
    case INSTALLUILEVEL_FULL:
        m_iUI = 1;
        break;
    case INSTALLUILEVEL_BASIC:
    default:
        m_iUI = 0;
        break;
    }

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

#include <shlobj.h>

void CToolDefs::OnBrowse()
{
    IMalloc * pmalloc;
    if (SUCCEEDED(SHGetMalloc(&pmalloc)))
    {
        LPITEMIDLIST pidlNetwork;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETWORK, &pidlNetwork)))
        {
            BROWSEINFO bi;
            memset(&bi, 0, sizeof(bi));
            OLECHAR szDisplayName[MAX_PATH];
            bi.pszDisplayName = szDisplayName;
            CString sz;
            sz.LoadString(IDS_BROWSEFOLDERS);
            bi.lpszTitle = sz;
            bi.pidlRoot = pidlNetwork;
            bi.ulFlags = BIF_RETURNONLYFSDIRS;
            LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
            if (NULL != pidl)
            {
                OLECHAR szPath[MAX_PATH];
                if (SHGetPathFromIDList(pidl, szPath))
                {
                    m_szStartPath = szPath;
                    UpdateData(FALSE);
                    SetModified();
                }
                pmalloc->Free(pidl);
            }
        }
        pmalloc->Release();
    }

}

BOOL CToolDefs::OnApply()
{
    m_pToolDefaults->fUseWizard = FALSE;
    m_pToolDefaults->fCustomDeployment = FALSE;
    m_pToolDefaults->szStartPath = m_szStartPath;
    switch (m_iDeployment)
    {
    default:
    case 0: // display dialog
        m_pToolDefaults->fUseWizard = TRUE;
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        break;
    case 1: // published
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        break;
    case 2: // assigned
        m_pToolDefaults->NPBehavior = NP_ASSIGNED;
        break;
    case 3: // configure
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        m_pToolDefaults->fCustomDeployment = TRUE;
        break;
    case 4: // disabled
        m_pToolDefaults->NPBehavior = NP_DISABLED;
        break;
    }

    switch (m_iUI)
    {
    case 1:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_FULL;
        break;
    case 0:
    default:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_BASIC;
    }

    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);

    return CPropertyPage::OnApply();
}


void CToolDefs::OnChanged()
{
    SetModified();
}

LRESULT CToolDefs::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CToolDefs::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_TOOL_DEFAULTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tooldefs.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolDefs.h
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolDefs
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog

class CToolDefs : public CPropertyPage
{
// Construction
public:
        CToolDefs(CWnd* pParent = NULL);   // standard constructor
        ~CToolDefs();

// Dialog Data
        //{{AFX_DATA(CToolDefs)
        enum { IDD = IDD_TOOL_DEFAULTS };
        CString m_szStartPath;
        int             m_iUI;
        int             m_iDeployment;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fMachine;

        CToolDefs ** m_ppThis;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CToolDefs)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CToolDefs)
        virtual BOOL OnInitDialog();
        afx_msg void OnBrowse();
        afx_msg void OnChanged();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\stdafx.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       stdafx.h
//
//  Contents:   include file for standard system include files, or project
//              specific include files that are used frequently, but are
//              changed infrequently
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#ifdef DBG
//
// ATL's implementation of Release always returns 0 unless _DEBUG is
// defined. The debug version of OLE.DLL asserts Release() != 0 in certain
// circumstances.  I don't want to define _DEBUG because it brings in a
// whole lot of baggage from MMC that I don't want to deal with, but I do
// want to avoid this assertion in OLE, so on debug builds, I'll go ahead
// and define _DEBUG for the appropriate ATL header file but I'll undefine
// it again right afterward.  This is a little flakey but it is relatively
// safe and it achieves the desired goal.
//
// - SteveBl
//
#define _DEBUG
#endif
#include <atlcom.h>
#ifdef DBG
#undef _DEBUG
#endif

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    (void) StringCchPrintfA(buf, 
                            sizeof(buf)/sizeof(buf[0]),
                            "%s has %d instances left over.", 
                            pszClassName, 
                            cInstRem);

    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tooladv.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolAdv.h
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolAdvDefs
//
//  History:    09-12-2000   stevebl   Split from the General property page
//
//---------------------------------------------------------------------------

#if !defined(AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs dialog

class CToolAdvDefs : public CPropertyPage
{
// Construction
public:
        CToolAdvDefs(CWnd* pParent = NULL);   // standard constructor
        ~CToolAdvDefs();

// Dialog Data
        //{{AFX_DATA(CToolAdvDefs)
        enum { IDD = IDD_TOOL_ADVANCEDDEFAULTS };
        BOOL    m_fUninstallOnPolicyRemoval;
        BOOL    m_fShowPackageDetails;
        BOOL    m_fZapOn64;
        BOOL    m_f32On64;
        BOOL    m_fIncludeOLEInfo;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fMachine;

        CToolAdvDefs ** m_ppThis;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CToolAdvDefs)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CToolAdvDefs)
        virtual BOOL OnInitDialog();
        afx_msg void OnChanged();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\snapin.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       snapin.cpp
//
//  Contents:   DLL support routines, class factory and registration
//              functions.
//
//  Classes:
//
//  Functions:
//
//  History:    2-12-1998   stevebl   comment header added
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "initguid.h"
#include "gpedit.h"

extern const CLSID CLSID_Snapin = {0xBACF5C8A,0xA3C7,0x11D1,{0xA7,0x60,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};
extern const wchar_t * szCLSID_Snapin = L"{BACF5C8A-A3C7-11D1-A760-00C04FB9603F}";
extern const CLSID CLSID_MachineSnapin = {0x942A8E4F,0xA261,0x11D1,{0xA7,0x60,0x00,0xc0,0x4f,0xb9,0x60,0x3f}};
extern const wchar_t * szCLSID_MachineSnapin = L"{942A8E4F-A261-11D1-A760-00C04FB9603F}";

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xF8B3A900,0X8EA5,0X11D0,{0X8D,0X3C,0X00,0XA0,0XC9,0X0D,0XCA,0XE7}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{F8B3A900-8EA5-11D0-8D3C-00A0C90DCAE7}";

// No public place for this now, real def is in gina\gpext\appmgmt\cs.idl.
extern const IID IID_IClassAdmin = {0x00000191,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// RSOP flavors:

extern const CLSID CLSID_RSOP_Snapin = {
    0x1bc972d6,
    0x555c,
    0x4ff7,
    {0xbe, 0x2c, 0xc5, 0x84, 0x02, 0x1a, 0x0a, 0x6a}};
extern const wchar_t * szCLSID_RSOP_Snapin = L"{1BC972D6-555C-4FF7-BE2C-C584021A0A6A}";
extern const CLSID CLSID_RSOP_MachineSnapin = {
    0x7e45546f,
    0x6d52,
    0x4d10,
    {0xb7, 0x02, 0x9c, 0x2e, 0x67, 0x23, 0x2e, 0x62}};
extern const wchar_t * szCLSID_RSOP_MachineSnapin = L"{7E45546F-6D52-4D10-B702-9C2E67232E62}";

#include "safereg.hxx"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define PSBUFFER_STR    L"AppManagementBuffer"
#define THREADING_STR   L"Apartment"

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_MachineSnapin, CMachineComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_Snapin, CRSOPUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_MachineSnapin, CRSOPMachineComponentDataImpl)
END_OBJECT_MAP()

CLSID CLSID_Temp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
//        CoGetMalloc(1, &g_pIMalloc);

        CsSetOptions( CsOption_AdminTool );

       InitDebugSupport();

        // Add theme'ing support
        BOOL bInitialized = SHFusionInitializeFromModuleID (m_hInstance, 2);
 
        if ( bInitialized )
        {
            return bInitialized = CWinApp::InitInstance();
        }

        return bInitialized;
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CResultPane);
        DEBUG_VERIFY_INSTANCE_COUNT(CScopePane);

        // Cleanup required by fusion support
        SHFusionUninitialize();
        
//        g_pIMalloc->Release();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

const wchar_t * szUser_Namespace = L"{59849DF9-A256-11D1-A760-00C04FB9603F}";
const wchar_t * szMachine_Namespace = L"{4D53F093-A260-11D1-A760-00C04FB9603F}";
const wchar_t * szMachineAppName = L"Software Installation (Computers)";
const wchar_t * szUserAppName = L"Software Installation (Users)";
const wchar_t * szUser_RSOP_Namespace = L"{9D5EB218-8EA3-4EE9-B120-52FC68C8D128}";
const wchar_t * szMachine_RSOP_Namespace = L"{DFA38559-8B35-42EF-8B00-E8F6CBF99BC0}";

const wchar_t * szUserAppNameIndirect = L"@appmgr.dll,-50";
const wchar_t * szMachineAppNameIndirect = L"@appmgr.dll,-51";

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
    HRESULT hr = S_OK;

    do
    {
        CLSID_Temp = CLSID_Snapin;
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szUserAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szUserAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();

        hr = shkCLSID.Create(szCLSID_MachineSnapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szMachineAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szMachine_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shkCLSID.Create(szMachine_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        WCHAR szGUID[50];
        StringFromGUID2 (NODEID_UserSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        StringFromGUID2 (NODEID_MachineSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_MachineSnapin,
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        //
        // RSOP versions
        //

        CLSID_Temp = CLSID_RSOP_Snapin;
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_RSOP_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szUserAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szUserAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();

        hr = shkCLSID.Create(szCLSID_RSOP_MachineSnapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szMachineAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szMachine_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shkCLSID.Create(szMachine_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        StringFromGUID2 (NODEID_RSOPUserSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        StringFromGUID2 (NODEID_RSOPMachineSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_MachineSnapin,
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    CLSID_Temp = CLSID_Snapin;
    _Module.UnregisterServer();

    HKEY hkey;
    CString sz;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_Snapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_Namespace));
        RegCloseKey(hkey);
    }
    WCHAR szGUID[50];
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_UserSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_Snapin);
        RegCloseKey(hkey);
    }

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_MachineSnapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szMachine_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_MachineSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_MachineSnapin);
        RegCloseKey(hkey);
    }

    //
    // RSOP versions
    //

    CLSID_Temp = CLSID_RSOP_Snapin;
    _Module.UnregisterServer();

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_Snapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_RSOP_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPUserSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_Snapin);
        RegCloseKey(hkey);
    }

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_MachineSnapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szMachine_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPMachineSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_RSOP_MachineSnapin);
        RegCloseKey(hkey);
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tracking.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Tracking.cpp
//
//  Contents:   tracking property sheet
//
//  Classes:    CTracking
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTracking property page

IMPLEMENT_DYNCREATE(CTracking, CPropertyPage)

CTracking::CTracking() : CPropertyPage(CTracking::IDD)
{
        //{{AFX_DATA_INIT(CTracking)
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
}

CTracking::~CTracking()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CTracking::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CTracking)
        DDX_Control(pDX, IDC_SPIN1, m_spin);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTracking, CPropertyPage)
        //{{AFX_MSG_MAP(CTracking)
        ON_BN_CLICKED(IDC_BUTTON1, OnCleanUpNow)
        ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN1, OnDeltaposSpin1)
        ON_EN_CHANGE(IDC_EDIT1, OnChangeEdit1)
        ON_EN_KILLFOCUS(IDC_EDIT1, OnKillfocusEdit1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTracking message handlers

void CTracking::OnCleanUpNow()
{
    FILETIME ft;
    SYSTEMTIME st;
    // get current time
    GetSystemTime(&st);
    // convert it to a FILETIME value
    SystemTimeToFileTime(&st, &ft);
    // subtract the right number of days
    LARGE_INTEGER li;
    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;
    li.QuadPart -= ONE_FILETIME_DAY * (((LONGLONG)m_pToolDefaults->nUninstallTrackingMonths * 365) / 12);
    ft.dwLowDateTime = li.LowPart;
    ft.dwHighDateTime = li.HighPart;
    // tell the CS to clean up anything older
    m_pIClassAdmin->Cleanup(&ft);
}

BOOL CTracking::OnApply()
{
        // TODO: Add your specialized code here and/or call the base class
        m_pToolDefaults->nUninstallTrackingMonths = (ULONG) m_spin.GetPos();
        MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
        return CPropertyPage::OnApply();
}

BOOL CTracking::OnInitDialog()
{
        CPropertyPage::OnInitDialog();
        m_spin.SetRange(1,60);
        m_spin.SetPos(m_pToolDefaults->nUninstallTrackingMonths);
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CTracking::OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
        *pResult = 0;
        SetModified(m_spin.GetPos() != m_pToolDefaults->nUninstallTrackingMonths);
}

LRESULT CTracking::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CTracking::OnChangeEdit1()
{
    SetModified(m_spin.GetPos() != m_pToolDefaults->nUninstallTrackingMonths);
}

void CTracking::OnKillfocusEdit1()
{
    // Reset the spin control to pull any values in the edit control back
    // into range if necessary.
    m_spin.SetPos(m_spin.GetPos());
}

void CTracking::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_UNINSTALLTRACKING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\upgrades.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       upgrades.h
//
//  Contents:   upgrades dialog (during deployment)
//
//  Classes:    CUpgrades
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CUpgrades dialog

class CUpgrades
{
// Construction
public:
        // m_UpgradeList: maps UpgradeIndex to UpgradeData
        map<CString, CUpgradeData> m_UpgradeList;

        // m_NameIndex: maps name to UpgradeIndex
        map<CString, CString> m_NameIndex;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\uplist.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       UpList.cpp
//
//  Contents:   upgrade realationships property sheet
//
//  Classes:    CUpgradeList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// uncomment the following line to allow double clicking on a list box to
// launch a property sheet for the the thing you've double clicked on
// #define DOUBLECLICKLAUNCH 1

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList property page

IMPLEMENT_DYNCREATE(CUpgradeList, CPropertyPage)

CUpgradeList::CUpgradeList() : CPropertyPage(CUpgradeList::IDD)
{
    //{{AFX_DATA_INIT(CUpgradeList)
        m_fForceUpgrade = FALSE;
        //}}AFX_DATA_INIT
    m_ppThis = NULL;
    m_fModified = FALSE;
    m_pIClassAdmin = NULL;
    m_fPreDeploy = FALSE;
}

CUpgradeList::~CUpgradeList()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CUpgradeList::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUpgradeList)
    DDX_Control(pDX, IDC_LIST2, m_UpgradedBy);
    DDX_Control(pDX, IDC_LIST1, m_Upgrades);
        DDX_Check(pDX, IDC_CHECK1, m_fForceUpgrade);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUpgradeList, CPropertyPage)
    //{{AFX_MSG_MAP(CUpgradeList)
        ON_LBN_DBLCLK(IDC_LIST1, OnDblclkList1)
        ON_LBN_DBLCLK(IDC_LIST2, OnDblclkList2)
        ON_BN_CLICKED(IDC_CHECK1, OnRequire)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON3, OnRemove)
        ON_BN_CLICKED(IDC_BUTTON2, OnEdit)
        ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList message handlers

LRESULT CUpgradeList::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        m_dlgAdd.EndDialog(IDCANCEL);
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

BOOL CUpgradeList::OnInitDialog()
{
    m_dlgAdd.m_pUpgradeList = &m_UpgradeList;
    m_dlgAdd.m_pScope = m_pScopePane;
    m_fForceUpgrade = (0 != (m_pData->m_pDetails->pInstallInfo->dwActFlags & ACTFLG_ForceUpgrade));
    if (m_fMachine)
    {
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    }
    if (m_fRSOP)
    {
        CString szText;
        szText.LoadString(IDS_RSOPUPGRADEDTEXT);
        SetDlgItemText(IDC_STATIC1, szText);
    }

    CPropertyPage::OnInitDialog();

    RefreshData();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CUpgradeList::RefreshData()
{
    GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    CString szUpgrade;
    CString szReplace;
    szUpgrade.LoadString(IDS_UPGRADE);
    szReplace.LoadString(IDS_REPLACE);
    m_Upgrades.ResetContent();
    m_Upgrades.SetHorizontalExtent(0);
    m_UpgradedBy.ResetContent();
    m_UpgradedBy.SetHorizontalExtent(0);
    m_UpgradeList.erase(m_UpgradeList.begin(), m_UpgradeList.end());
    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());

    // populate m_Upgrades and m_UpgradedBy
    if (m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);

        // populate the upgrade lists using the RSOP data
        set <CString>::iterator i;
        i = m_pData->m_setUpgradedBy.begin();
        while (i != m_pData->m_setUpgradedBy.end())
        {
            m_UpgradedBy.AddString(*i);
            CDC * pDC = m_UpgradedBy.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_UpgradedBy.ReleaseDC(pDC);
            if (m_UpgradedBy.GetHorizontalExtent() < size.cx)
            {
                m_UpgradedBy.SetHorizontalExtent(size.cx);
            }
            i++;
        }
        i = m_pData->m_setUpgrade.begin();
        while (i != m_pData->m_setUpgrade.end())
        {
            CString sz;
            sz = szUpgrade;
            sz += L'\t';
            sz += *i;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            i++;
        }
        i = m_pData->m_setReplace.begin();
        while (i != m_pData->m_setReplace.end())
        {
            CString sz;
            sz = szReplace;
            sz += L'\t';
            sz += *i;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            i++;
        }
    }
    else
    {
        UINT n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
        while (n--)
        {
            CString szPackageName;
            CUpgradeData data;
            memcpy(&data.m_PackageGuid, &m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, sizeof(GUID));
            data.m_szClassStore = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore;
            data.m_flags = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag;
            HRESULT hr = m_pScopePane->GetPackageNameFromUpgradeInfo(szPackageName, data.m_PackageGuid, (LPOLESTR)((LPCWSTR)data.m_szClassStore));
            if (SUCCEEDED(hr))
            {
                // found a match
                if (0 != (UPGFLG_UpgradedBy & data.m_flags))
                {
                    m_UpgradedBy.AddString(szPackageName);
                    CDC * pDC = m_UpgradedBy.GetDC();
                    CSize size = pDC->GetTextExtent(szPackageName);
                    pDC->LPtoDP(&size);
                    m_UpgradedBy.ReleaseDC(pDC);
                    if (m_UpgradedBy.GetHorizontalExtent() < size.cx)
                    {
                        m_UpgradedBy.SetHorizontalExtent(size.cx);
                    }
                }
                else
                {
                    CString sz = UPGFLG_Uninstall == m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag ? szReplace : szUpgrade;
                    sz += L'\t';
                    sz += szPackageName;
                    m_Upgrades.AddString(sz);
                    CDC * pDC = m_Upgrades.GetDC();
                    CSize size = pDC->GetTextExtent(sz);
                    pDC->LPtoDP(&size);
                    m_Upgrades.ReleaseDC(pDC);
                    if (m_Upgrades.GetHorizontalExtent() < size.cx)
                    {
                        m_Upgrades.SetHorizontalExtent(size.cx);
                    }
                    CString szIndex = GetUpgradeIndex(data.m_PackageGuid);
                    m_UpgradeList[szIndex] = data;
                    m_NameIndex[sz] = szIndex;
                }
            }
        }
    }
}


void CUpgradeList::OnDblclkList1()
{
#if DOUBLECLICKLAUNCH
    int i = m_Upgrades.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(i, sz);
        m_pScopePane->DisplayPropSheet(sz, 2);
    }
#endif
}

void CUpgradeList::OnDblclkList2()
{
#if DOUBLECLICKLAUNCH
    int i = m_UpgradedBy.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_UpgradedBy.GetText(i, sz);
        m_pScopePane->DisplayPropSheet(sz, 2);
    }
#endif
}

void CUpgradeList::OnRequire()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fModified = TRUE;
}

void CUpgradeList::OnAdd()
{
    CString szUpgrade;
    CString szReplace;
    szUpgrade.LoadString(IDS_UPGRADE);
    szReplace.LoadString(IDS_REPLACE);

    m_dlgAdd.m_szMyGuid = GetUpgradeIndex(m_pData->m_pDetails->pInstallInfo->PackageGuid);

    if (IDOK == m_dlgAdd.DoModal())
    {
        CString szIndex = GetUpgradeIndex(m_dlgAdd.m_UpgradeData.m_PackageGuid);
        if (IsUpgradeLegal(szIndex))
        {
            // add the chosen app
            m_UpgradeList[szIndex] = m_dlgAdd.m_UpgradeData;
            // m_dlgAdd.m_fUninstall ? UPGFLG_Uninstall : UPGFLG_NoUninstall;
            CString sz = 0 != (m_dlgAdd.m_UpgradeData.m_flags & UPGFLG_Uninstall) ? szReplace : szUpgrade;
            sz += L'\t';
            sz += m_dlgAdd.m_szPackageName;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(sz);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            m_NameIndex[sz] = szIndex;
            if (!m_fPreDeploy)
                SetModified();
            m_fModified = TRUE;
        }
        else
        {
            CString szText;
            szText.LoadString(IDS_INVALIDUPGRADE);
            MessageBox(szText, m_dlgAdd.m_szPackageName, MB_ICONEXCLAMATION | MB_OK);
        }
    }

}

BOOL CUpgradeList::IsUpgradeLegal(CString sz)
{
    // for now I'll just check to make sure that this guy isn't upgrading me
    CString sz2;
    UINT n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
        {
            sz2 = GetUpgradeIndex(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid);
            if (0 == sz.CompareNoCase(sz2))
                return FALSE;
        }
    }
    return TRUE;
}

void CUpgradeList::OnSelchangeList1()
{
    int iSel = m_Upgrades.GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(iSel, sz);
    }
    GetDlgItem(IDC_BUTTON3)->EnableWindow( !m_fRSOP );
}

void CUpgradeList::OnRemove()
{
    int iSel = m_Upgrades.GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(iSel, sz);
        // check to be sure app does not have UPGFLG_Enforced

        m_UpgradeList.erase(m_NameIndex[sz]);
        m_NameIndex.erase(sz);
        m_Upgrades.DeleteString(iSel);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        if (GetDlgItem(IDC_BUTTON3) == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    }
}

void CUpgradeList::OnEdit()
{
    // TODO: Add your control notification handler code here
}

BOOL CUpgradeList::OnApply()
{
    if (m_fModified)
    {
        // Set the new upgrade list and flags
        DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;

        if (m_fForceUpgrade)
            dwActFlags |= ACTFLG_ForceUpgrade;
        else
            dwActFlags &= ~ACTFLG_ForceUpgrade;

        // Pilot flag stuff is for backward compatability - it will
        // eventually be yanked.
        UINT n = m_UpgradeList.size();
        if (n)
        {
            if (m_fForceUpgrade)
                dwActFlags &= ~ACTFLG_Pilot;
            else
                dwActFlags |= ACTFLG_Pilot;
        }
        else
        {
            // no upgrades left in the list - remove the pilot flag just
            // to be safe
            dwActFlags &= ~ACTFLG_Pilot;
        }

        // count the "upgraded by" elements
        UINT n2 = m_pData->m_pDetails->pInstallInfo->cUpgrades;
        while (n2--)
        {
            if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag))
            {
                n++;
            }
        }
        UINT cUpgrades = n;
        UPGRADEINFO * prgUpgradeInfoList = NULL;

        if (n)
        {
            prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);

            if (prgUpgradeInfoList)
            {
                n = 0;

                // add the "upgraded by" elements
                n2 = m_pData->m_pDetails->pInstallInfo->cUpgrades;
                while (n2--)
                {
                    if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag))
                    {
                        prgUpgradeInfoList[n].Flag = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag;
                        OLESAFE_COPYSTRING(prgUpgradeInfoList[n].szClassStore, m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].szClassStore);
                        memcpy(&prgUpgradeInfoList[n].PackageGuid, &m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].PackageGuid, sizeof(GUID));
                        n++;
                    }
                }

                // add the "upgrading" elements
                map <CString, CUpgradeData>::iterator i;
                for (i = m_UpgradeList.begin(); i != m_UpgradeList.end(); i++)
                {
                    prgUpgradeInfoList[n].Flag = i->second.m_flags;
                    OLESAFE_COPYSTRING(prgUpgradeInfoList[n].szClassStore, i->second.m_szClassStore);
                    memcpy(&prgUpgradeInfoList[n].PackageGuid, &i->second.m_PackageGuid, sizeof(GUID));
                    n++;
                }
            }
            else
            {
                // out of memory
                HRESULT hr = E_OUTOFMEMORY;
                CString sz;
                sz.LoadString(IDS_CHANGEFAILED);
                ReportGeneralPropertySheetError(m_hWnd, sz, hr);
                return FALSE;
            }
        }

        HRESULT hr = E_FAIL;

        if (m_pIClassAdmin)
        {
            hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                         NULL,
                                                         &dwActFlags,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pIClassAdmin->ChangePackageUpgradeList(m_pData->m_pDetails->pszPackageName,
                                                                  cUpgrades,
                                                                  prgUpgradeInfoList);
            if (SUCCEEDED(hr))
            {
                m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
                if (n)
                {
                    while (n--)
                    {
                        OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                    }
                    OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList);
                }
                m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList = prgUpgradeInfoList;
                m_pData->m_pDetails->pInstallInfo->cUpgrades = cUpgrades;
                m_pData->m_pDetails->pInstallInfo->dwActFlags = dwActFlags;
                m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                if (m_pScopePane->m_pFileExt)
                {
                    m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                }
                m_pData->m_szUpgrades.Empty(); // Clear the cached
                                               // upgrade relation
                                               // string so it will be
                                               // refreshed.
                m_fModified = FALSE;

                if (!m_fPreDeploy)
                {
                    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
                }
                m_fModified = FALSE;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ChangePackageUpgradeList failed with 0x%x"), hr));
                // Put back the original flags if for some reason we were
                // able to change the flags but unable to change the upgrade
                // list.
                m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                             NULL,
                                                             &m_pData->m_pDetails->pInstallInfo->dwActFlags,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL);
                // Note that if this fails there's little we could do to
                // recover so I just assume it succeeds.
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        }
        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString(IDS_CHANGEFAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);
            n = cUpgrades;
            if (n)
            {
                while (n--)
                {
                    OLESAFE_DELETE(prgUpgradeInfoList[n].szClassStore);
                }
                OLESAFE_DELETE(prgUpgradeInfoList);
            }
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}


void CUpgradeList::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_UPGRADES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\tracking.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Tracking.h
//
//  Contents:   tracking settings property page
//
//  Classes:    CTracking
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
#define AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxcmn.h>

/////////////////////////////////////////////////////////////////////////////
// CTracking dialog

class CTracking : public CPropertyPage
{
        DECLARE_DYNCREATE(CTracking)

// Construction
public:
        CTracking();
        ~CTracking();

// Dialog Data
        //{{AFX_DATA(CTracking)
        enum { IDD = IDD_UNINSTALLTRACKING };
        CSpinButtonCtrl m_spin;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        IClassAdmin *   m_pIClassAdmin;
        CTracking ** m_ppThis;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CTracking)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CTracking)
        afx_msg void OnCleanUpNow();
        virtual BOOL OnInitDialog();
        afx_msg void OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult);
        afx_msg void OnChangeEdit1();
        afx_msg void OnKillfocusEdit1();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

// The number of FILETIME values that equals a single day, used to compute
// value to send to IClassAdmin->CleanUp.
// Each FILETIME value (or tick) is 100 nano-seconds.
//    0.01 tics/nano-seconds
//    * 1,000,000,000 nano-seconds/sec
//    * 60 sec/min
//    * 60 min/hour
//    * 24 hour/day
//    = 864,000,000,000 ticks/day
#define ONE_FILETIME_DAY 864000000000

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\uplist.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       UpList.h
//
//  Contents:   upgrade relationships property sheet
//
//  Classes:    CUpgradeList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_)
#define AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList dialog

class CUpgradeList : public CPropertyPage
{
        DECLARE_DYNCREATE(CUpgradeList)

// Construction
public:
        CUpgradeList();
        ~CUpgradeList();

// Dialog Data
        //{{AFX_DATA(CUpgradeList)
        enum { IDD = IDD_UPGRADES };
        CListBox        m_UpgradedBy;
        CListBox        m_Upgrades;
        BOOL    m_fForceUpgrade;
        BOOL            m_fRSOP;
        //}}AFX_DATA
        CUpgradeList **         m_ppThis;
        CAppData *              m_pData;
        LONG_PTR                m_hConsoleHandle;
        MMC_COOKIE              m_cookie;
        CScopePane *    m_pScopePane;
        BOOL            m_fMachine;
#if 0
        LPGPEINFORMATION m_pIGPEInformation;
#endif
        map<CString, CUpgradeData>      m_UpgradeList;
        map<CString, CString>   m_NameIndex;
        IClassAdmin *   m_pIClassAdmin;
        BOOL            m_fPreDeploy;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CUpgradeList)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CUpgradeList)
        virtual BOOL OnInitDialog();
        afx_msg void OnDblclkList1();
        afx_msg void OnDblclkList2();
        afx_msg void OnRequire();
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        afx_msg void OnEdit();
        afx_msg void OnSelchangeList1();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
        BOOL IsUpgradeLegal(CString sz);
        CAddUpgrade             m_dlgAdd;
        BOOL                    m_fModified;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\xforms.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Xforms.cpp
//
//  Contents:   modifications (transforms) property page
//
//  Classes:    CXforms
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXforms property page

IMPLEMENT_DYNCREATE(CXforms, CPropertyPage)

CXforms::CXforms() : CPropertyPage(CXforms::IDD)
{
        //{{AFX_DATA_INIT(CXforms)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
        m_fModified = FALSE;
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
}

CXforms::~CXforms()
{
        if (m_ppThis)
        {
            *m_ppThis = NULL;
        }
        if (m_pIClassAdmin)
        {
            m_pIClassAdmin->Release();
        }
}

void CXforms::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CXforms)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CXforms, CPropertyPage)
        //{{AFX_MSG_MAP(CXforms)
        ON_BN_CLICKED(IDC_BUTTON3, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON4, OnMoveDown)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXforms message handlers

void CXforms::OnMoveUp()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (LB_ERR != i && i > 0)
    {
        CString sz;
        pList->GetText(i, sz);
        pList->DeleteString(i);
        pList->InsertString(i-1, sz);
        pList->SetCurSel(i-1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
    }
}

void CXforms::OnMoveDown()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i < pList->GetCount() - 1)
    {
        CString sz;
        pList->GetText(i+1, sz);
        pList->DeleteString(i+1);
        pList->InsertString(i, sz);
        pList->SetCurSel(i+1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
    }
}

void CXforms::OnAdd()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_DEF_TRANSFORM_EXTENSION);
    szFilter.LoadString(IDS_TRANSFORM_EXTENSION_FILTER);

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = ghInstance;
    TCHAR lpstrFilter[MAX_PATH];

    //
    // Note that since wcsncpy does not null terminate
    // if the string hits the specified character limit,
    // we need to prevent it from going all the way
    // to the end of the buffer by specifying that
    // it should use a length one less than the size
    // of the buffer
    //
    wcsncpy(lpstrFilter, szFilter, MAX_PATH - 1 );

    //
    // Since the string may not have been null terminated
    // as described above, we ensure that the very last
    // character is a terminator to handle the case
    // where the string was at least MAX_PATH - 1 
    // chars long.
    //
    lpstrFilter[ MAX_PATH - 1 ] = L'\0';

    ofn.lpstrFilter = lpstrFilter;
    TCHAR szFileTitle[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    szFile[0] = NULL;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = MAX_PATH;
    ofn.lpstrInitialDir = m_pScopePane->m_ToolDefaults.szStartPath;
    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = szExtension;
    int iBreak = 0;
    while (lpstrFilter[iBreak])
    {
        if (lpstrFilter[iBreak] == TEXT('|'))
        {
            lpstrFilter[iBreak] = 0;
        }
        iBreak++;
    }
    if (GetOpenFileName(&ofn))
    {
        // user selected an application

        ULONG cbSize = sizeof(UNIVERSAL_NAME_INFO);
        UNIVERSAL_NAME_INFO * pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
        DWORD dwError = WNetGetUniversalName(ofn.lpstrFile,
                                          UNIVERSAL_NAME_INFO_LEVEL,
                                          pUni,
                                          &cbSize);
        if (ERROR_MORE_DATA == dwError)  // we expect this to be true
        {
            delete [] pUni;
            pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
            dwError = WNetGetUniversalName(ofn.lpstrFile,
                                      UNIVERSAL_NAME_INFO_LEVEL,
                                      pUni,
                                      &cbSize);
        }

        CString szTransformPath;

        if (ERROR_SUCCESS == dwError)
        {
            szTransformPath = pUni->lpUniversalName;
        }
        else
        {
            szTransformPath = ofn.lpstrFile;
        }
        delete[] pUni;

        CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
        pList->AddString(szTransformPath);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(szTransformPath);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
        pList->SetCurSel(pList->GetCount() - 1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        int n = pList->GetCount();
        GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 0);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(n > 1);
        GetDlgItem(IDC_BUTTON4)->EnableWindow(n > 1);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
    }
}

void CXforms::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (LB_ERR != i)
    {
        pList->DeleteString(i);
        pList->SetCurSel(0);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        int n = pList->GetCount();
        GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 0);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(n > 1);
        GetDlgItem(IDC_BUTTON4)->EnableWindow(n > 1);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
    }
}

BOOL CXforms::OnInitDialog()
{
    if (m_pScopePane->m_fRSOP || !m_fPreDeploy)
    {
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
        SetDlgItemText(IDC_STATICNOHELP1, TEXT(""));
    }
    GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON4)->EnableWindow(FALSE);
    // Remember what the package name was at first so we can tell if the
    // user's changed it.

    m_szInitialPackageName = m_pData->m_pDetails->pszPackageName;

    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CXforms::OnApply()
{
    // NOTE
    //
    // If the transform list changes we really have no choice but to
    // re-deploy the app because it can cause virtually every field in the
    // package details structure to change (a change in the transform list
    // causes a rebuild of the script file which could potentially affect
    // almost everything).
    //
    // For this reason, this property sheet MUST NOT BE ACTIVE once an app
    // is deployed.
    //
    BOOL fBuildSucceeded = FALSE;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_fModified)
    {
        CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
        PACKAGEDETAIL * ppd;
        if (FAILED(CopyPackageDetail(ppd, m_pData->m_pDetails)))
        {
            return FALSE;
        }

        CString sz;
        int i;
        for (i = ppd->cSources; i--;)
        {
            OLESAFE_DELETE(ppd->pszSourceList[i]);
        }
        OLESAFE_DELETE(ppd->pszSourceList);
        int n = pList->GetCount();
        ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * (n + 1));
        if (ppd->pszSourceList)
        {
            OLESAFE_COPYSTRING(ppd->pszSourceList[0], m_pData->m_pDetails->pszSourceList[0]);
            for (i = 0; i < n; i++)
            {
                pList->GetText(i, sz);
                OLESAFE_COPYSTRING(ppd->pszSourceList[i+1], sz);
            }
            ppd->cSources = n + 1;
        }
        else
        {
            ppd->cSources = 0;
            return FALSE;
        }

        // Create a name for the new script file.

        // set the script path
        GUID guid;
        HRESULT hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            // undone
        }
        OLECHAR szGuid [256];
        StringFromGUID2(guid, szGuid, 256);

        CString szScriptFile  = m_pScopePane->m_szGPT_Path;
        szScriptFile += L"\\";
        szScriptFile += szGuid;
        szScriptFile += L".aas";
        OLESAFE_DELETE(ppd->pInstallInfo->pszScriptPath);
        OLESAFE_COPYSTRING(ppd->pInstallInfo->pszScriptPath, szScriptFile);
        CString szOldName = ppd->pszPackageName;
        hr = BuildScriptAndGetActInfo(*ppd, ! m_pData->m_pDetails->pActInfo->bHasClasses);
        if (SUCCEEDED(hr))
        {
            if (0 != wcscmp(m_szInitialPackageName, szOldName))
            {
                // The User changed the name so we have to preserve his choice.
                // If the user hasn't changed the package name then it's ok to
                // set the packagename to whatever is in the script file.
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szOldName);
            }

            fBuildSucceeded = TRUE;
            hr = m_pScopePane->PrepareExtensions(*ppd);
            if (SUCCEEDED(hr))
            {
                CString szUniqueName;
                int     nHint;

                nHint = 1;

                m_pScopePane->GetUniquePackageName(ppd->pszPackageName, szUniqueName, nHint);
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueName);

                hr = m_pIClassAdmin->RedeployPackage(
                        &m_pData->m_pDetails->pInstallInfo->PackageGuid,
                        ppd);

                if (SUCCEEDED(hr))
                {
                    // delete the old script
                    DeleteFile(m_pData->m_pDetails->pInstallInfo->pszScriptPath);
                    // update indexes and property sheets
                    m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                    m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                    FreePackageDetail(m_pData->m_pDetails);
                    m_pData->m_pDetails = ppd;
                    m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                    m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                    if (m_pScopePane->m_pFileExt)
                    {
                        m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                    }
                    m_fModified = FALSE;
                    if (!m_fPreDeploy)
                    {
                        MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
                    }
                }
            }
        }
        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString(fBuildSucceeded ? IDS_TRANSFORM_FAILED_IN_CS : IDS_TRANSFORM_FAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);

            // delete new script file (assuming it was created)
            DeleteFile(szScriptFile);

            FreePackageDetail(ppd);
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}

LRESULT CXforms::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CXforms::RefreshData(void)
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    pList->ResetContent();
    pList->SetHorizontalExtent(0);

    UINT i;
    // Item at 0 is the package.  Items > 0 are transforms.
    for (i = 1; i < m_pData->m_pDetails->cSources; i++)
    {
        pList->AddString(m_pData->m_pDetails->pszSourceList[i]);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(m_pData->m_pDetails->pszSourceList[i]);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
    }
    pList->SetCurSel(0);

    SetModified(FALSE);
    m_fModified = FALSE;
}


void CXforms::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_MODIFICATIONS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\common.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       common.h
//
//  Contents:   common definitions used by the main snapin modules
//
//  Classes:    CResultPane, CScopePane
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include <vector>
#include <malloc.h>
#include <objsel.h>
#include <shlwapi.h>
#include "objidl.h"
#include "gpedit.h"
#include "iads.h"
#include "HelpArr.h"
#include "Path.hxx"
#include "PathSlct.hxx"
#include "redirect.hxx"
#include "FileInfo.hxx"
#include "utils.hxx"
#include "error.hxx"
#include "security.hxx"
#include "secpath.hxx"
#include "prefs.hxx"
#include "rsopinfo.h"
#include "rsopprop.h"

///////////////////////////////////////////////////////////////////
// workaround macro for MFC bug
// (see NTRAID 342926 and MFC "Monte Carlo" RAID db # 1034)
#define FIX_THREAD_STATE_MFC_BUG() \
                AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState(); \
                CWinThread _dummyWinThread; \
                if (pState->m_pCurrentWinThread == NULL) \
                { \
                    pState->m_pCurrentWinThread = &_dummyWinThread; \
                }

//get the index of a cookie in the folder cache of the scope pane
#define GETINDEX(x)         (((x) < IDS_DIRS_END && (x) >= IDS_DIRS_START) ? ((x) - IDS_DIRS_START) : -1)
// private notifications
#define WM_USER_REFRESH     WM_USER
#define WM_USER_CLOSE       (WM_USER + 1)
#define MAX_DS_PATH 1024

// Other private notifications.
#define WM_PATH_TWEAKED     (WM_APP + 1)

//the max. possible length of the path that can be entered into the edit control
#define TARGETPATHLIMIT     MAX_PATH - 4

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern const wchar_t * szCLSID_Snapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;

//the GUID for the client side extension
extern GUID guidExtension;

extern CString szExtension;
extern CString szFilter;

// RSOP GUIDS
extern const CLSID CLSID_RSOP_Snapin;
extern const wchar_t * szCLSID_RSOP_Snapin;

#define IMG_OPENBOX   0
#define IMG_CLOSEDBOX 1
#define IMG_DISABLED  2
#define IMG_PUBLISHED 3
#define IMG_ASSIGNED  4
#define IMG_UPGRADE   5

//
// MACROS for allocating and freeing memory via OLE's common allocator: IMalloc.
//
extern IMalloc * g_pIMalloc;

// UNDONE - throw exception on failure

//#define OLEALLOC(x) new char [x]
#define OLEALLOC(x) g_pIMalloc->Alloc(x)

//#define OLESAFE_DELETE(x) if (x) {delete x; x = NULL;}
#define OLESAFE_DELETE(x) if (x) {g_pIMalloc->Free(x); x = NULL;}

#define OLESAFE_COPYSTRING(szO, szI) {if (szI) {int i_dontcollidewithanything = wcslen(szI); szO=(OLECHAR *)OLEALLOC(sizeof(OLECHAR) * (i_dontcollidewithanything+1)); HRESULT hr = StringCchCopy(szO, i_dontcollidewithanything+1, szI);ASSERT(SUCCEEDED(hr));} else szO=NULL;}

/////////////////////////////////////////////////////////////////////////////
// Snapin

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CScopePane:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public CComObjectRoot,
    public IExtendPropertySheet,
    public ISnapinAbout,
    public ISnapinHelp
{

    friend class CResultPane;
    friend class CDataObject;
    friend class CRedirect;
    friend HRESULT ConvertOldStyleSection (const CString&, const CScopePane*);

public:
        CScopePane();
        ~CScopePane();

protected:
    LPGPEINFORMATION    m_pIGPEInformation;  // Interface pointer to the GPT
    LPRSOPINFORMATION    m_pIRSOPInformation;  // Interface pointer to the GPT
    CFileInfo m_FolderData[IDS_DIRS_END - IDS_DIRS_START];

public:
    virtual IUnknown * GetMyUnknown() = 0;

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// ISnapinAbout interface
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP * hSmallImage,
                                 HBITMAP * hSmallImageOpen,
                                 HBITMAP * hLargeImage,
                                 COLORREF * cMask);

    //
    // Implemented ISnapinHelp interface members
    //
public:
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);

// Notify handler declarations
private:
    HRESULT OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    LPDISPLAYHELP           m_pDisplayHelp;
    BOOL                    m_bIsDirty;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    void LoadToolDefaults();
    void SaveToolDefaults();
    CResultPane * m_pResultPane;
    IPropertySheetProvider * m_pIPropertySheetProvider;

public:
    CString m_szFileRoot;
    CString m_szFolderTitle;
    CString             m_szRSOPNamespace;
    BOOL                m_fRSOP;
};

class CResultPane :
    public IComponent,
    public IExtendContextMenu,
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    public IExtendPropertySheet,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
        CResultPane();
        ~CResultPane();

BEGIN_COM_MAP(CResultPane)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
//    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
//    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CResultPane
public:
    void SetIComponentData(CScopePane* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPARAM param); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick);
    HRESULT OnContextHelp(void);
public:
    HRESULT TestForRSOPData(MMC_COOKIE cookie);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

// IExtendContextMenu
public:

    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CScopePane *        m_pScopePane;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode
    HSCOPEITEM          m_hCurrScopeItem;   //the scope item whose elements are
                                            //currently being displayed in the
                                            //result pane

public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane

    int                 m_nSortColumn;
    DWORD               m_dwSortOptions;


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_columns[IDS_LAST_COL - IDS_FIRST_COL];
    CString m_RSOP_columns[IDS_LAST_RSOP_COL - IDS_FIRST_RSOP_COL];

    CString m_szFolderTitle;

    map <UINT, CRSOPInfo> m_RSOPData;
    UINT    m_nIndex ;
};

class CUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CUserComponentDataImpl, &CLSID_Snapin>
{
public:

DECLARE_REGISTRY(CResultPane, _T("FDE.1"), _T("FDE"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CUserComponentDataImpl()
    {
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPUserComponentDataImpl, &CLSID_RSOP_Snapin>
{
public:

DECLARE_REGISTRY(CResultPane, _T("FDE.1"), _T("FDE"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPUserComponentDataImpl()
    {
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

inline void CResultPane::SetIComponentData(CScopePane* pData)
{
    ASSERT(pData);
    ASSERT(m_pScopePane == NULL);
    LPUNKNOWN pUnk = pData->GetMyUnknown();
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    m_pScopePane = dynamic_cast<CScopePane*>(lpcd);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

LRESULT SetPropPageToDeleteOnClose(void * vpsp);

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\ade\xforms.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Xforms.h
//
//  Contents:   modifications (transforms) property sheet
//
//  Classes:    XForms
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CXforms dialog

class CXforms : public CPropertyPage
{
        DECLARE_DYNCREATE(CXforms)

// Construction
public:
        CXforms();
        ~CXforms();

        CXforms ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CXforms)
        enum { IDD = IDD_MODIFICATIONS };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fModified;
        CScopePane * m_pScopePane;
        BOOL            m_fPreDeploy;
        CString         m_szInitialPackageName;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CXforms)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        void RefreshData();
        // Generated message map functions
        //{{AFX_MSG(CXforms)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\error.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    error.cxx

Abstract:

    Contains error reporting routines. All functions are fairly straightforward

Author:

    Rahul Thombre (RahulTh) 4/12/1998

Revision History:

    4/12/1998   RahulTh         Created this module.
    10/1/1998   RahulTh         Massive changes to the error reporting mechanism
                                now better and more convenient

--*/

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Member:     CError::ConstructMessage
//
//  Synopsis:   this is an internal helper function that constructs a message
//              from the available error codes it is called by both ShowMessage
//              and ShowConsoleMessage
//
//  Arguments:  [in] argList : the va_list of arguments
//              [out] szErrMsg : the formatted error message
//
//  Returns:    nothing
//
//  History:    10/2/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::ConstructMessage (va_list argList, CString& szErrMsg)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    TCHAR   lpszMessage[2048];

    szErrMsg.LoadString (m_msgID);

    HRESULT hr;

    hr = StringCchVPrintf (lpszMessage, sizeof(lpszMessage)/sizeof(lpszMessage[0]), (LPCTSTR) szErrMsg, argList);
    if (FAILED(hr)) 
    {
        szErrMsg = L"";
        return;
    }

    szErrMsg = lpszMessage;

    if (ERROR_SUCCESS != m_winErr)
    {
        LPVOID lpMsgBuf;
        DWORD dwRet;
        dwRet = ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,
                                 m_winErr,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR) &lpMsgBuf,
                                 0,
                                 NULL
                               );
        if (dwRet)
        {
            szErrMsg += TEXT("\n\n");
            szErrMsg += (LPCTSTR) lpMsgBuf;
            LocalFree (lpMsgBuf);
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::SetTitle
//
//  Synopsis:   sets the value of the member that determines the title of the
//              message box.
//
//  Arguments:  titleID : the resource id of the title.
//
//  Returns:    nothing
//
//  History:    4/12/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetTitle (UINT titleID)
{
    m_titleID = titleID;
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::SetStyle
//
//  Synopsis:   sets the value of the member that determines the message
//              box style.
//
//  Arguments:  nStyle : the message box style.
//
//  Returns:    nothing
//
//  History:    4/12/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetStyle (UINT nStyle)
{
    m_nStyle = nStyle;
}

//+--------------------------------------------------------------------------
//
//  Member:    CError::SetError
//
//  Synopsis:  sets the value of the member that stores the windows error
//             encountered if any.
//
//  Arguments: dwWinError : the value of the windows error encountered
//
//  Returns:   nothing
//
//  History:   12/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetError (DWORD dwWinError)
{
   m_winErr = dwWinError;
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::ShowMessage
//
//  Synopsis:   displays an error message in a message box based on the
//              members of the object
//
//  Arguments:  message id for the error + more
//
//  Returns:    the return value of the message box
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      if the resultant message is longer than 2048 characters
//              then result is unpredictable and may also cause AVs.
//              but this is a limitation of wvsprintf. However, this is not
//              so bad since we can make sure that we do not have any error
//              message that exceed this self imposed limit
//
//---------------------------------------------------------------------------
int CError::ShowMessage (UINT errID, ...)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    va_list argList;
    CString szErrMsg;
    CString szTitle;

    m_msgID = errID;    //update the message ID with the new one

    szTitle.LoadString (m_titleID);

    va_start (argList, errID);
    ConstructMessage (argList, szErrMsg);
    va_end (argList);

    return ::MessageBox (m_hWndParent, (LPCTSTR)szErrMsg,
                         (LPCTSTR) szTitle, m_nStyle);
}

//+--------------------------------------------------------------------------
//
//  Member:     ShowConsoleMessage
//
//  Synopsis:   displays a message using MMC's IConsole interface
//
//  Arguments:  [in] pConsole : pointer to IConsole interface
//              [in] errID : error resource ID
//              + other codes
//
//  Returns:    return value of the message box
//
//  History:    10/2/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
int CError::ShowConsoleMessage (LPCONSOLE pConsole, UINT errID, ...)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    va_list argList;
    CString szErrMsg;
    CString szTitle;
    int     iRet;

    m_msgID = errID;

    szTitle.LoadString (m_titleID);

    va_start(argList, errID);
    ConstructMessage (argList, szErrMsg);
    va_end (argList);

    pConsole->MessageBox ((LPCTSTR)szErrMsg, (LPCTSTR) szTitle, m_nStyle,
                          &iRet);

    return iRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   _DbgMsg
//
//  Synopsis:   function that sends messages to the debugger
//
//  Arguments:  format string + more
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      Do not try to print debug messages longer than 2048 characters.
//
//---------------------------------------------------------------------------
void _DbgMsg (LPCTSTR szFormat ...)
{
    CString cszFormat;
    va_list argList;
    //do not try to print debug messages longer than 2048 characters.
    TCHAR lpszMessage[2048];
    CTime theTime = CTime::GetCurrentTime();

    va_start (argList, szFormat);
    (void) StringCchVPrintf (lpszMessage, sizeof(lpszMessage)/sizeof(lpszMessage[0]), szFormat, argList);
    va_end(argList);

    cszFormat =  ((TEXT("FDE.DLL@") + theTime.Format(TEXT("[%x, %X]>> "))) + lpszMessage) + '\n';

    OutputDebugString ((LPCTSTR)cszFormat);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\dataobj.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.h
//
//  Contents:   implementation of IDataObject for the snapin objects
//
//  Classes:    CDataObject
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CResultPane;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal;

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type)
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetID (long ID) { m_internal.m_scopeID = ID; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.cpp
//
//  Contents:   implementation of IDataObject
//
//  Classes:    CDataObject
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\path.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    path.cxx

Abstract:
    Implementation of the methods in the CRedirPath class. This class
    parses a path and breaks it up into different components and categorizes
    it into one of the well known paths:
        (a) a path in the local user profile location
        (b) a path in the user's home directory
        (c) a specific user specified path
        (d) a per-user path in a user specified location

Author:

    Rahul Thombre (RahulTh) 3/3/2000

Revision History:

    3/3/2000    RahulTh         Created this module.

--*/

#include "precomp.hxx"

CRedirPath::CRedirPath(UINT cookie) : _bDataValid (FALSE), _cookie(cookie)
{
    _szPrefix.Empty();
    _szSuffix.Empty();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::GeneratePath
//
//  Synopsis:   Generate the full path from the components
//
//  Arguments:  [out] szPath : the generated path
//              [in, optional] szUser : sample username
//
//  Returns:    TRUE : if the generated path is valid.
//              FALSE: if there is no valid path stored in this object. In
//                     this case szPath is set to an empty string.
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:      For per user paths, this function uses a sample username
//              if supplied, otherwise, it uses the username variable
//              string %username%
//
//---------------------------------------------------------------------------
BOOL CRedirPath::GeneratePath (OUT CString & szPath,
                               OPTIONAL IN const CString & szUser //= USERNAME_STR
                               ) const
{
    BOOL    bStatus;

    if (! _bDataValid)
        return FALSE;

    szPath = L"";
    bStatus = TRUE;
    switch (_type)
    {
    case IDS_SPECIFIC_PATH:
        szPath = _szPrefix;
        if (! IsValidPrefix (_type, (LPCTSTR) _szPrefix))
            bStatus = FALSE;
        break;
    case IDS_HOMEDIR_PATH:
        szPath = HOMEDIR_STR;
        if (!_szSuffix.IsEmpty())
            szPath += _szSuffix;
        bStatus = TRUE;
        break;
    case IDS_PERUSER_PATH:
        if (_szPrefix.IsEmpty() ||
            ! IsValidPrefix (_type, (LPCTSTR) _szPrefix))
        {
            bStatus = FALSE;
        }
        else
        {
            szPath = (_szPrefix + L'\\') + szUser;
            if (! _szSuffix.IsEmpty())
                szPath += _szSuffix;
            bStatus = TRUE;
        }
        break;
    case IDS_USERPROFILE_PATH:
        if (_szSuffix.IsEmpty())
        {
            bStatus = FALSE;
        }
        else
        {
            szPath = PROFILE_STR + _szSuffix;
            bStatus = TRUE;
        }
        break;
    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::GenerateSuffix
//
//  Synopsis:   generates a new suffix based on a given path type and folder
//
//  Arguments:  [out]   szSuffix
//              [in]    cookie
//              [in]    pathType
//
//  Returns:
//
//  History:    3/7/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirPath::GenerateSuffix (OUT    CString &   szSuffix,
                                 IN     UINT        cookie,
                                 IN     UINT        pathType
                                 ) const
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    szSuffix.Empty();

    if (IDS_HOMEDIR_PATH == pathType)
        return;

    if (IDS_MYPICS == cookie)
	{
		//
		// Use the full My Documents\My Pictures path
		// only if we are going to the user profile.
		// Otherwise stick to vanilla My Pictures
		// This ensures that when My Pictures is redirected independently
		// to another location, we do not create an extra level of folders
		// as this might cause security problems for MyDocs if they are 
		// also redirected to the same share.
		//
		if (IDS_USERPROFILE_PATH == pathType)
			szSuffix.LoadString (IDS_MYPICS_RELPATH);
		else
			szSuffix.LoadString (IDS_MYPICS);
	}
    else
        szSuffix.LoadString (cookie);

    // Precede it with a "\"
    szSuffix = L'\\' + szSuffix;

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::Load
//
//  Synopsis:   parses a given path and breaks it into different components
//              so that it can be categorized into one of the well known
//              types
//
//  Arguments:  [in] szPath : the given full path
//
//  Returns:    TRUE: if the categorization was succesful.
//              FALSE otherwise
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirPath::Load (IN LPCTSTR pwszPath)
{
    CString     szPath;
    BOOL        bStatus = FALSE;

    szPath = pwszPath;
    szPath.TrimLeft();
    szPath.TrimRight();
    szPath.TrimRight (L'\\');

    // First check to see if it is a homedir path.
    bStatus = this->LoadHomedir ((LPCTSTR)szPath);

    // If not, try per-user
    if (!bStatus)
        bStatus = this->LoadPerUser ((LPCTSTR) szPath);

    // If not, try local userprofile
    if (!bStatus)
        bStatus = this->LoadUserprofile ((LPCTSTR) szPath);

    //
    // If not try a user defined path.
    // Note: we cannot use the value blindly here because we need to
    // make sure that there are no environment variables in there.
    //
    if (!bStatus)
        bStatus = this->LoadSpecific ((LPCTSTR) szPath);

    return bStatus;
}

// Determines if a valid path is stored in this object.
BOOL CRedirPath::IsPathValid (void) const
{
    return _bDataValid;
}

//
// Determines if the supplied path is different from the path stored in the
// object. Note: the suffix is immaterial in these comparisons.
//
BOOL CRedirPath::IsPathDifferent (IN UINT type, IN LPCTSTR pwszPrefix) const
{
    CString     szPrefix;

    // Make sure that a path has been loaded in this object first.
    if (! _bDataValid)
        return TRUE;

    // If the types of the paths aren't the same, tnen the paths surely aren't
    if (type != _type)
        return TRUE;

    // If we are here, the types of the path are the same

    //
    // Comparing the prefix does not make sense for a homedir path or
    // a userprofile path
    //
    if (IDS_USERPROFILE_PATH == type ||
        IDS_HOMEDIR_PATH == type)
    {
        return FALSE;
    }

    szPrefix = pwszPrefix;
    szPrefix.TrimLeft();
    szPrefix.TrimRight();
    szPrefix.TrimRight (L'\\');
    if (szPrefix != _szPrefix)
        return TRUE;
    else
        return FALSE;
}

// parse the path to see if it is a homedir path
BOOL CRedirPath::LoadHomedir (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    int     len, lenHomedir;

    // Only the My Documents folder is allowed to have a homedir path
    if (IDS_MYDOCS != _cookie)
        return FALSE;

    len = lstrlen (pwszPath);
    lenHomedir = lstrlen (HOMEDIR_STR);

    if (lenHomedir <= len &&
        0 == _wcsnicmp (pwszPath, HOMEDIR_STR, lenHomedir) &&
        (L'\0' == pwszPath[lenHomedir] || L'\\' == pwszPath[lenHomedir]) &&
        NULL == wcsstr (&pwszPath[lenHomedir], L"%")    // Variables are not allowed anywhere else
        )
    {
        bStatus = TRUE;
        _type = IDS_HOMEDIR_PATH;
        _szPrefix.Empty();
        _szSuffix = &pwszPath[lenHomedir];
    }

    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a per-user path
BOOL CRedirPath::LoadPerUser (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    WCHAR * pwszPos = NULL;
    int     lenUsername, len;

    // Start menu is not allowed to have a per user path.
    if (IDS_STARTMENU == _cookie)
        return FALSE;

    pwszPos = wcsstr (pwszPath, L"%");

    if (pwszPos)
    {
        *pwszPos = L'\0';   // Temporarily look at only the prefix.
        if (!IsValidPrefix (IDS_PERUSER_PATH, pwszPath))
        {
            *pwszPos = L'%';    // Reset the character at pwszPos
            goto LoadPerUser_End;
        }
        else
        {
            *pwszPos = L'%';    // Reset the character at pwszPos
        }
    }

    //
    // %username% should be the first variable that appears in the path
    // if this is to be a per-user path, but it should not be the first
    // thing in the path
    //
    if (NULL != pwszPos && pwszPos != pwszPath)
    {
        len = lstrlen (pwszPos);
        lenUsername = lstrlen (USERNAME_STR);
        if (lenUsername <= len &&
            0 == _wcsnicmp (pwszPos, USERNAME_STR, lenUsername) &&
            NULL == wcsstr (&pwszPos[lenUsername], L"%")
            )
        {
            bStatus = TRUE;
            _type = IDS_PERUSER_PATH;
            _szPrefix = pwszPath;
            _szPrefix = _szPrefix.Left (pwszPos - pwszPath);
            _szPrefix.TrimLeft();
            _szPrefix.TrimRight();
            _szPrefix.TrimRight(L'\\');
            _szSuffix = &pwszPos[lenUsername];
        }
    }

LoadPerUser_End:
    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a userprofile path
BOOL CRedirPath::LoadUserprofile (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    int     len, lenUserprofile;

    len = lstrlen (pwszPath);
    lenUserprofile = lstrlen (PROFILE_STR);

	//
	// Note: it is considered a userprofile path only if it is of the form
	// %userprofile%\<name> where <name> does not contain any variables
	//
    if (lenUserprofile + 1 < len &&
        0 == _wcsnicmp (pwszPath, PROFILE_STR, lenUserprofile) &&
        (L'\0' == pwszPath[lenUserprofile] || L'\\' == pwszPath[lenUserprofile]) &&
        NULL == wcsstr (&pwszPath[lenUserprofile], L"%")
        )
    {
        bStatus = TRUE;
        _type = IDS_USERPROFILE_PATH;
        _szPrefix.Empty();
        _szSuffix = &pwszPath[lenUserprofile];
    }

    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a specific path provided by the user
BOOL CRedirPath::LoadSpecific (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;

    // We pretty much allow all paths other than empty paths.

    if (NULL != pwszPath && L'\0' != *pwszPath)
    {
        bStatus = TRUE;
        _type = IDS_SPECIFIC_PATH;
        _szPrefix = pwszPath;
        _szPrefix.TrimLeft();
        _szPrefix.TrimRight();
        _szPrefix.TrimRight(L'\\');
		// use X:\ rather than X: to make sure client does not fail
		if (2 == _szPrefix.GetLength() && L':' == ((LPCTSTR)_szPrefix)[1])
			_szPrefix += L'\\';
        _szSuffix.Empty();
    }

    _bDataValid = bStatus;
    return bStatus;
}

//
// Validates the arguments and loads the path into the object.
// The existing object is not modified if the data is invalid
//
BOOL CRedirPath::Load (UINT type, LPCTSTR pwszPrefix, LPCTSTR pwszSuffix)
{
    CString szPrefix;
    CString szSuffix;

    // First process the strings.
    szPrefix = pwszPrefix;
    szPrefix.TrimLeft();
    szPrefix.TrimRight();
    szPrefix.TrimRight(L'\\');

    szSuffix = pwszSuffix;
    szSuffix.TrimLeft();
    szSuffix.TrimRight();
    szSuffix.TrimRight(L'\\');

    //
    // The suffix should never have a variable name in it, except
    // IDS_SPECIFIC_PATH, for which a suffix really does not make
    // much sense.
    //
    if (IDS_SPECIFIC_PATH != type &&
        -1 != szSuffix.Find (L'%'))
    {
        return FALSE;
    }

    // Now do the remaining validation on the type and the suffix.
    switch (type)
    {
    case IDS_PERUSER_PATH:
        if (szPrefix.IsEmpty() ||
            ! IsValidPrefix (type, (LPCTSTR) szPrefix))
            return FALSE;
        break;
    case IDS_SPECIFIC_PATH:
        if (!IsValidPrefix (type, (LPCTSTR) szPrefix))
            return FALSE;
		// use X:\ rather than X: to make sure client does not fail.
		if (2 == szPrefix.GetLength() && L':' == ((LPCTSTR)szPrefix)[1])
			szPrefix += L'\\';
        szSuffix.Empty();   // The entire path is in the prefix. Suffix does not make sense here.
        break;
    case IDS_USERPROFILE_PATH:
    case IDS_HOMEDIR_PATH:
        szPrefix.Empty();   // The prefix does not make sense for these paths
        break;
    default:
        return FALSE;
        break;
    }

    //
    // If we are here, the data is okay. So populate the members.
    // Note: It is okay for the suffix to be an empty string.
    //
    _bDataValid = TRUE;
    _type = type;
    _szPrefix = szPrefix;
    _szSuffix = szSuffix;

    return TRUE;
}

void CRedirPath::GetPrefix (OUT CString & szPrefix) const
{
    if (_bDataValid)
        szPrefix = _szPrefix;
    else
        szPrefix.Empty();
}

UINT CRedirPath::GetType (void) const
{
    return _type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\helparr.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    HelpArr.h

Abstract:

    #defines for context sensitive help.


Author:

    Rahul Thombre (RahulTh) 2/3/1999

Revision History:

    2/3/1999    RahulTh         Created this module.

--*/

#ifndef __HELPARR_H__
#define __HELPARR_H__

//help id for controls that don't have context sensitive help
#define     IDH_DISABLEHELP         ((DWORD) -1)

//help ids for controls on IDD_REDIRECT
#define     IDH_REDIR_CHOICE        2001
#define     IDH_LIST_ADVANCED       2004
#define     IDH_BTNADD              2005
#define     IDH_BTNEDIT             2006
#define     IDH_BTNREMOVE           2007

// Help IDs for controls in IDD_PATHCHOOSER
#define     IDH_ROOT_PATH           2002
#define     IDH_BROWSE              2003
#define     IDH_DESTTYPE            2008

//help ids for controls on IDD_SECPATH
#define     IDH_EDIT_SECGROUP       2101
#define     IDH_BROWSE_SECGROUP     2102

//help ids for controls on IDD_REDIRMETHOD
#define     IDH_PREF_APPLYSECURITY  2201
#define     IDH_PREF_MOVE           2202
#define     IDH_PREF_ORPHAN         2203
#define     IDH_PREF_RELOCATE       2204
#define     IDH_PREF_CHANGEMYPICS   2205
#define     IDH_PREF_LEAVEMYPICS    2206


#endif  //__HELPARR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\prefs.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    prefs.cxx

Abstract:
    Code for the property page that is used to obtaining the redirection
    preferences e.g. Move Contents, Apply ACLs,... etc.


Author:

    Rahul Thombre (RahulTh) 11/8/1998

Notes:

Revision History:

    11/8/1998   RahulTh         Created this module.
    1/26/1999   RahulTh         converted the dialog into a property page

--*/


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//mapping between help ids and control ids for context sensitive help
//
const DWORD g_aHelpIDMap_IDD_REDIRMETHOD[] =
{
    IDC_PREF_ICON,          IDH_DISABLEHELP,
    IDC_PREF_TITLE,         IDH_DISABLEHELP,
    IDC_PREF_APPLYSECURITY, IDH_PREF_APPLYSECURITY,
    IDC_PREF_MOVE,          IDH_PREF_MOVE,
    IDC_GROUP_ORPHAN,       IDH_DISABLEHELP,
    IDC_PREF_ORPHAN,        IDH_PREF_ORPHAN,
    IDC_PREF_RELOCATE,      IDH_PREF_RELOCATE,
    IDC_PREF_MYPICS_GROUP,  IDH_DISABLEHELP,
    IDC_PREF_CHANGEMYPICS,  IDH_PREF_CHANGEMYPICS,
    IDC_PREF_LEAVEMYPICS,   IDH_PREF_LEAVEMYPICS,
    0,                      0
};

/////////////////////////////////////////////////////////////////////////////
// CRedirPref property page


CRedirPref::CRedirPref()
    : CPropertyPage (CRedirPref::IDD)
{
    //{{AFX_DATA_INIT(CRedirPref)
    m_szFolderName.Empty();
    m_fInitialized = FALSE;
    m_fMyPicsValid = FALSE;
    m_fMyPicsFollows = TRUE;
    m_fSettingsChanged = FALSE;
    //}}AFX_DATA_INIT

    //m_ppThis and m_pFileInfo are set immediately after creation in CScopePane routines
}

CRedirPref::~CRedirPref()
{
    //reset the pointer to this property page from its corresponding
    //CFileInfo object so that it know that it is gone.
    *m_ppThis = NULL;
    //reset the settings initialized member since this page is being destroyed
    m_fInitialized = m_pFileInfo->m_bSettingsInitialized = FALSE;
}

void CRedirPref::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRedirPref)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Control (pDX, IDC_PREF_TITLE, m_csTitle);
    DDX_Control (pDX, IDC_PREF_MOVE, m_cbMoveContents);
    DDX_Control (pDX, IDC_PREF_APPLYSECURITY, m_cbApplySecurity);
    DDX_Control (pDX, IDC_GROUP_ORPHAN, m_grOrphan);
    DDX_Control (pDX, IDC_PREF_ORPHAN, m_rbOrphan);
    DDX_Control (pDX, IDC_PREF_RELOCATE, m_rbRelocate);
    DDX_Control (pDX, IDC_PREF_MYPICS_GROUP, m_grMyPics);
    DDX_Control (pDX, IDC_PREF_CHANGEMYPICS, m_rbFollowMyDocs);
    DDX_Control (pDX, IDC_PREF_LEAVEMYPICS, m_rbNoModify);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRedirPref, CPropertyPage)
    //{{AFX_MSG_MAP(CRedirPref)
    ON_BN_CLICKED (IDC_PREF_MOVE, OnModify)
    ON_BN_CLICKED (IDC_PREF_APPLYSECURITY, OnModify)
    ON_BN_CLICKED (IDC_PREF_ORPHAN, OnModify)
    ON_BN_CLICKED (IDC_PREF_RELOCATE, OnModify)
    ON_BN_CLICKED (IDC_PREF_CHANGEMYPICS, OnMyPicsChange)
    ON_BN_CLICKED (IDC_PREF_LEAVEMYPICS, OnMyPicsChange)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRedirPref message handlers

BOOL CRedirPref::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    RECT        rc;
    RECT        rcDlg;
    int         top, height;
    CString     szFormat;
    CString     szText;

    CPropertyPage::OnInitDialog();

    //tell the other property pages that InitDialog has been received.
    m_fInitialized = m_pFileInfo->m_bSettingsInitialized = TRUE;

    //get the display name
    m_szFolderName = m_pFileInfo->m_szDisplayname;

    //set the right text in the check boxes etc.
    szFormat.LoadString (IDS_PREF_TITLE);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_csTitle.SetWindowText (szText);

    szFormat.LoadString (IDS_PREF_APPLYSECURITY);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_cbApplySecurity.SetWindowText (szText);

    szFormat.LoadString (IDS_PREF_MOVE);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_cbMoveContents.SetWindowText (szText);

   return TRUE; //return TRUE unless you set focus to a control.
}

BOOL CRedirPref::OnSetActive ()
{
    BOOL    bRet;
    CRedirect * pPage = NULL;

    bRet = CPropertyPage::OnSetActive();
    pPage = m_pFileInfo->m_pRedirPage;

    switch (pPage->m_iCurrChoice + pPage->m_iChoiceStart)
    {
    case IDS_DONT_CARE:
    case IDS_FOLLOW_PARENT:
        DisableSettings();
        break;
    case IDS_SCALEABLE:
        if (pPage->m_lstSecGroups.GetItemCount())
            EnableSettings();
        else
            DisableSettings();
        break;
    default:
        EnableSettings();
        break;
    }

    return bRet;
}

void CRedirPref::EnablePage (BOOL bEnable /* = TRUE*/)
{
    //enable or disable the contents of a page depending on whether
    if (!m_fInitialized)
        return;

    if (bEnable)
        EnableSettings();
    else
        DisableSettings();
}

void CRedirPref::DisableSettings(void)
{
    //since the settings are being disabled, the modifications in the
    //settings (if any) obviously have no significance.
    SetModified (FALSE);

    //disable all the options on this page... also uncheck all of them.
    m_csTitle.EnableWindow (FALSE);

    m_cbMoveContents.SetCheck(0);
    m_cbMoveContents.EnableWindow(FALSE);

    m_cbApplySecurity.SetCheck (0);
    m_cbApplySecurity.EnableWindow (FALSE);

    m_grOrphan.EnableWindow (FALSE);
    m_rbOrphan.SetCheck(0);
    m_rbOrphan.EnableWindow (FALSE);
    m_rbRelocate.SetCheck (0);
    m_rbRelocate.EnableWindow (FALSE);

    EnableMyPicsSettings (FALSE);

    return;
}

void CRedirPref::EnableMyPicsSettings (BOOL bEnable /* = TRUE*/)
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //my pics preferences are shown only in the tab for my documents
    if (IDS_MYDOCS != m_pFileInfo->m_cookie)
    {
        m_grMyPics.ShowWindow (SW_HIDE);
        m_rbFollowMyDocs.ShowWindow (SW_HIDE);
        m_rbNoModify.ShowWindow (SW_HIDE);
        return;
    }

    //this is the my docs folder
    m_grMyPics.ShowWindow (SW_SHOW);
    m_rbNoModify.ShowWindow (SW_SHOW);
    m_rbFollowMyDocs.ShowWindow (SW_SHOW);

    LONG index = pPage->m_iCurrChoice + pPage->m_iChoiceStart - IDS_CHILD_REDIR_START;
    if (bEnable &&
        pPage->m_fEnableMyPics &&
        pPage->m_fSettingModified [index])
    {
        m_grMyPics.EnableWindow ();
        m_rbFollowMyDocs.EnableWindow ();
        m_rbNoModify.EnableWindow ();

        if (m_fMyPicsValid)
        {
            m_rbFollowMyDocs.SetCheck (m_fMyPicsFollows ? 1 : 0);
            m_rbNoModify.SetCheck (m_fMyPicsFollows ? 0 : 1);
        }
        else    //set defaults as the setting
        {
            m_rbFollowMyDocs.SetCheck (1);
            m_rbNoModify.SetCheck (0);
            m_fMyPicsFollows = TRUE;
            m_fMyPicsValid = TRUE;
        }
    }
    else
    {
        m_grMyPics.EnableWindow (FALSE);

        //even when disabled, show the current status of My Pictures as far
        //as possible. The only situation when both the radio buttons should
        //be unchecked is when My Pics is getting redirected independently.

        m_rbFollowMyDocs.EnableWindow (FALSE);
        m_rbFollowMyDocs.SetCheck ((REDIR_FOLLOW_PARENT == pPage->m_dwMyPicsCurr) ? 1 : 0);

        m_rbNoModify.EnableWindow (FALSE);
        m_rbNoModify.SetCheck ((REDIR_DONT_CARE == pPage->m_dwMyPicsCurr) ? 1 : 0);
    }
}

void CRedirPref::EnableSettings (void)
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //the page is being enabled. If the settings had been modified earlier,
    //we need to make sure that the modified state indicates that.
    SetModified (m_fSettingsChanged);

    //enables applicable settings
    m_csTitle.EnableWindow (TRUE);

    if (IDS_STARTMENU == pPage->m_cookie)
    {
        m_cbMoveContents.EnableWindow (FALSE);
        m_cbMoveContents.SetCheck (0);

        m_cbApplySecurity.EnableWindow (FALSE);
        m_cbApplySecurity.SetCheck (0);
    }
    else
    {
        m_cbApplySecurity.EnableWindow ();
        m_cbMoveContents.EnableWindow ();
        if (pPage->m_fValidFlags)
        {
            m_cbApplySecurity.SetCheck ((pPage->m_dwFlags & REDIR_SETACLS)?1:0);
            m_cbMoveContents.SetCheck ((pPage->m_dwFlags & REDIR_MOVE_CONTENTS)? 1 : 0);
        }
        else
        {
            m_cbApplySecurity.SetCheck (1);
            m_cbMoveContents.SetCheck (1);
        }
    }

    m_grOrphan.EnableWindow ();
    m_rbOrphan.EnableWindow();
    m_rbRelocate.EnableWindow ();
    if (pPage->m_fValidFlags)
    {
        m_rbRelocate.SetCheck ((pPage->m_dwFlags & REDIR_RELOCATEONREMOVE)?1:0);
        m_rbOrphan.SetCheck ((pPage->m_dwFlags & REDIR_RELOCATEONREMOVE)?0:1);
    }
    else
    {
        m_rbOrphan.SetCheck (1);
        m_rbRelocate.SetCheck (0);
    }

    //enable my pics preferences for the My Docs folder
    EnableMyPicsSettings ();
    return;
}

void CRedirPref::OnModify()
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //modify the flags
    if (m_cbMoveContents.GetCheck())
        pPage->m_dwFlags |= REDIR_MOVE_CONTENTS;
    else
        pPage->m_dwFlags &= ~REDIR_MOVE_CONTENTS;

    if (m_cbApplySecurity.GetCheck())
        pPage->m_dwFlags |= REDIR_SETACLS;
    else
        pPage->m_dwFlags &= ~REDIR_SETACLS;

    if (m_rbRelocate.GetCheck())
        pPage->m_dwFlags |= REDIR_RELOCATEONREMOVE;
    else
        pPage->m_dwFlags &= ~REDIR_RELOCATEONREMOVE;

    //the flag now contains valid values
    pPage->m_fValidFlags = TRUE;

    DirtyPage (TRUE);
}

void CRedirPref::OnMyPicsChange()
{
    m_fMyPicsValid = TRUE;
    m_fMyPicsFollows = m_rbFollowMyDocs.GetCheck();

    DirtyPage(TRUE);
}

void CRedirPref::DirtyPage (BOOL fModified)
{
    m_fSettingsChanged = fModified;

    SetModified (fModified);
}

LONG CRedirPref::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_REDIRMETHOD);

    return lResult;
}

LONG CRedirPref::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_REDIRMETHOD);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\fileinfo.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1994 - 1998.

Module Name:

    FileInfo.cxx

Abstract:

    This file contains the methods of the class CFileInfo. This is the class
    of objects that are used by the code to keep track of files/folders that
    are displayed in the MMC snapin.

Author:

    Rahul Thombre (RahulTh) 4/5/1998

Revision History:

    4/5/1998    RahulTh         Created this module.
    6/22/1998   RahulTh         added comments.

--*/


#include "precomp.hxx"

//static members
UINT CFileInfo::class_res_id = IDS_DIRS_START; //since we have an array of structures for the folders
                                               //in the same order as the resource ids of their names
                                               //we can use this static member to figure out the cookie
                                               //for each folder in the constructor. This ensures
                                               //that the default flags are set properly

WCHAR * g_szEnglishNames [] =
{
    L"Application Data",
    L"Desktop",
    L"My Documents",
    L"Start Menu",
    L"My Pictures",
    L"Programs",
    L"Startup"
};

//////////////////////////////////////////////
// Construction
//
// initializes the members of this class to some default values
//////////////////////////////////////////////
CFileInfo::CFileInfo(LPCTSTR lpszFullPathname /*= NULL*/
                     )
{
    m_pRedirPage = NULL;
    m_pSettingsPage = NULL;
    m_bSettingsInitialized = FALSE;
    m_bHideChildren = TRUE;
    Initialize (class_res_id,  //use a random cookie for the time being
                NULL    //for now, we use a null path for the file root.
                );
    class_res_id++;
}

/////////////////////////////////////
// Destruction
//
CFileInfo::~CFileInfo()
{
    //clean up here... if there is anything to clean up in this class
    DeleteAllItems();
}

/////////////////////////////////////////////////////////////
// this routine set the scope item id for the node in its object
//
void CFileInfo::SetScopeItemID (IN LONG scopeID)
{
    m_scopeID = scopeID;
}

/////////////////////////////////////////////////////////////
// this routine sets the default values on most of the members of this class
//
void CFileInfo::Initialize (long cookie, LPCTSTR szGPTPath)
{
    SHFILEINFO fileInfo;
    CString szTmp;
    CString szExt;
    LONG    i;

    i = GETINDEX (cookie);

    //set the cookie
    m_cookie = cookie;

    //set the file root
    if (szGPTPath)
        m_szFileRoot = szGPTPath;
    else
        m_szFileRoot.Empty();

    //set the name and type.
    m_szDisplayname = TEXT("???");
    m_szRelativePath = TEXT ("???");
    m_szTypename.LoadString (IDS_FOLDER_TYPE);
    
    if (-1 != i)
    {
        m_szDisplayname.LoadString (m_cookie);
        m_szEnglishDisplayName = g_szEnglishNames[i];
        m_szTypename.LoadString (IDS_FOLDER_TYPE);
        m_dwFlags = REDIR_DONT_CARE;
        switch (m_cookie)
        {
        case IDS_MYPICS:
            m_szRelativePath.LoadString (IDS_MYPICS_RELPATH);
            break;
        case IDS_PROGRAMS:
            m_szRelativePath.LoadString (IDS_PROGRAMS_RELPATH);
            break;
        case IDS_STARTUP:
            m_szRelativePath.LoadString (IDS_STARTUP_RELPATH);
            break;
        default:
            m_szRelativePath = m_szDisplayname;
            break;
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::LoadSection
//
//  Synopsis:   This member function loads the redirection info. for this
//              folder from the ini file
//
//  Arguments:  none
//
//  Returns:    S_OK : if the section was loaded successfully
//              or other error codes
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT CFileInfo::LoadSection (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    i;
    BOOL    bStatus;
    DWORD   Status;
    const TCHAR lpszDefault[] = TEXT("*");  //a random default value
    DWORD   cbSize = 1024;
    DWORD   cbCopied;
    TCHAR*  lpszValue;
    TCHAR*  szEntry;
    CString IniFile;
    CString Value;
    BOOL    bValueFound;
    HRESULT hr;
    CString Pair;
    CString Key;
    CString Val;

    i = GETINDEX (m_cookie);

    if (-1 == i)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto LoadSec_Quit;
    }

    //get the name of the ini file
    IniFile.LoadString (IDS_INIFILE);
    IniFile = m_szFileRoot + '\\' + IniFile;

    m_dwFlags = REDIR_DONT_CARE;    //set the default value
    m_RedirGroups.erase (m_RedirGroups.begin(), m_RedirGroups.end());
    m_RedirPaths.erase (m_RedirPaths.begin(), m_RedirPaths.end());

    //read in the data from the FolderStatus section
    do
    {
        lpszValue = new TCHAR [cbSize];
        //set it to something other than the default value
        lpszValue[0] = '+';
        lpszValue[1] = '\0';
        //now try to read it from the ini file
        cbCopied = GetPrivateProfileString (TEXT("FolderStatus"),
                                            m_szEnglishDisplayName,
                                            lpszDefault,
                                            lpszValue,
                                            cbSize,
                                            (LPCTSTR) IniFile
                                            );
        if ('*' == lpszValue[0])    //the default string was copied, so the key does not exist
        {
            bValueFound = FALSE;
            break;
        }

        if (cbSize - 1 == cbCopied)
        {
            delete [] lpszValue;
            cbSize *= 2;
            continue;
        }

        bValueFound = TRUE;
        break;
    } while (TRUE);

    if (!bValueFound)
    {
        hr = S_OK;
        goto LoadSec_CleanupAndQuit;
    }

    Value = lpszValue;
    Value.TrimLeft();
    Value.TrimRight();

    int iRetVal;

    iRetVal = swscanf ((LPCTSTR) Value, TEXT("%x"), &m_dwFlags);
    if (0 == iRetVal || EOF == iRetVal ) 
    {
        hr = E_INVALIDARG;
        goto LoadSec_CleanupAndQuit;
    }

    if ((m_dwFlags & REDIR_DONT_CARE) || (m_dwFlags & REDIR_FOLLOW_PARENT))
    {
        hr = S_OK;
        goto LoadSec_CleanupAndQuit;
    }

    //if we are here, there is more redirection path info. to be read off
    //of the ini file
    //so we first load the section
    do
    {
        cbCopied = GetPrivateProfileSection ((LPCTSTR) m_szEnglishDisplayName,
                                             lpszValue,
                                             cbSize,
                                             (LPCTSTR) IniFile
                                             );
        if (cbSize - 2 == cbCopied)
        {
            delete [] lpszValue;
            cbSize *= 2;
            lpszValue = new TCHAR [cbSize];
            continue;
        }

        break;
    } while (TRUE);

    //we now have the other section too.
    for (szEntry = lpszValue; *szEntry; szEntry += (lstrlen(szEntry) + 1))
    {
        Pair = szEntry;
        hr = SplitProfileString (Pair, Key, Val);
        Key.MakeLower();    //since CString comparison operator == is case
                            //sensitive
        Insert (Key, Val, FALSE, FALSE);
    }

    hr = S_OK;  //the section has been successfully loaded

LoadSec_CleanupAndQuit:
    delete [] lpszValue;

LoadSec_Quit:
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::SaveSection
//
//  Synopsis:   this function saves the redir info. for the object to
//              the ini file on the sysvol
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS : if we were successful in saving
//              or other error codes
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CFileInfo::SaveSection (void)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    DWORD   cbSize = 1024;
    TCHAR*  lpszSection;
    CString szIniFile;
    CString szVal;
    BOOL    bStatus;
    CFileInfo*  pChildInfo;
    DWORD   Status = ERROR_SUCCESS;

    //derive the name of the ini file
    szIniFile.LoadString (IDS_INIFILE);
    szIniFile = m_szFileRoot + '\\' + szIniFile;

    //create an empty section and write it to the ini file
    //so that the new data can be saved easily
    lpszSection = new TCHAR [cbSize];
    lpszSection[0] = lpszSection [1] = '\0';

    //pre-create the ini file in unicode so that the WritePrivateProfile*
    //APIs do not write in ANSI.
    PrecreateUnicodeIniFile ((LPCTSTR) szIniFile);

    bStatus = WritePrivateProfileSection ((LPCTSTR) m_szEnglishDisplayName,
                                          lpszSection,
                                          (LPCTSTR) szIniFile
                                          );

    //write the data into the FolderStatus section
    if (bStatus)
    {
        szVal.Format (TEXT("%x"), m_dwFlags);
        bStatus = WritePrivateProfileString (TEXT("FolderStatus"),
                                             (LPCTSTR) m_szEnglishDisplayName,
                                             (LPCTSTR) szVal,
                                             szIniFile
                                             );

    }

    if (bStatus)
    {
        for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
             i != m_RedirGroups.end();
             i++, j++)
        {
            bStatus = WritePrivateProfileString ((LPCTSTR) m_szEnglishDisplayName,
                                                 (LPCTSTR) (*i),
                                                 (LPCTSTR) (*j),
                                                 szIniFile
                                                 );
            if (!bStatus)
                break;
        }
    }

    if (!bStatus)
        Status = GetLastError();
    else
        Status = ERROR_SUCCESS;

    delete [] lpszSection;

    return Status;

}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::Insert
//
//  Synopsis:   inserts a key value pair in the redir info structure of the
//              object. also note the description of the parameter fReplace
//
//  Arguments:  [in] szKey : the key
//              [in] szVal : the value
//              [in] fReplace : if FALSE, the key value pair won't be inserted
//                              if another entry with the same key exists
//              [in] fSaveSection : save the section after insertions if true
//
//  Returns:    ERROR_SUCCESS : if the key value pair was inserted
//              ERROR_ALREADY_EXISTS : if the key value pair was not inserted
//                                     since another entry with the same key
//                                     already exists
//              or other error codes that might be encountered while saving
//                 the section
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      to keep the sysvol updated, it also calls SaveSection at the end
//
//---------------------------------------------------------------------------
DWORD CFileInfo::Insert (const CString& szKey, const CString& szVal,
                           BOOL fReplace, BOOL fSaveSection /*= TRUE*/)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    CString     Key;
    CString     Val;
    DWORD       Status = ERROR_SUCCESS;

    Key = szKey;
    Key.MakeLower();
    Val = szVal;

    //in this case, we must first check if an entry exists with that key
    for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
         i != m_RedirGroups.end();
         i++, j++)
    {
        if (Key == *i)
            break;
    }

    if (m_RedirGroups.end() == i)   //we do not have an entry with this key
    {
        m_RedirGroups.push_back(Key);
        m_RedirPaths.push_back (Val);
    }
    else    //we do have an entry that matches the key
    {
        if (fReplace)
            *j = Key;
        else
            Status = ERROR_ALREADY_EXISTS;
    }

    if (ERROR_SUCCESS == Status && fSaveSection)
        Status = SaveSection();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::Delete
//
//  Synopsis:   deletes the entry corresponding to a given key
//
//  Arguments:  [in] szKey : the key that needs to get deleted
//
//  Returns:    ERROR_SUCCESS : if the deletion was successful
//              or other error codes that might be encountered while saving
//              the section (see notes below)
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      to maintain the ini file on the sysvol in sync with the
//              snapin, we save the redir info. at the end of every deletion
//
//---------------------------------------------------------------------------
DWORD CFileInfo::Delete (const CString& szKey, BOOL fSaveSection /*= TRUE*/)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    DWORD   Status = ERROR_SUCCESS;

    for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
         i != m_RedirGroups.end();
         i++, j++)
    {
        if (szKey == *i)
            break;
    }

    if (m_RedirGroups.end() != i)   //an entry with that key was found
    {
        m_RedirGroups.erase(i);
        m_RedirPaths.erase (j);
        if (fSaveSection)
            Status = SaveSection ();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::DeleteAllItems
//
//  Synopsis:   this functions deletes all the group and path information
//              stored in the object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CFileInfo::DeleteAllItems (void)
{
    m_RedirGroups.erase (m_RedirGroups.begin(), m_RedirGroups.end());
    m_RedirPaths.erase (m_RedirPaths.begin(), m_RedirPaths.end());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\pathslct.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    pathslct.cxx

Abstract:
    This module contains the methods and message handlers for the dialog
    that is used to select the redirection destination. This dialog is
    used as a child dialog by both the basic and the advanced settings.

Author:

    Rahul Thombre (RahulTh) 3/1/2000

Revision History:

    3/1/2000    RahulTh         Created this module.

--*/

#include "precomp.hxx"

BEGIN_MESSAGE_MAP (CEditNoVars, CEdit)
    ON_WM_CHAR()
END_MESSAGE_MAP()

//+--------------------------------------------------------------------------
//
//  Member:     CEditNoVars::OnChar
//
//  Synopsis:   Customized edit control behavior. Prevents users from
//              entering variables.
//
//  Arguments:  see MFC documentation
//
//  Returns:    nothing
//
//  History:    3/2/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CEditNoVars::OnChar (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    // Ignore the * symbol. Do not allow users to type it in.
    if ('*' != nChar)
    {
        CEdit::OnChar (nChar, nRepCnt, nFlags);
    }
    else
    {
        // Indicate to the user that % is not permitted in the path.
        ::MessageBeep (-1);
    }
}


// Mapping between control IDs and Help IDs for the path chooser
const DWORD g_aHelpIDMap_IDD_PATHCHOOSER[] =
{
    IDC_DESTTYPE,           IDH_DESTTYPE,
    IDC_ROOT_DESC,          IDH_DISABLEHELP,
    IDC_ROOT_PATH,          IDH_ROOT_PATH,
    IDC_BROWSE,             IDH_BROWSE,
    IDC_SAMPLE_PATH,        IDH_DISABLEHELP,
    0,                      0
};

CPathChooser::CPathChooser(CWnd* pParent /*=NULL*/)
    : CDialog(CPathChooser::IDD, pParent), m_pParent (pParent)
{
    //{{AFX_DATA_INIT(CPathChooser)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_iCurrType = 0;
}

void CPathChooser::GetRoot (CString & szRoot)
{
    m_rootPath.GetWindowText (szRoot);
    szRoot.TrimLeft();
    szRoot.TrimRight();
    szRoot.TrimRight(L'\\');
    // When redirecting to the root of a drive, redirect to X:\ rather than X:
    if (2 == szRoot.GetLength() && L':' == ((LPCTSTR)szRoot)[1])
        szRoot += L'\\';
}

UINT CPathChooser::GetType (void)
{
    return m_iCurrType + m_iTypeStart;
}


void
CPathChooser::Instantiate (IN UINT          cookie,
                           IN CWnd *        pParent,
                           IN CWnd *        pwndInsertAt,
                           IN const CRedirPath *  pRedirPath,
                           IN UINT          nFlags     // = SWP_HIDEWINDOW
                           )
{
    RECT    rc;
    RECT    rc_ctrl;

    //
    // Now initialize the member variables.
    // Note: it is important to set the parent before the making the call to
    // Create so that CPathChooser's OnInitDialog is able to set the right
    // parent. Otherwise, the window positioning won't work as expected.
    //
    m_pParent = pParent;
    m_cookie = cookie;
    m_pRedirPath = pRedirPath;

    // First create the modeless window.
    this->Create (IDD, pParent);

    //
    // Set a limit on the number of characters that can be entered into
    // into the edit control
    //
    m_rootPath.SetLimitText (TARGETPATHLIMIT);

    // Now adjust the dimensions and place the window that the right location.
    pwndInsertAt->ShowWindow (SW_HIDE);
    pwndInsertAt->GetWindowRect (&rc);
    pParent->ScreenToClient (&rc);
    this->SetWindowPos (pwndInsertAt,
                        rc.left,
                        rc.top,
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        nFlags
                        );

    //
    // Now resize and move the controls within this dialog to fit the new size
    // Widen the dest. type combo box.
    //
    m_destType.GetClientRect (&rc_ctrl);
    m_destType.SetWindowPos (NULL,
                             -1,
                             -1,
                             rc.right - rc.left,
                             rc_ctrl.bottom,
                             SWP_NOZORDER | SWP_NOMOVE
                             );
    //
    // Widen the edit control -- set the height to be the same as the
    // combo box above
    //
    m_rootPath.SetWindowPos (NULL,
                             -1,
                             -1,
                             rc.right - rc.left,
                             rc_ctrl.bottom,
                             SWP_NOZORDER | SWP_NOMOVE
                             );

    //
    // Move the browse button so that it is aligned with the right
    // edge of the edit control
    //
    m_rootPath.GetWindowRect (&rc);
    this->ScreenToClient (&rc);
    m_browse.GetWindowRect (&rc_ctrl);
    this->ScreenToClient (&rc_ctrl);
    m_browse.SetWindowPos (NULL,
                           rc_ctrl.left + rc.right - rc_ctrl.right,
                           rc_ctrl.top,
                           -1,
                           -1,
                           SWP_NOZORDER | SWP_NOSIZE
                           );

    //
    // Change the height and width of the static control used to display
    // example per user paths so that it is as wide as the dialog and is
    // aligned with the bottom of the control
    //
    this->GetClientRect (&rc);
    m_peruserPathDesc.GetWindowRect (&rc_ctrl);
    this->ScreenToClient (&rc_ctrl);
    m_iPathDescWidth = rc.right;
    m_peruserPathDesc.SetWindowPos (NULL,
                                    -1,
                                    -1,
                                    m_iPathDescWidth,
                                    rc.bottom - rc_ctrl.top,
                                    SWP_NOZORDER | SWP_NOMOVE
                                    );

    // Load the values into the controls
    PopulateControls ();
}


// Populates the controls based on the values passed into the dialog

void
CPathChooser::PopulateControls (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    i;
    CString szText;

    m_iCurrType = 0;
    switch (m_cookie)
    {
    case IDS_MYDOCS:
        m_iTypeStart = IDS_MYDOCS_DESTTYPE_START;
        break;
    case IDS_STARTMENU:
        m_iTypeStart = IDS_SMENU_DESTTYPE_START;
        break;
    default:
        m_iTypeStart = IDS_DESTTYPE_START;
        break;
    }

    // Now populate the destination type combo box based on the settings
    for (i = m_iTypeStart; i < IDS_DESTTYPE_END; i++)
    {
        szText.LoadString (i);
        m_destType.AddString ((LPCTSTR) szText);
    }

    // Put data in the controls.
    if (m_pRedirPath->IsPathValid())
    {
        m_iCurrType = m_pRedirPath->GetType() - m_iTypeStart;
        m_pRedirPath->GetPrefix (szText);
        m_rootPath.SetWindowText (szText);
        m_rootPath.SetModify (TRUE);
    }
    else
    {
        //
        // Use the first choice for all but the MyDocs folder.
        // because the first choice for MyDocs is the HOMEDIR option
        // and we want to encourage users to specify the path through
        // group policy rather than use the HOMEDIR path set on the user
        // object
        //
        if (IDS_MYDOCS == m_cookie)
            m_iCurrType = IDS_PERUSER_PATH - m_iTypeStart;
        else
            m_iCurrType = 0;
        m_rootPath.SetWindowText (L"");
        m_rootPath.SetModify (TRUE);
    }
    // Set the current type
    m_destType.SetCurSel (m_iCurrType);

    // Make sure that some of the controls are hidden if required
    ShowControls ();

    //
    // Notify the parent that the path has been tweaked so that it can
    // update any controls that on it that might depend on the contents of
    // this dialog
    //
    TweakPathNotify ();

}


void CPathChooser::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPathChooser)
    DDX_Control(pDX, IDC_DESTTYPE, m_destType);
    DDX_Control(pDX, IDC_ROOT_DESC, m_rootDesc);
    DDX_Control(pDX, IDC_ROOT_PATH, m_rootPath);
    DDX_Control(pDX, IDC_SAMPLE_PATH, m_peruserPathDesc);
    DDX_Control(pDX, IDC_BROWSE, m_browse);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPathChooser, CDialog)
    //{{AFX_MSG_MAP(CPathChooser)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_CBN_SELCHANGE (IDC_DESTTYPE, OnDestTypeChange)
    ON_EN_CHANGE (IDC_ROOT_PATH, OnChangeRoot)
    ON_EN_KILLFOCUS (IDC_ROOT_PATH, OnRootKillFocus)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPathChooser message handlers

BOOL CPathChooser::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // Always hide by default. Actual visible state will be determined
    // later in the instantiate method.
    //
    this->ShowWindow (SW_HIDE);
    this->SetParent (m_pParent);

    // Subclass the edit control to modify behavior
    m_rootPath.SubclassDlgItem (IDC_ROOT_PATH, this);


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPathChooser::OnCancel()
{
    DestroyWindow ();
}

void CPathChooser::OnBrowse()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    BROWSEINFO      browseInfo;
    CString         szInstructions;
    TCHAR           pszSelectedFolder[MAX_PATH];
    LPITEMIDLIST    lpItemIDList;
    LPMALLOC        pMalloc;
    CError          error(this);
    DWORD           dwError;
    CString         szSelectedPath;
    CString         szUNC;

    szSelectedPath.Empty();
    szInstructions.LoadString (IDS_FOLDERBROWSE_DESC);

    browseInfo.hwndOwner = m_hWnd;
    browseInfo.pidlRoot = NULL;
    browseInfo.pszDisplayName = pszSelectedFolder;
    browseInfo.lpszTitle = (LPCTSTR)szInstructions;
    browseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
    browseInfo.lpfn = BrowseCallbackProc;
    browseInfo.lParam = (LPARAM) (&szSelectedPath);

    if (NULL != (lpItemIDList = SHBrowseForFolder (&browseInfo)))
    {
        //try to get the path from the item id list
        dwError = GetUNCPath (szSelectedPath, szUNC);
        if (NO_ERROR != dwError)  //then do the best you can
            szUNC = szSelectedPath;

        if (TARGETPATHLIMIT < szUNC.GetLength())
            error.ShowMessage (IDS_PATHTOOLONG_ERROR, TARGETPATHLIMIT);
        else
        {
            m_rootPath.SetWindowText (szUNC);
            m_rootPath.SetModify(TRUE);
            // Notify the parent that the path has been modified
            TweakPathNotify();
        }

        if (SUCCEEDED(SHGetMalloc(&pMalloc)))
        {
            pMalloc->Free (lpItemIDList);
            pMalloc->Release();
        }
    }
}

void CPathChooser::OnDestTypeChange (void)
{
    int     Sel;

    Sel = m_destType.GetCurSel();

    if (Sel == m_iCurrType)
        return;                     // The choice has not changed

    // Update the current choice.
    m_iCurrType = Sel;
    ShowControls();

    // Notify the parent of the change
    TweakPathNotify ();
}

void CPathChooser::ShowControls (void)
{
    int nCmdShow;

    switch (m_iCurrType + m_iTypeStart)
    {
    case IDS_SPECIFIC_PATH:
    case IDS_PERUSER_PATH:
        nCmdShow = SW_SHOW;
        break;
    case IDS_USERPROFILE_PATH:
    case IDS_HOMEDIR_PATH:
        nCmdShow = SW_HIDE;
        break;
    }

    m_browse.ShowWindow (nCmdShow);
    m_rootPath.ShowWindow (nCmdShow);
    m_rootDesc.ShowWindow (nCmdShow);
}

void CPathChooser::OnChangeRoot()
{
    // Notify the parent that the path has changed.
    TweakPathNotify ();
}

void CPathChooser::OnRootKillFocus()
{
    CString     szUNC;
    CString     szCurr;

    m_rootPath.GetWindowText (szCurr);
    szCurr.TrimLeft();
    szCurr.TrimRight();
    szCurr.TrimRight(L'\\');
    if (szCurr.IsEmpty() || PathIsUNC ((LPCTSTR)szCurr))
    {
        return;
    }
    
    if (NO_ERROR == GetUNCPath (szCurr, szUNC))
    {
        if (TARGETPATHLIMIT < szUNC.GetLength())
            return;
    }
    else
    {
        szUNC = szCurr;
    }
    
    //
    // if the path is of the form X: change it to X:\ (so that
    // the redirection at the client does not run into problems
    //
    if (2 == szUNC.GetLength() && L':' == ((LPCTSTR)szUNC)[1])
        szUNC += L'\\';
    
    m_rootPath.SetWindowText (szUNC);
}

LONG CPathChooser::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_PATHCHOOSER);

    return lResult;
}

LONG CPathChooser::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_PATHCHOOSER);

    return lResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathChooser::TweakPathNotify
//
//  Synopsis:   Notifies the parent that the path has been tweaked.
//
//  Arguments:
//
//  Returns:
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void
CPathChooser::TweakPathNotify (void)
{
    LPARAM  lParam;
    WPARAM  wParam;
    CString szRootPath;
    WCHAR   szCompactPath[MAX_PATH];
    static CString szUser = TEXT("");
    static CString szPathDesc = TEXT("");

    lParam = (LPARAM) (m_iCurrType + m_iTypeStart);

    if (-1 == m_iCurrType)
    {
        wParam = (WPARAM) FALSE;
    }
    else
    {
        switch (m_iCurrType + m_iTypeStart)
        {
        case IDS_PERUSER_PATH:
            if (IDS_STARTMENU == m_cookie)
            {
                wParam = (WPARAM) FALSE;
            }
            else
            {
                m_rootPath.GetWindowText (szRootPath);
                szRootPath.TrimLeft();
                szRootPath.TrimRight();
                szRootPath.TrimRight (L'\\');
                if (szRootPath.IsEmpty() ||
                    ! IsValidPrefix (IDS_PERUSER_PATH, (LPCTSTR) szRootPath))
                {
                    wParam = (WPARAM) FALSE;
                    m_peruserPathDesc.ShowWindow (SW_HIDE);
                }
                else
                {
                    wParam = (WPARAM) TRUE;

                    if (szUser.IsEmpty())
                        szUser.LoadString (IDS_SAMPLE_USER);

                    if (szPathDesc.IsEmpty())
                        szPathDesc.LoadString (IDS_SAMPLE_PATHDESC);

                    CString     szTmp;
                    CString     szPath;
                    BOOL        bShowPath;

                    // Check if the path has changed
                    if (m_pRedirPath->IsPathDifferent (IDS_PERUSER_PATH, szRootPath))
                    {
                        CRedirPath  displayPath (m_cookie);
                        displayPath.GenerateSuffix (szTmp, m_cookie, IDS_PERUSER_PATH);
                        bShowPath = displayPath.Load (IDS_PERUSER_PATH, szRootPath, szTmp);
                        if (bShowPath)
                        {
                            bShowPath = displayPath.GeneratePath (szPath, szUser);
                        }
                    }
                    else
                    {
                        bShowPath = m_pRedirPath->GeneratePath (szPath, szUser);
                    }

                    if (bShowPath)
                        bShowPath = (MAX_PATH > szPath.GetLength());

                    if (bShowPath)
                    {
                        HRESULT hr;

                        hr = StringCchCopy (szCompactPath, sizeof(szCompactPath)/sizeof(szCompactPath[0]), (LPCTSTR) szPath);
                        if (FAILED(hr)) 
                        {
                            wParam = FALSE;
                            break;
                        }

                        bShowPath = PathCompactPath (NULL, szCompactPath, m_iPathDescWidth);
                        if (bShowPath)
                            szTmp.Format (szPathDesc, szUser, szCompactPath);
                    }

                    if (bShowPath)
                    {
                        m_peruserPathDesc.SetWindowText (szTmp);
                        m_peruserPathDesc.ShowWindow (SW_SHOW);
                    }
                    else
                    {
                        m_peruserPathDesc.ShowWindow (SW_HIDE);
                    }
                }
            }
            break;
        case IDS_SPECIFIC_PATH:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            m_rootPath.GetWindowText(szRootPath);
            szRootPath.TrimLeft();
            szRootPath.TrimRight();
            szRootPath.TrimRight ('\\');
            if (! IsValidPrefix (IDS_SPECIFIC_PATH, (LPCTSTR) szRootPath))
                wParam = (WPARAM) FALSE;
            else
                wParam = (WPARAM) TRUE;
            break;
        case IDS_HOMEDIR_PATH:
            {
                CString szTmp;

                szTmp.LoadString (IDS_HOMEDIR_WARNING);
                m_peruserPathDesc.SetWindowText (szTmp);
                m_peruserPathDesc.ShowWindow (SW_SHOW);
                wParam = (WPARAM) (m_cookie == IDS_MYDOCS ? TRUE : FALSE);
                break;
            }
        case IDS_USERPROFILE_PATH:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            wParam = (WPARAM) TRUE;
            break;
        default:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            wParam = (WPARAM) FALSE;
            break;
        }
    }

    m_pParent->SendMessage (WM_PATH_TWEAKED, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\redirect.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    redirect.cxx

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/24/1998

Revision History:

    4/24/1998   RahulTh
    7/16/1998   RahulTh     added calls to IGPEInformation::PolicyChanged()
    10/5/1998   RahulTh     massive changes for scaleability
    10/12/1998  RahulTh     added parameters for PolicyChanged

    Created this module.

--*/

#include "precomp.hxx"

//
// Guid of fdeploy client side GP extension
//

GUID guidExtension = {0x25537BA6, 0x77A8, 0x11D2, {0x9B, 0x6C, 0x00, 0x00, 0xF8,
                        0x08, 0x08, 0x61}};

//
//mapping between help ids and control ids for context sensitive help
//
const DWORD g_aHelpIDMap_IDD_REDIRECT[] =
{
    IDC_REDIR_ICON,         IDH_DISABLEHELP,
    IDC_REDIR_DESC,         IDH_DISABLEHELP,
    IDC_SETTING_TITLE,      IDH_DISABLEHELP,
    IDC_REDIR_CHOICE,       IDH_REDIR_CHOICE,
    IDC_SEL_DESC,           IDH_DISABLEHELP,
    IDC_STORE_GROUP,        IDH_DISABLEHELP,
    IDC_LIST_ADVANCED,      IDH_LIST_ADVANCED,
    IDC_BTNADD,             IDH_BTNADD,
    IDC_BTNEDIT,            IDH_BTNEDIT,
    IDC_BTNREMOVE,          IDH_BTNREMOVE,
    IDC_LIST_STRSIDS,       IDH_DISABLEHELP,
    0,                      0
};

CRedirect::CRedirect (UINT nID) : CPropertyPage (CRedirect::IDD), m_basicLocation (nID)
{
    m_szFolderName.Empty();
    m_ppThis = NULL;
    m_pScope = NULL;
    m_pFileInfo = NULL;
    m_cookie = nID;
    m_dwFlags = REDIR_DONT_CARE;
    m_iCurrChoice = 0;      // Be safe. initialize it to a valid value.
    m_fValidFlags = FALSE;
    m_fEnableMyPics = FALSE;
    m_dwMyPicsCurr = 0;     //the current status of MyPics -- don't care/follow my docs/independent redirection (= 0)

    //m_ppThis, m_pScope and m_pFileInfo are set immediately after creation in CScopePane routines
}

CRedirect::~CRedirect()
{
    //reset the pointer to this property page from its corresponding
    //CFileInfo object so that it know that it is gone.
    *m_ppThis = NULL;
}

BOOL CRedirect::OnApply ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CError  error(this);
    UINT    errCode;
    int     count;
    int     i;
    LONG    iSel;
    CString Key;
    CString Val;
    CString szSuffix;
    UINT    pathType;
    CRedirPath newPath (m_cookie);
    BOOL    bShowMyPics = FALSE;
    BOOL    bMyPicsShouldFollow = TRUE;
    CHourglass  hourGlass;  //this may take a while.
    GUID guidSnapin = CLSID_Snapin;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bPathChanged;
    BOOL    bStatus;

    //first check if it is necessary to go through the entire operation
    //maybe the Apply button has already been pressed and there is nothing
    //more to commit
    if (!m_fSettingModified [ m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START] &&
        !(pSettings->m_fSettingsChanged))
        return TRUE;

    m_pathChooser.OnRootKillFocus();

    //clear out the group+path info. in the associated fileinfo. object
    m_pFileInfo->DeleteAllItems();

    if (m_dwFlags & REDIR_DONT_CARE)
        goto OnApply_SaveChanges;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto OnApply_SaveChanges;


    if (m_dwFlags & REDIR_SCALEABLE)
    {
        count = m_lstSavedStrSids.GetItemCount();

        for (i = 0; i < count; i++)
        {
            Key = m_lstSavedStrSids.GetItemText (i, 0); //the sid
            Val = m_lstSecGroups.GetItemText (i, 1);    //the path
            m_pFileInfo->Insert(Key, Val, FALSE, FALSE);
        }

        if (count) //does not makes sense to get the move contents flags if no sec/path pairs have been specified
            GetPrefFlags (&bMyPicsShouldFollow);
        else
            bMyPicsShouldFollow = FALSE;

        goto OnApply_SaveChanges;
    }

    // If we are here, it means that the basic option was chosen
    Key.LoadString (IDS_SID_EVERYONE);
    m_pathChooser.GetRoot (Val);
    pathType = m_pathChooser.GetType();

    // First check if the path has changed from what we started out with
    bPathChanged = m_basicLocation.IsPathDifferent (pathType, (LPCTSTR) Val);

    if (!bPathChanged)   // The path has not changed, so use the same one as before
    {
        m_basicLocation.GeneratePath (Val);
    }
    else
    {
        //
        // The path has changed, so generate the correct suffix
        //
        newPath.GenerateSuffix (szSuffix, m_cookie, pathType);
        bStatus = newPath.Load (pathType, (LPCTSTR) Val, (LPCTSTR) szSuffix);
        if (bStatus)
        {
            // Make sure that the path is not just a "*"
            newPath.GeneratePath (Val);
            if (TEXT("*") == Val)
                bStatus = FALSE;
        }

        if (!bStatus)
        {
            // The path in the edit location is invalid. Display an error message
            // Also make sure that the target tab is visible
            ((CPropertySheet *)GetParent())->SetActivePage(0);
            errCode = IDS_INVALID_PATH;
            goto OnApply_ReportError;
        }
    }

    //
    // If we are here, Val has the right path
    // If it is not the local userprofile path and it is not a UNC path
    // pop up a warning message -- if the path has changed.
    //
    if (bPathChanged &&
        pathType != IDS_USERPROFILE_PATH &&
        m_fSettingModified [m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START] &&
        ! PathIsUNC ((LPCTSTR) Val)
        )
    {
        //no point in popping up this warning if only the redirection
        //preference were changed but not the redirection path.

        //make sure that the target tab is visible
        ((CPropertySheet *)GetParent())->SetActivePage(0);

        //pop-up the warning message.
        error.SetStyle (MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
        error.SetTitle (IDS_DEFAULT_WARNING_TITLE);
        if (IDNO == error.ShowMessage (IDS_PATHNOTUNC_WARNING))
            goto OnApply_QuitWithoutApply;
    }

    // If we are here, we are ready to commit changes.
    m_pFileInfo->Insert (Key, Val, TRUE, FALSE);

    GetPrefFlags (&bMyPicsShouldFollow);

OnApply_SaveChanges:
    //copy the flags to the associated fileinfo. object
    //this cannot be done earlier since the value of the move contents
    //flag is only know for sure at this point
    //also we don't want to modify the flags on the fileinfo object
    //unless we are sure that there are no other errors.
    if (ERROR_SUCCESS != (dwError = CommitChanges(bMyPicsShouldFollow)))
    {
        error.SetError (dwError);
        errCode = IDS_SAVE_ERROR;
        goto OnApply_ReportError;
    }
    //else accept changes and move on

    iSel = m_iCurrChoice + m_iChoiceStart;
    if (IDS_NETWORK == iSel ||
        (IDS_SCALEABLE == iSel && m_lstSavedStrSids.GetItemCount()))
    {
        m_fValidFlags = TRUE;
    }
    else
    {
        m_fValidFlags = FALSE;
    }

    //this needs to be called so that the policy engine knows that
    //the policy has been modified
    if (m_pScope->m_pIGPEInformation)
        m_pScope->m_pIGPEInformation->PolicyChanged(FALSE, TRUE, &guidExtension, &guidSnapin);

    DirtyPage(FALSE);
    pSettings->DirtyPage (FALSE);
    return TRUE;

OnApply_ReportError:
    //set all message box parameters to be on the safe side. They might have been
    //modified by the warning message above.
    error.SetStyle (MB_OK | MB_ICONERROR);
    error.SetTitle (IDS_DEFAULT_ERROR_TITLE);
    error.ShowMessage (errCode);

OnApply_QuitWithoutApply:
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::GetPrefFlags
//
//  Synopsis:   this function finds out the values of the various flags
//              related to moving : REDIR_MOVE_CONTENTS and REDIR_APPLY_ACLS
//              also, in the My Docs case, it can be used to change the settings
//              on MyPics
//
//  Arguments:  [out] bMyPicsShouldFollow : on return, if this, this contains
//                       a value that indicates whether My Pics should be forced
//                       to follow My Docs.
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      if this is not My Documents, the value of bMyPicsShouldFollow
//              is not pertinent
//
//---------------------------------------------------------------------------
void CRedirect::GetPrefFlags (BOOL* bMyPicsShouldFollow)
{
    CString     szFormat;
    CString     szPrompt;
    CString     szTitle;
    int         retVal;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;

    if (m_pFileInfo->m_bSettingsInitialized)
    {
        if (pSettings->m_cbMoveContents.GetCheck())
            m_dwFlags |= REDIR_MOVE_CONTENTS;
        else
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;

        if (pSettings->m_rbRelocate.GetCheck())
            m_dwFlags |= REDIR_RELOCATEONREMOVE;
        else
            m_dwFlags &= ~REDIR_RELOCATEONREMOVE;

        if (pSettings->m_cbApplySecurity.GetCheck())
            m_dwFlags |= REDIR_SETACLS;
        else
            m_dwFlags &= ~REDIR_SETACLS;

        if (m_fEnableMyPics && pSettings->m_fMyPicsValid)
            *bMyPicsShouldFollow = pSettings->m_fMyPicsFollows;
        else
            *bMyPicsShouldFollow = FALSE;
    }
    else    //the settings page was never initialized
    {
        //so use the defaults if the current flags are not valid
        if (!m_fValidFlags)
        {
            m_dwFlags &= ~REDIR_RELOCATEONREMOVE;
            if (IDS_STARTMENU == m_cookie)
            {
                m_dwFlags &= ~REDIR_MOVE_CONTENTS;
                m_dwFlags &= ~REDIR_SETACLS;
            }
            else
            {
                m_dwFlags |= REDIR_MOVE_CONTENTS;
                m_dwFlags |= REDIR_SETACLS;
            }
        }

        //decide what to do with  the My Pics folder
        if (IDS_MYDOCS == m_cookie && m_fEnableMyPics)
            *bMyPicsShouldFollow = TRUE;
        else
            *bMyPicsShouldFollow = FALSE;
    }
}

void CRedirect::DoDataExchange (CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CRedirect)
    DDX_Control (pDX, IDC_REDIR_DESC, m_csRedirDesc);
    DDX_Control (pDX, IDC_STORE_GROUP, m_cbStoreGroup);
    DDX_Control (pDX, IDC_REDIR_CHOICE, m_cmbRedirChoice);
    DDX_Control (pDX, IDC_PATHS_PLACEHOLDER, m_placeHolder);
    DDX_Control (pDX, IDC_BTNADD, m_cbAdd);
    DDX_Control (pDX, IDC_BTNREMOVE, m_cbRemove);
    DDX_Control (pDX, IDC_BTNEDIT, m_cbEdit);
    DDX_Control (pDX, IDC_LIST_ADVANCED, m_lstSecGroups);
    DDX_Control (pDX, IDC_LIST_STRSIDS, m_lstSavedStrSids);
    DDX_Control (pDX, IDC_SEL_DESC, m_csSelDesc);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRedirect, CPropertyPage)
    //{{AFX_MSG_MAP(CRedirect)
    ON_BN_CLICKED(IDC_BTNADD, OnAdd)
    ON_BN_CLICKED(IDC_BTNREMOVE, OnRemove)
    ON_BN_CLICKED(IDC_BTNEDIT, OnEdit)
    ON_MESSAGE (WM_PATH_TWEAKED, OnPathTweak)
    ON_CBN_SELCHANGE (IDC_REDIR_CHOICE, OnRedirSelChange)
    ON_NOTIFY (LVN_ITEMCHANGED, IDC_LIST_ADVANCED, OnSecGroupItemChanged)
    ON_NOTIFY (NM_DBLCLK, IDC_LIST_ADVANCED, OnSecGroupDblClk)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////
//CRedirect Message Handlers

//on clicking the Add button
void CRedirect::OnAdd ()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    FIX_THREAD_STATE_MFC_BUG();

    CSecGroupPath   dlgSecPath(this, m_cookie, (LPCTSTR) m_szFolderName);
    LV_FINDINFO     lvfi;
    int             i;
    int             itemCount;
    CError          error (this);

    if (IDOK != dlgSecPath.DoModal())
        goto OnAdd_Quit;

    //OK was pressed. The group selection dialog itself validates the data,
    //so we don't have to do it here.
    lvfi.flags = LVFI_STRING;
    lvfi.psz = (LPCTSTR)dlgSecPath.m_szSidStr;

    i = m_lstSavedStrSids.FindItem (&lvfi);

    if (-1 != i)
    {
        error.ShowMessage (IDS_SECGROUP_EXISTS,
                           (LPCTSTR) dlgSecPath.m_szGroup);
        goto OnAdd_Quit;
    }

    itemCount = m_lstSecGroups.GetItemCount();
    m_lstSecGroups.InsertItem (itemCount, (LPCTSTR) dlgSecPath.m_szGroup, 1);
    m_lstSecGroups.SetItemText (itemCount, 1, (LPCTSTR) dlgSecPath.m_szTarget);
    m_lstSavedStrSids.InsertItem (itemCount, (LPCTSTR) dlgSecPath.m_szSidStr, 1);
    //we must enable the Settings page if this is the first group being
    //added. since it would have been disabled until now
    //note: item count is the count of items before the current item was added
    if (0 == itemCount)
        m_pFileInfo->m_pSettingsPage->EnablePage ();

    DirtyPage (TRUE);

OnAdd_Quit:
    return;
}

//on clicking the Edit button
void CRedirect::OnEdit ()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    FIX_THREAD_STATE_MFC_BUG();

    CString szGroup;
    CString szSidStr;
    CString szTarget;
    int     iSel;
    CError  error(this);
    int     iFind;
    LV_FINDINFO lvfi;

    //there will be exactly one selected item
    iSel = m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED);
    ASSERT (-1 != iSel); //some item has to be selected or this button cannot be clicked

    szGroup = m_lstSecGroups.GetItemText (iSel, 0);
    szSidStr = m_lstSavedStrSids.GetItemText (iSel, 0);
    szTarget = m_lstSecGroups.GetItemText (iSel, 1);

    CSecGroupPath dlgSecPath(this,
                             m_cookie,
                             (LPCTSTR) m_szFolderName,
                             (LPCTSTR)szGroup,
                             (LPCTSTR) szSidStr,
                             (LPCTSTR) szTarget
                             );

    if (IDOK != dlgSecPath.DoModal())
        goto OnEdit_Quit;

    szGroup = dlgSecPath.m_szGroup;
    szSidStr = dlgSecPath.m_szSidStr;
    szTarget = dlgSecPath.m_szTarget;

    //OK was pressed. The sec/group selection dialog itself validates the
    //data, so we don't have to do it here.
    lvfi.flags = LVFI_STRING;
    lvfi.psz = (LPCTSTR)szSidStr;

    iFind = m_lstSavedStrSids.FindItem (&lvfi);

    //now, if we find the sid for the group in another entry (i.e. not the one
    //we are editing, then we must print an error message and abort
    //otherwise we replace the entries with the new data
    if (iFind == iSel || -1 == iFind)
    {
        m_lstSavedStrSids.SetItemText (iSel, 0, (LPCTSTR)szSidStr);
        m_lstSecGroups.SetItemText (iSel, 0, (LPCTSTR) szGroup);
        m_lstSecGroups.SetItemText (iSel, 1, (LPCTSTR) szTarget);
        DirtyPage(TRUE);
    }
    else
    {
        error.ShowMessage (IDS_SECGROUP_EXISTS, (LPCTSTR) szGroup);
    }

OnEdit_Quit:
    return;
}

//on clicking the remove button
void CRedirect::OnRemove ()
{
    int i;

    if (0 == m_lstSecGroups.GetSelectedCount())
        return; //this will never happen since the remove button gets disabled
                //if nothing is selected.

    //get the index of the selected item -- there can be only 1 selected item
    i = m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED);
    m_lstSecGroups.DeleteItem (i);
    m_lstSavedStrSids.DeleteItem (i);   //need to keep the 2 lists in sync
    //we must disable the settings page if this deletion causes the item count
    //to go down to 0.
    if (0 == m_lstSecGroups.GetItemCount())
    {
        m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);
    }
    else
    {
        //if there still are some items in the list, select the previous item
        //in the list or the first one, if we just deleted the first item
        //provided nothing else is already selected.
        if (0 == m_lstSecGroups.GetSelectedCount())
            m_lstSecGroups.SetItemState ((0 == i)?0:(i-1), LVIS_SELECTED,
                                            LVIS_SELECTED);
    }

    DirtyPage(TRUE);
}

void CRedirect::OnFollowParent()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_FOLLOW_PARENT;
    m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);

    SetPropSheetContents();
}

void CRedirect::OnScaleableLocation()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_SCALEABLE;
    if (m_lstSecGroups.GetItemCount())
        m_pFileInfo->m_pSettingsPage->EnablePage ();
    else
        m_pFileInfo->m_pSettingsPage->EnablePage(FALSE);

    SetPropSheetContents();
}

void CRedirect::OnNetworkLocation()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_pFileInfo->m_pSettingsPage->EnablePage ();

    SetPropSheetContents();
}

BOOL CRedirect::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CPropertyPage::OnInitDialog();

    CString szText;
    CString szFormat;
    RECT    rect;
    UINT    groupWidth;
    BOOL    fFocusSet;
    UINT    i;
    UINT    parentID;
    CString szParent;
    BOOL    bPathDiscarded = FALSE;
    BOOL    bStatus;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;
    HRESULT hr;

    //change the style of the advanced list control so that the full row gets
    //selected instead of just the first column. note, we cannot specify this
    //style in the resource file because it is ignored if we specify it there
    //(probably because MFC expects a lower version of IE/NT than what Win2K has
    //and therefore the definition of this extended style is not recognized
    //when the resources are compiled.
    ListView_SetExtendedListViewStyle (m_lstSecGroups.m_hWnd, LVS_EX_FULLROWSELECT);
    //set the column headers for the list control
    //this must happen before the call to InitPrivates
    //otherwise the security group membership won't be displayed
    //correctly in the advanced settings
    m_lstSecGroups.GetClientRect (&rect);
    groupWidth = rect.right / 3;
    szText.LoadString (IDS_COL_GROUP);
    m_lstSecGroups.InsertColumn (0, (LPCTSTR) szText, LVCFMT_LEFT, groupWidth);
    szText.LoadString (IDS_COL_PATH);
    m_lstSecGroups.InsertColumn (1, (LPCTSTR) szText, LVCFMT_LEFT,
                                 rect.right - groupWidth);
    //put it in report view
    m_lstSecGroups.ModifyStyle (LVS_TYPEMASK, LVS_REPORT);

    //initialize the list control that is going to be used to save the string ids
    szText.LoadString (IDS_COL_GROUP);
    m_lstSavedStrSids.ShowWindow (SW_HIDE); //this is never visible
    m_lstSavedStrSids.InsertColumn (0, (LPCTSTR) szText, LVCFMT_LEFT, 200);

    //initialize the remaining private data members
    if (!InitPrivates(&bPathDiscarded))
    {
        // We could not load the data... just quit. The error messages
        // if any, have already been displayed at this point.
        ((CPropertySheet *) GetParent())->EndDialog(IDCANCEL);
        return TRUE;
    }

    //
    // If we are here, then if the policy had basic settings, m_basicLocation
    // already has the path info.
    //
    m_pathChooser.Instantiate (m_cookie,
                               this,
                               &m_placeHolder,
                               (const CRedirPath *) &m_basicLocation
                               );


    //set the text describing the dialog.
    szFormat.LoadString (IDS_REDIR_DESC);
    szText.Format ((LPCTSTR)szFormat, m_szFolderName);
    m_csRedirDesc.SetWindowText (szText);

    //now. populate the combo box based on the settings
    for (i = m_iChoiceStart; i < IDS_REDIR_END; i++)
    {
        if (IDS_FOLLOW_PARENT == i)
        {
            //get the resource id of the parent and also verify that it this folder
            //is a special descendant
            VERIFY (IsSpecialDescendant (m_cookie, &parentID));
            szFormat.LoadString (i);
            szParent.LoadString (parentID);
            szText.Format ((LPCTSTR)szFormat, (LPCTSTR) szParent);
        }
        else
        {
            szText.LoadString (i);
        }
        m_cmbRedirChoice.AddString ((LPCTSTR)szText);
    }

    fFocusSet = SetPropSheetContents();

    if ((IDS_SCALEABLE == (m_iCurrChoice + m_iChoiceStart)) &&
        m_lstSecGroups.GetItemCount())
    {
        m_fValidFlags = TRUE;
    }

    DirtyPage (FALSE);  //this ensures that we start out with a clean page
                        //and also that the m_fSettingModified is set correctly


    //we might have to display the My Pics preferences
    //so check if we need to display the controls specific to My Pictures
    //special case
    if (IDS_MYDOCS == m_cookie)
    {
        //
        // Load the my pics section to see its current settings
        // Also, the MyPics settings on the settings page should be enabled
        // only if the current settings for both MyDocs and MyPics are don't
        // care. Because if the settings for MyDocs are not don't care and
        // those of MyPics are, then it means that someone has already explicitly
        // made that choice. So we should not change the settings.
        //
        if (SUCCEEDED(hr = m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].LoadSection()) &&
            (m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_DONT_CARE))
        {
            m_fEnableMyPics = (m_pFileInfo->m_dwFlags & REDIR_DONT_CARE) ? TRUE : FALSE;
            m_dwMyPicsCurr = REDIR_DONT_CARE;
        }
        else if (SUCCEEDED(hr) &&
                 m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_FOLLOW_PARENT)
        {
            m_dwMyPicsCurr = REDIR_FOLLOW_PARENT;
        }
        else
            m_dwMyPicsCurr = 0;
    }

    //
    // If the existing path was discarded because it could not be parsed
    // then we have to indicate that the page is Dirty so that the OnApply
    // function won't be a no-op.
    // Note: The call to DirtyPage (FALSE) above is still necessary in order
    // to ensure that the m_fSettingModified array is setup correctly.
    //
    if (bPathDiscarded)
        DirtyPage (TRUE);

    return ! fFocusSet;    //return TRUE unless you set focus to a control
}


BOOL CRedirect::InitPrivates(BOOL * pbPathDiscarded)
{
    ASSERT (m_pFileInfo);
    ASSERT (m_ppThis);
    ASSERT (m_pScope);

    int     iRestrict;
    int     index;
    BOOL    fInRedirect;
    BOOL    bStatus = TRUE;

    SetFolderStatus();

    bStatus = RetrieveRedirInfo(pbPathDiscarded);

    if (!bStatus)
        return FALSE;

    m_szFolderName = m_pFileInfo->m_szDisplayname;

    if (m_dwFlags & REDIR_DONT_CARE)
    {
        m_iCurrChoice = IDS_DONT_CARE - m_iChoiceStart;
        m_fValidFlags = FALSE;
    }
    else if (m_dwFlags & REDIR_FOLLOW_PARENT)
    {
        m_iCurrChoice = IDS_FOLLOW_PARENT - m_iChoiceStart;
        m_fValidFlags = FALSE;
    }
    else if (m_dwFlags & REDIR_SCALEABLE)
    {
        m_iCurrChoice = IDS_SCALEABLE - m_iChoiceStart;
        m_fValidFlags = FALSE;  //set false for now... oninitdialog will do the rest
    }
    else    //it has to be basic settings now
    {
        m_iCurrChoice = IDS_NETWORK - m_iChoiceStart;
        m_fValidFlags = TRUE;
    }

    return TRUE;
}

void CRedirect::SetFolderStatus (void)
{
    switch (m_cookie)
    {
    case IDS_MYPICS:
        m_iChoiceStart = IDS_CHILD_REDIR_START;
        m_iDescStart = IDS_CHILD_SELDESC_START;
        break;
    case IDS_STARTMENU:
        m_iChoiceStart = IDS_REDIR_START;
        m_iDescStart = IDS_SELDESC_START;
        break;
    default:
        m_iChoiceStart = IDS_REDIR_START;
        m_iDescStart = IDS_SELDESC_START;
        break;
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::SetPropSheetContents
//
//  Synopsis:   this functions arranges/hides/shows/displays contents
//              on the property sheet based on the state of the internal
//              variables of the object
//
//  Arguments:  none
//
//  Returns:    TRUE : if it sets focus to an item in the dialog
//              FALSE: otherwise
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirect::SetPropSheetContents (void)
{
    CString szFormat;
    CString szText;
    CString szParent;
    UINT    parentID;
    int     nCmdShowBasic;
    int     nCmdShowAdvanced;
    int     nCmdShowGroupBox;
    UINT    GroupTitle;
    BOOL    fFocusSet = FALSE;
    BOOL    bParam;

    //first select the choice from the combo box
    m_cmbRedirChoice.SetCurSel (m_iCurrChoice);

    //hide or show other controls based on the current choice
    switch (m_iCurrChoice + m_iChoiceStart)
    {
    case IDS_FOLLOW_PARENT:
    case IDS_DONT_CARE:
        nCmdShowBasic = SW_HIDE;
        nCmdShowAdvanced = SW_HIDE;
        nCmdShowGroupBox = SW_HIDE;
        szText.Empty();
        break;
    case IDS_SCALEABLE:
        nCmdShowBasic = SW_HIDE;
        nCmdShowAdvanced = SW_SHOW;
        nCmdShowGroupBox = SW_SHOW;
        szText.LoadString (IDS_SECGROUP_DESC);
        break;
    default:
        nCmdShowBasic = SW_SHOW;
        nCmdShowAdvanced = SW_HIDE;
        nCmdShowGroupBox = SW_SHOW;
        szText.LoadString(IDS_TARGET_DESC);
        break;
    }

    m_cbStoreGroup.SetWindowText (szText);
    m_cbStoreGroup.ShowWindow (nCmdShowGroupBox);
    //
    // Adjust the height of the description control so that it occupies the
    // max. possible space and let us have nice descriptive and verbose messages
    // and thereby minimize user confusion.
    //
    // Note: This function must be called after setting the correct state for
    // the group box because this function adjusts its height based on whether
    // the group box is visible or not.
    //
    AdjustDescriptionControlHeight ();
    // Set the description
    szText.LoadString (m_iCurrChoice + m_iDescStart);
    m_csSelDesc.SetWindowText (szText);


    m_pathChooser.ShowWindow (nCmdShowBasic);

    m_cbAdd.ShowWindow (nCmdShowAdvanced);
    m_cbRemove.ShowWindow (nCmdShowAdvanced);
    m_cbEdit.ShowWindow (nCmdShowAdvanced);
    m_lstSecGroups.ShowWindow (nCmdShowAdvanced);

    if (SW_SHOW == nCmdShowAdvanced)
    {
        //select the first item if possible
        if (m_lstSecGroups.GetItemCount())
        {
            m_lstSecGroups.SetItemState (0, LVIS_SELECTED,
                                         LVIS_SELECTED);
        }
        OnSecGroupItemChanged (NULL, NULL);
    }

    return fFocusSet;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnDontCare
//
//  Synopsis:   the actions that are taken when someone clicks on the
//              "This policy doesn't care about the location of this folder"
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    8/3/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnDontCare (void)
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_DONT_CARE;
    m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);

    SetPropSheetContents();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnRedirSelChange
//
//  Synopsis:   the handler for the CBN_SELCHANGE notification for the combo
//              box that is used to make the choice of redirection
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    8/4/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnRedirSelChange (void)
{
    int iSel;

    iSel = m_cmbRedirChoice.GetCurSel();

    if (iSel == m_iCurrChoice)  //the choice has not changed
        return;

    //the choice has changed, so update m_iCurrChoice
    m_iCurrChoice = iSel;

    switch (m_iCurrChoice + m_iChoiceStart)
    {
    case IDS_FOLLOW_PARENT:
        OnFollowParent ();
        break;
    case IDS_SCALEABLE:
        OnScaleableLocation();
        break;
    case IDS_NETWORK:
        OnNetworkLocation();
        break;
    case IDS_DONT_CARE:
        OnDontCare();
        break;
    default:
        break;
    }

    SetButtonEnableState();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::DirtyPage
//
//  Synopsis:   keeps track of whether the property page is dirty (has modified
//              data) or not. If the page is dirty, it also enables/disables the
//              apply button.
//
//  Arguments:  [in] fDataModified : TRUE/FALSE value
//
//  Returns:    nothing
//
//  History:    8/25/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::DirtyPage (BOOL fDataModified)
{
    if (!fDataModified)    //this is the tricky case. fDataModified is FALSE
    {                      //only if changes have been applied, or the dialog
                           //is being created. so all settings are affected.
        //first set all the defaults
        m_fSettingModified [IDS_FOLLOW_PARENT - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_NETWORK - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_SCALEABLE - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_DONT_CARE - IDS_CHILD_REDIR_START] = TRUE;
    }

    //now modify the value for the selected setting
    m_fSettingModified [m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START]
                    = fDataModified;

    //enable or disable the various buttons based on this.
    SetButtonEnableState ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::SetButtonEnableState
//
//  Synopsis:   enables or disables the OK & Apply buttons based on the
//              current modified value for the selected setting
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    10/14/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::SetButtonEnableState (void)
{
    BOOL    fMod;

    fMod = m_fSettingModified [ m_iCurrChoice + m_iChoiceStart
                                - IDS_CHILD_REDIR_START];

    SetModified (fMod);

    //uncomment the following line if you want the OK button to have the
    //same state as the Apply button. Needless to add that this would be
    //highly unconventional. requires careful consideration
    //((GetParent())->GetDescendantWindow (IDOK, FALSE))->EnableWindow (fMod);
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::RetrieveRedirInfo
//
//  Synopsis:   gets the redir info. stored in the corresponding CFileInfo
//              object and stores them in the control
//
//  Arguments:  [out] pbPathDiscarded : indicates if the current path
//                       was discarded because the stored path could not
//                       be parsed and the user chose to enter a new one.
//
//  Returns:    nothing
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirect::RetrieveRedirInfo (BOOL * pbPathDiscarded)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    int count;
    int cx;
    CString szDir;
    CString szAcct;
    BOOL    bStatus = TRUE;
    CHourglass hourglass;   //LookupAccountSid takes a little while

    m_dwFlags = m_pFileInfo->m_dwFlags;

    if (m_dwFlags & REDIR_DONT_CARE)
        goto RetrieveRedirInfo_Quit;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto RetrieveRedirInfo_Quit;

    if (m_dwFlags & REDIR_SCALEABLE)
    {
        m_lstSecGroups.DeleteAllItems();
        m_lstSavedStrSids.DeleteAllItems(); //keep it in sync. with m_lstSecGroups
        for (i = m_pFileInfo->m_RedirGroups.begin(), j = m_pFileInfo->m_RedirPaths.begin(), count = 0;
             i != m_pFileInfo->m_RedirGroups.end();
             i++, j++, count++)
        {
            //display the friendly name of the group represented by the sid
            if (STATUS_SUCCESS == GetFriendlyNameFromStringSid((LPCTSTR)(*i),
                                                               szDir,
                                                               szAcct))
            {
                if (!szDir.IsEmpty())
                    szAcct = szDir + '\\' + szAcct;
            }
            else    //just display the unfriendly string if the friendly name cannot be obtained
            {
                szAcct = (*i);
                szAcct.MakeUpper();
            }
            m_lstSecGroups.InsertItem (count, (LPCTSTR)szAcct, 1);   //we don't have any images
            //adjust the width of the column if required
            if ((cx = m_lstSecGroups.GetStringWidth ((LPCTSTR)szAcct)) >
                 m_lstSecGroups.GetColumnWidth (0))
            {
                m_lstSecGroups.SetColumnWidth (0, cx);
            }

            m_lstSecGroups.SetItemText (count, 1, (LPCTSTR) (*j));
            //adjust the width of the column if required
            if ((cx = m_lstSecGroups.GetStringWidth ((LPCTSTR)(*j))) >
                m_lstSecGroups.GetColumnWidth (1))
            {
                m_lstSecGroups.SetColumnWidth (1, cx);
            }

            //store the string representation of the sid in the control
            //will be handy when the contents of the dialog are written
            //back to the data structure. This won't be visible to anyone
            //this is just a means to hide away some useful info. in the control
            m_lstSavedStrSids.InsertItem (count, (LPCTSTR)(*i), 0);
        }

        goto RetrieveRedirInfo_Quit;
    }

    //
    // If we are here, this means that the Basic settings will be used
    // so just use the first path. The load will always succeed if the
    // path is not empty.
    //
    m_basicLocation.Load ((LPCTSTR) (*(m_pFileInfo->m_RedirPaths.begin())));

RetrieveRedirInfo_Quit:
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnSecGroupItemChanged
//
//  Synopsis:   handler for LVN_ITEMCHANGED sent by the list control to the
//              dialog
//
//  Arguments:  standard : refer to the docs
//
//  Returns:    nothing
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:      this notification has to be handled since some of the buttons
//              need to be activated or deactivated based on whether something
//              in the list control has been selected or not
//
//---------------------------------------------------------------------------
void CRedirect::OnSecGroupItemChanged (LPNMLISTVIEW pNMListView, LRESULT* pResult)
{
    BOOL fEnable = FALSE;

    if (m_lstSecGroups.GetSelectedCount())
        fEnable = TRUE;

    m_cbRemove.EnableWindow (fEnable);
    m_cbEdit.EnableWindow (fEnable);

    if (pResult)
        *pResult = 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     OnSecGroupDblClk
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    5/5/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnSecGroupDblClk (LPNMHDR pNMHdr, LRESULT* pResult)
{
    //do not try to edit if the double click happened in an area outside
    //the list of items.
    if (-1 != m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED))
        OnEdit();

    if (pResult)
        *pResult = 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     CommitChanges
//
//  Synopsis:   commits the changes made through the property sheet to
//              the ini file on the sysvol
//
//  Arguments:  [in] bMyPicsFollows : indicates if My Pics should be forced
//                    to follow My Docs. For other folders, this value
//                    is ignored
//
//  Returns:    ERROR_SUCCESS : if changes were committed
//              otherwise error codes pointing to the case of the error are returned
//
//  History:    11/8/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CRedirect::CommitChanges (BOOL bMyPicsFollows)
{
    DWORD   dwAdd;
    DWORD   dwRemove;
    BOOL    bCommitDescendants = FALSE;
    DWORD   dwError = ERROR_SUCCESS;

    //first copy over the flags to the corresponding fileinfo object
    //the other members have already been populated appropriately
    //strip off extraneous flags for REDIR_DONT_CARE and REDIR_FOLLOW_PARENT
    if (REDIR_DONT_CARE & m_dwFlags)
        m_pFileInfo->m_dwFlags = REDIR_DONT_CARE;
    else if (REDIR_FOLLOW_PARENT & m_dwFlags)
        m_pFileInfo->m_dwFlags = REDIR_FOLLOW_PARENT;
    else
        m_pFileInfo->m_dwFlags = m_dwFlags;

    if (ERROR_SUCCESS != (dwError = m_pFileInfo->SaveSection()))
        return dwError;

    //do special tweaking for Start Menu and My Docs
    if (m_dwFlags & REDIR_DONT_CARE)
    {
        dwAdd = REDIR_DONT_CARE;
        dwRemove = REDIR_FOLLOW_PARENT;
        if (IDS_MYDOCS == m_cookie)
        {
            //for my docs, change my pics only if it was supposed to follow it
            //in the first place.
            if (m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_FOLLOW_PARENT)
                bCommitDescendants = TRUE;
        }
        else if (IDS_STARTMENU == m_cookie)
        {
            bCommitDescendants = TRUE;  //Start Menu, Programs and Startup are always together.
        }
        //other folders do not have descendants
    }
    else    //if the folder is getting redirected
    {
        dwAdd = REDIR_FOLLOW_PARENT;
        dwRemove = REDIR_DONT_CARE;
        if (IDS_MYDOCS == m_cookie)
            bCommitDescendants = bMyPicsFollows;
        else if (IDS_STARTMENU == m_cookie)
            bCommitDescendants = TRUE;
    }

    //now that we have all the info. commit the descendants if necessary
    if (bCommitDescendants)
    {
        if (IDS_MYDOCS == m_cookie)
        {
            //clean out the group + path info. for My Pictures
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].DeleteAllItems();
            //modify the flags
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags |= dwAdd;
            //commit the changes
            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].SaveSection()))
                return dwError;
            m_fEnableMyPics = (REDIR_FOLLOW_PARENT == dwAdd) ? FALSE : TRUE;
            m_dwMyPicsCurr = dwAdd;
        }
        else if (IDS_STARTMENU == m_cookie)
        {
            //modify the programs flags
            m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].m_dwFlags |= dwAdd;
            //modify the startup flags
            m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].m_dwFlags |= dwAdd;
            //commit the changes
            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].SaveSection()))
                return dwError;

            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].SaveSection()))
                return dwError;
        }
    }

    return ERROR_SUCCESS;
}

void CRedirect::OnPathTweak (WPARAM wParam, LPARAM lParam)
{
    DirtyPage (TRUE);
}


LONG CRedirect::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_REDIRECT);

    return lResult;
}

LONG CRedirect::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_REDIRECT);

    return lResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::AdjustDescriptionControlHeight
//
//  Synopsis:   Resizes the control that holds the description text for the
//              chosen option such that it occupies the maximum space possible.
//              Certain options like "Not Configured" require a lot more verbose
//              description to avoid user confusion and since these options
//              don't have anything below the option selection combo box besides
//              the description, it is possible to expand the description box
//              to occupy the entire space. We do this based on whether the
//              group box underneath it is visible or not and use the 
//              co-ordinates of the group box for resizing.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    4/21/2001  RahulTh  created
//
//  Notes:      In order for this function to be effective, it must be invoked
//              after the group box is set to its correct state, i.e., visible
//              or hidden.      
//
//---------------------------------------------------------------------------
void CRedirect::AdjustDescriptionControlHeight (void)
{
    RECT    rcDesc;         // The rect. for the description control.
    RECT    rcGroupBox;     // The rect. for the group box.
    LONG    bottom;
    
    m_csSelDesc.GetWindowRect(&rcDesc);
    m_cbStoreGroup.GetWindowRect(&rcGroupBox);
    
    bottom = m_cbStoreGroup.IsWindowVisible() ? 
        rcGroupBox.top - 6 :    // if the group box is visible. Make the description window smaller.
        rcGroupBox.bottom;      // otherwise make it bigger.
    
    // Adjust the height of the description control.
    m_csSelDesc.SetWindowPos(NULL, 
                               -1, 
                               -1, 
                               rcDesc.right - rcDesc.left, 
                               bottom - rcDesc.top, 
                               SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOZORDER
                               );
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by filedep.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NODENAME                    2
#define IDS_FIRST_COL                   3
#define IDS_NAME                        3
#define IDS_TYPE                        4
#define IDS_LAST_COL                    5
#define IDS_SNAPIN_NAME					6
#define IDS_FOLDER_TYPE                 10
#define IDS_FIRST_RSOP_COL              20
#define IDS_PRECEDENCE                  20
#define IDS_REDIRECTEDPATH              21
#define IDS_GROUP                       22
#define IDS_GPO                         23
#define IDS_INSTALLATIONTYPE            24
#define IDS_EXCLUSIVE                   25
#define IDS_MOVE                        26
#define IDS_POLICYREMOVAL               27
#define IDS_LAST_RSOP_COL               28
#define IDS_FOLDER_TITLE                100
#define IDS_FOLDERBROWSE_DESC           109
#define IDS_MOVECONTENTS_TITLE          112
#define IDS_MOVECONTENTS_CONFIRM        113
#define IDS_INIFILE                     114
#define IDS_MYPICS_RELPATH              115
#define IDS_PROGRAMS_RELPATH            116
#define IDS_STARTUP_RELPATH             117
#define IDS_REDIR_DESC                  118
#define IDS_TARGET_DESC                 119
#define IDS_SECGROUP_DESC               120
#define IDS_COL_GROUP                   121
#define IDS_COL_PATH                    122
#define IDS_OBJPICK_ERROR               123
#define IDS_SID_EVERYONE                124
#define IDS_HELP_FILE                   125
#define IDS_DEFAULT_ERROR               200
#define IDS_DEFAULT_ERROR_TITLE         201
#define IDS_DEFAULT_WARNING_TITLE       202
#define IDS_NOSECURITY_INFO             203
#define IDS_INVALID_GROUPPATH           204
#define IDS_SECGROUP_EXISTS             205
#define IDS_SAVE_ERROR                  206
#define IDS_INVALID_PATH                207
#define IDS_SECTIONLOAD_ERROR           208
#define IDS_PATHTOOLONG_ERROR           209
#define IDS_PATHNOTUNC_WARNING          210
#define IDS_CHILD_REDIR_START           302
#define IDS_FOLLOW_PARENT               302
#define IDS_REDIR_START                 303
#define IDS_NETWORK                     303
#define IDS_SCALEABLE                   304
#define IDS_DONT_CARE                   305
#define IDS_REDIR_END                   306
#define IDS_CHILD_SELDESC_START         307
#define IDS_FOLLOWPARENT_DESC           307
#define IDS_SELDESC_START               308
#define IDS_NETWORK_DESC                308
#define IDS_SCALEABLE_DESC              309
#define IDS_DONTCARE_DESC               310
#define IDS_SELDESC_END                 311
#define IDI_FOLDER                      400
#define IDI_SNAPIN                      401
#define IDB_16x16                       500
#define IDB_32x32                       501
#define IDS_DIRS_START                  602
#define IDS_LEVEL1_DIRS_START           602
#define IDS_APPDATA                     602
#define IDS_DESKTOP                     603
#define IDS_MYDOCS                      604
#define IDS_STARTMENU                   605
#define IDS_LEVEL1_DIRS_END             606
#define IDS_LEVEL2_DIRS_START           606
#define IDS_MYPICS                      606
#define IDS_PROGRAMS                    607
#define IDS_LEVEL2_DIRS_END             608
#define IDS_LEVEL3_DIRS_START           608
#define IDS_STARTUP                     608
#define IDS_LEVEL3_DIRS_END             609
#define IDS_DIRS_END                    609
#define IDS_PREF_TITLE                  700
#define IDS_PREF_APPLYSECURITY          701
#define IDS_PREF_MOVE                   702
#define IDS_MYDOCS_DESTTYPE_START       801
#define IDS_HOMEDIR_PATH                801
#define IDS_DESTTYPE_START              802
#define IDS_PERUSER_PATH                802
#define IDS_SMENU_DESTTYPE_START        803
#define IDS_SPECIFIC_PATH               803
#define IDS_USERPROFILE_PATH            804
#define IDS_DESTTYPE_END                805
#define IDS_SETTINGS                    900
#define IDS_SETTING_BASIC               901
#define IDS_SETTING_MAXIMUM             902
#define IDS_NO                          903
#define IDS_YES                         904
#define IDS_ONPOLICYREMOVAL             904
#define IDS_LEAVE                       905
#define IDS_REDIRECT                    906
#define IDS_SAMPLE_USER                 907
#define IDS_SAMPLE_PATHDESC             908
#define IDS_HOMEDIR_WARNING				909
#define IDD_SECPATH                     1007
#define IDD_REDIRMETHOD                 1010
#define IDD_PATHCHOOSER                 1011
#define IDC_REDIR_ICON                  5002
#define IDC_REDIR_DESC                  5003
#define IDC_STORE_GROUP                 5004
#define IDC_REDIR_CHOICE                5032
#define IDC_SEL_DESC                    5034
#define IDC_SETTING_TITLE               5035
#define IDC_BTNADD                      5037
#define IDC_BTNEDIT                     5038
#define IDC_BTNREMOVE                   5039
#define IDC_LIST_ADVANCED               5040
#define IDC_LIST_STRSIDS                5042
#define IDC_SECPATH_DESC                5043
#define IDC_SECPATH_ICON                5044
#define IDC_SECPATH_SECGROUP            5045
#define IDC_SECPATH_TARGET              5046
#define IDC_EDIT_SECGROUP               5047
#define IDC_BROWSE_SECGROUP             5048
#define IDC_PREF_ICON                   5055
#define IDC_PREF_TITLE                  5056
#define IDC_PREF_MOVE                   5057
#define IDC_PREF_APPLYSECURITY          5058
#define IDC_PREF_CHANGEMYPICS           5061
#define IDC_PREF_LEAVEMYPICS            5062
#define IDC_PREF_MYPICS_GROUP           5063
#define IDC_PREF_ORPHAN                 5064
#define IDC_GROUP_ORPHAN                5065
#define IDC_PREF_RELOCATE               5067
#define IDC_SECPATH_PLACEHOLDER         5072
#define IDC_PATHS_PLACEHOLDER           5073
#define IDC_DESTTYPE                    5074
#define IDC_ROOT_DESC                   5075
#define IDC_ROOT_PATH                   5076
#define IDC_BROWSE                      5077
#define IDC_SAMPLE_PATH                 5078
#define IDC_GROUP                       5079
#define IDC_GPO                         5080
#define IDC_SETTING                     5081
#define IDC_PATH                        5082
#define IDD_REDIRECT                    6001
#define IDD_RSOP                        6002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1012
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         5083
#define _APS_NEXT_SYMED_VALUE           6002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\rsopinfo.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsopinfo.h
//
//  Contents:   Data for the RSOP mode result pane items
//
//  Classes:
//
//  Functions:
//
//  History:    03-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------

class CRsopProp;

class CRSOPInfo
{
public:
    UINT        m_nPrecedence;
    CString     m_szPath;
    CString     m_szGroup;
    CString     m_szGPO;
    CString     m_szFolder;
    BOOL        m_fGrantType;
    BOOL        m_fMoveType;
    UINT        m_nPolicyRemoval;
    UINT        m_nInstallationType;
    CRsopProp *  m_pRsopProp;
    CRSOPInfo(){
        m_pRsopProp = NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\rsopprop.cpp ===
// rsopprop.cpp : implementation file
//


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// rsopprop property page

IMPLEMENT_DYNCREATE(CRsopProp, CPropertyPage)

CRsopProp::CRsopProp() : CPropertyPage(CRsopProp::IDD)
{
    //{{AFX_DATA_INIT(CRsopProp)
    m_szGroup = _T("");
    m_szGPO = _T("");
    m_szPath = _T("");
    m_szSetting = _T("");
    m_fMove = FALSE;
    m_fApplySecurity = FALSE;
    m_iRemoval = -1;
    //}}AFX_DATA_INIT
}

CRsopProp::~CRsopProp()
{
    *m_ppThis = NULL;
}

void CRsopProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsopProp)
    DDX_Text(pDX, IDC_GROUP, m_szGroup);
    DDX_Text(pDX, IDC_GPO, m_szGPO);
    DDX_Text(pDX, IDC_PATH, m_szPath);
    DDX_Text(pDX, IDC_SETTING, m_szSetting);
    DDX_Check(pDX, IDC_PREF_MOVE, m_fMove);
    DDX_Check(pDX, IDC_PREF_APPLYSECURITY, m_fApplySecurity);
    DDX_Radio(pDX, IDC_PREF_ORPHAN, m_iRemoval);
    //}}AFX_DATA_MAP
}

BOOL CRsopProp::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString sz;
    CString sz2;

    GetDlgItemText(IDC_GPO, sz);
    m_szGPO.Format(sz, m_pInfo->m_szGPO);

    GetDlgItemText(IDC_SETTING, sz);
    sz2.LoadString(IDS_SETTINGS + m_pInfo->m_nInstallationType);
    m_szSetting.Format(sz, sz2);

    GetDlgItemText(IDC_GROUP, sz);
    m_szGroup.Format(sz, m_pInfo->m_szGroup);

    m_szPath = m_pInfo->m_szPath;

    m_fMove = m_pInfo->m_fMoveType;

    m_fApplySecurity = m_pInfo->m_fGrantType;

    m_iRemoval = m_pInfo->m_nPolicyRemoval - 1;

    GetDlgItemText(IDC_PREF_TITLE, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_TITLE, sz2);

    GetDlgItemText(IDC_PREF_APPLYSECURITY, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_APPLYSECURITY, sz2);

    GetDlgItemText(IDC_PREF_MOVE, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_MOVE, sz2);

    CPropertyPage::OnInitDialog();

    return TRUE;
}


BEGIN_MESSAGE_MAP(CRsopProp, CPropertyPage)
    //{{AFX_MSG_MAP(CRsopProp)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsopProp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\rsopprop.h ===
#if !defined(AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_)
#define AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// rsopprop.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// rsopprop dialog

class CRSOPInfo;

class CRsopProp : public CPropertyPage
{
    DECLARE_DYNCREATE(CRsopProp)

// Construction
public:
    CRsopProp();
    ~CRsopProp();

    CRsopProp ** m_ppThis;
    CRSOPInfo * m_pInfo;

// Dialog Data
    //{{AFX_DATA(CRsopProp)
    enum { IDD = IDD_RSOP };
    CString m_szGroup;
    CString m_szGPO;
    CString m_szPath;
    CString m_szSetting;
    CString m_szFolder;
    BOOL    m_fMove;
    BOOL    m_fApplySecurity;
    int     m_iRemoval;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsopProp)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CRsopProp)
        // NOTE: the ClassWizard will add member functions here
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\result.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       result.cpp
//
//  Contents:   implementation of the result pane
//
//  Classes:    CResultPane
//
//  History:    03-17-1998   stevebl   Created
//              07-16-1998   rahulth   added calls to IGPEInformation::PolicyChanged()
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <shlobj.h>

#include <atlimpl.cpp>
#include <wbemcli.h>
#include "rsoputil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const int HeaderWidths [] =
{
    200,    //name
    60,    //size
    100,    //type
    100     //modified date
};

const int RSOPHeaderWidths [] =
{
    150,      // precedence
    200,      // redirected path
    100,      // group
    75,       // setting
    100,      // gpo
    60,      // exclusive
    50,      // move
    150       // policy removal
};

long CResultPane::lDataObjectRefCount = 0;

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"FDE_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

//+--------------------------------------------------------------------------
//
//  Function:   ExtractInternalFormat
//
//  Synopsis:   Returns a pointer to our private object format given an
//              LPDATAOBJECT
//
//  Arguments:  [lpDataObject] - pointer to a DATAOBJECT, generally from a
//                                MMC call.
//
//  Returns:    A pointer to INTERNAL, our internal object structure.
//              NULL - if the object doesn't contain one of our objects
//              (wasn't created by us)
//
//  History:    3-13-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's IComponent implementation

STDMETHODIMP CResultPane::GetResultViewType(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CResultPane::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CResultPane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            cookie = 0;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }
        
        switch(event)
        {
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal && pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow (cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_SELECT:
            if (pInternal)
                hr = OnSelect(pInternal->m_type, cookie, arg, param);
            else
                hr = S_FALSE;
            break;

        case MMCN_COLUMNS_CHANGED:
            // Let MMC do its default thing.
            hr = S_FALSE;
            break;

        case MMCN_COLUMN_CLICK:
            // retain column number and sort option flags so we can pass
            // them in to sort in the event we need to trigger a resort of
            // the result pane
            m_nSortColumn = arg;
            m_dwSortOptions = param;
            break;

        case MMCN_CONTEXTHELP:
            hr = OnContextHelp();
            break;

        // Note - Future expansion of notify types possible
        default:
            //perform the default action
            hr = S_FALSE;
            break;
        }

        if (pInternal)
        {
                FREE_INTERNAL(pInternal);
        }
    }

    return hr;
}

STDMETHODIMP CResultPane::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pConsoleVerb);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pScopePane)
        {
            ((IComponentData*)m_pScopePane)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
        }
    }

    return S_OK;
}

STDMETHODIMP CResultPane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    CComObject<CDataObject>* pObject = NULL;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if (!pObject)
        return E_UNEXPECTED;

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CResultPane);

CResultPane::CResultPane()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CResultPane);
    CResultPane::lDataObjectRefCount = 0;
    m_lViewMode = LVS_REPORT;
    m_nSortColumn = 0;
    m_dwSortOptions = 0;
    m_nIndex = 0;
    Construct();
}

CResultPane::~CResultPane()
{
#if DBG
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CResultPane);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);

    Construct();

    ASSERT(CResultPane::lDataObjectRefCount == 0);
}

void CResultPane::Construct()
{
#if DBG
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pScopePane = NULL;
    m_hCurrScopeItem = -1;
}

void CResultPane::LoadResources()
{
    // Load strings from resources
    int i, j;

    for (j = 0, i = IDS_FIRST_COL; i < IDS_LAST_COL; i++, j++)
        m_columns[j].LoadString(i);
    for (j = 0, i = IDS_FIRST_RSOP_COL; i < IDS_LAST_RSOP_COL; i++, j++)
        m_RSOP_columns[j].LoadString(i);
    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
}

HRESULT CResultPane::InitializeHeaders(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;
    int i;

    ASSERT(m_pHeader);

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    if (m_pScopePane->m_fRSOP && cookie != IDS_FOLDER_TITLE)
    {
        for (i = 0; i < RSOPCOLUMNID(IDS_LAST_RSOP_COL); i++)
            m_pHeader->InsertColumn(i, m_RSOP_columns[i], LVCFMT_LEFT, RSOPHeaderWidths[i]); //add the columns
    }
    else
    {
        for (i = 0; i < COLUMNID(IDS_LAST_COL); i++)
            m_pHeader->InsertColumn(i, m_columns[i], LVCFMT_LEFT, HeaderWidths[i]); //add the columns
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CResultPane::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    //we do not have any special commands on the menu
    return S_OK;
}

STDMETHODIMP CResultPane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    //we do not have any special commands on the menu
    return S_OK;
}

HRESULT CResultPane::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    //
    // If any code ever gets added here, make sure that IDS_FOLDER_TITLE cookies
    // are handled correctly
    //
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

// Result item property pages:
STDMETHODIMP CResultPane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    if (!m_pScopePane->m_fRSOP)
        return S_FALSE;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

        if (! pInternal)
                return S_FALSE;

    DWORD   cookie = pInternal->m_cookie;
    LONG    i;
    BOOL    fShowPage = FALSE;
    AFX_OLDPROPSHEETPAGE * pPsp;
    CRSOPInfo * pRSOPInfo;

    //it is one of the folders
    pRSOPInfo = &(m_RSOPData[cookie]);

    if (!pRSOPInfo->m_pRsopProp)   //make sure that the property page is not already up.
    {
        pRSOPInfo->m_pRsopProp = new CRsopProp;
        pRSOPInfo->m_pRsopProp->m_ppThis = &(pRSOPInfo->m_pRsopProp);
        pRSOPInfo->m_pRsopProp->m_pInfo = pRSOPInfo;
        pRSOPInfo->m_pRsopProp->m_szFolder = pRSOPInfo->m_pRsopProp->m_pInfo->m_szFolder;
        fShowPage = TRUE;
        pPsp = (AFX_OLDPROPSHEETPAGE *)&(pRSOPInfo->m_pRsopProp->m_psp);
    }

    if (fShowPage)  //show page if it is not already up.
    {
        hr = SetPropPageToDeleteOnClose (pPsp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProp = CreateThemedPropertySheetPage(pPsp);
            if (NULL == hProp)
                hr = E_UNEXPECTED;
            else
            {
                lpProvider->AddPage(hProp);
                hr = S_OK;
            }
        }
    }

    FREE_INTERNAL(pInternal);

    return hr;
}

// Result items property pages:
STDMETHODIMP CResultPane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    if (!m_pScopePane->m_fRSOP)
        return S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (! pInternal)
                return S_FALSE;

    MMC_COOKIE cookie = pInternal->m_cookie;
    HRESULT hr = S_FALSE;
    CError  error;

    if (CCT_RESULT == pInternal->m_type)
    {
        hr = S_OK;
    }

    FREE_INTERNAL(pInternal);
    return hr;
}

STDMETHODIMP CResultPane::CompareObjects(LPDATAOBJECT lpDataObjectA,
                                         LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CResultPane::Compare(LPARAM lUserParam,
                                  MMC_COOKIE cookieA,
                                  MMC_COOKIE cookieB,
                                  int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    // Retrieve the objects referred to by the two cookies and compare them
    // based upon the data that's associated with nCol.  (The values you
    // compare depends on which column the caller asks for.)
    CString szA, szB;
    CRSOPInfo &dataA = m_RSOPData[cookieA];
    CRSOPInfo &dataB = m_RSOPData[cookieB];

    switch (nCol)
    {
    case 0: // precedence
        *pnResult = dataA.m_nPrecedence - dataB.m_nPrecedence;
        return S_OK;
    case 1: // redirected path
        szA = dataA.m_szPath;
        szB = dataB.m_szPath;
        break;
    case 2: // group
        szA = dataA.m_szGroup;
        szB = dataB.m_szGroup;
        break;
    case 3: // GPO
        szA = dataA.m_szGPO;
        szB = dataB.m_szGPO;
        break;
    case 4: // setting
        szA.LoadString(dataA.m_nInstallationType + IDS_SETTINGS);
        szB.LoadString(dataB.m_nInstallationType + IDS_SETTINGS);
        break;
    case 5: // exclusive
        szA.LoadString(dataA.m_fGrantType ? IDS_YES : IDS_NO);
        szB.LoadString(dataB.m_fGrantType ? IDS_YES : IDS_NO);
        break;
    case 6: // move
        szA.LoadString(dataA.m_fMoveType ? IDS_YES : IDS_NO);
        szB.LoadString(dataB.m_fMoveType ? IDS_YES : IDS_NO);
        break;
    case 7: // policy removal
        szA.LoadString(IDS_ONPOLICYREMOVAL + dataA.m_nPolicyRemoval);
        szB.LoadString(IDS_ONPOLICYREMOVAL + dataB.m_nPolicyRemoval);
        break;
    }

    *pnResult = szA.CompareNoCase(szB);
    return S_OK;
}


STDMETHODIMP CResultPane::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    static CString sz;
    CString szExt;

    ASSERT(pResult != NULL);
    ASSERT(pResult->bScopeItem);

    if (pResult)
    {
        if (pResult->bScopeItem)
        {
            switch (pResult->nCol)
            {
            case 0: //display name
                if (IDS_FOLDER_TITLE == pResult->lParam)
                    sz.LoadString (IDS_FOLDER_TITLE);
                else
                    sz = m_pScopePane->m_FolderData[GETINDEX(pResult->lParam)].m_szDisplayname;
                break;
            case 1: //type
                sz = m_pScopePane->m_FolderData[GETINDEX(pResult->lParam)].m_szTypename;
                break;
            default:
                sz = TEXT("");
                break;
            }
        }
        else
        {
            CRSOPInfo &data = m_RSOPData[pResult->lParam];
            switch (pResult->nCol)
            {
            case 0: // precedence
                sz.Format(TEXT("(%u) %s"), data.m_nPrecedence, data.m_szFolder);
                break;
            case 1: // redirected path
                sz = data.m_szPath;
                break;
            case 2: // group
                sz = data.m_szGroup;
                break;
            case 3: // GPO
                sz = data.m_szGPO;
                break;
            case 4: // setting
                sz.LoadString(data.m_nInstallationType + IDS_SETTINGS);
                break;
            case 5: // exclusive
                sz.LoadString(data.m_fGrantType ? IDS_YES : IDS_NO);
                break;
            case 6: // move
                sz.LoadString(data.m_fMoveType ? IDS_YES : IDS_NO);
                break;
            case 7: // policy removal
                sz.LoadString(IDS_ONPOLICYREMOVAL + data.m_nPolicyRemoval);
                break;
            default:
                sz = TEXT("");
                break;
            }

        }
        pResult->str = (unsigned short *)((LPCOLESTR)sz);
    }

    return S_OK;
}

HRESULT CResultPane::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CResultPane::TestForRSOPData(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;
    ASSERT(m_pScopePane != NULL);

    // Test for RSOP data for this folder
    RESULTDATAITEM  resultItem;
    memset(&resultItem, 0, sizeof(resultItem));
    resultItem.mask = RDI_STR | RDI_PARAM;
    resultItem.str = MMC_CALLBACK;

    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    CString szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting");
    if (cookie && (cookie != IDS_FOLDER_TITLE))
    {
        szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting where id = \"");
        szQuery += g_szEnglishNames[GETINDEX(cookie)];
        szQuery += TEXT("\"");
    }
    BSTR strQuery = SysAllocString(szQuery);
    BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    if (n == 0)
    {
        hr = E_FAIL;
    }
cleanup:
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);

    return hr;
}

HRESULT CResultPane::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    // Note - arg is TRUE when it is time to enumerate
    
    //
    // If we received the show notification for the top level FR node, then
    // return S_FALSE and let MMC do its thing. We really have nothing to show
    // in the result pane in this case.
    //
    if (IDS_FOLDER_TITLE == cookie)
        return S_FALSE;
    
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pScopePane != NULL);
        m_pResult->SetViewMode(m_lViewMode);
        InitializeHeaders(cookie);
        m_hCurrScopeItem = m_pScopePane->m_FolderData[GETINDEX(cookie)].m_scopeID;
        if (m_pScopePane->m_fRSOP)
        {
            // Enumerate the RSOP data for this folder
            // and add a result item for each entry
            RESULTDATAITEM  resultItem;
            memset(&resultItem, 0, sizeof(resultItem));
            resultItem.mask = RDI_STR | RDI_PARAM;
            resultItem.str = MMC_CALLBACK;

            IWbemLocator * pLocator = NULL;
            IWbemServices * pNamespace = NULL;
            IWbemClassObject * pObj = NULL;
            IEnumWbemClassObject * pEnum = NULL;
            BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
            CString szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting where name = \"");
            szQuery += g_szEnglishNames[GETINDEX(cookie)];
            szQuery += TEXT("\"");
            BSTR strQuery = SysAllocString(szQuery);
            BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
            ULONG n = 0;
            hr = CoCreateInstance(CLSID_WbemLocator,
                                  0,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IWbemLocator,
                                  (LPVOID *) & pLocator);
            if (FAILED(hr))
            {
                goto cleanup;
            }
            hr = pLocator->ConnectServer(strNamespace,
                                         NULL,
                                         NULL,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL,
                                         &pNamespace);
            if (FAILED(hr))
            {
                goto cleanup;
            }

			// Set the proper security to encrypt the data
			hr = CoSetProxyBlanket(pNamespace,
								RPC_C_AUTHN_DEFAULT,
								RPC_C_AUTHZ_DEFAULT,
								COLE_DEFAULT_PRINCIPAL,
								RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
								RPC_C_IMP_LEVEL_IMPERSONATE,
								NULL,
								0);
			if (FAILED(hr))
			{
				goto cleanup;
			}

            // First perform the query
            hr = pNamespace->ExecQuery(strQueryLanguage,
                                       strQuery,
                                       WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                       NULL,
                                       &pEnum);
            if (FAILED(hr))
            {
                goto cleanup;
            }
            do
            {
                hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
                if (FAILED(hr))
                {
                    goto cleanup;
                }
                if (n > 0)
                {
                    // process the data
                    UINT    nPrecedence;
                    LPTSTR pszGPOName = NULL;
                    CString szGPOID;
                    UINT    nGroups = 0;
                    TCHAR * * rgszGroups = NULL;
                    UINT    nPaths = 0;
                    TCHAR * * rgszPaths = NULL;
                    BOOL    fGrantType;
                    BOOL    fMoveType;
                    UINT    nPolicyRemoval;
                    UINT    nInstallationType;
                    CString ResultantPath;
                    CString RedirectingGroup;

                    hr = GetParameter(pObj,
                                      TEXT("GPOID"),
                                      szGPOID);
                    hr = GetGPOFriendlyName(pNamespace,
                                            (LPTSTR)((LPCTSTR) szGPOID),
                                            strQueryLanguage,
                                            &pszGPOName);
                    hr = GetParameter(pObj,
                                      TEXT("Precedence"),
                                      nPrecedence);
                    hr = GetParameter(pObj,
                                      TEXT("GrantType"),
                                      fGrantType);
                    hr = GetParameter(pObj,
                                      TEXT("MoveType"),
                                      fMoveType);
                    hr = GetParameter(pObj,
                                      TEXT("PolicyRemoval"),
                                      nPolicyRemoval);
                    hr = GetParameter(pObj,
                                      TEXT("securityGroups"),
                                      nGroups,
                                      rgszGroups);
                    hr = GetParameter(pObj,
                                      TEXT("RedirectedPaths"),
                                      nPaths,
                                      rgszPaths);
                    hr = GetParameter(pObj,
                                      TEXT("installationType"),
                                      nInstallationType);
                    hr = GetParameter(pObj,
                                      TEXT("resultantPath"),
                                      ResultantPath);
                    hr = GetParameter(pObj,
                                      TEXT("redirectingGroup"),
                                      RedirectingGroup);
                    if (nInstallationType != 2)
                    {
                        // force a valid value
                        nInstallationType = 1;
                    }

                    if (nPaths != nGroups)
                    {
                        // If we don't have the same number of paths
                        // as groups then we have a problem.
                        hr = E_UNEXPECTED;
                    }
                     
                    
                    CString szDir;
                    CString szAcct;
                    CRSOPInfo & info = m_RSOPData[m_nIndex++];
                    info.m_nPrecedence = nPrecedence;
                    info.m_szPath = ResultantPath;
                   
                    if (STATUS_SUCCESS == GetFriendlyNameFromStringSid(
                        RedirectingGroup,
                        szDir,
                        szAcct))
                    {
                        if (!szDir.IsEmpty())
                            szAcct = szDir + '\\' + szAcct;
                    }
                    else    //just display the unfriendly string if the friendly name cannot be obtained
                    {
                        szAcct = RedirectingGroup;
                        szAcct.MakeUpper();
                    }

                    info.m_szGroup = szAcct;
                    info.m_szGPO = pszGPOName;
                    info.m_fGrantType = FALSE != fGrantType;
                    info.m_fMoveType = FALSE != fMoveType;
                    info.m_nPolicyRemoval = nPolicyRemoval;
                    info.m_nInstallationType = nInstallationType;
                    info.m_szFolder = m_pScopePane->m_FolderData[GETINDEX(cookie)].m_szDisplayname;
                    resultItem.lParam = m_nIndex - 1;;
                    m_pResult->InsertItem(&resultItem);

                    // erase allocated data
                    OLESAFE_DELETE(pszGPOName);
                    while (nPaths--)
                    {
                        OLESAFE_DELETE(rgszPaths[nPaths]);
                    }
                    OLESAFE_DELETE(rgszPaths);
                    while (nGroups--)
                    {
                        OLESAFE_DELETE(rgszGroups[nGroups]);
                    }
                    OLESAFE_DELETE(rgszGroups);

                }
            } while (n > 0);
        cleanup:
            SysFreeString(strQueryLanguage);
            SysFreeString(strQuery);
            SysFreeString(strNamespace);
            if (pObj)
            {
                pObj->Release();
            }
            if (pEnum)
            {
                pEnum->Release();
            }
            if (pNamespace)
            {
                pNamespace->Release();
            }
            if (pLocator)
            {
                pLocator->Release();
            }
            m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);

        }
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);
    }

    return hr;
}

HRESULT CResultPane::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    //
    // If any code ever gets added here, make sure that IDS_FOLDER_TITLE cookies
    // are handled correctly
    //
    return S_OK;
}

HRESULT CResultPane::OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick)
{
    //
    // If any code ever gets added here, make sure that IDS_FOLDER_TITLE cookies
    // are handled correctly
    //
    return S_FALSE;
}

HRESULT CResultPane::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    //
    // If any code ever gets added here, make sure that IDS_FOLDER_TITLE cookies
    // are handled correctly
    //
    return S_OK;
}

HRESULT CResultPane::OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (m_pConsoleVerb)
    {
        if (m_pScopePane->m_fRSOP)
        {
            if (type == CCT_RESULT)
            {
                // Set the default verb to properties
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

                // Enable the properties verb.
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            }
            else
            {
                // Set the default verb to open
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

                // disable the properties verb
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
            }
        }
        else
        {
            if (type == CCT_SCOPE)
            {
                // Set the default verb to open
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

                if (IDS_FOLDER_TITLE != cookie)
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, HIDDEN, TRUE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnPropertyChange(LPARAM param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    // UNDONE - Make any updates to internal structures or visual
    // representation that might be necessary.
    m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
    return hr;
}

HRESULT CResultPane::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    if (m_pScopePane->m_fRSOP)
    {
        return S_OK;
    }
    INTERNAL* pInternal = ExtractInternalFormat (lpDataObject);

    if (!pInternal)
        return E_UNEXPECTED;

    if (m_hCurrScopeItem == pInternal->m_scopeID)
    {
        //also update the folders
        m_pScopePane->m_pScope->DeleteItem (pInternal->m_scopeID, FALSE);
        m_pScopePane->EnumerateScopePane (pInternal->m_cookie, pInternal->m_scopeID);

        //reenumerate the scope pane
        m_pConsole->SelectScopeItem (pInternal->m_scopeID);
    }
    FREE_INTERNAL (pInternal);
    return S_OK;
}

HRESULT CResultPane::OnContextHelp(void)
{
    LPOLESTR lpHelpTopic;
    LPCTSTR  pszHelpTopic = L"gpedit.chm::/Folder.htm";
    ULONG ulNoBytes = sizeof(pszHelpTopic);

    ASSERT (m_pDisplayHelp);

    lpHelpTopic = (LPOLESTR) CoTaskMemAlloc (ulNoBytes);

    if (!lpHelpTopic)
    {
        DbgMsg((TEXT("CScopePane::OnContexHelp: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr;
    
    hr = StringCbCopy(lpHelpTopic, ulNoBytes, pszHelpTopic);
    
    ASSERT(SUCCEEDED(hr));
    
    return m_pScopePane->m_pDisplayHelp->ShowTopic (lpHelpTopic);
}

// This code is needed to ensure that property pages get cleaned up properly.
// This ensures that when the property sheet is closed all my of property
// pages that are associated with that property sheet will get deleted.
LPFNPSPCALLBACK _MMCHookProp;

UINT CALLBACK HookPropertySheetProp(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookProp(hwnd, uMsg, ppsp);
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        delete (CPropertyPage *) ppsp->lParam;
        return TRUE;
    default:
        break;
    }
    return i;
}

LRESULT SetPropPageToDeleteOnClose(void * vpsp)
{
    HRESULT hr = MMCPropPageCallback(vpsp);
    if (SUCCEEDED(hr))
    {
        if (vpsp == NULL)
            return E_POINTER;

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

        if ((void*)psp->pfnCallback == (void*)HookPropertySheetProp)
            return E_UNEXPECTED;

        _MMCHookProp = psp->pfnCallback;

        psp->pfnCallback = HookPropertySheetProp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <wbemcli.h>
#include "rsoputil.h"
// Something in the build environment is causing this
// to be #defined to a version before 0x0500 and
// that causes the ConvertStringSecurityDescriptor... function
// to be undefined.
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#include "sddl.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        delete szData;
        szData = NULL;
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            ULONG ulNoChars;

            ulNoChars = _tcslen(var.bstrVal) + 1;
            szData = (TCHAR *) OLEALLOC(sizeof(TCHAR) * ulNoChars);
            if (szData)
            {
                hr = StringCchCopy(szData, ulNoChars, var.bstrVal);
                if (FAILED(hr)) 
                {
                    OLESAFE_DELETE(szData);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        szData = "";
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = var.bstrVal;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (bstrData)
    {
        SysFreeString(bstrData);
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
        if (NULL == bstrData)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        fData = var.bVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        hrData = (HRESULT) var.lVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ulData = var.ulVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid)
{
    TCHAR * sz = NULL;
    memset(&guid, 0, sizeof(GUID));
    HRESULT hr = GetParameter(pInst, szParam, sz);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(sz, &guid);
    }
    if (sz)
    {
        OLESAFE_DELETE(sz);
    }
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    ui = 0;
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ui = (HRESULT) var.uiVal;
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of guids and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, GUID * &rgGuid)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgGuid = (GUID *)OLEALLOC(sizeof(GUID) * uiCount);
            if (rgGuid)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    hr = CLSIDFromString(rgData[ui], &rgGuid[ui]);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of strings and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, TCHAR ** &rgszData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgszData = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * uiCount);
            if (rgszData)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    //
                    // Allocate memory and copy the string
                    //
                    OLESAFE_COPYSTRING(rgszData[ui], rgData[ui]);
                    
                    if ( ! rgszData[ui] )
                    {
                        //
                        // If we failed one allocation, free all the preceding
                        // allocations
                        //
                        for (int iCurrent = ui + 1; iCurrent < uiCount; iCurrent++ )
                        {
                            OLESAFE_DELETE( rgszData[iCurrent] );
                        }

                        OLESAFE_DELETE( rgszData );

                        uiCount = 0;
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd)
{
    VARIANT var;
    HRESULT hr = S_OK;
    if (psd)
    {
        LocalFree(psd);
        psd = NULL;
    }
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        PSECURITY_DESCRIPTOR psdTemp;
        BOOL f = ConvertStringSecurityDescriptorToSecurityDescriptor(
                    var.bstrVal,
                    //(LPCTSTR)var.parray->pvData,
                    SDDL_REVISION_1,
                    &psd,
                    NULL);
        if (!f)
        {
            // it failed
            // could call GetLastError here to figure out why
            // but at the moment I don't really care
        }
        if (!IsValidSecurityDescriptor(psd))
        {
            LocalFree(psd);
            psd = NULL;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID, BSTR pLanguage,
                           LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    ULONG ulNoChars = lstrlen(lpGPOID) + 50;

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpQuery)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    WCHAR szQuery[] = L"SELECT name, id FROM RSOP_GPO where id=\"%s\"";

    hr = StringCchPrintf (lpQuery, ulNoChars, szQuery, lpGPOID);
    if (FAILED(hr)) 
    {
        goto Exit;
    }

    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Save the name
    //

    ULONG ulNoCharsGPOName;
    
    ulNoCharsGPOName = lstrlen(varGPOName.bstrVal) + 1;
    *pGPOName = (LPTSTR) LocalAlloc (LPTR,  ulNoCharsGPOName * sizeof(TCHAR));
    if (!(*pGPOName))
    {
        goto Exit;
    }

    hr = StringCchCopy (*pGPOName, ulNoCharsGPOName, varGPOName.bstrVal);
    ASSERT(SUCCEEDED(hr));

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = StringCchCopy(pwszPathBuf, cchPathBuf, pwszExpandedPath);
                    ASSERT(SUCCEEDED(hr));
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\scope.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cpp
//
//  Contents:   implementation of the scope pane
//
//  Classes:    CScopePane
//
//  History:    03-14-1998   stevebl   Created
//              07-16-1998   rahulth   Added calls to IGPEInformation::PolicyChanged
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <shlobj.h>
#include <winnetwk.h>

// Comment this line to stop trying to set the main snapin icon in the
// scope pane.
#define SET_SCOPE_ICONS 1


// Un-comment the next line to persist snap-in related data.  (This really
// shouldn't be necessary since I get all my info from my parent anyway.)
// #define PERSIST_DATA 1

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CScopePane);

CScopePane::CScopePane()
{
    HKEY hKey;
    DWORD dwDisp;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopePane);

    m_bIsDirty = FALSE;

    m_fRSOP = FALSE;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIPropertySheetProvider = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPEInformation = NULL;
    m_pIRSOPInformation = NULL;
}

CScopePane::~CScopePane()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopePane);
    ASSERT(m_pScope == NULL);
    ASSERT(CResultPane::lDataObjectRefCount == 0);
}
#include <msi.h>

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::CreateNestedDirectory
//
//  Synopsis:   Ensures the existance of a path.  If any directory along the
//              path doesn't exist, this routine will create it.
//
//  Arguments:  [lpDirectory]          - path to the leaf directory
//              [lpSecurityAttributes] - security attributes
//
//  Returns:    1 on success
//              0 on failure
//
//  History:    3-17-1998   stevebl     Copied from ADE
//
//  Notes:      Originally written by EricFlo
//
//---------------------------------------------------------------------------

UINT CScopePane::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    HRESULT hr;

    hr = StringCchCopy(szDirectory, sizeof(szDirectory)/sizeof(szDirectory[0]), lpDirectory);
    if (FAILED(hr)) 
    {
        SetLastError(HRESULT_CODE(hr));
        return 0;
    }


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}

STDMETHODIMP CScopePane::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, reinterpret_cast<void**>(&m_pDisplayHelp));
    ASSERT(hr == S_OK);

#ifdef SET_SCOPE_ICONS
    LPIMAGELIST lpScopeImage;
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));
    lpScopeImage->Release();
#endif
    return S_OK;
}

STDMETHODIMP CScopePane::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CResultPane>* pObject;
    HRESULT hr = CComObject<CResultPane>::CreateInstance(&pObject);

    if ( FAILED(hr) )
    {
        return hr;
    }

    ASSERT(pObject != NULL);

    m_pResultPane = pObject;


    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CScopePane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;
    UINT    i;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        // perform any action needed as a result of result property changes
        hr = OnProperties(param);
    }
    else if ( event == MMCN_REMOVE_CHILDREN )
    {
        //
        // In RSoP, we may get called to refresh the scope pane when the query
        // is re-executed -- if this happens, current nodes will be removed and
        // we must reset all of our cached information.  We reset the relevant
        // information below
        //

        if ( ((HSCOPEITEM)arg != NULL) && m_fRSOP && (m_pIRSOPInformation != NULL) )
        {
            m_pIRSOPInformation->Release();
                    
            m_pIRSOPInformation = NULL;
        }
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        MMC_COOKIE cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_fRSOP)
        {
            WCHAR szBuffer[MAX_DS_PATH];
            if (m_pIRSOPInformation == NULL)
            {
                IRSOPInformation * pIRSOPInformation;
                hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                reinterpret_cast<void**>(&pIRSOPInformation));
                if (SUCCEEDED(hr))
                {
                    m_pIRSOPInformation = pIRSOPInformation;
                    m_pIRSOPInformation->AddRef();
                    /*  extract the namespace here */
                    hr = m_pIRSOPInformation->GetNamespace(GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                    if (SUCCEEDED(hr))
                    {
                        m_szRSOPNamespace = szBuffer;
                    }
                    pIRSOPInformation->Release();
                }
            }
        }
        else
        {
            if (m_pIGPEInformation == NULL)
            {
                IGPEInformation * pIGPEInformation;
                hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                reinterpret_cast<void**>(&pIGPEInformation));
                if (SUCCEEDED(hr))
                {
                    GROUP_POLICY_OBJECT_TYPE gpoType;
                    hr = pIGPEInformation->GetType(&gpoType);
                    if (SUCCEEDED(hr))
                    {
                        if (gpoType == GPOTypeDS)
                        {
                            WCHAR szBuffer[MAX_PATH];
                            do
                            {
                                AFX_MANAGE_STATE (AfxGetStaticModuleState());
                                hr = pIGPEInformation->GetFileSysPath(GPO_SECTION_USER, szBuffer, MAX_PATH);
                                if (FAILED(hr))
                                    break;

                                m_pIGPEInformation = pIGPEInformation;
                                m_pIGPEInformation->AddRef();
                                m_szFileRoot = szBuffer;
                                m_szFileRoot += L"\\Documents & Settings";
                                CreateNestedDirectory (((LPOLESTR)(LPCOLESTR)(m_szFileRoot)), NULL);

                                //initialize the folder data.
                                for (i = IDS_DIRS_START; i < IDS_DIRS_END; i++)
                                {
                                    m_FolderData[GETINDEX(i)].Initialize (i,
                                                                          (LPCTSTR) m_szFileRoot);
                                }

                                ConvertOldStyleSection (m_szFileRoot);
                            } while (0);
                        }
                        else
                        {
                            // force this to fail
                            hr = E_FAIL;
                        }
                    }
                    pIGPEInformation->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_EXPAND:
                {
                    hr = OnExpand(cookie, arg, param);
                }
                break;

            case MMCN_SELECT:
                hr = OnSelect(cookie, arg, param);
                break;

            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(cookie, arg, param);
                break;

            default:
                //perform the default action
                hr = S_FALSE;
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CScopePane::Destroy()
{
    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pDisplayHelp);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIPropertySheetProvider);
    SAFE_RELEASE(m_pIGPEInformation);
    SAFE_RELEASE(m_pIRSOPInformation);

    return S_OK;
}

STDMETHODIMP CScopePane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    CComObject<CDataObject>* pObject = NULL;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if (!pObject)
        return E_UNEXPECTED;

    // Save cookie and type for delayed rendering
    pObject->SetID (m_FolderData[GETINDEX(cookie)].m_scopeID);
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CScopePane::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return S_OK;
}

STDMETHODIMP CScopePane::IsDirty()
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CScopePane::Load(IStream *pStm)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // UNDONE - Read data from the stream here.
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
#else
    return S_OK;
#endif
}

STDMETHODIMP CScopePane::Save(IStream *pStm, BOOL fClearDirty)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // UNDONE - Write data to the stream here.
    // on error, return STG_E_CANTSAVE;
#endif
    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CScopePane::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    // UNDONE - set the size of the string to be saved
    ULONG cb = 0;
    // Set the size of the string to be saved
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CScopePane::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CScopePane::OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}


HRESULT CScopePane::OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)    //MMC never sends arg = FALSE (for collapse)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
                           param);
    }

    return S_OK;
}

HRESULT CScopePane::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CScopePane::OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CScopePane::OnProperties(LPARAM param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CScopePane::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szFullPathname;
    CString szParent;
    SCOPEDATAITEM scopeItem;
    FILETIME ftCurr;
    LONG i;
    int     cChildren = 0;
    DWORD   myDocsFlags = REDIR_DONT_CARE;
    DWORD   myPicsFlags = REDIR_DONT_CARE;

    memset(&scopeItem, 0, sizeof(SCOPEDATAITEM));

    CHourglass hourglass;   //this may take some time, so put up an hourglass

    GetSystemTimeAsFileTime (&ftCurr);

    //set the common members for the scope pane items
    scopeItem.mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;
    #ifdef SET_SCOPE_ICONS
    scopeItem.mask |= SDI_IMAGE | SDI_OPENIMAGE;
    scopeItem.nImage = IMG_CLOSEDBOX;
    scopeItem.nOpenImage = IMG_OPENBOX;
    #endif
    scopeItem.relativeID = pParent;
    scopeItem.displayname = MMC_CALLBACK;

    if (m_fExtension)
    {
        switch(cookie)
        {
        case NULL:  //getting the folder
        // if we're an extension then add a root folder to hang everything off of
            if (m_fRSOP)
            {
                // make sure that nodes don't get enumerated if they contain no data
                if (FAILED(m_pResultPane->TestForRSOPData(cookie)))
                {
                    if (m_pIRSOPInformation) 
                    {
                        m_pIRSOPInformation->Release();
                        m_pIRSOPInformation = NULL;
                    }
                    return;
                }
            }
            scopeItem.lParam = IDS_FOLDER_TITLE;    //use resource id's as cookies
            scopeItem.cChildren = 1;
            m_pScope->InsertItem(&scopeItem);
            break;
        case IDS_FOLDER_TITLE:
            for (i = IDS_LEVEL1_DIRS_START; i < IDS_LEVEL1_DIRS_END; i++)
            {
                BOOL fInsert = TRUE;
                if (m_fRSOP)
                {
                    if (FAILED(m_pResultPane->TestForRSOPData(i)))
                    {
                        fInsert = FALSE;
                    }
                }
                if (fInsert)
                {
                    scopeItem.lParam = i;
                    m_FolderData[GETINDEX(i)].Initialize(i,
                                                         (LPCTSTR) m_szFileRoot
                                                         );
                    if (i == IDS_MYDOCS && !m_fRSOP)
                    {
                        //
                        // Show the My Pictures folder only if it does not follow MyDocs.
                        // and only if there is no registry setting overriding the hiding behavior
                        // for My Pics
                        //
                        if (AlwaysShowMyPicsNode())
                        {
                            cChildren = 1;
                            m_FolderData[GETINDEX(i)].m_bHideChildren = FALSE;
                        }
                        else
                        {
                            m_FolderData[GETINDEX(IDS_MYPICS)].Initialize(IDS_MYPICS,
                                                                          (LPCTSTR) m_szFileRoot
                                                                          );
                            m_FolderData[GETINDEX(i)].LoadSection();
                            m_FolderData[GETINDEX(IDS_MYPICS)].LoadSection();
                            myDocsFlags = m_FolderData[GETINDEX(i)].m_dwFlags;
                            myPicsFlags = m_FolderData[GETINDEX(IDS_MYPICS)].m_dwFlags;
                            if (((REDIR_DONT_CARE & myDocsFlags) && (REDIR_DONT_CARE & myPicsFlags)) ||
                                ((REDIR_FOLLOW_PARENT & myPicsFlags) && (!(REDIR_DONT_CARE & myDocsFlags)))
                                )
                            {
                                cChildren = 0;
                                m_FolderData[GETINDEX(i)].m_bHideChildren = TRUE;
                            }
                            else
                            {
                                cChildren = 1;
                                m_FolderData[GETINDEX(i)].m_bHideChildren = FALSE;
                            }
                        }
                    }
                    scopeItem.cChildren = cChildren;    //only My Docs will possibly have children
                    m_pScope->InsertItem(&scopeItem);
                    m_FolderData[GETINDEX(i)].SetScopeItemID(scopeItem.ID);
                }
                if (IDS_MYDOCS == i && m_fRSOP  && SUCCEEDED(m_pResultPane->TestForRSOPData(IDS_MYPICS)))
                {
                    // In RSOP mode we put My Pictures after My Documents
                    // instead of under it.  Otherwise the results pane
                    // for My Documents would contain a folder along with
                    // the data and it would look very odd.
                    scopeItem.lParam = IDS_MYPICS;
                    scopeItem.cChildren = 0;
                    m_pScope->InsertItem(&scopeItem);
                    m_FolderData[GETINDEX(IDS_MYPICS)].Initialize (IDS_MYPICS,
                                                                   (LPCTSTR) m_szFileRoot
                                                                   );
                    m_FolderData[GETINDEX(IDS_MYPICS)].SetScopeItemID(scopeItem.ID);
                }
            }
            break;
        case IDS_MYDOCS:    //of all levels 1 folder, only MyDocs has children
            if (!m_fRSOP && !(m_FolderData[GETINDEX(IDS_MYDOCS)].m_bHideChildren))
            {
                scopeItem.lParam = IDS_MYPICS;
                scopeItem.cChildren = 0;
                m_pScope->InsertItem(&scopeItem);
                m_FolderData[GETINDEX(IDS_MYPICS)].Initialize (IDS_MYPICS,
                                                               (LPCTSTR) m_szFileRoot
                                                               );
                m_FolderData[GETINDEX(IDS_MYPICS)].SetScopeItemID(scopeItem.ID);
            }
            break;
        }
    }
}


STDMETHODIMP CScopePane::GetSnapinDescription(LPOLESTR * lpDescription)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpDescription, L"description");
    return S_OK;
}

STDMETHODIMP CScopePane::GetProvider(LPOLESTR * lpName)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpName, L"provider");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinVersion(LPOLESTR * lpVersion)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpVersion, L"version");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinImage(HICON * hAppIcon)
{
    // UNDONE
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetStaticFolderImage(HBITMAP * hSmallImage,
                             HBITMAP * hSmallImageOpen,
                             HBITMAP * hLargeImage,
                             COLORREF * cMask)
{
    // UNDONE
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DbgMsg((TEXT("CScopePane::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

STDMETHODIMP CScopePane::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONG i;
    ASSERT(pScopeDataItem != NULL);

    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (IDS_FOLDER_TITLE == pScopeDataItem->lParam)
    {
        m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        pScopeDataItem->displayname = L"???";
        if (-1 != (i = GETINDEX(pScopeDataItem->lParam)))
            pScopeDataItem->displayname = (unsigned short*)((LPCOLESTR)(m_FolderData[i].m_szDisplayname));
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CScopePane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    
    if (! pInternal)
        return S_FALSE;

    DWORD   cookie = pInternal->m_cookie;
    LONG    i;
    BOOL    fShowPage = FALSE;
    AFX_OLDPROPSHEETPAGE * pPsp;
    AFX_OLDPROPSHEETPAGE * pPspSettings;
    CFileInfo* pFileInfo;

    //it is one of the folders
    i = GETINDEX (cookie);
    pFileInfo = &(m_FolderData[i]);

    if (!pFileInfo->m_pRedirPage)   //make sure that the property page is not already up.
    {
        pFileInfo->m_pRedirPage = new CRedirect(cookie);
        pFileInfo->m_pRedirPage->m_ppThis = &(pFileInfo->m_pRedirPage);
        pFileInfo->m_pRedirPage->m_pScope = this;
        pFileInfo->m_pRedirPage->m_pFileInfo = pFileInfo;
        fShowPage = TRUE;
        pPsp = (AFX_OLDPROPSHEETPAGE *)&(pFileInfo->m_pRedirPage->m_psp);
        //create the settings page;
        pFileInfo->m_pSettingsPage = new CRedirPref();
        pFileInfo->m_pSettingsPage->m_ppThis = &(pFileInfo->m_pSettingsPage);
        pFileInfo->m_pSettingsPage->m_pFileInfo = pFileInfo;
        pPspSettings = (AFX_OLDPROPSHEETPAGE *)&(pFileInfo->m_pSettingsPage->m_psp);
    }

    if (fShowPage)  //show page if it is not already up.
    {
        hr = SetPropPageToDeleteOnClose (pPsp);
        if (SUCCEEDED (hr))
            hr = SetPropPageToDeleteOnClose (pPspSettings);

        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProp = CreateThemedPropertySheetPage(pPsp);
            HPROPSHEETPAGE hPropSettings = CreateThemedPropertySheetPage(pPspSettings);
            if (NULL == hProp || NULL == hPropSettings )
                hr = E_UNEXPECTED;
            else
            {
                lpProvider->AddPage(hProp);
                lpProvider->AddPage (hPropSettings);
                hr = S_OK;
            }
        }
    }

    FREE_INTERNAL(pInternal);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    // scope panes don't have property pages in RSOP mode
    if (m_fRSOP)
    {
        return S_FALSE;
    }
    //the only property sheets we are presenting right now are those
    //for built-in folder redirection
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    
    if (! pInternal)
        return S_FALSE;
    
    MMC_COOKIE cookie = pInternal->m_cookie;
    HRESULT hr = S_FALSE;
    CError  error;

    if (CCT_SCOPE == pInternal->m_type)
    {
        if (SUCCEEDED(m_FolderData[GETINDEX(cookie)].LoadSection()))
            hr = S_OK;
        else
        {
            error.ShowConsoleMessage (m_pConsole, IDS_SECTIONLOAD_ERROR,
                                      m_FolderData[GETINDEX(cookie)].m_szDisplayname);
            hr = S_FALSE;
        }
    }

    FREE_INTERNAL(pInternal);
    return hr;
}

BOOL CScopePane::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    
    if (! pInternal)
        return bResult;

    if (pInternal->m_type == CCT_SCOPE)
        bResult = TRUE;

    FREE_INTERNAL(pInternal);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CScopePane::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG * pInsertionAllowed)
{
    //we do not have any commands on the menu.
    return S_OK;
}

STDMETHODIMP CScopePane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    //we do not have any commands on the menu
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData);
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, GUID * &rgGuid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, TCHAR ** &rgszData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd);

//+--------------------------------------------------------------------------
//
//  Function:   GetGPOFriendlyName
//
//  Synopsis:
//
//  Arguments:  [pIWbemServices] -
//              [lpGPOID]        -
//              [pLanguage]      -
//              [pGPOName]       -
//              [pGPOPath]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    01-26-2000   stevebl   Stolen from code written by EricFlo
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID,
                           BSTR pLanguage,
                           LPTSTR *pGPOName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\secpath.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    secpath.cxx

Abstract:

    this file contains the code for the dialog that is used for associating
    security groups with paths.

Author:

    Rahul Thombre (RahulTh) 4/14/1998

Revision History:

    4/14/1998   RahulTh

    Created this module.

--*/

#include "precomp.hxx"

//
//mapping between help ids and controls ids for this dialog
//
const DWORD g_aHelpIDMap_IDD_SECPATH[] =
{
    IDC_SECPATH_ICON,       IDH_DISABLEHELP,
    IDC_SECPATH_DESC,       IDH_DISABLEHELP,
    IDC_SECPATH_SECGROUP,   IDH_DISABLEHELP,
    IDC_EDIT_SECGROUP,      IDH_EDIT_SECGROUP,
    IDC_BROWSE_SECGROUP,    IDH_BROWSE_SECGROUP,
    IDC_SECPATH_TARGET,     IDH_DISABLEHELP,
    0,                      0
};

///////////////////////////
/// Construction

CSecGroupPath::CSecGroupPath (CWnd *    pParent,
                              UINT      cookie,
                              LPCTSTR   szFolderName,
                              LPCTSTR   szGroupName /*=NULL*/,
                              LPCTSTR   szGroupSidStr /*=NULL*/,
                              LPCTSTR   szTarget /*= NULL*/)
    : CDialog(CSecGroupPath::IDD, pParent), m_redirPath (cookie), m_cookie (cookie)
{
    m_szFolderName = szFolderName;
    m_szGroup = szGroupName;
    m_szSidStr = szGroupSidStr;
    m_szTarget = szTarget;
    if (! m_szTarget.IsEmpty())
    {
        m_szTarget.TrimLeft();
        m_szTarget.TrimRight();
        m_szTarget.TrimRight(L'\\');
    }
    m_bPathValid = FALSE;
    m_iCurrType = -1;
}

/////////////////////////
///Overrides

void CSecGroupPath::DoDataExchange (CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecGroupPath)
    DDX_Control(pDX, IDC_EDIT_SECGROUP, m_EditSecGroup);
    DDX_Control(pDX, IDC_BROWSE_SECGROUP, m_btnBrowseSecGroup);
    DDX_Control(pDX, IDC_SECPATH_PLACEHOLDER, m_placeHolder);
    //}}AFX_DATA_MAP
}

/////////////////////
/// Message maps
BEGIN_MESSAGE_MAP(CSecGroupPath, CDialog)
    //{{AFX_MSG_MAP(CSecGroupPath)
    ON_BN_CLICKED (IDC_BROWSE_SECGROUP, OnBrowseGroups)
    ON_EN_UPDATE (IDC_EDIT_SECGROUP, OnSecGroupUpdate)
    ON_EN_KILLFOCUS (IDC_EDIT_SECGROUP, OnSecGroupKillFocus)
    ON_MESSAGE (WM_PATH_TWEAKED, OnPathTweak)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CSecGroupPath::OnInitDialog ()
{
    CError  error (this);

    CDialog::OnInitDialog();

    //
    // Make sure that the supplied path is parseable into one of the known
    // types
    //
    if (! m_szTarget.IsEmpty())
        m_redirPath.Load ((LPCTSTR) m_szTarget);    // This will always succeed if m_szTarget is not empty

    m_pathChooser.Instantiate (m_cookie,
                               this,
                               &m_placeHolder,
                               (const CRedirPath *) &m_redirPath,
                               SWP_SHOWWINDOW
                               );

    m_EditSecGroup.SetWindowText (m_szGroup);
    m_EditSecGroup.SetSel (0, -1, FALSE);
    m_EditSecGroup.SetFocus();
    SetOKState();

    return FALSE;    //returning FALSE since we are setting the focus to the edit box
}

void CSecGroupPath::OnOK ()
{
    CError      error(this);
    CString     szRoot;
    CString     szSuffix;
    CRedirPath  newPath (m_cookie);
    BOOL        bStatus = TRUE;
    UINT        pathType;

    //first check if we have a valid group.
    OnSecGroupKillFocus();

    //if the target is not a UNC path, try to convert it to one.
    m_pathChooser.OnRootKillFocus();

    if (!m_fValidSid)
    {
        error.ShowMessage (IDS_NOSECURITY_INFO);
        return;
    }

    m_EditSecGroup.GetWindowText (m_szGroup);
    m_szGroup.TrimLeft();
    m_szGroup.TrimRight();

    m_szSidStr.TrimLeft();
    m_szSidStr.TrimRight();
    m_szSidStr.MakeLower();

    m_pathChooser.GetRoot (szRoot);
    pathType = m_pathChooser.GetType();

    bStatus = TRUE;
    if (m_redirPath.IsPathDifferent (pathType, (LPCTSTR)szRoot))
    {
        // The path has changed, so use the new suffix
        newPath.GenerateSuffix (szSuffix, m_cookie, pathType);
        bStatus = newPath.Load (pathType, (LPCTSTR) szRoot, (LPCTSTR) szSuffix);
        if (bStatus)
            newPath.GeneratePath (m_szTarget);
    }
    else
    {
        m_redirPath.GeneratePath (m_szTarget);
    }

    //check if all the data has been provided.
    if (! bStatus               ||
        m_szTarget == TEXT("*") ||   //this particular check is very important -- see code for CFileInfo::LoadSection to see why
        m_szGroup.IsEmpty())
    {
        error.ShowMessage (IDS_INVALID_GROUPPATH);
    }
    else if (pathType != IDS_USERPROFILE_PATH &&
             ! PathIsUNC ((LPCTSTR) m_szTarget)
             )
    {
        error.SetStyle (MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
        error.SetTitle (IDS_DEFAULT_WARNING_TITLE);
        if (IDYES == error.ShowMessage (IDS_PATHNOTUNC_WARNING))
        {
            CDialog::OnOK();
        }
    }
    else
    {
        CDialog::OnOK();
    }
}

void
CSecGroupPath::OnCancel (void)
{
    m_pathChooser.OnCancel();
    CDialog::OnCancel();
}

//browse the security groups
void CSecGroupPath::OnBrowseGroups ()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CError                  error(this);
   PCWSTR                  apwszAttribs[] =
                           {
                              L"ObjectSid"
                           };
   DWORD                   dwError = ERROR_SUCCESS;
   HRESULT                 hr;
   IDsObjectPicker       * pDsObjectPicker = NULL;
   DSOP_INIT_INFO          InitInfo;
   const ULONG             cbNumScopes = 3;
   DSOP_SCOPE_INIT_INFO    ascopes[cbNumScopes];
   IDataObject           * pdo = NULL;
   STGMEDIUM               stgmedium = {
                              TYMED_HGLOBAL,
                              NULL
                           };
   UINT                    cf = 0;
   PDS_SELECTION_LIST      pDsSelList = NULL;
   FORMATETC               formatetc = {
                              (CLIPFORMAT)cf,
                              NULL,
                              DVASPECT_CONTENT,
                              -1,
                              TYMED_HGLOBAL
                           };
   PDS_SELECTION           pDsSelection = NULL;
   BOOL                    bAllocatedStgMedium = FALSE;
   SAFEARRAY             * pVariantArr = NULL;
   PSID                    pSid = NULL;
   CString                 szDomain;
   CString                 szAcct;
   SID_NAME_USE            eUse;


   hr = CoInitialize (NULL);

   if (SUCCEEDED (hr))
   {
       hr = CoCreateInstance (CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) & pDsObjectPicker
                              );
   }

   if (FAILED(hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }


   //Initialize the scopes
   ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

   ascopes[0].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
   ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS |
                                       DSOP_FILTER_UNIVERSAL_GROUPS_DL  |
                                       DSOP_FILTER_UNIVERSAL_GROUPS_SE  |
                                       DSOP_FILTER_GLOBAL_GROUPS_DL |
                                       DSOP_FILTER_GLOBAL_GROUPS_SE;
   ascopes[0].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
       DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

   ascopes[1].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
   ascopes[1].FilterFlags.Uplevel.flBothModes =
      ascopes[0].FilterFlags.Uplevel.flBothModes;
   ascopes[1].FilterFlags.Uplevel.flNativeModeOnly =
       ascopes[0].FilterFlags.Uplevel.flNativeModeOnly;

   ascopes[2].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[2].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS |
                                       DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

   //Populate the InitInfo structure that is used to initialize the object
   //picker.
   ZeroMemory (&InitInfo, sizeof (InitInfo));

   InitInfo.cbSize = sizeof (InitInfo);
   InitInfo.cDsScopeInfos = cbNumScopes;
   InitInfo.aDsScopeInfos = ascopes;
   InitInfo.cAttributesToFetch = 1;
   InitInfo.apwzAttributeNames = apwszAttribs;

   hr = pDsObjectPicker->Initialize (&InitInfo);

   if (FAILED (hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }

   hr = pDsObjectPicker->InvokeDialog (this->m_hWnd, &pdo);

   if (FAILED(hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }

   if (S_FALSE == hr)   //the user hit cancel
      goto BrwsGrp_CleanupAndQuit;

   //if we are here, the user chose, OK, so find out what group was chosen
   cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

   if (0 == cf)
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   //set the clipformat for the formatetc structure
   formatetc.cfFormat = (CLIPFORMAT)cf;

   hr = pdo->GetData (&formatetc, &stgmedium);

   if (FAILED (hr) )
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   bAllocatedStgMedium = TRUE;

   pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

   if (NULL == pDsSelList)
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }


   if (!pDsSelList->cItems)    //some item must have been selected
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   pDsSelection = &(pDsSelList->aDsSelection[0]);

   //we must get the ObjectSid attribute, otherwise we fail
   //so make sure that the attribute has been fetched.
   if (!pDsSelList->cFetchedAttributes ||
       (! (VT_ARRAY & pDsSelection->pvarFetchedAttributes->vt)))
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   pVariantArr = pDsSelection->pvarFetchedAttributes->parray;
   pSid = (PSID) pVariantArr->pvData;

   if (STATUS_SUCCESS != GetFriendlyNameFromSid (pSid, szDomain, szAcct, &eUse))
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   //store away the string representation of this sid
   if (STATUS_SUCCESS != GetStringFromSid(pSid, m_szSidStr))
       goto BrwsGrp_Err;

   m_szSidStr.MakeLower();
   if (!szDomain.IsEmpty())
       szAcct = szDomain + '\\' + szAcct;

   m_EditSecGroup.SetWindowText (szAcct);
   m_fValidSid = TRUE;

   goto BrwsGrp_CleanupAndQuit;

BrwsGrp_Err:
   error.ShowMessage (dwError);

BrwsGrp_CleanupAndQuit:
   if (pDsSelList)
      GlobalUnlock (stgmedium.hGlobal);
   if (bAllocatedStgMedium)
      ReleaseStgMedium (&stgmedium);
   if (pdo)
      pdo->Release();
   if (pDsObjectPicker)
      pDsObjectPicker->Release ();
}

void CSecGroupPath::SetOKState (void)
{
    CString szGroup;
    CString szPath;
    BOOL    bCheckPath = FALSE;

    m_EditSecGroup.GetWindowText(szGroup);
    szGroup.TrimLeft();
    szGroup.TrimRight();

    if (IDS_SPECIFIC_PATH == m_iCurrType ||
        IDS_PERUSER_PATH == m_iCurrType)
    {
        bCheckPath = TRUE;
        m_pathChooser.GetRoot (szPath);
        szPath.TrimLeft();
        szPath.TrimRight();
        szPath.TrimRight(L'\\');
    }

    if (szGroup.IsEmpty() || (bCheckPath && szPath.IsEmpty()))
        GetDescendantWindow(IDOK, FALSE)->EnableWindow(FALSE);
    else
        GetDescendantWindow(IDOK, FALSE)->EnableWindow(TRUE);
}

void CSecGroupPath::OnSecGroupUpdate()
{
    //the group in the edit box is about to change.
    //this means we can no longer trust the sid that we may have
    m_fValidSid = FALSE;
    SetOKState();
}

//we try to get a sid and domain for the group specified
//if we can't, we simply ignore the error and sit tight.
void CSecGroupPath::OnSecGroupKillFocus()
{
    BOOL    bStatus;
    CString szGroup;
    WCHAR*  szWindowText = NULL;
    WCHAR   szDom[MAX_PATH];
    DWORD   dwDomLen = MAX_PATH;
    WCHAR*  szAcct;
    PSID    Sid = NULL;
    DWORD   dwSidLen = 0;
    SID_NAME_USE    eUse;
    DWORD   Status;
    CHourglass  hourglass;  //LookupAccountName takes a while
    BOOL    fDomainSupplied = FALSE;


    //if we already have a valid sid, there is nothing to worry.
    if (m_fValidSid)
        goto KillFocusEnd;

    //we don't have a valid sid, so we try to get one from the data in the
    //group box
    m_EditSecGroup.GetWindowText (szGroup);
    szGroup.TrimLeft();
    szGroup.TrimRight();

    if (szGroup.IsEmpty())
        goto KillFocusEnd;

    ULONG ulNoChars;

    ulNoChars = wcslen( (LPCWSTR)szGroup )+1;
    szWindowText = new WCHAR[ulNoChars];
    if ( szWindowText == NULL )
    {
        goto KillFocusEnd;
    }
    
    //get the account name from the window
    
    HRESULT hr;

    hr = StringCchCopy (szWindowText, ulNoChars, (LPCWSTR) szGroup);
    ASSERT(SUCCEEDED(hr));

    szAcct = wcsrchr (szWindowText, '\\');
    if (!szAcct)
    {
        szAcct = szWindowText;
    }
    else
    {
        *szAcct++ = 0;  //advance it so that it now points to the account
                        //and szWindowText will now refer to the supplied domain
        fDomainSupplied = TRUE;
    }

    do
    {
        bStatus = LookupAccountName (NULL, szAcct, Sid, &dwSidLen,
                                    szDom, &dwDomLen, &eUse);

        if (!bStatus)
        {
            Status = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER != Status)
                goto KillFocusEnd;  //we just ignore the error for now

            LocalFree(Sid);
            Sid = (PSID) LocalAlloc (LPTR, dwSidLen);
            if (NULL == Sid)
                goto KillFocusEnd;  //we just ignore the error for now      

            continue;
        }
        break;
    } while (1);

    //we have the sid if we are here
    //make sure it represents a group
    switch (eUse)
    {
    case SidTypeGroup:
    case SidTypeWellKnownGroup:
    case SidTypeAlias:
        break;
    default:
        goto KillFocusEnd;
    }

    //also make sure that if a domain was supplied, it matches what we
    //got back
    if (fDomainSupplied && (0 != lstrcmpi (szWindowText, szDom)))
        goto KillFocusEnd;

    //if we are here, then we have the sid for a group
    if (STATUS_SUCCESS != GetStringFromSid (Sid, m_szSidStr))
        goto KillFocusEnd;

    //we were finally successful in getting the sid in a string format
    m_szSidStr.MakeLower();
    szGroup = szDom;
    if (!szGroup.IsEmpty())
        szGroup += '\\';
    szGroup += szAcct;
    m_EditSecGroup.SetWindowText ((LPCTSTR) szGroup);
    m_fValidSid = TRUE;

    KillFocusEnd:

        LocalFree(Sid);
        if ( szWindowText != NULL )
        {
            delete [] szWindowText;
        }
        return;
}

void CSecGroupPath::OnPathTweak (WPARAM wParam, LPARAM lParam)
{
    m_bPathValid = (BOOL) wParam;
    m_iCurrType = (LONG) lParam;

    SetOKState();
}

LONG CSecGroupPath::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_SECPATH);

    return lResult;
}

LONG CSecGroupPath::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_SECPATH);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\security.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    security.cxx

Abstract:
    This file contains utility functions concerning file security, e.g.
    convertings SIDs to strings and back, getting the display name for
    a given sid or getting the sid, given the display name


Author:

    Rahul Thombre (RahulTh) 9/28/1998

Revision History:

    9/28/1998   RahulTh         Created this module.

--*/

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = wcslen (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    CString     SidStr;
    WCHAR*      pSidStr;
    WCHAR*      pString;
    NTSTATUS    Status;
    WCHAR*      pEnd;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    int         len;
    SID_IDENTIFIER_AUTHORITY Auth;

    SidStr = lpszSidStr;
    len = SidStr.GetLength();
    pSidStr = SidStr.GetBuffer (len);
    pString = pSidStr;

    *ppSid = NULL;
    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFriendlyNameFromStringSid
//
//  Synopsis:   given a sid in string format, this function returns
//              the friendly name for it and the container in which
//              occurs. For more details on the string representation
//              of a sid, see ntseapi.h & ntrtl.h
//
//  Arguments:  [in] pSidStr : sid represented as a unicode string
//              [out] szDir  : the container in which the account occurs
//              [out] szAcct : the account name
//
//  Returns:    STATUS_SUCCESS : if successful
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetFriendlyNameFromStringSid (const WCHAR* pSidStr,
                                       CString& szDir,
                                       CString& szAcct
                                       )
{
    NTSTATUS    Status;
    PSID        pSid = NULL;
    WCHAR       szName[MAX_PATH];
    WCHAR       szDomain [MAX_PATH];
    DWORD       dwNameLen;
    DWORD       dwDomLen;
    SID_NAME_USE eUse;

    Status = AllocateAndInitSidFromString (pSidStr, &pSid);

    if (STATUS_SUCCESS != Status)
        goto GetFriendlyName_End;

    dwNameLen = dwDomLen = MAX_PATH;
    if (!LookupAccountSid (NULL, pSid, szName, &dwNameLen, szDomain, &dwDomLen,
                           &eUse))
        goto GetFriendlyName_Err;

    //we have got the container and the name of the account
    szDir = szDomain;
    szAcct = szName;

    Status = STATUS_SUCCESS;
    goto GetFriendlyName_End;

GetFriendlyName_Err:
    Status = GetLastError();

GetFriendlyName_End:
    if (pSid)
        FreeSid (pSid);
    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetFriendlyNameFromSid
//
//  Synopsis:   give a pointer to a sid, this function gets the friendly name
//              of the account to which the sid belongs and its friendly name
//
//  Arguments:  [in] pSid : pointer to the SID
//              [out] szDir : the domain to which the account belongs
//              [out] szAcct : the friendly name of the account
//              [out] peUse : pointer to a sid_name_use structure that
//                            identifies the type of the account
//
//  Returns:    STATUS_SUCCESS : if successful
//              an error code otherwise
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetFriendlyNameFromSid (PSID   pSid,
                                 CString& szDir,
                                 CString& szAcct,
                                 SID_NAME_USE*  peUse)
{
    ASSERT (peUse);

    TCHAR   szName[MAX_PATH];
    TCHAR   szDomain [MAX_PATH];
    DWORD   dwNameLen;
    DWORD   dwDomLen;
    DWORD   Status = STATUS_SUCCESS;

    dwNameLen = dwDomLen = MAX_PATH;
    if (!LookupAccountSid (NULL, pSid, szName, &dwNameLen, szDomain, &dwDomLen,
                           peUse))
    {
        Status = GetLastError();
    }
    else
    {
        szDir = szDomain;
        szAcct = szName;
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromSid
//
//  Synopsis:   given a SID, this function gets its string representation
//              for more information on string representations of sids,
//              refer to ntsecapi.h & ntrtl.h
//
//  Arguments:  [in] pSid : pointer to a SID
//              [out] szStringSid : the string representation of the SID
//
//  Returns:    STATUS_SUCCESS if successful
//              an error code otherwise
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetStringFromSid (PSID pSid, CString& szStringSid)
{
    UNICODE_STRING  stringW;
    DWORD           Status;

    Status = RtlConvertSidToUnicodeString (&stringW, pSid, TRUE);

    if (STATUS_SUCCESS == Status)
    {
        szStringSid = stringW.Buffer;
        RtlFreeUnicodeString (&stringW);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\snapin.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       snapin.cpp
//
//  Contents:   DLL support routines, class factory and registration
//              functions.
//
//  Classes:
//
//  Functions:
//
//  History:    2-12-1998   stevebl   comment header added
//              4-22-1998   rahulth   added CSection objects for the ini files
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "initguid.h"
#include "gpedit.h"

extern const CLSID CLSID_Snapin = {0x88E729D6,0xBDC1,0x11D1,{0xBD,0x2A,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};
extern const wchar_t * szCLSID_Snapin = L"{88E729D6-BDC1-11D1-BD2A-00C04FB9603F}";

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xE0494114,0xBDC1,0x11D1,{0xBD,0x2A,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{E0494114-BDC1-11D1-BD2A-00C04FB9603F}";

// RSOP GUIDs
extern const CLSID CLSID_RSOP_Snapin = {0XC40D66A0,0XE90C,0X46C6,{0XAA,0X3B,0X47,0X3E,0X38,0XC7,0X2B,0XF2}};
extern const wchar_t * szCLSID_RSOP_Snapin = L"{C40D66A0-E90C-46C6-AA3B-473E38C72BF2}";

IMalloc * g_pIMalloc;

#include "safereg.hxx"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define THREADING_STR   L"Apartment"

//+--------------------------------------------------------------------------
//
//  Function:   RegDeleteTree
//
//  Synopsis:   deletes a registry key and all of its children
//
//  Arguments:  [hKey]     - handle to the key's parent
//              [szSubKey] - name of the key to be deleted
//
//  Returns:    ERROR_SUCCESS
//
//  History:    3-17-1998   stevebl   Copied from ADE
//
//---------------------------------------------------------------------------

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, szSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, szSubKey);
}


HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_Snapin, CRSOPUserComponentDataImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
        if (FAILED(CoGetMalloc(1, &g_pIMalloc)))
            return FALSE;
        return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CResultPane);
        DEBUG_VERIFY_INSTANCE_COUNT(CScopePane);

        g_pIMalloc->Release();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

const wchar_t * szUser_Namespace = L"{08114B47-BDC2-11D1-BD2A-00C04FB9603F}";
const wchar_t * szUserAppName = L"Folder Redirection Editor (Users)";
const wchar_t * szUser_RSOP_Namespace = L"{8CDE1CC8-0D3A-4B60-99EA-27EF3D7C0174}";
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());
    
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
    WCHAR       szMUIUserAppName[MAX_PATH + 50];
    WCHAR       szModule[MAX_PATH];
    HRESULT     hr = S_OK;

    // Get the path to the module.
    if (0 != ::GetModuleFileName(AfxGetInstanceHandle(), szModule, MAX_PATH))
    {
        // MUI: MMC: Use the new NameStringIndirect value of MMC to display
        // a localized name for the snap-in while using MUI.
        hr = StringCchPrintf (szMUIUserAppName, sizeof(szMUIUserAppName)/sizeof(szMUIUserAppName[0]), L"@%s,-%d", szModule, IDS_SNAPIN_NAME);
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    else
    {
        szMUIUserAppName[0] = L'\0';
    }
        
    do
    {
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        
        // MUI: MMC: Use localized snap-in name for MUI.
        if (L'\0' != szMUIUserAppName[0])
        {
            hr = shk.SetValue(L"NameStringIndirect",
                              REG_SZ,
                              (CONST BYTE *) szMUIUserAppName,
                              sizeof(WCHAR) * (lstrlen(szMUIUserAppName) + 1));
        }

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        WCHAR szGUID[50];
        StringFromGUID2 (NODEID_User, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();

        // register RSOP extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_RSOP_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        // MUI: MMC: Use localized snap-in name for MUI.
        if (L'\0' != szMUIUserAppName[0])
        {
            hr = shk.SetValue(L"NameStringIndirect",
                              REG_SZ,
                              (CONST BYTE *) szMUIUserAppName,
                              sizeof (WCHAR) * (lstrlen(szMUIUserAppName) + 1));
        }
        
        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        StringFromGUID2 (NODEID_RSOPUser, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    HKEY hkey;
    CString sz;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_Snapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_Namespace));
    RegCloseKey(hkey);
    WCHAR szGUID[50];
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_User, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_Snapin);
    RegCloseKey(hkey);

    // unregister RSOP nodes
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_Snapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_RSOP_Namespace));
    RegCloseKey(hkey);
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPUser, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_RSOP_Snapin);
    RegCloseKey(hkey);

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\stdafx.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       stdafx.h
//
//  Contents:   include file for standard system include files, or project
//              specific include files that are used frequently, but are
//              changed infrequently
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include <afxwin.h>
#include <afxcmn.h>
#include <afxdisp.h>

#include <atlbase.h>

#include <shlobj.h>
#include <intshcut.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#ifdef DBG
//
// ATL's implementation of Release always returns 0 unless _DEBUG is
// defined. The debug version of OLE.DLL asserts Release() != 0 in certain
// circumstances.  I don't want to define _DEBUG because it brings in a
// whole lot of baggage from MMC that I don't want to deal with, but I do
// want to avoid this assertion in OLE, so on debug builds, I'll go ahead
// and define _DEBUG for the appropriate ATL header file but I'll undefine
// it again right afterward.  This is a little flakey but it is relatively
// safe and it achieves the desired goal.
//
// - SteveBl
//
#define _DEBUG
#endif
#include <atlcom.h>
#ifdef DBG
#undef _DEBUG
#endif

#include <afxwin.h>         //MFC core and standard components
#include <afxext.h>         //MFC extensions

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;
    HSCOPEITEM          m_scopeID;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\about.cpp ===
//*************************************************************
//  File name: ABOUT.CPP
//
//  Description:  About information for the Group Policy Editor
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE implementation                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutGPE::CAboutGPE(BOOL fRSOP) : m_smallImage( 0 ), m_largeImage( 0 )


{
    m_fRSOP = fRSOP;
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;
}

CAboutGPE::~CAboutGPE()
{
    InterlockedDecrement(&g_cRefThisDll);
    if ( m_smallImage )
    {
        DeleteObject( m_smallImage );
    }
    if ( m_largeImage )
    {
        DeleteObject( m_largeImage );
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE object implementation (IUnknown)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CAboutGPE::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_ISnapinAbout))
    {
        *ppv = (LPSNAPABOUT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CAboutGPE::AddRef (void)
{
    return ++m_cRef;
}

ULONG CAboutGPE::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE object implementation (ISnapinAbout)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAboutGPE::GetSnapinDescription(LPOLESTR *lpDescription)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (256 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, m_fRSOP? IDS_RSOP_SNAPIN_DESCRIPT : IDS_SNAPIN_DESCRIPT, lpBuffer, 256);
        *lpDescription = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetProvider(LPOLESTR *lpName)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (50 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, IDS_PROVIDER_NAME, lpBuffer, 50);
        *lpName = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetSnapinVersion(LPOLESTR *lpVersion)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (50 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, IDS_SNAPIN_VERSION, lpBuffer, 50);
        *lpVersion = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetSnapinImage(HICON *hAppIcon)
{
    *hAppIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_POLICY));

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetStaticFolderImage(HBITMAP *hSmallImage,
                                                  HBITMAP *hSmallImageOpen,
                                                  HBITMAP *hLargeImage,
                                                  COLORREF *cMask)
{
    if ( !m_smallImage )
    {
        m_smallImage = (HBITMAP) LoadImage (g_hInstance, MAKEINTRESOURCE(IDB_POLICY16),
                                            IMAGE_BITMAP,
                                            16, 16, LR_DEFAULTCOLOR);
    }

    if ( !m_largeImage )
    {
        m_largeImage = (HBITMAP) LoadImage (g_hInstance, MAKEINTRESOURCE(IDB_POLICY32),
                                            IMAGE_BITMAP,
                                            32, 32, LR_DEFAULTCOLOR);
    }

    *hLargeImage = m_largeImage;
    *hSmallImage = *hSmallImageOpen = m_smallImage;
    *cMask = RGB(255,0,255);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutGPECF::CAboutGPECF(BOOL fRSOP)
{
    m_fRSOP = fRSOP;
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CAboutGPECF::~CAboutGPECF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CAboutGPECF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CAboutGPECF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CAboutGPECF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CAboutGPECF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CAboutGPE *pAboutGPE = new CAboutGPE(m_fRSOP); // ref count == 1

    if (!pAboutGPE)
        return E_OUTOFMEMORY;

    HRESULT hr = pAboutGPE->QueryInterface(riid, ppvObj);
    pAboutGPE->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CAboutGPECF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\about.h ===
//
// CLSID_AboutGPE
//

// {0FDE5092-AA2A-11d1-A7D4-0000F87571E3}
DEFINE_GUID(CLSID_AboutGPE, 0xfde5092, 0xaa2a, 0x11d1, 0xa7, 0xd4, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {4f637904-2cab-4f0e-8688-d3717ebd2975}
DEFINE_GUID(CLSID_RSOPAboutGPE, 0x4f637904, 0x2cab, 0x4f0e, 0x86, 0x88, 0xd3, 0x71, 0x7e, 0xbd, 0x29, 0x75);

#ifndef _ABOUT_H_
#define _ABOUT_H_


//
// CAboutGPE class
//

class CAboutGPE : public ISnapinAbout
{
protected:
    BOOL m_fRSOP;
public:
    CAboutGPE(BOOL fRSOP = FALSE);
    ~CAboutGPE();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented ISnapinAbout interface members
    //

    STDMETHODIMP         GetSnapinDescription(LPOLESTR *lpDescription);
    STDMETHODIMP         GetProvider(LPOLESTR *lpName);
    STDMETHODIMP         GetSnapinVersion(LPOLESTR *lpVersion);
    STDMETHODIMP         GetSnapinImage(HICON *hAppIcon);
    STDMETHODIMP         GetStaticFolderImage(HBITMAP *hSmallImage,
                                              HBITMAP *hSmallImageOpen,
                                              HBITMAP *hLargeImage,
                                              COLORREF *cMask);

private:

    ULONG    m_cRef;
    HBITMAP  m_smallImage;
    HBITMAP  m_largeImage;

};


//
// AboutGPE class factory
//


class CAboutGPECF : public IClassFactory
{
protected:
    ULONG m_cRef;
    BOOL  m_fRSOP;

public:
    CAboutGPECF(BOOL fRSOP = FALSE);
    ~CAboutGPECF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


#endif // _ABOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\fde\utils.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    utils.cxx

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/8/1998

Revision History:

    4/8/1998    RahulTh

    Created this module.

--*/
#include "precomp.hxx"

BOOL IsSpecialDescendant (const long nID, UINT* parentID /*= NULL*/)
{
    BOOL fRetVal;
    int prntID = -1;

    switch (nID)
    {
    case IDS_MYPICS:
        prntID = IDS_MYDOCS;
        break;
    case IDS_PROGRAMS:
        prntID = IDS_STARTMENU;
        break;
    case IDS_STARTUP:
        prntID = IDS_PROGRAMS;
        break;
    default:
        prntID = -1;
        break;
    }

    if (fRetVal = (-1 != prntID))
    {
        if (parentID)
            *parentID = prntID;
    }

    return fRetVal;
}

//this is a helper function for ConvertOldStyleSection(...) which is used
//to convert Beta3 style ini files to Win2K style ini files.
void SplitRHS (CString& szValue, unsigned long & flags, CString& szPath)
{
    int index;
    int iRetVal;

    //take some precautions
    szValue.TrimRight();
    szValue.TrimLeft();
    szPath.Empty();
    flags = 0;

    if (szValue.IsEmpty())
        return;

    //if we are here, szValue at least contains the flags
    iRetVal = swscanf ((LPCTSTR)szValue, TEXT("%x"), &flags);
    ASSERT((iRetVal != 0) && (iRetVal != EOF));

    //check if there is a path too.
    index = szValue.Find(' ');  //we will find a space only if there is a path too.
    if (-1 != index)    //there is a path too.
    {
        szPath = szValue.Mid (index + 1);
        szPath.TrimLeft();
        szPath.TrimRight();
        ASSERT (!szPath.IsEmpty());
    }
}

//////////////////////////////////////////////////////////////////////////
// Given a full path name, this routine extracts its display name, viz.
// the part of which follows the final \. If there are no \'s in the
// full name, then it sets the display name to the full name
//////////////////////////////////////////////////////////////////////////
void ExtractDisplayName (const CString& szFullname, CString& szDisplayname)
{
    CString szName;
    szName = szFullname;
    //first get rid of any trailing spaces; this might happen in cases
    //where one is trying to create a shortcut to a network drive and
    //when resolved to a UNC path, it yields a path ending in a slash

    //reverse the string so that any trailing slashes will now be at the
    //head of the string
    szName.MakeReverse();
    //get rid of the leading slashes and spaces of the reversed string
    szName = szName.Mid ((szName.SpanIncluding(TEXT("\\ "))).GetLength());
    //reverse the string again and we will have a string without
    //any trailing '\' or ' '
    szName.MakeReverse();

    //with the trailing '\' and spaces removed, we can go about the
    //business of getting the display name

    //if \ cannot be found, ReverseFind returns -1 which gives 0 on adding
    //1, therefore szDisplayname gets the entire name if no \ is found.
    szDisplayname = szName.Mid (szName.ReverseFind('\\') + 1);
}

//+--------------------------------------------------------------------------
//
//  Function:   SplitProfileString
//
//  Synopsis:   This function takes in a string of the type key=value and
//              extracts the key and the value from it.
//
//  Arguments:  [in] szPair : the key value pair
//              [out] szKey : the key
//              [out] szValue : the value
//
//  Returns:    S_OK : if everything goes well.
//              E_FAIL: if the '=' sign cannot be found
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT SplitProfileString (CString szPair, CString& szKey, CString& szValue)
{
    int nEqPos;

    nEqPos = szPair.Find ('=');

    if (-1 == nEqPos)
        return E_FAIL;

    szKey = szPair.Left(nEqPos);
    szKey.TrimLeft();
    szKey.TrimRight();

    szValue = szPair.Mid (nEqPos + 1);
    szValue.TrimLeft();
    szValue.TrimRight();

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   ConvertOldStyleSection
//
//  Synopsis:   this function looks at an ini file and if does not have the
//              new ini file format, it reads the old redirect section and
//              transforms it into the new ini file format which supports
//              scaleability
//
//  Arguments:  [in] szGPTPath : the directory where the ini file resides
//              [in] pScope    : pointer to the scope pane
//
//  Returns:    S_OK if it was successful
//              an error code if it fails
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      This function exists primarily for backward compatibility
//              with Win2K betas. Might be okay to remove it.
//
//---------------------------------------------------------------------------
HRESULT ConvertOldStyleSection (
                                const CString& szGPTPath
                                )
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szIniFile;
    TCHAR*  lpszSection;
    TCHAR*  szEntry;
    DWORD   cbSize = 1024;
    DWORD   cbCopied;
    CString SectionEntry;
    CString Key;
    CString Dir;
    CString Value;
    CString Path;
    CString szStartMenu;
    CString szPrograms;
    CString szStartup;
    ULONG   flags;
    DWORD   Status;
    BOOL    bStatus;
    HRESULT hr = S_OK;
    const TCHAR   szEveryOne[] = TEXT("s-1-1-0");

    //derive the full path of the ini file.
    szIniFile.LoadString (IDS_INIFILE);
    szIniFile = szGPTPath + '\\' + szIniFile;

    //create an empty section
    lpszSection = new TCHAR [cbSize];
    lpszSection[0] = lpszSection[1] = '\0';


    switch (CheckIniFormat (szIniFile))
    {
    case S_OK:
        //this section has already been converted
        goto ConOldStlSec_CleanupAndQuit;

    case S_FALSE:
        break;          //has the Redirect section but not the FolderStatus
                        //section, so there is processing to do.
    case REGDB_E_KEYMISSING:
        //this means that the function has neither the FolderStatus section
        //nor the Redirect section, so we just create an empty FolderStatus
        //section to make processing simpler in future.
        //ignore any errors here because they don't really cause any harm
        //however, make sure that the file is pre-created in unicode so that
        //the WritePrivateProfile* functions don't puke in ANSI
        PrecreateUnicodeIniFile ((LPCTSTR)szIniFile);
        WritePrivateProfileSection (TEXT("FolderStatus"),
                                    lpszSection,
                                    (LPCTSTR) szIniFile);
        hr = S_OK;
        goto ConOldStlSec_CleanupAndQuit;
    }

    //this means that we need to convert the section ourselves
    //first load the redirect section
    do
    {
        cbCopied = GetPrivateProfileSection (TEXT("Redirect"),
                                             lpszSection,
                                             cbSize,
                                             (LPCTSTR) szIniFile
                                             );
        if (cbSize - 2 == cbCopied)
        {
            delete [] lpszSection;
            cbSize *= 2;
            lpszSection = new TCHAR [cbSize];
            continue;
        }

        //the section has been successfully loaded if we are here.
        break;
    } while (TRUE);

    //start the conversion process:
    for (szEntry = lpszSection; *szEntry; szEntry += (lstrlen(szEntry) + 1))
    {
        SectionEntry = szEntry;
        if (FAILED(hr = SplitProfileString (SectionEntry, Key, Value)))
            goto ConOldStlSec_CleanupAndQuit;

        SplitRHS (Value, flags, Path);
        Path.TrimLeft();
        Path.TrimRight();
        if (Path.IsEmpty())
            Path = TEXT("%USERPROFILE%") + ('\\' + Key);  //we used the relative paths for keys in the old style section
        ExtractDisplayName (Key, Dir);

        //set the new flags or modify the existing flags to reflect new behavior
        szStartMenu.LoadString (IDS_STARTMENU);
        szPrograms.LoadString (IDS_PROGRAMS);
        szStartup.LoadString (IDS_STARTUP);
        if (Dir.CompareNoCase (szStartMenu) && //it is not the start menu and
            Dir.CompareNoCase (szPrograms) &&  //it is not programs and
            Dir.CompareNoCase (szStartup))  //it is not the startup folder
        {
            flags |= REDIR_SETACLS;         //apply acls. this was the default behavior earlier, but not any more
        }
        else    //it is one of start menu/programs/startup
        {
            //move contents is not allowed for start menu and its descendants
            flags &= ~REDIR_MOVE_CONTENTS;
        }

        if ((flags & REDIR_DONT_CARE) && (flags & REDIR_FOLLOW_PARENT))
        {
            //if both flags were present, this implies they are linked together
            //in the new format, in order to express this, only follow_parent
            //is required
            flags &= ~REDIR_DONT_CARE;
        }

        Value.Format (TEXT("%x"), flags);

        bStatus = WritePrivateProfileString (TEXT("FolderStatus"),
                                             Dir,
                                             Value,
                                             (LPCTSTR)szIniFile
                                             );

        if (bStatus && (!(flags & REDIR_DONT_CARE)) && (!(flags & REDIR_FOLLOW_PARENT)))
            bStatus = WritePrivateProfileString ((LPCTSTR) Dir,
                                                 szEveryOne,
                                                 (LPCTSTR) Path,
                                                 (LPCTSTR) szIniFile
                                                 );

        if (!bStatus)
        {
            Status = GetLastError();
            hr = HRESULT_FROM_WIN32 (Status);
            goto ConOldStlSec_CleanupAndQuit;
        }
    }

ConOldStlSec_CleanupAndQuit:
    delete [] lpszSection;
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFolderIndex
//
//  Synopsis:   given the name of a folder, this function returns its index
//              in the array of CFileInfo objects in the scope pane
//
//  Arguments:  [in] szName : name of the folder
//
//  Returns:    the index of the folder or -1 if the name is invalid
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LONG GetFolderIndex (const CString& szName)
{
    LONG i;
    CString szBuiltinFolder;

    for (i = IDS_DIRS_START; i < IDS_DIRS_END; i++)
    {
        szBuiltinFolder.LoadString (i);
        if (szName.CompareNoCase((LPCTSTR)szBuiltinFolder))
            break;
    }

    return GETINDEX (i);
}

//+--------------------------------------------------------------------------
//
//  Function:   CheckIniFormat
//
//  Synopsis:   this function examines the sections of an ini file to see
//              if it supports the new ini file format (that allows for
//              scaleability)
//
//  Arguments:  [in] szIniFile : the full path of the ini file
//
//  Returns:    S_OK : if it finds the FolderStatus section
//              S_FALSE : if it does not find the FolderStatus section but
//                        finds the Redirect section
//              REGDB_E_KEYMISSING : if it finds neither the FolderStatus
//                                   section nor the Redirect section
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      this function exists for backward compatibility with Win2K
//              Betas. Might be okay to get rid of this eventually.
//
//---------------------------------------------------------------------------
HRESULT CheckIniFormat (LPCTSTR szIniFile)
{
    DWORD   cchSize = 1024;
    DWORD   cchCopied;
    TCHAR*  lpszNames;
    TCHAR*  szSectionName;
    BOOL    fHasFolderStatus = FALSE;
    BOOL    fHasRedirect = FALSE;

    do
    {
        lpszNames = (TCHAR*) LocalAlloc( LPTR, cchSize * sizeof(TCHAR) );
        if (! lpszNames)
            return E_OUTOFMEMORY;
        
        *lpszNames = L'\0';
        cchCopied = GetPrivateProfileSectionNames (lpszNames, cchSize, szIniFile);

        if (cchSize - 2 == cchCopied) //the buffer was not enough.
        {
            LocalFree( lpszNames );
            cchSize *= 2;            //increase the buffer size
            continue;
        }

        break;  //if we are here, we are done.

    } while (TRUE);

    for (szSectionName = lpszNames;
         *szSectionName;
         szSectionName += (lstrlen(szSectionName) + 1))
    {
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szSectionName, -1, TEXT("FolderStatus"), -1) == CSTR_EQUAL)
        {
            fHasFolderStatus = TRUE;
            continue;
        }

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szSectionName, -1, TEXT("Redirect"), -1) == CSTR_EQUAL)
        {
            fHasRedirect = TRUE;
            continue;
        }
    }

    //cleanup dynamically allocated memory before quitting
    LocalFree( lpszNames );

    if (fHasFolderStatus)
        return S_OK;

    //if we are here, the file does not have the FolderStatus section
    if (fHasRedirect)
        return S_FALSE;

    //if we are here, then the file has neither the folder status section
    //nor the Redirect section
    return REGDB_E_KEYMISSING;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    CString StrNum;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    StrNum = szNum;
    len = StrNum.GetLength();
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = sizeof(WCHAR) * (len + 1);
    StringW.Buffer = StrNum.GetBuffer(len);

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetUNCPath
//
//  Synopsis:   this function tries to retrieve the UNC path of an item
//              given its PIDL
//
//  Arguments:  [in] lpszPath : the full path to the selected file.
//              [out] szUNC : the UNC path of the item
//
//  Returns:    NO_ERROR if the conversion was successful.
//              other error codes if not...
//
//  History:    10/1/1998  RahulTh  created
//              4/12/1999  RahulTh  added error code. changed params.
//                                  (item id list is no longer passed in)
//
//  Notes:      if this function is unsuccessful, then szUNC will contain an
//              empty string
//
//---------------------------------------------------------------------------
DWORD GetUNCPath (LPCTSTR lpszPath, CString& szUNC)
{
    TCHAR* lpszUNCName;
    UNIVERSAL_NAME_INFO* pUNCInfo;
    DWORD lBufferSize;
    DWORD retVal = NO_ERROR;

    szUNC.Empty();  //precautionary measures

    //we have a path, now we shall try to get a UNC path
    lpszUNCName = new TCHAR[MAX_PATH];
    pUNCInfo = (UNIVERSAL_NAME_INFO*)lpszUNCName;
    lBufferSize = MAX_PATH * sizeof(TCHAR);
    retVal = WNetGetUniversalName (lpszPath,
                                   UNIVERSAL_NAME_INFO_LEVEL,
                                   (LPVOID)pUNCInfo,
                                   &lBufferSize);
    if (ERROR_MORE_DATA == retVal)  //MAX_PATH was insufficient to hold the UNC path
    {
        delete [] lpszUNCName;
        lpszUNCName = new TCHAR[lBufferSize/(sizeof(TCHAR)) + 1];
        pUNCInfo = (UNIVERSAL_NAME_INFO*)lpszUNCName;
        retVal = WNetGetUniversalName (lpszPath,
                                       UNIVERSAL_NAME_INFO_LEVEL,
                                       (LPVOID)pUNCInfo,
                                       &lBufferSize);
    }

    //at this point we may or may not have a UNC path.
    //if we do, we return that, or we return whatever we already have
    if (NO_ERROR == retVal)
        szUNC = pUNCInfo->lpUniversalName;

    delete [] lpszUNCName;

    return retVal;
}

//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   the callback function for SHBrowseForFolder
//
//  Arguments:  see Platform SDK
//
//  Returns:    see Platform SDK
//
//  History:    4/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg,
                                LPARAM lParam, LPARAM lpData
                                )
{
    CString * pszData;
    CString   szStart;
    int       index;
    LPITEMIDLIST    lpidl = NULL;
    TCHAR      lpszPath [MAX_PATH];

    pszData = (CString *) lpData;

    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        if (pszData)
        {
            szStart = *pszData;
            szStart.TrimRight();
            szStart.TrimLeft();
            if (! szStart.IsEmpty())
            {
                index = szStart.ReverseFind (L'\\');
                if (-1 != index && index > 1)
                    szStart = szStart.Left (index);
                SendMessage (hwnd, BFFM_SETSELECTION, TRUE,
                             (LPARAM)(LPCTSTR)szStart);
            }
        }
        break;
    case BFFM_SELCHANGED:
        //we need to check if we can get the full path to the selected folder.
        //e.g. if the full path exceeds MAX_PATH, we cannot obtain the path
        //from the item id list. if we cannot get the path, we should not
        //enable the OK button. So, over here, as a precaution, we first
        //disable the OK button. We will enable it only after we get the path.
        SendMessage (hwnd, BFFM_ENABLEOK, FALSE, FALSE);
        if (SHGetPathFromIDList((LPCITEMIDLIST)lParam, lpszPath))
        {
            //set the path into the data member and enable the OK button
            if (lpData)
            {
                SendMessage (hwnd, BFFM_ENABLEOK, TRUE, TRUE);
                *((CString *) lpData) = lpszPath;
            }
        }
        break;
    default:
        break;
    }

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Function:   PrecreateUnicodeIniFile
//
//  Synopsis:   The WritePrivateProfile* functions do not write in unicode
//              unless the file already exists in unicode format. Therefore,
//              this function is used to precreate a unicode file so that
//              the WritePrivateProfile* functions can preserve the unicodeness.
//
//  Arguments:  [in] lpszFilePath : the full path of the ini file.
//
//  Returns:    ERROR_SUCCESS if successful.
//              an error code otherwise.
//
//  History:    7/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PrecreateUnicodeIniFile (LPCTSTR lpszFilePath)
{
    HANDLE      hFile;
    WIN32_FILE_ATTRIBUTE_DATA   fad;
    DWORD       Status = ERROR_ALREADY_EXISTS;
    DWORD       dwWritten;

    if (!GetFileAttributesEx (lpszFilePath, GetFileExInfoStandard, &fad))
    {
        if (ERROR_FILE_NOT_FOUND == (Status = GetLastError()))
        {
            hFile = CreateFile(lpszFilePath, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                //add the unicode marker to the beginning of the file
                //so that APIs know for sure that it is a unicode file.
                WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR),
                          &dwWritten, NULL);
                //add some unicode characters to the file.
                WriteFile(hFile, L"     \r\n", 7 * sizeof(WCHAR),
                          &dwWritten, NULL);
                CloseHandle(hFile);
                Status = ERROR_SUCCESS;
            }
            else
            {
                Status = GetLastError();
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsValidPrefix
//
//  Synopsis:   Given a path, this function determines if it is a valid prefix
//
//  Arguments:  [in] pathType : the type of the path
//              [in] pwszPath : the supplied path
//
//  Returns:    TRUE: if the prefix is valid.
//              FALSE: otherwise
//
//  History:    3/14/2000  RahulTh  created
//
//  Notes:      A valid prefix is either a non-unc path or a UNC path which
//              has at least the server and the share component. It must also
//              be a non-empty path.
//
//---------------------------------------------------------------------------
BOOL IsValidPrefix (UINT pathType, LPCTSTR pwszPath)
{
    CString       szPath;
    const WCHAR * pwszProcessedPath;

    if (! pwszPath || L'\0' == *pwszPath)
        return FALSE;

    szPath = pwszPath;
    szPath.TrimLeft();
    szPath.TrimRight();
    szPath.TrimRight(L'\\');
    pwszProcessedPath = (LPCTSTR) szPath;

    if (PathIsUNC ((LPCTSTR) szPath))
    {
        // Make sure it has both the server and the share component
        if (lstrlen (pwszProcessedPath) <= 2 ||
            L'\\' != pwszProcessedPath[0] ||
            L'\\' != pwszProcessedPath[1] ||
            NULL ==  wcschr (&pwszProcessedPath[2], L'\\'))
        {
            return FALSE;
        }
    }

    //
    // If we are here, we just need to make sure that the path does not contain
    // any environment variables -- if it is not IDS_SPECIFIC_PATH
    //
    if (pathType != IDS_SPECIFIC_PATH &&
        NULL != wcschr(pwszProcessedPath, L'%'))
    {
        return FALSE;
    }

    // If we make it up to here, then the path is a valid prefix.

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Function:   AlwaysShowMyPicsNode
//
//  Synopsis:   In WindowsXP, we now show the MyPics node in the scope pane
//              only if My Pics does not follow My Docs. However, if required
//              this MyPics can always be made visible by setting a reg. value
//              under HKLM\Software\Policies\Microsoft\Windows\System called 
//              FRAlwaysShowMyPicsNode. This is a DWORD value and if set to
//              non-zero, the MyPics node will always be displayed.
//
//  Arguments:  none.
//
//  Returns:    TRUE : if the value was found in the registry and was non-zero.
//              FALSE : otherwise.
//
//  History:    4/10/2001  RahulTh  created
//
//  Notes:      Note: In case of errors, the default value of FALSE is returned.
//
//---------------------------------------------------------------------------
BOOL AlwaysShowMyPicsNode (void)
{
    BOOL    bAlwaysShowMyPics = FALSE;
    DWORD   dwValue = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);
    HKEY    hKey = NULL;
    
    if (ERROR_SUCCESS != RegOpenKey (HKEY_LOCAL_MACHINE,
                                     TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                                     &hKey)
        )
    {
        return bAlwaysShowMyPics;
    }
    
    if (ERROR_SUCCESS == RegQueryValueEx (hKey,
                                          TEXT("FRAlwaysShowMyPicsNode"),
                                          NULL,
                                          &dwType,
                                          (LPBYTE)(&dwValue),
                                          &dwSize)
        )
    {
        if (REG_DWORD == dwType && dwValue)
            bAlwaysShowMyPics = TRUE;
    }
    
    RegCloseKey(hKey);
    
    return bAlwaysShowMyPics;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateThemedPropertyPage
//
//  Synopsis:   Helper function to make sure that property pages put up
//              by the snap-in are themed.
//
//  Arguments:
//
//  Returns:
//
//  History:    4/20/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\browser.h ===
#if !defined __BROWSER_H__
#define __BROWSER_H__

#include "cproppg.h"

#define PAGETYPE_DOMAINS        0
#define PAGETYPE_SITES          1
#define PAGETYPE_COMPUTERS      2
#define PAGETYPE_ALL            3

#define ITEMTYPE_SITE           0
#define ITEMTYPE_DOMAIN         1
#define ITEMTYPE_OU             2
#define ITEMTYPE_GPO            3
#define ITEMTYPE_FOREST         4

#define CLASSNAME_OU        L"organizationalUnit"
#define CLASSNAME_DOMAIN    L"domainDNS"

typedef struct tag_MYLISTEL
{
    LPWSTR  szName;
    LPWSTR  szData;
    UINT    nType;
    BOOL    bDisabled;
} MYLISTEL;

#define BUTTONSIZE 16

#define SMALLICONSIZE   16
#define LARGEICONSIZE   32
#define INDENT          10


typedef struct tag_LOOKDATA
{
    LPWSTR     szName;
    UINT       nIndent;
    UINT       nType;
    LPWSTR     szData;
    struct tag_LOOKDATA * pSibling;
    struct tag_LOOKDATA * pParent;
    struct tag_LOOKDATA * pChild;
} LOOKDATA;

LOOKDATA * BuildDomainList(WCHAR * szServerName);
VOID FreeDomainInfo (LOOKDATA * pEntry);

class CBrowserPP : CHlprPropPage
{
    // Construction
    public:
    CBrowserPP();
    HPROPSHEETPAGE Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive);
    ~CBrowserPP();

    INT AddElement(MYLISTEL * pel, INT index);

public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
protected:

    // Implementation
protected:
    virtual BOOL OnInitDialog();
    void OnContextMenu(LPARAM lParam);
    void OnDoubleclickList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnDetails();
    void OnList();
    void OnLargeicons();
    void OnSmallicons();
    void OnArrangeAuto();
    void OnArrangeByname();
    void OnArrangeBytype();
    void OnDelete();
    void OnEdit();
    void OnNew();
    void OnProperties();
    void OnRefresh();
    void OnRename();
    void OnTopLineupicons();
    void OnBeginlabeleditList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnEndlabeleditList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnBegindragList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnDeleteitemList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnKeyDownList(NMHDR * pNMHDR, LRESULT * pResult);
    void OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult);
    void OnComboChange();
    void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
    void RefreshDomains(void);
    void RefreshSites(void);
    void RefreshAll(void);
    void SetButtonState(void);
    LPOLESTR GetCurrentObject();
    LPOLESTR GetCurrentDomain();
    BOOL IsCurrentObjectAForest();
    BOOL FillDomainList();
    BOOL SetInitialOU();
    BOOL FillSitesList();
    BOOL AddGPOsForDomain();
    BOOL AddGPOsLinkedToObject();
    void TrimComboBox();
    BOOL AddChildContainers();
    BOOL CreateLink(LPOLESTR szObject, LPOLESTR szContainer);
    BOOL DeleteLink(LPOLESTR szObject, LPOLESTR szContainer);
    LPTSTR GetFullPath (LPTSTR lpGPO, HWND hParent);

    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND                    m_hwndDlg;
    HWND                    m_hList;
    HWND                    m_hCombo;
    HWND                    m_toolbar;
    HIMAGELIST              m_ilSmall;
    HIMAGELIST              m_ilLarge;
    void **                 m_ppActive;
    LPGPOBROWSEINFO         m_pGBI;
    DWORD                   m_dwPageType;
    WCHAR                   m_szTitle[256];
    LOOKDATA *              m_pPrevSel;
    LPTSTR                  m_szServerName;
    LPTSTR                  m_szDomainName;

    BOOL DoBackButton();
    BOOL DoNewGPO();
    BOOL DeleteGPO();
    BOOL DoRotateView();
};

#endif // __BROWSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\browser.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       browser.cpp
//
//  Contents:   implementation of the general GPO browser pane
//
//  Classes:    CBrowserPP
//
//  Functions:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This is the pane that behaves much like the standard file
//              open dialog.  The class is used for all panes that have this
//              format since they share so much functionality.  The
//              dwPageType parameter passed to CBrowserPP::Initialize is
//              used to distinguish between the different flavors.
//
//---------------------------------------------------------------------------

#include "main.h"
#include "browser.h"
#include "commctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Help ids
//

DWORD aBrowserDomainHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_LOOKIN,
    IDC_LIST1,                    IDH_BROWSER_DOMAINGPO,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};

DWORD aBrowserSiteHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_SITELIST,
    IDC_LIST1,                    IDH_BROWSER_GPOLIST,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};

DWORD aBrowserAllHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_DOMAINLIST,
    IDC_LIST1,                    IDH_BROWSER_FULLGPOLIST,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};


CBrowserPP::CBrowserPP()
{
    m_ppActive = NULL;
    m_pGBI = NULL;
    m_pPrevSel = NULL;
    m_szServerName = NULL;
    m_szDomainName = NULL;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyAsFriendlyName
//
//  Synopsis:   Copies a LDAP path converting it to a friendly name by
//              removing the "LDAP://" and "XX=" and converting "," to "."
//              and removing a server name (if any)
//
//  Arguments:  [lpDest] - destination buffer
//              [lpSrc]  - source buffer
//
//  Returns:    nothing
//
//  History:    5-07-1998   stevebl   Created
//
//  Notes:      The destination buffer should be as large as the source
//              buffer to ensure safe completion.  lpDest and lpSrc may both
//              point to the same buffer.
//
//              As an example, this routine would convert the following path:
//                  LDAP://DC=abcd,DC=efg
//              into this:
//                  abcd.efg
//
//---------------------------------------------------------------------------

void CopyAsFriendlyName(WCHAR * lpDest, WCHAR * lpSrc)
{
    LPOLESTR lpProvider = L"LDAP://";
    DWORD dwStrLen = wcslen(lpProvider);

    // lpStopChecking marks the last spot where we can safely
    // look ahead 2 spaces for an '=' character.  Anything past
    // this and we are looking in memory we don't own.
    OLECHAR * lpStopChecking = (wcslen(lpSrc) - 2) + lpSrc;

    //
    // Skip the LDAP:// if found
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                       lpProvider, dwStrLen, lpSrc, dwStrLen) == CSTR_EQUAL)
    {
        lpSrc += dwStrLen;
    }

    //
    // Remove server name (if any)
    //
    if (lpSrc < lpStopChecking)
    {
        if (*(lpSrc+2) != L'=')
        {
            // look for a '/' character marking the end of a server name
            while (*lpSrc)
            {
                if (*lpSrc == L'/')
                {
                    lpSrc++;
                    break;
                }
                lpSrc++;
            }
        }
    }

    //
    // Parse through the name replacing all the XX= with .
    //

    while (*lpSrc)
    {
        if (lpSrc < lpStopChecking)
        {
            if (*(lpSrc+2) == L'=')
            {
                lpSrc += 3;
            }
        }

        while (*lpSrc && (*lpSrc != L','))
        {
            // remove escape sequences
            if (*lpSrc == L'\\')
            {
                lpSrc++;
                // special cases
                // make sure that '\\x' becomes '\x'
                if (*lpSrc == L'\\')
                {
                    *lpDest++ = *lpSrc++;
                }
                // make sure that '\0D' becomes '\r'
                else if (*lpSrc == L'0' && *(lpSrc+1) == L'D')
                {
                    *lpDest++ = L'\r';
                    lpSrc += 2;
                }
                // make sure that '\0A' becomes '\n'
                else if (*lpSrc == L'0' && *(lpSrc+1) == L'A')
                {
                    *lpDest++ = L'\n';
                    lpSrc += 2;
                }
            }
            else
            {
                *lpDest++ = *lpSrc++;
            }
        }

        if (*lpSrc == L',')
        {
            *lpDest++ = L'.';
            lpSrc++;
        }
    }

    *lpDest = L'\0';
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::Initialize
//
//  Synopsis:   Initializes the property page.
//
//  Arguments:  [dwPageType] - used to identify which page this is.  (See
//                              notes.)
//              [pGBI]       - pointer to the browse info structure passed
//                              by caller
//              [ppActive]   - pointer to a common variable that remembers
//                              which object was last given the focus.
//                              Needed because only the page with the focus
//                              is allowed to return data to the caller when
//                              the property sheet is dismissed.
//
//  Returns:    Handle to the newly created property page.
//
//  Modifies:
//
//  Derivation:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This class implements the following property pages:
//                  PAGETYPE_DOMAINS    - GPO's linked to domains
//                  PAGETYPE_SITES      - GPO's linked to sites
//                  PAGETYPE_ALL        - All GPO's in a selected
//
//              PAGETYPE_COMPUTERS is implemented by CCompsPP since it
//              behaves so differently.
//
//---------------------------------------------------------------------------

HPROPSHEETPAGE CBrowserPP::Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void * * ppActive)
{
    m_ppActive = ppActive;
    m_dwPageType = dwPageType;
    m_pGBI = pGBI;

    if (m_pGBI->lpInitialOU)
    {
        //
        // Get the server name
        //

        m_szServerName = ExtractServerName(m_pGBI->lpInitialOU);
        DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::Initialize extracted server name: %s"), m_szServerName));

        //
        // Get the friendly domain name
        //

        LPOLESTR pszDomain = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);

        //
        // Convert LDAP to dot (DN) style
        //

        if (pszDomain)
        {
            ConvertToDotStyle (pszDomain, &m_szDomainName);
            DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::Initialize extracted domain name: %s"), m_szDomainName));
            delete [] pszDomain;
        }
    }

    DWORD dwTitle;
    switch (dwPageType)
    {
    case PAGETYPE_DOMAINS:
        dwTitle = IDS_DOMAINS;
        break;
    case PAGETYPE_SITES:
        dwTitle = IDS_SITES;
        break;
    case PAGETYPE_ALL:
    default:
        dwTitle = IDS_ALL;
        break;
    }
    LoadString(g_hInstance, dwTitle, m_szTitle, sizeof(m_szTitle) / sizeof(WCHAR));

    PROPSHEETPAGE psp;
    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_USETITLE;
    psp.pszTitle = m_szTitle;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_GPOBROWSER);
    return CreatePropertySheetPage(&psp);
}

CBrowserPP::~CBrowserPP()
{
    if (m_szServerName)
    {
        LocalFree(m_szServerName);
    }
    if (m_szDomainName)
    {
        LocalFree(m_szDomainName);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserPP message handlers

INT CBrowserPP::AddElement(MYLISTEL * pel, INT index)
{
    LV_ITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    if (-1 == index)
    {
        index = ListView_GetItemCount(m_hList);
    }
    item.iItem = index;
    item.pszText = pel->szName;

    if (pel->nType == ITEMTYPE_FOREST)
    {
        item.iImage = 10;
    }
    else if (pel->nType == ITEMTYPE_SITE)
    {
        item.iImage = 6;
    }
    else if (pel->nType == ITEMTYPE_DOMAIN)
    {
        item.iImage = 7;
    }
    else if (pel->nType == ITEMTYPE_OU)
    {
        item.iImage = 0;
    }
    else
    {
        if (pel->bDisabled)
        {
            item.iImage = 3;
        }
        else
        {
            item.iImage = 2;
        }
    }

    item.lParam = (LPARAM)pel;
    index = ListView_InsertItem(m_hList, &item);
    if (index != -1 && pel->nType == ITEMTYPE_GPO)
    {
        // check to see if we need to add the domain name
        LPOLESTR szObject = GetCurrentObject();
        LPOLESTR szDomain = GetDomainFromLDAPPath(pel->szData);
        if (szDomain && szObject)
        {
            // ignore potential differences in server name when we compare
            // the domain paths
            LPOLESTR szBuffer1 = NULL;
            LPOLESTR szBuffer2 = NULL;
            szBuffer1 = new OLECHAR[wcslen(szObject) + 1];
            szBuffer2 = new OLECHAR[wcslen(szDomain) + 1];
            if (NULL != szBuffer1 && NULL != szBuffer1)
            {
                CopyAsFriendlyName(szBuffer1, szObject);
                CopyAsFriendlyName(szBuffer2, szDomain);
                if (0 != wcscmp(szBuffer1, szBuffer2))
                {
                    // Need to add the domain name since the domain is different
                    // from the focus object.

                    // Need to convert the domain to a friendly name.
                    // Let's just do it in place so I don't have to allocate any
                    // more memory. :)
                    // We can get away with this because the string can only get smaller.
                    CopyAsFriendlyName(szDomain, szDomain);

                    memset(&item, 0, sizeof(item));
                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 1;
                    item.pszText = szDomain;
                    ListView_SetItem(m_hList, &item);
                }
            }
            if (szBuffer1)
            {
                delete [] szBuffer1;
            }
            if (szBuffer2)
            {
                delete [] szBuffer2;
            }
        }

        if (szDomain)
            delete [] szDomain;
        if (szObject)
            delete [] szObject;
    }
    return (index);
}

#include "ntdsapi.h"

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::FillSitesList
//
//  Synopsis:   Fills the combobox with the trusted sites information.
//              The szData member of the combobox element structure is the
//              containing domain.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    05-04-1998   stevebl   created
//              05-27-1999   stevebl   now initializes to site in lpInitialOU
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::FillSitesList ()
{
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    PDS_NAME_RESULTW pSites;
    int iInitialSite = 0;
    int iIndex = -1;
    HANDLE hDs;

    DWORD dw = DsBindW(NULL, NULL, &hDs);
    if (ERROR_SUCCESS == dw)
    {
        dw = DsListSitesW(hDs, &pSites);
        if (ERROR_SUCCESS == dw)
        {
            DWORD n = 0;
            for (n = 0; n < pSites->cItems; n++)
            {
                //
                // Add the site name (if it has a name)
                //
                if (pSites->rItems[n].pName)
                {
                    LPTSTR lpFullPath, lpTempPath;
                    LOOKDATA * pdata;
                    pdata = new LOOKDATA;
                    if (pdata)
                    {
                        HRESULT hr;
                        ULONG   ulNoChars;

                        ulNoChars = wcslen(pSites->rItems[n].pName)+1;
                        pdata->szName = new WCHAR[ulNoChars];
                        if (pdata->szName)
                        {
                            hr = StringCchCopy(pdata->szName, ulNoChars, pSites->rItems[n].pName);
                            ASSERT(SUCCEEDED(hr));
                        }

                        pdata->szData = NULL;

                        ulNoChars = lstrlen(pSites->rItems[n].pName) + 10;
                        lpTempPath = (LPTSTR) LocalAlloc (LPTR,  ulNoChars * sizeof(TCHAR));

                        if (lpTempPath)
                        {
                            hr = StringCchCopy (lpTempPath, ulNoChars, TEXT("LDAP://"));
                            ASSERT(SUCCEEDED(hr));

                            hr = StringCchCat (lpTempPath, ulNoChars, pSites->rItems[n].pName);
                            ASSERT(SUCCEEDED(hr));

                            lpFullPath = GetFullPath (lpTempPath, m_hwndDlg);

                            if (lpFullPath)
                            {
                                ulNoChars = wcslen(lpFullPath)+1;
                                pdata->szData = new WCHAR[ulNoChars];
                                if (pdata->szData)
                                {
                                    hr = StringCchCopy(pdata->szData, ulNoChars, lpFullPath);
                                    ASSERT(SUCCEEDED(hr));
                                }

                                LocalFree (lpFullPath);
                            }

                            LocalFree (lpTempPath);
                        }

                        if (!pdata->szData)
                        {
                            if (pdata->szName)
                            {
                                delete [] pdata->szName;
                            }

                            delete pdata;
                            continue;
                        }

                        // try and use a friendlier name for the site
                        {
                            IADs * pADs = NULL;
                            // Get the friendly display name
                            hr = OpenDSObject(pdata->szData, IID_IADs,
                                                      (void **)&pADs);

                            if (SUCCEEDED(hr))
                            {
                                VARIANT varName;
                                BSTR bstrNameProp;
                                VariantInit(&varName);
                                bstrNameProp = SysAllocString(SITE_NAME_PROPERTY);

                                if (bstrNameProp)
                                {
                                    hr = pADs->Get(bstrNameProp, &varName);

                                    if (SUCCEEDED(hr))
                                    {
                                        ulNoChars = wcslen(varName.bstrVal) + 1;
                                        LPOLESTR sz = new OLECHAR[ulNoChars];
                                        if (sz)
                                        {
                                            hr = StringCchCopy(sz, ulNoChars, varName.bstrVal);
                                            ASSERT(SUCCEEDED(hr));

                                            if (pdata->szName)
                                                delete [] pdata->szName;
                                            pdata->szName = sz;
                                        }
                                    }
                                    SysFreeString(bstrNameProp);
                                }
                                VariantClear(&varName);
                                pADs->Release();
                            }
                        }
                        pdata->nIndent = 0;
                        pdata->nType = ITEMTYPE_SITE;

                        iIndex = (int)SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) (LPCTSTR) pdata);
                        if (CB_ERR == iIndex)
                        {
                            DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddSitesList: Failed to alloc memory with %d"), GetLastError()));
                        }
                        if (NULL != pdata->szData && NULL != m_pGBI->lpInitialOU)
                        {
                            if (0 == wcscmp(pdata->szData, m_pGBI->lpInitialOU))
                            {
                                iInitialSite = iIndex;
                            }
                        }
                    }
                }
            }
            DsFreeNameResultW(pSites);
        }
        DsUnBindW(&hDs);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddSitesList: DsBindW failed with 0x%x"), dw));
        ReportError(m_hwndDlg, dw, IDS_DSBINDFAILED);
    }

    if (iIndex >= 0)
    {
        SendMessage (m_hCombo, CB_SETCURSEL, iInitialSite, 0);
    }
    SetCursor(hcur);
    return TRUE;
}

PDS_DOMAIN_TRUSTS Domains;

int __cdecl CompareDomainInfo(const void * arg1, const void * arg2)
{
    WCHAR * sz1, *sz2;
    sz1 = Domains[*(ULONG *)arg1].DnsDomainName;
    sz2 = Domains[*(ULONG *)arg2].DnsDomainName;
    if (!sz1)
    {
        sz1 = Domains[*(ULONG *)arg1].NetbiosDomainName;
    }
    if (!sz2)
    {
        sz2 = Domains[*(ULONG *)arg2].NetbiosDomainName;
    }
    return _wcsicmp(sz1,sz2);
}

typedef struct tag_WORKING_LIST_EL
{
    ULONG index;
    struct tag_WORKING_LIST_EL * pNext;
} WORKING_LIST_EL;

//+--------------------------------------------------------------------------
//
//  Function:   BuildDomainList
//
//  Synopsis:   Builds a tree containing all domains that have a trust
//              relationship with the server.
//
//              Siblings within the tree are alphabetized.
//
//  Arguments:  [szServerName] - (NULL for local)
//
//  Returns:    pointer to the root node of the tree (NULL on error)
//
//  History:    10-16-1998   stevebl   Created
//
//  Notes:      Tree nodes must be freed by the caller (using delete).
//
//---------------------------------------------------------------------------

LOOKDATA * BuildDomainList(WCHAR * szServerName)
{
    ULONG DomainCount;
    OLECHAR szBuffer[128];
    HRESULT hr;
    ULONG ulNoChars;

#if FGPO_SUPPORT
    LOOKDATA * pDomainList = new LOOKDATA;

    if (!pDomainList)
    {
        // failed to even create the Forest node!
        return NULL;
    }

    pDomainList->szData = GetPathToForest(szServerName);

    if (!pDomainList->szData)
    {
        delete pDomainList;
        return NULL;
    }

    // load the name for the forest from resources
    if (0 == LoadStringW(g_hInstance, IDS_FOREST, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])))
    {
        // failed to get the resource name
        delete pDomainList;
        return NULL;
    }

    ulNoChars = lstrlen(szBuffer) + 1;
    pDomainList->szName = new OLECHAR [ulNoChars];
    if (NULL == pDomainList->szName)
    {
        // not enough memory to create name of the forest node
        delete pDomainList;
        return NULL;
    }
    hr = StringCchCopy(pDomainList->szName, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    pDomainList->nIndent = 0;
    pDomainList->nType = ITEMTYPE_FOREST;
    pDomainList->pParent = NULL;
    pDomainList->pSibling = NULL;
    pDomainList->pChild = NULL;
#else
    LOOKDATA * pDomainList = NULL;
#endif

    long l = DsEnumerateDomainTrusts(szServerName,
                                     DS_DOMAIN_IN_FOREST | DS_DOMAIN_NATIVE_MODE | 
                                     DS_DOMAIN_PRIMARY   | DS_DOMAIN_TREE_ROOT,
                                     &Domains,
                                     &DomainCount);
    //
    // Some of the below code might be unnecessary since DsEnumerateTrusts will no
    // longer return domains from other forests. Shouldn't do any harm though..
    //

    if ((0 == l) && (DomainCount > 0))
    {
        // sort the list of domains alphabetically
        ULONG * rgSorted = new ULONG[DomainCount];
        if (rgSorted)
        {
            ULONG uCount = DomainCount;
            while (uCount--)
            {
                rgSorted[uCount] = uCount;
            }
            qsort(rgSorted, DomainCount, sizeof (ULONG), CompareDomainInfo);

            // Build a working list of the domains, sorted alphabetically in
            // INVERTED order.

            WORKING_LIST_EL * pWorkList = NULL;

            LOOKDATA ** rgDataMap = new LOOKDATA * [DomainCount];
            if (rgDataMap)
            {
                uCount = 0;
                while (uCount < DomainCount)
                {
                    WORKING_LIST_EL * pNew = new WORKING_LIST_EL;
                    if (pNew)
                    {
                        pNew->index = rgSorted[uCount];
                        pNew->pNext = pWorkList;
                        pWorkList = pNew;
                    }
                    rgDataMap[uCount] = NULL;
                    uCount++;
                }

                // Build the ordered tree of domains by removing domains from the
                // working list and inserting them into the new tree until there are
                // none left in the working list.

                // NOTE - if this routine runs out of memory it will begin
                // to drop nodes rather than AV.

                WORKING_LIST_EL ** ppWorker;

                BOOL fContinue = TRUE;
                while (pWorkList && fContinue)
                {
                    fContinue = FALSE;
                    ppWorker = &pWorkList;
                    while (*ppWorker)
                    {
                        if (NULL == Domains[(*ppWorker)->index].DnsDomainName)
                        {
                            //
                            // For now, if it doesn't have a
                            // DnsDomainName then we're going to
                            // skip it.
                            // Eventually we'll want to make sure it doesn't
                            // have a DC by calling DsGetDcName with
                            // DS_DIRECTORY_SERVICE_PREFERRED.

                            // remove it from the worker list
                            WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                            delete *ppWorker;
                            *ppWorker = pNext;
                        }
                        else
                        {
                            // Does this node have a parent?
                            ULONG flags = Domains[(*ppWorker)->index].Flags;
                            if ((0 != (flags & DS_DOMAIN_IN_FOREST)) && (0 == (flags & DS_DOMAIN_TREE_ROOT)))
                            {
                                // it has a parent has its parent been added?
                                LOOKDATA * pParent = rgDataMap[Domains[(*ppWorker)->index].ParentIndex];
                                if (pParent != NULL)
                                {
                                    // its parent has been added
                                    // insert this one in its parent's child list
                                    LOOKDATA * pData = new LOOKDATA;
                                    if (pData)
                                    {

                                        WCHAR * szName = Domains[(*ppWorker)->index].DnsDomainName;
                                        if (!szName)
                                        {
                                            szName = Domains[(*ppWorker)->index].NetbiosDomainName;
                                        }
                                        ulNoChars = wcslen(szName) + 1;
                                        pData->szName = new WCHAR[ulNoChars];
                                        if (pData->szName)
                                        {
                                            int cch = 0;
                                            int count=0;
                                            // count the dots in szName;
                                            while (szName[count])
                                            {
                                                if (L'.' == szName[count])
                                                {
                                                    cch++;
                                                }
                                                count++;
                                            }
                                            cch *= 3; // multiply the number of dots by 3;
                                            cch += 11; // add 10 + 1 (for the null)
                                            cch += count; // add the string size;
                                            pData->szData = new WCHAR[cch];
                                            if (pData->szData)
                                            {
                                                NameToPath(pData->szData, szName, cch);
                                                hr = StringCchCopy(pData->szName, ulNoChars, szName);
                                                ASSERT(SUCCEEDED(hr));
                                                pData->nIndent = pParent->nIndent+1;
                                                pData->nType = ITEMTYPE_DOMAIN;
                                                pData->pParent = pParent;
                                                pData->pSibling = pParent->pChild;
                                                pData->pChild = NULL;
                                                pParent->pChild = pData;
                                                rgDataMap[(*ppWorker)->index] = pData;
                                                // make sure we remember
                                                // that we added something
                                                // to the master list (helps
                                                // us avoid infinite loops
                                                // in case of an error)
                                                fContinue = TRUE;
                                            }
                                            else
                                            {
                                                delete [] pData->szName;
                                                delete pData;
                                            }
                                        }
                                        else
                                        {
                                            delete pData;
                                        }
                                    }
                                    // and remove it from the worker list
                                    WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                                    delete *ppWorker;
                                    *ppWorker = pNext;
                                }
                                else
                                {
                                    // skip it for now
                                    ppWorker = &((*ppWorker)->pNext);
                                }
                            }
                            else
                            {
                                // it doesn't have a parent add it just under the forest
                                // level of the list
                                LOOKDATA * pData = new LOOKDATA;
                                if (pData)
                                {
                                    WCHAR * szName = Domains[(*ppWorker)->index].DnsDomainName;
                                    if (!szName)
                                    {
                                        szName = Domains[(*ppWorker)->index].NetbiosDomainName;
                                    }
                                    ulNoChars = wcslen(szName) + 1;
                                    pData->szName = new WCHAR[ulNoChars];
                                    if (pData->szName)
                                    {
                                        int cch = 0;
                                        int count=0;
                                        // count the dots in szName;
                                        while (szName[count])
                                        {
                                            if (L'.' == szName[count])
                                            {
                                                cch++;
                                            }
                                            count++;
                                        }
                                        cch *= 3; // multiply the number of dots by 3;
                                        cch += 11; // add 10 + 1 for the null
                                        cch += count; // add the string size;
                                        pData->szData = new WCHAR[cch];
                                        if (pData->szData)
                                        {
                                            NameToPath(pData->szData, szName, cch);
                                            hr = StringCchCopy(pData->szName, ulNoChars, szName);
                                            ASSERT(SUCCEEDED(hr));
#if FGPO_SUPPORT
                                            pData->nIndent = 1;
                                            pData->nType = ITEMTYPE_DOMAIN;
                                            pData->pParent = pDomainList;
                                            pData->pSibling = pDomainList->pChild;
                                            pData->pChild = NULL;
                                            pDomainList->pChild = pData;
#else
                                            pData->nIndent = 0;
                                            pData->nType = ITEMTYPE_DOMAIN;
                                            pData->pParent = NULL;
                                            pData->pSibling = pDomainList;
                                            pData->pChild = NULL;
                                            pDomainList = pData;
#endif
                                            rgDataMap[(*ppWorker)->index] = pData;
                                            // make sure we remember
                                            // that we added something
                                            // to the master list (helps
                                            // us avoid infinite loops
                                            // in case of an error)
                                            fContinue = TRUE;
                                        }
                                        else
                                        {
                                            delete [] pData->szName;
                                            delete pData;
                                        }
                                    }
                                    else
                                    {
                                        delete pData;
                                    }
                                }
                                // and remove it from the worker list
                                WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                                delete *ppWorker;
                                *ppWorker = pNext;
                            }

                        }
                    }
                }
                delete [] rgDataMap;
            }
            delete [] rgSorted;
        }
        NetApiBufferFree(Domains);
    }
    else
    {
        if (0 != l)
        {
            DebugMsg((DM_WARNING, TEXT("DsEnumerateDomainTrustsW failed with %u"), l));
        }
    }
    return pDomainList;
}

VOID FreeDomainInfo (LOOKDATA * pEntry)
{

    if (!pEntry)
    {
        return;
    }

    if (pEntry->pChild)
    {
        FreeDomainInfo (pEntry->pChild);
    }

    if (pEntry->pSibling)
    {
        FreeDomainInfo (pEntry->pSibling);
    }

    delete [] pEntry->szName;
    delete pEntry;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::FillDomainList
//
//  Synopsis:   Fills the combobox with the trusted domain information.
//              The szData member of the combobox element structure is the
//              LDAP domain name.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    04-30-1998   stevebl   Modified from original version
//                                     written by EricFlo
//              10-20-1998   stevebl   Heavily modified to support domains
//                                     "outside the forest" and to fix a
//                                     whole passle o' bugs.
//
//  Note:       This routine also sets the focus to the domain of the object
//              passed in via the lpInitialOU member of the GPOBROWSEINFO
//              structure.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::FillDomainList ()
{
    BOOL bResult = TRUE;
    HRESULT hr;
    DWORD dwIndex;
    BOOL fEnableBackbutton = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    WCHAR * szBuffer1 = NULL;
    if (m_pGBI->lpInitialOU)
    {
        if (IsForest(m_pGBI->lpInitialOU))
        {
            szBuffer1 = new TCHAR[128];
            LoadStringW(g_hInstance, IDS_FOREST, szBuffer1, 128);
        }
        else
        {
            WCHAR * sz = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);
            if (sz)
            {
                szBuffer1 = new WCHAR[wcslen(sz) + 1];
                if (szBuffer1)
                {
                    CopyAsFriendlyName(szBuffer1, sz);
                }
                delete [] sz;
            }
        }
    }

    LOOKDATA * pDomainList = BuildDomainList(m_szServerName);

    if (!pDomainList)
    {
        ReportError(m_hwndDlg, GetLastError(), IDS_DOMAINLIST);
    }

    // Walk the ordered tree of domains, inserting each one into the
    // dialog box

    DWORD dwInitialDomain = -1;

    // start at the head
    while (pDomainList)
    {
        WCHAR * szBuffer2 = NULL;
        // add this node
        dwIndex = (DWORD)SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList);
        szBuffer2 = new WCHAR[wcslen(pDomainList->szData) + 1];
        if (szBuffer2)
        {
            CopyAsFriendlyName(szBuffer2, pDomainList->szData);
        }
        if (NULL != szBuffer1 && NULL !=szBuffer2 && 0 ==_wcsicmp(szBuffer1, szBuffer2))
        {
            // replace the domain path with the path provided by the caller
            // (because it contains the server)

            WCHAR * sz = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);
            if (sz)
            {
                DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::FillDomainList: Resetting domain path to user specified path: %s"), sz));
                delete [] pDomainList->szData;
                pDomainList->szData = sz;
            }
            dwInitialDomain = dwIndex;
            if (pDomainList->nIndent > 0)
                fEnableBackbutton = TRUE;
        }
        if (szBuffer2)
        {
            delete [] szBuffer2;
        }

        if (pDomainList->pChild)
        {
            // go to its child
            pDomainList = pDomainList->pChild;
        }
        else
        {
            if (pDomainList->pSibling)
            {
                // go to its sibling if there are no children
                pDomainList = pDomainList->pSibling;
            }
            else
            {
                // there are no children and no siblings
                // back up until we find a parent with a sibling
                // or there are no more parents (we're done)
                do
                {
                    pDomainList = pDomainList->pParent;
                    if (pDomainList)
                    {
                        if (pDomainList->pSibling)
                        {
                            pDomainList = pDomainList->pSibling;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                } while (TRUE);
            }
        }
    }
    if (szBuffer1)
    {
        delete [] szBuffer1;
    }

    if (-1 == dwInitialDomain)
    {
        // didn't find the initial domain anywhere in that list
        // Set the first entry by default
        dwInitialDomain = 0;
    }

    SendMessage (m_hCombo, CB_SETCURSEL, dwInitialDomain, 0);
    SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(fEnableBackbutton, 0));
    SetCursor(hcur);
    return bResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::SetInitialOU
//
//  Synopsis:   Adds nodes to the combobox until the initial OU specified by
//              the caller via the lpInitalOU member of the GPOBROWSEINFO
//              structure is present and gives it the focus.
//
//  Returns:    TRUE - success
//
//  History:    10-20-1998   stevebl   Created
//
//  Notes:      This routine assumes that FillDomainList() was just called.
//              It will not work properly otherwise.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::SetInitialOU()
{
    if (!m_pGBI->lpInitialOU)
    {
        // nothing requested so nothing required
        return TRUE;
    }
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::SetInitialOU: No object selected.")));
         return FALSE;
    }

    // get the current object to see what's selected
    LOOKDATA * pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdataSelected)
    {
        // is it the same as the requested object?
        WCHAR * szSelected = NULL;
        WCHAR * szRequested = NULL;
        szSelected = new WCHAR[wcslen(pdataSelected->szData) + 1];
        if (szSelected)
        {
            CopyAsFriendlyName(szSelected, pdataSelected->szData);
        }
        szRequested = new WCHAR[wcslen(m_pGBI->lpInitialOU + 1)];
        if (NULL != szSelected && NULL != szRequested && 0 != wcscmp(szSelected, szRequested))
        {
            // it's not the same
            // try and bind to the requested object
            IADs * pADs = NULL;
            HRESULT hr = OpenDSObject(m_pGBI->lpInitialOU,
                                       IID_IADs, (void **)&pADs);
            if (SUCCEEDED(hr))
            {
                // the requested object exists and we have access permission

                // now make sure that it's a domain or OU
                BOOL fDomainOrOU = FALSE;
                VARIANT var;
                VariantInit(&var);
                BSTR bstrProperty = SysAllocString(L"objectClass");

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);
                    if (SUCCEEDED(hr))
                    {
                        int cElements = var.parray->rgsabound[0].cElements;
                        VARIANT * rgData = (VARIANT *)var.parray->pvData;
                        while (cElements--)
                        {
                            if (0 == _wcsicmp(L"domain", rgData[cElements].bstrVal))
                            {
                                fDomainOrOU = TRUE;
                            }
                            if (0 == _wcsicmp(L"organizationalUnit", rgData[cElements].bstrVal))
                            {
                                fDomainOrOU = TRUE;
                            }
                        }
                    }
                    SysFreeString(bstrProperty);
                }
                VariantClear(&var);
                pADs->Release();

                if (fDomainOrOU)
                {
                    LOOKDATA * pLast = NULL;
                    LOOKDATA * pNew = NULL;

                    // build a list of nodes
                    // repeat removing leaf nodes until we're down to the domain
                    // (which will be the same as the selected object)
                    IADsPathname * pADsPathname = NULL;
                    BSTR bstr;
                    hr = CoCreateInstance(CLSID_Pathname,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IADsPathname,
                                          (LPVOID*)&pADsPathname);

                    if (SUCCEEDED(hr))
                    {
                        BSTR bstrInitialOU = SysAllocString( m_pGBI->lpInitialOU );
                        if ( bstrInitialOU != NULL )
                        {
                            hr = pADsPathname->Set( bstrInitialOU, ADS_SETTYPE_FULL );
                            if (SUCCEEDED(hr))
                            {
                                while (TRUE)
                                {
                                    // add this node to the list
                                    hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                                    if (FAILED(hr))
                                    {
                                        break;
                                    }

                                    if (szRequested)
                                    {
                                        delete [] szRequested;
                                    }
                                    szRequested = new WCHAR[wcslen(bstr) + 1];
                                    if (szRequested)
                                    {
                                        CopyAsFriendlyName(szRequested, bstr);
                                    }
                                    if (NULL != szRequested && 0 == wcscmp(szSelected, szRequested))
                                    {
                                        // we're back to the first node
                                        SysFreeString(bstr);
                                        break;
                                    }

                                    pNew = new LOOKDATA;
                                    if (!pNew)
                                    {
                                        // ran out of memory
                                        SysFreeString(bstr);
                                        break;
                                    }

                                    ULONG ulNoCharsRequested = wcslen(szRequested) + 1;

                                    pNew->szName  = new WCHAR[ulNoCharsRequested];
                                    if (!pNew->szName)
                                    {
                                        // ran out of memory
                                        delete pNew;
                                        SysFreeString(bstr);
                                        break;
                                    }

                                    ULONG ulNoChars = wcslen(bstr) + 1;

                                    pNew->szData = new WCHAR[ulNoChars];
                                    if (!pNew->szData)
                                    {
                                        // ran out of memory
                                        delete [] pNew->szName;
                                        delete pNew;
                                        SysFreeString(bstr);
                                        break;
                                    }
                                    hr = StringCchCopy(pNew->szData, ulNoChars, bstr);
                                    ASSERT(SUCCEEDED(hr));

                                    hr = StringCchCopy(pNew->szName, ulNoCharsRequested, szRequested);
                                    ASSERT(SUCCEEDED(hr));

                                    SysFreeString(bstr);
                                    pNew->nIndent = 0;
                                    pNew->nType = ITEMTYPE_OU;
                                    pNew->pParent = NULL;
                                    pNew->pSibling = NULL;
                                    pNew->pChild = pLast;
                                    if (pLast)
                                    {
                                        pLast->pParent = pNew;
                                    }
                                    pLast = pNew;

                                    // strip off a leaf node and go again

                                    hr = pADsPathname->RemoveLeafElement();
                                    if (FAILED(hr))
                                    {
                                        break;
                                    }
                                }
                            }

                            SysFreeString( bstrInitialOU );
                        }
                        pADsPathname->Release();
                    }

                    // At this point I should have a list of LOOKDATA nodes
                    // (in pLast).
                    // The only things left to do are to link them into the
                    // tree, set their nIndent members, add them to the combo
                    // box and set the combo box's focus to the last one.

                    if (pLast)
                    {
                        // link in the list
                        pLast->pSibling = pdataSelected->pChild;
                        pLast->pParent = pdataSelected;
                        pLast->nIndent = pdataSelected->nIndent+1;
                        pdataSelected->pChild = pLast;
                        // now walk the tree, adding entries to the combo box
                        // and updating the nIndent members
                        while (pLast)
                        {
                            iIndex = (int)SendMessage(m_hCombo, CB_INSERTSTRING, iIndex+1, (LPARAM)(LPCTSTR) pLast);

                            if (pLast->pChild)
                            {
                                pLast->pChild->nIndent = pLast->nIndent+1;
                            }
                            pLast = pLast->pChild;
                        }
                        if (iIndex != CB_ERR)
                        {
                            SendMessage(m_hCombo, CB_SETCURSEL, iIndex, 0);
                            SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                        }
                    }
                }
            }
        }
        if (szSelected)
        {
            delete [] szSelected;
        }
        if (szRequested)
        {
            delete [] szRequested;
        }
    }
    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::GetCurrentObject
//
//  Synopsis:   returns the LDAP path to the currently selected object
//
//  Arguments:  [] -
//
//  Returns:    NULL if no ojbect is selected else the LDAP path of the object
//
//  Modifies:
//
//  Derivation:
//
//  History:    5-05-1998   stevebl   Created
//              06-23-1999   stevebl   Added logic to give DCs names
//
//  Notes:
//              Checks to see if a domain has a named server.  If it doesn't
//              then it calls GetDCName to get it one.
//
//---------------------------------------------------------------------------

LPOLESTR CBrowserPP::GetCurrentObject()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetCurrentObject: No object selected.")));
         return NULL;
    }

    LPOLESTR sz=NULL;
    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (pdata->szData)
        {
            HRESULT hr;
            ULONG ulNoChars;

            if (ITEMTYPE_DOMAIN == pdata->nType)
            {
                // make sure that domains are resolved to a server
                LPTSTR szServer = ExtractServerName(pdata->szData);
                if (NULL == szServer)
                {
                    LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                    if (szTemp)
                    {
                        LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                        if (szFullPath)
                        {
                            ulNoChars = wcslen(szFullPath)+1;
                            LPWSTR szTemp2 = new WCHAR[ulNoChars];
                            if (szTemp2)
                            {
                                hr = StringCchCopy (szTemp2, ulNoChars, szFullPath);
                                ASSERT(SUCCEEDED(hr));

                                delete [] pdata->szData;
                                pdata->szData = szTemp2;
                            }
                            LocalFree(szFullPath);
                        }
                        LocalFree(szTemp);
                    }
                    else
                    {
                        return NULL;
                    }
                }
                else
                {
                    LocalFree(szServer);
                }
            }

            ulNoChars = wcslen(pdata->szData) + 1;
            sz = new OLECHAR[ulNoChars];
            if (sz)
            {
                hr = StringCchCopy(sz, ulNoChars, pdata->szData);
                ASSERT(SUCCEEDED(hr));
            }
        }
    }
    return sz;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::IsCurrentObjectAForest
//
//  Synopsis:   tests to see if the currently selected object is a forest
//
//  Arguments:  [] -
//
//  Returns:    TRUE  - if it is a forest
//              FALSE - otherwise
//
//  History:    03-31-2000   stevebl   Created
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::IsCurrentObjectAForest()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::IsCurrentObjectAForest: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    return (ITEMTYPE_FOREST == pdata->nType);
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::GetCurrentDomain
//
//  Synopsis:   returns the domain of the currently selecte object (if the
//              currently currently selected object is the domain then they
//              are one and the same)
//
//  Arguments:  [] -
//
//  Returns:    NULL - if no object is selected else returns LDAP path of
//              domain
//
//  History:    05-04-1998   stevebl   Created
//              06-23-1999   stevebl   Added logic to give DCs names
//
//  Notes:      Checks to see if a domain has a named server.  If it doesn't
//              then it calls GetDCName to get it one.
//
//---------------------------------------------------------------------------

LPOLESTR CBrowserPP::GetCurrentDomain()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetCurrentDomain: No object selected.")));
         return NULL;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    switch (pdata->nType)
    {
    case ITEMTYPE_DOMAIN:
        {
            if (pdata->szData)
            {
                HRESULT hr;
                ULONG ulNoChars; 

                // make sure the domain has a server
                LPTSTR szServer = ExtractServerName(pdata->szData);
                if (NULL == szServer)
                {
                    LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                    if (szTemp)
                    {
                        LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                        if (szFullPath)
                        {
                            ulNoChars = wcslen(szFullPath)+1;
                            LPWSTR sz = new WCHAR[ulNoChars];
                            if (sz)
                            {
                                hr = StringCchCopy(sz, ulNoChars, szFullPath);
                                ASSERT(SUCCEEDED(hr));
                                delete [] pdata->szData;
                                pdata->szData = sz;
                            }
                            LocalFree(szFullPath);
                        }
                        LocalFree(szTemp);
                    }
                    else
                    {
                        return NULL;
                    }
                }
                else
                {
                    LocalFree(szServer);
                }
                ulNoChars = wcslen(pdata->szData)+1;
                LPOLESTR sz = new OLECHAR[ulNoChars];
                if (sz)
                {
                    hr = StringCchCopy(sz, ulNoChars, pdata->szData);
                    ASSERT(SUCCEEDED(hr));
                }
                return sz;
            }
            return NULL;
        }
    case ITEMTYPE_FOREST:
    case ITEMTYPE_SITE:
    case ITEMTYPE_OU:
        {
            return GetDomainFromLDAPPath(pdata->szData);
        }
        break;
    default:
        break;
    }
    return NULL;
}

BOOL CBrowserPP::AddGPOsLinkedToObject()
{
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPOLESTR lpObject;
    HRESULT hr;
    IADs * pADs = NULL;
    IADs * pADsGPO;
    VARIANT var;
    BSTR bstrProperty;
    BOOL fResult = FALSE;
    int index = ListView_GetItemCount(m_hList);

    //
    // Get the current object name
    //
    lpObject = GetCurrentObject();
    if (NULL == lpObject)
    {
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::AddGPOsLinkedToObject: Reading gPLink property from %s"), lpObject));

    hr = OpenDSObject(lpObject, IID_IADs, (void **)&pADs);

    delete [] lpObject;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: OpenDSObject failed with 0x%x"), hr));
        ReportError(m_hwndDlg, hr, IDS_FAILEDGPLINK);
        goto Exit;
    }

    VariantInit(&var);

    bstrProperty = SysAllocString(GPM_LINK_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            LPOLESTR szGPOList = var.bstrVal;
            OLECHAR * pchTemp;
            OLECHAR * pchGPO;
            VARIANT varName;
            BSTR bstrNameProp;

            if (szGPOList)
            {
                OLECHAR * szGPO = new WCHAR[wcslen(szGPOList) + 1];
                if (szGPO)
                {
                    pchTemp = szGPOList;
                    while (TRUE)
                    {
                        // Look for the [
                        while (*pchTemp && (*pchTemp != L'['))
                            pchTemp++;
                        if (!(*pchTemp))
                            break;

                        pchTemp++;

                        // Copy the GPO name
                        pchGPO = szGPO;

                        while (*pchTemp && (*pchTemp != L';'))
                            *pchGPO++ = *pchTemp++;

                        *pchGPO = L'\0';

                        // Add the object to the list view
                        MYLISTEL * pel = new MYLISTEL;
                        if (pel)
                        {

                            pel->szData = NULL;
                            pel->bDisabled = FALSE;

                            LPTSTR szFullGPOPath = GetFullPath(szGPO, m_hwndDlg);

                            if (szFullGPOPath)
                            {
                                ULONG ulNoChars = wcslen(szFullGPOPath) + 1;
                                pel->szData = new WCHAR[ulNoChars];
                                if (pel->szData)
                                {
                                    hr = StringCchCopy(pel->szData, ulNoChars, szFullGPOPath);
                                    ASSERT(SUCCEEDED(hr));
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Failed to allocate memory for new full gpo path")));
                                    LocalFree(szFullGPOPath);
                                    delete pel;
                                    continue;
                                }

                                LocalFree(szFullGPOPath);
                            }
                            else
                            {
                                DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Failed to get full gpo path")));
                                delete pel;
                                continue;
                            }

                            VariantInit(&varName);

                            // get the friendly display name
                            hr = OpenDSObject(pel->szData, IID_IADs,
                                              (void **)&pADsGPO);

                            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                            {
                                delete pel;
                                continue;
                            }

                            if (SUCCEEDED(hr))
                            {
                                bstrNameProp = SysAllocString(GPO_NAME_PROPERTY);

                                if (bstrNameProp)
                                {
                                    hr = pADsGPO->Get(bstrNameProp, &varName);
                                    SysFreeString(bstrNameProp);
                                }
                                else
                                {
                                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                                }

                                pADsGPO->Release();
                            }

                            if (FAILED(hr))
                            {
                                DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Couldn't get display name for %s with 0x%x"), pel->szData, hr));
                                pel->szName = new WCHAR[200];
                                if (pel->szName)
                                {
                                    LoadString(g_hInstance, IDS_GPM_NOGPONAME, pel->szName, 200);
                                }
                                pel->bDisabled = TRUE;
                            }
                            else
                            {
                                ULONG ulNoChars = wcslen(varName.bstrVal) + 1;
                                pel->szName = new WCHAR[ulNoChars];
                                if (pel->szName)
                                {
                                    hr = StringCchCopy(pel->szName, ulNoChars, varName.bstrVal);
                                    ASSERT(SUCCEEDED(hr));
                                }
                            }

                            VariantClear(&varName);

                            pel->nType = ITEMTYPE_GPO;

                            AddElement(pel, index);
                        }
                    }
                    delete [] szGPO;
                }
            }
        }

        SysFreeString(bstrProperty);
    }

    VariantClear(&var);

    fResult = TRUE;

Exit:
    if (pADs)
    {
        pADs->Release();
    }
    SetCursor(hcur);
    return fResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::AddGPOsForDomain
//
//  Synopsis:   Adds all the GPOs in the specified domain to the list view
//              control.   The szData member of the list element structure
//              contains the LDAP path of the GPO.
//
//              The domain is indicated by the currently selected combobox
//              element.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    04-30-1998   stevebl   Modified from original routine
//                                     written by EricFlo.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::AddGPOsForDomain()
{
    LPTSTR lpDomain;
    LPTSTR lpGPO;
    INT iIndex;
    VARIANT var;
    VARIANT varGPO;
    ULONG ulResult;
    HRESULT hr = E_FAIL;
    IADsPathname * pADsPathname = NULL;
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    IEnumVARIANT *pVar = NULL;
    BSTR bstrContainer = NULL;
    BSTR bstrCommonName = NULL;
    BSTR bstrDisplayName = NULL;
    BSTR bstrGPO = NULL;
    TCHAR szDisplayName[512];
    TCHAR szCommonName[50];
    MYLISTEL * pel;
    ULONG ulNoChars;

    //
    // Test to see if we're focused on a forest
    //

    BOOL fForest = IsCurrentObjectAForest();

    //
    // Get the current domain name
    //

    lpDomain = GetCurrentDomain();

    if (!lpDomain)
    {
         DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: NULL domain name.")));
         return FALSE;
    }

    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    BSTR bstrDomain = SysAllocString( lpDomain );
    if ( bstrDomain == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set (bstrDomain, ADS_SETTYPE_FULL);
    SysFreeString( bstrDomain );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    BSTR bstrFolder = NULL;
    if (fForest)
    {
        //
        // Add the configuration folder to the path
        //

        bstrFolder = SysAllocString( TEXT("CN=Configuration") );
    }
    else
    {
        //
        // Add the system folder to the path
        //

        bstrFolder = SysAllocString( TEXT("CN=System") );
    }

    if ( bstrFolder == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrFolder);
    SysFreeString( bstrFolder );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add system folder with 0x%x"), hr));
        goto Exit;
    }

    //
    // Add the policies container to the path
    //

    BSTR bstrCNPolicies = SysAllocString( TEXT("CN=Policies") );
    if ( bstrCNPolicies == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrCNPolicies);
    SysFreeString( bstrCNPolicies );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add policies folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path - this is the path to the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Release the pathname object
    //

    pADsPathname->Release();
    pADsPathname = NULL;


    //
    // Build an enumerator
    //

    hr = OpenDSObject(bstrContainer, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get gpo container interface with 0x%x for object %s"),
                     hr, bstrContainer));
            ReportError(m_hwndDlg, hr, IDS_FAILEDGPLINK);
        }
        goto Exit;
    }


    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }

    bstrCommonName = SysAllocString (L"cn");

    if (!bstrCommonName)
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    bstrDisplayName = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    //
    // Enumerate
    //

    while (TRUE)
    {
        BOOL fNeedDisplayName = FALSE;

        VariantInit(&var);
        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to enumerator with 0x%x"), hr));
            VariantClear (&var);
            break;
        }

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        //
        // If var.vt isn't VT_DISPATCH, we're finished.
        //

        if (var.vt != VT_DISPATCH)
        {
            VariantClear (&var);
            break;
        }


        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get IDispatch interface")));
            goto LoopAgain;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this GPO.
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Get the display name
        //

        VariantInit(&varGPO);

        hr = pADs->Get(bstrDisplayName, &varGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get display name with 0x%x"),hr));
            fNeedDisplayName = TRUE;
        }
        else
        {
            wcsncpy (szDisplayName, varGPO.bstrVal, (sizeof(szDisplayName) / sizeof(szDisplayName[0])) - 1);
        }

        VariantClear (&varGPO);


        //
        // Get the common name
        //

        VariantInit(&varGPO);

        hr = pADs->Get(bstrCommonName, &varGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get common name with 0x%x"),hr));
            VariantClear (&varGPO);
            pADs->Release();
            goto LoopAgain;
        }

        hr = StringCchCopy (szCommonName, ARRAYSIZE(szCommonName), TEXT("CN="));
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szCommonName, ARRAYSIZE(szCommonName), varGPO.bstrVal);
        }

        //
        // Clean up
        //

        VariantClear (&varGPO);
        pADs->Release();
        
        if (FAILED(hr)) 
        {
            goto LoopAgain;
        }

        //
        // Create a pathname object so we can tack the common name
        // onto the end of the LDAP path
        //

        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (LPVOID*)&pADsPathname);


        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to create adspathname instance with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Add the LDAP path
        //

        hr = pADsPathname->Set (bstrContainer, ADS_SETTYPE_FULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to set the ldap path with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Add the GPO's common name
        //

        BSTR bstrTmpCommonName = SysAllocString( szCommonName );
        if ( bstrTmpCommonName == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate BSTR memory.")));
            hr = E_OUTOFMEMORY;
            goto LoopAgain;
        }
        hr = pADsPathname->AddLeafElement (bstrTmpCommonName);
        SysFreeString( bstrTmpCommonName );

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add the common name with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Retreive the gpo path
        //

        hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to retreive gpo path with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Make a copy of it
        //

        ulNoChars = wcslen(bstrGPO) + 1;
        lpGPO = new WCHAR[ulNoChars];

        if (!lpGPO)
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to alloc memory for gpo path with 0x%x"),
                     GetLastError()));
            goto LoopAgain;
        }

        hr = StringCchCopy (lpGPO, ulNoChars, bstrGPO);
        ASSERT(SUCCEEDED(hr));

        pel = new MYLISTEL;
        if (pel)
        {
            if (fNeedDisplayName)
            {
                pel->szName = new WCHAR[wcslen(lpGPO) + 1];
                if (pel->szName)
                {
                    CopyAsFriendlyName(pel->szName, lpGPO);
                }
            }
            else
            {
                ulNoChars = wcslen(szDisplayName) + 1;
                pel->szName = new WCHAR[ulNoChars];
                if (pel->szName)
                {
                    hr = StringCchCopy(pel->szName, ulNoChars, szDisplayName);
                    ASSERT(SUCCEEDED(hr));
                }
            }
            pel->szData = lpGPO;
            pel->nType = ITEMTYPE_GPO;
            pel->bDisabled = FALSE;

            AddElement(pel, -1);
        }

LoopAgain:

        if (pADsPathname)
        {
            pADsPathname->Release();
            pADsPathname = NULL;
        }

        if (bstrGPO)
        {
            SysFreeString (bstrGPO);
            bstrGPO = NULL;
        }

        VariantClear (&var);
    }


    SendMessage (m_hList, LB_SETCURSEL, 0, 0);

Exit:

    if (pVar)
    {
        ADsFreeEnumerator (pVar);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (pADsContainer)
    {
        pADsContainer->Release();
    }

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (bstrCommonName)
    {
        SysFreeString (bstrCommonName);
    }

    if (bstrDisplayName)
    {
        SysFreeString (bstrDisplayName);
    }

    if (lpDomain)
    {
        delete [] lpDomain;
    }

    SetCursor(hcur);

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::AddChildContainers
//
//  Synopsis:   Adds the child domains and OUs for the currently selected object
//
//  History:    05-006-1998   stevebl   Created
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::AddChildContainers()
{
    LPOLESTR szObject = NULL;
    HRESULT hr;
    ULONG ulNoChars;

    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddChildContainers: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (ITEMTYPE_DOMAIN == pdata->nType)
        {
            // make sure that domains are resolved to a server
            LPTSTR szServer = ExtractServerName(pdata->szData);
            if (NULL == szServer)
            {
                BOOL bDCFound = FALSE;
                LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                if (szTemp)
                {
                    LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                    if (szFullPath)
                    {
                        ulNoChars = wcslen(szFullPath)+1;
                        LPWSTR sz = new WCHAR[ulNoChars];
                        if (sz)
                        {
                            hr = StringCchCopy(sz, ulNoChars, szFullPath);
                            ASSERT(SUCCEEDED(hr));

                            delete [] pdata->szData;
                            pdata->szData = sz;
                            bDCFound = TRUE;
                        }
                        LocalFree(szFullPath);
                    }
                    LocalFree(szTemp);
                }

                if (!bDCFound)
                {
                    DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddChildContainers: Failed to get a DC name for %s"),
                              pdata->szName));
                    return FALSE;
                }
            }
            else
            {
                LocalFree(szServer);
            }
        }
        LOOKDATA * pChild = pdata->pChild;
        while (pChild)
        {
            // Add child domains this way since ADsEnumerateNext doesn't
            // seem to be giving them to us.
            if (ITEMTYPE_DOMAIN == pChild->nType)
            {
                // got something we can work with
                MYLISTEL * pel = new MYLISTEL;
                if (pel)
                {
                    memset(pel, 0, sizeof(MYLISTEL));
                    ulNoChars = wcslen(pChild->szData) + 1;
                    pel->szData = new OLECHAR[ulNoChars];
                    if (pel->szData)
                    {
                        hr = StringCchCopy(pel->szData, ulNoChars, pChild->szData);
                        ASSERT(SUCCEEDED(hr));
                    }

                    ulNoChars = wcslen(pChild->szName) +  1;
                    pel->szName = new OLECHAR[ulNoChars];
                    if (pel->szName)
                    {
                        hr = StringCchCopy(pel->szName, ulNoChars, pChild->szName);
                        ASSERT(SUCCEEDED(hr));
                    }
                    pel->bDisabled = FALSE;
                    pel->nType = ITEMTYPE_DOMAIN;
                    INT index = -1;
                    AddElement(pel, -1);
                }
                pChild = pChild->pSibling;
            }

        }
        szObject = pdata->szData;
        m_pPrevSel = pdata;
    } else {
        m_pPrevSel = NULL;
    }

    if ( ! szObject )
    {
        return FALSE;
    }

    IADsContainer * pADsContainer;

    hr = OpenDSObject(szObject, IID_IADsContainer, (void **)&pADsContainer);

    if (SUCCEEDED(hr))
    {
        IEnumVARIANT *pVar;
        hr = ADsBuildEnumerator(pADsContainer, &pVar);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            ULONG ulResult;

            while (SUCCEEDED(ADsEnumerateNext(pVar, 1, &var, &ulResult)))
            {
                if (0 == ulResult)
                {
                    break;
                }
                if (var.vt == VT_DISPATCH)
                {
                    // query for the IADs interface so we can get its properties
                    IADs * pDSObject;
                    hr = var.pdispVal->QueryInterface(IID_IADs, (LPVOID *)&pDSObject);
                    if (SUCCEEDED(hr))
                    {
                        BSTR bstr;
                        DWORD dwType = -1;
                        hr = pDSObject->get_Class(&bstr);
                        if (SUCCEEDED(hr))
                        {
                            if (0 == wcscmp(bstr, CLASSNAME_OU))
                            {
                                dwType = ITEMTYPE_OU;
                            }
                            else if (0 == wcscmp(bstr, CLASSNAME_DOMAIN))
                            {
                                dwType = ITEMTYPE_DOMAIN;
                            }
                            SysFreeString(bstr);
                        }
                        if (ITEMTYPE_DOMAIN == dwType || ITEMTYPE_OU == dwType)
                        {
                            // got something we can work with
                            MYLISTEL * pel = new MYLISTEL;
                            if (pel)
                            {
                                memset(pel, 0, sizeof(MYLISTEL));
                                hr = pDSObject->get_ADsPath(&bstr);
                                if (SUCCEEDED(hr))
                                {
                                    ulNoChars = wcslen(bstr) + 1;
                                    pel->szData = new OLECHAR[ulNoChars];
                                    if (pel->szData)
                                    {
                                        hr = StringCchCopy(pel->szData, ulNoChars, bstr);
                                        ASSERT(SUCCEEDED(hr));
                                    }
                                    pel->szName = new OLECHAR[wcslen(bstr) +  1];
                                    if (pel->szName)
                                    {
                                        // Need to convert to a friendly name.
                                        CopyAsFriendlyName(pel->szName, bstr);
                                    }
                                    SysFreeString(bstr);
                                }
                                pel->nType = dwType;
                                INT index = -1;
                                AddElement(pel, -1);
                            }
                        }
                        pDSObject->Release();
                    }
                }
                VariantClear(&var);
            }

            ADsFreeEnumerator(pVar);
        }

        pADsContainer->Release();
    }

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshDomains
//
//  Synopsis:   refreshes the listview for the "domains" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshDomains()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle &= ~LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    if (AddChildContainers())
    {
        AddGPOsLinkedToObject();
        EnableWindow (m_hList, TRUE);
        if (!(m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)) {
            SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(1, 0));
        }
    }
    else
    {
        EnableWindow (m_hList, FALSE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(0, 0));
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshSites
//
//  Synopsis:   refreshes the listview for the "sites" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshSites()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle &= ~LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    AddGPOsLinkedToObject();
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshAll
//
//  Synopsis:   refreshes the listview for the "all" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshAll()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle |= LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    if (AddGPOsForDomain())
    {
        EnableWindow (m_hList, TRUE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(1, 0));
    }
    else
    {
        EnableWindow (m_hList, FALSE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(0, 0));
    }

}

void CBrowserPP::SetButtonState()
{
    if (ListView_GetNextItem (m_hList, -1, LVNI_ALL | LVNI_SELECTED) != -1)
    {
        EnableWindow (GetDlgItem(GetParent(m_hwndDlg), IDOK), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem(GetParent(m_hwndDlg), IDOK), FALSE);
    }
}

BOOL CBrowserPP::OnInitDialog()
{
    DWORD dwDescription;
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        dwDescription = IDS_DOMAINDESCRIPTION;
        break;
    case PAGETYPE_SITES:
        dwDescription = IDS_SITEDESCRIPTION;
        break;
    case PAGETYPE_ALL:
    default:
        dwDescription = IDS_ALLDESCRIPTION;
        break;
    }
    WCHAR szDescription[MAX_PATH];  // this is a resource - size doesn't need to be dynamic
    LoadString(g_hInstance, dwDescription, szDescription, MAX_PATH);
    SetDlgItemText(m_hwndDlg, IDC_DESCRIPTION, szDescription);

    m_hList = GetDlgItem(m_hwndDlg, IDC_LIST1);
    m_ilSmall = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16), SMALLICONSIZE, 0, RGB(255,0,255));
    m_ilLarge = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32), LARGEICONSIZE, 0, RGB(255, 0 ,255));
    m_hCombo = GetDlgItem(m_hwndDlg, IDC_COMBO1);

    RECT rect;
    GetClientRect(m_hList, &rect);
    WCHAR szText[32];
    int dxScrollBar = GetSystemMetrics(SM_CXVSCROLL);
    if (PAGETYPE_ALL == m_dwPageType)
    {
        LV_COLUMN lvcol;
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        lvcol.cx = (rect.right - rect.left) - dxScrollBar;
        LoadString(g_hInstance, IDS_NAMECOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 0, &lvcol);
    }
    else
    {
        LV_COLUMN lvcol;
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        int cx = ((rect.right - rect.left) - dxScrollBar)*2/3;
        lvcol.cx = cx;
        LoadString(g_hInstance, IDS_NAMECOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 0, &lvcol);
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        lvcol.cx = ((rect.right - rect.left) - dxScrollBar) - cx;
        LoadString(g_hInstance, IDS_DOMAINCOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 1, &lvcol);
    }
    ListView_SetImageList(m_hList, m_ilSmall, LVSIL_SMALL);
    ListView_SetImageList(m_hList, m_ilLarge, LVSIL_NORMAL);
    SendMessage(m_hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_LABELTIP);

    GetWindowRect(GetDlgItem(m_hwndDlg, IDC_STATIC1), &rect);
    MapWindowPoints(NULL , m_hwndDlg, (LPPOINT) &rect , 2);

    TBBUTTON rgButtons[3];
    rgButtons[0].iBitmap = 0;
    rgButtons[0].idCommand = ID_BACKBUTTON;
    rgButtons[0].fsState = 0;       // this button will be disabled by
                                    // default and only enabled when there
                                    // is something to back up to
    //rgButtons[0].fsState = PAGETYPE_ALL == m_dwPageType ? 0 : TBSTATE_ENABLED;
    rgButtons[0].fsStyle = TBSTYLE_BUTTON;
    rgButtons[0].dwData = 0;
    rgButtons[0].iString = 0;

    rgButtons[1].iBitmap = 1;
    rgButtons[1].idCommand = ID_NEWFOLDER;
    rgButtons[1].fsStyle = TBSTYLE_BUTTON;
    rgButtons[1].dwData = 0;
    rgButtons[1].iString = 0;

    if (PAGETYPE_ALL != m_dwPageType)
    {
        if (m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)
        {
            rgButtons[1].fsState = 0;
        }
        else
        {
            rgButtons[1].fsState =  TBSTATE_ENABLED;
        }
    }
    else
    {
        rgButtons[1].fsState =TBSTATE_ENABLED;
    }

    rgButtons[2].iBitmap = 2;
    rgButtons[2].idCommand = ID_ROTATEVIEW;
    rgButtons[2].fsState = TBSTATE_ENABLED ;
    rgButtons[2].fsStyle = TBSTYLE_DROPDOWN;
    rgButtons[2].dwData = 0;
    rgButtons[2].iString = 0;
    m_toolbar = CreateToolbarEx(m_hwndDlg,
                                WS_CHILD | WS_VISIBLE | CCS_NODIVIDER | CCS_NORESIZE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
                                IDR_TOOLBAR1,
                                4,
                                g_hInstance,
                                IDR_TOOLBAR1,
                                rgButtons,
                                3,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                sizeof(TBBUTTON));
    SendMessage(m_toolbar, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);
    MoveWindow(m_toolbar, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top, FALSE);

// Don't need to call Refresh in any of these because we're calling it in
// OnComboChange().

    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        FillDomainList();
        SetInitialOU();
//        RefreshDomains();
        break;
    case PAGETYPE_SITES:
        SendMessage(m_hCombo, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);
        FillSitesList();
//        RefreshSites();
        break;
    default:
    case PAGETYPE_ALL:
        SendMessage(m_hCombo, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);
        FillDomainList();
//        RefreshAll();
        break;
    }

    SetButtonState();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CBrowserPP::DoBackButton()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoBackButton: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (pdata->pParent)
        {
            // if this item has a parent then select it
            SendMessage(m_hCombo, CB_SELECTSTRING, (WPARAM)-1,  (LPARAM) (LPCTSTR) pdata->pParent);

            // force everything to refresh
            OnComboChange();
        }
    }
    return FALSE;
}

BOOL CBrowserPP::DeleteGPO()
{
    BOOL fSucceeded = FALSE;
    BOOL fRemoveListEntry = FALSE;

    int index = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (-1 == index)
    {
        return FALSE;
    }

    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_PARAM;
    item.iItem = index;
    ListView_GetItem(m_hList, &item);
    MYLISTEL * pel = (MYLISTEL *)item.lParam;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;
    WCHAR szBuffer[100];
    WCHAR szConfirm[MAX_FRIENDLYNAME + 100];
    WCHAR szTitle[100];


    if (pel->nType != ITEMTYPE_GPO)
    {
        goto CleanUp;
    }


    LoadString(g_hInstance, IDS_CONFIRMTITLE, szTitle, 100);
    LoadString(g_hInstance, IDS_DELETECONFIRM, szBuffer, 100);
    
    (void) StringCchPrintf (szConfirm, ARRAYSIZE(szConfirm), szBuffer, pel->szName);

    if (IDNO == MessageBox(m_hwndDlg, szConfirm, szTitle, MB_YESNO | MB_ICONEXCLAMATION))
    {
        goto CleanUp;
    }


    // If we're on any page other than the "All" page then we need to break
    // the association before we can delete the object.
    if (m_dwPageType != PAGETYPE_ALL)
    {
        // break the association
        LPOLESTR szContainer = GetCurrentObject();
        if (szContainer)
        {
            DeleteLink(pel->szData, szContainer);
            delete [] szContainer;
        }
    }

    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }


    // open GPO object without opening registry data
    hr = pGPO->OpenDSGPO(pel->szData, 0);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
        DebugMsg((DM_WARNING, TEXT("OpenDSGPO failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // delete it
    hr = pGPO->Delete();
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDELETE);
        DebugMsg((DM_WARNING, TEXT("Delete failed with 0x%x\r\n"), hr));
        goto Done;
    }
    fRemoveListEntry = TRUE;

Done:
    if (pGPO)
    {
        pGPO->Release();
    }


    // remove the list entry
    if (fRemoveListEntry)
        fSucceeded = ListView_DeleteItem(m_hList, index);
CleanUp:

    return fSucceeded;
}

BOOL CBrowserPP::DoNewGPO()
{
    BOOL fSucceeded = FALSE;
    HRESULT hr;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    BOOL fEdit = FALSE;
    MYLISTEL * pel = NULL;
    LPOLESTR szObject = GetCurrentObject();
    LPOLESTR szDomain = GetCurrentDomain();
    INT index = -1;
    int cch = 0;
    LPTSTR szFullPath = NULL;
    LPTSTR szServerName = NULL;
    DWORD dwOptions = 0;


    if (NULL == szDomain)
    {
        goto Done;
    }

    if (NULL == szObject)
    {
        goto Done;
    }


    pel = new MYLISTEL;
    if (NULL == pel)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO name")));
        goto Done;
    }
    pel->bDisabled = FALSE;
    pel->szData = NULL;
    pel->szName = new OLECHAR[MAX_FRIENDLYNAME];
    if (NULL == pel->szName)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO name")));
        goto Done;
    }

    GetNewGPODisplayName (pel->szName, MAX_FRIENDLYNAME);

    pel->nType = ITEMTYPE_GPO;

    // Create a new GPO named "New Group Policy Object"

    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }

    //
    // Open the requested object without mounting the registry
    //
#if FGPO_SUPPORT
    if (IsCurrentObjectAForest())
    {
        dwOptions = GPO_OPEN_FOREST;
    }
#endif
    hr = pGPO->New(szDomain, pel->szName, dwOptions);

    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDNEW);
        DebugMsg((DM_WARNING, TEXT("Failed to create GPO object with 0x%x\r\n"), hr));
        goto Done;
    }

    // continue to try to allocate memory until either a big enough buffer is
    // created to load the GPO path or we run out of memory
    pel->szData = NULL;
    do
    {
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        cch += MAX_PATH;
        pel->szData = new OLECHAR[cch];
        if (NULL == pel->szData)
        {
        }
        hr = pGPO->GetPath(pel->szData, cch);
    } while (hr == E_OUTOFMEMORY);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("Failed to get GPO object path with 0x%x\r\n"), hr));
        goto Done;

    }

    szServerName = ExtractServerName(szDomain);
    szFullPath = MakeFullPath(pel->szData, szServerName);
    if (szFullPath)
    {
        ULONG ulNoChars = wcslen(szFullPath) + 1;

        delete [] pel->szData;
        pel->szData = new OLECHAR[ulNoChars];
        if (NULL == pel->szData)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO path")));
            goto Done;
        }

        hr = StringCchCopy(pel->szData, ulNoChars, szFullPath);
        ASSERT(SUCCEEDED(hr));
    }


    if (m_dwPageType != PAGETYPE_ALL)
    {
        // If we're not on the "All" page then we need to create a link.
        CreateLink(pel->szData, szObject);
    }

    // Add the entry to the list view

    index = AddElement(pel, -1);
    fSucceeded = index != -1;

    // It's been added so now we need to make sure we don't delete it below
    pel = NULL;

    // Record that we got this far
    fEdit = TRUE;

Done:
    if (pel)
    {
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        if (pel->szName)
        {
            delete [] pel->szName;
        }
        delete pel;
    }
    if (pGPO)
        pGPO->Release();

    if (fEdit)
    {
        // Now trigger an edit of the entry
        SetFocus(m_hList);
        ListView_EditLabel(m_hList, index);

    }

    if (szServerName)
        LocalFree(szServerName);
    if (szFullPath)
        LocalFree(szFullPath);
    if (szDomain)
        delete [] szDomain;
    if (szObject)
        delete [] szObject;

    return fSucceeded;
}

BOOL CBrowserPP::CreateLink(LPOLESTR szObject, LPOLESTR szContainer)
{
    HRESULT hr = CreateGPOLink(szObject, szContainer, FALSE);
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    ReportError(m_hwndDlg, hr, IDS_FAILEDLINK);
    return FALSE;
}

BOOL CBrowserPP::DeleteLink(LPOLESTR szObject, LPOLESTR szContainer)
{
    HRESULT hr = DeleteGPOLink(szObject, szContainer);
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    ReportError(m_hwndDlg, hr, IDS_FAILEDUNLINK);
    return FALSE;
}

BOOL CBrowserPP::DoRotateView()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    DWORD dw =  dwStyle & LVS_TYPEMASK;
    switch (dw)
    {
    case LVS_ICON:
        dw = LVS_SMALLICON;
        break;
    case LVS_SMALLICON:
        dw = LVS_LIST;
        break;
    case LVS_REPORT:
        dw = LVS_ICON;
        break;
    case LVS_LIST:
        default:
        dw = LVS_REPORT;
        break;
    }
    dwStyle -= dwStyle & LVS_TYPEMASK;
    dwStyle += dw;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle);
    return TRUE;
}

void CBrowserPP::OnDetails()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_REPORT);
}

void CBrowserPP::OnList()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_LIST);
}

void CBrowserPP::OnLargeicons()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_ICON);

}

void CBrowserPP::OnSmallicons()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_SMALLICON);
}

void CBrowserPP::OnContextMenu(LPARAM lParam)
{
    int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    RECT rc;
    POINT pt;
    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (GetDlgItem (m_hwndDlg, IDC_LIST1), &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (m_hList, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (m_hList, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    // get the popup menu
    HMENU hPopup;
    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_LISTMENU));
    HMENU hSubMenu = GetSubMenu(hPopup, 0);

    if (i >= 0)
    {
        // item selected

        // figure out what type it is
        LVITEM item;
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(m_hList, &item);
        MYLISTEL * pel = (MYLISTEL *)item.lParam;

        // get rid of the view menu and separator
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        // get rid of the arrange and line-up items
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);

        // get rid of the "new" menu item
        RemoveMenu(hSubMenu, ID_NEW, MF_BYCOMMAND);
        switch (pel->nType)
        {
        case ITEMTYPE_GPO:
            if (pel->bDisabled)
            {
                // disable edit, rename, delete
                EnableMenuItem(hSubMenu, ID_EDIT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                EnableMenuItem(hSubMenu, ID_RENAME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                EnableMenuItem(hSubMenu, ID_DELETE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            }
            break;
        default:
        case ITEMTYPE_FOREST:
        case ITEMTYPE_SITE:
        case ITEMTYPE_DOMAIN:
        case ITEMTYPE_OU:
            // remove the edit menu item and the separator
            RemoveMenu(hSubMenu, ID_EDIT, MF_BYCOMMAND);
            RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
            // disable rename, delete and properties
            EnableMenuItem(hSubMenu, ID_RENAME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            EnableMenuItem(hSubMenu, ID_DELETE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            EnableMenuItem(hSubMenu, ID_PROPERTIES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            break;
        }
    }
    else
    {
        // no item selected

        // get rid of the edit menu item
        RemoveMenu(hSubMenu, ID_EDIT, MF_BYCOMMAND);

        // get rid of the delete and rename items
        RemoveMenu(hSubMenu, ID_DELETE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, ID_RENAME, MF_BYCOMMAND);


        if (PAGETYPE_ALL != m_dwPageType)
        {
            if (m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)
            {
                // get rid of the "new" menu item
                RemoveMenu(hSubMenu, ID_NEW, MF_BYCOMMAND);
                RemoveMenu(hSubMenu, 4, MF_BYPOSITION);
            }
        }

        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);


        // set view radio button
        UINT ui = ID_LIST;

        DWORD dw = GetWindowLong(m_hList, GWL_STYLE) & LVS_TYPEMASK;

        if (dw == LVS_ICON || dw == LVS_SMALLICON)
        {
            // Auto-Arrange means something in these views so we need to enable it
            EnableMenuItem(hSubMenu, ID_ARRANGE_AUTO, MF_BYCOMMAND | MF_ENABLED);
            // also need to make sure it's set correctly
            if (LVS_AUTOARRANGE == (GetWindowLong(m_hList, GWL_STYLE) & LVS_AUTOARRANGE))
                CheckMenuItem(hSubMenu, ID_ARRANGE_AUTO, MF_BYCOMMAND | MF_CHECKED);
        }
        switch (dw)
        {
        case LVS_ICON:
            ui = ID_LARGEICONS;
            break;
        case LVS_SMALLICON:
            ui = ID_SMALLICONS;
            break;
        case LVS_REPORT:
            ui = ID_DETAILS;
            break;
        case LVS_LIST:
            default:
            ui = ID_LIST;
            break;
        }
        CheckMenuRadioItem(hSubMenu, ui, ui, ui, MF_BYCOMMAND);

    }
    TrackPopupMenu(hSubMenu,
                   TPM_LEFTALIGN,
                   pt.x, pt.y,
                   0,
                   m_hwndDlg,
                   NULL);
    DestroyMenu(hPopup);
}


void CBrowserPP::OnArrangeAuto()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    if (LVS_AUTOARRANGE == (dwStyle & LVS_AUTOARRANGE))
        SetWindowLong(m_hList, GWL_STYLE, dwStyle - LVS_AUTOARRANGE);
    else
        SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_AUTOARRANGE);
}

int CALLBACK CompareName(LPARAM lParam1, LPARAM lParam2, LPARAM lParamsort)
{
    MYLISTEL * pel1 = (MYLISTEL *)lParam1;
    MYLISTEL * pel2 = (MYLISTEL *)lParam2;
    return _wcsicmp(pel1->szName, pel2->szName);
}

int CALLBACK CompareType(LPARAM lParam1, LPARAM lParam2, LPARAM lParamsort)
{
    MYLISTEL * pel1 = (MYLISTEL *)lParam1;
    MYLISTEL * pel2 = (MYLISTEL *)lParam2;
    return pel1->nType - pel2->nType;
}

void CBrowserPP::OnArrangeByname()
{
    ListView_SortItems(m_hList, CompareName, 0);
}

void CBrowserPP::OnArrangeBytype()
{
    ListView_SortItems(m_hList, CompareType, 0);
}

void CBrowserPP::OnDelete()
{
    DeleteGPO();
}

void CBrowserPP::OnEdit()
{
    INT i;
    HRESULT hr;
    LVITEM item;
    MYLISTEL * pel;
    LPTSTR lpDomainName;
    LPOLESTR pszDomain;



    i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);

    if (i >= 0)
    {
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;

        ListView_GetItem(m_hList, &item);

        pel = (MYLISTEL *)item.lParam;

        if (pel->nType == ITEMTYPE_GPO)
        {
            //
            // Get the friendly domain name
            //

            pszDomain = GetDomainFromLDAPPath(pel->szData);

            if (!pszDomain)
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnEdit: Failed to get domain name")));
                return;
            }


            //
            // Convert LDAP to dot (DN) style
            //

            hr = ConvertToDotStyle (pszDomain, &lpDomainName);

            delete [] pszDomain;

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
                return;
            }


            //
            // Check if the GPO is in the same domain as GPM is focused on
            //

            if (!lstrcmpi(lpDomainName, m_szDomainName))
            {
                SpawnGPE (pel->szData, GPHintUnknown, m_szServerName, m_hwndDlg);
            }
            else
            {
                SpawnGPE (pel->szData, GPHintUnknown, NULL, m_hwndDlg);
            }


            LocalFree (lpDomainName);
        }
    }
}

void CBrowserPP::OnNew()
{
    DoNewGPO();
}

void CBrowserPP::OnProperties()
{
    INT iIndex;
    LVITEM item;
    HRESULT hr;
    LPGROUPPOLICYOBJECT pGPO;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    PROPSHEETHEADER psh;

    iIndex = ListView_GetNextItem(m_hList, -1, LVNI_ALL | LVNI_SELECTED);
    if (iIndex >= 0)
    {
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        ListView_GetItem(m_hList, &item);

        MYLISTEL * pel = (MYLISTEL *)item.lParam;
        if (pel && pel->nType == ITEMTYPE_GPO)
        {
            hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                   CLSCTX_SERVER, IID_IGroupPolicyObject,
                                   (void**)&pGPO);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: CoCreateInstance failed with 0x%x\r\n"), hr));
                return;
            }


            //
            // Open the requested object without mounting the registry
            //

            hr = pGPO->OpenDSGPO(pel->szData, 0);

            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                hr = pGPO->OpenDSGPO(pel->szData, GPO_OPEN_READ_ONLY);
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: Failed to open GPO object with 0x%x\r\n"), hr));
                ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
                return;
            }


            //
            // Ask the GPO for the property sheet pages
            //

            hr = pGPO->GetPropertySheetPages (&hPages, &uPageCount);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: Failed to query property sheet pages with 0x%x."), hr));
                pGPO->Release();
                return;
            }

            //
            // Display the property sheet
            //

            ZeroMemory (&psh, sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_PROPTITLE;
            psh.hwndParent = m_hwndDlg;
            psh.hInstance = g_hInstance;
            psh.pszCaption = pel->szName;
            psh.nPages = uPageCount;
            psh.phpage = hPages;

            PropertySheet (&psh);

            LocalFree (hPages);
            pGPO->Release();
        }
    }
}

void CBrowserPP::OnRefresh()
{
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        RefreshDomains();
        break;
    case PAGETYPE_SITES:
        RefreshSites();
        break;
    default:
    case PAGETYPE_ALL:
        RefreshAll();
        break;
    }

    SetButtonState();
}

void CBrowserPP::OnRename()
{
    //
    // alow the rename only if it is possible to rename
    //

    int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (i >= 0)
    {
        // item selected

        // figure out what type it is
        LVITEM item;
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(m_hList, &item);
        MYLISTEL * pel = (MYLISTEL *)item.lParam;

        if ((pel) && (pel->nType == ITEMTYPE_GPO) 
            && (!(pel->bDisabled))) {
            ListView_EditLabel(m_hList, ListView_GetNextItem(m_hList, -1, LVNI_SELECTED));
        }
    }
}

void CBrowserPP::OnTopLineupicons()
{
    ListView_Arrange(m_hList, LVA_SNAPTOGRID);
}

void CBrowserPP::OnBeginlabeleditList(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
    // Return FALSE to enable editing, TRUE to disable it
    MYLISTEL * pel = (MYLISTEL *)pDispInfo->item.lParam;
    *pResult = (pel->nType == ITEMTYPE_GPO) ? FALSE : TRUE;
}

void CBrowserPP::OnEndlabeleditList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = FALSE;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;

    if (NULL == pDispInfo->item.pszText)
    {
        // user cancelled edit
        return;
    }

    if (TEXT('\0') == (*pDispInfo->item.pszText))
    {
        // user entered an empty string
        return;
    }


    MYLISTEL * pel = (MYLISTEL *)pDispInfo->item.lParam;
    if (0 ==wcscmp(pDispInfo->item.pszText, pel->szName))
    {
        // user didn't change anything
        return;
    }

    LPWSTR sz = new WCHAR[wcslen(pDispInfo->item.pszText)+1];

    if (NULL == sz)
    {
        *pResult = FALSE;
        goto Done;
        return;
    }

    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }


    // open GPO object without opening registry data
    hr = pGPO->OpenDSGPO(pel->szData, 0);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
        DebugMsg((DM_WARNING, TEXT("OpenDSGPO failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // rename it
    hr = pGPO->SetDisplayName(pDispInfo->item.pszText);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDSETNAME);
        DebugMsg((DM_WARNING, TEXT("SetDisplayName failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // requery for the name
    hr = pGPO->GetDisplayName(sz, (wcslen(pDispInfo->item.pszText)+1));
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDSETNAME);
        DebugMsg((DM_WARNING, TEXT("GetDisplayName failed with 0x%x\r\n"), hr));
        goto Done;
    }

    delete [] pel->szName;
    pel->szName = sz;
    sz = NULL;

    // return TRUE to accept the rename, FALSE to reject it

    *pResult = TRUE;
    PostMessage (m_hwndDlg, WM_REFRESHDISPLAY, (WPARAM) pDispInfo->item.iItem, 0);

Done:
    if (sz)
    {
        delete [] sz;
    }

    if (pGPO)
    {
        pGPO->Release();
    }
}

void CBrowserPP::OnBegindragList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    *pResult = 0;
}

void CBrowserPP::OnDeleteitemList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    MYLISTEL * pel = (MYLISTEL *)pNMListView->lParam;
    if (pel)
    {
        if (pel->szName)
        {
            delete [] pel->szName;
        }
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        delete pel;
    }
    *pResult = 0;
}

void CBrowserPP::OnDoubleclickList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if (pNMListView->iItem >= 0)
    {
        // item selected
        PropSheet_PressButton(GetParent(m_hwndDlg), PSBTN_OK);
    }
    *pResult = 0;
}

void CBrowserPP::OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch (pNMListView->iSubItem)
    {
    case 0:
        ListView_SortItems(m_hList, CompareName, 0);
        break;
    case 1:
        default:
        ListView_SortItems(m_hList, CompareType, 0);
        break;
    }
    *pResult = 0;
}

void CBrowserPP::OnKeyDownList(NMHDR * pNMHDR, LRESULT * pResult)
{
    LV_KEYDOWN * pnkd = (LV_KEYDOWN *)pNMHDR;

    switch (pnkd->wVKey)
    {
        case VK_F5:
            OnRefresh();
            break;
        case VK_F2:
            OnRename();
            break;
        case VK_DELETE:
            OnDelete();
            break;

        case VK_BACK:
            DoBackButton();
            break;

        case VK_RETURN:
            OnProperties();
            break;

        default:
            break;
    }
}

void CBrowserPP::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    SetButtonState();
}

void CBrowserPP::TrimComboBox()
{
    LOOKDATA * pdataSelected = NULL;
    int iCount;

    // first check to see if something is selected
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
    if (iIndex != CB_ERR)
    {
        // something's selected, get a pointer to it's data
        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);

        // check if the user selected the same thing again
        if (m_pPrevSel && (m_pPrevSel == pdataSelected))
        {
            return;
        }

        // if it has a parent then enable the back button
        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM)MAKELONG(NULL != pdataSelected->pParent, 0));
    }

    // If the child of the selected object is an OU then delete all of it's children
    // otherwise delete ALL OUs from the list.

    if (pdataSelected)
    {
        if (pdataSelected->pChild)
        {
            if (ITEMTYPE_OU == pdataSelected->pChild->nType)
            {
                // delete all of its children
                goto DeleteChildren;
            }
        }
    }

    iCount = (int)SendMessage(m_hCombo, CB_GETCOUNT, 0, 0);
    iIndex = 0;
    while (iIndex < iCount)
    {
        // find the first entry that has an OU for a child.
        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);

        if (pdataSelected)
        {
            if (pdataSelected->pChild)
            {
                if (ITEMTYPE_OU == pdataSelected->pChild->nType)
                {
                    DeleteChildren:
                        LOOKDATA * pChild = pdataSelected->pChild;
                        pdataSelected->pChild = pChild->pSibling;
                        while (pChild)
                        {
                            iIndex = (int)SendMessage(m_hCombo, CB_FINDSTRING, iIndex, (LPARAM)(LPCTSTR*)pChild);
                            if (iIndex  != CB_ERR)
                            {
                                pChild = pChild->pChild;
                                SendMessage(m_hCombo, CB_DELETESTRING, iIndex, 0);
                            }
                            else
                            {
                                pChild = NULL;
                            }
                        }
                        return;
                }
            }
        }
        iIndex++;
    }
}

void CBrowserPP::OnComboChange()
{
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        {
            TrimComboBox();
        }
        // fall through to refresh the list view
    case PAGETYPE_SITES:
    case PAGETYPE_ALL:
    default:
        OnRefresh();
        break;
    }
}

BOOL CBrowserPP::OnSetActive()
{
    *m_ppActive = this;
    OnRefresh();
    return TRUE;
}

BOOL CBrowserPP::OnApply()
{
    if (*m_ppActive == (void *) this)
    {
        // perform the proper task on the selected item
        int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
        if (i >= 0)
        {
            LVITEM item;
            memset(&item, 0, sizeof(item));
            item.mask = LVIF_PARAM;
            item.iItem = i;
            ListView_GetItem(m_hList, &item);
            MYLISTEL * pel = (MYLISTEL *)item.lParam;
            switch (pel->nType)
            {
            case ITEMTYPE_GPO:
                m_pGBI->gpoType = GPOTypeDS;
                wcsncpy(m_pGBI->lpDSPath, pel->szData, m_pGBI->dwDSPathSize);
                if (m_pGBI->lpName)
                {
                    wcsncpy(m_pGBI->lpName, pel->szName, m_pGBI->dwNameSize);
                }
                m_pGBI->gpoHint = GPHintUnknown;
                break;
            default:
            case ITEMTYPE_FOREST:
            case ITEMTYPE_SITE:
            case ITEMTYPE_DOMAIN:
                // change the focus
                {
                    LOOKDATA * pdataSelected = NULL;


                    // first make sure something is selected
                    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
                    if (iIndex != CB_ERR)
                    {
                        // something's selected, get a pointer to it's data
                        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
                        if (pdataSelected)
                        {
                            // Now walk its children until we find a match
                            pdataSelected = pdataSelected->pChild;
                            while (pdataSelected)
                            {
                                if (0 == wcscmp(pdataSelected->szData, pel->szData))
                                {
                                    iIndex = (int)SendMessage(m_hCombo, CB_FINDSTRING, iIndex, (LPARAM) (LPCTSTR)pdataSelected);
                                    if (iIndex != CB_ERR)
                                    {
                                        SendMessage(m_hCombo, CB_SETCURSEL, iIndex, 0);
                                        // Enable the back-button
                                        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                                    }
                                    break;
                                }
                                pdataSelected = pdataSelected->pSibling;
                            }
                        }
                    }
                }
                OnRefresh();
                return FALSE; // don't allow propsheet to close
            case ITEMTYPE_OU:
                // Add the new object to combobox and change the focus.
                {
                    LOOKDATA * pdataSelected = NULL;


                    // first make sure something is selected
                    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
                    if (iIndex != CB_ERR)
                    {
                        // something's selected, get a pointer to it's data
                        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
                        if (pdataSelected)
                        {
                            LOOKDATA * pNew = new LOOKDATA;
                            if (pNew)
                            {
                                ULONG ulNoCharsName = wcslen(pel->szName)+1;
                                pNew->szName = new WCHAR[ulNoCharsName];
                                if (pNew->szName)
                                {
                                    ULONG ulNoCharsData = wcslen(pel->szData)+1;
                                    pNew->szData = new WCHAR[ulNoCharsData];
                                    if (pNew->szData)
                                    {
                                        HRESULT hr;

                                        hr = StringCchCopy(pNew->szName, ulNoCharsName, pel->szName);
                                        ASSERT(SUCCEEDED(hr));

                                        hr = StringCchCopy(pNew->szData, ulNoCharsData, pel->szData);
                                        ASSERT(SUCCEEDED(hr));

                                        pNew->nIndent = pdataSelected->nIndent + 1;
                                        pNew->nType = ITEMTYPE_OU;
                                        pNew->pParent = pdataSelected;
                                        pNew->pSibling = pdataSelected->pChild;
                                        pNew->pChild = NULL;
                                        pdataSelected ->pChild = pNew;
                                        SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) iIndex + 1, (LPARAM) (LPCTSTR) pNew);
                                        SendMessage(m_hCombo, CB_SETCURSEL, iIndex + 1, 0);
                                        // Enable the back-button
                                        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                                    }
                                    else
                                    {
                                        delete [] pNew->szName;
                                        delete pNew;
                                    }
                                }
                                else
                                {
                                    delete pNew;
                                }
                            }
                        }
                    }
                }
                OnRefresh();
                return FALSE;   // don't allow propsheet to close
            }
            return TRUE;
        }
        else
            return FALSE;       // don't allow propsheet to close
    }
    return TRUE;
}

BOOL CBrowserPP::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturn = FALSE;
    m_hwndDlg = hwndDlg;

    switch (uMsg)
    {
     case WM_INITDIALOG:
        {
            return OnInitDialog();
        }
        break;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            LRESULT lResult = 0;

            switch (pnmh->code)
            {
            case NM_KEYDOWN:
                {
                    LPNMKEY pnkd = (LPNMKEY)pnmh;

                    if (VK_F5 == pnkd->nVKey)
                    {
                        OnRefresh();
                    }
                }
                break;
            case PSN_SETACTIVE:
                OnSetActive();
                break;
            case PSN_APPLY:
                lResult = OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
                fReturn = TRUE;
                break;
            case NM_DBLCLK:
                if (IDC_LIST1 == wParam)
                {
                    OnDoubleclickList(pnmh, &lResult);
                    fReturn = TRUE;
                }
                break;
            case LVN_BEGINLABELEDIT:
                OnBeginlabeleditList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_ENDLABELEDIT:
                OnEndlabeleditList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_BEGINDRAG:
                OnBegindragList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_DELETEITEM:
                OnDeleteitemList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_COLUMNCLICK:
                OnColumnclickList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_KEYDOWN:
                OnKeyDownList(pnmh, &lResult);
                break;
            case LVN_ITEMCHANGED:
                OnItemChanged(pnmh, &lResult);
                break;
            case TBN_DROPDOWN:
                {
                    RECT r;
                    SendMessage(m_toolbar, TB_GETRECT, ((TBNOTIFY *)lParam)->iItem, (LPARAM)&r);
                    MapWindowPoints(m_toolbar, NULL, (POINT *)&r, 2);
                    HMENU hPopup;
                    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_LISTMENU));
                    
                    if ( ! hPopup )
                    {
                        break;
                    }

                    UINT ui = ID_LIST;

                    DWORD dw = GetWindowLong(m_hList, GWL_STYLE) & LVS_TYPEMASK;
                    switch (dw)
                    {
                    case LVS_ICON:
                        ui = ID_LARGEICONS;
                        break;
                    case LVS_SMALLICON:
                        ui = ID_SMALLICONS;
                        break;
                    case LVS_REPORT:
                        ui = ID_DETAILS;
                        break;
                    case LVS_LIST:
                        default:
                        ui = ID_LIST;
                        break;
                    }
                    HMENU hSubMenu = GetSubMenu(GetSubMenu(hPopup, 0), 0);
                    CheckMenuRadioItem(hSubMenu, ui, ui, ui, MF_BYCOMMAND);
                    TrackPopupMenu(hSubMenu,
                                   TPM_LEFTALIGN,
                                   r.left, r.bottom,
                                   0,
                                   m_hwndDlg,
                                   &r);
                    fReturn = TRUE;
                    DestroyMenu(hPopup);
                    break;
                }
                break;
            case TTN_GETDISPINFO:
                {
                LPNMTTDISPINFO pDI = (LPNMTTDISPINFO) lParam;
                UINT id = 0;

                if (pDI->hdr.idFrom == ID_BACKBUTTON)
                    id = IDS_TOOLTIP_BACK;
                else if (pDI->hdr.idFrom == ID_NEWFOLDER)
                    id = IDS_TOOLTIP_NEW;
                else if (pDI->hdr.idFrom == ID_ROTATEVIEW)
                    id = IDS_TOOLTIP_ROTATE;

                if (id)
                    LoadString (g_hInstance, id, pDI->szText, 80);
                else
                    pDI->szText[0] = TEXT('\0');

                fReturn = TRUE;
                }
                break;
            default:
                break;
            }
            SetWindowLongPtr(m_hwndDlg, DWLP_MSGRESULT, lResult);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_COMBO1:
            if (CBN_SELCHANGE == HIWORD(wParam))
            {
                OnComboChange();
            }
            break;
        case ID_BACKBUTTON:
            return DoBackButton();
        case ID_NEWFOLDER:
            return DoNewGPO();
        case ID_ROTATEVIEW:
            return DoRotateView();
        case ID_DETAILS:
            OnDetails();
            fReturn = TRUE;
            break;
        case ID_LIST:
            OnList();
            fReturn = TRUE;
            break;
        case ID_LARGEICONS:
            OnLargeicons();
            fReturn = TRUE;
            break;
        case ID_SMALLICONS:
            OnSmallicons();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_AUTO:
            OnArrangeAuto();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_BYNAME:
            OnArrangeByname();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_BYTYPE:
            OnArrangeBytype();
            fReturn = TRUE;
            break;
        case ID_DELETE:
            OnDelete();
            fReturn = TRUE;
            break;
        case ID_EDIT:
            OnEdit();
            fReturn = TRUE;
            break;
        case ID_NEW:
            OnNew();
            fReturn = TRUE;
            break;
        case ID_PROPERTIES:
            OnProperties();
            fReturn = TRUE;
            break;
        case ID_REFRESH:
            OnRefresh();
            fReturn = TRUE;
            break;
        case ID_RENAME:
            OnRename();
            fReturn = TRUE;
            break;
        case ID_TOP_LINEUPICONS:
            OnTopLineupicons();
            fReturn = TRUE;
            break;
        default:
            break;
        }
        break;

    case WM_CONTEXTMENU:
        fReturn = TRUE;
        if ((HWND)wParam != m_toolbar)
        {
            if (GetDlgItem(hwndDlg, IDC_LIST1) == (HWND)wParam)
            {
                OnContextMenu(lParam);
            }
            else
            {
                // right mouse click
                switch (m_dwPageType)
                {
                    case PAGETYPE_DOMAINS:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserDomainHelpIds);
                        break;

                    case PAGETYPE_SITES:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserSiteHelpIds);
                        break;

                    case PAGETYPE_ALL:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserAllHelpIds);
                        break;
                }
            }
        }
        break;

    case WM_HELP:
        // F1 help
        if (((LPHELPINFO) lParam)->iCtrlId != IDR_TOOLBAR1)
        {
            switch (m_dwPageType)
            {
                case PAGETYPE_DOMAINS:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserDomainHelpIds);
                    break;

                case PAGETYPE_SITES:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserSiteHelpIds);
                    break;

                case PAGETYPE_ALL:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserAllHelpIds);
                    break;
            }
        }

        fReturn = TRUE;
        break;

    case WM_DRAWITEM:
        if (IDC_COMBO1 == wParam)
        {
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;
    case WM_MEASUREITEM:
        if (IDC_COMBO1 == wParam)
        {
            MeasureItem((LPMEASUREITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;
    case WM_COMPAREITEM:
        if (IDC_COMBO1 == wParam)
        {
            int iReturn = CompareItem((LPCOMPAREITEMSTRUCT)lParam);
            SetWindowLongPtr(m_hwndDlg, DWLP_MSGRESULT, iReturn);
            fReturn = TRUE;
        }
        break;
    case WM_DELETEITEM:
        if (IDC_COMBO1 == wParam)
        {
            DeleteItem((LPDELETEITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;

    case WM_REFRESHDISPLAY:
        {
        MYLISTEL * pel;
        LVITEM item;


        ZeroMemory (&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = (INT) wParam;

        if (ListView_GetItem(m_hList, &item))
        {
            pel = (MYLISTEL *)item.lParam;
            ListView_SetItemText(m_hList, (INT)wParam, 0, pel->szName);
        }

        }
        break;
    default:
        break;
    }
    return fReturn;
}

void CBrowserPP::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
    // DRAWITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      UINT itemID;    // index of the item
    //  UINT itemAction;
    //  UINT itemState;
    //  HWND hwndItem;
    //      HDC hDC;
    //  RECT rcItem;
    //  DWORD itemData;     // user-defined data

    if (-1 != lpDrawItemStruct->itemID)
    {
        LOOKDATA * pdata = (LOOKDATA *)lpDrawItemStruct->itemData;
        POINT pt;
        INT iIndex;

        if (pdata->nType == ITEMTYPE_FOREST)
        {
            iIndex = 10;
        }
        else if (pdata->nType == ITEMTYPE_SITE)
        {
            iIndex = 6;
        }
        else if (pdata->nType == ITEMTYPE_DOMAIN)
        {
            iIndex = 7;
        }
        else
        {
            iIndex = 0;
        }

        pt.x = lpDrawItemStruct->rcItem.left;
        BOOL fSelected = ODS_SELECTED == (ODS_SELECTED & lpDrawItemStruct->itemState);
        BOOL fComboBoxEdit = ODS_COMBOBOXEDIT != (ODS_COMBOBOXEDIT & lpDrawItemStruct->itemState);
        if (fComboBoxEdit)
            pt.x += (INDENT * pdata->nIndent);
        pt.y = lpDrawItemStruct->rcItem.top;
        ImageList_Draw(m_ilSmall, iIndex, lpDrawItemStruct->hDC, pt.x, pt.y, fSelected ? ILD_SELECTED : ILD_NORMAL);
        SIZE size;
        GetTextExtentPoint32(lpDrawItemStruct->hDC, pdata->szName, wcslen(pdata->szName), &size);
        COLORREF crBk;
        COLORREF crText;
        if (fSelected)
        {
            crBk = GetBkColor(lpDrawItemStruct->hDC);
            crText = GetTextColor(lpDrawItemStruct->hDC);
            SetBkColor(lpDrawItemStruct->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpDrawItemStruct->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        // NOTE, SMALLICONSIZE + 1 is used here to ensure it rounds UP
        // instead of down when centering the text.  (It looks better this
        // way.)
        // Adding 18 to the x coord spaces us past the icon.
        ExtTextOut(lpDrawItemStruct->hDC, pt.x + (SMALLICONSIZE + 2), pt.y + (((SMALLICONSIZE + 1) - size.cy) / 2), ETO_CLIPPED, &lpDrawItemStruct->rcItem, pdata->szName, wcslen(pdata->szName), NULL);
        if (fSelected)
        {
            SetBkColor(lpDrawItemStruct->hDC, crBk);
            SetTextColor(lpDrawItemStruct->hDC, crText);
        }
    }
}

void CBrowserPP::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
    // MEASUREITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      UINT itemID;    // index of the item
    //      UINT itemWidth; // width of item in pixels
    //      UINT itemHeight;        // height of item in pixels
    //  DWORD itemData;     // user-defined data

    lpMeasureItemStruct->itemHeight = SMALLICONSIZE;
}

int CBrowserPP::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct)
{
    // COMPAREITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      HWND hwndItem;  // handle of the control
    //      UINT itemID;    // index of the item
    //  DWORD itemData1;    // user-defined data
    //  UINT itemID2;       // index of the second item
    //      DWORD itemData2;        // user-defined data

    // I'm not doing any sorting.

    return 0;
}

void CBrowserPP::DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct)
{
    LOOKDATA * pdata = (LOOKDATA *)lpDeleteItemStruct->itemData;
    if (NULL != pdata)
    {
        if (NULL != pdata->szName)
        {
            delete [] pdata->szName;
        }
        if (NULL != pdata->szData)
        {
            delete [] pdata->szData;
        }
        delete pdata;
    }
}

LPTSTR CBrowserPP::GetFullPath (LPTSTR lpPath, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPDCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpPath);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }


    if (!lstrcmpi(lpDomainName, m_szDomainName))
    {

        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpPath, m_szServerName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to build new DS object path")));
            goto Exit;
        }

    }
    else
    {

        //
        // Get the GPO DC for this domain
        //

        lpGPDCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

        if (!lpGPDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to get DC name for %s"),
                     lpDomainName));
            goto Exit;
        }


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpPath, lpGPDCName);

        LocalFree (lpGPDCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to build new DS object path")));
            goto Exit;
        }
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\compspp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CompsPP.cpp
//
//  Contents:   Implementation for the "computers" property page of the GPO
//              browser.
//
//  Classes:    CCompsPP
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------


#include "main.h"
#include "CompsPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help ids
//

DWORD aBrowserComputerHelpIds[] =
{
    IDC_RADIO1,                   IDH_BROWSER_LOCALCOMPUTER,
    IDC_RADIO2,                   IDH_BROWSER_REMOTECOMPUTER,
    IDC_EDIT1,                    IDH_BROWSER_REMOTECOMPUTER,
    IDC_BUTTON1,                  IDH_BROWSER_BROWSE,

    0, 0
};


CCompsPP::CCompsPP()
{
    m_szComputer = _T("");
    m_iSelection = 0;
    m_ppActive = NULL;
    m_pGBI;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCompsPP::Initialize
//
//  Synopsis:   Initializes the property page.
//
//  Arguments:  [dwPageType] - used to identify which page this is.  (See
//                              notes.)
//              [pGBI]       - pointer to the browse info structure passed
//                              by caller
//              [ppActive]   - pointer to a common variable that remembers
//                              which object was last given the focus.
//                              Needed because only the page with the focus
//                              is allowed to return data to the caller when
//                              the property sheet is dismissed.
//
//  Returns:    Handle to the newly created property page.
//
//  Modifies:
//
//  Derivation:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This class implements the PAGETYPE_COMPUTERS page.  The
//              other pages are all implemented by CBrowserPP:
//
//                  PAGETYPE_DOMAINS    - GPO's linked to domains
//                  PAGETYPE_SITES      - GPO's linked to sites
//                  PAGETYPE_ALL        - All GPO's in a selected
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CCompsPP::Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive)
{
    m_ppActive = ppActive;
    m_dwPageType = dwPageType;
    m_pGBI = pGBI;
    PROPSHEETPAGE psp;
    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_COMPUTERS);
    return CreatePropertySheetPage(&psp);
}

CCompsPP::~CCompsPP()
{
}

#include "objsel.h"

//+--------------------------------------------------------------------------
//
//  Member:     CCompsPP::OnBrowseComputers
//
//  Synopsis:   browses for computers in the entire directory
//
//  Arguments:  [in] hwndDlg : the handle to the window to which the computer
//                             selection dialog is made modal.
//
//  Returns:    nothing
//
//  History:    1/8/1999  RahulTh  created
//
//  Notes:      in case of errors, this function bails out silently
//
//---------------------------------------------------------------------------
void CCompsPP::OnBrowseComputers (HWND hwndDlg)
{
    HRESULT                 hr;
    IDsObjectPicker *       pDsObjectPicker = NULL;
    const ULONG             cbNumScopes = 4;    //make sure this number matches the number of scopes initialized
    DSOP_SCOPE_INIT_INFO    ascopes [cbNumScopes];
    DSOP_INIT_INFO          InitInfo;
    IDataObject *           pdo = NULL;
    STGMEDIUM               stgmedium = {
                                            TYMED_HGLOBAL,
                                            NULL
                                        };
    UINT                    cf = 0;
    FORMATETC               formatetc = {
                                            (CLIPFORMAT)cf,
                                            NULL,
                                            DVASPECT_CONTENT,
                                            -1,
                                            TYMED_HGLOBAL
                                        };
    BOOL                    bAllocatedStgMedium = FALSE;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    PDS_SELECTION           pDsSelection = NULL;
    PCWSTR                  lpAttributes [] = {L"dNSHostName", 0};
    VARIANT   *             pVarAttributes;

    hr = CoInitialize (NULL);

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    hr = CoCreateInstance (CLSID_DsObjectPicker,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDsObjectPicker,
                           (void **) & pDsObjectPicker
                           );

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    //Initialize the scopes.
    ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

    ascopes[0].cbSize = ascopes[1].cbSize = ascopes[2].cbSize = ascopes[3].cbSize
        = sizeof (DSOP_SCOPE_INIT_INFO);

    ascopes[0].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;

    ascopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    ascopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;

    ascopes[2].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_WORKGROUP;
    ascopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    ascopes[3].flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    ascopes[3].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    ascopes[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //populate the InitInfo structure that will be used to initialize the
    //object picker
    ZeroMemory (&InitInfo, sizeof (DSOP_INIT_INFO));

    InitInfo.cbSize = sizeof (DSOP_INIT_INFO);
    InitInfo.cDsScopeInfos = cbNumScopes;
    InitInfo.aDsScopeInfos = ascopes;
    InitInfo.apwzAttributeNames = lpAttributes;
    InitInfo.cAttributesToFetch = 1;

    hr = pDsObjectPicker->Initialize (&InitInfo);

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    hr = pDsObjectPicker->InvokeDialog (hwndDlg, &pdo);

    //if the computer selection dialog cannot be invoked or if the user
    //hits cancel, bail out.
    if (FAILED(hr) || S_FALSE == hr)
        goto BrowseComps_Cleanup;

   //if we are here, the user chose, OK, so find out what group was chosen
   cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

   if (0 == cf)
       goto BrowseComps_Cleanup;

   //set the clipboard format for the FORMATETC structure
   formatetc.cfFormat = (CLIPFORMAT)cf;

   hr = pdo->GetData (&formatetc, &stgmedium);

   if (FAILED (hr))
       goto BrowseComps_Cleanup;

   bAllocatedStgMedium = TRUE;

   pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

   //
   // Since the dialog was in single-select mode and the user was able
   // to hit OK, there should be exactly one selection.
   //
   ASSERT (1 == pDsSelList->cItems);

   pDsSelection = &(pDsSelList->aDsSelection[0]);


   pVarAttributes = pDsSelection->pvarFetchedAttributes;

   if (pVarAttributes->vt != VT_EMPTY)
   {
       //
       // Put the machine name in the edit control
       //
       SetWindowText (GetDlgItem (hwndDlg, IDC_EDIT1), pVarAttributes->bstrVal);
   }
   else
   {
       //
       // Put the machine name in the edit control
       //
       SetWindowText (GetDlgItem (hwndDlg, IDC_EDIT1), pDsSelection->pwzName);
   }


BrowseComps_Cleanup:
    if (pDsSelList)
        GlobalUnlock (pDsSelList);
    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);
    if (pdo)
        pdo->Release();
    if (pDsObjectPicker)
        pDsObjectPicker->Release();

    return;
}


BOOL CCompsPP::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Initialize dialog data
            SendMessage(GetDlgItem(hwndDlg, IDC_RADIO1), BM_SETCHECK, TRUE, 0);
            EnableWindow (GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
        }
        break;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
            case PSN_APPLY:
                {
                    if (*m_ppActive == this)
                    {
                        if (SendMessage(GetDlgItem(hwndDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                        {
                            // local computer is selected
                            m_pGBI->gpoType = GPOTypeLocal;
                        }
                        else
                        {
                            // other computer is selected
                            m_pGBI->gpoType = GPOTypeRemote;
                            int cch = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_EDIT1));
                            LPWSTR sz = new WCHAR[cch + 1];

                            if (sz)
                            {
                                GetWindowText(GetDlgItem(hwndDlg, IDC_EDIT1), sz, cch+1);
                                wcsncpy(m_pGBI->lpName, sz, m_pGBI->dwNameSize);
                                delete [] sz;
                            }
                        }
                    }
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);   // accept changes
                }
                break;
            case PSN_SETACTIVE:
                *m_ppActive = this;
                EnableWindow (GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
                break;
            default:
                break;
            }
        }
        break;
    case WM_COMMAND:
        if (IDC_BUTTON1 == LOWORD(wParam))
        {
           OnBrowseComputers (hwndDlg);
           return TRUE;
        }
        if (IDC_RADIO1 == LOWORD(wParam))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT1), FALSE);
            return TRUE;
        }
        if (IDC_RADIO2 == LOWORD(wParam))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT1), TRUE);
            SetFocus (GetDlgItem(hwndDlg, IDC_EDIT1));
            return TRUE;
        }
        break;
    case WM_ACTIVATE:
        if (WA_INACTIVE != LOWORD(wParam))
        {
            *m_ppActive = this;
        }
        break;
    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aBrowserComputerHelpIds);
        break;
    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aBrowserComputerHelpIds);
        return (TRUE);
    default:
        break;
    }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\compdata.cpp ===
//*************************************************************
//  File name: COMPDATA.C
//
//  Description:  Main component of the GPE snapin
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "main.h"
#include <initguid.h>
#include "compdata.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentData::CComponentData()
{
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;
    m_hwndFrame = NULL;
    m_bOverride = FALSE;
    m_bDirty = FALSE;
    m_bRefocusInit = FALSE;
    m_pGPO = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hMachine = NULL;
    m_hUser = NULL;
    m_gpHint = GPHintUnknown;
    m_pDisplayName = NULL;

    m_pChoosePath = NULL;
    m_hChooseBitmap = NULL;
    m_tChooseGPOType = GPOTypeLocal;
}

CComponentData::~CComponentData()
{
    if (m_pDisplayName)
    {
        LocalFree (m_pDisplayName);
    }

    if (m_pChoosePath)
    {
        LocalFree (m_pChoosePath);
    }

    if (m_hChooseBitmap)
    {
        DeleteObject (m_hChooseBitmap);
    }

    if (m_pGPO)
    {
        m_pGPO->Release();
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }


    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    HBITMAP hbmp32x32;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
    hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(hbmp32x32),
                      0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPEDATAOBJECT pGPEDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPODataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPEDataObject->SetType(type);
    pGPEDataObject->SetCookie(cookie);
    pGPEDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)
                hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
            break;

        case MMCN_PRELOAD:
            if (!m_bRefocusInit)
            {
                SCOPEDATAITEM item;

                DebugMsg((DM_VERBOSE, TEXT("CComponentData::Notify:  Received MMCN_PRELOAD event.")));
                m_bRefocusInit = TRUE;

                ZeroMemory (&item, sizeof(SCOPEDATAITEM));
                item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
                item.displayname = MMC_CALLBACK;

                if (m_pGPO)
                {
                    item.nImage = 2;
                    item.nOpenImage = 2;
                }
                else
                {
                    item.nImage = 3;
                    item.nOpenImage = 3;
                }

                item.ID = (HSCOPEITEM) arg;

                m_pScope->SetItem (&item);
            }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == g_dwNameSpaceItems)
        pItem->displayname = NULL;
    else
    {
        if (((DWORD) pItem->lParam == 0) && m_pDisplayName)
            pItem->displayname = m_pDisplayName;
        else
            pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObjectA, pGPEDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectB)))
    {
        pGPEDataObjectA->Release();
        return S_FALSE;
    }

    pGPEDataObjectA->GetCookie(&cookie1);
    pGPEDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPEDataObjectA->Release();
    pGPEDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendPropertySheet)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    TCHAR szTitle[150];



    if (IsSnapInManager(lpDataObject) == S_OK)
    {
        //
        // Create the wizard property sheet
        //

        LoadString (g_hInstance, IDS_GPE_WELCOME, szTitle, ARRAYSIZE(szTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_CHOOSE_INTRO);
        psp.pfnDlgProc = ChooseInitDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = NULL;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            return E_FAIL;
        }

        return (lpProvider->AddPage(hPage));
    }


    //
    // If we don't have a GPO, exit now.
    //

    if (!m_pGPO)
    {
        return E_FAIL;
    }


    //
    // Check if this is the GPO root object.  If so we'll display a
    // properties page.
    //

    if (IsGPORoot(lpDataObject) != S_OK)
    {
        return E_FAIL;
    }


    //
    // Ask the GPO for the property sheet pages
    //

    hr = m_pGPO->GetPropertySheetPages (&hPages, &uPageCount);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to query property sheet pages with 0x%x."), hr));
        return hr;
    }


    //
    // Add the pages
    //

    for (i = 0; i < uPageCount; i++)
    {
        hr = lpProvider->AddPage(hPages[i]);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to add property sheet page with 0x%x."), hr));
            return hr;
        }
    }

    LocalFree (hPages);

    return hr;
}

STDMETHODIMP CComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;

    hr = IsSnapInManager(lpDataObject);

    if (hr != S_OK)
    {
        hr = IsGPORoot(lpDataObject);

        if ((hr == S_OK) && !m_pGPO)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CComponentData::GetWatermarks(LPDATAOBJECT lpIDataObject,
                                           HBITMAP* lphWatermark,
                                           HBITMAP* lphHeader,
                                           HPALETTE* lphPalette,
                                           BOOL* pbStretch)
{
    *lphPalette = NULL;
    *lphHeader = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_HEADER));
    *lphWatermark = NULL;
    *pbStretch = TRUE;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendContextMenu)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;


    if (!m_pGPO)
    {
        DebugMsg((DM_VERBOSE, TEXT("CComponentData::AddMenuItems: No GPO available.  Exiting.")));
        return S_OK;
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        if (IsGPORoot(piDataObject) == S_OK)
        {
            LoadString (g_hInstance, IDS_DCOPTIONS, szMenuItem, 100);
            LoadString (g_hInstance, IDS_DCOPTIONSDESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_DCOPTIONS;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }


    return (hr);
}

STDMETHODIMP CComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{
    DCSELINFO SelInfo;
    INT iResult = 1;
    HKEY hKey;
    DWORD dwDisp, dwSize, dwType;

    if (lCommandID == IDM_DCOPTIONS)
    {

        //
        // Get the user's current DC preference
        //

        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(iResult);
            RegQueryValueEx(hKey, DCOPTION_VALUE, NULL, &dwType,
                            (LPBYTE)&iResult, &dwSize);

            RegCloseKey(hKey);
        }


        //
        // Show the dialog
        //

        SelInfo.bError = FALSE;
        SelInfo.bAllowInherit = TRUE;
        SelInfo.iDefault = iResult;
        SelInfo.lpDomainName = NULL;

        iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODC), NULL,
                                  DCDlgProc, (LPARAM) &SelInfo);


        //
        // Save the preference if appropriate
        //

        if (iResult > 0)
        {
            if (RegCreateKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                &hKey, &dwDisp) == ERROR_SUCCESS)
            {
                RegSetValueEx (hKey, DCOPTION_VALUE, 0, REG_DWORD,
                              (LPBYTE)&iResult, sizeof(iResult));

                RegCloseKey (hKey);
            }
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_GPESnapIn;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD dwVersion;
    DWORD dwPathLen;
    ULONG nBytesRead;
    DWORD dwFlags = 0;
    LPTSTR lpPath = NULL;
    LPTSTR lpCommandLine = NULL;
    GROUP_POLICY_HINT_TYPE gpHint;
    LPOLESTR pszDomain;
    LPTSTR lpDomainName;
    LPTSTR lpDCName;
    LPTSTR lpTemp, lpHint, lpName;
    TCHAR szHint[10];
    TCHAR szComputerName[MAX_PATH];
    INT iStrLen, iTemp;


    //
    // Parameter / initialization check
    //

    if (!pStm)
        return E_FAIL;

    if (m_pGPO)
        return E_UNEXPECTED;


    //
    // Get the command line
    //

    lpCommandLine = GetCommandLine();


    //
    // Create a GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&m_pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to create a GPO object with 0x%x."), hr));
        goto Exit;
    }


    //
    // Read in the saved data version number
    //

    hr = pStm->Read(&dwVersion, sizeof(dwVersion), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read version number with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Confirm that we are working with version 2
    //

    if (dwVersion != PERSIST_DATA_VERSION)
    {
        ReportError(m_hwndFrame, 0, IDS_INVALIDMSC);
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Wrong version number (%d)."), dwVersion));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the flags
    //

    hr = pStm->Read(&dwFlags, sizeof(dwFlags), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read flags with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the hint information
    //

    hr = pStm->Read(&gpHint, sizeof(gpHint), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(gpHint)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read hint with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the path string length (including null terminator)
    //

    hr = pStm->Read(&dwPathLen, sizeof(dwPathLen), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwPathLen)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read path size with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the path if there is one
    //

    if (dwPathLen > 0)
    {

        lpPath = (LPTSTR) LocalAlloc (LPTR, dwPathLen);

        if (!lpPath)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to allocate memory with %d."),
                     GetLastError()));
            hr = E_FAIL;
            goto Exit;
        }

        hr = pStm->Read(lpPath, dwPathLen, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwPathLen))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read path with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Path is: <%s>"), lpPath));
    }


    //
    // Parse the command line
    //

    if (dwFlags & MSC_FLAG_OVERRIDE)
    {

        m_bOverride = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line switch override enabled.  Command line = %s"), lpCommandLine));

        lpTemp = lpCommandLine;
        iStrLen = lstrlen (CMD_LINE_START);

        do
        {
            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              CMD_LINE_START, iStrLen,
                              lpTemp, iStrLen) == CSTR_EQUAL)
            {

                iTemp = lstrlen (CMD_LINE_HINT);
                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_HINT, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the hint switch
                    //

                    lpTemp += iTemp;
                    ZeroMemory (szHint, sizeof(szHint));
                    lpHint = szHint;

                    while (*lpTemp && ((*lpTemp) != TEXT(' ')))
                        *lpHint++ = *lpTemp++;

                    if (szHint[0] != TEXT('\0'))
                    {
                        gpHint = (GROUP_POLICY_HINT_TYPE) _ttoi(szHint);
                    }

                    continue;
                }


                iTemp = lstrlen (CMD_LINE_COMPUTER);
                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_COMPUTER, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the computer switch
                    //

                    lpTemp += iTemp + 1;
                    ZeroMemory (szComputerName, sizeof(szComputerName));
                    lpName = szComputerName;

                    while (*lpTemp && ((*lpTemp) != TEXT('\"')))
                        *lpName++ = *lpTemp++;

                    if ((*lpTemp) == TEXT('\"'))
                        lpTemp++;

                    if (szComputerName[0] != TEXT('\0'))
                    {
                        ULONG ulNoChars;

                        if (lpPath) 
                        {
                            LocalFree (lpPath);
                        }

                        ulNoChars = lstrlen(szComputerName) + 1;

                        lpPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                        if (lpPath)
                        {
                            hr = StringCchCopy (lpPath, ulNoChars, szComputerName);
                            ASSERT(SUCCEEDED(hr));

                            dwFlags &= ~MSC_FLAG_LOCAL_GPO;
                            dwFlags &= ~MSC_FLAG_DS_GPO;
                            dwFlags |= MSC_FLAG_REMOTE_GPO;
                        }
                    }

                    continue;
                }


                iTemp = lstrlen (CMD_LINE_GPO);
                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_GPO, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the gpo switch
                    //

                    lpTemp += iTemp + 1;

                    if (lpPath)
                    {
                        LocalFree (lpPath);
                    }

                    lpPath = (LPTSTR) LocalAlloc (LPTR, 512 * sizeof(TCHAR));

                    if (!lpPath)
                    {
                        lpTemp++;
                        continue;
                    }

                    dwFlags &= ~MSC_FLAG_LOCAL_GPO;
                    dwFlags &= ~MSC_FLAG_REMOTE_GPO;
                    dwFlags |= MSC_FLAG_DS_GPO;

                    lpName = lpPath;

                    while (*lpTemp && ((*lpTemp) != TEXT('\"')))
                        *lpName++ = *lpTemp++;

                    if ((*lpTemp) == TEXT('\"'))
                        lpTemp++;

                    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line path is: <%s>"), lpPath));

                    continue;
                }
            }

            lpTemp++;

        } while (*lpTemp);
    }
    else if (dwFlags & MSC_FLAG_DS_GPO && dwPathLen > 0)
    {
        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(lpPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the domain controller for this domain
        //

        lpDCName = GetDCName (lpDomainName, NULL, NULL, TRUE, 0);

        LocalFree (lpDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load:  Failed to get DC name")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Make a full path
        //

        lpTemp = MakeFullPath (lpPath, lpDCName);

        LocalFree (lpDCName);

        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load:  Failed to make full path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Swap the relative path with the full path
        //

        LocalFree (lpPath);
        lpPath = lpTemp;

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Full Path is: <%s>"), lpPath));
    }


    //
    // Do the appropriate action
    //

    if (dwFlags & MSC_FLAG_LOCAL_GPO)
    {
        hr = m_pGPO->OpenLocalMachineGPO(TRUE);

        if (FAILED(hr))
        {
            ReportError(m_hwndFrame, hr, IDS_FAILEDLOCAL);
        }
    }
    else if (dwFlags & MSC_FLAG_REMOTE_GPO)
    {
        if (lpPath)
        {
            hr = m_pGPO->OpenRemoteMachineGPO(lpPath, TRUE);

            if (FAILED(hr))
            {
                ReportError(m_hwndFrame, hr, IDS_FAILEDREMOTE, lpPath);
            }
        }
        else
        {
            hr = E_FAIL;
            ReportError(m_hwndFrame, hr, IDS_INVALIDMSC);
        }
    }
    else
    {
        if (lpPath)
        {
            hr = m_pGPO->OpenDSGPO(lpPath, GPO_OPEN_LOAD_REGISTRY);

            if (FAILED(hr))
            {
                ReportError(m_hwndFrame, hr, IDS_FAILEDDS, lpPath);
            }
        }
        else
        {
            hr = E_FAIL;
            ReportError(m_hwndFrame, hr, IDS_INVALIDMSC);
        }
    }


    if (SUCCEEDED(hr))
    {

        ClearDirty();
        m_gpHint = gpHint;

        BuildDisplayName();
    }

Exit:

    if (FAILED(hr) && m_pGPO)
    {
        m_pGPO->Release();
        m_pGPO = NULL;
    }


    if (lpPath)
    {
        LocalFree (lpPath);
    }

    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Leaving with 0x%x."), hr));

    return hr;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = STG_E_CANTSAVE;
    ULONG nBytesWritten;
    DWORD dwTemp;
    DWORD dwFlags;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    DWORD dwPathSize = 1024;


    if (!pStm)
    {
        return E_FAIL;
    }


    if (!m_pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: No GPO.  Leaving.")));
        goto Exit;
    }


    //
    // Allocate a buffer to hold the path
    //

    lpPath = (LPTSTR) LocalAlloc(LPTR, dwPathSize * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to alloc buffer for path with %d."), GetLastError()));
        goto Exit;
    }

    //
    // Determine what the flags are
    //

    dwFlags = 0;

    if (m_bOverride)
    {
        dwFlags |= MSC_FLAG_OVERRIDE;
    }

    m_pGPO->GetType (&gpoType);

    if (gpoType == GPOTypeLocal)
    {
        dwFlags |= MSC_FLAG_LOCAL_GPO;
        hr = S_OK;
    }
    else if (gpoType == GPOTypeRemote)
    {
        dwFlags |= MSC_FLAG_REMOTE_GPO;
        hr = m_pGPO->GetMachineName (lpPath, dwPathSize);
    }
    else
    {
        dwFlags |= MSC_FLAG_DS_GPO;
        hr = m_pGPO->GetPath (lpPath, dwPathSize);

        if (SUCCEEDED(hr))
        {
            lpTemp = MakeNamelessPath (lpPath);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to get nameless path")));
                goto Exit;
            }

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::Save: Nameless GPO path is:  %s"), lpTemp));

            LocalFree (lpPath);
            lpPath = lpTemp;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to get path with %d."), hr));
        goto Exit;
    }


    //
    // Save the version number
    //

    dwTemp = PERSIST_DATA_VERSION;
    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write version number with %d."), hr));
        goto Exit;
    }


    //
    // Save the flags
    //

    hr = pStm->Write(&dwFlags, sizeof(dwFlags), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write flags with %d."), hr));
        goto Exit;
    }


    //
    // Save the hint information
    //

    hr = pStm->Write(&m_gpHint, sizeof(m_gpHint), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(m_gpHint)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write hint with %d."), hr));
        goto Exit;
    }


    //
    // Save the path length
    //

    dwTemp = lstrlen (lpPath);

    if (dwTemp)
    {
        dwTemp = (dwTemp + 1) * sizeof (TCHAR);
    }

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write ds path length with %d."), hr));
        goto Exit;
    }


    if (dwTemp)
    {
        //
        // Save the path
        //

        hr = pStm->Write(lpPath, dwTemp, &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != dwTemp))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write ds path with %d."), hr));
            goto Exit;
        }
    }

    if (fClearDirty)
    {
        ClearDirty();
    }

Exit:

    if (lpPath)
    {
        LocalFree (lpPath);
    }

    return hr;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    HRESULT hr = E_FAIL;
    DWORD dwSize;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    DWORD dwPathSize = 1024;
    DWORD dwStrLen;


    //
    // Check arguments
    //

    if (!pcbSize)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: NULL pcbSize argument")));
        goto Exit;
    }


    //
    // Allocate a buffer to hold the path
    //

    lpPath = (LPTSTR) LocalAlloc(LPTR, dwPathSize * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to alloc buffer for path with %d."), GetLastError()));
        goto Exit;
    }


    //
    // Get the path if appropriate
    //

    m_pGPO->GetType (&gpoType);

    if (gpoType == GPOTypeLocal)
    {
        hr = S_OK;
    }
    else if (gpoType == GPOTypeRemote)
    {
        hr = m_pGPO->GetMachineName (lpPath, dwPathSize);
    }
    else
    {
        hr = m_pGPO->GetPath (lpPath, dwPathSize);

        if (SUCCEEDED(hr))
        {
            lpTemp = MakeNamelessPath (lpPath);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to get nameless path")));
                goto Exit;
            }

            LocalFree (lpPath);
            lpPath = lpTemp;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to get path with %d."), hr));
        goto Exit;
    }


    //
    // Set the stream size.  Version Number + Flags + Length + Unicode String + null
    //

    dwSize = 3 * sizeof(DWORD);

    dwStrLen = lstrlen(lpPath);
    if (dwStrLen)
    {
        dwSize += (dwStrLen + 1) * sizeof (TCHAR);
    }


    ULISet32(*pcbSize, dwSize);

    hr = S_OK;

Exit:

    if (lpPath)
    {
        LocalFree (lpPath);
    }

    return hr;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (ISnapinHelp)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CComponentData::InitializeNewGPO(HWND hDlg)
{
    HRESULT hr;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: Entering")));

    SetWaitCursor();

    //
    // Clean up existing GPO
    //

    if (m_pGPO)
    {
        m_pGPO->Release();
    }


    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&m_pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to create GPO with 0x%x."), hr));
        goto Exit;
    }


    //
    // Determine which item was selected
    //

    switch (m_tChooseGPOType)
    {
    case GPOTypeLocal:
        //
        // Open local policy
        //

        hr = m_pGPO->OpenLocalMachineGPO(TRUE);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDLOCAL);
        }
        else
        {
            m_gpHint = GPHintMachine;
        }
        break;
    case GPOTypeRemote:
        //
        // Open remote policy
        //

        hr = m_pGPO->OpenRemoteMachineGPO (m_pChoosePath, TRUE);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDREMOTE, m_pChoosePath);
        }
        else
        {
            m_gpHint = GPHintMachine;
        }
        break;
    case GPOTypeDS:
        {
        LPOLESTR pszDomain;
        LPTSTR lpDomainName;
        LPTSTR lpDCName;
        LPTSTR lpTemp;


        //
        // Open existing DS GPO
        //

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: User selected %s"), m_pChoosePath));


        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(m_pChoosePath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the domain controller for this domain
        //

        lpDCName = GetDCName (lpDomainName, NULL, hDlg, TRUE, 0);

        LocalFree (lpDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO:  Failed to get DC name")));
            goto Exit;
        }


        //
        // Build the full path
        //

        lpTemp = MakeFullPath (m_pChoosePath, lpDCName);

        LocalFree (lpDCName);

        if (!lpTemp)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO:  Full ADSI path is %s"),
                 lpTemp));


        hr = m_pGPO->OpenDSGPO (lpTemp, GPO_OPEN_LOAD_REGISTRY);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDDS, lpTemp);
        }
        else
        {
            m_gpHint = GPHintUnknown;
        }

        LocalFree (lpTemp);

        }
        break;
    default:
        hr = E_FAIL;
    }

Exit:

    ClearWaitCursor();


    if (SUCCEEDED(hr))
    {

        if (IsDlgButtonChecked (hDlg, IDC_OVERRIDE))
        {
            m_bOverride = TRUE;
        }
        else
        {
            m_bOverride = FALSE;
        }

        SetDirty();

        BuildDisplayName();
    }
    else
    {
        if (m_pGPO)
        {
            m_pGPO->Release();
            m_pGPO = NULL;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: Leaving with 0x%x."), hr));

    return hr;
}

HRESULT CComponentData::BuildDisplayName(void)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[MAX_FRIENDLYNAME + MAX_PATH + 20];
    WCHAR  szFriendlyName[MAX_FRIENDLYNAME];
    WCHAR  szDCName[MAX_PATH];
    GROUP_POLICY_OBJECT_TYPE type;


    szDisplayName[0] = TEXT('\0');

    if (SUCCEEDED(m_pGPO->GetDisplayName(szFriendlyName, ARRAYSIZE(szFriendlyName))))
    {
        if (SUCCEEDED(m_pGPO->GetMachineName(szDCName, ARRAYSIZE(szDCName))))
        {
            if (SUCCEEDED(m_pGPO->GetType(&type)))
            {
                if ((szDCName[0] == TEXT('\0')) || (type != GPOTypeDS))
                {
                    LoadStringW (g_hInstance, IDS_DISPLAYNAME, szDispName, ARRAYSIZE(szDispName));

                    // Display name is truncated if more than the sizeof szDisplayName

                    (void) StringCchPrintf (szDisplayName, 
                                            sizeof(szDisplayName)/sizeof(szDisplayName[0]), 
                                            szDispName, 
                                            szFriendlyName);
                }
                else
                {
                    LoadStringW (g_hInstance, IDS_DISPLAYNAME2, szDispName, ARRAYSIZE(szDispName));

                    // Display name is truncated if more than the sizeof szDisplayName

                    (void) StringCchPrintf (szDisplayName, 
                                            sizeof(szDisplayName)/sizeof(szDisplayName[0]), 
                                            szDispName, 
                                            szFriendlyName, 
                                            szDCName);
                }
            }
        }
    }

    if (szDisplayName[0] == TEXT('\0'))
    {
        LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    ULONG ulNoChars = lstrlen(szDisplayName) + 1;
    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR,  ulNoChars * sizeof(TCHAR));

    if (m_pDisplayName)
    {
        HRESULT hr;

        hr = StringCchCopy (m_pDisplayName, ulNoChars, szDisplayName);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}



//
// Returns S_OK if this is the GPO root in the scope pane or results pane.
// S_FALSE if not.
//

HRESULT CComponentData::IsGPORoot (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObject;
    DATA_OBJECT_TYPES type;
    MMC_COOKIE cookie;


    //
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPEDataObject,
                 (LPVOID *)&pGPEDataObject)))
    {

        pGPEDataObject->GetType(&type);
        pGPEDataObject->GetCookie(&cookie);

        if ((type == CCT_SCOPE) && (cookie == 0))
        {
            hr = S_OK;
        }

        pGPEDataObject->Release();
    }

    return (hr);
}

HRESULT CComponentData::IsSnapInManager (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObject;
    DATA_OBJECT_TYPES type;


    //
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPEDataObject,
                 (LPVOID *)&pGPEDataObject)))
    {

        //
        // This is a GPO object.  Now see if is a scope pane
        // data object.  We only want to display the property
        // sheet for the scope pane.
        //

        if (SUCCEEDED(pGPEDataObject->GetType(&type)))
        {
            if (type == CCT_SNAPIN_MANAGER)
            {
                hr = S_OK;
            }
        }
        pGPEDataObject->Release();
    }

    return (hr);
}

HRESULT CComponentData::GetDefaultDomain (LPTSTR *lpDomain, HWND hDlg)
{
    LPTSTR lpUserName = NULL;
    LPTSTR lpFullUserName = NULL;
    LPTSTR lpResult = NULL;
    LPTSTR lpDCName = NULL;
    LPOLESTR lpDomainTemp = NULL;
    LPTSTR lpFullDomain = NULL;
    HRESULT hr = S_OK;


    //
    // Get the username in DN format
    //

    lpUserName = MyGetUserName (NameFullyQualifiedDN);

    if (!lpUserName) {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  MyGetUserName failed for DN style name with %d"),
                 GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }


    ULONG ulNoChars = lstrlen(lpUserName) + 10;

    lpFullUserName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));
    if (!lpFullUserName)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  Failed to allocate memory for full user name with %d"),
                 GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }

    hr = StringCchCopy (lpFullUserName, ulNoChars, TEXT("LDAP://"));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (lpFullUserName, ulNoChars, lpUserName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  Failed to copy user name")));
        goto Exit;
    }

    //
    // Get the domain from the ldap path
    //

    lpDomainTemp = GetDomainFromLDAPPath(lpFullUserName);

    if (!lpDomainTemp) {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  Failed to get domain from ldap path")));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Get the domain controller for this domain
    //

    hr = ConvertToDotStyle (lpDomainTemp, &lpResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain: Failed to convert domain name with 0x%x"), hr));
        hr = E_FAIL;
        goto Exit;
    }

    lpDCName = GetDCName (lpResult, NULL, hDlg, TRUE, 0);

    if (!lpDCName)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain: Failed to query <%s> for a DC name with 0xd"),
                 lpResult, GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Build a fully qualified domain name to a specific DC
    //

    lpFullDomain = MakeFullPath (lpDomainTemp, lpDCName);

    if (!lpFullDomain)
    {
        hr = E_FAIL;
        goto Exit;
    }

    *lpDomain = lpFullDomain;


Exit:

    if (lpDomainTemp)
        delete [] lpDomainTemp;

    if (lpUserName)
        LocalFree (lpUserName);

    if (lpFullUserName)
        LocalFree (lpFullUserName);

    if (lpResult)
        LocalFree (lpResult);

    if (lpDCName)
        LocalFree (lpDCName);

    return hr;
}


INT_PTR CALLBACK CComponentData::ChooseInitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CComponentData * pCD;


    switch (message)
    {
        case WM_INITDIALOG:
            {
            TCHAR szDefaultGPO[128];

            pCD = (CComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            pCD->m_pChoosePath = NULL;
            pCD->m_tChooseGPOType = GPOTypeLocal;

            SendDlgItemMessage (hDlg, IDC_DS_GPO, BM_SETCHECK, BST_CHECKED, 0);

            if (!pCD->m_hChooseBitmap)
            {
                pCD->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                            MAKEINTRESOURCE(IDB_WIZARD),
                                                            IMAGE_BITMAP, 0, 0,
                                                            LR_DEFAULTCOLOR);
            }

            if (pCD->m_hChooseBitmap)
            {
                SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                    IMAGE_BITMAP, (LPARAM) pCD->m_hChooseBitmap);
            }


            LoadString(g_hInstance, IDS_LOCAL_DISPLAY_NAME, szDefaultGPO,
                       ARRAYSIZE(szDefaultGPO));
            SetDlgItemText (hDlg, IDC_OPEN_NAME, szDefaultGPO);
            }
            break;

        case WM_COMMAND:
            {
            pCD = (CComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD) {
                break;
            }

            switch (LOWORD(wParam))
            {
                case IDC_OPEN_BROWSE:
                    {
                    LPTSTR lpDomain = NULL;
                    TCHAR szPath[512];
                    TCHAR szName[MAX_FRIENDLYNAME];
                    GPOBROWSEINFO info;

                    ZeroMemory (&info, sizeof(GPOBROWSEINFO));

                    if (!IsStandaloneComputer())
                    {
                        pCD->GetDefaultDomain (&lpDomain, hDlg);
                    }

                    info.dwSize = sizeof(GPOBROWSEINFO);
                    info.hwndOwner = hDlg;
                    info.lpInitialOU = lpDomain;
                    info.lpDSPath = szPath;
                    info.dwDSPathSize = ARRAYSIZE(szPath);
                    info.lpName = szName;
                    info.dwNameSize = ARRAYSIZE(szName);
                    if (!lpDomain)
                    {
                        info.dwFlags = GPO_BROWSE_NODSGPOS;
                    }

                    if (SUCCEEDED(BrowseForGPO(&info)))
                    {
                        if (pCD->m_pChoosePath)
                        {
                            LocalFree (pCD->m_pChoosePath);
                            pCD->m_pChoosePath = NULL;
                        }

                        pCD->m_tChooseGPOType = info.gpoType;

                        switch (pCD->m_tChooseGPOType)
                        {
                            HRESULT hr;
                            ULONG ulNoChars;

                            default:
                            case GPOTypeLocal:
                                LoadString(g_hInstance, IDS_LOCAL_DISPLAY_NAME, szPath, ARRAYSIZE(szPath));
                                break;

                            case GPOTypeRemote:
                                ulNoChars = lstrlen (szName) + 1;
                                pCD->m_pChoosePath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                                if (pCD->m_pChoosePath)
                                {
                                    hr = StringCchCopy (pCD->m_pChoosePath, ulNoChars, szName);
                                    ASSERT(SUCCEEDED(hr));
                                }

                                LoadString(g_hInstance, IDS_REMOTE_DISPLAY_NAME, szPath, ARRAYSIZE(szPath));
                                (void) StringCchCat(szPath, ARRAYSIZE(szPath), szName);
                                break;

                            case GPOTypeDS:
                                ulNoChars = lstrlen (szPath) + 1;
                                pCD->m_pChoosePath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                                if (pCD->m_pChoosePath)
                                {
                                    hr = StringCchCopy (pCD->m_pChoosePath, ulNoChars, szPath);
                                    ASSERT(SUCCEEDED(hr));
                                }

                                (void) StringCchCopy(szPath, ARRAYSIZE(szPath),szName );
                                break;
                        }

                        SetDlgItemText (hDlg, IDC_OPEN_NAME, szPath);
                    }

                    if (lpDomain)
                    {
                        LocalFree (lpDomain);
                    }

                    }
                    break;
            }

            }
            break;

        case WM_REFRESHDISPLAY:
            SetFocus (GetDlgItem(hDlg, IDC_OPEN_NAME));
            break;

        case WM_NOTIFY:

            pCD = (CComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_FINISH);
                    break;

                case PSN_WIZFINISH:
                    if (FAILED(pCD->InitializeNewGPO(hDlg)))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                        return TRUE;
                    }

                    // fall through

                case PSN_RESET:

                    if (pCD->m_pChoosePath)
                    {
                        LocalFree (pCD->m_pChoosePath);
                        pCD->m_pChoosePath = NULL;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}

HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    if (!m_hRoot) {

        m_hRoot = hParent;

        if (!m_bRefocusInit)
        {
            SCOPEDATAITEM rootItem;

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::EnumerateScopePane:  Resetting the root node")));
            m_bRefocusInit = TRUE;

            ZeroMemory (&rootItem, sizeof(SCOPEDATAITEM));
            rootItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            rootItem.displayname = MMC_CALLBACK;

            if (m_pGPO)
            {
                rootItem.nImage = 2;
                rootItem.nOpenImage = 2;
            }
            else
            {
                rootItem.nImage = 3;
                rootItem.nOpenImage = 3;
            }

            rootItem.ID = hParent;

            m_pScope->SetItem (&rootItem);
        }
    }


    if (!m_pGPO)
    {
        if (m_hRoot == hParent)
        {
            SCOPEDATAITEM rootItem;

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::EnumerateScopePane: No GPO available.  Exiting.")));

            ZeroMemory (&rootItem, sizeof(SCOPEDATAITEM));
            rootItem.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            rootItem.displayname = MMC_CALLBACK;
            rootItem.nImage = 3;
            rootItem.nOpenImage = 3;
            rootItem.nState = 0;
            rootItem.cChildren = 0;
            rootItem.lParam = g_NameSpace[0].dwID;
            rootItem.relativeID =  hParent;

            m_pScope->InsertItem (&rootItem);
        }

        return S_OK;
    }


    // Now to do the actual enumeration ...
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;

    if (m_hRoot == hParent)
    {
        dwIndex = 0;
    }
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    for (i = 0; i < g_dwNameSpaceItems; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = g_NameSpace[i].iIcon;
            item.nOpenImage = g_NameSpace[i].iOpenIcon;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            if (SUCCEEDED(m_pScope->InsertItem (&item)))
            {
                if (i == 1)
                {
                    m_hMachine = item.ID;
                }
                else if (i == 2)
                {
                    m_hUser = item.ID;
                }
            }
        }
    }

    return S_OK;
}

HRESULT CComponentData::GetOptions (DWORD * pdwOptions)
{

    if (!pdwOptions)
    {
        return E_INVALIDARG;
    }


    *pdwOptions = 0;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\compdata.h ===
//
// Root of the name space
// {8FC0B736-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_GPERoot, 0x8fc0b736, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// Computer Configuration
// {8FC0B739-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineRoot, 0x8fc0b739, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration
// {8FC0B73B-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserRoot, 0x8fc0b73b, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// Root of the RSOP name space
// {6f13bce5-39fd-45bc-8e9c-2002b409eba5}
//

DEFINE_GUID(NODEID_RSOPRoot, 0x6f13bce5, 0x39fd, 0x45bc, 0x8e, 0x9c, 0x20, 0x02, 0xb4, 0x09, 0xeb, 0xa5);

//
// RSOP Computer Configuration
// {e753a11a-66cc-4816-8dd8-3cbe46717fd3}
//

DEFINE_GUID(NODEID_RSOPMachineRoot, 0xe753a11a, 0x66cc, 0x4816, 0x8d, 0xd8, 0x3c, 0xbe, 0x46, 0x71, 0x7f, 0xd3);

//
// RSOP User Configuration
// {99d5b872-1ad0-4d87-acf1-82125d317653}
//
DEFINE_GUID(NODEID_RSOPUserRoot, 0x99d5b872, 0x1ad0, 0x4d87, 0xac, 0xf1, 0x82, 0x12, 0x5d, 0x31, 0x76, 0x53);

#ifndef _COMPDATA_H_
#define _COMPDATA_H_


//
// CComponentData class
//

class CComponentData:
    public IComponentData,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                          m_cRef;
    HWND                           m_hwndFrame;
    BOOL                           m_bOverride;
    BOOL                           m_bDirty;
    BOOL                           m_bRefocusInit;
    LPGROUPPOLICYOBJECT            m_pGPO;
    LPCONSOLENAMESPACE             m_pScope;
    LPCONSOLE                      m_pConsole;
    HSCOPEITEM                     m_hRoot;
    HSCOPEITEM                     m_hMachine;
    HSCOPEITEM                     m_hUser;
    GROUP_POLICY_HINT_TYPE         m_gpHint;
    LPTSTR                         m_pDisplayName;
    LPTSTR                         m_pDCName;

    LPTSTR                         m_pChoosePath;
    HBITMAP                        m_hChooseBitmap;
    GROUP_POLICY_OBJECT_TYPE       m_tChooseGPOType;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IExtendPropertySheet2 methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
    STDMETHODIMP         GetWatermarks(LPDATAOBJECT lpIDataObject,  HBITMAP* lphWatermark,
                                       HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* pbStretch);


    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);


private:
    HRESULT InitializeNewGPO(HWND hDlg);
    HRESULT BuildDisplayName(void);
    HRESULT IsGPORoot (LPDATAOBJECT lpDataObject);
    HRESULT IsSnapInManager (LPDATAOBJECT lpDataObject);
    HRESULT GetDefaultDomain (LPTSTR *lpDomain, HWND hDlg);
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    HRESULT GetOptions (DWORD * pdwOptions);

    void SetDirty(VOID)  { m_bDirty = TRUE; }
    void ClearDirty(VOID)  { m_bDirty = FALSE; }
    BOOL ThisIsDirty(VOID) { return m_bDirty; }

    static INT_PTR CALLBACK ChooseInitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};



//
// ComponentData class factory
//


class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// Save console defines
//

#define PERSIST_DATA_VERSION    3              // version number in msc file

#define MSC_FLAG_OVERRIDE       0x00000001     // allow command line switches to override msc contents
#define MSC_FLAG_LOCAL_GPO      0x00000002     // open local gpo
#define MSC_FLAG_REMOTE_GPO     0x00000004     // open remote gpo, machine name is stored in msc file
#define MSC_FLAG_DS_GPO         0x00000008     // open ds gpo, ldap path is stored in msc file


//
// Command line switches
//

#define CMD_LINE_START          TEXT("/gp")               // base to all group policy command line switches
#define CMD_LINE_HINT           TEXT("/gphint:")          // hint to which DS object (or machine) this gpo is linked to
#define CMD_LINE_GPO            TEXT("/gpobject:")        // gpo path in quotes
#define CMD_LINE_COMPUTER       TEXT("/gpcomputer:")      // computer name in quotes

#endif // _COMPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\compspp.h ===
#if !defined __COMPSPP_H__
#define __COMPSPP_H__

#include "cproppg.h"

/////////////////////////////////////////////////////////////////////////////
// CCompsPP dialog

class CCompsPP:CHlprPropPage
{
// Construction
public:
    CCompsPP();
    ~CCompsPP();
    HPROPSHEETPAGE Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive);

    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dialog Data
    LPCWSTR             m_szComputer;
    int                 m_iSelection;
    LPGPOBROWSEINFO     m_pGBI;
    protected:
    DWORD               m_dwPageType;
    void **             m_ppActive;

private:    //private helper functions
    void    OnBrowseComputers (HWND hwndDlg);
};

#endif // __COMPSPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\dataobj.h ===
//
// IGPEDataobject interface id
//

// {4AE19822-BCEE-11d0-9484-080036B11A03}
DEFINE_GUID(IID_IGPEDataObject, 0x4ae19822, 0xbcee, 0x11d0, 0x94, 0x84, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);



#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPE.
// When the GPE snapin receives a dataobject and needs to determine
// if it came from the GPE snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPEDataObject
DECLARE_INTERFACE_(IGPEDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IGPEDataObject *LPGPEDATAOBJECT;



//
// CDataObject class
//

class CDataObject : public IDataObject,
                    public IGPEInformation,
                    public IGPEDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfPreloads;
    static unsigned int    m_cfNodeID;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IGPEInformation methods
    //

    STDMETHOD(GetName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetDisplayName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetRegistryKey) (DWORD dwSection, HKEY *hKey);
    STDMETHOD(GetDSPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetFileSysPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetOptions) (DWORD *dwOptions);
    STDMETHOD(GetType) (GROUP_POLICY_OBJECT_TYPE *gpoType);
    STDMETHOD(GetHint) (GROUP_POLICY_HINT_TYPE *gpHint);
    STDMETHOD(PolicyChanged) (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin);


    //
    // Implemented IGPEDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\cproppg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cproppg.cxx
//
//  Contents:
//
//  Classes:    CHlprPropPage
//
//  Functions:  DialogProc
//
//  History:    4-12-1994   stevebl   original dialog box helpers Created
//              4-29-1998   stevebl   Modified from dialog box helpers
//
//----------------------------------------------------------------------------

#include "main.h"
#include "cproppg.h"

HPROPSHEETPAGE CHlprPropPage::CreatePropertySheetPage(LPPROPSHEETPAGE lppsp)
{
    lppsp->pfnDlgProc = HlprPropPageDialogProc;
    lppsp->lParam = (LPARAM)(CHlprPropPage *) this;
    return ::CreatePropertySheetPage(lppsp);
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprPropPage class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprPropPage::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprPropPage class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK HlprPropPageDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprPropPage * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprPropPage *) ((PROPSHEETPAGE *)lParam)->lParam;
        // set its USERDATA word to point to the class object
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprPropPage *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprPropPage *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\cproppg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cproppg.h
//
//  Contents:   definition for common property page functionality
//
//  Classes:    CHlprPropPage (pure virtual class)
//
//  Functions:  HlprPropPageDialogProc
//
//  History:    4-12-1994   stevebl   original dialog box helpers Created
//              4-29-1998   stevebl   Modified from dialog box helpers
//
//----------------------------------------------------------------------------

#ifndef __CPROPPG_H__
#define __CPROPPG_H__

#ifdef __cplusplus
extern "C" {
#endif

INT_PTR CALLBACK HlprPropPageDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprPropPage
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprPropPage   -- destructor
//
//  History:    4-12-94   stevebl   Created
//              7-02-1997   stevebl   added CreateDlg
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprPropPage
{
public:
    virtual HPROPSHEETPAGE CreatePropertySheetPage(LPPROPSHEETPAGE lppsp);
    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprPropPage(){};
protected:
    HINSTANCE m_hInstance;
};

#endif //__cplusplus

#endif //__CPROPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\dataobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
unsigned int CDataObject::m_cfNodeID         = RegisterClipboardFormat(CCF_NODEID);
unsigned int CDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPEInformation))
    {
        *ppv = (LPGPEINFORMATION)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IGroupPolicyObject))
    {
        if (m_pcd->m_pGPO)
        {
            return (m_pcd->m_pGPO->QueryInterface (riid, ppv));
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (IsEqualIID(riid, IID_IGPEDataObject))
    {
        *ppv = (LPGPEDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[300];

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                LoadString (g_hInstance, g_NameSpace[m_cookie].iStringDescID, szDesc, ARRAYSIZE(szDesc));
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie == 0)
            {
                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IGPEInformation)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDataObject::GetName (LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->m_pGPO->GetName(pszName, cchMaxLength);
}

STDMETHODIMP CDataObject::GetDisplayName (LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->m_pGPO->GetDisplayName(pszName, cchMaxLength);
}

STDMETHODIMP CDataObject::GetRegistryKey (DWORD dwSection, HKEY *hKey)
{
    return m_pcd->m_pGPO->GetRegistryKey(dwSection, hKey);
}

STDMETHODIMP CDataObject::GetDSPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    return m_pcd->m_pGPO->GetDSPath(dwSection, pszPath, cchMaxPath);
}

STDMETHODIMP CDataObject::GetFileSysPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    return m_pcd->m_pGPO->GetFileSysPath(dwSection, pszPath, cchMaxPath);
}

STDMETHODIMP CDataObject::GetOptions (DWORD *dwOptions)
{
    return m_pcd->GetOptions(dwOptions);
}

STDMETHODIMP CDataObject::GetType (GROUP_POLICY_OBJECT_TYPE *gpoType)
{
    return m_pcd->m_pGPO->GetType(gpoType);
}

STDMETHODIMP CDataObject::GetHint (GROUP_POLICY_HINT_TYPE *gpHint)
{
    if (!gpHint)
    {
        return E_INVALIDARG;
    }

    *gpHint = m_pcd->m_gpHint;

    return S_OK;
}

STDMETHODIMP CDataObject::PolicyChanged (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin)
{
    return m_pcd->m_pGPO->Save(bMachine, bAdd, pGuidExtension, pGuidSnapin);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[300];

    //
    // This is the display named used in the scope pane and snap-in manager
    //

    szDisplayName[0] = TEXT('\0');

    if (m_pcd->m_pGPO && m_pcd->m_pDisplayName)
    {
        lstrcpyn (szDisplayName, m_pcd->m_pDisplayName, 300);
    }
    else
    {
        LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPESnapIn, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}

HRESULT CDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];
    SNodeID * psNode;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    lpMedium->hGlobal = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, (lstrlen(szNodeType) * sizeof(TCHAR)) + sizeof(SNodeID));

    if (!lpMedium->hGlobal)
    {
        return (STG_E_MEDIUMFULL);
    }

    psNode = (SNodeID *) GlobalLock (lpMedium->hGlobal);

    psNode->cBytes = lstrlen(szNodeType) * sizeof(TCHAR);
    CopyMemory (psNode->id, szNodeType, psNode->cBytes);

    GlobalUnlock (lpMedium->hGlobal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "main.h"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPEdit[] = TEXT("GPEDIT(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPEditDebugLevel")

//
// Log files
//

TCHAR szLogFileName[] = TEXT("%SystemRoot%\\Debug\\UserMode\\gpedit.log");

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level appropriately
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    dwDebugLevel = DL_NORMAL | DL_LOGFILE;
#endif


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[40];
    TCHAR szDebugBuffer[4096];
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {

        //
        // Build the error text prefix and message
        //

        GetLocalTime (&systime);
        (void) StringCchPrintf (szDebugTitle, ARRAYSIZE(szDebugTitle),c_szGPEdit ,
                                GetCurrentProcessId(), GetCurrentThreadId(),
                                systime.wHour, systime.wMinute, systime.wSecond,
                                systime.wMilliseconds);

        va_start(marker, pszMsg);
        (void) StringCchVPrintf(szDebugBuffer, ARRAYSIZE(szDebugBuffer), pszMsg, marker);
        va_end(marker);


        //
        // Print to the debugger if appropriate
        //

        if (dwDebugLevel & DL_DEBUGGER) {
            OutputDebugString(szDebugTitle);
            OutputDebugString(szDebugBuffer);
            OutputDebugString(c_szCRLF);
        }


        //
        // Add to the log file if appropriate
        //

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            ExpandEnvironmentStrings (szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));

            hFile = CreateFile(szExpLogFileName,
                               FILE_WRITE_DATA | FILE_APPEND_DATA,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DmAssert(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,TEXT("Gpedit.dll assertion ") TEXT(#x) TEXT(" failed\n"));

#define DebugMsg(x) if (dwDebugLevel != DL_NONE) \
                        _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\events.h ===
//
// Event log entry
//

typedef struct tagEVENTLOGENTRY {
    DWORD    dwEventID;
    FILETIME ftEventTime;
    LPTSTR   lpEventLogName;
    LPTSTR   lpEventSourceName;
    LPTSTR   lpText;
    struct tagEVENTLOGENTRY * pNext;
} EVENTLOGENTRY, *LPEVENTLOGENTRY;


//
// Source name entry
//

typedef struct tagSOURCEENTRY {
    LPTSTR   lpEventLogName;
    LPTSTR   lpEventSourceName;
    struct tagSOURCEENTRY * pNext;
} SOURCEENTRY, *LPSOURCEENTRY;


//
// CEvents class
//

class CEvents
{
private:

    LPEVENTLOGENTRY   m_pEventEntries;

public:
    CEvents();
    ~CEvents();

    BOOL AddEntry(LPTSTR lpEventLogName, LPTSTR lpEventSourceName, LPTSTR lpText,
                  DWORD dwEventID, FILETIME *ftTime);

    VOID FreeData();

    STDMETHODIMP SecondsSince1970ToFileTime(DWORD dwSecondsSince1970,
                                            FILETIME *pftTime);

    LPTSTR BuildMessage(LPTSTR lpMsg, LPTSTR *lpStrings, DWORD dwStringCount,
                        HMODULE hParamFile);

    STDMETHODIMP SaveEventLogEntry (PEVENTLOGRECORD pEntry,
                                    LPTSTR lpEventLogName,
                                    LPTSTR lpEventSourceName,
                                    FILETIME *ftEntry);

    LPTSTR * BuildStringArray(LPTSTR lpStrings, DWORD dwStringCount);

    STDMETHODIMP ParseEventLogRecords (PEVENTLOGRECORD lpEntries,
                                       DWORD dwEntriesSize,
                                       LPTSTR lpEventLogName,
                                       LPTSTR lpEventSourceName,
                                       DWORD  dwEventID,
                                       FILETIME * pBeginTime,
                                       FILETIME * pEndTime);

    STDMETHODIMP QueryForEventLogEntries (LPTSTR lpComputerName,
                                          LPTSTR lpEventLogName,
                                          LPTSTR lpEventSourceName,
                                          DWORD dwEventID,
                                          SYSTEMTIME * pBeginTime,
                                          SYSTEMTIME * pEndTime);

    STDMETHODIMP GetEventLogEntryText(LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                      LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);

    BOOL IsEntryInEventSourceList (LPEVENTLOGENTRY lpEntry, LPSOURCEENTRY lpEventSources);

    BOOL IsEntryInExceptionList (LPEVENTLOGENTRY lpEntry);

    STDMETHODIMP GetCSEEntries(SYSTEMTIME * pBeginTime, SYSTEMTIME * pEndTime,
                               LPSOURCEENTRY lpEventSources, LPOLESTR *ppszText, BOOL bGpCore);

    STDMETHODIMP DumpDebugInfo (void);

    LPTSTR ConvertTimeToDisplayTime (SYSTEMTIME *pSysTime, FILETIME *pFileTime, LPTSTR szBuffer, ULONG ulNoChars);

    STDMETHODIMP AddSourceEntry (LPTSTR lpEventLogName,
                                 LPTSTR lpEventSourceName,
                                 LPSOURCEENTRY *lpList);

    static VOID FreeSourceData(LPSOURCEENTRY lpList);

    STDMETHODIMP SaveEntriesToStream (IStream *pStm);

    STDMETHODIMP LoadEntriesFromStream (IStream *pStm);

};

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\events.cpp ===
//*************************************************************
//  File name: Events.CPP
//
//  Description:  Event log entries for RSOP
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************
#include "main.h"
#include "rsoputil.h"

EVENTLOGENTRY   ExceptionEventEntries[] = 
                {
                    {1036, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1037, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1038, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1039, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1040, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1041, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1085, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL}
            };

DWORD           dwExceptionEventEntriesSize = 7;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CEvents implementation                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

                     
                     
CEvents::CEvents(void)
{
    InterlockedIncrement(&g_cRefThisDll);

    m_pEventEntries = NULL;
}

CEvents::~CEvents()
{
    FreeData();

    InterlockedDecrement(&g_cRefThisDll);
}

BOOL CEvents::AddEntry(LPTSTR lpEventLogName, LPTSTR lpEventSourceName, LPTSTR lpText,
                       DWORD dwEventID, FILETIME *ftTime)
{
    DWORD dwSize;
    LPEVENTLOGENTRY lpItem, lpTemp, pPrev;
    HRESULT hr;
    ULONG ulNoChars;


    //
    // Check if this entry exists already
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if (dwEventID == lpTemp->dwEventID)
        {
            if (!lstrcmpi(lpEventLogName, lpTemp->lpEventLogName))
            {
                if (!lstrcmpi(lpEventSourceName, lpTemp->lpEventSourceName))
                {
                    if (ftTime->dwLowDateTime == lpTemp->ftEventTime.dwLowDateTime)
                    {
                        if (ftTime->dwHighDateTime == lpTemp->ftEventTime.dwHighDateTime)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (EVENTLOGENTRY);

    dwSize += ((lstrlen(lpEventLogName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpEventSourceName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpText) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPEVENTLOGENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddEntry: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    ulNoChars = (dwSize - sizeof(EVENTLOGENTRY))/sizeof(WCHAR);
    lpItem->lpEventLogName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(EVENTLOGENTRY));
    hr = StringCchCopy (lpItem->lpEventLogName, ulNoChars, lpEventLogName);

    if (SUCCEEDED(hr)) 
    {
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpEventLogName) + 1);
        lpItem->lpEventSourceName = lpItem->lpEventLogName + lstrlen (lpItem->lpEventLogName) + 1;
        hr = StringCchCopy (lpItem->lpEventSourceName, ulNoChars, lpEventSourceName);
    }

    if (SUCCEEDED(hr)) 
    {
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpEventSourceName) + 1);
        lpItem->lpText = lpItem->lpEventSourceName + lstrlen (lpItem->lpEventSourceName) + 1;
        hr = StringCchCopy (lpItem->lpText, ulNoChars, lpText);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddEntry: Failed to copy event item with %d"), hr));
        LocalFree(lpItem);
        return FALSE;
    }

    lpItem->dwEventID = dwEventID;

    CopyMemory ((LPBYTE)&lpItem->ftEventTime, ftTime, sizeof(FILETIME));


    //
    // Add item to the link list
    //

    if (m_pEventEntries)
    {

        if (CompareFileTime(ftTime, &m_pEventEntries->ftEventTime) < 0)
        {
            lpItem->pNext = m_pEventEntries;
            m_pEventEntries = lpItem;
        }
        else
        {
            pPrev = m_pEventEntries;
            lpTemp = m_pEventEntries->pNext;

            while (lpTemp)
            {
                if (lpTemp->pNext)
                {
                    if ((CompareFileTime(ftTime, &lpTemp->ftEventTime) >= 0) &&
                        (CompareFileTime(ftTime, &lpTemp->pNext->ftEventTime) <= 0))
                    {
                        lpItem->pNext = lpTemp->pNext;
                        lpTemp->pNext = lpItem;
                        break;
                    }
                }

                pPrev = lpTemp;
                lpTemp = lpTemp->pNext;
            }

            if (!lpTemp)
            {
                pPrev->pNext = lpItem;
            }
        }
    }
    else
    {
        m_pEventEntries = lpItem;
    }

    return TRUE;
}

VOID CEvents::FreeData()
{
    if (m_pEventEntries)
    {
        LPEVENTLOGENTRY lpTemp;

        do {
            lpTemp = m_pEventEntries->pNext;
            LocalFree (m_pEventEntries);
            m_pEventEntries = lpTemp;

        } while (lpTemp);
    }
}


STDMETHODIMP CEvents::SecondsSince1970ToFileTime(DWORD dwSecondsSince1970,
                                                 FILETIME *pftTime)
{
    //  Seconds since the start of 1970 -> 64 bit Time value

    LARGE_INTEGER liTime;

    RtlSecondsSince1970ToTime(dwSecondsSince1970, &liTime);

    //
    //  The time is in UTC
    //

    pftTime->dwLowDateTime  = liTime.LowPart;
    pftTime->dwHighDateTime = liTime.HighPart;

    return S_OK;
}

LPTSTR * CEvents::BuildStringArray(LPTSTR lpStrings, DWORD dwStringCount)
{
    LPTSTR lpTemp;
    LPTSTR *lpResult;


    if (!lpStrings || !dwStringCount)
    {
        return NULL;
    }

    //
    // Allocate a new array to hold the pointers
    //

    lpResult = (LPTSTR *) LocalAlloc (LPTR, dwStringCount * sizeof(LPTSTR));

    if (lpResult)
    {    
        //
        // Save the pointers
        //

        lpTemp = lpStrings;

        for ( DWORD dwIndex = 0; dwIndex < dwStringCount; dwIndex++)
        {
            lpResult[dwIndex] = lpTemp;
            lpTemp += lstrlen(lpTemp) + 1;
        }
    }

    return lpResult;
}

LPTSTR CEvents::BuildMessage(LPTSTR lpMsg, LPTSTR *lpStrings, DWORD dwStringCount,
                             HMODULE hParamFile)
{
    LPTSTR lpFullMsg = NULL;
    LPTSTR lpSrcIndex;
    LPTSTR lpTemp, lpNum;
    TCHAR cChar, cTemp;
    TCHAR cCharStr[2] = {0,0};
    DWORD dwCharCount = 1, dwTemp;
    BOOL bAdd;
    TCHAR szNumStr[10];
    DWORD dwIndex;
    LPTSTR lpParamMsg;
    HRESULT hr;

    if ( !lpMsg || (dwStringCount && !lpStrings) )
    {
        return 0;
    }

    lpFullMsg = (LPTSTR) LocalAlloc (LPTR, dwCharCount * sizeof(TCHAR));

    if (!lpFullMsg)
    {
        return NULL;
    }


    lpSrcIndex = lpMsg;

    while (*lpSrcIndex)
    {
        bAdd = TRUE;
        cChar = *lpSrcIndex;


        if (cChar == TEXT('%'))
        {
            cTemp = *(lpSrcIndex + 1);

            if (ISDIGIT (cTemp))
            {

                if (dwStringCount == 0)
                {
                    goto LoopAgain;
                }

                //
                // Found a replaceable parameter from the passed in strings
                //

                lpNum = lpSrcIndex + 1;


                //
                // Pull the string index off
                //

                ZeroMemory (szNumStr, sizeof(szNumStr));

                while (ISDIGIT(*lpNum))
                {
                    cCharStr[0] = *lpNum;

                    hr = StringCchCat (szNumStr, ARRAYSIZE(szNumStr),cCharStr );
                    if (FAILED(hr)) 
                    {
                        LocalFree(lpFullMsg);
                        lpFullMsg = NULL;
                        goto Exit;
                    }

                    if (lstrlen (szNumStr) == (ARRAYSIZE(szNumStr) - 2))
                    {
                        goto LoopAgain;
                    }

                    lpNum++;
                }

                //
                // Convert the string index to a dword
                //

                dwIndex = 0;
                StringToNum(szNumStr, (UINT *)&dwIndex);


                //
                // Subtrack 1 to make it zero based
                //

                if (dwIndex)
                {
                    dwIndex--;
                }

                if (dwIndex > dwStringCount)
                {
                    goto LoopAgain;
                }

                // shorter strings will go to the else condition
                if ( (*(lpStrings[dwIndex]) == TEXT('%')) && (*(lpStrings[dwIndex]+1) == TEXT('%')) ) {

                    DWORD       dwArgIndex;
                    LPTSTR      lpArgString;
                    LPTSTR      lpEnd;
                    TCHAR       szNumArg[10];

                    lpArgString =  lpStrings[dwIndex]+2;
                    lpEnd = szNumArg;
                    
                    for(int i=0; i<9 && ISDIGIT(*lpArgString); i++)
                    {
                        *lpEnd = *lpArgString;
                        lpEnd++;
                        lpArgString++;
                    }
                    
                    *lpEnd = TEXT('\0');

                    //
                    // Convert the string index to a dword
                    //

                    dwArgIndex = 0;
                    StringToNum(szNumArg, (UINT *)&dwArgIndex);


                    //
                    // Convert the string number to a dword
                    //


                    lpParamMsg = NULL;
                    if (hParamFile)
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, (LPCVOID) hParamFile,
                                       dwArgIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);
                    }
                    else
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL,
                                       dwArgIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);


                    }

                    LPWSTR szMsgArg;

                    if (lpParamMsg) {
                        szMsgArg = lpParamMsg;
                    }
                    else {
                        szMsgArg = lpStrings[dwIndex]; 
                    }

                    dwTemp = lstrlen (szMsgArg) + dwCharCount;
                    lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwTemp * sizeof(TCHAR),
                                                    LMEM_MOVEABLE | LMEM_ZEROINIT);

                    if (!lpTemp)
                    {
                        LocalFree (lpFullMsg);
                        lpFullMsg = NULL;
                        goto Exit;
                    }

                    dwCharCount = dwTemp;
                    lpFullMsg = lpTemp;

                    hr = StringCchCat (lpFullMsg, dwCharCount, szMsgArg);
                    if (FAILED(hr)) 
                    {
                        LocalFree(lpFullMsg);
                        lpFullMsg = NULL;
                        goto Exit;
                    }

                    if (lpParamMsg) {
                        LocalFree(lpParamMsg);
                    }
                }
                else {
                    //
                    // Add the string to the buffer
                    //

                    dwTemp = lstrlen (lpStrings[dwIndex]) + dwCharCount;
                    lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwTemp * sizeof(TCHAR),
                                                    LMEM_MOVEABLE | LMEM_ZEROINIT);

                    if (!lpTemp)
                    {
                        LocalFree (lpFullMsg);
                        lpFullMsg = NULL;
                        goto Exit;
                    }

                    dwCharCount = dwTemp;
                    lpFullMsg = lpTemp;

                    hr = StringCchCat (lpFullMsg, dwCharCount, lpStrings[dwIndex]);
                    if (FAILED(hr)) 
                    {
                        LocalFree(lpFullMsg);
                        lpFullMsg = NULL;
                        goto Exit;
                    }
                }

                lpSrcIndex = lpNum - 1;

                bAdd = FALSE;
            }
            else if (cTemp == TEXT('%'))
            {

                cTemp = *(lpSrcIndex + 2);

                if (cTemp == TEXT('%'))
                  {
                    //
                    // Found a replacable parameter from the parameter file
                    //

                    lpNum = lpSrcIndex + 3;


                    //
                    // Pull the string index off
                    //

                    ZeroMemory (szNumStr, sizeof(szNumStr));

                    while (ISDIGIT(*lpNum))
                    {
                        cCharStr[0] = *lpNum;
                        hr = StringCchCat (szNumStr, ARRAYSIZE(szNumStr), cCharStr);
                        if (FAILED(hr)) 
                        {
                            LocalFree(lpFullMsg);
                            lpFullMsg = NULL;
                            goto Exit;
                        }

                        if (lstrlen (szNumStr) == (ARRAYSIZE(szNumStr) - 2))
                        {
                            goto LoopAgain;
                        }

                        lpNum++;
                    }


                    //
                    // Convert the string index to a dword
                    //

                    dwIndex = 0;
                    StringToNum(szNumStr, (UINT *)&dwIndex);


                    //
                    // Subtrack 1 to make it zero based
                    //

                    if (dwIndex)
                    {
                        dwIndex--;
                    }

                    if (dwIndex > dwStringCount)
                    {
                        goto LoopAgain;
                    }


                    //
                    // Convert the string number to a dword
                    //

                    StringToNum(lpStrings[dwIndex], (UINT *)&dwIndex);


                    lpParamMsg = NULL;
                    if (hParamFile)
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, (LPCVOID) hParamFile,
                                       dwIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);
                    }
                    else
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL,
                                       dwIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);
                    }

                    if (lpParamMsg)
                    {

                        lpTemp = lpParamMsg + lstrlen(lpParamMsg) - 2;

                        *lpTemp = TEXT('\0');

                        //
                        // Add the string to the buffer
                        //

                        dwTemp = lstrlen (lpParamMsg) + dwCharCount;
                        lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwTemp * sizeof(TCHAR),
                                                        LMEM_MOVEABLE | LMEM_ZEROINIT);

                        if (!lpTemp)
                        {
                            LocalFree (lpFullMsg);
                            lpFullMsg = NULL;
                            goto Exit;
                        }

                        dwCharCount = dwTemp;
                        lpFullMsg = lpTemp;

                        hr = StringCchCat (lpFullMsg, dwCharCount, lpParamMsg);
                        if (FAILED(hr)) 
                        {
                            LocalFree(lpFullMsg);
                            lpFullMsg = NULL;
                            goto Exit;
                        }

                        lpSrcIndex = lpNum - 1;

                        bAdd = FALSE;

                        LocalFree (lpParamMsg);
                    }
                }
            }
        }


LoopAgain:

        if (bAdd)
        {
            //
            // Add this character to the buffer
            //

            dwCharCount++;
            lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwCharCount * sizeof(TCHAR),
                                            LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTemp)
            {
                LocalFree (lpFullMsg);
                lpFullMsg = NULL;
                goto Exit;
            }

            lpFullMsg = lpTemp;

            cCharStr[0] = cChar;
            hr = StringCchCat (lpFullMsg, dwCharCount, cCharStr);
            if (FAILED(hr)) 
            {
                LocalFree(lpFullMsg);
                lpFullMsg = NULL;
                goto Exit;
            }
        }

        lpSrcIndex++;
    }

Exit:

    return lpFullMsg;
}

STDMETHODIMP CEvents::SaveEventLogEntry (PEVENTLOGRECORD pEntry,
                                         LPTSTR lpEventLogName,
                                         LPTSTR lpEventSourceName,
                                         FILETIME *ftEntry)
{
    LPTSTR lpRegKey = NULL;
    HKEY hKey = NULL;
    TCHAR szEventFile[MAX_PATH];
    TCHAR szExpEventFile[MAX_PATH];
    TCHAR szParamFile[MAX_PATH] = {0};
    TCHAR szExpParamFile[MAX_PATH] = {0};
    HRESULT hr = S_OK;
    DWORD dwType, dwSize;
    HMODULE hEventFile = NULL;
    HMODULE hParamFile = NULL;
    LPTSTR lpMsg, *lpStrings, lpFullMsg;
    LPBYTE lpData;
    ULONG ulNoChars;

    ulNoChars = lstrlen(lpEventLogName) + lstrlen(lpEventSourceName) + 60;
    lpRegKey = new TCHAR [ulNoChars];

    if (!lpRegKey)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to alloc memory for key name")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

     hr = StringCchPrintf(lpRegKey, 
                          ulNoChars, 
                          TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\%s\\%s"), 
                          lpEventLogName, 
                          lpEventSourceName);
     if (FAILED(hr)) 
     {
         DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to copy registry key name")));
         goto Exit;
     }

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, lpRegKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to open reg key for %s"), lpRegKey));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    dwSize = sizeof(szEventFile);
    if (RegQueryValueEx (hKey, TEXT("EventMessageFile"), NULL, &dwType, (LPBYTE) szEventFile,
                     &dwSize) != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to query dll pathname for %s"), lpRegKey));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    ExpandEnvironmentStrings (szEventFile, szExpEventFile, ARRAYSIZE(szExpEventFile));


    dwSize = sizeof(szParamFile);
    if (RegQueryValueEx (hKey, TEXT("ParameterMessageFile"), NULL, &dwType, (LPBYTE) szParamFile,
                     &dwSize) == ERROR_SUCCESS)
    {
        ExpandEnvironmentStrings (szParamFile, szExpParamFile, ARRAYSIZE(szExpParamFile));
    }


    hEventFile = LoadLibraryEx (szExpEventFile, NULL, LOAD_LIBRARY_AS_DATAFILE);

    if (!hEventFile)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to loadlibrary dll %s with %d"), szExpEventFile, GetLastError()));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    if (szExpParamFile[0] != TEXT('\0'))
    {
        if (!StrStrI(szExpParamFile, TEXT("kernel32")))
        {
            hParamFile = LoadLibraryEx (szExpParamFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
        }
    }


    lpData = (LPBYTE)((LPBYTE)pEntry + pEntry->StringOffset);
    lpStrings = BuildStringArray((LPTSTR) lpData, pEntry->NumStrings);
    lpMsg = NULL;

    if (FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS, (LPCVOID) hEventFile,
                       pEntry->EventID, 0, (LPTSTR)&lpMsg, 1, NULL))
    {
        lpFullMsg = BuildMessage(lpMsg, lpStrings, pEntry->NumStrings, hParamFile);

        if (lpFullMsg)
        {
            AddEntry(lpEventLogName, lpEventSourceName, lpFullMsg, pEntry->EventID, ftEntry);
            LocalFree (lpFullMsg);
        }

        LocalFree (lpMsg);
    }

    if (lpStrings)
    {
        LocalFree (lpStrings);
    }

Exit:

    if (hEventFile)
    {
        FreeLibrary (hEventFile);
    }

    if (hParamFile)
    {
        FreeLibrary (hParamFile);
    }

    if (hKey)
    {
        RegCloseKey (hKey);
    }

    if (lpRegKey)
    {
        delete [] lpRegKey;
    }

    return S_OK;
}


STDMETHODIMP CEvents::ParseEventLogRecords (PEVENTLOGRECORD lpEntries,
                                            DWORD dwEntriesSize,
                                            LPTSTR lpEventLogName,
                                            LPTSTR lpEventSourceName,
                                            DWORD dwEventID,
                                            FILETIME * pBeginTime,
                                            FILETIME * pEndTime)
{
    PEVENTLOGRECORD pEntry = lpEntries;
    FILETIME ftEntry;
    LONG lResult;
    LPTSTR lpSource;
    TCHAR szCurrentTime[100];
    DWORD dwTotal = 0;


    while (dwTotal < dwEntriesSize)
    {
        if (pEntry->EventType != EVENTLOG_INFORMATION_TYPE)
        {
            SecondsSince1970ToFileTime (pEntry->TimeWritten, &ftEntry);

            lpSource = (LPTSTR)(((LPBYTE)pEntry) + sizeof(EVENTLOGRECORD));

//          DebugMsg((DM_VERBOSE, TEXT("CEvents::ParseEventLogRecords: Found %s at %s"),
//                    lpSource, ConvertTimeToDisplayTime (NULL, &ftEntry, szCurrentTime)));

            if ((CompareFileTime (&ftEntry, pBeginTime) >= 0) &&
                (CompareFileTime (&ftEntry, pEndTime) <= 0))
            {
                if (!lstrcmpi(lpSource, lpEventSourceName))
                {
                    //
                    // The dwEventID parameter is optional.  If it is non-zero, then
                    // we're looking for a specific event message.  If it is zero,
                    // consider the id to be a wildcard and grab all the events that
                    // the remaining criteria.
                    //

                    if (dwEventID)
                    {
                        if (dwEventID == pEntry->EventID)
                        {
                            SaveEventLogEntry (pEntry, lpEventLogName, lpEventSourceName, &ftEntry);
                        }
                    }
                    else
                    {
                        SaveEventLogEntry (pEntry, lpEventLogName, lpEventSourceName, &ftEntry);
                    }
                }
            }
        }

        dwTotal += pEntry->Length;
        pEntry = (PEVENTLOGRECORD)(((LPBYTE)pEntry) + pEntry->Length);
    }

    return S_OK;
}

STDMETHODIMP CEvents::QueryForEventLogEntries (LPTSTR lpComputerName,
                                               LPTSTR lpEventLogName,
                                               LPTSTR lpEventSourceName,
                                               DWORD  dwEventID,
                                               SYSTEMTIME * pBeginTime,
                                               SYSTEMTIME * pEndTime)
{
    LPTSTR lpServerName, lpTemp = lpComputerName;
    HANDLE hLog;
    ULONG ulSize;
    TCHAR szBuffer[300];
    LPBYTE lpEntries;
    DWORD  dwEntriesBufferSize = 4096;
    DWORD dwBytesRead, dwBytesNeeded;
    FILETIME ftBeginTime, ftEndTime;
    TCHAR szBeginTime[100];
    TCHAR szEndTime[100];
    HRESULT hr;
    ULONG ulNoChars;


    DebugMsg((DM_VERBOSE, TEXT("CEvents::QueryForEventLogEntries: Entering for %s,%s between %s and %s"),
              lpEventLogName, lpEventSourceName,
              ConvertTimeToDisplayTime (pBeginTime, NULL, szBeginTime, ARRAYSIZE(szBeginTime)),
              ConvertTimeToDisplayTime (pEndTime, NULL, szEndTime, ARRAYSIZE(szEndTime))));

    //
    // Check if this is the local machine
    //

    if (!lstrcmpi(lpComputerName, TEXT(".")))
    {
        ulSize = ARRAYSIZE(szBuffer);
        if ( !GetComputerNameEx (ComputerNameNetBIOS, szBuffer, &ulSize) )
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: GetComputerNameEx() failed.")));
            return HRESULT_FROM_WIN32(GetLastError());
        }
        
        lpTemp = szBuffer;
    }

    ulNoChars = lstrlen(lpTemp) + 3;
    lpServerName = new TCHAR [ulNoChars];

    if (!lpServerName)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory for server name")));
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    hr = StringCchCopy (lpServerName, ulNoChars, TEXT("\\\\"));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (lpServerName, ulNoChars, lpTemp);
    }

    if (FAILED(hr)) 
    {
        delete [] lpServerName;
        return hr;
    }

    //
    // Open the event log
    //

    hLog = OpenEventLog (lpServerName, lpEventLogName);

    if (!hLog)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to open event log on %s with %d"),
                  lpServerName, GetLastError()));
    }
    
    delete [] lpServerName;

    if (!hLog)
        return HRESULT_FROM_WIN32(GetLastError());

    //
    // Allocate a buffer to read the entries into
    //

    lpEntries = (LPBYTE) LocalAlloc (LPTR, dwEntriesBufferSize);

    if (!lpEntries)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory for server name")));
        CloseEventLog (hLog);
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    SystemTimeToFileTime (pBeginTime, &ftBeginTime);
    SystemTimeToFileTime (pEndTime, &ftEndTime);

    while (TRUE)
    {
        ZeroMemory (lpEntries, dwEntriesBufferSize);

        if (ReadEventLog (hLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ, 0, lpEntries, dwEntriesBufferSize,
                           &dwBytesRead, &dwBytesNeeded))
        {
            ParseEventLogRecords ((PEVENTLOGRECORD) lpEntries, dwBytesRead, lpEventLogName, lpEventSourceName, dwEventID, &ftBeginTime, &ftEndTime);
        }
        else
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                dwEntriesBufferSize = dwBytesNeeded;

                LocalFree (lpEntries);

                lpEntries = (LPBYTE) LocalAlloc (LPTR, dwEntriesBufferSize);

                if (!lpEntries)
                {
                    DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory")));
                    CloseEventLog (hLog);
                    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else
            {
                break;
            }
        }
    }


    LocalFree (lpEntries);

    CloseEventLog (hLog);

    DebugMsg((DM_VERBOSE, TEXT("CEvents::QueryForEventLogEntries: Leaving ===")));

    return S_OK;
}

STDMETHODIMP CEvents::GetEventLogEntryText (LPOLESTR pszEventSource,
                                            LPOLESTR pszEventLogName,
                                            LPOLESTR pszEventTime,
                                            DWORD dwEventID,
                                            LPOLESTR *ppszText)
{
    XBStr xbstrWbemTime = pszEventTime;
    SYSTEMTIME EventTime;
    FILETIME ftLower, ftUpper;
    ULARGE_INTEGER ulTime;
    LPEVENTLOGENTRY lpTemp;
    LPOLESTR lpMsg = NULL, lpTempMsg;
    ULONG ulSize;
    TCHAR szLowerTime[100];
    TCHAR szUpperTime[100];
    HRESULT hr;

    if (!ppszText)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }


    WbemTimeToSystemTime(xbstrWbemTime, EventTime);


    //
    // Subtrack 1 second to EventTime to get the lower end of the range
    //

    SystemTimeToFileTime (&EventTime, &ftLower);


    ulTime.LowPart = ftLower.dwLowDateTime;
    ulTime.HighPart = ftLower.dwHighDateTime;

    ulTime.QuadPart = ulTime.QuadPart - (10000000 * 1);  // 1 second

    ftLower.dwLowDateTime = ulTime.LowPart;
    ftLower.dwHighDateTime = ulTime.HighPart;


    //
    // Add 2 seconds to determine the upper bounds
    //

    ulTime.QuadPart = ulTime.QuadPart + (10000000 * 2);  // 2 second

    ftUpper.dwLowDateTime = ulTime.LowPart;
    ftUpper.dwHighDateTime = ulTime.HighPart;


    DebugMsg((DM_VERBOSE, TEXT("CEvents::GetEventLogEntryText: Entering for %s,%s,%d between %s and %s"),
              pszEventLogName, pszEventSource, dwEventID,
              ConvertTimeToDisplayTime (NULL, &ftLower, szLowerTime, ARRAYSIZE(szLowerTime)),
              ConvertTimeToDisplayTime (NULL, &ftUpper, szUpperTime, ARRAYSIZE(szUpperTime))));

    //
    // Loop through the entries looking for matches
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if (lpTemp->dwEventID == dwEventID)
        {
            if (!lstrcmpi(lpTemp->lpEventLogName, pszEventLogName))
            {
                if (!lstrcmpi(lpTemp->lpEventSourceName, pszEventSource))
                {
                    if ((CompareFileTime (&lpTemp->ftEventTime, &ftLower) >= 0) &&
                        (CompareFileTime (&lpTemp->ftEventTime, &ftUpper) <= 0))
                    {
                        if (lpMsg)
                        {
                            ulSize = lstrlen(lpMsg);
                            ulSize += lstrlen(lpTemp->lpText) + 3;

                            lpTempMsg = (LPOLESTR) CoTaskMemRealloc (lpMsg, ulSize * sizeof(TCHAR));

                            if (!lpTempMsg)
                            {
                                CoTaskMemFree (lpMsg);
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            }

                            lpMsg = lpTempMsg;

                            hr = StringCchCat (lpMsg, ulSize, TEXT("\r\n"));
                            if (SUCCEEDED(hr)) 
                            {
                                hr = StringCchCat (lpMsg, ulSize, lpTemp->lpText);
                            }

                            if (FAILED(hr)) 
                            {
                                CoTaskMemFree (lpMsg);
                                return hr;
                            }
                        }
                        else
                        {
                            ulSize = lstrlen(lpTemp->lpText) + 1;
                            lpMsg = (LPOLESTR) CoTaskMemAlloc (ulSize * sizeof(TCHAR));

                            if (!lpMsg)
                            {
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            }

                            hr = StringCchCopy (lpMsg, ulSize, lpTemp->lpText);
                            if (FAILED(hr)) 
                            {
                                CoTaskMemFree(lpMsg);
                                return hr;
                            }
                        }
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    if (!lpMsg)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    *ppszText = lpMsg;

    return S_OK;
}

BOOL CEvents::IsEntryInEventSourceList (LPEVENTLOGENTRY lpEntry, LPSOURCEENTRY lpEventSources)
{
    LPSOURCEENTRY lpTemp;


    if (!lpEventSources)
    {
        return FALSE;
    }

    lpTemp = lpEventSources;

    while (lpTemp)
    {
        if (!lstrcmpi(lpTemp->lpEventLogName, lpEntry->lpEventLogName))
        {
            if (!lstrcmpi(lpTemp->lpEventSourceName, lpEntry->lpEventSourceName))
            {
                return TRUE;
            }
        }

        lpTemp = lpTemp->pNext;
    }

    return FALSE;
}

BOOL CEvents::IsEntryInExceptionList (LPEVENTLOGENTRY lpEntry)
{
    LPEVENTLOGENTRY lpTemp;
    DWORD           i;

    for (i = 0; i < dwExceptionEventEntriesSize; i++) {
        lpTemp = ExceptionEventEntries+i;
        if (!lstrcmpi(lpTemp->lpEventLogName, lpEntry->lpEventLogName))
        {
            if (!lstrcmpi(lpTemp->lpEventSourceName, lpEntry->lpEventSourceName))
            {
                if (LOWORD(lpTemp->dwEventID) == LOWORD(lpEntry->dwEventID)) {
                    DebugMsg((DM_VERBOSE, TEXT("Skipping event id")));
                    DebugMsg((DM_VERBOSE, TEXT("Event Log:    %s"), lpEntry->lpEventLogName));
                    DebugMsg((DM_VERBOSE, TEXT("Event Source: %s"), lpEntry->lpEventSourceName));
                    DebugMsg((DM_VERBOSE, TEXT("Event ID:     %d"), LOWORD(lpEntry->dwEventID)));

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

STDMETHODIMP CEvents::GetCSEEntries(SYSTEMTIME * pBeginTime, SYSTEMTIME * pEndTime,
                                    LPSOURCEENTRY lpEventSources, LPOLESTR *ppszText, 
                                    BOOL bGPCore)
{
    LPEVENTLOGENTRY lpTemp;
    FILETIME ftBeginTime, ftEndTime;
    LPOLESTR lpMsg = NULL, lpTempMsg;
    ULONG ulSize;
    HRESULT hr;


    SystemTimeToFileTime (pBeginTime, &ftBeginTime);
    SystemTimeToFileTime (pEndTime, &ftEndTime);


    //
    // Loop through the entries looking for matches
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if ((CompareFileTime (&lpTemp->ftEventTime, &ftBeginTime) >= 0) &&
            (CompareFileTime (&lpTemp->ftEventTime, &ftEndTime) <= 0))
        {
            if (IsEntryInEventSourceList (lpTemp, lpEventSources))
            {
                if ((bGPCore) || (!IsEntryInExceptionList(lpTemp))) {
                    if (lpMsg)
                    {
                        ulSize = lstrlen(lpMsg);
                        ulSize += lstrlen(lpTemp->lpText) + 3;

                        lpTempMsg = (LPOLESTR) CoTaskMemRealloc (lpMsg, ulSize * sizeof(TCHAR));

                        if (!lpTempMsg)
                        {
                            CoTaskMemFree (lpMsg);
                            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }

                        lpMsg = lpTempMsg;

                        hr = StringCchCat (lpMsg, ulSize, TEXT("\r\n"));
                        if (SUCCEEDED(hr)) 
                        {
                            hr = StringCchCat (lpMsg, ulSize, lpTemp->lpText);
                        }

                        if (FAILED(hr)) 
                        {
                            CoTaskMemFree(lpMsg);
                            return hr;
                        }
                    }
                    else
                    {
                        ulSize = lstrlen(lpTemp->lpText) + 1;
                        lpMsg = (LPOLESTR) CoTaskMemAlloc (ulSize * sizeof(TCHAR));

                        if (!lpMsg)
                        {
                            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }

                        hr = StringCchCopy (lpMsg, ulSize, lpTemp->lpText);
                        if (FAILED(hr)) 
                        {
                            CoTaskMemFree (lpMsg);
                            return hr;
                        }
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }

    if (!lpMsg)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    *ppszText = lpMsg;

    return S_OK;
}

STDMETHODIMP CEvents::DumpDebugInfo (void)
{
    LPEVENTLOGENTRY lpTemp;
    FILETIME ftLocal;
    SYSTEMTIME systime;
    TCHAR szDateTime[100];


    lpTemp = m_pEventEntries;

    if (lpTemp)
    {
        DebugMsg((DM_VERBOSE, TEXT(" ")));
        DebugMsg((DM_VERBOSE, TEXT("Event log entries:")));
    }

    while (lpTemp)
    {
        ConvertTimeToDisplayTime (NULL, &lpTemp->ftEventTime, szDateTime, ARRAYSIZE(szDateTime));

        DebugMsg((DM_VERBOSE, TEXT(" ")));
        DebugMsg((DM_VERBOSE, TEXT("Event Time:   %s"), szDateTime));
        DebugMsg((DM_VERBOSE, TEXT("Event Log:    %s"), lpTemp->lpEventLogName));
        DebugMsg((DM_VERBOSE, TEXT("Event Source: %s"), lpTemp->lpEventSourceName));
        DebugMsg((DM_VERBOSE, TEXT("Event ID:     %d"), LOWORD(lpTemp->dwEventID)));
        DebugMsg((DM_VERBOSE, TEXT("Message:      %s"), lpTemp->lpText));

        lpTemp = lpTemp->pNext;
    }


    return S_OK;
}

LPTSTR CEvents::ConvertTimeToDisplayTime (SYSTEMTIME *pSysTime, 
                                          FILETIME *pFileTime, 
                                          LPTSTR szBuffer, 
                                          ULONG ulNoChars)
{
    FILETIME ftTime, ftLocal;
    SYSTEMTIME systime;

    if (pSysTime)
    {
        SystemTimeToFileTime (pSysTime, &ftTime);
    }
    else if ( pFileTime )
    {
        CopyMemory (&ftTime, pFileTime, sizeof(FILETIME));
    }
    else
    {
        //
        // No time was specified, so just return an empty string
        // in the buffer
        //
        if ( ulNoChars > 0 )
        {
            *szBuffer = L'\0';
        }

        return szBuffer;
    }

    FileTimeToLocalFileTime (&ftTime, &ftLocal);

    FileTimeToSystemTime (&ftLocal, &systime);

    (void) StringCchPrintf (szBuffer, 
                            ulNoChars, 
                            TEXT("%d/%d/%d  %02d:%02d:%02d:%03d"), 
                            systime.wMonth, 
                            systime.wDay, 
                            systime.wYear,
                            systime.wHour, 
                            systime.wMinute, 
                            systime.wSecond, 
                            systime.wMilliseconds);
    return szBuffer;
}

STDMETHODIMP CEvents::AddSourceEntry (LPTSTR lpEventLogName,
                                      LPTSTR lpEventSourceName,
                                      LPSOURCEENTRY *lpList)
{
    LPSOURCEENTRY lpItem;
    DWORD dwSize;
    ULONG ulNoChars;
    HRESULT hr;

    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (SOURCEENTRY);

    dwSize += ((lstrlen(lpEventLogName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpEventSourceName) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPSOURCEENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddSourceEntry: Failed to allocate memory with %d"),
                 GetLastError()));
        return E_FAIL;
    }


    //
    // Fill in item
    //

    ulNoChars = (dwSize - sizeof(SOURCEENTRY))/sizeof(WCHAR);
    lpItem->lpEventLogName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(SOURCEENTRY));
    hr = StringCchCopy (lpItem->lpEventLogName, ulNoChars, lpEventLogName);
    if (SUCCEEDED(hr)) 
    {
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpEventLogName) + 1);
        lpItem->lpEventSourceName = lpItem->lpEventLogName + lstrlen (lpItem->lpEventLogName) + 1;
        hr = StringCchCopy (lpItem->lpEventSourceName, ulNoChars, lpEventSourceName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddSourceEntry: Failed to copy event log name with %d"), hr));
        LocalFree(lpItem);
        return hr;
    }
    
    //
    // Add it to the list
    //

    if (*lpList)
    {
        lpItem->pNext = *lpList;
    }

    *lpList = lpItem;

    return S_OK;
}

VOID CEvents::FreeSourceData(LPSOURCEENTRY lpList)
{
    LPSOURCEENTRY lpTemp;


    if (lpList)
    {
        do {
            lpTemp = lpList->pNext;
            LocalFree (lpList);
            lpList = lpTemp;

        } while (lpTemp);
    }
}

STDMETHODIMP CEvents::SaveEntriesToStream (IStream *pStm)
{
    HRESULT hr;
    DWORD dwCount = 0;
    LPEVENTLOGENTRY lpTemp;
    ULONG nBytesWritten;



    //
    // First count how many entries are in the link list
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        dwCount++;
        lpTemp = lpTemp->pNext;
    }


    //
    // Save the count to the stream
    //

    hr = pStm->Write(&dwCount, sizeof(dwCount), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwCount)))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write entry count with %d."), hr));
        hr = E_FAIL;
        goto Exit;
    }



    //
    // Now loop through each item saving each field in the node
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {

        //
        // Save the event id
        //

        hr = pStm->Write(&lpTemp->dwEventID, sizeof(DWORD), &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != sizeof(DWORD)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write event id with %d."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Save the event time
        //

        hr = pStm->Write(&lpTemp->ftEventTime, sizeof(FILETIME), &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != sizeof(FILETIME)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write file time with %d."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Save the event log name
        //

        hr = SaveString (pStm, lpTemp->lpEventLogName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event log name with %d."), hr));
            goto Exit;
        }


        //
        // Save the event source name
        //

        hr = SaveString (pStm, lpTemp->lpEventSourceName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event source name with %d."), hr));
            goto Exit;
        }


        //
        // Save the event text
        //

        hr = SaveString (pStm, lpTemp->lpText);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event text with %d."), hr));
            goto Exit;
        }


        lpTemp = lpTemp->pNext;
    }

Exit:

    return hr;
}

STDMETHODIMP CEvents::LoadEntriesFromStream (IStream *pStm)
{
    HRESULT hr;
    DWORD dwCount = 0, dwIndex, dwEventID;
    LPEVENTLOGENTRY lpTemp;
    ULONG nBytesRead;
    FILETIME ftEventTime;
    LPTSTR lpEventLogName = NULL;
    LPTSTR lpEventSourceName = NULL;
    LPTSTR lpText = NULL;


    //
    // Read in the entry count
    //

    hr = pStm->Read(&dwCount, sizeof(dwCount), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwCount)))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event count with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Loop through the items
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {

        //
        // Read in the event id
        //

        hr = pStm->Read(&dwEventID, sizeof(dwEventID), &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != sizeof(dwEventID)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event id with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Read in the event time
        //

        hr = pStm->Read(&ftEventTime, sizeof(FILETIME), &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != sizeof(FILETIME)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event time with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Read the event log name
        //

        hr = ReadString (pStm, &lpEventLogName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event log name with 0x%x."), hr));
            goto Exit;
        }


        //
        // Read the event source name
        //

        hr = ReadString (pStm, &lpEventSourceName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event source name with 0x%x."), hr));
            goto Exit;
        }


        //
        // Read the event text
        //

        hr = ReadString (pStm, &lpText);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event text with 0x%x."), hr));
            goto Exit;
        }


        //
        // Add this entry to the link list
        //

        if (!AddEntry (lpEventLogName, lpEventSourceName, lpText, dwEventID, &ftEventTime))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to add the entry.")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Clean up for next item
        //

        delete [] lpEventLogName;
        lpEventLogName = NULL;

        delete [] lpEventSourceName;
        lpEventSourceName = NULL;

        delete [] lpText;
        lpText = NULL;
    }


Exit:

    if (lpEventLogName)
    {
        delete [] lpEventLogName;
    }

    if (lpEventSourceName)
    {
        delete [] lpEventSourceName;
    }

    if (lpText)
    {
        delete [] lpText;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\gpmgr.cpp ===
//*************************************************************
//  File name: GPMGR.C
//
//  Description:  Group Policy Manager - property sheet extension
//                for DS Admin
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "main.h"

unsigned int CGroupPolicyMgr::m_cfDSObjectName  = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
unsigned int CGroupPolicyMgr::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);

//
// Snapin manager's CLSID
//

const CLSID CLSID_NodeInit = {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


//
// CheckMark string
//

TCHAR szCheckMark[]   = TEXT("a");  // In the Marlett font, "a" becomes a check mark
TCHAR szNoCheckMark[] = TEXT("");


//
// Help ids
//

DWORD aGroupPolicyMgrHelpIds[] =
{
    IDC_GPM_DCNAME,               IDH_GPMGR_DCNAME,
    IDC_GPM_LIST,                 IDH_GPMGR_LIST,
    IDC_GPM_UP,                   IDH_GPMGR_UP,
    IDC_GPM_DOWN,                 IDH_GPMGR_DOWN,
    IDC_GPM_ADD,                  IDH_GPMGR_ADD,
    IDC_GPM_EDIT,                 IDH_GPMGR_EDIT,
    IDC_GPM_DELETE,               IDH_GPMGR_DELETE,
    IDC_GPM_PROPERTIES,           IDH_GPMGR_PROPERTIES,
    IDC_GPM_BLOCK,                IDH_GPMGR_BLOCK,
    IDC_GPM_NEW,                  IDH_GPMGR_NEW,
    IDC_GPM_OPTIONS,              IDH_GPMGR_OPTIONS,

    IDC_GPM_TITLE,                -1,
    IDC_GPM_ICON,                 -1,
    IDC_GPM_LINE1,                -1,
    IDC_GPM_PRIORITY,             -1,
    IDC_GPM_LINE2,                -1,

    0, 0
};

DWORD aLinkOptionsHelpIds[] =
{
    IDC_GPM_NOOVERRIDE,           IDH_GPMGR_NOOVERRIDE,
    IDC_GPM_DISABLED,             IDH_GPMGR_DISABLED,
    0, 0
};

DWORD aRemoveGPOHelpIds[] =
{
    IDC_REMOVE_LIST,              IDH_REMOVE_LIST,
    IDC_REMOVE_DS,                IDH_REMOVE_DS,
    0, 0
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyMgr::CGroupPolicyMgr()
{
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;

    m_lpDSObject = NULL;
    m_lpGPODCName = NULL;
    m_lpDSADCName = NULL;
    m_lpDomainName = NULL;
    m_hDefaultFont = NULL;
    m_hMarlettFont = NULL;
    m_bReadOnly = FALSE;
    m_bDirty = FALSE;
    m_gpHint = GPHintUnknown;
}

CGroupPolicyMgr::~CGroupPolicyMgr()
{
    if (m_hMarlettFont)
    {
        DeleteObject (m_hMarlettFont);
    }

    if (m_lpDSObject)
    {
        LocalFree (m_lpDSObject);
    }

    if (m_lpGPODCName)
    {
        LocalFree (m_lpGPODCName);
    }

    if (m_lpDSADCName)
    {
        LocalFree (m_lpDSADCName);
    }

    if (m_lpDomainName)
    {
        LocalFree (m_lpDomainName);
    }


    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CGroupPolicyMgr::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CGroupPolicyMgr::AddRef (void)
{
    return ++m_cRef;
}

ULONG CGroupPolicyMgr::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (ISnapinHelp)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyMgr::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (IExtendPropertySheet)              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyMgr::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    FORMATETC fm;
    STGMEDIUM medium;
    LPDSOBJECTNAMES lpNames;
    LPTSTR lpTemp;


    //
    // Ask DS admin for the ldap path to the selected object
    //

    ZeroMemory (&fm, sizeof(fm));
    fm.cfFormat = (WORD)m_cfDSObjectName;
    fm.tymed = TYMED_HGLOBAL;

    ZeroMemory (&medium, sizeof(medium));
    medium.tymed = TYMED_HGLOBAL;

    medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_NODISCARD, 512);

    if (medium.hGlobal)
    {
        hr = lpDataObject->GetData(&fm, &medium);

        if (SUCCEEDED(hr))
        {
            lpNames = (LPDSOBJECTNAMES) GlobalLock (medium.hGlobal);


            lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetName);

            if (m_lpDSObject)
            {
                LocalFree (m_lpDSObject);
            }

            ULONG ulNoChars = lstrlen (lpTemp) + 1;

            m_lpDSObject = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

            if (m_lpDSObject)
            {
                hr = StringCchCopy (m_lpDSObject, ulNoChars, lpTemp);
                ASSERT(SUCCEEDED(hr));

                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: LDAP path from DS Admin %s"), m_lpDSObject));

                //
                // Now look at the object type to get a hint type
                //

                m_gpHint = GPHintUnknown;

                if (lpNames->aObjects[0].offsetClass) {
                    lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetClass);

                    if (CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("domainDNS"), -1) == CSTR_EQUAL)
                    {
                        m_gpHint = GPHintDomain;
                    }
                    else if (CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("organizationalUnit"), -1) == CSTR_EQUAL)
                    {
                        m_gpHint = GPHintOrganizationalUnit;
                    }
                    else if (CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("site"), -1) == CSTR_EQUAL)
                    {
                        m_gpHint = GPHintSite;
                    }

                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: m_gpHint = %d"), m_gpHint));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: No objectclass defined.")));
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            GlobalUnlock (medium.hGlobal);
        }

        GlobalFree (medium.hGlobal);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Add the GPM property sheet page
    //

    if (SUCCEEDED(hr))
    {
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_USECALLBACK;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE (IDD_GPMANAGER);
        psp.pfnDlgProc = GPMDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pfnCallback = PropSheetPageCallback;

        hPage = CreatePropertySheetPage(&psp);

        if (hPage)
        {
            hr = lpProvider->AddPage(hPage);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            hr = E_FAIL;
        }
    }

    return (hr);
}

STDMETHODIMP CGroupPolicyMgr::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

UINT CALLBACK CGroupPolicyMgr::PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CGroupPolicyMgr * pGPM;

    pGPM = (CGroupPolicyMgr *) ppsp->lParam;

    if (uMsg == PSPCB_ADDREF)
    {
        pGPM->AddRef();
    }
    else if (uMsg == PSPCB_RELEASE)
    {
        pGPM->Release();
    }

    return 1;
}

INT_PTR CALLBACK CGroupPolicyMgr::GPMDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyMgr * pGPM;
    static BOOL bDisableWarningIssued;

    switch (message)
    {
        case WM_INITDIALOG:
            pGPM = (CGroupPolicyMgr *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPM);

            SetWaitCursor();
            bDisableWarningIssued = FALSE;

            EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);

            if (!pGPM->OnInitDialog(hDlg))
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_LIST), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_NEW), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_ADD), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

            if (pGPM->m_bReadOnly)
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_NEW), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_ADD), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

#if FGPO_SUPPORT
            if (pGPM->m_gpHint == GPHintForest)
#else
            if (pGPM->m_gpHint == GPHintSite)
#endif
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

            ClearWaitCursor();
            break;

        case WM_COMMAND:
            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPM) {
                break;
            }

            if ((LOWORD(wParam) == IDC_GPM_ADD) || (LOWORD(wParam) == IDM_GPM_ADD))
            {
                TCHAR szPath[512];
                TCHAR szName[MAX_FRIENDLYNAME];
                TCHAR szTitle[100];
                LPTSTR lpNamelessPath;
                GPOBROWSEINFO stGBI;
                IADs * pADs;
                HRESULT hr;
                BOOL bReadOnly = FALSE;

                LoadString (g_hInstance, IDS_GPM_ADDTITLE, szTitle, ARRAYSIZE(szTitle));

                ZeroMemory(&stGBI, sizeof(GPOBROWSEINFO));
                stGBI.dwSize = sizeof(GPOBROWSEINFO);
                stGBI.dwFlags = GPO_BROWSE_NOCOMPUTERS | GPO_BROWSE_DISABLENEW;
                stGBI.hwndOwner = hDlg;
                stGBI.lpTitle = szTitle;
                stGBI.lpInitialOU = pGPM->m_lpDSObject;
                stGBI.lpDSPath = szPath;
                stGBI.dwDSPathSize = ARRAYSIZE(szPath);
                stGBI.lpName = szName;
                stGBI.dwNameSize = ARRAYSIZE(szName);

                if (SUCCEEDED(BrowseForGPO(&stGBI)))
                {

                    //
                    // Check if the user has write access to the select GPO
                    //

                    lpNamelessPath = MakeNamelessPath (szPath);

                    if (lpNamelessPath)
                    {
                        hr = OpenDSObject(szPath, IID_IADs, (void **)&pADs);

                        if (SUCCEEDED(hr)) {

                            if (FAILED(CheckDSWriteAccess((LPUNKNOWN) pADs, GPO_VERSION_PROPERTY)))
                            {
                                bReadOnly = TRUE;
                            }

                            pADs->Release();
                        }

                        //
                        // Read the policy value for the GPO link
                        //

                        HKEY hKey;
                        DWORD dwSize, dwType;
                        BOOL bDisabledLink = FALSE;


                        //
                        // Check if there is a user preference or policy that
                        // any new GPOs should be created with a disabled link
                        // by default
                        //

                        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                                          KEY_READ, &hKey) == ERROR_SUCCESS)
                        {

                            dwSize = sizeof(bDisabledLink);
                            RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                                             (LPBYTE) &bDisabledLink, &dwSize);

                            RegCloseKey (hKey);
                        }

                        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                                          KEY_READ, &hKey) == ERROR_SUCCESS)
                        {

                            dwSize = sizeof(bDisabledLink);
                            RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                                             (LPBYTE) &bDisabledLink, &dwSize);

                            RegCloseKey (hKey);
                        }


                        if (pGPM->AddGPOToList (GetDlgItem(hDlg, IDC_GPM_LIST),
                                                szName, lpNamelessPath, (bDisabledLink ? GPO_FLAG_DISABLE : 0), FALSE,
                                                pGPM->IsGPODisabled (lpNamelessPath), bReadOnly))
                        {
                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                            SetFocus (GetDlgItem(hDlg, IDC_GPM_LIST));
                            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                        }

                        LocalFree (lpNamelessPath);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_DELETE) || (LOWORD(wParam) == IDM_GPM_DELETE))
            {
                INT iIndex, iNext;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    HRESULT hr;
                    LPGPOITEM lpGPO, lpTemp;
                    LPGROUPPOLICYOBJECT pGPO;
                    TCHAR szMessageFmt[100];
                    LPTSTR lpMessage;
                    TCHAR szTitle[100];
                    INT iResult;
                    LPTSTR lpDSPath;
                    LPTSTR lpFullPath;


                    //
                    // The GPO item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpGPO = (LPGPOITEM) item.lParam;
                    if ( !lpGPO )
                    {
                        break;
                    }

                    lpGPO->bLocked = TRUE;

                    //
                    // Offer the user a choice of Remove actions
                    //

                    
                    iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_REMOVE_GPO),
                                        hDlg, RemoveGPODlgProc, (LPARAM) lpGPO);

                    if ((iResult == -1) || (iResult == 0))
                    {
                        SetFocus (hLV);
                        lpGPO->bLocked = FALSE;
                        break;
                    }

                    iNext = ListView_GetNextItem (hLV, iIndex, LVNI_ALL);

                    if (iNext > 0)
                    {
                        iNext--;
                    }
                    else
                    {
                        iNext = 0;
                    }
                    if (iResult == 1)
                    {
                        IADs * pADs;

                        //
                        // Bind to the DS object to make sure it's still reachable
                        //

                        hr = OpenDSObject(pGPM->m_lpDSObject, IID_IADs, (void **)&pADs);

                        if (SUCCEEDED(hr))
                        {
                            pADs->Release();
                            ListView_DeleteItem (hLV, iIndex);
                            lpGPO = NULL;
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to get IADs interface with 0x%x"), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPINFO);
                            lpGPO->bLocked = FALSE;
                            break;
                        }
                    }
                    else if (iResult == 2)
                    {
                        //
                        // Confirm the delete operation
                        //

                        LoadString (g_hInstance, IDS_DELETECONFIRM, szMessageFmt, ARRAYSIZE(szMessageFmt));

                        ULONG ulNoChars;

                        ulNoChars = lstrlen(szMessageFmt) + lstrlen(lpGPO->lpDisplayName) + 1;                        
                        lpMessage = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                        if (lpMessage) 
                        {
                            hr = StringCchPrintf (lpMessage, ulNoChars, szMessageFmt, lpGPO->lpDisplayName);
                            if (FAILED(hr)) 
                            {
                                LocalFree(lpMessage);
                                lpMessage = NULL;
                            }
                        }

                        if (!lpMessage)
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to allocate memory with %d."),
                                     GetLastError()));
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        LoadString (g_hInstance, IDS_CONFIRMTITLE, szTitle, ARRAYSIZE(szTitle));

                        if (MessageBox (hDlg, lpMessage, szTitle,
                                        MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                        {
                            LocalFree (lpMessage);
                            SetFocus (hLV);
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        LocalFree (lpMessage);
                        SetWaitCursor ();

                        ulNoChars = lstrlen(lpGPO->lpDSPath) + 1;
                        lpDSPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                        if (!lpDSPath)
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to allocate memory with %d."),
                                     GetLastError()));
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        hr = StringCchCopy (lpDSPath, ulNoChars, lpGPO->lpDSPath);
                        ASSERT(SUCCEEDED(hr));

                        //
                        // Create a new GPO object to work with
                        //

                        hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                               CLSCTX_SERVER, IID_IGroupPolicyObject,
                                               (void**)&pGPO);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to create GPO object with 0x%x."), hr));
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        lpFullPath = pGPM->GetFullGPOPath (lpGPO->lpDSPath, hDlg);

                        if (!lpFullPath)
                        {
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        //
                        // Open the requested object without mounting the registry
                        //

                        hr = pGPO->OpenDSGPO(lpFullPath, 0);

                        LocalFree (lpFullPath);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to open GPO object with 0x%x."), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPODELETE, lpGPO->lpDisplayName);
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        //
                        // Delete the object
                        //

                        hr = pGPO->Delete();

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to delete GPO object with 0x%x."), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPODELETE, lpGPO->lpDisplayName);
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        pGPO->Release();

                        //
                        // Delete all the entries of this item in the listview
                        //

                        iIndex = (ListView_GetItemCount (hLV) - 1);
                        while (iIndex >= 0)
                        {
                            item.mask = LVIF_PARAM;
                            item.iItem = iIndex;
                            item.iSubItem = 0;

                            if (!ListView_GetItem (hLV, &item))
                            {
                                lpGPO->bLocked = FALSE;
                                break;
                            }

                            lpTemp = (LPGPOITEM) item.lParam;

                            if (lpTemp)
                            {
                                if (!lstrcmpi(lpTemp->lpDSPath, lpDSPath))
                                {
                                    if (iNext == iIndex)
                                    {
                                        iNext--;
                                    }
                                    ListView_DeleteItem (hLV, iIndex);
                                    lpGPO = NULL;
                                }
                            }

                            iIndex--;
                        }

                        LocalFree (lpDSPath);

                        ClearWaitCursor ();
                    }

                    if (iNext < 0)
                    {
                        iNext = 0;
                    }


                    //
                    // Select the next item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iNext;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;


                    SendMessage (hLV, LVM_SETITEMSTATE, iNext, (LPARAM) &item);


                    pGPM->m_bDirty = TRUE;

                    if (!pGPM->Save(hDlg))
                    {
                        pGPM->RefreshGPM (hDlg, FALSE);
                    }

                    SendMessage (GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                    SetFocus (hLV);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
            }

            if (LOWORD(wParam) == IDC_GPM_UP)
            {
                INT iSrc, iDest, iSrcImage, iDestImage;
                LPGPOITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;

                ListView_EditLabel (hLV, -1);

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc - 1;

                    //
                    // Get the current lpGPOItem pointers
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPGPOITEM) item.lParam;
                    iSrcImage = item.iImage;


                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPGPOITEM) item.lParam;
                    iDestImage = item.iImage;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iImage = iDestImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iImage = iSrcImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);
                    SendMessage (hLV, LVM_ENSUREVISIBLE, iDest, (LPARAM) FALSE);

                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iDest, iSrc);

                    pGPM->m_bDirty = TRUE;
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);

                    SetFocus (hLV);
                }
            }


            if (LOWORD(wParam) == IDC_GPM_DOWN)
            {
                INT iSrc, iDest, iSrcImage, iDestImage;
                LPGPOITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;

                ListView_EditLabel (hLV, -1);

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc + 1;

                    //
                    // Get the current lpGPOItem pointers
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPGPOITEM) item.lParam;
                    iSrcImage = item.iImage;

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPGPOITEM) item.lParam;
                    iDestImage = item.iImage;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iImage = iDestImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iImage = iSrcImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);
                    SendMessage (hLV, LVM_ENSUREVISIBLE, iDest, (LPARAM) FALSE);

                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iSrc, iDest);

                    pGPM->m_bDirty = TRUE;
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);


                    SetFocus (hLV);
                }
            }

            if (LOWORD(wParam) == IDM_GPM_NOOVERRIDE)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;

                        if (lpItem->dwOptions & GPO_FLAG_FORCE)
                            lpItem->dwOptions &= ~GPO_FLAG_FORCE;
                        else
                            lpItem->dwOptions |= GPO_FLAG_FORCE;

                        ListView_RedrawItems (hLV, iIndex, iIndex);
                        UpdateWindow (hLV);

                        pGPM->m_bDirty = TRUE;
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (hLV);
                        lpItem->bLocked = FALSE;
                    }
                }
            }

            if (LOWORD(wParam) == IDM_GPM_DISABLED)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        if (lpItem->dwOptions & GPO_FLAG_DISABLE)
                            lpItem->dwOptions &= ~GPO_FLAG_DISABLE;
                        else
                        {
                            if (bDisableWarningIssued)
                            {
                                lpItem->dwOptions |= GPO_FLAG_DISABLE;
                            }
                            else
                            {
                                TCHAR szMessage[200];
                                TCHAR szTitle[100];

                                bDisableWarningIssued = TRUE;

                                LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                                LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                                if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                            MB_ICONWARNING | MB_DEFBUTTON2) == IDYES) {

                                    lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                }
                            }
                        }

                        ListView_RedrawItems (hLV, iIndex, iIndex);
                        UpdateWindow (hLV);

                        pGPM->m_bDirty = TRUE;
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (hLV);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_EDIT) || (LOWORD(wParam) == IDM_GPM_EDIT))
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;
                        pGPM->StartGPE (lpItem->lpDSPath, hDlg);
                        lpItem->bLocked = FALSE;
                        SetFocus (hLV);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_NEW) || (LOWORD(wParam) == IDM_GPM_NEW))
            {
                SetWaitCursor();
                pGPM->OnNew (hDlg);
                ClearWaitCursor();
            }

            if (LOWORD(wParam) == IDC_GPM_OPTIONS)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;

                        if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_GPM_LINK_OPTIONS),
                                            hDlg, LinkOptionsDlgProc, (LPARAM) lpItem))
                        {
                            ListView_RedrawItems (hLV, iIndex, iIndex);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }

                        lpItem->bLocked = FALSE;
                        SetFocus (hLV);
                    }
                }
            }


            if (LOWORD(wParam) == IDM_GPM_RENAME)
            {
                INT iIndex;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);

                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    ListView_EditLabel (hLV, iIndex);
                }
            }


            if ((LOWORD(wParam) == IDC_GPM_PROPERTIES) || (LOWORD(wParam) == IDM_GPM_PROPERTIES))
            {
                pGPM->OnProperties (hDlg);
            }

            if (LOWORD(wParam) == IDM_GPM_REFRESH)
            {
                pGPM->RefreshGPM (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_GPM_BLOCK)
            {
                pGPM->m_bDirty = TRUE;
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
            }

            break;

        case WM_NOTIFY:

            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPM) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case NM_CUSTOMDRAW:
                {
                    LPNMLVCUSTOMDRAW  lplvcd = (LPNMLVCUSTOMDRAW)lParam;

                    SelectObject(lplvcd->nmcd.hdc, pGPM->m_hDefaultFont);

                    if ((lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT) ||
                        (lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_NOTIFYSUBITEMDRAW);
                        return TRUE;
                    }

                    if ((lplvcd->nmcd.dwDrawStage == (CDDS_SUBITEM | CDDS_ITEMPREPAINT)) &&
                        (lplvcd->iSubItem > 0))
                    {
                        SelectObject(lplvcd->nmcd.hdc, pGPM->m_hMarlettFont);
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                        return TRUE;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }


                case LVN_GETDISPINFO:
                    {
                        NMLVDISPINFO * lpDispInfo = (NMLVDISPINFO *) lParam;
                        LPGPOITEM lpItem = (LPGPOITEM)lpDispInfo->item.lParam;

                        if (lpDispInfo->item.iSubItem == 0)
                        {
                            lpDispInfo->item.pszText = lpItem->lpDisplayName;
                        }
                        else
                        {
                            lpDispInfo->item.pszText = szNoCheckMark;

                            if ((lpDispInfo->item.iSubItem == 1) &&
                                (lpItem->dwOptions & GPO_FLAG_FORCE))
                            {
                                lpDispInfo->item.pszText = szCheckMark;
                            }

                            if ((lpDispInfo->item.iSubItem == 2) &&
                                (lpItem->dwOptions & GPO_FLAG_DISABLE))
                            {
                                lpDispInfo->item.pszText = szCheckMark;
                            }
                        }
                    }
                    break;

                case LVN_DELETEITEM:
                    {
                    NMLISTVIEW * pLVInfo = (NMLISTVIEW *) lParam;

                    if (pLVInfo->lParam)
                    {
                        LocalFree ((LPTSTR)pLVInfo->lParam);
                    }

                    }
                    break;

                case LVN_ITEMCHANGED:
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    break;

                case LVN_ITEMACTIVATE:
                    {
                    LPNMITEMACTIVATE pItem = (LPNMITEMACTIVATE) lParam;
                    LPGPOITEM lpItem;
                    LVITEM item;
                    HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);

                    if (pItem->uKeyFlags != 0)
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = pItem->iItem;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPGPOITEM) item.lParam;

                    if (!lpItem)
                    {
                        break;
                    }


                    if (pItem->iSubItem == 0)
                    {
                        if (!lpItem->bReadOnly)
                        {
                            pGPM->StartGPE (lpItem->lpDSPath, hDlg);
                        }
                    }
                    else if (pItem->iSubItem == 1)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            if (lpItem->dwOptions & GPO_FLAG_FORCE)
                                lpItem->dwOptions &= ~GPO_FLAG_FORCE;
                            else
                                lpItem->dwOptions |= GPO_FLAG_FORCE;

                            ListView_RedrawItems (hLV, pItem->iItem, pItem->iItem);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }
                    }
                    else if (pItem->iSubItem == 2)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            lpItem = (LPGPOITEM) item.lParam;

                            if (lpItem->dwOptions & GPO_FLAG_DISABLE)
                            {
                                lpItem->dwOptions &= ~GPO_FLAG_DISABLE;
                            }
                            else
                            {
                                if (bDisableWarningIssued)
                                {
                                    lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                }
                                else
                                {
                                    TCHAR szMessage[200];
                                    TCHAR szTitle[100];

                                    bDisableWarningIssued = TRUE;

                                    LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                                    LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                                    if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                                MB_ICONWARNING | MB_DEFBUTTON2) == IDYES) {

                                        lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                    }
                                }
                            }

                            ListView_RedrawItems (hLV, pItem->iItem, pItem->iItem);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }
                    }

                    }
                    break;

                case LVN_BEGINLABELEDIT:
                    {
                    NMLVDISPINFO * pInfo = (NMLVDISPINFO *) lParam;
                    LPGPOITEM lpItem;

                    if (pInfo)
                    {
                        lpItem = (LPGPOITEM) pInfo->item.lParam;

                        if (lpItem)
                        {
                            if (lpItem->bReadOnly)
                            {
                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                                return TRUE;
                            }
                            else
                            {
                                HWND hEdit;

                                hEdit = ListView_GetEditControl(GetDlgItem(hDlg, IDC_GPM_LIST));

                                if (hEdit)
                                {
                                    SetWindowText (hEdit, lpItem->lpGPOName);
                                }
                            }
                        }
                    }
                    }
                    break;

                case LVN_ENDLABELEDIT:
                    {
                    NMLVDISPINFO * pInfo = (NMLVDISPINFO *) lParam;
                    LPGROUPPOLICYOBJECT pGPO;
                    LPGPOITEM lpItem, lpTemp;
                    LV_ITEM item;
                    HRESULT hr;
                    DWORD dwSize;
                    LPTSTR lpFullPath;
                    TCHAR szDisplayName[MAX_FRIENDLYNAME];

                    if (pInfo->item.pszText && (*pInfo->item.pszText))
                    {
                        //
                        // Get the LPGPOITEM pointer
                        //

                        lpItem = (LPGPOITEM) pInfo->item.lParam;

                        if (!lpItem)
                        {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  NULL lpGPOItem pointer")));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        if ( lpItem->bLocked )
                        {
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        //
                        // Create a GPO object to work with
                        //

                        hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                                              CLSCTX_SERVER, IID_IGroupPolicyObject,
                                              (void **)&pGPO);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  CoCreateInstance failed with 0x%x"), hr));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        lpFullPath = pGPM->GetFullGPOPath (lpItem->lpDSPath, hDlg);

                        if (!lpFullPath)
                        {
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Open GPO object without opening registry data
                        //

                        hr = pGPO->OpenDSGPO(lpFullPath, 0);

                        LocalFree (lpFullPath);

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDDS);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  OpenDSGPO failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Rename it
                        //

                        hr = pGPO->SetDisplayName(pInfo->item.pszText);

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDSETNAME);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  SetDisplayName failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Query for the display name again in case its been truncated
                        //

                        hr = pGPO->GetDisplayName(szDisplayName, ARRAYSIZE(szDisplayName));

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDSETNAME);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  GetDisplayName failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        pGPO->Release();


                        //
                        // Update the name in the LPGPOITEM structure
                        //

                       lpTemp = pGPM->CreateEntry (szDisplayName, lpItem->lpDSPath,
                                                   lpItem->dwOptions, lpItem->dwDisabled,
                                                   lpItem->bReadOnly);

                        if (!lpTemp) {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  Failed to create replacement entry.")));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                            return TRUE;
                        }

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_PARAM;
                        item.iItem = pInfo->item.iItem;
                        item.lParam = (LPARAM)lpTemp;

                        ListView_SetItem (GetDlgItem (hDlg, IDC_GPM_LIST), &item);

                        LocalFree (lpItem);

                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                    }
                    }
                    return TRUE;

                case LVN_KEYDOWN:
                    {
                    LPNMLVKEYDOWN pKey = (LPNMLVKEYDOWN) lParam;

                    if (pKey->wVKey == VK_DELETE)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            PostMessage (hDlg, WM_COMMAND, IDC_GPM_DELETE, 0);
                        }
                    }

                    if (pKey->wVKey == VK_F5)
                    {
                        PostMessage (hDlg, WM_COMMAND, IDM_GPM_REFRESH, 0);
                    }

                    if (pKey->wVKey == VK_RETURN)
                    {
                        PostMessage (hDlg, WM_COMMAND, IDM_GPM_PROPERTIES, 0);
                    }

                    if (pKey->wVKey == VK_F2)
                    {
                        HWND hLV;
                        int i;
                        LPGPOITEM lpItem;
                        LV_ITEM item;

                        //
                        // Allow the rename only if it is possible to rename
                        //

                        
                        //
                        // Get the selected item (if any)
                        //

                        hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

                        i = ListView_GetNextItem(GetDlgItem (hDlg, IDC_GPM_LIST), -1, LVNI_SELECTED);

                        if (i >= 0)
                        {
                            //
                            // Get the lpGPOItem structure pointer
                            //

                            ZeroMemory(&item, sizeof(item));

                            item.mask = LVIF_PARAM;
                            item.iItem = i;
                            ListView_GetItem(hLV, &item);

                            lpItem = (LPGPOITEM)item.lParam;

                            if ( (lpItem) &&  (!(lpItem->bReadOnly)) ) {
                                PostMessage (hDlg, WM_COMMAND, IDM_GPM_RENAME, 0);
                            }
                        }
                    }

                    }
                    break;

                case PSN_APPLY:
                    {
                    PSHNOTIFY * pNotify = (PSHNOTIFY *) lParam;

                    if (!pGPM->Save(hDlg))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    }


                // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_REFRESHDISPLAY:
            {
            INT iIndex, iCount;
            LPGPOITEM lpItem = NULL;
            HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
            LVITEM item;

            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            iIndex = ListView_GetNextItem (hLV, -1,
                                           LVNI_ALL | LVNI_SELECTED);

            if (iIndex != -1)
            {
                item.mask = LVIF_PARAM;
                item.iItem = iIndex;
                item.iSubItem = 0;

                if (!ListView_GetItem (hLV, &item))
                {
                    break;
                }

                lpItem = (LPGPOITEM) item.lParam;
            }


            if (pGPM && (!pGPM->m_bReadOnly))
            {
                if (iIndex != -1)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), TRUE);
                    if (lpItem && !lpItem->bReadOnly)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    }
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), TRUE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), TRUE);

                    iCount = ListView_GetItemCount(hLV);

                    if (iIndex > 0)
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), TRUE);
                    else
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);

                    if (iIndex < (iCount - 1))
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), TRUE);
                    else
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                }
                else
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);
                }
            }
            else
            {
                if (lpItem)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), TRUE);

                    if (!lpItem->bReadOnly)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    }
                }
                else
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);
                }
            }
            }
            break;

        case WM_CONTEXTMENU:
            if (GetDlgItem(hDlg, IDC_GPM_LIST) == (HWND)wParam)
            {
                pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

                if (pGPM)
                {
                    pGPM->OnContextMenu(hDlg, lParam);
                }
            }
            else
            {
                // right mouse click
                WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPSTR) aGroupPolicyMgrHelpIds);
            }
            return TRUE;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aGroupPolicyMgrHelpIds);
            break;
    }

    return FALSE;
}

void CGroupPolicyMgr::OnContextMenu(HWND hDlg, LPARAM lParam)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    HMENU hPopup;
    HWND hLV;
    int i;
    RECT rc;
    POINT pt;


    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);


    //
    // Figure out where to place the context menu
    //

    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (hLV, &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (hLV, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (hLV, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    //
    // Load the context menu
    //

    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_GPM_CONTEXTMENU));

    if (!hPopup) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnContextMenu: LoadMenu failed with error %d"), GetLastError()));
        return;
    }

    HMENU hSubMenu = GetSubMenu(hPopup, 0);


    //
    // If there is an item selected, then set the checkmarks appropriately
    //

    if (i >= 0)
    {
        //
        // Get the lpGPOItem structure pointer
        //

        ZeroMemory(&item, sizeof(item));

        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(hLV, &item);

        lpItem = (LPGPOITEM)item.lParam;

        if (!lpItem)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnContextMenu: Failed to get lpGPOItem pointer")));
            return;
        }


        //
        // Check the menu items
        //

        if (lpItem->dwOptions & GPO_FLAG_DISABLE)
        {
            CheckMenuRadioItem(hSubMenu, IDM_GPM_DISABLED, IDM_GPM_DISABLED,
                               IDM_GPM_DISABLED, MF_BYCOMMAND);
        }

        if (lpItem->dwOptions & GPO_FLAG_FORCE)
        {
            CheckMenuRadioItem(hSubMenu, IDM_GPM_NOOVERRIDE, IDM_GPM_NOOVERRIDE,
                               IDM_GPM_NOOVERRIDE, MF_BYCOMMAND);
        }

        RemoveMenu(hSubMenu, 9, MF_BYPOSITION);
        RemoveMenu(hSubMenu, IDM_GPM_REFRESH, MF_BYCOMMAND);

        //
        // Gray out Edit / Rename if read only
        //

        if (lpItem->bReadOnly)
        {
            EnableMenuItem (hSubMenu, IDM_GPM_EDIT, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem (hSubMenu, IDM_GPM_RENAME, MF_BYCOMMAND | MF_GRAYED);
        }
    }
    else
    {
        //
        // No item selected, remove some of the items on the
        // context menu
        //

        RemoveMenu(hSubMenu, IDM_GPM_NOOVERRIDE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_DISABLED, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, IDM_GPM_EDIT, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_DELETE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_RENAME, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_PROPERTIES, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 2), MF_BYPOSITION);
    }


    //
    // Gray out some menu items in read only mode
    //

    if (m_bReadOnly)
    {
        EnableMenuItem (hSubMenu, IDM_GPM_NEW, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_ADD, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_DELETE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_NOOVERRIDE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_DISABLED, MF_BYCOMMAND | MF_GRAYED);
    }

    //
    // Display the menu
    //

    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN, pt.x, pt.y, 0, hDlg, NULL);

    DestroyMenu(hPopup);
}

void CGroupPolicyMgr::OnProperties(HWND hDlg)
{
    INT iIndex;
    LVITEM item;
    HWND hLV;
    HRESULT hr;
    LPGPOITEM pItem;
    LPGROUPPOLICYOBJECT pGPO;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    PROPSHEETHEADER psh;
    LPTSTR lpTemp;


    //
    // Get the selected item
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

    iIndex = ListView_GetNextItem(hLV, -1, LVNI_ALL | LVNI_SELECTED);

    if (iIndex >= 0)
    {

        SetWaitCursor();

        //
        // Get the lpGPOItem pointer
        //

        ZeroMemory(&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        ListView_GetItem(hLV, &item);

        pItem = (LPGPOITEM)item.lParam;

        if (!pItem)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to get lpGPOItem pointer")));
            ClearWaitCursor();
            return;
        }

        pItem->bLocked = TRUE;

        hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                               CLSCTX_SERVER, IID_IGroupPolicyObject,
                               (void**)&pGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: CoCreateInstance failed with 0x%x"), hr));
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            return;
        }

        lpTemp = GetFullGPOPath (pItem->lpDSPath, hDlg);

        if (!lpTemp)
        {
            ClearWaitCursor();
            pItem->bLocked = FALSE;
            ReportError(hDlg, hr, IDS_FAILEDDS);
            return;
        }


        //
        // Open the requested object without mounting the registry
        //

        hr = pGPO->OpenDSGPO(lpTemp, pItem->bReadOnly ? GPO_OPEN_READ_ONLY : 0);

        LocalFree (lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to open GPO object with 0x%x"), hr));
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            ReportError(hDlg, hr, IDS_FAILEDDS);
            return;
        }


        //
        // Ask the GPO for the property sheet pages
        //

        hr = pGPO->GetPropertySheetPages (&hPages, &uPageCount);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to query property sheet pages with 0x%x."), hr));
            pGPO->Release();
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            return;
        }

        //
        // Display the property sheet
        //

        ZeroMemory (&psh, sizeof(psh));
        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hwndParent = hDlg;
        psh.hInstance = g_hInstance;
        psh.pszCaption = pItem->lpDisplayName;
        psh.nPages = uPageCount;
        psh.phpage = hPages;

        PropertySheet (&psh);

        LocalFree (hPages);
        pGPO->Release();

        CheckIconStatus (hLV, pItem);
        pItem->bLocked = FALSE;
        ClearWaitCursor();
    }
}

void CGroupPolicyMgr::OnNew(HWND hDlg)
{
    HRESULT hr;
    HWND hLV;
    INT iIndex;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    TCHAR szName[256];
    TCHAR szGPOPath[MAX_PATH];
    LPOLESTR lpDomain = NULL;
    HKEY hKey;
    DWORD dwSize, dwType;
    BOOL bDisabledLink = FALSE;


    //
    // Check if there is a user preference or policy that
    // any new GPOs should be created with a disabled link
    // by default
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bDisabledLink);
        RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisabledLink, &dwSize);

        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bDisabledLink);
        RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisabledLink, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Get the domain name
    //

    lpDomain = GetDomainFromLDAPPath(m_lpDSObject);

    if (!lpDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to get the domain name")));
        goto Exit;
    }


    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create a new GPO without mounting the registry
    //

    GetNewGPODisplayName (szName, ARRAYSIZE(szName));

#if FGPO_SUPPORT
    hr = pGPO->New(lpDomain, szName, (m_gpHint == GPHintForest) ? GPO_OPEN_FOREST : 0);
#else
    hr = pGPO->New(lpDomain, szName, 0);
#endif

    if (FAILED(hr))
    {
        ReportError(hDlg, hr, IDS_FAILEDNEW);
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to create GPO object with 0x%x"), hr));
        goto Exit;
    }


    hr = pGPO->GetPath(szGPOPath, ARRAYSIZE(szGPOPath));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to get GPO object path with 0x%x"), hr));
        pGPO->Delete();
        goto Exit;
    }


    //
    // Add the GPO to the list view
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

    if (!AddGPOToList (hLV, szName, szGPOPath,
                      (bDisabledLink ? GPO_FLAG_DISABLE : 0), FALSE, FALSE, FALSE))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to add the GPO to the listview")));
        pGPO->Delete();
        goto Exit;
    }

    m_bDirty = TRUE;

    Save(hDlg);
    SendMessage (GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);

    iIndex = ListView_GetItemCount(hLV) - 1;


    //
    // Now trigger an edit of the entry
    //

    SetFocus(hLV);
    ListView_EnsureVisible (hLV, iIndex, FALSE);
    ListView_EditLabel(hLV, iIndex);


Exit:

    if (lpDomain)
    {
        delete [] lpDomain;
    }

    if (pGPO)
    {
        pGPO->Release();
    }
}

BOOL CGroupPolicyMgr::RefreshGPM (HWND hDlg, BOOL bInitial)
{
    HRESULT hr;
    BOOL bResult = FALSE;
    TCHAR szHeaderName[50];
    TCHAR szBuffer1[100];
    TCHAR szBuffer2[MAX_FRIENDLYNAME];
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    LV_COLUMN col;
    RECT rc;
    INT iTotal = 0, iCurrent, iMaxVisibleItems, iSize;
    IADs * pADs;
    VARIANT var;
    BSTR bstrProperty;


    //
    // Prep work
    //

    SetWaitCursor();
    SendMessage (hLV, WM_SETREDRAW, 0, 0);
    ListView_DeleteAllItems(hLV);
    CheckDlgButton (hDlg, IDC_GPM_BLOCK, BST_UNCHECKED);


    //
    // Insert Columns
    //

    if (bInitial)
    {
        GetClientRect (hLV, &rc);
        LoadString(g_hInstance, IDS_GPM_NAME, szHeaderName, ARRAYSIZE(szHeaderName));
        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
        col.fmt = LVCFMT_LEFT;
        iCurrent = (int)(rc.right * .65);
        iTotal += iCurrent;
        col.cx = iCurrent;
        col.pszText = szHeaderName;
        col.iSubItem = 0;

        ListView_InsertColumn (hLV, 0, &col);

        LoadString(g_hInstance, IDS_GPM_NOOVERRIDE, szHeaderName, ARRAYSIZE(szHeaderName));
        iCurrent = (int)(rc.right * .20);
        iTotal += iCurrent;
        col.cx = iCurrent;
        col.fmt = LVCFMT_CENTER;
        col.iSubItem = 1;
        ListView_InsertColumn (hLV, 1, &col);


        LoadString(g_hInstance, IDS_GPM_DISABLED, szHeaderName, ARRAYSIZE(szHeaderName));
        col.iSubItem = 2;
        col.cx = rc.right - iTotal;
        col.fmt = LVCFMT_CENTER;
        ListView_InsertColumn (hLV, 2, &col);
    }


    //
    // Set the DC name
    //

    if (bInitial)
    {
        LoadString (g_hInstance, IDS_GPM_DCNAME, szBuffer1, ARRAYSIZE(szBuffer1));
        
        hr = StringCchPrintf (szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1 , m_lpGPODCName);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM:Could not copy DC name due to 0x%x"), hr));
            ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
            goto Exit;

        }

        SetDlgItemText (hDlg, IDC_GPM_DCNAME, szBuffer2);
    }


    //
    // Bind to the object and get the friendly name
    //

    hr = OpenDSObject(m_lpDSObject, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: %s does not exist on the server."), m_lpDSObject));

            DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODSOBJECT),
                 hDlg, NoDSObjectDlgProc, (LPARAM) this);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: OpenDSObject failed with 0x%x"), hr));
            ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
        }
        goto Exit;
    }

    if (bInitial)
    {
#if FGPO_SUPPORT
        if (m_gpHint != GPHintForest)
        {
#endif
            VariantInit(&var);
            bstrProperty = SysAllocString (GPM_NAME_PROPERTY);

            if (!bstrProperty)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: Failed to allocate memory with %d"), GetLastError()));
                ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
                VariantClear (&var);
                pADs->Release();
                goto Exit;
            }


            hr = pADs->Get(bstrProperty, &var);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: Failed to query for display name with 0x%x"), hr));
                ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
                SysFreeString (bstrProperty);
                VariantClear (&var);
                pADs->Release();
                goto Exit;
            }

            LoadString (g_hInstance, IDS_GPM_DESCRIPTION, szBuffer1, ARRAYSIZE(szBuffer1));
            hr = StringCchPrintf (szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1, var.bstrVal);
            if (FAILED(hr)) 
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: Failed to copy GPM description with 0x%x"), hr));
                ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
                SysFreeString (bstrProperty);
                VariantClear (&var);
                pADs->Release();
                goto Exit;
            }

            SysFreeString (bstrProperty);
            VariantClear (&var);
#if FGPO_SUPPORT
        }
        else
        {
            LoadString (g_hInstance, IDS_GPM_FORESTDESC, szBuffer2, ARRAYSIZE(szBuffer2));
        }
#endif

        SetDlgItemText (hDlg, IDC_GPM_TITLE, szBuffer2);


        //
        // Check if the user has write access to gPLink
        //

        hr = CheckDSWriteAccess ((LPUNKNOWN)pADs, TEXT("gPLink"));

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::RefreshGPM: User has read only access to the gPLink property.")));
            m_bReadOnly = TRUE;
        }
    }


    //
    // Get the options for this DS object
    //

    VariantInit(&var);
    bstrProperty = SysAllocString (GPM_OPTIONS_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            if (var.lVal & GPC_BLOCK_POLICY)
            {
                CheckDlgButton (hDlg, IDC_GPM_BLOCK, BST_CHECKED);
            }
        }

        SysFreeString (bstrProperty);
    }

    VariantClear (&var);


    //
    // Get the GPOs linked to this object
    //

    VariantInit(&var);
    bstrProperty = SysAllocString (GPM_LINK_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            AddGPOs (hDlg, var.bstrVal);
        }

        SysFreeString (bstrProperty);
    }

    VariantClear (&var);


    pADs->Release();


    //
    // Get the max number of visible items and the total number
    // of items in the listview
    //

    if (bInitial)
    {
        iMaxVisibleItems = ListView_GetCountPerPage (hLV);
        iTotal = ListView_GetItemCount(hLV);


        //
        // If the number of items in the listview is greater than
        // the max visible items, then we need to make the first
        // column smaller by the width of a vertical scroll bar so
        // that the horizontal scroll bar doesn't appear
        //

        if (iTotal > iMaxVisibleItems) {
            iSize = ListView_GetColumnWidth (hLV, 0);
            iSize -= GetSystemMetrics(SM_CYHSCROLL);
            ListView_SetColumnWidth (hLV, 0, iSize);
        }
    }

    PropSheet_UnChanged (GetParent(hDlg), hDlg);

    //
    // Success
    //

    bResult = TRUE;

Exit:

    SendMessage (hLV, WM_SETREDRAW, 1, 0);
    ClearWaitCursor();

    return bResult;
}

BOOL CGroupPolicyMgr::OnInitDialog (HWND hDlg)
{
    BOOL bResult = FALSE;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    LOGFONT lf;
    HICON hIcon;
    HIMAGELIST hImageList;
    HRESULT hr;
    LPOLESTR pszDomain;
    LPTSTR lpTemp;


    //
    // Retreive the name of the DC DSAdmin is using
    //

    m_lpDSADCName = ExtractServerName (m_lpDSObject);

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OnInitDialog:  DS Admin is focused on DC %s"),
             m_lpDSADCName));


    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(m_lpDSObject);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog: Failed to get domain name")));
        return FALSE;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &m_lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
    }


    //
    // Get the GPO DC for this domain
    //

    m_lpGPODCName = GetDCName (m_lpDomainName, m_lpDSADCName, hDlg, TRUE, VALIDATE_INHERIT_DC);

    if (!m_lpGPODCName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog:  Failed to get DC name for %s"),
                 m_lpDomainName));
        return FALSE;
    }


    //
    // Switch to using the GPO domain controller for this DS object
    //

    lpTemp = MakeFullPath (m_lpDSObject, m_lpGPODCName);

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog:  Failed to build new DS object path")));
        return FALSE;
    }

    LocalFree (m_lpDSObject);
    m_lpDSObject = lpTemp;


    //
    // Create the Marlett font based upon the currently selected font
    //

    m_hDefaultFont = (HFONT) SendMessage (hLV, WM_GETFONT, 0, 0);

    GetObject (m_hDefaultFont, sizeof(lf), &lf);

    lf.lfHeight += (LONG)(lf.lfHeight * .20);
    lf.lfCharSet = SYMBOL_CHARSET;
    lf.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
    
    hr = StringCchCopy (lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), TEXT("Marlett"));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnInitDialog: Failed to copy font name with 0x%x"), hr));
        return FALSE;
    }

    m_hMarlettFont = CreateFontIndirect (&lf);


    //
    // Set extended LV styles
    //

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Create the imagelist
    //

    hImageList = ImageList_Create (16, 16, ILC_MASK, 3, 3);

    if (!hImageList)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnInitDialog: Failed to create the image list")));
        return FALSE;
    }

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY2),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY3),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);


    //
    // Associate the imagelist with the listview.
    // The listview will free this when the
    // control is destroyed.
    //

    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) hImageList);


    //
    // Refresh GPM
    //

    if (!RefreshGPM(hDlg, TRUE))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnInitDialog: Failed to refresh GPM")));
        return FALSE;
    }


    return TRUE;

}

BOOL CGroupPolicyMgr::Save (HWND hDlg)
{
    HRESULT hr;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    IADs * pADs;
    VARIANT var;
    BSTR bstrName;
    LVITEM item;
    LPGPOITEM lpItem;
    TCHAR szOptions[12];
    LPTSTR lpTemp, lpResult = NULL;
    DWORD dwStrLen, dwOptions;
    TCHAR szEmpty [] = TEXT(" ");
    INT iIndex = -1;


    if (m_bReadOnly)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::Save: User only has read access, so no changes will be saved.")));
        return TRUE;
    }



    if (!m_bDirty)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::Save: Nothing has changed (dirty flag is FALSE), so no changes will be saved.")));
        return TRUE;
    }

    //
    // Enumerate through the selected items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPGPOITEM) item.lParam;

        _itot(lpItem->dwOptions, szOptions, 10);


        //         [    ldap path                  ;   options             ]   0

        dwStrLen = 1 + lstrlen(lpItem->lpDSPath) + 1 + lstrlen(szOptions) + 1 + 1;

        if (lpResult)
        {
            dwStrLen += lstrlen(lpResult);
        }

        dwStrLen *= sizeof(TCHAR);

        lpTemp = (LPTSTR) LocalAlloc (LPTR, dwStrLen);

        if (!lpTemp)
        {
            continue;
        }

        ULONG ulNoChars;

        ulNoChars = lstrlen(TEXT("[")) + 1;
        hr = StringCchCopy (lpTemp, ulNoChars, TEXT("["));
        ASSERT(SUCCEEDED(hr));

        ulNoChars += lstrlen(lpItem->lpDSPath) + 1;
        hr = StringCchCat (lpTemp, ulNoChars, lpItem->lpDSPath);
        ASSERT(SUCCEEDED(hr));

        ulNoChars += lstrlen(TEXT(";")) + 1;
        hr = StringCchCat (lpTemp, ulNoChars, TEXT(";"));
        ASSERT(SUCCEEDED(hr));

        ulNoChars += lstrlen(szOptions) + 1;
        hr = StringCchCat (lpTemp, ulNoChars, szOptions);
        ASSERT(SUCCEEDED(hr));

        ulNoChars += lstrlen(TEXT("]")) + 1;
        hr = StringCchCat (lpTemp, ulNoChars, TEXT("]"));
        ASSERT(SUCCEEDED(hr));

        if (lpResult)
        {
            ulNoChars += lstrlen(lpResult) + 1;
            hr = StringCchCat (lpTemp, ulNoChars, lpResult);
            ASSERT(SUCCEEDED(hr));
        }

        LocalFree (lpResult);
        lpResult = lpTemp;
    }


    if (!lpResult)
    {
        lpResult = szEmpty;
    }


    //
    // Bind to the DS object
    //

    hr = OpenDSObject(m_lpDSObject, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to get gpo interface with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        return FALSE;
    }


    //
    // Set the link property
    //

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString (lpResult);

    if (!var.bstrVal)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }


    bstrName = SysAllocString (GPM_LINK_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }


    hr = pADs->Put(bstrName, var);

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to put link property with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }


    dwOptions = 0;

    if (IsDlgButtonChecked (hDlg, IDC_GPM_BLOCK) == BST_CHECKED)
    {
        dwOptions |= GPC_BLOCK_POLICY;
    }


    //
    // Set the options
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = dwOptions;

    bstrName = SysAllocString (GPM_OPTIONS_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }

    hr = pADs->Put(bstrName, var);

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to set options with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to commit changes with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }

    if (lpResult != szEmpty)
    {
        LocalFree (lpResult);
    }

    pADs->Release();

    m_bDirty = FALSE;

    return TRUE;
}


BOOL CGroupPolicyMgr::AddGPOs (HWND hDlg, LPTSTR lpGPOList)
{
    HRESULT hr;
    TCHAR szGPO[512];
    TCHAR szOptions[20];
    TCHAR szDisplayName[MAX_PATH];
    DWORD dwOptions;
    LPTSTR lpTemp, lpGPO, lpNamedGPO;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    IADs * pADs;
    VARIANT var;
    BSTR bstrProperty;
    DWORD dwDisabled;
    BOOL bReadOnly;


    if (!lpGPOList)
    {
        return TRUE;
    }

    lpTemp = lpGPOList;

    while (TRUE)
    {
        szDisplayName[0] = TEXT('\0');
        dwDisabled = 0;
        bReadOnly = FALSE;


        //
        // Look for the [
        //

        while (*lpTemp && (*lpTemp != TEXT('[')))
            lpTemp++;

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;

        //
        // Copy the GPO name
        //

        lpGPO = szGPO;

        while (*lpTemp && (*lpTemp != TEXT(';')))
            *lpGPO++ = *lpTemp++;

        *lpGPO = TEXT('\0');

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;


        //
        // Get the options
        //

        lpGPO = szOptions;

        while (*lpTemp && (*lpTemp != TEXT(']')))
            *lpGPO++ = *lpTemp++;

        *lpGPO = TEXT('\0');
        dwOptions = _ttoi (szOptions);

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;


        //
        // Convert the nameless path into a named path
        //

        lpNamedGPO = GetFullGPOPath (szGPO, hDlg);

        if (lpNamedGPO)
        {

            //
            // Get the friendly display name and GPO options
            //

            hr = OpenDSObject(lpNamedGPO, IID_IADs, (void **)&pADs);

            if (SUCCEEDED(hr)) {

                VariantInit(&var);
                bstrProperty = SysAllocString (GPO_NAME_PROPERTY);

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);

                    if (SUCCEEDED(hr))
                    {
                        lstrcpyn (szDisplayName, var.bstrVal, ARRAYSIZE(szDisplayName));
                    }

                    SysFreeString (bstrProperty);
                }

                VariantClear (&var);


                //
                // Query for the options
                //

                VariantInit(&var);
                bstrProperty = SysAllocString (GPO_OPTIONS_PROPERTY);

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);

                    if (SUCCEEDED(hr))
                    {
                        dwDisabled = var.lVal;
                    }

                    SysFreeString (bstrProperty);
                }
                VariantClear (&var);


                if (FAILED(CheckDSWriteAccess((LPUNKNOWN) pADs, GPO_VERSION_PROPERTY)))
                {
                    bReadOnly = TRUE;
                }

                pADs->Release();
            }
            else
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::AddGPOs: Skipping link to deleted object.  %s"), lpNamedGPO));
                    LocalFree (lpNamedGPO);
                    continue;
                }

                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::AddGPOs: OpenDSObject failed with 0x%x"), hr));
            }

            LocalFree (lpNamedGPO);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::AddGPOs: Failed to get the full domain name for %s"), szGPO));
        }


        if (szDisplayName[0] == TEXT('\0'))
        {
            LoadString (g_hInstance, IDS_GPM_NOGPONAME, szDisplayName, ARRAYSIZE(szDisplayName));
            dwDisabled = (GPO_OPTION_DISABLE_USER | GPO_OPTION_DISABLE_MACHINE);
            bReadOnly = TRUE;
        }


        AddGPOToList (hLV, szDisplayName, szGPO, dwOptions, TRUE, dwDisabled, bReadOnly);
    }

Exit:

    return TRUE;
}

LPGPOITEM CGroupPolicyMgr::CreateEntry (LPTSTR szName, LPTSTR szGPO, DWORD dwOptions,
                                    DWORD dwDisabled, BOOL bReadOnly)
{
    LPGPOITEM lpItem;
    DWORD dwSize;
    TCHAR szFormat[20];
    LPTSTR lpResult, lpName = szName, lpFullName = NULL;
    LPOLESTR pszDomain;
    HRESULT hr;
    ULONG ulNoChars;
    //
    // Check if the GPO is in this domain
    //

    pszDomain = GetDomainFromLDAPPath(szGPO);

    if (pszDomain)
    {
        if (SUCCEEDED(ConvertToDotStyle (pszDomain, &lpResult)))
        {
            if (lstrcmpi(lpResult, m_lpDomainName) != 0)
            {
                LoadString (g_hInstance, IDS_GPM_DOMAINNAME, szFormat,
                            ARRAYSIZE(szFormat));

                ulNoChars = lstrlen (szName) + lstrlen (szFormat) + lstrlen (lpResult);
                lpFullName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));
                if (lpFullName)
                {                
                    hr = StringCchPrintf (lpFullName, ulNoChars, szFormat, szName, lpResult);
                    if (FAILED(hr)) 
                    {
                        LocalFree(lpFullName);
                        delete [] pszDomain;
                        return NULL;
                    }
                    lpName = lpFullName;
                }
            }

            LocalFree (lpResult);
        }

        delete [] pszDomain;
    }


    //
    // Calculate the size needed and fill in the structure
    //

    dwSize = sizeof(GPOITEM);
    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(szName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(szGPO) + 1) * sizeof(TCHAR));

    lpItem = (LPGPOITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
    {
        if (lpFullName)
        {
            LocalFree (lpFullName);
        }

        return NULL;
    }


    lpItem->lpDisplayName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(GPOITEM));
    ulNoChars = (dwSize - sizeof(GPOITEM))/sizeof(WCHAR);

    hr = StringCchCopy (lpItem->lpDisplayName, ulNoChars, lpName);
    if (SUCCEEDED(hr)) 
    {
        lpItem->lpGPOName = lpItem->lpDisplayName + lstrlen (lpItem->lpDisplayName) + 1;
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpDisplayName) + 1);

        hr = StringCchCopy (lpItem->lpGPOName, 
                            ulNoChars,
                            szName);
    }

    if (SUCCEEDED(hr)) 
    {
        lpItem->lpDSPath = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpGPOName) + 1);
        hr = StringCchCopy (lpItem->lpDSPath, 
                            ulNoChars,
                            szGPO);
    }

    if (SUCCEEDED(hr)) 
    {
        lpItem->dwOptions = dwOptions;
        lpItem->dwDisabled = dwDisabled;
        lpItem->bReadOnly = bReadOnly;
        lpItem->bLocked = FALSE;

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Adding  %s"), lpName));
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: GPO Name  %s"), szName));
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: DS Path  %s"), szGPO));
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Options  %d"), dwOptions));
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Disabled  %d"), dwDisabled));
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: ReadOnly  %d"), bReadOnly));
    }
    else
    {
        LocalFree(lpItem);
        lpItem = NULL;
    }

    if (lpFullName)
    {
        LocalFree (lpFullName);
    }


    return lpItem;
}

BOOL CGroupPolicyMgr::AddGPOToList (HWND hLV, LPTSTR szName, LPTSTR szGPO,
                                    DWORD dwOptions, BOOL bHighest,
                                    DWORD dwDisabled, BOOL bReadOnly)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    INT iItem;


    //
    // Create the link list entry
    //

    lpItem = CreateEntry (szName, szGPO, dwOptions, dwDisabled, bReadOnly);

    if (!lpItem)
    {
        return FALSE;
    }


    //
    // Add the item
    //

    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    item.iItem = (bHighest ? 0 : ListView_GetItemCount(hLV));
    item.iSubItem = 0;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = (LPARAM) lpItem;

    if ((dwDisabled & GPO_OPTION_DISABLE_USER) && (dwDisabled & GPO_OPTION_DISABLE_MACHINE))
    {
        item.iImage = 1;
    }
    else if (dwDisabled == 0)
    {
        item.iImage = 0;
    }
    else
    {
        item.iImage = 2;
    }

    iItem = ListView_InsertItem (hLV, &item);


    //
    // Select the item
    //

    item.mask = LVIF_STATE;
    item.iItem = iItem;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    return TRUE;
}

INT_PTR CALLBACK CGroupPolicyMgr::RemoveGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPGPOITEM lpGPO = (LPGPOITEM)lParam;
            TCHAR szBuffer[200];
            LPTSTR lpTitle;
            HICON hIcon;
            ULONG ulNoChars;

            hIcon = LoadIcon (NULL, IDI_QUESTION);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_QUESTION, STM_SETICON, (WPARAM) hIcon, 0);
            }

            GetDlgItemText (hDlg, IDC_REMOVE_TITLE, szBuffer, ARRAYSIZE(szBuffer));

            ulNoChars = lstrlen(szBuffer) + lstrlen(lpGPO->lpDisplayName) + 1;
            lpTitle = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

            if (lpTitle)
            {
                (void) StringCchPrintf (lpTitle, ulNoChars, szBuffer, lpGPO->lpDisplayName);
                SetDlgItemText (hDlg, IDC_REMOVE_TITLE, lpTitle);

                LocalFree (lpTitle);
            }

            CheckDlgButton (hDlg, IDC_REMOVE_LIST, BST_CHECKED);

            if (lpGPO->bReadOnly)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVE_DS), FALSE);
            }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if (IsDlgButtonChecked (hDlg, IDC_REMOVE_LIST) == BST_CHECKED)
                    {
                        EndDialog (hDlg, 1);
                    }
                    else
                    {
                        EndDialog (hDlg, 2);
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aRemoveGPOHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aRemoveGPOHelpIds);
            return (TRUE);
    }

    return FALSE;
}

INT_PTR CALLBACK CGroupPolicyMgr::LinkOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPGPOITEM lpItem = (LPGPOITEM) lParam;
            TCHAR szBuffer[50];
            LPTSTR lpTitle;
            ULONG ulNoChars;

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpItem);

            GetWindowText (hDlg, szBuffer, ARRAYSIZE(szBuffer));

            ulNoChars = lstrlen(szBuffer) + lstrlen(lpItem->lpDisplayName) + 1;
            lpTitle = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) +
                                           lstrlen(lpItem->lpDisplayName) + 1) * sizeof(TCHAR));

            if (lpTitle)
            {
                (void) StringCchPrintf (lpTitle, ulNoChars, szBuffer, lpItem->lpDisplayName);
                SetWindowText (hDlg, lpTitle);

                LocalFree (lpTitle);
            }

            if (lpItem->dwOptions & GPO_FLAG_DISABLE)
            {
                CheckDlgButton (hDlg, IDC_GPM_DISABLED, BST_CHECKED);
            }

            if (lpItem->dwOptions & GPO_FLAG_FORCE)
            {
                CheckDlgButton (hDlg, IDC_GPM_NOOVERRIDE, BST_CHECKED);
            }

            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_GPM_DISABLED:
                    {
                    if ((HIWORD(wParam) == BN_CLICKED) &&
                        (IsDlgButtonChecked (hDlg, IDC_GPM_DISABLED) == BST_CHECKED))
                    {
                        TCHAR szMessage[200];
                        TCHAR szTitle[100];

                        LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                        LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                        if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                    MB_ICONWARNING | MB_DEFBUTTON2) == IDNO) {

                            CheckDlgButton (hDlg, IDC_GPM_DISABLED, BST_UNCHECKED);
                        }
                    }
                    }
                    break;

                case IDOK:
                    {
                    LPGPOITEM lpItem;
                    DWORD dwTemp = 0;

                    lpItem = (LPGPOITEM) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (IsDlgButtonChecked (hDlg, IDC_GPM_DISABLED) == BST_CHECKED)
                    {
                        dwTemp |= GPO_FLAG_DISABLE;
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_GPM_NOOVERRIDE) == BST_CHECKED)
                    {
                        dwTemp |= GPO_FLAG_FORCE;
                    }

                    if (dwTemp != lpItem->dwOptions)
                    {
                        lpItem->dwOptions = dwTemp;
                        EndDialog (hDlg, 1);
                    }
                    else
                    {
                        EndDialog (hDlg, 0);
                    }
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aLinkOptionsHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aLinkOptionsHelpIds);
            return (TRUE);
    }

    return FALSE;
}


INT_PTR CALLBACK CGroupPolicyMgr::NoDSObjectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            CGroupPolicyMgr *pGPM = (CGroupPolicyMgr *)lParam;
            TCHAR szBuffer[100];
            TCHAR szTitle[300];
            LPTSTR lpMsg, lpMsgEx;
            INT iSize;
            HWND hMsg = GetDlgItem (hDlg, IDC_NODSOBJECT_TEXT);
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_ERROR);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_NODSOBJECT_ICON, STM_SETICON, (WPARAM) hIcon, 0);
            }

            GetWindowText (hDlg, szBuffer, ARRAYSIZE(szBuffer));
            (void) StringCchPrintf (szTitle, ARRAYSIZE(szTitle), szBuffer, pGPM->m_lpGPODCName);
            SetWindowText (hDlg, szTitle);

            iSize = 600;

            iSize += lstrlen(pGPM->m_lpGPODCName);
            iSize += lstrlen(pGPM->m_lpDSADCName);
            iSize++;

            lpMsg = (LPTSTR) LocalAlloc(LPTR, iSize * sizeof(TCHAR));

            if (lpMsg)
            {
                lpMsgEx = (LPTSTR) LocalAlloc(LPTR, iSize * sizeof(TCHAR));

                if (lpMsgEx)
                {
                    LoadString (g_hInstance, IDS_NODSOBJECT_MSG, lpMsg, iSize);
                    (void) StringCchPrintf (lpMsgEx, iSize, lpMsg, pGPM->m_lpGPODCName, pGPM->m_lpDSADCName);
                    SetWindowText (hMsg, lpMsgEx);
                    LocalFree (lpMsgEx);
                }

                LocalFree (lpMsg);
            }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hDlg, 1);
                    return TRUE;

                case IDHELP:
                    {
                        SHELLEXECUTEINFO ShellInfo;
                        WCHAR            pszHelpFilePath[ MAX_PATH ];

                        memset( &ShellInfo, 0, sizeof( ShellInfo ) );

                        ExpandEnvironmentStringsW (
                            L"%SystemRoot%\\Help\\gpedit.chm::/sag_spTShoot.htm",
                            pszHelpFilePath, MAX_PATH);

                        ShellInfo.cbSize = sizeof( ShellInfo );
                        ShellInfo.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_DOENVSUBST;
                        ShellInfo.lpVerb = L"open";
                        ShellInfo.lpFile = L"%SystemRoot%\\hh.exe";
                        ShellInfo.lpParameters = pszHelpFilePath;
                        ShellInfo.nShow = SW_SHOWNORMAL;
                        
                        (void) ShellExecuteEx( &ShellInfo );
                        break;
                    }
                
            }
            break;
    }

    return FALSE;
}

DWORD CGroupPolicyMgr::IsGPODisabled(LPTSTR lpGPO)
{
    HRESULT hr;
    LPTSTR lpTemp;
    DWORD dwOptions = 0;
    LPGROUPPOLICYOBJECT pGPO = NULL;


    //
    // Create a GroupPolicyObject to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to create GPO object with 0x%x."), hr));
        return 0;
    }

    lpTemp = GetFullGPOPath (lpGPO, NULL);

    if (!lpTemp)
    {
        pGPO->Release();
        return 0;
    }


    //
    // Open the requested object without mounting the registry
    //

    hr = pGPO->OpenDSGPO(lpTemp, GPO_OPEN_READ_ONLY);

    LocalFree (lpTemp);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to open GPO object with 0x%x."), hr));
        pGPO->Release();
        return 0;
    }


    //
    // Get the options
    //

    hr = pGPO->GetOptions(&dwOptions);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to get GPO options with 0x%x."), hr));
        pGPO->Release();
        return 0;
    }

    pGPO->Release();

    return dwOptions;
}

void CGroupPolicyMgr::CheckIconStatus (HWND hLV, LPGPOITEM lpGPO)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    INT iIndex = -1;
    DWORD dwDisabled;



    //
    // Check if the GPO disabled
    //

    dwDisabled = IsGPODisabled(lpGPO->lpDSPath);


    //
    // If the status hasn't changed, exit now
    //

    if (dwDisabled == lpGPO->dwDisabled)
    {
        return;
    }


    //
    // Enumerate through the items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPGPOITEM) item.lParam;


        //
        // If the item has a path to the GPO in question,
        // update the icon
        //

        if (!lstrcmpi (lpItem->lpDSPath, lpGPO->lpDSPath))
        {
            //
            // Update the icon if appropriate
            //

            item.mask = LVIF_IMAGE;
            item.iItem = iIndex;
            item.iSubItem = 0;

            if ((dwDisabled & GPO_OPTION_DISABLE_USER) && (dwDisabled & GPO_OPTION_DISABLE_MACHINE))
            {
                item.iImage = 1;
            }
            else if (dwDisabled == 0)
            {
                item.iImage = 0;
            }
            else
            {
                item.iImage = 2;
            }

            SendMessage (hLV, LVM_SETITEM, 0, (LPARAM) &item);
            ListView_RedrawItems (hLV, iIndex, iIndex);
        }
    }

    lpGPO->dwDisabled = dwDisabled;
}

LPTSTR CGroupPolicyMgr::GetFullGPOPath (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPODCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }


    if (!lstrcmpi(lpDomainName, m_lpDomainName))
    {

        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, m_lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to build new DS object path")));
            goto Exit;
        }

    }
    else
    {

        //
        // Get the GPO DC for this domain
        //

        lpGPODCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

        if (!lpGPODCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to get DC name for %s"),
                     lpDomainName));
            goto Exit;
        }


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

        LocalFree (lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to build new DS object path")));
            goto Exit;
        }
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}

BOOL CGroupPolicyMgr::StartGPE (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpDomainName;
    LPOLESTR pszDomain;
    HRESULT hr;
    BOOL bResult;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::StartGPE: Failed to get domain name")));
        return FALSE;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return FALSE;
    }


    //
    // Check if the GPO is in the same domain as GPM is focused on
    //

    if (!lstrcmpi(lpDomainName, m_lpDomainName))
    {
        bResult = SpawnGPE (lpGPO, m_gpHint, m_lpGPODCName, hParent);
    }
    else
    {
        bResult = SpawnGPE (lpGPO, m_gpHint, NULL, hParent);
    }


    LocalFree (lpDomainName);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyMgrCF::CGroupPolicyMgrCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CGroupPolicyMgrCF::~CGroupPolicyMgrCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CGroupPolicyMgrCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CGroupPolicyMgrCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CGroupPolicyMgrCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CGroupPolicyMgrCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CGroupPolicyMgr *pComponentData = new CGroupPolicyMgr(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CGroupPolicyMgrCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\gpmgr.h ===
//
// Structures
//

typedef struct _GPOITEM
{
    DWORD   dwOptions;
    LPTSTR  lpDisplayName;
    LPTSTR  lpGPOName;
    LPTSTR  lpDSPath;
    DWORD   dwDisabled;   // see GPO_OPTION_DISABLE_* flags in gpedit.h
    BOOL    bReadOnly;
    BOOL    bLocked;
} GPOITEM, *LPGPOITEM;

typedef struct _ADDGPOITEM
{
    LPTSTR  lpDSName;
    BOOL    bSpawn;
    LPTSTR  lpName;
    LPTSTR  lpPath;
    LPTSTR  lpImport;
} ADDGPOITEM, *LPADDGPOITEM;


//
// CGroupPolicyMgr class
//

class CGroupPolicyMgr:
    public IExtendPropertySheet,
    public ISnapinHelp
{

protected:
    UINT                        m_cRef;
    LPTSTR                      m_lpDSObject;
    LPTSTR                      m_lpGPODCName;
    LPTSTR                      m_lpDSADCName;
    LPTSTR                      m_lpDomainName;
    HFONT                       m_hDefaultFont;
    HFONT                       m_hMarlettFont;
    BOOL                        m_bReadOnly;
    BOOL                        m_bDirty;
    GROUP_POLICY_HINT_TYPE      m_gpHint;

    static unsigned int         m_cfDSObjectName;
    static unsigned int         m_cfNodeTypeString;

public:
    CGroupPolicyMgr();
    ~CGroupPolicyMgr();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

private:

    static UINT CALLBACK PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static INT_PTR CALLBACK GPMDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void OnContextMenu(HWND hDlg, LPARAM lParam);
    void OnProperties(HWND hDlg);
    void OnNew(HWND hDlg);
    BOOL RefreshGPM (HWND hDlg, BOOL bInitial);
    BOOL OnInitDialog (HWND hDlg);
    BOOL Save (HWND hDlg);
    BOOL AddGPOs (HWND hDlg, LPTSTR lpGPOList);
    LPGPOITEM CreateEntry (LPTSTR szName, LPTSTR szGPO, DWORD dwOptions,
                           DWORD dwDisabled, BOOL bReadOnly);
    BOOL AddGPOToList (HWND hLV, LPTSTR szName, LPTSTR szGPO, DWORD dwOptions, BOOL bHighest, DWORD dwDisabled, BOOL bReadOnly);
    static BOOL CALLBACK AddGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RemoveGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK DeleteGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK LinkOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK NoDSObjectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    DWORD IsGPODisabled(LPTSTR lpGPO);
    void CheckIconStatus (HWND hLV, LPGPOITEM lpGPO);
    LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent);
    BOOL StartGPE (LPTSTR lpGPO, HWND hParent);
};



//
// ComponentData class factory
//


class CGroupPolic