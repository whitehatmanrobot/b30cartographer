NCELLED);
                        b = FALSE;
                        break;
                    }

                    if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        continue;
                    }
                    if (!e.FindData->nFileSizeLow) {
                        DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                        continue;
                    }

                    if (!BuildPath (upginfsFile, upginfsDir, e.FileName)) {
                        b = FALSE;
                        break;
                    }
                    SetFileAttributes (upginfsFile, FILE_ATTRIBUTE_NORMAL);
                    if (!CopyFile (e.FullPath, upginfsFile, FALSE)) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Error copying %1 to %2"), 0, e.FullPath, upginfsFile);
                        b = FALSE;
                        break;
                    }
                    //
                    // let w95upg.dll know about the new files
                    //
                    UpginfsUpdated = TRUE;
                    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpginfs: INF %1 successfully copied to %2"), 0, e.FullPath, upginfsFile);
                } while (EnumNextFilePatternRecursive (&e));
                AbortEnumFilePatternRecursive (&e);
            }
        }
    }

exit:

    return b;
}


#ifdef _X86_

BOOL
pProcessMigdlls (
    IN      PCTSTR MigdllsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERN_ENUM e;
    TCHAR migdllsLocalDir[MAX_PATH];
    TCHAR dirName[MAX_PATH];
    DWORD rc;
    HKEY key;
    BOOL migdlls = FALSE;
    BOOL b = TRUE;

    if (ISNT ()) {
        return TRUE;
    }

    if (!pNonemptyFilePresent (MigdllsCab)) {
        return TRUE;
    }

    if (g_DynUpdtStatus->PrepareWinnt32) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessMigdlls: Skipping it due to /%1 switch"), 0, WINNT_U_DYNAMICUPDATESPREPARE);
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        MigdllsCab
        );

    if (!BuildPath (migdllsLocalDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_MIGDLLS)) {
        return FALSE;
    }

    //
    // expand CAB in this dir
    //
    MyDelnode (migdllsLocalDir);
    if (CreateMultiLevelDirectory (migdllsLocalDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, migdllsLocalDir);
        return FALSE;
    }
    if (!MySetupIterateCabinet (MigdllsCab, 0, pExpandCabInDir, (PVOID)migdllsLocalDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, MigdllsCab);
        return FALSE;
    }

    //
    // look for CAB files and expand each one in its own subdir
    //
    if (EnumFirstFilePattern (&e, migdllsLocalDir, TEXT("*.cab"))) {
        do {
            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }
            if (!e.FindData.nFileSizeLow) {
                DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                continue;
            }

            pGetAutoSubdirName (e.FullPath, dirName, ARRAYSIZE(dirName));
            if (CreateMultiLevelDirectory (dirName) != ERROR_SUCCESS) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1; skipping it"), 0, dirName);
                continue;
            }
            //
            // expand CAB in this dir
            //
            if (!MySetupIterateCabinet (e.FullPath, 0, pExpandCabInDir, (PVOID)dirName)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1; skipping it"), 0, e.FullPath);
                continue;
            }

            migdlls = TRUE;

        } while (EnumNextFilePattern (&e));
    }

    if (b && migdlls) {
        //
        // register them
        //
        rc = RegCreateKey (HKEY_LOCAL_MACHINE, S_REGKEY_MIGRATION_DLLS_WIN9X, &key);
        if (rc == ERROR_SUCCESS) {
            rc = RegSetValueEx (key, S_REGVALUE_DYNUPDT, 0, REG_SZ, (CONST BYTE*)migdllsLocalDir, (lstrlen (migdllsLocalDir) + 1) * sizeof (TCHAR));
        }
        if (rc != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to register downloaded migdlls (rc=%1!u!)"), 0, rc);
            b = FALSE;
        }
    }

    return b;
}

#endif


BOOL
ProcessDownloadedFiles (
    OUT     PBOOL StopSetup
    )
{
    TCHAR cabName[MAX_PATH];
    BOOL bClientInstall = FALSE;

    if (g_DynUpdtStatus->UserSpecifiedUpdates && !g_DynUpdtStatus->PrepareWinnt32) {
        bClientInstall = TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Source=%1"),
        0,
        g_DynUpdtStatus->UserSpecifiedUpdates ? g_DynUpdtStatus->DynamicUpdatesSource : TEXT("Windows Update")
        );

    if (!g_DynUpdtStatus->HwdbInitialize) {
        if (CreateMultiLevelDirectory (g_DynUpdtStatus->TempDir) != ERROR_SUCCESS ||
            !pInitializeSupport (S_HWDB_DLL, pLoadHwdbLib, FALSE) ||
            !g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir)
            ) {
            return FALSE;
        }
    }

    if (!Winnt32Restarted ()) {
        if (!BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_WINNT32)) {
            return FALSE;
        }
        if (!pProcessWinnt32Files (cabName, bClientInstall, StopSetup)) {
            return FALSE;
        }
        if (g_DynUpdtStatus->RestartWinnt32) {
            MYASSERT (!g_DynUpdtStatus->PrepareWinnt32);
            return TRUE;
        }
    }

    if (!BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_UPDATES)) {
        return FALSE;
    }

    if (!pProcessUpdates (cabName, bClientInstall, StopSetup)) {
        if (g_DynUpdtStatus->PrepareWinnt32) {
            MessageBoxFromMessage (
                g_DynUpdtStatus->ProgressWindow,
                MSG_ERROR_PROCESSING_UPDATES,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError (),
                cabName
                );
        }

        return FALSE;
    }

    //
    // process New Assemblies on WU
    //
    if (BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_DUASMS)) {
        if (!pProcessDuasms (cabName, bClientInstall)) {
            //
            // don't fail DU if we didn't install them
            //
        }
    }

    if (!BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_UPGINFS)) {
        return FALSE;
    }
    if (!pProcessUpginfs (cabName, bClientInstall)) {
        return FALSE;
    }

#ifdef _X86_

    if (!BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_MIGDLLS)) {
        return FALSE;
    }
    if (!pProcessMigdlls (cabName, bClientInstall)) {
        return FALSE;
    }

#endif

    if (!pProcessNewdrvs (g_DynUpdtStatus->DynamicUpdatesSource, bClientInstall)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Winnt32Restarted (
    VOID
    )
{
    return g_DynUpdtStatus->Winnt32Restarted;
}

BOOL
Winnt32RestartedWithAF (
    VOID
    )
{
    return g_DynUpdtStatus->RestartAnswerFile[0];
}

VOID
pLogWininetError (
    IN      DWORD Error
    )
{
    HMODULE hWinInet = LoadLibraryEx (TEXT("wininet.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hWinInet) {
        HLOCAL msg = NULL;
        if (FormatMessage (
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hWinInet,
                Error,
                0,
                (LPTSTR)&msg,
                0,
                NULL
                ) &&
            msg != NULL
            ) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with wininet error code %1!u!: \"%2\""), 0, Error, msg);
            LocalFree (msg);
        }
        FreeLibrary (hWinInet);
    } else {
        MYASSERT (FALSE);
    }
}


VOID
pLogStandardError (
    IN      DWORD Error
    )
{
    HLOCAL msg = NULL;
    if (FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            Error,
            0,
            (LPTSTR)&msg,
            0,
            NULL
            ) &&
        msg != NULL
        ) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with standard error code %1!u!:\r\n%2"), 0, Error, msg);
        LocalFree (msg);
    }
}

VOID
pUpdateDUStatus (
    IN      DWORD Error
    )
{
    MYASSERT (Error != ERROR_SUCCESS);
    if (Error == ERROR_SUCCESS) {
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        return;
    }
    switch (Error) {
    case ERROR_CONNECTION_UNAVAIL:
        //
        // ask for manual connection
        //
        MYASSERT (g_DynUpdtStatus->DUStatus == DUS_PREPARING);
        g_DynUpdtStatus->DUStatus = DUS_PREPARING_CONNECTIONUNAVAILABLE;
        break;
    case ERROR_INTERNET_INVALID_URL:
    case ERROR_INTERNET_NAME_NOT_RESOLVED:
        //
        // site not available; ask user if they want to retry
        //
        MYASSERT (g_DynUpdtStatus->DUStatus == DUS_PREPARING);
        g_DynUpdtStatus->DUStatus = DUS_PREPARING_INVALIDURL;
        break;
    case ERROR_INVALID_PARAMETER:
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OLD_WIN_VERSION:
    case ERROR_OUTOFMEMORY:
    case ERROR_NO_MORE_ITEMS:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_INVALID_DATA:
    case ERROR_UNSUPPORTED_TYPE:
    case ERROR_INVALID_HANDLE:
        pLogStandardError (Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    case DU_ERROR_MISSING_DLL:
    case DU_NOT_INITIALIZED:
        DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with custom error code %1!u!"), 0, Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    case ERROR_INTERNET_NO_CONTEXT:
        pLogWininetError (Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    default:
        if (Error > INTERNET_ERROR_BASE) {
            pLogWininetError (Error);
        } else {
            pLogStandardError (Error);
        }
    }
}

DWORD
WINAPI
DoDynamicUpdate (
    LPVOID Parameter
    )
{

#define MIN_INTERVAL_BETWEEN_TASKS 3000

    HWND hUIWindow = (HWND)Parameter;
    DWORD rc = ERROR_SUCCESS;
    LONG ticks;
    LONG sleep;
    DWORD estTime, estSize;
    TCHAR drive[4];
    DWORD sectorsPerCluster;
    DWORD bytesPerSector;
    ULARGE_INTEGER freeClusters = {0, 0};
    ULARGE_INTEGER totalClusters = {0, 0};
    DWORD clusterSize;
    ULONGLONG availableBytes;
    HANDLE hEvent;
    BOOL bStopSetup;
    BOOL bContinue = TRUE;

    hEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, S_DU_SYNC_EVENT_NAME);
    if (!hEvent) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("OpenEvent(%1) failed"),
            0,
            S_DU_SYNC_EVENT_NAME
            );
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        goto exit;
    }

    while (bContinue) {

        if (g_DynUpdtStatus->Cancelled) {
            g_DynUpdtStatus->DUStatus = DUS_CANCELLED;
            rc = ERROR_CANCELLED;
            DynamicUpdateUninitialize ();
            break;
        }

        switch (g_DynUpdtStatus->DUStatus) {

        case DUS_INITIAL:
            if (Winnt32Restarted () || g_DynUpdtStatus->UserSpecifiedUpdates) {
                g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
                break;
            }
            g_DynUpdtStatus->DUStatus = DUS_PREPARING;
            SendMessage (hUIWindow, WMX_SETUPUPDATE_PREPARING, 0, 0);
            break;

        case DUS_PREPARING:
            ticks = GetTickCount ();
            if (!DynamicUpdateInitDownload (hUIWindow)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DynamicUpdateInitDownload failed"),
                    0
                    );
                pUpdateDUStatus (GetLastError ());
                if (g_DynUpdtStatus->DUStatus != DUS_SKIP &&
                    g_DynUpdtStatus->DUStatus != DUS_ERROR) {
                    //
                    // the UI thread will decide what the next state will be
                    // based on user's selection
                    //
                    PostMessage (hUIWindow, WMX_SETUPUPDATE_INIT_RETRY, 0, 0);
                    rc = WaitForSingleObject (hEvent, INFINITE);
                    if (rc != WAIT_OBJECT_0) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("WaitForSingleObject failed (%1!u!)"),
                            0,
                            rc
                            );
                        g_DynUpdtStatus->DUStatus = DUS_ERROR;
                        break;
                    }
                }
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
            break;

        case DUS_DOWNLOADING:
            ticks = GetTickCount ();
            estSize = estTime = 0;
            if (!DynamicUpdateStart (&estTime, &estSize)) {
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                break;
            }
            //
            // check if there is enough disk space available for this operation
            //
            MYASSERT(ARRAYSIZE(drive) >= 4);
            lstrcpyn (drive, g_DynUpdtStatus->WorkingDir, 4);
            if (Winnt32GetDiskFreeSpaceNew (
                    drive,
                    &sectorsPerCluster,
                    &bytesPerSector,
                    &freeClusters,
                    &totalClusters
                    )) {
                clusterSize = bytesPerSector * sectorsPerCluster;
                availableBytes = (ULONGLONG)clusterSize * freeClusters.QuadPart;
                //
                // assume the average-worst case where each file occupies 1/2 cluster
                // then the space required is the double of estimated space
                //
                if (availableBytes < (ULONGLONG)estSize * 2) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("DoDynamicUpdate: not enough free space on drive %1 to perform download (available=%2!u! MB, needed=%3!u! MB)"),
                        0,
                        drive,
                        (DWORD)(availableBytes >> 20),
                        (DWORD)(estSize >> 20)
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    DynamicUpdateCancel ();
                    //
                    // wait for the UI thread to signal the event, no more than about a minute
                    //
                    rc = WaitForSingleObject (hEvent, 66000);
                    if (rc == WAIT_TIMEOUT) {
                        //
                        // why?
                        //
                        MYASSERT (FALSE);
                    } else if (rc != WAIT_OBJECT_0) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("WaitForSingleObject failed (%1!u!)"),
                            0,
                            rc
                            );
                    }
                    break;
                }
            }

            SendMessage (hUIWindow, WMX_SETUPUPDATE_DOWNLOADING, estTime, estSize);

            rc = WaitForSingleObject (hEvent, INFINITE);
            if (rc != WAIT_OBJECT_0) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("WaitForSingleObject failed (%1!u!)"),
                    0,
                    rc
                    );
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            //
            // the UI thread has already set the next state,
            // based on the result of download
            //
            break;

        case DUS_PROCESSING:
            ticks = GetTickCount ();
            SendMessage (hUIWindow, WMX_SETUPUPDATE_PROCESSING, 0, 0);
            if (!g_DynUpdtStatus->UserSpecifiedUpdates) {
                MYASSERT(ARRAYSIZE(g_DynUpdtStatus->DynamicUpdatesSource) == ARRAYSIZE(g_DynUpdtStatus->WorkingDir));
                lstrcpy (g_DynUpdtStatus->DynamicUpdatesSource, g_DynUpdtStatus->WorkingDir);
            }
            bStopSetup = FALSE;
            if (!DynamicUpdateProcessFiles (&bStopSetup)) {
                g_DynUpdtStatus->DUStatus = bStopSetup ? DUS_FATALERROR : DUS_ERROR;
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            g_DynUpdtStatus->DUStatus = DUS_SUCCESSFUL;
            break;

        case DUS_SUCCESSFUL:
            if (CheckUpgradeOnly && !g_DynUpdtStatus->RestartWinnt32 && !g_DynUpdtStatus->UserSpecifiedUpdates) {
                if (pSaveLastDownloadInfo ()) {
                    g_DynUpdtStatus->PreserveWorkingDir = TRUE;
                }
            }
            //
            // notify the upgrade module that DU completed with success
            //
            g_DynUpdtStatus->Successful = TRUE;
            //
            // fall through
            //
        case DUS_ERROR:
        case DUS_FATALERROR:
        case DUS_SKIP:
            //
            // always make sure to uninitialize DU
            // if the user had a modem connection active, this should close
            // the connection
            // DynamicUpdateUninitialize () will not reset any DU data
            // in case the processing was successful
            //
            DynamicUpdateUninitialize ();
            bContinue = FALSE;
            break;

        default:
            MYASSERT (FALSE);
        }
    }

    CloseHandle (hEvent);

exit:
    //
    // always notify the UI thread before exiting
    //
    PostMessage (hUIWindow, WMX_SETUPUPDATE_THREAD_DONE, 0, 0);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\dynupdt.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Interface for code that implements the Dynamic Update feature of Winnt32.

Author:

    Ovidiu Temereanca (ovidiut) 06-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/


#define DynUpdtLogLevel     Winnt32LogInformation


#ifdef PRERELEASE
#define TRY
#define EXCEPT(e)   goto __skip;
#define _exception_code() 0
#define END_EXCEPT  __skip:;
#else
#define TRY         __try
#define EXCEPT(e)   __except (e)
#define END_EXCEPT
#endif


#define S_DUCTRL_DLL                    TEXT("wsdu.dll")
#define S_HWDB_DLL                      TEXT("hwdb.dll")

#define S_REGKEY_MIGRATION_DLLS_WIN9X   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Migration DLLs")
#define S_REGVALUE_DYNUPDT              TEXT("DynUpdt")


typedef
BOOL
(CALLBACK* PWIN9XGETINCOMPDRVS) (
    OUT     PSTR** IncompatibleDrivers
    );

typedef
VOID
(CALLBACK* PWIN9XRELEASEINCOMPDRVS) (
    IN      PSTR* IncompatibleDrivers
    );

typedef
DWORD
(* PFNMAPFILEANDCHECKSUM) (
    IN      PTSTR Filename,
    OUT     PDWORD HeaderSum,
    OUT     PDWORD CheckSum
);

typedef enum {
    DUS_INITIAL = 0,
    DUS_SKIP,
    DUS_PREPARING,
    DUS_PREPARING_CONNECTIONUNAVAILABLE,
    DUS_PREPARING_INVALIDURL,
    DUS_DOWNLOADING,
    DUS_DOWNLOADING_ERROR,
    DUS_PROCESSING,
    DUS_SUCCESSFUL,
    DUS_CANCELLED,
    DUS_ERROR,
    DUS_FATALERROR,
} DUS_STATUS;

typedef struct {
    DUS_STATUS DUStatus;
    BOOL Disabled;
    BOOL SupportQueried;
    BOOL SupportPresent;
    BOOL RestartWinnt32;
    BOOL PrepareWinnt32;
    BOOL Winnt32Restarted;
    BOOL Cancelled;
    BOOL PreserveWorkingDir;
    BOOL ForceRemoveWorkingDir;
    BOOL Successful;
    PTSTR RestartCmdLine;
    TCHAR RestartAnswerFile[MAX_PATH];
    TCHAR DynamicUpdatesSource[MAX_PATH];
    TCHAR UpdatesPath[MAX_PATH];
    TCHAR UpdatesCabSource[MAX_PATH];
    TCHAR UpdatesCabTarget[MAX_PATH];
    TCHAR DuasmsSource[MAX_PATH];
    TCHAR DuasmsTarget[MAX_PATH];
    TCHAR WorkingDir[MAX_PATH];
    TCHAR DriversSource[MAX_PATH];
    TCHAR SelectedDrivers[MAX_PATH];
    TCHAR GuidrvsInfSource[MAX_PATH];
    BOOL UserSpecifiedUpdates;
    TCHAR Winnt32Path[MAX_PATH];
    TCHAR TempDir[MAX_PATH];
    PSDLIST NewDriversList;
    PSTRINGLIST BootDriverPathList;
    DWORD IncompatibleDriversCount;
    //
    // target OS information
    //
    OSVERSIONINFOEX TargetOsVersion;
    TCHAR TargetPlatform[32];               // "i386", "ia64"
    LCID TargetLCID;
    //
    // compression/decompression support
    //
    HANDLE Diamond;
    //
    // Support libraries stuff
    //
    HWND ProgressWindow;

    HANDLE DuLib;
    HANDLE Connection;

    PDUISSUPPORTED DuIsSupported;
    PDUINITIALIZE DuInitialize;
    PDUDODETECTION DuDoDetection;
    PDUQUERYUNSUPDRVS DuQueryUnsupDrvs;
    PDUBEGINDOWNLOAD DuBeginDownload;
    PDUABORTDOWNLOAD DuAbortDownload;
    PDUUNINITIALIZE DuUninitialize;


    HANDLE HwdbLib;
    HANDLE HwdbDatabase;

    PHWDBINITIALIZE HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPEN HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFS HwdbAppendInfs;
    PHWDBFLUSH HwdbFlush;
    PHWDBHASDRIVER HwdbHasDriver;
    PHWDBHASANYDRIVER HwdbHasAnyDriver;
#ifndef UNICODE
    PWIN9XGETINCOMPDRVS Win9xGetIncompDrvs;
    PWIN9XRELEASEINCOMPDRVS Win9xReleaseIncompDrvs;
#endif

    HANDLE ImagehlpDll;
    PFNMAPFILEANDCHECKSUM IhMapFileAndCheckSum;
} DYNUPDT_STATUS, *PDYNUPDT_STATUS;

extern PDYNUPDT_STATUS g_DynUpdtStatus;



typedef struct {
    PCTSTR DownloadRoot;
    POSVERSIONINFOEX TargetOsVersion;
    PCTSTR TargetPlatform;                  // "i386", "ia64"
    LCID TargetLCID;
    BOOL Upgrade;
    PCTSTR* SourceDirs;
    DWORD SourceDirsCount;
    BOOL Unattend;
    PCTSTR AnswerFile;
    HWND ProgressWindow;
    PTSTR TempDir;
} DYNUPDT_INIT, *PDYNUPDT_INIT;


typedef struct {
    TCHAR BaseDir[MAX_PATH];
} DYNUPDTSTATUS_INFO, *PDYNUPDTSTATUS_INFO;


typedef struct {
    BOOL ExpressUpgrade;        // WelcomeWizPage
    TCHAR OemPid[30];           // OemPid30WizPage
    TCHAR CdPid[30];            // CdPid30WizPage
} RESTART_DATA, *PRESTART_DATA;

extern RESTART_DATA g_RestartData;

#define S_DOWNLOAD_ROOT         TEXT("setupupd")
#define S_CABNAME_UPDATES       TEXT("updates.cab")
#define S_CABNAME_UPGINFS       TEXT("upginfs.cab")
#define S_CABNAME_MIGDLLS       TEXT("migdlls.cab")
#define S_CABNAME_WINNT32       TEXT("winnt32.cab")
#define S_CABNAME_IDENT         TEXT("ident.cab")
#define S_CABNAME_WSDUENG       TEXT("wsdueng.cab")
#define S_CABNAME_DUASMS        TEXT("duasms.cab")
#define S_SUBDIRNAME_UPDATES    TEXT("updates")
#define S_SUBDIRNAME_UPGINFS    TEXT("upginfs")
#define S_SUBDIRNAME_MIGDLLS    TEXT("migdlls")
#define S_SUBDIRNAME_WINNT32    TEXT("winnt32")
#define S_SUBDIRNAME_DUASMS     TEXT("duasms")
#define S_SUBDIRNAME_TEMP       TEXT("temp")
#define S_SUBDIRNAME_DRIVERS    TEXT("dudrvs")
#define S_SECTIONNAME_UPDATES   TEXT("updates")
#define S_RESTART_TXT           TEXT("restart.txt")
#define S_PATCH_FILE_EXT        TEXT("*._p1")
#define S_HWCOMP_DAT            TEXT("hwcomp.dat")
#define S_GUI_DRIVERS_INF       TEXT("guidrvs.inf")
#define S_SECTION_VERSION       TEXT("Version")
#define S_SECTION_DRIVERS       TEXT("Drivers")
#define S_SECTION_EXCLUDED_DRVS TEXT("ExcludedDrivers")
#define S_DRIVER_TYPE_KEY       TEXT("DriversAreGuiApproved")
#define S_DU_SYNC_EVENT_NAME    TEXT("_WINNT32_DU_")
//
// if this file is present in winnt32.cab, Setup will restart unconditionally
//
#define S_RESTART_FILENAME      TEXT("winnt32.rst")
//
// if this file is present in updates.cab, Setup will create a local source directory
//
#define S_MAKE_LS_FILENAME      TEXT("updates.~ls")

#define DYN_DISKSPACE_PADDING   10000000

BOOL
DynamicUpdateInitialize (
    VOID
    );

VOID
DynamicUpdateUninitialize (
    VOID
    );

BOOL
DynamicUpdateBuildDefaultPaths (
    VOID
    );

BOOL
DynamicUpdateIsSupported (
    IN      HWND ParentWnd
    );

BOOL
__inline
DynamicUpdateSuccessful (
    VOID
    )
{
    return g_DynUpdtStatus && g_DynUpdtStatus->Successful;
}

DWORD
WINAPI
DoDynamicUpdate (
    LPVOID Parameter
    );

BOOL
DynamicUpdateInitDownload (
    IN      HWND hNotifyWnd
    );

BOOL
DynamicUpdateStart (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

VOID
DynamicUpdateCancel (
    VOID
    );

BOOL
DynamicUpdateProcessFiles (
    OUT     PBOOL StopSetup
    );

BOOL
DynamicUpdateWriteParams (
    IN      PCTSTR ParamsFile
    );

BOOL
DynamicUpdatePrepareRestart (
    VOID
    );

BOOL
Winnt32Restarted (
    VOID
    );

BOOL
Winnt32RestartedWithAF (
    VOID
    );

BOOL
WINAPI
Winnt32DuIsSupported (
    VOID
    );

typedef
BOOL
(WINAPI* PWINNT32DUISSUPPORTED) (
    IN      PCTSTR* SourceDirs,
    IN      DWORD Count
    );


BOOL
WINAPI
Winnt32DuInitialize (
    IN      PDYNUPDT_INIT InitData
    );

typedef
BOOL
(WINAPI* PWINNT32DUINITIALIZE) (
    IN      PDYNUPDT_INIT InitData
    );


BOOL
WINAPI
Winnt32DuInitiateGetUpdates (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	);

typedef
BOOL
(WINAPI* PWINNT32DUINITIATEGETUPDATES) (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	);


VOID
WINAPI
Winnt32DuCancel (
    VOID
    );

typedef
VOID
(WINAPI* PWINNT32DUCANCEL) (
    VOID
    );


BOOL
WINAPI
Winnt32DuProcessFiles (
    OUT     PBOOL StopSetup
    );

typedef
BOOL
(WINAPI* PWINNT32DUPROCESSFILES) (
    );


BOOL
WINAPI
Winnt32DuWriteParams (
    IN      PCTSTR ParamsFile
    );

typedef
BOOL
(WINAPI* PWINNT32DUWRITEPARAMS) (
    IN      PCTSTR ParamsFile
    );


VOID
WINAPI
Winnt32DuUninitialize (
    VOID
    );

typedef
VOID
(WINAPI* PWINNT32DUUNINITIALIZE) (
    VOID
    );

BOOL
BuildSifName (
    IN      PCTSTR CabName,
    OUT     PTSTR SifName,
    IN      UINT CchSifName
    );

BOOL
ProcessDownloadedFiles (
    OUT     PBOOL StopSetup
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\incompat.c ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    incompat.cpp
//
// Abstract:
//    This file implements compatibility checking for various components.
//    The functions get executed by winnt32. It's purpose is to alert the user to possible
//    incompatibilities that may be encountered after performing an upgrade.
//
//
// Author:
//    matt thomlinson (mattt)
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma hdrstop

HRESULT CertSrv_TestForIllegalUpgrade(BOOL *pfComplain);
extern HINSTANCE hInst;






/////////////////////////////////////////////////////////////////////////////
//++
//
// CertificateServerUpgradeCompatibilityCheck
//
// Routine Description:
//    This is the exported function, called to check for incompatibilities when
//    upgrading the machine. 
// 
//    Behavior: If Certificate server is installed on NT4, we wish to warn the user.
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no incompatibility was detected or that
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CertificateServerUpgradeCompatibilityCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
     BOOL  fReturnValue = (BOOL) TRUE;
     BOOL fComplain;

     // Is this an illegal upgrade?
     if ((S_OK == CertSrv_TestForIllegalUpgrade(&fComplain)) &&
         fComplain)
     {
        // It is necessary to display a compatibility warning.
        
        TCHAR tszDescription[MAX_PATH];       // size is arbitrary

        COMPATIBILITY_ENTRY  CompatibilityEntry;
        ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );
        
        // Set the Description string.
        
        *tszDescription = TEXT( '\0' );

        LoadString( hInst,
                    IDS_CERTSRV_UPGRADE_WARNING,
                    tszDescription,
                    ARRAYSIZE(tszDescription));

        // Build the COMPATIBILITY_ENTRY structure to pass to *pfnCompatibilityCallback().
        CompatibilityEntry.Description = tszDescription;
        // Set the HTML file name.             
        CompatibilityEntry.HtmlName = TEXT( "compdata\\certsrv.htm" );
        // Set the TEXT file name.             
        CompatibilityEntry.TextName = TEXT( "compdata\\certsrv.txt" );

        // Execute the callback function.
        fReturnValue = pfnCompatibilityCallback( (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                                                 pvContext );
     }
     else
     {
        // It is not necessary to display a compatibility warning.

        fReturnValue = (BOOL) TRUE;
     } // Is it necessary to display a compatibility warning?
  
   return ( fReturnValue );
}



HRESULT CertSrv_TestForIllegalUpgrade(BOOL *pfComplain)
{
    HRESULT hr = S_OK;
    SC_HANDLE hSC=NULL, hSvc=NULL;
    OSVERSIONINFO osVer;

    // only complain about NT4 certsvr upgrades

    *pfComplain = FALSE;
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(! GetVersionEx(&osVer) )
    {   
        // error getting version, can't be NT4
        hr = GetLastError(); 
        goto error;
    }

    if ((osVer.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
        (osVer.dwMajorVersion != 4))
    {
        goto NoComplaint;
        // not NT4, must be ok
    }

    // now the hard part -- open the service to see if it exists
    hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (hSC == NULL)
    {
        hr = GetLastError();
        goto error;
    }

    hSvc = OpenService(hSC, TEXT("CertSvc"), SERVICE_QUERY_CONFIG);
    if (hSvc == NULL)
    {
       hr = GetLastError();
       if (ERROR_SERVICE_DOES_NOT_EXIST == hr)
            goto NoComplaint;
       goto error;
    }

    // failed version check and service is installed 
    *pfComplain = TRUE;
            
NoComplaint:
    hr = S_OK;

error:

    if (NULL != hSC)
        CloseServiceHandle(hSC);

    if (NULL != hSvc)
        CloseServiceHandle(hSvc);

    return hr;
}

BOOL
IsStandardServerSKU(
    PBOOL pIsServer
    )
/////////////////////////////////////////////////////////////////////////////
//++
//
// IsStandardServerSKU
//
// Routine Description:
//    This routine determines if the user is running the standard server
//    SKU
// 
//
// Arguments:
//    pIsServer - indicates if the server is the standard server SKU
//                or not.
//
// Return Value:
//    Indicates success of the check
//
//--
/////////////////////////////////////////////////////////////////////////////
{
    BOOL  fReturnValue = (BOOL) FALSE;
    OSVERSIONINFOEX  VersionInfo;
    BOOL  IsServer = FALSE;

     //
     // get the current SKU.
     //
     VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
     if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
         fReturnValue = TRUE; 
         //
         // is it some sort of server SKU?
         //
         if (VersionInfo.wProductType != VER_NT_WORKSTATION) {
    
             //
             // standard server or a server variant?
             //
             if ((VersionInfo.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) == 0) {
                 //
                 // it's standard server
                 //
                 IsServer = TRUE;
             }
    
         }

         *pIsServer = IsServer;

     }

     return(fReturnValue);

}


#if 0

/////////////////////////////////////////////////////////////////////////////
//++
//
// ProcessorUpgradeCompatibilityCheck
//
// Routine Description:
//    This is the exported function, called to check for incompatibilities when
//    upgrading the machine. 
// 
//    Behavior: If the current processor count is > that allowed after upgrade,
//              a warning is generated.
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no incompatibility was detected or that
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL ProcessorUpgradeCompatibilityCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
     BOOL  fReturnValue = (BOOL) TRUE;
     BOOL fComplain = FALSE;
     BOOL IsServer = FALSE;
     SYSTEM_INFO SysInfo;
     ULONG SourceSkuId;
     ULONG DontCare;

     
     //
     // we only care about standard server SKU.
     //
     SourceSkuId = DetermineSourceProduct(&DontCare,NULL);

     if ( SourceSkuId == COMPLIANCE_SKU_NTSFULL || SourceSkuId == COMPLIANCE_SKU_NTSU) {
         //
         // we only allow 2 processors on standard server.
         //
         DWORD AllowedCount = 2;

         GetSystemInfo(&SysInfo);
         if (SysInfo.dwNumberOfProcessors > AllowedCount) {
             fComplain = TRUE;
         }                      
     }

     // Is this an illegal upgrade?
     if (fComplain)
     {
        // It is necessary to display a compatibility warning.
        
        TCHAR tszDescription[MAX_PATH];       // size is arbitrary

        COMPATIBILITY_ENTRY  CompatibilityEntry;
        ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );
        
        // Set the Description string.
        
        *tszDescription = TEXT( '\0' );

        LoadString( hInst,
                    IDS_PROCESSOR_UPGRADE_WARNING,
                    tszDescription,
                    ARRAYSIZE(tszDescription) );

        // Build the COMPATIBILITY_ENTRY structure to pass to *pfnCompatibilityCallback().
        CompatibilityEntry.Description = tszDescription;
        // Set the HTML file name.             
        CompatibilityEntry.HtmlName = TEXT( "compdata\\proccnt.htm" );
        // Set the TEXT file name.             
        CompatibilityEntry.TextName = TEXT( "compdata\\proccnt.txt" );

        // Execute the callback function.
        fReturnValue = pfnCompatibilityCallback( (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                                                 pvContext );
     }
     else
     {
        // It is not necessary to display a compatibility warning.

        fReturnValue = (BOOL) TRUE;
     } // Is it necessary to display a compatibility warning?
  
   return ( fReturnValue );
}

#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
// IntelProcessorPteCheck
//
// Routine Description:
//    This is the exported function, called to check for Intel PTE Errata when
//    upgrading the machine. 
// 
//    Behavior: This PTE errata (EFLAGS may be incorrect after a MP TLB 
//              shootdown) exists on Pentium-Pro steppings upto 619 (errata 69)
//              and Pentium II steppings upto 634 (errata A27). If a MP
//              system has these processors, a warning is generated to 
//              let user know that the system will be brought up 
//              uni-processor after the install
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no processor with incompatibility was 
//             detected or a processor with incompatibility was detected but 
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL IntelProcessorPteCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
     BOOL       fReturnValue = (BOOL) TRUE;
     BOOL       fComplain = FALSE;
     SYSTEM_INFO SysInfo;
     WORD       ProcessorFamily;
     WORD       ProcessorModel;
     WORD       ProcessorStepping;

     //
     // If there are more than one Intel processors and processor steppings
     // with PTE errata are found, let user know about it
     //
     GetSystemInfo(&SysInfo);
     if ((SysInfo.dwNumberOfProcessors > 1) &&
         (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)) {

         //
         // Get Processor Family, Model and Stepping info
         //
         ProcessorFamily = SysInfo.wProcessorLevel;
         ProcessorModel = ((SysInfo.wProcessorRevision & 0xff00) >> 8);
         ProcessorStepping = SysInfo.wProcessorRevision & 0xff;

         if (ProcessorFamily == 6) {
             if ( ((ProcessorModel == 1) && (ProcessorStepping <= 9)) ||
                  ((ProcessorModel == 3) && (ProcessorStepping <= 4)) ) {
                 //
                 // There is at least one processor on the system with errata
                 //
                 fComplain = TRUE;
             }
         }
     }

     // Is this an illegal upgrade?
     if (fComplain)
     {
        // It is necessary to display a compatibility warning.
        
        TCHAR tszDescription[MAX_PATH];       // size is arbitrary

        COMPATIBILITY_ENTRY  CompatibilityEntry;
        ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );
        
        // Set the Description string.
        
        *tszDescription = TEXT( '\0' );

        LoadString( hInst,
                    IDS_INTEL_PROCESSOR_PTE_WARNING,
                    tszDescription,
                    ARRAYSIZE(tszDescription));

        // Build the COMPATIBILITY_ENTRY structure to pass to 
        // *pfnCompatibilityCallback().
        CompatibilityEntry.Description = tszDescription;
        CompatibilityEntry.HtmlName = TEXT("compdata\\intelup.htm");
        CompatibilityEntry.TextName = TEXT("compdata\\intelup.txt");

        // Execute the callback function.
        fReturnValue = pfnCompatibilityCallback( 
                            (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                            pvContext
                            );
     }
     else
     {
        // It is not necessary to display a compatibility warning.

        fReturnValue = (BOOL) TRUE;
     } // Is it necessary to display a compatibility warning?
  
   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\inspect.c ===
#include "precomp.h"
#pragma hdrstop

#include <stdio.h>


BOOL
LoadInfs(
    IN HWND hdlg
    );

BOOL
BuildCopyList(
    IN HWND hdlg
    );



BOOL
LoadAndRunMigrationDlls (
    HWND hDlg
    );


BOOL
ProcessCompatibilityData(
    HWND hDlg
    );

DWORD
ProcessCompatibilitySection(
    LPVOID InfHandle,
    LPTSTR SectionName
    );


DWORD
InspectAndLoadThread(
    IN PVOID ThreadParam
    )
{
    HWND hdlg;
    BOOL b;

    //
    // Thread parameter is the handle of the page in the wizard.
    //
    hdlg = ThreadParam;
    b = FALSE;

    //
    // If we're running the upgrade checker, fixup the title
    // right away.
    //
    if (CheckUpgradeOnly) {
        FixUpWizardTitle(GetParent(hdlg));
        PropSheet_SetTitle(GetParent(hdlg),0,UIntToPtr( IDS_APPTITLE_CHECKUPGRADE ));
    }

    //
    // Step 1: delete existing local sources.
    //
    CleanUpOldLocalSources(hdlg);

#ifdef _X86_ //NEC98
    //
    // If NEC98, Backup NT4 files
    // boot.ini, NTLDR, NTDETECT
    //
    if (IsNEC98() && Floppyless)
    {
        SaveRestoreBootFiles_NEC98(NEC98SAVEBOOTFILES);
    }
#endif //NEC98

    //
    // Step 2: inspect for HPFS, etc.
    //
    if(!InspectFilesystems(hdlg)) {
        Cancelled = TRUE;
    } else {

        //
        // Step 3: load inf(s).
        //
        if(LoadInfs(hdlg)) {

            //
            // Put in an "|| CheckUpgradeOnly" on these
            // function calls because if we're really only
            // checking the ability to upgrade, we want
            // to continue even if one of these guys fails.
            //

            //
            // Step 4: Check memory resources.
            //
            if( EnoughMemory( hdlg, FALSE ) || CheckUpgradeOnly ) {

                //
                // check for services to disable
                //
                ProcessCompatibilityData(hdlg);

#if defined(UNICODE) && defined(_X86_)

                //
                // Run Migration DLLs.
                //
                LoadAndRunMigrationDlls (hdlg);


#endif

                //
                // migrate any important data in boot.ini (like the countdown)
                //
                if (Upgrade) {
                    if (IsArc()) {
                        MigrateBootVarData();
                    } else {
#if defined(_AMD64_) || defined(_X86_)
                        MigrateBootIniData();
#endif
                    }
                }

                //
                // Step 5: build the master file copy list.
                //
                if(CheckUpgradeOnly || BuildCopyList(hdlg)) {

                    //
                    // Step 6: look for a valid local source and check disk space.
                    //
                    if(FindLocalSourceAndCheckSpace(hdlg, FALSE, 0) || CheckUpgradeOnly) {

                        //
                        // Step 7:
                        //
                        // At this point we actually know everything we need to know
                        // in order to pass parameters to text mode setup.
                        //
                        if( CheckUpgradeOnly ) {
                            b = TRUE;
                        } else {
                            b = WriteParametersFile(hdlg);

                            if (IsArc()) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                                if(b) {
                                    TCHAR Text[128];

                                    LoadString(hInst,IDS_SETTING_NVRAM,Text,sizeof(Text)/sizeof(TCHAR));
                                    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

                                    b = SetUpNvRam(hdlg);
                                }
#endif // UNICODE
                            } // if (IsArc())
                        }

#ifdef UNICODE

#if defined(_AMD64_) || defined(_X86_)
                        if( b && (Upgrade || BuildCmdcons) && Floppyless)
#else
                        if( b && Upgrade )                        
#endif
                           {
                            //
                            //  Do the migration of unsupported NT drivers.
                            //  We can ignore the return code, since the fuction will inform the user if
                            //  migration could not be done.
                            //
                            MigrateUnsupportedNTDrivers( hdlg, TxtsetupSif );
                        }
#endif // UNICODE
                    }
                }

                if(!b) {
                    UnloadInfFile(MainInf);
                    MainInf = NULL;
                    if(TxtsetupSif) {
                        UnloadInfFile(TxtsetupSif);
                        TxtsetupSif = NULL;
                    }
                }
            }
        }
    }

    PostMessage(hdlg,WMX_INSPECTRESULT,(CheckUpgradeOnly ? TRUE : b),0);
    return(0);
}

#if defined(UNICODE) && defined(_X86_)

LIST_ENTRY g_HandledData;
TCHAR g_MigDllAnswerFilePath[MAX_PATH];
DWORD GlobalCompFlags;
UINT g_MigDllIndex = 0;


#define HANDLED_REGISTRY  1
#define HANDLED_FILE  2
#define HANDLED_SERVICE  3

typedef struct {

    LIST_ENTRY ListEntry;

    LONG Type;

    PCTSTR RegKey;
    PCTSTR RegValue;
    PCTSTR File;
    PCTSTR Service;

} HANDLED_DATA, *PHANDLED_DATA;


BOOL
ResolveHandledIncompatibilities (
    VOID
    )
{
    //
    // At this point, all incompatibilities that will exist in the list are in place.
    // we can now compare this with our list of handled data and remove
    // anything a migration dll is taking care of.
    //
    PLIST_ENTRY     nextHandled;
    PLIST_ENTRY     nextCompData;
    PHANDLED_DATA   handledData;
    PCOMPATIBILITY_DATA compData;
    BOOL remove;

    nextHandled = g_HandledData.Flink;

    if (!nextHandled) {
        return TRUE;
    }

    while ((ULONG_PTR)nextHandled != (ULONG_PTR)&g_HandledData) {

        handledData = CONTAINING_RECORD (nextHandled, HANDLED_DATA, ListEntry);
        nextHandled = handledData->ListEntry.Flink;

        nextCompData = CompatibilityData.Flink;
        if (!nextCompData) {
            return TRUE;
        }

        while ((ULONG_PTR)nextCompData != (ULONG_PTR)&CompatibilityData) {

            compData = CONTAINING_RECORD (nextCompData, COMPATIBILITY_DATA, ListEntry);
            nextCompData = compData->ListEntry.Flink;
            remove = FALSE;

            if (handledData->Type == HANDLED_REGISTRY && compData->RegKey && *compData->RegKey) {

                if (!lstrcmpi (compData->RegKey, handledData->RegKey)) {

                    if (!handledData->RegValue || !lstrcmpi (compData->RegValue, handledData->RegValue)) {
                        remove = TRUE;

                    }
                }
            }

            if (handledData->Type == HANDLED_SERVICE && compData->ServiceName && *compData->ServiceName) {

                if (!lstrcmpi (compData->ServiceName, handledData->Service)) {
                    remove = TRUE;

                }
            }

            if (handledData->Type == HANDLED_FILE && compData->FileName && *compData->FileName) {

                if (!lstrcmpi (compData->FileName, handledData->File)) {
                    remove = TRUE;
                }
            }

            //
            // Migration dll has handled something. Remove it from the compatibility list.
            //
            if (remove) {

                RemoveEntryList (&compData->ListEntry);
            }
        }
    }

    return TRUE;
}


BOOL
CallMigDllEntryPoints (
    PMIGDLLENUM Enum
    )
{
    MIGRATIONDLL dll;
    BOOL b = FALSE;

    if (!MigDllOpen (&dll, Enum->Properties->DllPath, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
        return FALSE;
    }


    __try {

        if (!MigDllInitializeSrc (
            &dll,
            Enum->Properties->WorkingDirectory,
            NativeSourcePaths[0],
            Enum->Properties->SourceMedia,
            NULL,
            0
            )) {

            __leave;
        }

        if (!MigDllGatherSystemSettings (
            &dll,
            g_MigDllAnswerFilePath,
            NULL,
            0
            )) {

            __leave;
        }

        b = TRUE;
    }
    __finally {
        MigDllClose (&dll);
    }


    return b;
}



BOOL
ParseMigrateInf (
    PCWSTR MigInfPath
    )
{

    PVOID migInf = NULL;
    LONG lineCount;
    LONG i;
    PCTSTR type;
    PHANDLED_DATA data;
    PCTSTR regKey;
    PCTSTR regValue;
    PCTSTR file;
    PCTSTR service;


    if (LoadInfFile (MigInfPath, FALSE, &migInf) != ERROR_SUCCESS) {
        return FALSE;
    }




    __try {

        //
        // Add any compatibility items to the list.
        //
        if( !CompatibilityData.Flink ) {
            InitializeListHead( &CompatibilityData );
        }

        GlobalCompFlags = COMPFLAG_STOPINSTALL;
        CompatibilityCount += ProcessCompatibilitySection (migInf, TEXT("ServicesToStopInstallation") );
        if (CompatibilityCount) {
            IncompatibilityStopsInstallation = TRUE;
        }

        GlobalCompFlags = 0;
        CompatibilityCount += ProcessCompatibilitySection (migInf, TEXT("ServicesToDisable") );

        //
        // Add Handled compatibility items to the list.
        //

        lineCount = InfGetSectionLineCount (migInf, TEXT("Handled"));

        if (lineCount && lineCount != -1) {

            for (i=0; i < lineCount; i++) {

                type = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 0);
                if (!type) {
                    continue;
                }

                if (!lstrcmpi (type, TEXT("Registry"))) {

                    regKey = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    regValue = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 2);

                    if (regKey && *regKey) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_REGISTRY;
                        data->RegKey = regKey;
                        data->RegValue = regValue;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
                else if (!lstrcmpi (type, TEXT("File"))) {

                    file = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    if (file && *file) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_FILE;
                        data->File = file;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
                else if (!lstrcmpi (type, TEXT("Service"))) {

                    service = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    if (service && *service) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_SERVICE;
                        data->Service = service;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
            }
        }
    }
    __finally {

        UnloadInfFile (migInf);

    }

    return TRUE;
}

VOID
SearchDirForMigDlls (
    PCTSTR SearchDir,
    PCTSTR BaseDir,
    DLLLIST List

    )
{
    HANDLE findHandle;
    WIN32_FIND_DATA findData;
    MIGRATIONDLL dll;
    WCHAR path[MAX_PATH];
    PWSTR p;
    WCHAR searchPath[MAX_PATH];
    PMIGRATIONINFO migInfo;
    PMIGDLLPROPERTIES dllProps = NULL;
    WCHAR workingDir[MAX_PATH];

    if (FAILED(StringCchCopy(searchPath, ARRAYSIZE(searchPath), SearchDir)))
    {
        return;
    }

    if (!ConcatenatePaths (searchPath, TEXT("*"), MAX_PATH))
    {
        return;
    }

    findHandle = FindFirstFile (searchPath, &findData);
    if (findHandle != INVALID_HANDLE_VALUE) {

        if (SUCCEEDED(StringCchCopy(path, ARRAYSIZE(path), SearchDir))) {
            //
            //StringCchCopy return S_OK only when dest string null terminated
            //
            p = _tcschr (path, 0);
            MYASSERT(p);

            do {

                if (!lstrcmpi (findData.cFileName, TEXT("migrate.dll"))) {

                    *p = 0;
                    if (!ConcatenatePaths (path, findData.cFileName, MAX_PATH)) {
                        continue;
                    }

                    if (!MigDllOpen (&dll, path, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
                        continue;
                    }

                    if (!MigDllQueryMigrationInfo (&dll, TEXT("c:\\"), &migInfo)) {
                        MigDllClose (&dll);
                        continue;
                    }

                    if (migInfo->SourceOs == OS_WINDOWS9X || migInfo->TargetOs != OS_WINDOWSWHISTLER) {
                        continue;
                    }

                    //
                    // Do we already have a version of this migration dll?
                    //
                    dllProps = MigDllFindDllInList (List, migInfo->StaticProductIdentifier);

                    if (dllProps && dllProps->Info.DllVersion >= migInfo->DllVersion) {
                        MigDllClose (&dll);
                        continue;
                    }
                    else if (dllProps) {

                        MigDllRemoveDllFromList (List, migInfo->StaticProductIdentifier);
                    }

                    //
                    // Move dll locally.
                    //
                    StringCchPrintf(workingDir, ARRAYSIZE(workingDir), TEXT("%s\\mig%u"), BaseDir, g_MigDllIndex);
                    g_MigDllIndex++;

                    MigDllMoveDllLocally (&dll, workingDir);



                    //
                    // Add the dll to the list.
                    //
                    MigDllAddDllToList (List, &dll);
                    MigDllClose (&dll);
                }
                else if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && *findData.cFileName != TEXT('.')) {

                    *p = 0;

                    //Don't want to infinitely recurse
                    if (ConcatenatePaths (path, findData.cFileName, MAX_PATH))
                    {
                        SearchDirForMigDlls (path, BaseDir, List);
                    }
                }

            } while (FindNextFile (findHandle, &findData));
        }

        FindClose (findHandle);
    }
}

#endif // UNICODE

#if defined(UNICODE) && defined(_X86_)

BOOL
LoadAndRunMigrationDlls (
    HWND hDlg
    )
{
//    HKEY regKey = NULL;
//    DWORD index;
//    DWORD nameSize;
//    DWORD valueSize;
//    DWORD type;
//    TCHAR valueName[MAX_PATH];
//    TCHAR value[MAX_PATH];
//    TCHAR workingDir[MAX_PATH];
//    LONG rc;
    TCHAR baseDir[MAX_PATH];
    PTSTR p;
    DLLLIST list = NULL;
    MIGRATIONDLL dll;
    PMIGDLLPROPERTIES dllProps = NULL;
    MIGDLLENUM e;
    PMIGRATIONINFO migInfo;
    TCHAR migInfPath[MAX_PATH];
    HANDLE migInf;
    TCHAR searchDir[MAX_PATH];
    TCHAR tempDir[MAX_PATH];

    *g_MigDllAnswerFilePath = 0;

    //
    // NT Upgrades only.
    //
    if (!ISNT() || !Upgrade) {
        return TRUE;
    }

/*NTBUG9:394164
    //
    // Win2k > Upgrades only.
    //
    if (BuildNumber <= NT40) {
        return TRUE;
    }
*/
    __try {

        if (!MigDllInit ()) {
            return TRUE;
        }

        list = MigDllCreateList ();
        if (!list) {
            return TRUE;
        }

        InitializeListHead (&g_HandledData);

        MyGetWindowsDirectory (baseDir, MAX_PATH);
        ConcatenatePaths (baseDir, TEXT("Setup"), MAX_PATH);
        if (!CreateDirectoryW (baseDir, NULL) && 
            GetLastError() != ERROR_ALREADY_EXISTS){
            return FALSE;
        }
        //
        // ISSUE: we never delete this temp directory!
        //
        lstrcpy (g_MigDllAnswerFilePath, baseDir);
        lstrcpy (tempDir, baseDir);
        ConcatenatePaths (g_MigDllAnswerFilePath, TEXT("migdll.txt"), MAX_PATH);
        if(ActualParamFile[0]){
            CopyFile(ActualParamFile, g_MigDllAnswerFilePath, FALSE);
        }

/*        //
        // Scan registry for migration dlls and load them.
        //
        if (RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                S_REGKEY_MIGRATION_DLLS_WINNT,
                0,
                KEY_READ | KEY_WRITE,
                &regKey
                ) == ERROR_SUCCESS) {
            //
            // Enumerate Values.
            //
            index = 0;
            do {

                nameSize = MAX_PATH;
                valueSize = MAX_PATH * sizeof (TCHAR);

                rc = RegEnumValue (
                            regKey,
                            index,
                            valueName,
                            &nameSize,
                            NULL,
                            &type,
                            (PBYTE) value,
                            &valueSize
                            );

                index++;

                if (rc == ERROR_MORE_DATA) {
                    continue;
                }

                if (rc == ERROR_NO_MORE_ITEMS) {
                    break;
                }

                if (rc != ERROR_SUCCESS) {
                    return TRUE;
                }

                if (!MigDllOpen (&dll, value, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
                    continue;
                }

                if (!MigDllQueryMigrationInfo (&dll, tempDir, &migInfo)) {
                    MigDllClose (&dll);
                    continue;
                }

                if (migInfo->SourceOs == OS_WINDOWS9X || migInfo->TargetOs != OS_WINDOWSWHISTLER) {
                    continue;
                }

                //
                // Do we already have a version of this migration dll?
                //
                dllProps = MigDllFindDllInList (list, migInfo->StaticProductIdentifier);

                if (dllProps && dllProps->Info.DllVersion >= migInfo->DllVersion) {
                    MigDllClose (&dll);
                    continue;
                }
                else {

                    MigDllRemoveDllFromList (list, migInfo->StaticProductIdentifier);
                }

                //
                // Move dll locally.
                //
                wsprintf (workingDir, TEXT("%s\\mig%u"), baseDir, g_MigDllIndex);
                g_MigDllIndex++;

                MigDllMoveDllLocally (&dll, workingDir);
                //
                // Add the dll to the list.
                //
                MigDllAddDllToList (list, &dll);
                MigDllClose (&dll);

            } while (1);
        }*/

        //
        // Now, look for dlls shipped with the source.
        //
        if (!MyGetModuleFileName (NULL, searchDir, ARRAYSIZE(searchDir))) {
            __leave;
        }
        p = _tcsrchr (searchDir, TEXT('\\'));
        if (p) {
            p++;
            StringCchCopy (p, searchDir + ARRAYSIZE(searchDir) - p, TEXT("WINNTMIG"));
        }

        SearchDirForMigDlls (searchDir, baseDir, list);

        //
        // All dlls are now in the list. Lets run them.
        //
        ConcatenatePaths (baseDir, TEXT("dlls.inf"), MAX_PATH);
        if (MigDllEnumFirst (&e, list)) {

            WritePrivateProfileString (
                TEXT("Version"),
                TEXT("Signature"),
                TEXT("\"$Windows NT$\""),
                baseDir
                );

            do {

                StringCchPrintf (migInfPath, ARRAYSIZE(migInfPath), TEXT("%s\\migrate.inf"), e.Properties->WorkingDirectory);
                migInf = CreateFile (
                            migInfPath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

                if (migInf == INVALID_HANDLE_VALUE) {
                    continue;
                }

                CloseHandle (migInf);

                WritePrivateProfileString (
                    TEXT("Version"),
                    TEXT("Signature"),
                    TEXT("\"$Windows NT$\""),
                    migInfPath
                    );


                if (!CallMigDllEntryPoints (&e)) {
                    MigDllRemoveDllInEnumFromList (list, &e);
                }
                else {

                    ParseMigrateInf (migInfPath);

                    WritePrivateProfileString (
                        TEXT("DllsToLoad"),
                        e.Properties->Info.StaticProductIdentifier,
                        e.Properties->DllPath,
                        baseDir
                        );
                }

            } while (MigDllEnumNext (&e));

            WritePrivateProfileString (NULL, NULL, NULL, baseDir);


            //
            // Get rid of compatibility messages handled by migration dlls.
            //
            ResolveHandledIncompatibilities ();
        }
    }
    __finally {

/*        
        if (regKey) {
            RegCloseKey (regKey);
        }
*/

        if (list) {
            MigDllFreeList (list);
        }


    }

    return TRUE;
}

#endif


VOID
CleanUpOldLocalSources(
    IN HWND hdlg
    )

/*++

Routine Description:

    Locate and delete old local source trees. All local fixed drives
    are scanned for \$win_nt$.~ls, and if present, delnoded.
    On amd64/x86, we also check the system partition for \$win_nt$.~bt
    and give it the same treatment.

Arguments:

Return Value:

--*/

{
    TCHAR Drive;
    TCHAR Text[250];
    TCHAR Filename[128];

    LoadString(hInst,IDS_INSPECTING,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {
        if(MyGetDriveType(Drive) != DRIVE_FIXED) {
            continue;
        }

        Filename[0] = Drive;
        Filename[1] = TEXT(':');
        Filename[2] = 0;
        ConcatenatePaths(Filename,LOCAL_SOURCE_DIR,sizeof(Filename)/sizeof(TCHAR));

        if(FileExists(Filename, NULL)) {

            LoadString(hInst,IDS_REMOVING_OLD_TEMPFILES,Text,sizeof(Text)/sizeof(TCHAR));
            SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

            MyDelnode(Filename);

            LoadString(hInst,IDS_INSPECTING,Text,sizeof(Text)/sizeof(TCHAR));
            SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
        }
    }

    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        MYASSERT (SystemPartitionDriveLetter);
        Filename[0] = SystemPartitionDriveLetter;
        Filename[1] = TEXT(':');
        Filename[2] = TEXT('\\');
        StringCchCopy(Filename+3, ARRAYSIZE(Filename) - 3, LOCAL_BOOT_DIR);

        LoadString(hInst,IDS_REMOVING_OLD_TEMPFILES,Text,sizeof(Text)/sizeof(TCHAR));
        SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

        MyDelnode(Filename);

        //
        // Clean up backup directory, if it exists.
        //
        if(IsNEC98() && Floppyless) {

            Filename[0] = SystemPartitionDriveLetter;
            Filename[1] = TEXT(':');
            Filename[2] = TEXT('\\');
            StringCchCopy(Filename+3, ARRAYSIZE(Filename) - 3, LOCAL_BACKUP_DIR);

            MyDelnode(Filename);
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } // if (!IsArc())
}


BOOL
InspectSources(
    HWND ParentWnd
    )

/*++

Routine Description:

    Check all sources given to ensure that they contain a valid
    windows NT distribution. We do this simply by looking for
    DOSNET.INF on each source.

Arguments:

    ParentWnd - Specifies the handle of the parent window for any
                error messages.

Return Value:

    None.

--*/

{
    UINT i,j;
    TCHAR Filename[MAX_PATH];
    TCHAR Text[512];
    UINT OriginalCount;
    HCURSOR OldCursor;
    BOOL b = TRUE;

    OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    OriginalCount = SourceCount;

    //
    // if we have a good alternate path then there
    // is no need to verify the source paths
    //

    if (AlternateSourcePath[0]) {
        lstrcpy(Filename,AlternateSourcePath);
        ConcatenatePaths(Filename,InfName,MAX_PATH);
        if(FileExists (Filename, NULL)) {
            SetCursor (OldCursor);
            return TRUE;
        }
    }

    //
    // verify each path
    //

    for (i=0; i<SourceCount; ) {

        lstrcpy(Filename,NativeSourcePaths[i]);
        ConcatenatePaths(Filename,InfName,MAX_PATH);

        if(!FileExists (Filename, NULL)) {
            //
            // Source doesn't exist or isn't valid.
            // Adjust the list.
            //
            for(j=i+1; j<SourceCount; j++) {
                lstrcpy(NativeSourcePaths[j-1],NativeSourcePaths[j]);
                lstrcpy(SourcePaths[j-1],SourcePaths[j]);
            }
            SourceCount--;
        } else {
            i++;
        }
    }

    if (!SourceCount) {

        //
        // No sources are valid.
        //

        MessageBoxFromMessage(
            ParentWnd,
            (OriginalCount == 1) ? MSG_INVALID_SOURCE : MSG_INVALID_SOURCES,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING | MB_TASKMODAL,
            NativeSourcePaths[0]
            );

        //
        // Set it to look like one source that is the empty string,
        // so logic elsewhere will work correctly without special casing.
        //
        SourceCount = 1;
        NativeSourcePaths[0][0] = 0;
        SourcePaths[0][0] = 0;
        b = FALSE;
    }

    SetCursor (OldCursor);

    return b;
}


BOOL
LoadInfs(
    IN HWND hdlg
    )

/*++

Routine Description:

    Load dosnet.inf from source 0. If upgrading and we're running
    on NT then also load txtsetup.sif. If running on NT, load ntcompat.inf

Arguments:

    hdlg - supplies handle of dialog to which progress messages
        should be directed.

Return Value:

    Boolean value indicating outcome. If FALSE then the user
    will have been informed.

--*/

{
    BOOL b;
    LPCTSTR p;
    TCHAR szPath[MAX_PATH];

    if (!MainInf) {
        b = LoadInfWorker(hdlg,InfName,&MainInf, TRUE);
        if(!b) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                InfName
                );
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load dosnet.inf!"), 0);
            goto c0;
        }
    } else {
        b = TRUE;
    }

    if(p = InfGetFieldByKey(MainInf,TEXT("Miscellaneous"),TEXT("ProductType"),0)) {
        ProductFlavor = _tcstoul(p,NULL,10);

        Server = (ProductFlavor != PROFESSIONAL_PRODUCTTYPE && ProductFlavor != PERSONAL_PRODUCTTYPE);
        UpgradeProductType = Server ? NT_SERVER : NT_WORKSTATION;

        if( CheckUpgradeOnly ) {
            AppTitleStringId = IDS_APPTITLE_CHECKUPGRADE;
        } else if( ProductFlavor == PROFESSIONAL_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_WKS;
        } else if( ProductFlavor == SERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_SRV;
        } else if( ProductFlavor == ADVANCEDSERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_ASRV;
        } else if( ProductFlavor == DATACENTER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_DAT;
        } else if( ProductFlavor == BLADESERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_BLADE;
        } else if( ProductFlavor == SMALLBUSINESS_PRODUCTTYPE )
            AppTitleStringId = IDS_APPTITLE_SBS;

//            AppTitleStringId = Server ? IDS_APPTITLE_SRV : IDS_APPTITLE_WKS;

        FixUpWizardTitle(GetParent(hdlg));
        PropSheet_SetTitle(GetParent(hdlg),0,UIntToPtr( AppTitleStringId ));
    }

    if((Upgrade || BuildCmdcons) && ISNT()) {
        //
        // If upgrading NT, pull in txtsetup.sif.
        //
        b = LoadInfWorker(hdlg,TEXTMODE_INF,&TxtsetupSif, FALSE);
        
        if(!b) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                TEXTMODE_INF
                );
            TxtsetupSif = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load txtsetup.sif!"), 0);
            goto c1;
        }
    }
    if( ISNT()) {
        b = FindPathToWinnt32File(NTCOMPAT_INF, szPath, MAX_PATH);
        if(!b) {
            NtcompatInf = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not find ntcompat.inf!"), 0);
            goto c2;
        }
        if(LoadInfFile( szPath,TRUE, &NtcompatInf) != NO_ERROR) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                szPath
                );
            b = FALSE;
            NtcompatInf = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load ntcompat.inf!"), 0);
            goto c2;
        }
        DebugLog (Winnt32LogInformation, TEXT("NTCOMPAT: Using %1"), 0, szPath);
    }
    return(b);

c2:
    if( TxtsetupSif) {
        UnloadInfFile(TxtsetupSif);
        TxtsetupSif = NULL;
    }
c1:
    UnloadInfFile(MainInf);
    MainInf = NULL;
c0:
    return(b);
}


BOOL
BuildCopyList(
    IN HWND hdlg
    )
{
    TCHAR Text[256];

    LoadString(hInst,IDS_BUILDING_COPY_LIST,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
    SaveLanguageDirs();

    return(BuildCopyListWorker(hdlg));
}


BOOL
FindLocalSourceAndCheckSpace(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    )
{
    TCHAR Text[256];

    if (!QuickTest) {
        LoadString(hInst,IDS_CHECKING_SPACE,Text,sizeof(Text)/sizeof(TCHAR));
        SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
    }

    return FindLocalSourceAndCheckSpaceWorker(hdlg, QuickTest, AdditionalPadding);
}


BOOL
EnoughMemory(
    IN HWND hdlg,
    IN BOOL QuickTest
    )
{
LPCTSTR         p;
MEMORYSTATUS    MemoryStatus;
DWORD           RequiredMemory;
SIZE_T          RequiredMB, AvailableMB;
    TCHAR buffer[64];

    UpgRequiredMb = 0;
    UpgAvailableMb = 0;


    //
    // Load the minimum memory requirements from the inf
    //
    if(GetMainInfValue (TEXT("Miscellaneous"),TEXT("MinimumMemory"), 0, buffer, 64)) {
        RequiredMemory = _tcstoul(buffer,NULL,10);
        //
        // Got it.  Now figure out how much we've got.
        //
        GlobalMemoryStatus( &MemoryStatus );

        //
        // Convert to MB, rounding up to nearest 4MB boundary...
        //
        RequiredMB = ((RequiredMemory + ((4*1024*1024)-1)) >> 22) << 2;
        AvailableMB = ((MemoryStatus.dwTotalPhys + ((4*1024*1024)-1)) >> 22) << 2;

        //
        // Allow for UMA machine which may reservce 8MB for video
        //
        if( AvailableMB < (RequiredMB-8) ) {

            if (!QuickTest) {
                UpgRequiredMb = (DWORD)RequiredMB;
                UpgAvailableMb = (DWORD)AvailableMB;
                //
                // Fail.
                //
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_NOT_ENOUGH_MEMORY,
                          AvailableMB,
                          RequiredMB );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_NOT_ENOUGH_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING,
                    AvailableMB,
                    RequiredMB );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        } else {
            if (!QuickTest) {
                TCHAR   Buffer[MAX_PATH];
                _stprintf( Buffer, TEXT("Detected %dMB of RAM.\n"), AvailableMB );
                DebugLog( Winnt32LogInformation,
                          Buffer,
                          0 );
            }
        }
    }

    return( TRUE );
}


BOOL
LoadInfWorker(
    IN  HWND     hdlg,
    IN  LPCTSTR  FilenamePart,
    OUT PVOID   *InfHandle,
    IN  BOOL     Winnt32File
    )
{
    DWORD d;
    UINT u;
    UINT Id;
    TCHAR infPath[MAX_PATH];
    TCHAR FormatString[128];
    TCHAR Text[MAX_PATH+128];
    BOOL b;

    LoadString(hInst,IDS_LOADINGINF,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

    //
    // use standard searching algorithm to get to the right INF
    //
    if (Winnt32File) {
        b = FindPathToWinnt32File (FilenamePart, infPath, MAX_PATH);
    } else {
        b = FindPathToInstallationFile (FilenamePart, infPath, MAX_PATH);
    }

    if (b) {
        d = LoadInfFile(infPath,TRUE,InfHandle);
        if (d == NO_ERROR) {
            return TRUE;
        }
    } else {
        d = ERROR_FILE_NOT_FOUND;
    }

    switch(d) {

    case NO_ERROR:

        Id = 0;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:

        Id = MSG_OUT_OF_MEMORY;
        break;

    case ERROR_READ_FAULT:
        //
        // I/O error.
        //
        Id = MSG_CANT_LOAD_INF_IO;
        break;

    case ERROR_INVALID_DATA:

        Id = MSG_CANT_LOAD_INF_SYNTAXERR;
        break;

    default:

        Id = MSG_CANT_LOAD_INF_GENERIC;
        break;
    }

    if(Id) {
        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

        MessageBoxFromMessage(
            hdlg,
            Id,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            infPath
            );

        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);

        return(FALSE);
    }

    return(TRUE);
}

BOOL
WriteFileToLog( 
    const PTCHAR pszFileMetaName,
    const PTCHAR pszActualFileName
    )
{
    HANDLE hActualFile = INVALID_HANDLE_VALUE;
    BOOL fResult = FALSE;
    DWORD cbBootIniSize, cbReadBootIniSize;
    PUCHAR pszBuffer = NULL;
    PTCHAR pszActualBuffer = NULL;

    //
    // Open the boot.ini file, get its size, convert it to the proper
    // string type internally, and then log it out.
    //
    hActualFile = CreateFile( 
        pszActualFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if ( hActualFile == INVALID_HANDLE_VALUE )
        goto Exit;

    cbBootIniSize = GetFileSize( hActualFile, NULL );

    //
    // Buffer we'll be reading the boot.ini into
    //
    if ((pszBuffer = MALLOC(cbBootIniSize)) == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    if ( !ReadFile( hActualFile, pszBuffer, cbBootIniSize, &cbReadBootIniSize, NULL ) )
        goto Exit;

    //
    // Ensure that we read as much as we really wanted.
    //
    if ( cbBootIniSize != cbReadBootIniSize ) {
        DebugLog( Winnt32LogError, 
            TEXT("Error: %1 unable to be read entirely.\n"),
            0,
            pszFileMetaName);
        goto Exit;
    }


#ifdef UNICODE
    pszActualBuffer = MALLOC( (cbBootIniSize + 3) * sizeof(TCHAR) );

    MultiByteToWideChar( 
        CP_ACP, 
        0, 
        pszBuffer, 
        cbBootIniSize, 
        pszActualBuffer,
        cbBootIniSize );
#else
    pszActualBuffer = pszBuffer;
#endif    

    pszActualBuffer[cbBootIniSize] = 0;

    //
    // And write it out
    //
    DebugLog( 
        Winnt32LogInformation, 
        TEXT("%1 ----\n%2\n---- (from %3)\n"), 
        0, 
        pszFileMetaName, 
        pszActualBuffer,
        pszActualFileName);

    fResult = TRUE;
    SetLastError(ERROR_SUCCESS);
Exit:
    if ( hActualFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hActualFile );
        hActualFile = INVALID_HANDLE_VALUE;
    }
    
#ifdef UNICODE
    if ( pszActualBuffer != NULL )
#else
    if ( ( pszActualBuffer != pszBuffer ) && ( pszActualBuffer != NULL ) )
#endif
    {
    
        FREE(pszActualBuffer);
        pszActualBuffer = NULL;
    }
    
    if ( pszBuffer != NULL ) {
        FREE(pszBuffer);
        pszBuffer = NULL;
    }
    return fResult;
}



BOOL
InspectFilesystems(
    IN HWND hdlg
    )
{
    TCHAR DriveRoot[4];
    BOOL b;
    TCHAR VolumeName[MAX_PATH];
    DWORD SerialNumber;
    DWORD MaxComponent;
    BOOL Bogus[26];
    TCHAR Filesystem[100];
    TCHAR Drive;
    DWORD Flags;
    int i;

    DriveRoot[1] = TEXT(':');
    DriveRoot[2] = TEXT('\\');
    DriveRoot[3] = 0;

    ZeroMemory(Bogus,sizeof(Bogus));

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) != DRIVE_FIXED) {
            continue;
        }


        DriveRoot[0] = Drive;

        b = GetVolumeInformation(
                DriveRoot,
                VolumeName,MAX_PATH,
                &SerialNumber,
                &MaxComponent,
                &Flags,
                Filesystem,
                sizeof(Filesystem)/sizeof(TCHAR)
                );

        if(b) {
            //
            // On NT, we want to warn about HPFS.
            // On Win9x, we want to warn about doublespace/drivespace.
            //
            if(ISNT()) {
                if(!lstrcmpi(Filesystem,TEXT("HPFS"))) {
                    Bogus[Drive-TEXT('A')] = TRUE;
                }
            } else {
                if(Flags & FS_VOL_IS_COMPRESSED) {
                    Bogus[Drive-TEXT('A')] = TRUE;
                }
            }
        }
    }

#if defined(_AMD64_) || defined(_X86_)
    if(ISNT()) {
        TCHAR BootIniName[16];
        DWORD dwAttributes;

        //
        // Disallow HPFS system partition. If someone figured out how
        // to get an HPFS system partition on an ARC machine, more power
        // to 'em.
        //
        MYASSERT (SystemPartitionDriveLetter);
        if(SystemPartitionDriveLetter && Bogus[SystemPartitionDriveLetter-TEXT('A')]) {

            MessageBoxFromMessage(
                hdlg,
                MSG_SYSPART_IS_HPFS,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }

        /*
            If we're upgrading NT, then log the existing boot.ini to the
            logfiles for this pass.  However, if that failed, then there
            was something wrong - a missing boot.ini during an upgrade
            is really a bad thing that should be snipped in the bud before
            we go much further and copy files down, change system state,
            etc.
        */
#ifdef PRERELEASE
        if (Upgrade) 
        {
            _stprintf(BootIniName, TEXT("%c:\\BOOT.INI"), SystemPartitionDriveLetter);
            if ( !WriteFileToLog( TEXT("Boot configuration file while inspecting filesystems"), BootIniName ) )
            {
                MessageBoxFromMessage(
                    hdlg,
                    MSG_UPGRADE_INSPECTION_MISSING_BOOT_INI,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    BootIniName );
                return FALSE;
            }
        }
#endif
    }
#endif

    //
    // User cannot upgrade a system on an HPFS/DriveSpace drive
    //
    MyGetWindowsDirectory(VolumeName,MAX_PATH);
    if(Upgrade && Bogus[VolumeName[0]-TEXT('A')]) {

        MessageBoxFromMessage(
            hdlg,
            ISNT() ? MSG_SYSTEM_ON_HPFS : MSG_SYSTEM_ON_CVF,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }


    //
    // General case, HPFS data partition/compressed drive.
    //
    for(b=FALSE,Drive=0; !b && (Drive<26); Drive++) {
        if(Bogus[Drive]) {
            b = TRUE;
        }
    }
    if(b) {
        i = MessageBoxFromMessage(
                hdlg,
                ISNT() ? MSG_HPFS_DRIVES_EXIST : MSG_CVFS_EXIST,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL
                );

        if(i == IDNO) {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\internal.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    internal.c

Abstract:

    Routines to support hidden or internal-only functionlity.

Author:

    Ted Miller (tedm) 4 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Value used internally to automatically fetch
// alternate setup hives for differing # of processors.
//
UINT NumberOfLicensedProcessors;

//
// internal value used to turn off processing of "exception packages"
//
BOOL IgnoreExceptionPackages;

//
// Where to get missing files.
//

TCHAR AlternateSourcePath[MAX_PATH];


BOOL
AddCopydirIfExists(
    IN LPTSTR pszPathToCopy,
    IN UINT Flags
    )
/*++

Routine Description:

    If pszPathToCopy exists, then act like "/copydir:pszPathToCopy" was passed
    on the cmd line.

Arguments:

    pszPathToCopy - path that we want to additionally copy if it exists.

    Flags - one of the OPTDIR_xxx flags to specify how to treat this optional directory

Return Value:

    TRUE  - pszPathToCopy existed and we added this to list of extra dirs to copy.
    FALSE - pszPathToCopy did not exist or we failed to add it to our list of extra dirs

--*/
{
    TCHAR szFullPath[MAX_PATH], szRealPath[MAX_PATH];
    PTSTR p;
    
    if( !pszPathToCopy )
        return FALSE;

    if (NativeSourcePaths[0][0]) {
        lstrcpy(szFullPath, NativeSourcePaths[0]);
    } else {
        if (!MyGetModuleFileName(NULL, szFullPath, ARRAYSIZE(szFullPath)) ||
            !(p = _tcsrchr(szFullPath, TEXT('\\')))
            ) {
            return FALSE;
        }
        // remove "\winnt32.exe" part
        *p = TEXT('\0');
    }
    ConcatenatePaths(szFullPath, pszPathToCopy, MAX_PATH);

    if(GetFullPathName( szFullPath, MAX_PATH, szRealPath, NULL )){
        if (FileExists (szRealPath, NULL))
        {
            DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists for <%1> <%2>"), 0, szRealPath, pszPathToCopy);
            return RememberOptionalDir(pszPathToCopy, Flags);
        }else{
            
            DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists FileExists failed for <%1>"), 0, szRealPath);
        }
    }else{
        DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists GetFullPathName failed for <%1>"), 0, szFullPath );
    }

    
    
    return FALSE;
}



VOID
CopyExtraBVTDirs(
                 )
/*++

Routine Description:
    Copies the extra dirs that are good to have when running bvt's:
    symbols.pri, idw, mstools, and debugger extensions.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LPTSTR psz;

    if (CopySymbols)
    {
        // copy symbols.pri\retail
        if (AddCopydirIfExists(TEXT("..\\..\\sym\\retail"), 0)  ||
            AddCopydirIfExists(TEXT("..\\..\\symbols.pri\\retail"), 0) || // for dev postbuild installs
            AddCopydirIfExists(TEXT("..\\..\\sym\\netfx"), 0)  ||
            AddCopydirIfExists(TEXT("..\\..\\symbols.pri\\netfx"), 0)) // for dev postbuild installs
        {}
    }

    // copy idw
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\idw"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\idw"), 0)) // for dev postbuild installs
    {}

    // copy mstools
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\mstools"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\mstools"), 0)) // for dev postbuild installs
    {}

    // copy bldtools
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\bldtools"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\bldtools"), 0))    // for dev postbuild installs
    {}

    // copy debugger package to %windir%\Debuggers
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\dbg\\released"), OPTDIR_DEBUGGER)  ||
        AddCopydirIfExists(TEXT("..\\..\\dbg\\released"), OPTDIR_DEBUGGER))   // for dev postbuild installs
    {}
}


BOOL
AppendUpgradeOption (
    IN      PCTSTR String
    )
{
    BOOL result = FALSE;
    UINT lengthInBytes;
    UINT lengthPlusTerminator;
    PTSTR UpgradeOptionsReAllocated = NULL;

    __try {
        //
        // Ensure there is enough room.
        //
        lengthInBytes = UpgradeOptionsLength + ((_tcslen(String) + 1) * sizeof (TCHAR));
        lengthPlusTerminator = lengthInBytes + sizeof (TCHAR);

        if (lengthPlusTerminator > UpgradeOptionsSize) {
            //
            // Allocate more space, aligned to 256 bytes.
            //
            UpgradeOptionsSize = ((lengthPlusTerminator / 256) + 1) * 256;
            UpgradeOptionsReAllocated = REALLOC(UpgradeOptions,UpgradeOptionsSize);
        }

        if (UpgradeOptionsReAllocated) {
            
            UpgradeOptions = UpgradeOptionsReAllocated;
            //
            // Ok, memory was successfully allocated. Save the new option onto the end
            // of the list.
            //
            wsprintf (
                (PTSTR) ((PBYTE) UpgradeOptions + UpgradeOptionsLength),
                TEXT("%s%c"),
                String,
                0
                );

            UpgradeOptionsLength = lengthInBytes;
        } else {
            //
            // This is bad. realloc failed.
            //
            __leave;
        }

        result = TRUE;
    }
    __finally {
    }

    return result;
}



VOID
InternalProcessCmdLineArg(
    IN LPCTSTR Arg
    )

/*++

Routine Description:

    Parse a command line arg that is thought to be internal-only.

    The caller should call this routine only if the switch arg char
    is # (ie something like /#x:foo).

    /#[n]:sharename             internal distribution
                                n can be a digit from 1-9 to indicate source
                                count, default is 3 n win9x and 5 on nt.

    /#L:number                  number of licensed processors

    /#N                         auto skip missing files

    /#U:[Option]                Upgrade option. All upgrade options are packed together
                                into a multisz and passed to the plugin-dll.

    /#bvt:[Option]:[Option]     Setup machine for running bvt's. Options include :nosymbols,
                                :baudrate=XXXX, and :debugport=X

    /#asr[{t|f}:[AsrSifPath]]   Setup machine for running ASR coverage tests, using the
                                asr.sif specified.  This includes adding /DEBUG
                                /BAUDRATE=115200  (on IA64 use 19200 and /DEBUGPORT=COM1),
                                in addition to setting setupcmdlineprepend="ntsd -isd -odgGx",
                                and adding other options as appropriate.
Arguments:

    Arg - supplies comment line argument, starting with the switch
        character itself (ie, - or /). This routine assumes that
        the interesting part of the argument starts at Arg[2].

Return Value:

    None.

--*/

{
    UINT NumSources;
    UINT u;
    UINT length;
    LPTSTR src;

    if(!Arg[0] || !Arg[1]) {
        return;
    }

    NumSources = ISNT() ? 5 : 3;

    switch(_totupper(Arg[2])) {

    case TEXT('1'): case ('2'): case ('3'):
    case TEXT('4'): case ('5'): case ('6'):
    case TEXT('7'): case ('8'): case ('9'):
        if(Arg[3] != TEXT(':')) {
            break;
        }

        NumSources = Arg[2] - TEXT('0');
        Arg++;
        //
        // Fall through
        //
    case TEXT(':'):
        //
        // Internal distribution stuff
        //

        //
        // handle cases where
        //  -they put a "\" before path
        //  -they map a net drive and put "f:" first
        //  -they map a net driver and put "f:\" first
        //
        src = (LPTSTR)(Arg+3);

        for(u=0; u<NumSources; u++) {
            if(SourceCount < MAX_SOURCE_COUNT) {

                if (GetFullPathName (
                        src,
                        sizeof(NativeSourcePaths[SourceCount])/sizeof(TCHAR),
                        NativeSourcePaths[SourceCount],
                        NULL
                        )) {
                    SourceCount++;
                }
            }
        }
        break;

    case TEXT('A'):

        if (_tcsnicmp(Arg+2,TEXT("asr"),3) == 0) {
            //
            // Setup machine for running ASR tests
            //
            AsrQuickTest = 3;   // Assume default is full

            if (Arg[5] == TEXT('t') || Arg[5] == TEXT('T')) {
                AsrQuickTest = 2;   // Text mode only
            }

            if (Arg[5] == TEXT('f') || Arg[5] == TEXT('F')) {
                AsrQuickTest = 3;   // Full mode
            }

            if (Arg[5] != 0 && Arg[6] == TEXT(':')) {
                //
                // User specified asr.sif to use
                //
                StringCchCopy(AlternateSourcePath, ARRAYSIZE(AlternateSourcePath), Arg+7);
            }
            else {
                //
                // Use default asr.sif (%systemroot%\repair\asr.sif)
                //
                ExpandEnvironmentStrings(
                    TEXT("%systemroot%\\repair"),
                    AlternateSourcePath,
                    MAX_PATH
                    );
            }

            RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);

            //
            // Don't block if we can't find enough disk space.
            //
            BlockOnNotEnoughSpace = FALSE;

            //
            // Run in unattended mode
            //
            UnattendedOperation = TRUE;

            //
            // Pretend we're running from CD
            //
            RunFromCD = TRUE;

            //
            // Make sure we're not upgrading
            //
            Upgrade = FALSE;

            //
            // Skip EULA
            //
            EulaComplete = TRUE;

        }

        break;

    case TEXT('B'):
        if (_tcsnicmp(Arg+2,TEXT("bvt"),3) == 0)
        {
            TCHAR* pszTemp = (TCHAR*)Arg;

            // setup for running BVT's
            RunningBVTs = TRUE;

            // replace all ":"'s with spaces so that _ttol will work properly
            while (*pszTemp)
            {
                if (*pszTemp == TEXT(':'))
                {
                    *pszTemp = TEXT(' ');
                }
                pszTemp++;
            }

            // check for other #bvt switches (eg "/#bvt:nosymbols:baudrate=19200:debugport=1")
            if (_tcsstr(Arg, TEXT("nosymbols")))
            {
                CopySymbols = FALSE;
            }

            pszTemp = _tcsstr(Arg, TEXT("baudrate="));
            if (pszTemp)
            {
                pszTemp = pszTemp + ((sizeof(TEXT("baudrate=")) - sizeof(TCHAR))/sizeof(TCHAR));
                lDebugBaudRate = _ttol(pszTemp);
            }

            pszTemp = _tcsstr(Arg, TEXT("debugport="));
            if (pszTemp)
            {
                if ( _tcsstr(pszTemp, TEXT("com")) ) {
                    pszTemp = pszTemp + ((sizeof(TEXT("debugport=com")) - sizeof(TCHAR))/sizeof(TCHAR));
                    lDebugComPort = _ttol(pszTemp);
                }
                else {
                    pszTemp = pszTemp + ((sizeof(TEXT("debugport=")) - sizeof(TCHAR))/sizeof(TCHAR));
                    lDebugComPort = _ttol(pszTemp);
                }
            }

            break;
        }

        //
        // Don't block if we can't find enough disk space.
        //
        BlockOnNotEnoughSpace = FALSE;
        break;

    case TEXT('C'):
        //
        // Don't block if we can't find enough disk space.
        //
        UseBIOSToBoot = TRUE;
        break;

#if defined(_AMD64_) || defined(_X86_)
    case TEXT('F'):
        //
        // temp variable to allow compliance checking
        //
        Floppyless = FALSE;
        break;
#endif

    case TEXT('L'):
        //
        // Licensed processors
        //
        if(Arg[3] == TEXT(':')) {
            NumberOfLicensedProcessors = _tcstoul(Arg+4,NULL,10);
        }
        break;

    case TEXT('M'):
        //
        // Alternate source for missing files
        //
        if(Arg[3] == TEXT(':')) {
            StringCchCopy(AlternateSourcePath, ARRAYSIZE(AlternateSourcePath), Arg+4);
            RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);  //behave like /m:
        }
        break;

    case TEXT('I'):
        if (!_tcsicmp(Arg+2,TEXT("IgnoreExceptionPackages"))) {
            IgnoreExceptionPackages = TRUE;
        }
        break;

    case TEXT('N'):
#ifdef PRERELEASE
        if (!_tcsicmp(Arg+2,TEXT("NODEBUGBOOT"))) {
            AppendDebugDataToBoot = FALSE;
        } else
        //
        // this is PRERELEASE code only, intended to help testing of winnt32
        // the use of this switch is not supported in any way!
        //
        if (!_tcsicmp (Arg+2, TEXT("nopid"))) {
            extern BOOL NoPid;
            NoPid = TRUE;
        }
        else
#endif
        {

        //
        // Skip missing files mode
        //
        AutoSkipMissingFiles = TRUE;

        }

        break;

    case TEXT('H'):
        //
        // Hide windows dir
        //
        HideWinDir = TRUE;
        break;

    case TEXT('P'):
        //
        // allow the user to select a partition during textmode setup
        //
        ChoosePartition = TRUE;
        break;

    case TEXT('R'):
        //
        // Pretending to run from CD.
        //
        RunFromCD = TRUE;
        break;

    case TEXT('Q'):
       //
       // Denote running from MSI file.
       //
       RunFromMSI = TRUE;
       break;

    case TEXT('S'):
        //
        // use signature based arc paths
        //
        UseSignatures = !UseSignatures;
        break;

    case TEXT('D'):
        //
        // specify the directory to install into
        //
        if(Arg[3] == TEXT(':')) {
            StringCchCopy(InstallDir, ARRAYSIZE(InstallDir), Arg+4);
        }
        break;

    case TEXT('T'):
        //
        // Give the user detailed timing info during file copy.
        //
        DetailedCopyProgress = TRUE;
        break;

    case TEXT('U'):
        //
        // Plugin option. Add it to the multisz that will be passed to the plugin.
        //
        if (Arg[3] == TEXT(':')) {

            if (!AppendUpgradeOption (Arg+4)) {
                break;
            }

            //
            // winnt32 uses the anylocale and virusscanersok switches itself.
            //
            if (!_tcsicmp(Arg+4,TEXT("ANYLOCALE"))) {
                SkipLocaleCheck = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("VIRUSSCANNERSOK"))) {
                SkipVirusScannerCheck = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("NOLS"))) {
                NoLs = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("NOBUILDCHECK"))) {
                CCDisableBuildCheck();
            }

#ifdef PRERELEASE
            if (!_tcsicmp(Arg+4,TEXT("NOCOMPLIANCE"))) {
                NoCompliance = TRUE;
            }
#endif

        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\inf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Sunil Pai    (sunilp) 13-Nov-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <string.h>
#include <ctype.h>

#define ISSPACE(x)          (((x) == TEXT(' ')) || ((x) == TEXT('\t')) || ((x) == TEXT('\r')))
#define STRNCPY(s1,s2,n)    CopyMemory((s1),(s2),(n)*sizeof(WCHAR))


// what follows was alpar.h

//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//

// typedefs exported
//

typedef struct _value {
    struct _value *pNext;
    PTSTR  pName;
    BOOL   IsStringId;
} XVALUE, *PXVALUE;

typedef struct _line {
    struct _line *pNext;
    PTSTR   pName;
    PXVALUE  pValue;
} LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PTSTR    pName;
    PLINE    pLine;
} SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
} INF, *PINF;


DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_STRING_ID,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PTSTR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

DWORD
DnAppendSection(
    IN PTSTR pSectionName
    );

DWORD
DnAppendLine(
    IN PTSTR pLineKey
    );

DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    );

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR     MaxStream
    );

BOOL
IsStringTerminator(
   IN TCHAR ch
   );

BOOL
IsQStringTerminator(
   IN TCHAR ch,
   IN TCHAR term
   );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PXVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   );

BOOL
ProcessStringSection(
    PINF pINF
    );



DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle
   )

/*++

Routine Description:

Arguments:

    Filename - supplies win32 filename of inf file to be loaded.

    OemCodepage - if TRUE amd the file named by Filename is not
        Unicode text, then the file is assumed to be in the OEM
        codepage (otherwise it's in the ANSI codepage).

    InfHandle - if successful, receives a handle to be used with
        subsequent inf operations.

Return Value:

    ERROR_FILE_NOT_FOUND - file does not exist or error opening it.
    ERROR_INVALID_DATA - syntax error in inf file.
    ERROR_READ_FAULT - unable to read file.
    ERROR_NOT_ENOUGH_MEMORY - mem alloc failed
    NO_ERROR - file read and parsed.

--*/

{
    DWORD err;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    BOOL IsUnicode;

    DWORD ParseCount;
    PVOID ParseBuffer;

    //
    // Open and map the inf file.
    //
    err = MapFileForRead(Filename,&FileSize,&FileHandle,&MappingHandle,&BaseAddress);
    if(err != NO_ERROR) {
        err = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    //
    // Determine whether the file is unicode. If it's got the byte order mark
    // then it's unicode, otherwise call the IsTextUnicode API. We do it this way
    // because IsTextUnicode always returns FALSE on Win95 so we need to break out
    // the BOM to detect Unicode files on Win95.
    //
    if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)BaseAddress == 0xfeff)) {
        IsUnicode = 2;
    } else {
        IsUnicode = IsTextUnicode(BaseAddress,FileSize,NULL) ? 1 : 0;
    }

#ifdef UNICODE
    if(IsUnicode) {
        //
        // Copy into local buffer, skipping BOM if necessary.
        //
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {

            CopyMemory(
                ParseBuffer,
                (PUCHAR)BaseAddress + ((IsUnicode == 2) ? sizeof(WCHAR) : 0),
                FileSize - ((IsUnicode == 2) ? sizeof(WCHAR) : 0)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        ParseCount = (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0);

    } else {
        //
        // Convert to Unicode.
        //
        // Allocate a buffer large enough to hold the maximum sized unicode
        // equivalent of the multibyte text.  This size occurs when all chars
        // in the file are single-byte and thus double in size when converted.
        //
        ParseBuffer = MALLOC(FileSize * sizeof(WCHAR));
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = MultiByteToWideChar(
                            OemCodepage ? CP_OEMCP : CP_ACP,
                            MB_PRECOMPOSED,
                            BaseAddress,
                            FileSize,
                            ParseBuffer,
                            FileSize
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    }
#else
    if(IsUnicode) {
        //
        // Text is unicode but internal routines want ansi. Convert here.
        //
        // Maximum required buffer is when each unicode char ends up as
        // a double-byte char.
        //
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            (PWCHAR)BaseAddress + ((IsUnicode == 2) ? 1 : 0),
                            (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0),
                            ParseBuffer,
                            FileSize,
                            NULL,
                            NULL
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    } else {
        //
        // Text is not unicode. It might be OEM though and could thus still
        // require translation.
        //
        ParseCount = FileSize;
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            CopyMemory(ParseBuffer,BaseAddress,FileSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        if(err != NO_ERROR) {
            goto c2;
        }

        if(OemCodepage && (GetOEMCP() != GetACP())) {
            OemToCharBuff(ParseBuffer,ParseBuffer,ParseCount);
        }
    }
#endif

    if(err != NO_ERROR) {
        goto c2;
    }

    err = ParseInfBuffer(ParseBuffer,ParseCount,InfHandle);

c2:
    FREE(ParseBuffer);
c1:
    UnmapFile(MappingHandle,BaseAddress);
    CloseHandle(FileHandle);
c0:
    return(err);
}


VOID
UnloadInfFile(
   IN PVOID InfHandle
   )

/*++

Routine Description:

    Unload a file previously loaded by LoadInfFile().

Arguments:

    InfHandle - supplies a habdle previously returned by a successful
        call to LoadInfFile().

Return Value:

    None.

--*/

{
   PINF pINF;

   pINF = InfHandle;

   FreeSectionList(pINF->pSection);
   FREE(pINF);
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            FREE(pSection->pName);
        }
        FREE(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList(
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if(pLine->pName) {
            FREE(pLine->pName);
        }
        FREE(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PXVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PXVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            FREE(pValue->pName);
        }
        FREE(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section,
// returns line count (-1 if not found)
//
LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   LONG count;

   //
   // if search for section fails return failure
   //
   if ((pSection = SearchSectionByName(INFHandle,SectionName)) == NULL) {
       return(-1);
   }

   for(count=0,pLine=pSection->pLine; pLine; pLine=pLine->pNext) {
       count++;
   }

   return(count);
}




//
// given section name, line number and index return the value.
//
LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
                    (PINF)INFHandle,
                    SectionName
                    ))
                == NULL)
        return(NULL);

   if((pLine = SearchLineInSectionByIndex(
                    pSection,
                    LineIndex
                    ))
                == NULL)
        return(NULL);

   if((pValue = SearchValueInLine(
                    pLine,
                    ValueIndex
                    ))
                == NULL)
        return(NULL);

   return (pValue->pName);
}


BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key) == NULL) {
       return( FALSE );
   }

   return( TRUE );
}


BOOL
InfDoesEntryExistInSection (
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Entry
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   PXVALUE pValue;
   PCTSTR pEntryName;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   pLine = pSection->pLine;
   while (pLine) {
       pEntryName = pLine->pName ?
                        pLine->pName :
                        pLine->pValue ?
                            pLine->pValue->pName :
                            NULL;
       if (pEntryName && !lstrcmpi (pEntryName, Entry)) {
            return TRUE;
       }
       pLine = pLine->pNext;
   }

   return FALSE;
}


LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



//
// given section name, key and index return the value
//
LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL)
       return(NULL);

   if((pLine = SearchLineInSectionByKey(
              pSection,
              Key
              ))
              == NULL)
       return(NULL);

   if((pValue = SearchValueInLine(
              pLine,
              ValueIndex
              ))
              == NULL)
       return(NULL);

   return (pValue->pName);

}




PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PXVALUE pValue;
   unsigned  i;

   if (pLine == NULL)
       return (NULL);

   pValue = pLine->pValue;
   for (i = 0; (i < ValueIndex) && (pValue = pValue->pNext); i++)
      ;

   return pValue;

}

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;

   if (pSection == NULL || Key == NULL) {
       return (NULL);
   }

   pLine = pSection->pLine;
   while(pLine && ((pLine->pName == NULL) || lstrcmpi(pLine->pName, Key))) {
       pLine = pLine->pNext;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   unsigned  i;

   //
   // Validate the parameters passed in
   //

   if(pSection == NULL) {
       return (NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; (i < LineIndex) && (pLine = pLine->pNext); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == NULL || SectionName == NULL) {
       return (NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while (pSection && lstrcmpi(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PXVALUE  pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

TCHAR  StringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                             };

unsigned NumberOfTerminators = sizeof(StringTerminators)/sizeof(TCHAR);

//
// quoted string terminators allow some of the regular terminators to
// appear as characters

TCHAR  QStringTerminators[] = { TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                              };

unsigned QNumberOfTerminators = sizeof(QStringTerminators)/sizeof(TCHAR);


//
// Main parser routine
//

DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

   If this module is compiler for unicode, the input is assumed to be
   a bufferful of unicode characters.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in characters.

   Handle - receives INF handle ptr to be used in subsequent INF calls.

Return Value:

   Win32 error code indicating outcome. One of NO_ERROR, ERROR_INVALID_DATA,
   or ERROR_NOT_ENOUGH_MEMORY.

--*/

{
    LPTSTR Stream, MaxStream, pchSectionName, pchValue;
    unsigned State, InfLine;
    TOKEN Token;
    BOOL Done;
    BOOL Error;
    DWORD ErrorCode;
    BOOL IsStringId;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Get INF record
    //
    pINF = MALLOC(sizeof(INF));
    if(!pINF) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State      = 1;
    InfLine    = 1;
    Stream     = Buffer;
    MaxStream  = Buffer + Size;
    Done       = FALSE;
    Error      = FALSE;
    ErrorCode  = NO_ERROR;
    IsStringId = FALSE;

    pchSectionName = NULL;
    pchValue = NULL;

    //
    // Enter token processing loop
    //

    if (Size == 0)
       return ERROR_INVALID_DATA;
    while (!Done)       {

       Token = DnGetToken(&Stream, MaxStream);

       if(Token.Type == TOK_ERRNOMEM){
            Error = Done = TRUE;
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
       }

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = DnAppendLine(pchValue)) !=NO_ERROR)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           IsStringId = FALSE;
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_COMMA
       //
       case 7:
           switch (Token.Type) {
              case TOK_EOL:
                  //
                  // this is the end of the line, after a comma
                  //
                  State = 5;
                  //
                  // fall through
                  //
              case TOK_COMMA:
                  Token.pValue = DupString(TEXT(""));
                  if(!Token.pValue) {
                    Error = Done = TRUE;
                    ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                  } else {
                    ErrorCode = DnAppendValue(Token.pValue,FALSE);
                    if(ErrorCode != NO_ERROR) {
                      Error = Done = TRUE;
                    }
                  }
                  break;

              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                     State = 9;
                  }
                  IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 9;
                  }
                  IsStringId = FALSE;
                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = DupString(TEXT(""));
                  if(!Token.pValue) {
                    Error = Done = TRUE;
                    ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                  } else {
                    if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                      Error = Done = TRUE;
                    } else {
                      State = 5;
                    }
                  }

                  IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = ERROR_INVALID_DATA;
           break;

       } // end switch(State)


       if (Error) {

           UnloadInfFile(pINF);
           if(pchSectionName) {
               FREE(pchSectionName);
           }

           if(pchValue) {
               FREE(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if(!Error) {
        ProcessStringSection( pINF );
        *Handle = pINF;
    }
    return(Error ? ErrorCode : NO_ERROR);
}



DWORD
DnAppendSection(
    IN PTSTR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !lstrcmpi(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;
    } else {

        //
        // Allocate memory for the new section
        //

        pNewSection = MALLOC(sizeof(SECTION));
        if(!pNewSection) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return NO_ERROR;

}


DWORD
DnAppendLine(
    IN PTSTR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;

    //
    // Allocate memory for the new Line
    //
    pNewLine = MALLOC(sizeof(LINE));
    if(!pNewLine) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return NO_ERROR;
}



DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PXVALUE pNewValue;

    //
    // Allocate memory for the new value record
    //
    pNewValue = MALLOC(sizeof(XVALUE));
    if(!pNewValue) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in.
    //

    pNewValue->pNext       = NULL;
    pNewValue->pName       = pValueString;
    pNewValue->IsStringId  = IsStringId;

    if (pValueRecord == NULL)
        pLineRecord->pValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return NO_ERROR;
}

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR      MaxStream
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PTSTR pch, pchStart, pchNew;
    unsigned  Length;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != TEXT('\n') && (ISSPACE(*pch) || (*pch == TEXT('\032'))))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == TEXT(';')) || (*pch == TEXT('#'))
            || (*pch == TEXT('/') && pch+1 < MaxStream && *(pch+1) == TEXT('/'))))
        while (pch < MaxStream && *pch != TEXT('\n'))
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if ( pch >= MaxStream ) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case TEXT('[') :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']') :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('=') :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(',') :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n') :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('%'):
        pch++;
        //
        // determine percented string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('%'))) {
            pch++;
        }

        if (pch >=MaxStream || *pch != TEXT('%')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if(pchNew = MALLOC(Length + sizeof(TCHAR))){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING_ID;
                Token.pValue = pchNew;
                pch++;   // advance past the percent
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }



        }
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('\"'))) {
            pch++;
        }

        if (pch >=MaxStream || *pch != TEXT('\"')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if( pchNew = MALLOC(Length + sizeof(TCHAR))){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
                pch++;   // advance past the quote
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }


        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsStringTerminator(*pch))
            pch++;

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if( pchNew = MALLOC(Length + sizeof(TCHAR)) ){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }

        }
        break;
    }

    *Stream = pch;
    return (Token);
}



BOOL
IsStringTerminator(
    TCHAR ch
    )
/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.

Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.

--*/

{
    unsigned i;

    //
    // one of the string terminator array
    //

    for (i = 0; i < NumberOfTerminators; i++) {
        if (ch == StringTerminators[i]) {
            return (TRUE);
        }
    }

    return FALSE;
}



BOOL
IsQStringTerminator(
    TCHAR ch,
    TCHAR term
    )

/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.


Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.


--*/


{
    unsigned i;
    //
    // one of quoted string terminators array
    //
    for (i = 0; i < QNumberOfTerminators; i++) {

        if (ch == QStringTerminators[i] || ch == term) {
            return (TRUE);
        }
    }

    return FALSE;
}


typedef struct _STRING_ENTRY {
    LPCTSTR     StringId;
    LPCTSTR     StringValue;
} STRING_ENTRY, *PSTRING_ENTRY;

BOOL
ProcessStringSection(
    PINF pINF
    )

/*++

Routine Description:

    This routine processes the strings sections on the
    specified inf file.  The processing scans all values
    in the inf and replaces any string ids that are
    referenced.

Arguments:

    pINF - pointer to the specified inf structure

Return Value:

    TRUE if the strings section is processed properly

--*/

{
    PSTRING_ENTRY StringTable;
    DWORD StringTableCount;
    DWORD LineCount;
    DWORD i;
    LPCTSTR StringId;
    LPCTSTR StringValue;
    PSECTION pSection;
    PLINE pLine;
    PXVALUE pValue;


    LineCount = InfGetSectionLineCount( pINF, TEXT("Strings") );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return FALSE;
    }

    StringTable = (PSTRING_ENTRY) MALLOC( LineCount * sizeof(STRING_ENTRY) );
    if (StringTable == NULL) {
        return FALSE;
    }

    StringTableCount = 0;

    for (i=0; i<LineCount; i++) {
        StringId = InfGetLineKeyName( pINF, TEXT("Strings"), i );
        StringValue = InfGetFieldByIndex( pINF, TEXT("Strings"), i, 0 );
        if (StringId && StringValue) {
            StringTable[i].StringId = StringId;
            StringTable[i].StringValue = StringValue;
            StringTableCount += 1;
        }
    }

    pSection = pINF->pSection;
    while(pSection) {
        pLine = pSection->pLine;
        while(pLine) {
            pValue = pLine->pValue;
            while(pValue) {
                if (pValue->IsStringId) {
                    for (i=0; i<StringTableCount; i++) {
                        if (_tcsicmp( StringTable[i].StringId, pValue->pName ) == 0) {
                            FREE(pValue->pName);
                            pValue->pName = DupString( (PTSTR)StringTable[i].StringValue );
                            break;
                        }
                    }
                }
                pValue = pValue->pNext;
            }
            pLine = pLine->pNext;
        }
        pSection = pSection->pNext;
    }

    FREE( StringTable );

    return TRUE;
}


BOOL
EnumFirstInfLine (
    OUT     PINF_ENUM InfEnum,
    IN      PVOID InfHandle,
    IN      PCTSTR InfSection
    )
{
    ZeroMemory (InfEnum, sizeof (INF_ENUM));
    InfEnum->SectionName = DupString (InfSection);
    InfEnum->InfHandle = InfHandle;
    InfEnum->LineIndex = (unsigned) -1;

    return EnumNextInfLine (InfEnum);
}


BOOL
EnumNextInfLine (
    IN OUT  PINF_ENUM InfEnum
    )
{
    if (!InfEnum->InfHandle) {
        return FALSE;
    }

    if (!InfEnum->SectionName) {
        return FALSE;
    }

    InfEnum->LineIndex++;

    InfEnum->FieldZeroData = InfGetFieldByIndex (
                                InfEnum->InfHandle,
                                InfEnum->SectionName,
                                InfEnum->LineIndex,
                                0
                                );

    if (!InfEnum->FieldZeroData) {
        AbortInfLineEnum (InfEnum);
        return FALSE;
    }

    return TRUE;
}


VOID
AbortInfLineEnum (
    IN      PINF_ENUM InfEnum           // ZEROED
    )
{
    if (InfEnum->SectionName) {
        FREE ((PVOID) InfEnum->SectionName);
    }

    ZeroMemory (InfEnum, sizeof (INF_ENUM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\lang.c ===
#include "precomp.h"
#pragma hdrstop


//
// Global variables defined here
//

//
// TargetNativeLangID : this is native language ID of running system
//
LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
LANGID SourceNativeLangID;

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//                     1. if SourceNativeLangID == TargetNativeLangID
//
//                     2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
BOOL IsLanguageMatched;

typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

BOOL 
TrustedDefaultUserLocale(
    HINF Inf,
    LANGID LangID);

BOOL
MySetupapiGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue,
    IN  int Base
    );


BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
   )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource, 
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time 
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}

LANGID 
GetNTDLLNativeLangID()
/*++

Routine Description:

    This function is designed specifically for getting native lang of ntdll.dll
    
    This is not a generic function to get other module's language
    
    the assumption is:
    
    1. if only one language in resource then return this lang
    
    2. if two languages in resource then return non-US language
    
    3. if more than two languages, it's invalid in our case, but returns the last one.

Arguments:

    None

Return Value:

    Native lang ID in ntdll.dll

--*/
{
    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages(
            GetModuleHandle(TEXT("ntdll.dll")),
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

BOOL IsHongKongVersion()
/*++

Routine Description:

    Try to identify HongKong NT 4.0
    
    It based on:
    
    NTDLL's language is English and build is 1381 and
    pImmReleaseContext return TRUE
    
Arguments:
    

Return Value:

   Language ID of running system

--*/
{
    HMODULE hMod;
    BOOL bRet=FALSE;
    typedef BOOL (*IMMRELEASECONTEXT) (HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if ((OsVersion.dwBuildNumber == 1381) &&
        (TmpID == 0x0409)){

        hMod = LoadLibrary(TEXT("imm32.dll"));

        if (hMod) {

            pImmReleaseContext = (IMMRELEASECONTEXT) GetProcAddress(hMod,"ImmReleaseContext");

            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }

            FreeLibrary(hMod);
        }
    }
    return (bRet);
}

LANGID GetDefaultUserLangID()
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          langid = 0;

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueExA(hkey,
                                 "Locale",
                                 NULL,  //reserved
                                 NULL,  //type
                                 buffer,
                                 &dwSize );

        if(dwErr == ERROR_SUCCESS) {
            langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));

        }
        RegCloseKey(hkey);
    }
    return langid;
}

LANGID 
GetTargetNativeLangID(
    HINF Inf)
/*++

Routine Description:

    Applies different rules to different platforms
    
    NT
        build number <= 1840           : check ntdll's language, 
                                         we scaned all 3.51's ntdll on boneyard\intl,
                                         it looks like we can trust them.
        build number > 1840            : user MUI language  
        
    Win9x                                                           
        use default user's resource language
    
Arguments:
    

Return Value:

   Language ID of running system

--*/
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          rcLang;
    LANGID          langid = 0;


    // Find out if we are running on NT or WIN9X

    if( ISNT() ) {

        //
        // We're on NT, but which version?  GetSystemDefaultUILanguage() was broke until 1840...
        //
        if( OsVersion.dwBuildNumber > 1840 ) {
        FARPROC     NT5API;

            //
            // Use the API to find out our locale.
            //

            if( NT5API = GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDefaultUILanguage") ) {

                rcLang = (LANGID)NT5API();
                //
                // need to convert decimal to hex, LANGID to chr.
                //
                langid = rcLang;
            }
        } else {

                //
                // by looking into \\boneyard\intl, almost every ntdll.dll marked correct lang ID
                // so get langID from ntdll.dll
                //

                langid = GetNTDLLNativeLangID();

                if (langid == 0x0409) {

                    if (IsHongKongVersion()) {

                        langid = 0x0C04;

                    } else {
                        //
                        // if default user's locale is in [TrustedDefaultUserLocale] in intl.inf
                        //
                        // then this is a backdoor for some localized build that its ntdll.dll marked
                        //
                        // as English but can't be upgrade by US version.
                        //
                        LANGID DefaultUserLangID = GetDefaultUserLangID();

                        if (DefaultUserLangID  && 
                            TrustedDefaultUserLocale(Inf,DefaultUserLangID)) {

                            langid = DefaultUserLangID;
                        }
                    }
                }

        }
    } else {

        //
        // We're on Win9x.
        //
        dwErr = RegOpenKeyEx( HKEY_USERS,
                              TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                              0,
                              KEY_READ,
                              &hkey );

        if (dwErr == ERROR_SUCCESS) {

            dwSize = sizeof(buffer);
            dwErr = RegQueryValueExA( hkey,
                                     "",
                                     NULL,  //reserved
                                     NULL,  //type
                                     buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS) {
                langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
            }
            RegCloseKey(hkey);
        }

        if ( dwErr != ERROR_SUCCESS ) {
           // Check HKLM\System\CurrentControlSet\Control\Nls\Locale

           dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale"),
                                0,
                                KEY_READ,
                                &hkey );

           if (dwErr == ERROR_SUCCESS) {

              dwSize = sizeof(buffer);
              dwErr = RegQueryValueExA( hkey,
                                        "",
                                        NULL,  //reserved
                                        NULL,  //type
                                        buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS) {
                  langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
              }
              RegCloseKey(hkey);
           }
        }
    }

    return (langid);
}


LANGID 
GetSourceNativeLangID(
    HINF Inf)
/*++

Routine Description:

    [DefaultValues]
    Locale = xxxx
    
    every localized build has it's own Locale in intl.inf, 
    
    so we use this value to identify source languag
        
Arguments:
    
Return Value:

   Language ID of source

--*/
{
    INFCONTEXT InfContext;
    LANGID langid = 0;
    INT i=0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("DefaultValues"), 
                               TEXT("Locale"), 
                               &InfContext )) {


        if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
            langid = (LANGID)i;
        }
    }

    return langid;
}


DWORD 
GetOSMajorID(
    HINF Inf)
{
    INFCONTEXT InfContext;
    DWORD MajorId;
    INT i=0;

    MajorId = 0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("OSVersionMajorID"), 
                               NULL, 
                               &InfContext )) {

        do {
            if (MySetupapiGetIntField( &InfContext, 2, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwPlatformId) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 3, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMajorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 4, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMinorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
                MajorId = (DWORD)i;
                break;
            }
        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }

    return MajorId;
}

DWORD 
GetOSMinorID(
    HINF Inf)
{
    TCHAR Field[128];
    INFCONTEXT InfContext;
    DWORD MinorId;
    INT i = 0;

    MinorId = 0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("OSVVersionMinorID"), 
                               NULL, 
                               &InfContext )) {

        do {
            if (MySetupapiGetIntField( &InfContext, 2, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwPlatformId) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 3, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMajorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 4, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMinorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 5, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwBuildNumber) {
                    continue;
                }
            }
            if (SetupapiGetStringField( &InfContext, 6, Field, (sizeof(Field)/sizeof(TCHAR)), NULL )) {

                if (lstrcmpi(Field,OsVersion.szCSDVersion) != 0) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
                MinorId = (DWORD)i;
                break;
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }

    return MinorId;
}

BOOL 
TrustedDefaultUserLocale(
    HINF Inf,
    LANGID LangID)
{
    TCHAR LangIDStr[9];
    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    wsprintf(LangIDStr,TEXT("0000%04X"),LangID);
    if (SetupapiFindFirstLine( Inf, 
                               TEXT("TrustedDefaultUserLocale"), 
                               LangIDStr, 
                               &InfContext )) {
        do {
            //
            // if in excluded field, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }
    return FALSE;
}

BOOL 
IsInExcludeList(
    HINF Inf,
    LANGID LangID)
{
    TCHAR LangIDStr[9];
    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    wsprintf(LangIDStr,TEXT("0000%04X"),LangID);
    if (SetupapiFindFirstLine( Inf, 
                               TEXT("ExcludeSourceLocale"), 
                               LangIDStr, 
                               &InfContext )) {
        do {
            //
            // if in excluded field, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }
    return FALSE;
}

BOOL 
CheckLanguageVersion(
    HINF Inf,
    LANGID SourceLangID,
    LANGID TargetLangID)
/*++

Routine Description:

    Check if the language of source NT is same as target NT or ,at least, 
    
    compatibile
    
Arguments:

    Inf    handle of intl.inf

Return Value:

   TRUE  They are same or compatibile
   FALSE They are different
   
--*/
{
    TCHAR TargetLangIDStr[9];

    LANGID SrcLANGID;
    LANGID DstLANGID;

    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    //
    // If either one is 0, allow the upgrade. This is Windows 2000 Beta3 behavior.
    //
    if (SourceLangID == 0 || TargetLangID == 0) {
        return TRUE;
    }

    if (SourceLangID == TargetLangID) {
        //
        // special case, for Middle East version, NT5 is localized build but NT4 is not
        //
        // they don't allow NT5 localized build to upgrade NT4, although they are same language
        //
        // so we need to exclude these
        //
        return ((IsInExcludeList(Inf, SourceLangID) == FALSE));
    }

    //
    // if Src != Dst, then we need to look up inf file to see
    //
    // if we can open a backdoor for Target language
    //

    //
    // use TargetLangID as key to find alternative SourceLangID
    //

    wsprintf(TargetLangIDStr,TEXT("0000%04X"),TargetLangID);

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("AlternativeSourceLocale"), 
                               TargetLangIDStr, 
                               &InfContext )) {
        
        do {
            //
            // Check if we found alternative locale
            //
            if (MySetupapiGetIntField(&InfContext, 1, &i, 16)) {

                LANGID AltSourceLangID = LANGIDFROMLCID(i);
    
                if (SourceLangID != AltSourceLangID) {
                    continue;
                }

            }

            //
            // We are here if we found alternative source lang, 
            //
            // now check the version criteria
            //

            //
            // if in excluded list, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 4, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextMatchLine (&InfContext,TargetLangIDStr,&InfContext));
    }
    return FALSE;
}


BOOL InitLanguageDetection(LPCTSTR SourcePath,LPCTSTR InfFile)
/*++

Routine Description:

    Initialize language detection and put the result in 3 global variables
    
    SourceNativeLangID  - LANGID of Source (NT is going to be installed)
    
    TargetNativeLangID  - LANGID of Target (OS system which is running)
    
    IsLanguageMatched - If language is not matched, then blocks upgrade
    
Arguments:

    SourcePath    directory path of INF file
    
    InfFile       INF file name   

Return Value:

   TRUE  init correctly
   FALSE init failed

--*/
{
    HINF    Inf;
    TCHAR   InfName[MAX_PATH];

    if (!FindPathToInstallationFile( InfFile, InfName, MAX_PATH )) {
        return FALSE;
    }

    Inf = SetupapiOpenInfFile( InfName, NULL, INF_STYLE_WIN4, NULL );

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
        }
    

    //
    // Init Global Variables
    //
  
    SourceNativeLangID  = GetSourceNativeLangID(Inf);

    TargetNativeLangID  = GetTargetNativeLangID(Inf);

    IsLanguageMatched = CheckLanguageVersion(Inf,SourceNativeLangID,TargetNativeLangID);

    SetupapiCloseInfFile(Inf);

    return TRUE;
}

BOOL
MySetupapiGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue,
    IN  int Base
    )
/*
    Routine to get a field from an INF file and convert to an integer. The reason
    we have this and don't use Setupapi!SetupGetIntField is because intl.inf mixes and matches 
    numeric conventions. It may use Hex values without a 0x notation and this is an attempt
    to clean that up without modifying the INF. With this change we also won't link to internal Setupapi routines 
    like pSetupGetField.
    
    Arguments:
    
        PINFCONTEXT : - Pointer to setupapi INFCONTEXT structure
        FieldIndex  : - 1-based index for fields, 0 for key itself.
        IntegerValue : - Converted Integer value that is returned by the function
        Base : - Base used for string to integer conversion.
        
    Return Value:
    
        TRUE - If we could convert the returned string to an integer else,
        FALSE
                

*/
{
    DWORD Size = 0;
    PTSTR Field = NULL;
    BOOL Ret = FALSE;

    if( IntegerValue == NULL )
        return FALSE;

    if (Context) {

        if( SetupapiGetStringField( Context, FieldIndex, NULL, 0, &Size )){

            if (Field = MALLOC( Size * sizeof( TCHAR))){

                if( SetupapiGetStringField( Context, FieldIndex, Field, Size, NULL )){

                    *IntegerValue = _tcstoul( Field, NULL, Base );
                    Ret = TRUE;

                }
            }
        }
    }

    if( Field )
        FREE( Field );

    return Ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\misc.c ===
#include "precomp.h"
#pragma hdrstop
#include "sxs.h"

BOOL ForceNTFSConversion;

ULONG
CheckRegKeyVolatility (
    IN HKEY     Root,
    IN LPCTSTR  KeyPath
    )

{
    HKEY    Key;
    HKEY    TestKey;
    ULONG   Error;
    PTSTR   TestKeyName = TEXT( "$winnt32$_test" );
    DWORD   Disposition;

    Error = RegOpenKeyEx( Root,
                          KeyPath,
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return ( Error );

    }

    Error = RegCreateKeyEx( Key,
                            TestKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            MAXIMUM_ALLOWED,
                            NULL,
                            &TestKey,
                            &Disposition );

    if( Error == ERROR_SUCCESS ) {
        RegCloseKey( TestKey );
        RegDeleteKey( Key, TestKeyName );
    }
    RegCloseKey( Key );
    return( Error );
}


ULONG
DumpRegKeyToInf(
    IN  PINFFILEGEN InfContext,
    IN  HKEY        PredefinedKey,
    IN  LPCTSTR     FullKeyPath,
    IN  BOOL        DumpIfEmpty,
    IN  BOOL        DumpSubKeys,
    IN  BOOL        SetNoClobberFlag,
    IN  BOOL        DumpIfVolatileKey
    )
{
    HKEY    Key;
    ULONG   Error;
    TCHAR   SubKeyName[ MAX_PATH + 1 ];
    ULONG   SubKeyNameLength;
    ULONG   cSubKeys;
    ULONG   cValues;
    ULONG   MaxValueNameLength;
    ULONG   MaxValueLength;
    LPTSTR  ValueName;
    PBYTE   ValueData;
    ULONG   i;
    LPTSTR  SubKeyFullPath;
    ULONG   MaxSubKeyNameLength;

    //
    //  Open the key for read access
    //
    Error = RegOpenKeyEx( PredefinedKey,
                          FullKeyPath,
                          0,
                          KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        //
        //  If the key doesn't exist, than assume it got dumped.
        //
        return( ( Error == ERROR_PATH_NOT_FOUND )? ERROR_SUCCESS : Error );
    }

    //
    //  Find out if the key is empty (has no subkeys, and no values)
    //
    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             &cSubKeys,
                             &MaxSubKeyNameLength, //There is a bug before build 3612 where this value may be wrong for HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002
                             NULL,
                             &cValues,
                             &MaxValueNameLength,
                             &MaxValueLength,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }

    if( !DumpIfEmpty && (cSubKeys == 0) && (cValues == 0) ) {
        RegCloseKey( Key );
        return( ERROR_SUCCESS );
    }

    if( !DumpIfVolatileKey ) {
        //
        //  If we are not supposed to dump volatile keys, then check if the key is volatile.
        //
        Error = CheckRegKeyVolatility ( PredefinedKey,
                                        FullKeyPath );
        if( Error == ERROR_CHILD_MUST_BE_VOLATILE ) {
            //
            //  The key is volatile, so skip it.
            //
            RegCloseKey( Key );
            return( ERROR_SUCCESS );
        } else if( Error != ERROR_SUCCESS ) {
            //
            //  We don't knlw if the key is volatile or non-volatile.
            RegCloseKey( Key );
            return( Error );
        }
    }


    Error = InfRecordAddReg( InfContext,
                             PredefinedKey,
                             FullKeyPath,
                             NULL,
                             REG_NONE,
                             NULL,
                             0,
                             SetNoClobberFlag );

    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }


    if( cValues != 0 ) {
        ValueName = (LPTSTR)MALLOC( (MaxValueNameLength + 1)*sizeof(TCHAR) );
        if( !ValueName ) {
	    return ERROR_OUTOFMEMORY;
        }
        ValueData = (PBYTE)MALLOC( MaxValueLength );
        if( !ValueData ) {
	    FREE( ValueName );
            return ERROR_OUTOFMEMORY;
        }

        //
        //  Dump the value entries
        //
        for( i = 0; i < cValues; i++ ) {
            ULONG   ValueNameLength;
            ULONG   ValueType;
            ULONG   DataSize;

            ValueNameLength = MaxValueNameLength + 1;
            DataSize = MaxValueLength;
            Error = RegEnumValue( Key,  // handle of key to query
                                  i,
                                  ValueName,
                                  &ValueNameLength,
                                  NULL,
                                  &ValueType,
                                  ValueData,
                                  &DataSize );

            if( Error != ERROR_SUCCESS ) {
                break;
            }

            Error = InfRecordAddReg( InfContext,
                                     PredefinedKey,
                                     FullKeyPath,
                                     ValueName,
                                     ValueType,
                                     ValueData,
                                     DataSize,
                                     SetNoClobberFlag );

            if( Error != ERROR_SUCCESS ) {
                break;
            }
        }

        FREE( ValueName );
        FREE( ValueData );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( Key );
            return( Error );
        }
    }

    //
    //  Check if subkeys neeed to be dumped
    //
    if( !DumpSubKeys || (cSubKeys == 0) ) {
        RegCloseKey( Key );
        return( ERROR_SUCCESS );
    }
    //
    //  Dump the subkeys
    //
    SubKeyFullPath = (LPTSTR)MALLOC( (lstrlen(FullKeyPath) + 1 + MaxSubKeyNameLength + 1)*sizeof(TCHAR) );
    if( SubKeyFullPath == NULL ) {
        RegCloseKey( Key );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for( i = 0; i < cSubKeys; i++ ) {
        SubKeyNameLength = sizeof( SubKeyName )/sizeof( TCHAR );

        Error = RegEnumKeyEx( Key,
                              i,
                              SubKeyName,
                              &SubKeyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              NULL );
        if( Error != ERROR_SUCCESS ) {
            break;
        }

        //These 3 operations are safe, since the max size of SubKeyFullPath is calculated above
        lstrcpy( SubKeyFullPath, FullKeyPath );
        lstrcat( SubKeyFullPath, TEXT("\\") );
        lstrcat( SubKeyFullPath, SubKeyName );
        Error = DumpRegKeyToInf( InfContext,
                                 PredefinedKey,
                                 SubKeyFullPath,
                                 DumpIfEmpty,
                                 DumpSubKeys,
                                 SetNoClobberFlag,
                                 DumpIfVolatileKey);
        if( Error != ERROR_SUCCESS ) {
            break;
        }
    }
    FREE( SubKeyFullPath );
    RegCloseKey( Key );
    return( Error );
}



BOOL
GetAndSaveNTFTInfo(
    IN HWND ParentWindow
    )
{
    static BOOL Done = FALSE;
    HKEY Key;
    DWORD d;
    LONG l;
    TCHAR HiveName[MAX_PATH];
    PINFFILEGEN   InfContext;

    LONG    i;
    LPTSTR  KeysToMigrate[] = {
                              TEXT("SYSTEM\\DISK"),
                              TEXT("SYSTEM\\MountedDevices")
                              };


    if(Done) {
        return(TRUE);
    }

    Done = TRUE;

    //
    //  Before we migrate the disk information, make the drive letters sticky.
    //  This will ensure that the drive letters assigned during textmode setup
    //  are consistent with the drive letters in the current system.
    //
    ForceStickyDriveLetters();

    //
    // Load up the setupreg.hiv hive.
    //
    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        if(Floppyless) {
            lstrcpy(HiveName,LocalBootDirectory);
        } else {
            HiveName[0] = FirstFloppyDriveLetter;
            HiveName[1] = TEXT(':');
            HiveName[2] = 0;
        }
#endif
    } else {
        //These are both size MAX_PATH tchars
        lstrcpy(HiveName,LocalSourceWithPlatform);
    }

    l = InfStart( WINNT_MIGRATE_INF_FILE,
                  HiveName,
                  &InfContext);

    if(l != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_CANT_SAVE_FT_INFO,
            l,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    l = InfCreateSection( TEXT("Addreg"), &InfContext );
    if(l != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_CANT_SAVE_FT_INFO,
            l,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    //
    //  Dump each key to MIGRATE.INF.
    //
    for( i = 0; i < sizeof(KeysToMigrate)/sizeof(LPTSTR); i++ ) {
        //
        //  Check if the key exists
        //
        l = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                KeysToMigrate[i],
                0,
                KEY_QUERY_VALUE,
                &Key
                );

        if(l != NO_ERROR) {
            if( l == ERROR_FILE_NOT_FOUND ) {
                //
                // The key does not exist.
                // This is OK, just continue the migration of other keys
                //
                continue;
            } else {
                //
                //  The key exists but we cannot read it
                //
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_CANT_SAVE_FT_INFO,
                    l,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
                InfEnd( &InfContext );
                return(FALSE);
            }
        }
        RegCloseKey( Key );
        //
        //  The key exists, so go ahead and dump it.
        //
        l = DumpRegKeyToInf( InfContext,
                             HKEY_LOCAL_MACHINE,
                             KeysToMigrate[i],
                             FALSE,
                             FALSE,
                             FALSE,
                             TRUE );

        if(l != NO_ERROR) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_CANT_SAVE_FT_INFO,
                    l,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                InfEnd( &InfContext );
                return(FALSE);
        }
    }
    InfEnd( &InfContext );
    return(TRUE);
}


BOOL
ForceBootFilesUncompressed(
    IN HWND ParentWindow,
    IN BOOL TellUserAboutError
    )

/*++

Routine Description:

    This routine ensures that critical boot files (ntldr and $ldr$ on amd64/x86)
    are uncompressed. On ARC we also make sure setupldr is uncompressed,
    even though this is not strictly necessary since the system partition
    is always supposed to be FAT, just in case.

Arguments:

    ParentWindow - supplies window handle for window to act as parent/owner of
        any ui windows this routine may display

    TellUserAboutError - if TRUE and and an error occurs, the user will get
        an error message. Otherwise the routine does not tell the user
        about errors.

Return Value:

    Boolean value indicating whether relevent files were processed
    successfully.

--*/

{
    TCHAR Filename[MAX_PATH];


#if defined(REMOTE_BOOT)
    //
    // For remote boot, the loader is on the server, so we don't need to
    // worry about whether it's compressed.
    //
    if (RemoteBoot) {
        return(TRUE);
    }
#endif // defined(REMOTE_BOOT)

    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        //
        // File is NTLDR on BIOS, but don't do this unless we're
        // dealing with the floppyless case.
        //
        if(!MakeBootMedia || !Floppyless) {
            return(TRUE);
        }
        BuildSystemPartitionPathToFile (TEXT("NTLDR"), Filename, MAX_PATH);
#endif // defined(_AMD64_) || defined(_X86_)
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        BuildSystemPartitionPathToFile (SETUPLDR_FILENAME, Filename, MAX_PATH);
#endif // UNICODE
    } // if (!IsArc())

    if(!ForceFileNoCompress(Filename)) {
        if(TellUserAboutError) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                Filename
                );
        }
        return(FALSE);
    }

    //
    // Also do $LDR$
    //
    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        BuildSystemPartitionPathToFile (AUX_BS_NAME, Filename, MAX_PATH);
        if(!ForceFileNoCompress(Filename)) {
            if(TellUserAboutError) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_BOOT_FILE_ERROR,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    Filename
                    );
            }
            return(FALSE);
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } // if (!IsArc())

    return(TRUE);
}

BOOL
InDriverCacheInf( 
    IN      PVOID InfHandle, 
    IN      PCTSTR FileName,
    OUT     PTSTR DriverCabName,        OPTIONAL
    IN      DWORD BufferChars           OPTIONAL
    )
{
    PCTSTR     SectionName;
    UINT       i;
    

    if( !InfHandle ) {
        return( FALSE );
    }

    //
    // Now get the section names that we have to search.
    //
    i = 0;
    SectionName = InfGetFieldByKey ( 
                            InfHandle, 
                            TEXT("Version"), 
                            TEXT("CabFiles"),
                            i);


    if (SectionName) {
    
    
        //
        // Search the sections for our entry.
        //
        do {                   
            
            if( InfDoesEntryExistInSection(InfHandle, SectionName, FileName)){
                if (DriverCabName) {
                    //
                    // fill out the parameter
                    //
                    PCTSTR p = InfGetFieldByKey ( 
                                    InfHandle, 
                                    TEXT("Cabs"), 
                                    SectionName,
                                    0
                                    );
                    if (p) {
                        StringCchCopy (DriverCabName, BufferChars, p);
                    } else {
                        *DriverCabName = 0;
                    }
                }
                //
                // we found a match
                //
                return(TRUE);    
            }
            
            i++;
            SectionName = InfGetFieldByKey ( 
                            InfHandle, 
                            TEXT("Version"), 
                            TEXT("CabFiles"),
                            i);


        } while ( SectionName);

    }

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );




}



BOOL
CreatePrivateFilesInf(
    IN PCTSTR PrivatesDirectory,
    IN PCTSTR InfName)
{
    
    TCHAR infPath[MAX_PATH];
    TCHAR DriverInfName[MAX_PATH];
    TCHAR Search[MAX_PATH];
    WIN32_FIND_DATA CurrentFileInfo;
    HANDLE CurrentFile;
    PVOID InfHandle;
    BOOL retval = FALSE;
    DWORD d;
    HANDLE hPrivateInfFile;
    DWORD dontcare = 0;
    PCSTR privates = "[Privates]\r\n";

    StringCchCopy(infPath, ARRAYSIZE(infPath), LocalSourceWithPlatform);
    if (!ConcatenatePaths( infPath, InfName, MAX_PATH)) {
        goto e0;
    }

    StringCchCopy(Search, ARRAYSIZE(Search), PrivatesDirectory);
    if (!ConcatenatePaths( Search, TEXT("*"), MAX_PATH)) {
        goto e0;
    }

    StringCchCopy(DriverInfName, ARRAYSIZE(DriverInfName), NativeSourcePaths[0]);
    if (!ConcatenatePaths( DriverInfName, DRVINDEX_INF, MAX_PATH)) {
        goto e0;
    }

    CurrentFile = FindFirstFile(Search,&CurrentFileInfo);
    
    if (CurrentFile == INVALID_HANDLE_VALUE) {
        goto e0;
    }

    d = LoadInfFile( DriverInfName, FALSE, &InfHandle );
    
    if (d != NO_ERROR) {
        goto e1;
    }

    WritePrivateProfileString(TEXT("Version"),
                              TEXT("Signature"),
                              TEXT("\"$Windows NT$\""), 
                              infPath);    

#if defined(_X86_)
	WritePrivateProfileString(
                    TEXT("DestinationDirs"),
				    TEXT("Privates"),
                    IsNEC98() ?
                        TEXT("10,\"Driver Cache\\nec98\"") :
				        TEXT("10,\"Driver Cache\\i386\""),
				    infPath
                    );
#elif defined(_AMD64_)
	WritePrivateProfileString(
                    TEXT("DestinationDirs"),
				    TEXT("Privates"),
				    TEXT("10,\"Driver Cache\\amd64\""),
				    infPath
                    );

#elif defined(_IA64_)
	WritePrivateProfileString(
                    TEXT("DestinationDirs"),
				    TEXT("Privates"),
				    TEXT("10,\"Driver Cache\\ia64\""),
				    infPath
                    );
#else
#error "No Target Architecture"
#endif

    WritePrivateProfileString(TEXT("InstallSection"),
                              TEXT("CopyFiles"),
                              TEXT("Privates"), 
                              infPath);

#ifndef UNICODE
    WritePrivateProfileString (NULL, NULL, NULL, infPath);
#endif

    //
    // writeprivateprofilestring works for the above, but doesnt work for 
    // adding files to the section, so we have to do it manually...yuck!
    //
    hPrivateInfFile = CreateFile(
                            infPath,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

    if (hPrivateInfFile == INVALID_HANDLE_VALUE) {
        goto e2;
    }

    //
    // seek to the end of the file so we don't overwrite everything we already
    // put in there
    //
    SetFilePointer(hPrivateInfFile,0,0,FILE_END);
    
    WriteFile(hPrivateInfFile,(LPCVOID)privates,lstrlenA(privates),&dontcare,NULL);    
    
    do {
        if (InDriverCacheInf( InfHandle, CurrentFileInfo.cFileName, NULL, 0 )) {
            CHAR AnsiFile[MAX_PATH+2]; //2 ==> CR, LF
            DWORD Size;
            DWORD Written;
              
#ifdef UNICODE
        WideCharToMultiByte(
             CP_ACP,
             0,
             CurrentFileInfo.cFileName,
             -1,
             AnsiFile,
             sizeof(AnsiFile),
             NULL,
             NULL
             );
#else
        StringCbCopyA(AnsiFile,sizeof(AnsiFile),CurrentFileInfo.cFileName);
#endif

        StringCbCatA(AnsiFile,sizeof(AnsiFile),"\r\n");
        WriteFile(hPrivateInfFile,AnsiFile,lstrlenA(AnsiFile),&Written,NULL);        

        }

    } while ( FindNextFile(CurrentFile,&CurrentFileInfo) );

    CloseHandle(hPrivateInfFile);

    retval = TRUE;

e2:
    UnloadInfFile( InfHandle );
e1:
    FindClose( CurrentFile );
e0:
    return(retval);
}


DWORD
DoPostCopyingStuff(
    IN PVOID ThreadParam
    )

/*++

Routine Description:

    This routine performs actions that are done after copying has been
    finished. This includes

    - amd64/X86 boot stuff (boot.ini, boot code, etc)
    - Saving NTFT information into the setup hive
    - Forcing ntldr or setupldr to be uncompressed

Arguments:

Return Value:

--*/

{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    BOOL b;

    //
    //  Check to see if delta.cat was processed as a result of 
    //  /m so that we can write the "includecatalog = delta.cat"
    //  to winnt.sif
    //

    if ((AlternateSourcePath[0] != UNICODE_NULL) && MakeLocalSource) {
        TCHAR Buff[MAX_PATH];
        LPCTSTR WinntSetupSection = WINNT_SETUPPARAMS;

        //This is safe, since both buffers are of size MAX_PATH
        lstrcpy( Buff, LocalSourceWithPlatform );
        ConcatenatePaths( Buff, TEXT("delta.cat"), MAX_PATH);


        if( FileExists(Buff,NULL) ){

            // Write out entry into winnt.sif

            WritePrivateProfileString(WinntSetupSection,WINNT_S_INCLUDECATALOG,TEXT("delta.cat"),ActualParamFile);
            
        }

        //
        // also create an inf file for the files that were changed and copy it to the local source as well
        //
        CreatePrivateFilesInf(AlternateSourcePath, TEXT("delta.inf"));

    }

#ifdef TEST_EXCEPTION
    DoException( 4);
#endif


    //
    // ALWAYS do this, since the system might not boot otherwise.
    //
    if(b = ForceBootFilesUncompressed(ThreadParam,TRUE)) {

        //
        // In the BIOS case, lay boot code, munge boot.ini, etc.
        //
        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            if(MakeBootMedia && Floppyless) {
                b = DoX86BootStuff(ThreadParam);
            }
#endif // defined(_AMD64_) || defined(_X86_)
        } // if (!IsArc())

        //
        // In the NT case, also save off disk information into
        // the tiny setup system hive. This is done on both clean
        // install and upgrade case, so that drive letters can be
        // preserved.
        // Drive letters should not be migrated on OEM preinstall case
        //
        if(ISNT() && !OemPreinstall
#if defined(_AMD64_) || defined(_X86_)
           && MakeBootMedia
#endif
        ) {
            if( !GetAndSaveNTFTInfo(ThreadParam) ) {
                b = FALSE;
            }
        }
    }

    {
        SXS_CHECK_LOCAL_SOURCE SxsCheckLocalSourceParameters = { 0 };

        SxsCheckLocalSourceParameters.ParentWindow = ThreadParam;
        if (!SxsCheckLocalSource(&SxsCheckLocalSourceParameters))
        {
            b = FALSE;
        }
    }

    PostMessage(ThreadParam,WMX_I_AM_DONE,b,0);
    return(b);
}


BOOL
IsNTFSConversionRecommended(
    void
    )
{
    if (UnattendedOperation) {
        return FALSE;
    }

    if (TYPICAL() || !ISNT()) {
        //
        // NTFS conversion is not recommended
        // for win9x upgrades or if the user chooses typical
        //
        return FALSE;
    }

    if (NTFSConversionChanged) {
        return ForceNTFSConversion;
    }

    return TRUE;
}


BOOL
NTFSConvertWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bPainted = FALSE;


    switch(msg) {
        case WM_INITDIALOG:
            if (!UnattendedOperation) {
                CheckRadioButton( hdlg, IDOK, IDCANCEL, IsNTFSConversionRecommended() ? IDOK : IDCANCEL );
                if (TYPICAL())
                {
                    ForceNTFSConversion = FALSE;
                }
            }
            break;

	case WM_CTLCOLORDLG:
	    bPainted = TRUE;
	    return FALSE;

        case WMX_ACTIVATEPAGE:

            if(wParam) {
                HCURSOR OldCursor;
                MSG msgTemp;
                TCHAR buf[MAX_PATH];

                //
                // don't activate the page in restart mode
                //
                if (Winnt32RestartedWithAF ()) {
                    if (GetPrivateProfileString(
                            WINNT_UNATTENDED,
                            TEXT("ForceNTFSConversion"),
                            TEXT(""),
                            buf,
                            sizeof(buf) / sizeof(TCHAR),
                            g_DynUpdtStatus->RestartAnswerFile
                            )) {
                        ForceNTFSConversion = !lstrcmpi (buf, WINNT_A_YES);
                    }
                    return FALSE;
                }

		        // Scanning for drives can take a bit of time, so we lets change
		        // the cursor to let the user know this should take a while
                OldCursor = SetCursor(LoadCursor (NULL, IDC_WAIT));


#ifdef _X86_

                //
                // Skip if this is a clean install from Win95 so that dual boot is safe
                //
                if( !Upgrade && !ISNT() ){
                    SetCursor(OldCursor);
                    return( FALSE );
                }


                //
                // We will skip this wizard page if in Win9x upgrade and Boot16 option is ON.
                //
                if (Upgrade && !ISNT() && (g_Boot16 == BOOT16_YES)) {
                    SetCursor(OldCursor);
                    return FALSE;
                }
#endif


                //
                // We may not want to display this page under
                // certain circumstances.
                //
                if( ISNT() && Upgrade ) {
                    TCHAR   Text[MAX_PATH];
                    //
                    // We're on NT and we know where the %windir%
                    // will be since we're doing an upgrade.  Is
                    // it on a partition that's already NTFS?  If so,
                    // don't bother with this page.
                    //
                    MyGetWindowsDirectory( Text, MAX_PATH );
                    if( IsDriveNTFS( Text[0] ) ) {
                        SetCursor(OldCursor);
                        return FALSE;
                    }

                    if (IsArc()) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        //
                        // Let's also make sure we're not asking to
                        // upgrade the system partition on ARC (which
                        // must remain FAT).
                        //
                        MyGetWindowsDirectory( Text, MAX_PATH );
                        if( SystemPartitionDriveLetter == Text[0] ) {
                            SetCursor(OldCursor);
                            return FALSE;
                        }
#endif // UNICODE
                    } // if (IsArc())
                }


                //
                // Last, but not least, disallow the page if all partitions
                // are already NTFS...
                //
                if( ISNT() ) {
                BOOL AllNTFS = TRUE;
                TCHAR DriveLetter;
                    for( DriveLetter = TEXT('A'); DriveLetter <= TEXT('Z'); DriveLetter++ ) {

                        //
                        // Skip the system partition drive on ARC
                        //
                        if( (IsArc() && (DriveLetter != SystemPartitionDriveLetter)) || !IsArc() ) {

                            AllNTFS &= (
                                         //
                                         // Is the drive NTFS?
                                         //
                                         (IsDriveNTFS(DriveLetter)) ||

                                         //
                                         // If it's removable, don't even
                                         // consider it because we can't
                                         // install there anyway.  This gets
                                         // around the problem where the
                                         // user has a CD in his CDROM drive
                                         // or has a floppy in his floppy drive
                                         // while we're doing this check.
                                         //
                                         (MyGetDriveType(DriveLetter) != DRIVE_FIXED) );

                        }
                    }

                    if( AllNTFS ) {
			SetCursor(OldCursor);
                        return FALSE;
                    }
                }

                //
                // Activation.
                //

                //
                // WMX_VALIDATE will return TRUE if the page should be skipped,
                // that is if we are in unattended mode and the parameters are OK.
                //

                if (CallWindowProc ((WNDPROC)NTFSConvertWizPage, hdlg, WMX_VALIDATE, 0, 0)) {
		    SetCursor(OldCursor);
                    return FALSE;
                }

		// if we get this far, we want to empty the message cue, to make sure
		// that people will see this page, and not accidentally agree to
		// converting their drives because they were antsy
		
		while (PeekMessage(&msgTemp,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
		while (PeekMessage(&msgTemp,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));

		SetCursor(OldCursor);
            }
            return TRUE;

        case WMX_VALIDATE:
            //
            // In the unattended case, this page might get reactivated because of an error,
            // in which case we don't want to automatically continue because we could
            // get into an infinite loop.
            //
            if(!WizPage->PerPageData) {
                WizPage->PerPageData = 1;
                if (((UnattendedOperation) && (!CancelPending)) || 
                     (NTFSConversionChanged && (!CancelPending)) ||
                     (TYPICAL() && (!CancelPending)) ) {
                    return TRUE;
                }
            }
            else if (TYPICAL() && (!CancelPending)) 
            {
                // If WizPage->PerPageData == 1 we already ran through the above check.
                // and in the typical case we don't show the NTFS conversion page.
                // Anything wrong with the unattend value for NTFS would have been 
                // cought the first time.
                return TRUE;
            }
            return FALSE;

        case WMX_NEXTBUTTON:
	    // don't let the user choose next until we know the screen has been painted.
	    if (!bPainted){
	        // while we're here, empty the queue of mouse/key presses so we might not
		// have to follow this path again.
		MSG m;
		while (PeekMessage(&m,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
		while (PeekMessage(&m,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));
	        return FALSE;
	    }
            if (IsDlgButtonChecked( hdlg, IDOK ) == BST_CHECKED) {
                ForceNTFSConversion = TRUE;
            } else {
                ForceNTFSConversion = FALSE;
            }
            return TRUE;

        default:
            break;
    }

    return FALSE;
}

UINT
MyGetWindowsDirectory(
    LPTSTR  MyBuffer,
    UINT    Size
    )
/*++

Routine Description:

    Get the windows directory in a terminal-server-aware fashion.

       
Arguments:

    MyBuffer    - Holds the return string.

    Size        - How big is the buffer?

Return Value:

    length of the string we copied or 0 if there was an error or if the
    supplied buffer wasn't big enough

--*/
{
HMODULE     hModuleKernel32;
FARPROC     MyProc;
UINT        ReturnVal = 0;

#if defined(UNICODE)
    if( ISNT() ) {

        //
        // We can't trust GetWindowsDirectory because Terminal Server may be
        // installed, so use GetSystemWindowsDirectory.
        //
        if( hModuleKernel32 = LoadLibrary( TEXT("kernel32") ) ) {
            if( MyProc = GetProcAddress(hModuleKernel32,"GetSystemWindowsDirectoryW")) {
                ReturnVal = (UINT)MyProc( MyBuffer, Size );
            }
            FreeLibrary(hModuleKernel32);
        }
    }
#endif

    if( ReturnVal == 0 ) {
        ReturnVal = GetWindowsDirectory( MyBuffer, Size );
    }
    //
    // no matter what, make sure the buffer is nul-terminated
    //
    if (Size > 0) {
        MyBuffer[Size - 1] = 0;
    }

    return ReturnVal < Size ? ReturnVal : 0;
}

//
// Calc how fast setup can coyp files
//
#define BUFFER_SIZE 0x1000
DWORD dwThroughPutSrcToDest;
DWORD dwThroughPutHDToHD;

DWORD GetThroughput(LPTSTR Source, LPTSTR Dest)
{
    BYTE buffer[BUFFER_SIZE];
    HANDLE hFile = NULL;
    HANDLE hFileOut = NULL;
    DWORD bytes;
    DWORD written;
    DWORD size;
    DWORD ticks;
    ticks = GetTickCount();

    hFile = CreateFile(Source, 
                GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    hFileOut = CreateFile(Dest, 
                GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    size = 0;
    if ((hFile != INVALID_HANDLE_VALUE) && (hFileOut != INVALID_HANDLE_VALUE))

    {
        do
        {
            ReadFile(hFile, buffer, BUFFER_SIZE, &bytes, NULL);
            if (hFileOut)
                WriteFile(hFileOut, buffer, bytes, &written, NULL);
            size += bytes;
        } while (bytes == BUFFER_SIZE);
        CloseHandle(hFile);
        if (hFileOut)
        {
            FlushFileBuffers(hFileOut);
            CloseHandle(hFileOut);
        }
        ticks = (GetTickCount() - ticks);
        // If less then a second, assume 1 second.
        if (ticks == 0)
        {
            ticks = 1;
        }

        ticks = (size/ticks);
    }
    else
    {
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
        if (hFileOut != INVALID_HANDLE_VALUE)
            CloseHandle(hFileOut);
        // Failed to open/create one of the files. Assume a through put of 5KB/msec
        ticks = DEFAULT_IO_THROUGHPUT;
    }
    return ticks;
}

// Copy txtsetup.sif from the sources to %windir%\$win_nt$.~ls
// and determine the throughput for this.
// Then copy txtsetup.sif in the local folder to testfile.000 and
// calc the throughput for that.
// Remove the folder.
void CalcThroughput()
{
    TCHAR SrcFolder[MAX_PATH];
    TCHAR DestFolder[MAX_PATH];
    TCHAR Folder[MAX_PATH];

    MyGetWindowsDirectory(Folder, sizeof(DestFolder)/sizeof(TCHAR));
    // Only use the driver
    Folder[3] = TEXT('\0');
    ConcatenatePaths( Folder, LOCAL_SOURCE_DIR, MAX_PATH);
    if (CreateMultiLevelDirectory(Folder) == NO_ERROR)
    {
        lstrcpy(DestFolder, Folder);
        ConcatenatePaths( DestFolder, TEXTMODE_INF, MAX_PATH);
        lstrcpy(SrcFolder, NativeSourcePaths[0]);
        ConcatenatePaths( SrcFolder, TEXTMODE_INF, MAX_PATH);
        dwThroughPutSrcToDest = GetThroughput(SrcFolder, DestFolder);
        // 
        lstrcpy(SrcFolder, DestFolder);
        lstrcpy(DestFolder, Folder);
        ConcatenatePaths( DestFolder, TEXT("testfile.000"), MAX_PATH);
        dwThroughPutHDToHD = GetThroughput(SrcFolder, DestFolder);
        MyDelnode(Folder);
        wsprintf(Folder, TEXT("SrcToDest: %d bytes/msec HDtoHD: %d bytes/msec"),dwThroughPutSrcToDest, dwThroughPutHDToHD);
        DebugLog(Winnt32LogInformation,Folder,0 );
    }
}

#ifdef UNICODE

#define NB10_SIG        ((DWORD)'01BN')
#define RSDS_SIG        ((DWORD)'SDSR')

typedef struct _NB10I              // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
    char    szPdb[_MAX_PATH];
} NB10I, *PNB10I;

typedef struct _NB10I_HEADER       // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
} NB10IH, *PNB10IH;

typedef struct _RSDSI              // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
    char    szPdb[_MAX_PATH * 3];
} RSDSI, *PRSDSI;

typedef struct _RSDSI_HEADER       // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
} RSDSIH, *PRSDSIH;

typedef union _CVDD
{
    DWORD   dwSig;
    NB10I   nb10i;
    RSDSI   rsdsi;
    NB10IH  nb10ih;
    RSDSIH  rsdsih;
} CVDD, *PCVDD;


//BUGBUG -- what about c:\\myfile.txt.   (with a trailing dot character)
BOOL
ExtractFileName(PCHAR pName, PCHAR pFileName, IN INT pCchFileName)
{
    // Extract the name part of the filename.
    PCHAR pStartName, pEndName;
    pEndName = pName + strlen(pName);
    while ((*pEndName != '.') && (pEndName != pName)) {
        pEndName--;
    }

    if (pEndName == pName) {
        return FALSE;
    }

    // String consist of just '.' or no periods at all?
    if ((pEndName == pName) || 
        ((pEndName-1) == pName))
    {
        return FALSE;
    }

    pStartName = pEndName-1;

    while ((*pStartName != '\\') && (pStartName != pName)) {
        pStartName--;
    }

    // Found either the start of the string (filename.pdb) or the first backslash
    // path\filename.pdb.

    if (*pStartName == '\\')
        pStartName++;

    // Someone pass us \\.?
    if (pStartName == pEndName) {
        return FALSE;
    }

    CopyMemory(pFileName, pStartName, min (pEndName - pStartName, pCchFileName));
    return TRUE;
}

CHAR HalName[_MAX_FNAME];

PCHAR
FindRealHalName(TCHAR *pHalFileName)
{
    HINSTANCE hHal = NULL;
    PIMAGE_DEBUG_DIRECTORY pDebugData;
    DWORD DebugSize, i;
    BOOL NameFound = FALSE;

    __try {
        hHal = LoadLibraryEx(pHalFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (!hHal) {
            __leave;
        }
    
        pDebugData = RtlImageDirectoryEntryToData(hHal, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);
    
        // verify we have debug data and it's a reasonable size.
        if (!pDebugData || 
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            (DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)))
        {
            __leave;
        }
    
        ZeroMemory(HalName, sizeof(HalName));
    
        // See if we have CV or MISC debug data.
        for (i = 0; i < DebugSize/sizeof(IMAGE_DEBUG_DIRECTORY); i++) {
            if (pDebugData->Type == IMAGE_DEBUG_TYPE_MISC) {
                // Misc data.
                PIMAGE_DEBUG_MISC pMisc = (PIMAGE_DEBUG_MISC)((PCHAR)(hHal) - 1 + pDebugData->AddressOfRawData);
                PCHAR pName = pMisc->Data;
                NameFound = ExtractFileName(pName, HalName, ARRAYSIZE(HalName));
                __leave;
            }
    
            if (pDebugData->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
                // got cv, see if it's nb10 (pdb) or rsds (v7 pdb)
                PCVDD pCodeView = (PCVDD)((PCHAR)(hHal) - 1 + pDebugData->AddressOfRawData);
                if (pCodeView->dwSig == NB10_SIG) {
                    NameFound = ExtractFileName(pCodeView->nb10i.szPdb, HalName, ARRAYSIZE(HalName));
                    __leave;
                }

                if (pCodeView->dwSig == RSDS_SIG) {
                    NameFound = ExtractFileName(pCodeView->rsdsi.szPdb, HalName, ARRAYSIZE(HalName));
                    __leave;
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (hHal) {
        FreeLibrary(hHal);
    }

    if (NameFound) {
        return HalName;
    } else {
        return NULL;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\options.c ===
#include "precomp.h"
#pragma hdrstop


DWORD OptionsDlgContextHelp[] = { IDC_MAKELOCALSOURCEFROMCD, IDH_MAKELOCALSOURCEFROMCD,
                                  IDC_USEFLOPPIES          , IDH_USEFLOPPIES,
                                  IDC_SYSPARTDRIVE         , IDH_SYSPARTDRIVE,
                                  IDT_SYSPARTTEXT          , IDH_SYSPARTDRIVE,
                                  IDC_CHOOSE_INSTALLPART   , IDH_CHOOSE_INSTALLPART,
                                  IDC_INSTALL_DIR          , IDH_INSTALL_DIR,
                                  0                        , 0
                                };

typedef struct _LOCALE_ENTRY {
    LPTSTR Lcid;
    LPTSTR Description;
    LPTSTR LanguageGroup1;
    LPTSTR LanguageGroup2;
} LOCALE_ENTRY, *PLOCALE_ENTRY;

typedef struct _LANGUAGE_GROUP_ENTRY {
    LPTSTR Id;
    LPTSTR Description;
    LPTSTR Directory;
    BOOL    Selected;
} LANGUAGE_GROUP_ENTRY, *PLANGUAGE_GROUP_ENTRY;

BOOL    IntlInfProcessed = FALSE;
DWORD   LocaleCount = 0;
PLOCALE_ENTRY LocaleList;
DWORD   PrimaryLocale;
DWORD   LanguageGroupsCount = 0;
PLANGUAGE_GROUP_ENTRY   LanguageGroups;
BOOL    NTFSConversionChanged;

//
// Headless settings.
//
TCHAR   HeadlessSelection[MAX_PATH];
ULONG   HeadlessBaudRate = 0;
#define DEFAULT_HEADLESS_SETTING TEXT("COM1")

BOOL
(*Kernel32IsValidLanguageGroup)(
    IN LGRPID  LanguageGroup,
    IN DWORD   dwFlags);

// Only used for amd64/X86 case.
BOOL ForceFloppyless = FALSE;
UINT g_Boot16 = BOOT16_NO;


INT_PTR
OptionsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    TCHAR Text[MAX_PATH];

    switch(msg) {

    case WM_INITDIALOG:

#if defined(REMOTE_BOOT)
        if (RemoteBoot) {

            //
            // For remote boot client upgrade, uncheck and disable the
            // "copy files from CD-ROM to hard drive" checkbox.
            //
            CheckDlgButton(hdlg,IDC_MAKELOCALSOURCEFROMCD,BST_UNCHECKED);
            EnableWindow(GetDlgItem(hdlg,IDC_MAKELOCALSOURCEFROMCD),FALSE);
            ShowWindow(GetDlgItem(hdlg, IDC_MAKELOCALSOURCEFROMCD), SW_HIDE);

        } else
#endif // defined(REMOTE_BOOT)
        {

            if (!IsArc()) {
                //
                // Set initial state of "copy files from CD-ROM to hard drive"
                // checkbox. Note that that control might be disabled.
                //
                CheckDlgButton(hdlg,
                    IDC_MAKELOCALSOURCEFROMCD,
                    MakeLocalSource ? BST_CHECKED : BST_UNCHECKED);

                if(!RunFromCD) {
                    //
                    // Not run from CD, disable the control. The box won't be checked.
                    // But MakeLocalSource is probably TRUE.
                    //
                    EnableWindow(GetDlgItem(hdlg,IDC_MAKELOCALSOURCEFROMCD),FALSE);
                }
            } else {
                //
                //  On ARC machines the files are always copied to the hard drive
                //
                ShowWindow(GetDlgItem(hdlg, IDC_MAKELOCALSOURCEFROMCD), SW_HIDE);
            } // if (!IsArc())
        }



        //
        // Disable system partition controls?
        //
#if defined _IA64_
        EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),FALSE);
        ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SW_HIDE);
        ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SW_HIDE);
#else
        if( !IsArc()) {
            EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),FALSE);
            ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SW_HIDE);
            ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SW_HIDE);
        } else {
            EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SystemPartitionDriveLetter != 0);
            ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SystemPartitionDriveLetter ? SW_SHOW : SW_HIDE);
            ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SystemPartitionDriveLetter ? SW_SHOW : SW_HIDE);
        }
#endif



        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            if (Upgrade && !ISNT()) {
                //
                // Populate the Boot16 value.
                //
                SendDlgItemMessage(hdlg,IDC_BOOT16_1,BM_SETCHECK, (g_Boot16 == BOOT16_AUTOMATIC) ? BST_CHECKED : BST_UNCHECKED, 0);
                SendDlgItemMessage(hdlg,IDC_BOOT16_2,BM_SETCHECK, (g_Boot16 == BOOT16_YES      ) ? BST_CHECKED : BST_UNCHECKED, 0);
                SendDlgItemMessage(hdlg,IDC_BOOT16_3,BM_SETCHECK, (g_Boot16 == BOOT16_NO       ) ? BST_CHECKED : BST_UNCHECKED, 0);
            }

            //
            // Set floppyless control.
            //
#if defined(REMOTE_BOOT)
            if (RemoteBoot) {
                //
                // For remote boot client upgrade, this is always unchecked and disabled.
                //
                CheckDlgButton(hdlg,IDC_USEFLOPPIES,BST_UNCHECKED);
                EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                ShowWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),SW_HIDE);
            } else
#endif // defined(REMOTE_BOOT)
            {
                CheckDlgButton(hdlg,IDC_USEFLOPPIES,Floppyless ? BST_UNCHECKED : BST_CHECKED);
                if(ForceFloppyless) {
                    EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                }
            }
#endif // defined(_AMD64_) || defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // Get rid of floppy-related controls.
            //
            EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
            ShowWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),SW_HIDE);

            //
            // Populate the system partition combobox.
            //
            if (SystemPartitionDriveLetter)
            {
                PWCHAR p;
                WCHAR x[3];

                x[1] = L':';
                x[2] = 0;

                for(p=SystemPartitionDriveLetters; *p; p++) {

                    x[0] = *p;

                    SendDlgItemMessage(hdlg,IDC_SYSPARTDRIVE,CB_ADDSTRING,0,(LPARAM)x);
                }

                x[0] = SystemPartitionDriveLetter;
                SendDlgItemMessage(hdlg,IDC_SYSPARTDRIVE,CB_SELECTSTRING,(WPARAM)(-1),(LPARAM)x);
            }
#endif // UNICODE
        } // if (!IsArc())

        //
        // Set text in edit controls, and configure the control a little.
        //
        SetDlgItemText(hdlg,IDC_SOURCE,InfName);
        SendDlgItemMessage(hdlg,IDC_SOURCE,EM_LIMITTEXT,MAX_PATH,0);

        if(SourceCount == 1) {
            EnableWindow(GetDlgItem(hdlg,IDC_SOURCE2),TRUE);
            SetDlgItemText(hdlg,IDC_SOURCE2,NativeSourcePaths[0]);
        } else {
            LoadString(hInst,IDS_MULTIPLE,Text,sizeof(Text)/sizeof(TCHAR));
            SetDlgItemText(hdlg,IDC_SOURCE2,Text);
            EnableWindow(GetDlgItem(hdlg,IDC_SOURCE2),FALSE);
        }
        SendDlgItemMessage(hdlg,IDC_SOURCE2,EM_LIMITTEXT,MAX_PATH-1,0);

        SetDlgItemText(hdlg,IDC_INSTALL_DIR,InstallDir);
        //
        // limit the path to the same value as textmode setup (50 TCHARS)
        //

#define MAX_NT_DIR_LEN      50

        SendDlgItemMessage(hdlg,IDC_INSTALL_DIR,EM_LIMITTEXT,MAX_NT_DIR_LEN,0);

        CheckDlgButton(hdlg,IDC_CHOOSE_INSTALLPART,ChoosePartition ? BST_CHECKED : BST_UNCHECKED);

        if (Upgrade) {
            TCHAR Text[MAX_PATH];

            //
            // Set the installation directory to the current Windows directory,
            // then disable the user's ability to edit it.
            //
            MyGetWindowsDirectory(Text,MAX_PATH);
            SetDlgItemText(hdlg,IDC_INSTALL_DIR,Text+3);
            SendDlgItemMessage(hdlg,IDC_INSTALL_DIR,EM_LIMITTEXT,MAX_PATH,0);

            EnableWindow(GetDlgItem(hdlg,IDC_INSTALL_DIR),FALSE);
            EnableWindow(GetDlgItem(hdlg,IDC_CHOOSE_INSTALLPART),FALSE);
        }

        //
        // On server installs, don't all the user to modify the
        // install partition selection state
        //
        if (Server) {
            EnableWindow( GetDlgItem(hdlg,IDC_CHOOSE_INSTALLPART), FALSE );
        }

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
#if defined(REMOTE_BOOT)
                if (RemoteBoot) {
                    MakeLocalSource = FALSE;
                } else
#endif // defined(REMOTE_BOOT)
                if(RunFromCD) {
                    if (!IsArc()) {
#if defined(_AMD64_)
                        MakeLocalSource = TRUE;
                        UserSpecifiedMakeLocalSource = TRUE;

#endif // defined(_AMD64_)

#if defined(_X86_)
                        MakeLocalSource = (IsDlgButtonChecked(hdlg,IDC_MAKELOCALSOURCEFROMCD) == BST_CHECKED);
                        UserSpecifiedMakeLocalSource = (IsDlgButtonChecked(hdlg,IDC_MAKELOCALSOURCEFROMCD) == BST_CHECKED);
#endif // defined(_X86_)
                    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        MakeLocalSource = TRUE;
                        UserSpecifiedMakeLocalSource = TRUE;
#endif // UNICODE
                    } // if (!IsArc())
                }

                if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
#if defined(REMOTE_BOOT)
                    if (RemoteBoot) {
                        MakeBootMedia = FALSE;
                        Floppyless = TRUE;
                    } else
#endif // defined(REMOTE_BOOT)
                    {
                        Floppyless = (IsDlgButtonChecked(hdlg,IDC_USEFLOPPIES) == BST_UNCHECKED);
                    }
#endif // defined(_AMD64_) || defined(_X86_)
                } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        WCHAR x[3];

                        GetDlgItemText(hdlg,IDC_SYSPARTDRIVE,x,3);
                        SystemPartitionDriveLetter = x[0];
                        LocalBootDirectory[0] = x[0];
#endif // UNICODE
                } // if (!IsArc())

                GetDlgItemText(hdlg,IDC_SOURCE,InfName,MAX_PATH);

                if(SourceCount == 1) {
                    GetDlgItemText(hdlg,IDC_SOURCE2,NativeSourcePaths[0],MAX_PATH);
                }


                {
                    TCHAR tmp[MAX_PATH];
                    BOOL bSelectedChoosePartition;

                    bSelectedChoosePartition = (IsDlgButtonChecked(hdlg, IDC_CHOOSE_INSTALLPART) == BST_CHECKED);
                    
                    GetDlgItemText(hdlg,IDC_INSTALL_DIR,tmp,MAX_PATH);
                    if (tmp[0] == 0) {
                        InstallDir[0] = 0;
                    } else if (tmp[1] == L':' && tmp[2] == L'\\') 
                    {
                        // User included a drive letter.
                        // remove it and assume they selected to choose the installation
                        // partition in textmode.
                        lstrcpy( InstallDir, &tmp[2] );
                        bSelectedChoosePartition = TRUE;
                    } else {
                        if (tmp[0] == L'\\') {
                            lstrcpy( InstallDir, tmp );
                        } else {
                            InstallDir[0] = L'\\';
                            lstrcpy( &InstallDir[1], tmp );
                        }
                    }
                    //
                    // if user selected any of the accessibility options, warn about choosing the partition installation
                    //
                    if(bSelectedChoosePartition && 
                        (AccessibleMagnifier || AccessibleKeyboard || AccessibleVoice || AccessibleReader) &&
                        IDYES != MessageBoxFromMessage(hdlg, MSG_WARNING_ACCESSIBILITY, FALSE, AppTitleStringId, MB_YESNO | MB_ICONEXCLAMATION)) {
                        b = TRUE;
                        break;
                    }

                    ChoosePartition = bSelectedChoosePartition;
                }

                //
                // warn the user if their install dir is > 8 characters, since it will be truncated
                //
                if (!IsValid8Dot3(InstallDir) && IsWindowEnabled(GetDlgItem(hdlg,IDC_INSTALL_DIR ))) {
                    InstallDir[0] = 0;
                    MessageBoxFromMessage(
                        hdlg,
                        MSG_WRN_TRUNC_WINDIR,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONEXCLAMATION
                        );
                    SetFocus(GetDlgItem(hdlg,IDC_INSTALL_DIR));
                    b = FALSE;

                } else {

                   EndDialog(hdlg,TRUE);
                   b = TRUE;
                }


#ifdef _X86_
                {
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_1, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_AUTOMATIC;
                    }
                    else
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_2, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_YES;
                    }
                    else
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_3, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_NO;
                    }
                    else {
                        g_Boot16 = BOOT16_AUTOMATIC;
                    }
                }
#endif


                //
                // Now take care of the headless settings.
                //
                if( IsDlgButtonChecked( hdlg, IDC_ENABLE_HEADLESS) == BST_CHECKED ) {

                    //
                    // He wants to run setup, and the resulting installation
                    // through a headless port.  Got figure out which headless
                    // port he wants to use.
                    //
                    GetDlgItemText( hdlg,
                                    IDC_HEADLESS_PORT,
                                    HeadlessSelection,
                                    MAX_PATH );

                    if( (HeadlessSelection[0] == 0) ||
                        (lstrcmpi( HeadlessSelection, TEXT("usebiossettings"))) ||
                        (_tcsnicmp( HeadlessSelection, TEXT("com"), 3)) ) {

                        //
                        // He gave us something that's invalid.
                        //
                        MessageBoxFromMessage( hdlg,
                                               MSG_INVALID_HEADLESS_SETTING,
                                               FALSE,
                                               AppTitleStringId,
                                               MB_OK | MB_ICONEXCLAMATION );

                        _tcscpy( HeadlessSelection, DEFAULT_HEADLESS_SETTING );
                        SetDlgItemText( hdlg,
                                        IDC_HEADLESS_PORT,
                                        HeadlessSelection );

                        SetFocus(GetDlgItem(hdlg,IDC_HEADLESS_PORT));
                        b = FALSE;

                    }
                }
            }
            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;

        case IDC_ENABLE_HEADLESS:

            if( HIWORD(wParam) == BN_CLICKED ) {

                if( IsDlgButtonChecked(hdlg, IDC_ENABLE_HEADLESS) ) {

                    //
                    // Make sure the headless settings box is enabled.
                    //
                    EnableWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), TRUE );
                    ShowWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), SW_SHOW );
                    if( HeadlessSelection[0] == TEXT('\0') ) {

                        //
                        // This is the first time the user has asked
                        // us to enable Headless.  Suggest the use of
                        // se the default COM port.
                        //
                        _tcscpy( HeadlessSelection, DEFAULT_HEADLESS_SETTING );

                    }
                    SetDlgItemText( hdlg,
                                    IDC_HEADLESS_PORT,
                                    HeadlessSelection );

                    SetFocus(GetDlgItem(hdlg,IDC_HEADLESS_PORT));

                } else {

                    //
                    // Disable the headless settings box since the
                    // user has chosen not to use headless.
                    //
                    HeadlessSelection[0] = TEXT('\0');
                    EnableWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), FALSE );
                    ShowWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), SW_HIDE );
                }
            }
            break;

        case IDC_HEADLESS_PORT:

            if( HIWORD(wParam) == EN_CHANGE) {

                EnableWindow( GetDlgItem(hdlg, IDOK),
                              SendDlgItemMessage(hdlg, IDC_HEADLESS_PORT,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE );
            }
            break;

        case IDC_SOURCE:

            if(HIWORD(wParam) == EN_CHANGE) {

                EnableWindow(
                    GetDlgItem(hdlg,IDOK),
                    SendDlgItemMessage(hdlg,IDC_SOURCE,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE
                    );
            }
            break;

        case IDC_SOURCE2:

            if(HIWORD(wParam) == EN_CHANGE) {

                EnableWindow(
                    GetDlgItem(hdlg,IDOK),
                    SendDlgItemMessage(hdlg,IDC_SOURCE2,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE
                    );
            }
            break;

        case IDB_BROWSE:

            if(HIWORD(wParam) == BN_CLICKED) {
                TCHAR InitialPath[MAX_PATH];
                TCHAR NewPath[MAX_PATH];

                GetDlgItemText(hdlg,IDC_SOURCE2,InitialPath,MAX_PATH);
                if(BrowseForDosnetInf(hdlg,InitialPath,NewPath)) {
                    SetDlgItemText(hdlg,IDC_SOURCE2,NewPath);
                }
                b = TRUE;
            }
            break;

#if defined(_AMD64_) || defined(_X86_)
        case IDC_USEFLOPPIES:

            b = FALSE;
            if(HIWORD(wParam) == BN_CLICKED) {

                MEDIA_TYPE MediaType;

//              switch(MediaType = GetMediaType(TEXT('A'), NULL)) {
                switch(MediaType = GetMediaType(FirstFloppyDriveLetter, NULL)) {

                case Unknown:
                case F5_1Pt2_512:
                case F3_720_512:
                case F5_360_512:
                case F5_320_512:
                case F5_320_1024:
                case F5_180_512:
                case F5_160_512:
                case RemovableMedia:
                case FixedMedia:
                    //
                    // None of these are acceptable.
                    //
                    MessageBoxFromMessage(
                        hdlg,
                        MSG_EVIL_FLOPPY_DRIVE,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR
                        );

                    CheckDlgButton(hdlg,IDC_USEFLOPPIES,BST_UNCHECKED);
                    EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                    Floppyless = TRUE;
                    ForceFloppyless = TRUE;
                    b = TRUE;
                    break;

                case F3_1Pt44_512:
                case F3_2Pt88_512:
                case F3_20Pt8_512:
                case F3_120M_512:
                default:
                    //
                    // Allow these -- nothing to do here.
                    // Note that this includes types we don't know about,
                    // since new types could appear after we ship and we assume
                    // they'll be big enough.
                    //
                    break;
                }
                // } -to match commented out switch above.
            }
            break;
#endif
        }

        break;

    case WM_HELP:

        MyWinHelp(((HELPINFO *)lParam)->hItemHandle,HELP_WM_HELP,(ULONG_PTR)OptionsDlgContextHelp);
        b = TRUE;
        break;

    case WM_CONTEXTMENU:

        MyWinHelp((HWND)wParam,HELP_CONTEXTMENU,(ULONG_PTR)OptionsDlgContextHelp);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoOptions(
    IN HWND Parent
    )
{
    INT_PTR i;

    if (Upgrade && !ISNT()) {
        i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ADVANCED3),Parent,OptionsDlgProc);
    }
    else {
        i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ADVANCED),Parent,OptionsDlgProc);
    }

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}

VOID
SaveLanguageDirs(
    )
{
    DWORD   ItemNo;
    HMODULE hKernel32 = NULL;
    LGRPID  LangGroupId;
    PTSTR   p;

    p = NULL;
    Kernel32IsValidLanguageGroup = NULL;

    //
    // Get IsValidLanguageGroup if we can
    //
    if (Upgrade && ISNT() && (BuildNumber >= NT50B3)) {

        hKernel32 = LoadLibrary(TEXT("KERNEL32"));
        if (hKernel32) {
            (FARPROC)Kernel32IsValidLanguageGroup =
                GetProcAddress( hKernel32, "IsValidLanguageGroup" );
        }
    }

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {

        //
        // When upgrading from NT 5, select any languages which are already
        // installed, to make sure they get upgraded.
        //
        LangGroupId = _tcstoul( LanguageGroups[ItemNo].Id, NULL, 10 );
        if (Kernel32IsValidLanguageGroup && LangGroupId &&
            Kernel32IsValidLanguageGroup( LangGroupId, LGRPID_INSTALLED )
            ) {

            LanguageGroups[ItemNo].Selected = TRUE;
        }

        //
        // Install any languages required by the primary locale.
        //
        if (!lstrcmp( LanguageGroups[ItemNo].Id, LocaleList[PrimaryLocale].LanguageGroup1 ) ||
            !lstrcmp( LanguageGroups[ItemNo].Id, LocaleList[PrimaryLocale].LanguageGroup2 )
            ) {

            LanguageGroups[ItemNo].Selected = TRUE;
        }


        //
        // Make sure the necessary optional directories get copied for all
        // selected language groups.
        //
        if( LanguageGroups[ItemNo].Selected ) {

            TCHAR TempString[MAX_PATH];

            if( LanguageGroups[ItemNo].Directory &&
                LanguageGroups[ItemNo].Directory[0]
                ) {
                RememberOptionalDir(
                    LanguageGroups[ItemNo].Directory,
                    OPTDIR_TEMPONLY | OPTDIR_ADDSRCARCH
                    );
#if defined(_WIN64)

        //Add the i386\lang folder if needed

                StringCchCopy( TempString, ARRAYSIZE(TempString), TEXT("\\I386\\"));
                StringCchCat(  TempString, ARRAYSIZE(TempString), LanguageGroups[ItemNo].Directory );
                
                
                RememberOptionalDir(
                    TempString,
                    OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP
                    );


#endif


            }
        }
    }

#ifdef _X86_


    //
    // If this is a win9xupg, we need to get any optional directories they need for installed languages.
    //
    if (Upgrade && !ISNT()) {

        p = UpgradeSupport.OptionalDirsRoutine ();

        while (p && *p) {

            RememberOptionalDir (p, OPTDIR_TEMPONLY | OPTDIR_ADDSRCARCH);
            p = _tcschr (p, 0) + 1;
        }
    }

#endif
}


BOOL
SaveLanguageParams(
    IN LPCTSTR FileName
    )
{
    BOOL    b;
    DWORD   ItemNo;
    LPCTSTR WinntLangSection = WINNT_REGIONALSETTINGS;
    PTSTR   LanguageString = NULL;
    UINT    LanguageLength = 0;
    LPTSTR  p;


    if( !IntlInfProcessed ) {
        return TRUE;
    }


    //
    // If this is a win9x upgrade, let the upgrade .dll take care
    // of writing these parameters.
    //
    if (Upgrade && !ISNT()) {
        return TRUE;
    }

    b = WritePrivateProfileString(
        WinntLangSection,
        WINNT_D_LANGUAGE,
        LocaleList[PrimaryLocale].Lcid,
        FileName
        );

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {

        if( LanguageGroups[ItemNo].Selected ) {

            if(LanguageString) {
                p = REALLOC(
                    LanguageString,
                    (lstrlen( LanguageGroups[ItemNo].Id) + 2 + LanguageLength ) * sizeof(TCHAR)
                    );
            } else {
                p = MALLOC((lstrlen(LanguageGroups[ItemNo].Id)+2)*sizeof(TCHAR));
            }

            if(!p) {
                if( LanguageString ) {
                    FREE( LanguageString );
                }
                return FALSE;
            }

            LanguageString = p;

            if( LanguageLength ) {
                lstrcat( LanguageString, LanguageGroups[ItemNo].Id );
            } else {
                lstrcpy( LanguageString, LanguageGroups[ItemNo].Id );
            }

            lstrcat( LanguageString, TEXT(",") );
            LanguageLength = lstrlen( LanguageString );
        }
    }

    if( LanguageString ) {
        //
        // Remove trailing "," if any
        //
        if( LanguageLength && (LanguageString[LanguageLength-1] == TEXT(','))) {
            LanguageString[LanguageLength-1] = 0;
        }

        b = b && WritePrivateProfileString(
            WinntLangSection,
            WINNT_D_LANGUAGE_GROUP,
            LanguageString,
            FileName
            );

        FREE( LanguageString );
    }

    return b;
}


VOID
FreeLanguageData(
    )
{
    DWORD   ItemNo;


    //
    // Free all the data allocated for the language options data
    //
    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        FREE( LocaleList[ItemNo].Lcid );
        FREE( LocaleList[ItemNo].Description );
        FREE( LocaleList[ItemNo].LanguageGroup1 );
        FREE( LocaleList[ItemNo].LanguageGroup2 );
    }
    LocaleCount = 0;
    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
        FREE( LanguageGroups[ItemNo].Id );
        FREE( LanguageGroups[ItemNo].Description );
        FREE( LanguageGroups[ItemNo].Directory );
    }
    LanguageGroupsCount = 0;
    if( LocaleList ) {
        FREE( LocaleList );
    }
    if( LanguageGroups ) {
        FREE( LanguageGroups );
    }
    IntlInfProcessed = FALSE;
}


int
__cdecl
LocaleCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((PLOCALE_ENTRY)arg1)->Description,
       ((PLOCALE_ENTRY)arg2)->Description
       );
}


int
__cdecl
LangGroupCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((PLANGUAGE_GROUP_ENTRY)arg1)->Description,
       ((PLANGUAGE_GROUP_ENTRY)arg2)->Description
       );
}


BOOL
ReadIntlInf(
    IN HWND   hdlg
    )
{
    HINF    IntlInf;
    TCHAR   IntlInfName[MAX_PATH];
    DWORD   LineCount;
    DWORD   ItemNo, NeededSize = 0;
    LPCTSTR SectionName;
    INFCONTEXT InfContext;
    LPCTSTR Language;
    TCHAR   CurrentLcid[9] = TEXT("\0");
    TCHAR   CurrentLcidEx[9] = TEXT("\0");  // for AUTO_LANGPACK

    //
    // For AUTO_LANGPACK - BEGIN
    //
    // The pieces that are enclosed with AUTO_LANGPACK are for easy
    // installation of other LangPack rather than English.
    //
    // This is originally for globalization testing. You can erase it by
    // deleting lines surrounded or marked by the keyword AUTO_LANGPACK.
    //
    // Contact: YuhongLi
    //

    //
    // read "Locale" from an extra file INTLEX.INF to install
    // the locale rather than English (United States) by default.
    //
    // Here is a sample of INTLEX.INF which specifies Japanese
    // as the default. The file INTLEX.INF should be in Unicode.
    //
    // --- cut here ---
    //  [Version]
    //  Signature = $Chicago$
    //
    //  [DefaultValues]
    //  Locale = "00000411"
    // --- end of cut ---
    //
    // For German (Germany), Locale will be 00000407.
    //
    
    FindPathToInstallationFile( TEXT("intlex.inf"), IntlInfName, MAX_PATH);
    IntlInf = SetupapiOpenInfFile( IntlInfName, NULL, INF_STYLE_WIN4, NULL );
    if( IntlInf != INVALID_HANDLE_VALUE ) {
        if( SetupapiFindFirstLine( IntlInf, TEXT("DefaultValues"), TEXT("Locale"), &InfContext ) ) {
            SetupapiGetStringField( &InfContext, 1, CurrentLcidEx, (sizeof(CurrentLcidEx)/sizeof(TCHAR)), NULL );
        }
        SetupapiCloseInfFile( IntlInf );
    }
    //
    // For AUTO_LANGPACK -- END
    //

    //
    // Open the INF
    //
    
    FindPathToInstallationFile( TEXT("intl.inf"), IntlInfName, MAX_PATH);
    IntlInf = SetupapiOpenInfFile( IntlInfName, NULL, INF_STYLE_WIN4, NULL );
    if(IntlInf == INVALID_HANDLE_VALUE && hdlg) {
        MessageBoxFromMessageAndSystemError(
            hdlg,
            MSG_INTLINF_NOT_FOUND,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        return FALSE;
    }

    //
    // Figure out what the default locale should be.
    //
    if( Upgrade ) {
        wsprintf( CurrentLcid, TEXT("%08x"), GetSystemDefaultLCID());
    } else if ( CurrentLcidEx[0] ) {            // for AUTO_LANGPACK
        lstrcpy( CurrentLcid, CurrentLcidEx);   // for AUTO_LANGPACK
    } else if( SetupapiFindFirstLine( IntlInf, TEXT("DefaultValues"), TEXT("Locale"), &InfContext )) {
        SetupapiGetStringField( &InfContext, 1, CurrentLcid, (sizeof(CurrentLcid)/sizeof(TCHAR)), NULL );
    } else {
        if (hdlg) {
            MessageBoxFromMessage(
                hdlg,
                MSG_INTLINF_NOT_FOUND,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
        }
        return FALSE;
    }

    //
    // Read the [Locales] section, sort it, and find the default value in the list.
    //
    SectionName = TEXT("Locales");
    LocaleCount = SetupapiGetLineCount( IntlInf, SectionName );
    LocaleList = MALLOC( LocaleCount*sizeof( LOCALE_ENTRY ) );
    if(!LocaleList){
        SetupapiCloseInfFile( IntlInf );
        return FALSE;
    }
    memset(LocaleList, 0, LocaleCount*sizeof( LOCALE_ENTRY ) );

    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        if( SetupapiGetLineByIndex( IntlInf, SectionName, ItemNo, &InfContext )) {


            if( SetupapiGetStringField( &InfContext, 0, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].Lcid = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 0, LocaleList[ItemNo].Lcid, NeededSize, NULL );
                }
            }

            if( SetupapiGetStringField( &InfContext, 1, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].Description = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 1, LocaleList[ItemNo].Description, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 3, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].LanguageGroup1 = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 3, LocaleList[ItemNo].LanguageGroup1, NeededSize, NULL );
                }
            }

            if( SetupapiGetStringField( &InfContext, 4, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].LanguageGroup2 = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 4, LocaleList[ItemNo].LanguageGroup2, NeededSize, NULL );
                }
            }
            
        }
        else {
	    SetupapiCloseInfFile( IntlInf );
            free( LocaleList );
	    return FALSE;
	}
    }

    qsort(
        LocaleList,
        LocaleCount,
        sizeof(LOCALE_ENTRY),
        LocaleCompare
        );

    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        if( LocaleList[ItemNo].Lcid && !lstrcmpi( CurrentLcid, LocaleList[ItemNo].Lcid)) {
            PrimaryLocale = ItemNo;
            break;
        }
    }

    //
    // Read the [LanguageGroups] section and sort it
    //
    SectionName = TEXT("LanguageGroups");
    LanguageGroupsCount = SetupapiGetLineCount( IntlInf, SectionName );
    LanguageGroups = MALLOC( LanguageGroupsCount*sizeof( LANGUAGE_GROUP_ENTRY ) );
    if(!LanguageGroups){
        SetupapiCloseInfFile( IntlInf );
        return FALSE;
    }
    memset(LanguageGroups, 0, LanguageGroupsCount*sizeof( LANGUAGE_GROUP_ENTRY ) );

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
        if( SetupapiGetLineByIndex( IntlInf, SectionName, ItemNo, &InfContext )) {

            if( SetupapiGetStringField( &InfContext, 0, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Id = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 0, LanguageGroups[ItemNo].Id, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 1, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Description = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 1, LanguageGroups[ItemNo].Description, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 2, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Directory = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 2, LanguageGroups[ItemNo].Directory, NeededSize, NULL );
                }

            }

            LanguageGroups[ItemNo].Selected = FALSE;
            //
            // Handle Hong Kong upgrades as a special case: always install Language
            // Groups 9 and 10.
            //

            if( (TargetNativeLangID == 0xc04) && Upgrade &&
                (!lstrcmpi( LanguageGroups[ItemNo].Id, TEXT("9")) ||
                 !lstrcmpi( LanguageGroups[ItemNo].Id, TEXT("10"))) ) {

                LanguageGroups[ItemNo].Selected = TRUE;
            }
        }
        else {
	    SetupapiCloseInfFile( IntlInf );
            free( LocaleList );
            free( LanguageGroups );
            return FALSE;
        }
    }

    qsort(
        LanguageGroups,
        LanguageGroupsCount,
        sizeof(LANGUAGE_GROUP_ENTRY),
        LangGroupCompare
        );

    // If the primary language is a Far East one, don't show the check box.
    if (IsFarEastLanguage(PrimaryLocale))
    {
        ShowWindow(GetDlgItem(hdlg, IDC_FAREAST_LANG), SW_HIDE);
    }
    //
    // Clean up
    //
    SetupapiCloseInfFile( IntlInf );
    IntlInfProcessed = TRUE;
    return TRUE;
}

BOOL InitLangControl(HWND hdlg, BOOL bFarEast)
{
    DWORD   ItemNo;
    //
    // Init primary language combo box
    //
    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        SendDlgItemMessage( hdlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)LocaleList[ItemNo].Description );
    }
    SendDlgItemMessage( hdlg, IDC_COMBO1, CB_SETCURSEL, PrimaryLocale, 0 );

    // if the running language or the to be installed language is a FarEast 
    // language, this check box is not visible, because we install the language folder anyway.
    if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
    {
        if (bFarEast || IsFarEastLanguage(PrimaryLocale))
        {
            CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_CHECKED);
        }
        else
        {
            CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_UNCHECKED);
        }
    }
    return TRUE;
}


INT_PTR
LanguageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    DWORD   ItemNo;


    switch(msg) {

    case WM_INITDIALOG:

        if( !IntlInfProcessed ) {
            EndDialog( hdlg, FALSE );
        }

        //
        // Init locales
        //
        for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
            SendDlgItemMessage( hdlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)LocaleList[ItemNo].Description );
        }
        SendDlgItemMessage( hdlg, IDC_COMBO1, CB_SETCURSEL, PrimaryLocale, 0 );

        //
        // Init language groups
        //
        for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
            SendDlgItemMessage( hdlg, IDC_LIST, LB_ADDSTRING, 0, (LPARAM)LanguageGroups[ItemNo].Description );
            SendDlgItemMessage( hdlg, IDC_LIST, LB_SETSEL, LanguageGroups[ItemNo].Selected, ItemNo );
        }
        for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
            LanguageGroups[ItemNo].Selected = (int)SendDlgItemMessage( hdlg, IDC_LIST, LB_GETSEL, ItemNo, 0 );
        }

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
                PrimaryLocale = (DWORD)SendDlgItemMessage( hdlg, IDC_COMBO1, CB_GETCURSEL, 0, 0 );
                for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
                    LanguageGroups[ItemNo].Selected = (int)SendDlgItemMessage( hdlg, IDC_LIST, LB_GETSEL, ItemNo, 0 );
                }

                EndDialog(hdlg,TRUE);
                b = TRUE;
            }
            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;
        }

        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoLanguage(
    IN HWND Parent
    )
{
    INT_PTR i;

    i = DialogBox(hInst,MAKEINTRESOURCE(IDD_LANGUAGE),Parent,LanguageDlgProc);

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}


INT_PTR
AccessibilityDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    TCHAR VisibleNarrator[2];


    switch(msg) {

    case WM_INITDIALOG:
        //
        // Disable the narrator in locales that don't support it.
        //

        if (!LoadString(hInst,IDS_VISIBLE_NARRATOR_CONTROL,VisibleNarrator,sizeof(VisibleNarrator)/sizeof(TCHAR)) ||
            lstrcmp(VisibleNarrator,TEXT("1"))) {

            EnableWindow(GetDlgItem( hdlg, IDC_READER ), FALSE);
            ShowWindow(GetDlgItem( hdlg, IDC_READER ), SW_HIDE);
            EnableWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), FALSE);
            ShowWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), SW_HIDE);
        }

        //
        // check the target LCID and disable it for non-English locales
        //
        if (SourceNativeLangID) {
            if (!(SourceNativeLangID == 0x0409 || SourceNativeLangID == 0x0809)) {
                EnableWindow(GetDlgItem( hdlg, IDC_READER ), FALSE);
                ShowWindow(GetDlgItem( hdlg, IDC_READER ), SW_HIDE);
                EnableWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), FALSE);
                ShowWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), SW_HIDE);
            }
        }
        //
        // Set the initial state of the check boxes.
        //
        CheckDlgButton(hdlg,IDC_MAGNIFIER,AccessibleMagnifier ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_KEYBOARD,AccessibleKeyboard ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_VOICE,AccessibleVoice ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_READER,AccessibleReader ?
            BST_CHECKED : BST_UNCHECKED);

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
                BOOL bSelectedAccessibleMagnifier;
                BOOL bSelectedAccessibleKeyboard;
                BOOL bSelectedAccessibleVoice;
                BOOL bSelectedAccessibleReader;

                b = TRUE;
                bSelectedAccessibleMagnifier = (IsDlgButtonChecked(hdlg,IDC_MAGNIFIER) == BST_CHECKED);
                bSelectedAccessibleKeyboard = (IsDlgButtonChecked(hdlg,IDC_KEYBOARD) == BST_CHECKED);
                bSelectedAccessibleVoice = (IsDlgButtonChecked(hdlg,IDC_VOICE) == BST_CHECKED);
                bSelectedAccessibleReader = (IsDlgButtonChecked(hdlg,IDC_READER) == BST_CHECKED);
                //
                // if user selected any of the accessibility options, warn about choosing the partition installation
                //
                if(ChoosePartition && 
                    (bSelectedAccessibleMagnifier || bSelectedAccessibleKeyboard || bSelectedAccessibleVoice || bSelectedAccessibleReader) && 
                    IDYES != MessageBoxFromMessage(hdlg, MSG_WARNING_ACCESSIBILITY, FALSE, AppTitleStringId, MB_YESNO | MB_ICONEXCLAMATION)) {
                    break;
                }

                AccessibleMagnifier = bSelectedAccessibleMagnifier;
                AccessibleKeyboard = bSelectedAccessibleKeyboard;
                AccessibleVoice = bSelectedAccessibleVoice;
                AccessibleReader = bSelectedAccessibleReader;
                EndDialog(hdlg,TRUE);
            }

            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;
        }

        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoAccessibility(
    IN HWND Parent
    )
{
    INT_PTR i;

    i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ACCESSIBILITY),Parent,AccessibilityDlgProc);

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}


VOID
InitVariousOptions(
    VOID
    )

/*++

Routine Description:

    Initialize options for program operation, including

    - determining whether we were run from a CD

    - whether we should create a local source

    If we are being run from CD then there's no need to create
    a local source since we assume we can get to the CD from NT.

Arguments:

    None.

Return Value:

    None.

    Global variables RunFromCD, MakeLocalSource filled in.

--*/

{
    TCHAR Path[MAX_PATH];


    //
    // Assume not run from CD. In that case we need to create
    // a local source.  This is a global, and should be FALSE
    // unless the user has sent us a /#R to force the RunFromCD.
    //
//    RunFromCD = FALSE;

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot client, MakeLocalSource is always false.
    //
    if (RemoteBoot) {

        MakeLocalSource = FALSE;
        MakeBootMedia = FALSE;
        Floppyless = TRUE;

    } else
#endif // defined(REMOTE_BOOT)
    {
        //
        // Determine if we were run from CD.
        //
        if(MyGetModuleFileName(NULL,Path,MAX_PATH)) {
            //
            // For UNC paths this will do something bogus, but certainly
            // won't return DRIVE_CDROM, so we don't care.
            //
            Path[3] = 0;
            if(GetDriveType(Path) == DRIVE_CDROM) {
                RunFromCD = TRUE;
            }
        }

        //
        // Now determine if we should MakeLocalSource.
        //
        if (!IsArc()) {
#if defined(_AMD64_)
            //
            // on AMD64, always make local source.
            //
            MakeLocalSource = TRUE;
#endif // defined(_AMD64_)

#if defined(_X86_)
            //
            // MakeLocalSource is a global, so he
            // will be FALSE by default, unless the
            // user has sent winnt32.exe the /MakeLocalSource flag,
            // in which case, the flag will already be set to true.
            //
            MakeLocalSource = (MakeLocalSource || (!RunFromCD));
#endif // defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // on ARC, always make local source.
            //
            MakeLocalSource = TRUE;
#endif // UNICODE
        } // if (!IsArc())

    }
}


BOOL
BrowseForDosnetInf(
    IN  HWND    hdlg,
    IN  LPCTSTR InitialPath,
    OUT TCHAR   NewPath[MAX_PATH]
    )

/*++

Routine Description:

    This routine invokes the standard win32 find file dialog for
    dosnet.inf or whatever inf is currently selected to substitute for
    dosnet.inf.

Arguments:

    hdlg - supplies window handle of dialog to use as parent for
        find file common dialog.

Return Value:

    Boolean value indicating whether the user browsed and successfully
    located dosnet.inf (or substitute).

--*/

{
    BOOL b;
    OPENFILENAME Info;
    TCHAR Filter[2*MAX_PATH];
    TCHAR File[MAX_PATH];
    TCHAR Path[MAX_PATH];
    DWORD d;
    TCHAR Title[150];
    PVOID p;
    TCHAR* lastWack;

    ZeroMemory(Filter,sizeof(Filter));

    p = InfName;

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_DOSNET_INF_DESC,
            0,
            Filter,
            MAX_PATH,
            (va_list *)&p
            );

    //
    // This is ok, since Filter is 2*MAX_PATH tchars long.
    //
    lstrcpy(Filter+d+1,InfName);

    //
    // This is ok, since both buffers are of size MAX_PATH
    //
    lstrcpy(File,InfName);

    StringCchCopy(Path, ARRAYSIZE(Path), InitialPath);

    LoadString(hInst,IDS_FIND_NT_FILES,Title,sizeof(Title)/sizeof(TCHAR));

    Info.lStructSize = sizeof(OPENFILENAME);
    Info.hwndOwner = hdlg;
    Info.hInstance = NULL;              // unused because not using a template
    Info.lpstrFilter = Filter;
    Info.lpstrCustomFilter = NULL;
    Info.nMaxCustFilter = 0;            // unused because lpstrCustomFilter is NULL
    Info.nFilterIndex = 1;
    Info.lpstrFile = File;
    Info.nMaxFile = MAX_PATH;
    Info.lpstrFileTitle = NULL;
    Info.nMaxFileTitle = 0;             // unused because lpstrFileTitle is NULL
    Info.lpstrInitialDir = Path;
    Info.lpstrTitle = Title;
    Info.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NODEREFERENCELINKS | OFN_PATHMUSTEXIST;
    Info.nFileOffset = 0;
    Info.nFileExtension = 0;
    Info.lpstrDefExt = NULL;
    Info.lCustData = 0;                 // unused because no hook is used
    Info.lpfnHook = NULL;               // unused because no hook is used
    Info.lpTemplateName = NULL;         // unused because no template is used

    b = GetOpenFileName(&Info);

    if(b) {
        lstrcpy(NewPath,File);

        lastWack = _tcsrchr(NewPath,TEXT('\\'));

        if (lastWack) {
            *lastWack = 0;
        }
    }

    return(b);
}

BOOL
IsValid8Dot3(
    IN LPCTSTR Path
    )

/*++

Routine Description:

    Check whether a path is valid 8.3.  The path may or may not start with
    a backslash.  Only backslashes are recognized as path separators.
    Individual characters are not checked for validity (ie, * would not
    invalidate the path).  The path may or may not terminate with a backslash.
    A component may have a dot without characters in the extension
    (ie, a\b.\c is valid).

    \ and "" are explicitly disallowed even though they fit the rules.

    Stolen from textmode\kernel sptarget.c

Arguments:

    Path - pointer to path to check.

Return Value:

    TRUE if valid 8.3, FALSE otherwise.

--*/

{
    UINT Count;
    BOOLEAN DotSeen,FirstChar;
    static LPCTSTR UsableChars = TEXT("_-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");

    if((*Path == 0) || ((Path[0] == TEXT('\\')) && (Path[1] == 0))) {
        return(FALSE);
    }

    DotSeen = FALSE;
    FirstChar = TRUE;
    Count = 0;

    while(*Path) {

        //
        // Path points to start of current component (1 past the slash)
        //

        switch(*Path) {

        case TEXT('.'):
            if(FirstChar) {
                return(FALSE);
            }
            if(DotSeen) {
                return(FALSE);
            }

            Count = 0;
            DotSeen = TRUE;
            break;

        case TEXT('\\'):

            DotSeen = FALSE;
            FirstChar = TRUE;
            Count = 0;

            if(*(++Path) == TEXT('\\')) {

                // 2 slashes in a row
                return(FALSE);
            }

            continue;

        default:

            Count++;
            FirstChar = FALSE;

            if((Count == 4) && DotSeen) {
                return(FALSE);
            }

            if(Count == 9) {
                return(FALSE);
            }

            //
            // Make sure it's a printable, US character.
            //
            if( !_tcschr( UsableChars, *Path ) ) {
                return( FALSE );
            }

        }

        Path++;
    }

    return(TRUE);
}


BOOL
SaveLanguageOptions (
    IN      PCTSTR AnswerFile
    )
{
    UINT u;
    UINT rem;
    PTSTR list;
    TCHAR buf[32];
    LPTSTR  p;
    DWORD len;
    DWORD size;

    if (IntlInfProcessed) {

        if (!WritePrivateProfileString (
                WINNT_REGIONALSETTINGS,
                TEXT("LangInf"),
                WINNT_A_YES,
                AnswerFile
                )) {
            return FALSE;
        }

        wsprintf (buf, TEXT("%u"), PrimaryLocale);
        if (!WritePrivateProfileString(
                WINNT_REGIONALSETTINGS,
                TEXT("PrimaryLocaleIndex"),
                buf,
                AnswerFile
                )) {
            return FALSE;
        }

        size = rem = 32;
        list = MALLOC (size);
        if (!list) {
            return FALSE;
        }
        *list = 0;
        for (u = 0; u < LanguageGroupsCount; u++) {
            if (LanguageGroups[u].Selected) {
                len = wsprintf (buf, TEXT("%u"), u);
                while (len + 1 > rem) {
                    PTSTR listReallocated = NULL;
                    
                    size *= 2;
                    
                    listReallocated = REALLOC (list, size);
                    if (!listReallocated) {
                        FREE(list);
                        return FALSE;
                    }
                    
                    list = listReallocated;
                    rem = size;
                }
                if (*list) {
                    lstrcat (list, TEXT(","));
                    rem--;
                }
                lstrcat (list, buf);
                rem -= len;
            }
        }

        if (*list) {
            if (!WritePrivateProfileString(
                    WINNT_REGIONALSETTINGS,
                    TEXT("Selected"),
                    list,
                    AnswerFile
                    )) {
                FREE( list );
                return FALSE;
            }
        }
        FREE( list );
    }

    return TRUE;
}

BOOL
LoadLanguageOptions (
    IN      PCTSTR AnswerFile
    )
{
    PTSTR optDirs;
    TCHAR buf[MAX_PATH];
    PTSTR list = NULL;
    PTSTR p, q;
    DWORD size;
    DWORD u;

    if (!IntlInfProcessed) {
        return FALSE;
    }

    GetPrivateProfileString (
            WINNT_REGIONALSETTINGS,
            TEXT("LangInf"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    IntlInfProcessed = !lstrcmpi (buf, WINNT_A_YES);

    if (!IntlInfProcessed) {
        return FALSE;
    }

    if (!GetPrivateProfileString(
            WINNT_REGIONALSETTINGS,
            TEXT("PrimaryLocaleIndex"),
            TEXT(""),
            buf,
            MAX_PATH,
            AnswerFile
            )) {
        return FALSE;
    }
    PrimaryLocale = (DWORD) _ttol (buf);

    size = 16;
    do {
        if (!list) {
            list = MALLOC (size);
        } else {
            PTSTR listReallocated;
            
            size *= 2;
            listReallocated = REALLOC (list, size);
            if(!listReallocated){
                FREE(list);
            }
            list = listReallocated;
        }
        if (!list) {
            return FALSE;
        }
        if (GetPrivateProfileString (
                WINNT_REGIONALSETTINGS,
                TEXT("Selected"),
                TEXT(""),
                list,
                size / sizeof ( TCHAR ),
                AnswerFile
                ) < size - 1) {
            break;
        }
    } while (TRUE);

    p = list;
    do {
        q = _tcschr (p, TEXT(','));
        if (q) {
            *q = 0;
        }
        u = _ttol (p);
        if (u >= LanguageGroupsCount) {
            FREE (list);
            return FALSE;
        }
        LanguageGroups[u].Selected = TRUE;
        if (q) {
            p = q + 1;
        }
    } while (q);

    FREE (list);
    return TRUE;
}


BOOL
SaveAdvancedOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[32];

    return
        (!MakeLocalSource ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("MakeLS"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!UserSpecifiedMakeLocalSource ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("UserMakeLS"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!Floppyless ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("Floppyless"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!SystemPartitionDriveLetter ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("SysPartDriveLetter"),
            _ltot (SystemPartitionDriveLetter, buf, 10),
            AnswerFile
            )) &&
        (!ChoosePartition ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("ChoosePartition"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!InstallDir[0] ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("InstallDir"),
            InstallDir,
            AnswerFile
            ));
}

BOOL
LoadAdvancedOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[MAX_PATH];

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("MakeLS"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    MakeLocalSource = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("UserMakeLS"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    UserSpecifiedMakeLocalSource = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("Floppyless"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    Floppyless = !lstrcmpi (buf, WINNT_A_YES);

    if (GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("SysPartDriveLetter"),
            TEXT(""),
            buf,
            MAX_PATH,
            AnswerFile
            )) {
        SystemPartitionDriveLetter = (TCHAR) _ttol (buf);
    }

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("ChoosePartition"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    ChoosePartition = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("InstallDir"),
            TEXT(""),
            InstallDir,
            sizeof (InstallDir) / sizeof (TCHAR),
            AnswerFile
            );

    return TRUE;
}

BOOL
SaveAccessibilityOptions (
    IN      PCTSTR AnswerFile
    )
{
    return
        (!AccessibleMagnifier ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleMagnifier"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleKeyboard ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleKeyboard"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleVoice ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleVoice"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleReader ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleReader"),
            WINNT_A_YES,
            AnswerFile
            ));
}

BOOL
LoadAccessibilityOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[MAX_PATH];

    if (!AccessibleMagnifier)
    {
        GetPrivateProfileString (
                TEXT("AccessibilityOptions"),
                TEXT("AccessibleMagnifier"),
                WINNT_A_NO,
                buf,
                MAX_PATH,
                AnswerFile
                );
        AccessibleMagnifier = !lstrcmpi (buf, WINNT_A_YES);
    }

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleKeyboard"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleKeyboard = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleVoice"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleVoice = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleReader"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleReader = !lstrcmpi (buf, WINNT_A_YES);

    return TRUE;
}

BOOL IsFarEastLanguage(DWORD LangIdx)
{
    BOOL FarEastLang = FALSE;
    DWORD LangGroup;

    LangGroup = (DWORD) _ttol (LocaleList[LangIdx].LanguageGroup1);
    if ((LangGroup >= 7) && (LangGroup <= 10))
    {
        FarEastLang = TRUE;
    }
    else
    {
        if (LocaleList[LangIdx].LanguageGroup2)
        {
            LangGroup = (DWORD) _ttol (LocaleList[LangIdx].LanguageGroup2);
            if ((LangGroup >= 7) && (LangGroup <= 10))
            {
                FarEastLang = TRUE;
            }
        }
    }

    return FarEastLang;
}

BOOL SelectFarEastLangGroup (BOOL bSelect)
{
    DWORD LangIdx;

    for (LangIdx = 0; LangIdx < LanguageGroupsCount; LangIdx++)
    {
        // NOTE: Only FarEast Language should have a directory
        // If this ever changes, this code need to change too.
        if (LanguageGroups[LangIdx].Directory && 
            LanguageGroups[LangIdx].Directory[0] )
        {
            LanguageGroups[LangIdx].Selected = bSelect;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2000.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for files >8MB

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0007

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\regmigrt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    regmigrt.c

Abstract:

    Registry migration routines

Author:

    Ted Miller (tedm) 12-Apr-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef enum {
    AddQuotesNone,
    AddQuotesNormal,
    AddQuotesOpenNoClose,
    AddQuotesNoOpenOrClose,
} AddQuotesOp;


BOOL
RetrieveMessageIntoBufferV(
    IN  UINT     MessageId,
    OUT PTSTR    Buffer,
    IN  UINT     BufferSizeChars,
    IN  va_list *arglist
    )
{
    DWORD d;

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
            hInst,
            MessageId,
            0,
            Buffer,
            BufferSizeChars,
            arglist
            );

    if(!d) {

        d = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst,
                MSG_NOT_FOUND,
                0,
                Buffer,
                BufferSizeChars,
                (va_list *)&MessageId
                );

        if(!d) {

            return FALSE;
        }
    }
    return TRUE;
}


DWORD
WriteText(
    IN HANDLE FileHandle,
    IN UINT   MessageId,
    ...
    )
{
    TCHAR Message[2048];
    CHAR message[4096];
    va_list arglist;
    DWORD Written;
    BOOL b;

    

    va_start(arglist,MessageId);

    b = RetrieveMessageIntoBufferV(
            MessageId,
            Message,
            sizeof(Message)/sizeof(Message[0]),
            &arglist
            );

    va_end(arglist);

    if(!b)
        return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
    Written = (DWORD)WideCharToMultiByte(
                        CP_ACP,
                        0,
                        Message,
                        lstrlen(Message),
                        message,
                        sizeof(message),
                        NULL,
                        NULL
                        );
#else
    StringCchCopyA(message,sizeof(message),Message);
    Written = lstrlen(message);
#endif
    b = WriteFile(FileHandle,message,Written,&Written,NULL);

    return(b ? NO_ERROR : GetLastError());
}





DWORD
FlushGenInfLineBuf(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File
    )
{
    CHAR TransBuf[INFLINEBUFLEN*2];
    DWORD rc;
    PVOID Buffer;
    DWORD Size;
    BOOL b;

    Buffer = TransBuf;

#ifdef UNICODE
    Size = WideCharToMultiByte(
                CP_ACP,
                0,
                Context->LineBuf,
                Context->LineBufUsed,
                TransBuf,
                sizeof(TransBuf),
                NULL,
                NULL
                );
#else
    StringCchCopyA(TransBuf,sizeof(TransBuf),Context->LineBuf);
    Size = Context->LineBufUsed;
#endif

    if(WriteFile(File,Buffer,Size,&rc,NULL)) {
        rc = NO_ERROR;
        Context->LineBufUsed = 0;
    } else {
        rc = GetLastError();
    }

    return(rc);
}


DWORD
__inline
GenInfWriteChar(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File,
    IN     TCHAR       Char
    )
{
    DWORD rc;
    PVOID Buffer;

    Context->LineBuf[Context->LineBufUsed++] = Char;

    rc = (Context->LineBufUsed == INFLINEBUFLEN)
       ? FlushGenInfLineBuf(Context,File)
       : NO_ERROR;

    return(rc);
}


DWORD
GenInfWriteString(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File,
    IN     LPCTSTR     String,
    IN     AddQuotesOp AddQuotes
    )
{
    DWORD rc;
    TCHAR CONST *p;

    if((AddQuotes == AddQuotesNormal) || (AddQuotes == AddQuotesOpenNoClose)) {
        rc = GenInfWriteChar(Context,File,TEXT('\"'));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    for(p=String; *p; p++) {
        rc = GenInfWriteChar(Context,File,*p);
        if(rc != NO_ERROR) {
            return(rc);
        }

        if((*p == TEXT('\"')) && (AddQuotes != AddQuotesNone)) {
            rc = GenInfWriteChar(Context,File,TEXT('\"'));
            if(rc != NO_ERROR) {
                return(rc);
            }
        }
    }

    if(AddQuotes == AddQuotesNormal) {
        rc = GenInfWriteChar(Context,File,TEXT('\"'));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    return(NO_ERROR);
}



DWORD
CreateAndOpenTempFile(
    IN  LPCTSTR  Path,
    IN  LPCTSTR  HeaderLine, OPTIONAL
    OUT HANDLE   *Handle,
    OUT PTSTR    Filename
    )
{
    HANDLE h;
    DWORD rc;

    //
    // Note that this creates the file.
    //
    if(!GetTempFileName(Path,TEXT("$IF"),0,Filename)) {
        rc = GetLastError();
        goto c0;
    }

    h = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        goto c1;
    }

    if(HeaderLine) {
        rc = WriteText(h,MSG_INF_SINGLELINE,HeaderLine);
        if(rc != NO_ERROR) {
            goto c2;
        }
    }

    *Handle = h;
    return(NO_ERROR);

c2:
    CloseHandle(h);
c1:
    DeleteFile(Filename);
c0:
    return(rc);
}


DWORD
InfCreateSection(
    IN     LPCTSTR      SectionName,
    IN OUT PINFFILEGEN  *Context
    )
{
    PTSTR Buffer;
    DWORD rc;

    Buffer = MALLOC( (lstrlen(SectionName) + 3)*sizeof(TCHAR) );
    if( !Buffer ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    lstrcpy( Buffer, TEXT("[") );
    lstrcat( Buffer, SectionName );
    lstrcat( Buffer, TEXT("]") );

    rc = WriteText((*Context)->FileHandle,MSG_INF_SINGLELINE,Buffer);
    FREE( Buffer );

    return(rc);
}

DWORD
InfStart(
    IN  LPCTSTR       InfName,
    IN  LPCTSTR       Directory,
    OUT PINFFILEGEN   *Context
    )
{
    TCHAR InfFileName[MAX_PATH];
    DWORD d;
    DWORD rc;
    PINFFILEGEN context;
    UCHAR UnicodeMark[2];
    PTSTR p;
    DWORD   BytesWritten = 0;

    //
    // Allocate some context.
    //
    context = MALLOC(sizeof(INFFILEGEN));

    if(!context) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    ZeroMemory(context,sizeof(INFFILEGEN));

    //
    // We'll create a unique inf name in the given directory
    // to use as the output inf. The directory itself will
    // become the oem file root.
    //
    if(!GetFullPathName(Directory,MAX_PATH,context->FileName,&p)) {
        rc = GetLastError();
        goto c1;
    }

    if (!ConcatenatePaths(context->FileName,InfName,MAX_PATH)) {
        rc = ERROR_BUFFER_OVERFLOW;
        goto c1;
    }

    SetFileAttributes(context->FileName, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(context->FileName);

    //
    // Create the output file.
    //
    context->FileHandle = CreateFile(
                            context->FileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if(context->FileHandle == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        goto c1;
    }

    //
    // Write out header for inf file.
    //    
    WriteFile(context->FileHandle, 
        INF_FILE_HEADER, 
        strlen(INF_FILE_HEADER), 
        &BytesWritten,
        NULL);

    rc = GetLastError();            
            
    if(rc != NO_ERROR) {
        goto c5;
    }

    *Context = context;
    return(NO_ERROR);

c5:
    CloseHandle(context->FileHandle);
    DeleteFile(context->FileName);
c1:
    FREE(context);
c0:
    return(rc);
}


DWORD
InfEnd(
    IN OUT PINFFILEGEN *Context
    )
{
    PINFFILEGEN context;
    DWORD rc;
    HANDLE h;
    DWORD Size;

    context = *Context;
    *Context = NULL;

    h = context->FileHandle;

    rc = NO_ERROR;

    CloseHandle(h);
    if(rc != NO_ERROR) {
        DeleteFile(context->FileName);
    }
    FREE(context);
    return(rc);
}



DWORD
pInfRegLineCommon(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      OutputFile,
    IN     HKEY        Key,
    IN     LPCTSTR      Subkey,
    IN     LPCTSTR      Value    OPTIONAL
    )
{
    LPCTSTR RootSpec;
    LPCTSTR SubkeySpec;
    DWORD rc;

    if(Subkey[0] == TEXT('\\')) {
        Subkey++;
    }

    //
    // Figure out the root key spec.
    //
    switch((ULONG_PTR)Key) {

    case (ULONG_PTR)HKEY_LOCAL_MACHINE:

        //
        // Check for HKEY_CLASSES_ROOT
        //
        if(_tcsnicmp(Subkey,TEXT("SOFTWARE\\Classes"),16)) {
            RootSpec = TEXT("HKLM");
            SubkeySpec = Subkey;
        } else {
            RootSpec = TEXT("HKCR");
            SubkeySpec = Subkey+16;
            if(*SubkeySpec == TEXT('\\')) {
                SubkeySpec++;
            }
        }
        break;

    case (ULONG_PTR)HKEY_CURRENT_USER:

        RootSpec = TEXT("HKCU");
        SubkeySpec = Subkey;
        break;

    case (ULONG_PTR)HKEY_CLASSES_ROOT:

        RootSpec = TEXT("HKCR");
        SubkeySpec = Subkey;
        break;

    default:
        //
        // Value we can't express via inf.
        // Use HKEY_ROOT but also write out a comment incidating
        // that there's a problem
        //
        RootSpec = TEXT("HKR");
        SubkeySpec = Subkey;

        Context->SawBogusOp = TRUE;
        rc = FlushGenInfLineBuf(Context,OutputFile);
        if(rc != NO_ERROR) {
            return(rc);
        }

        rc = WriteText(OutputFile,MSG_INF_BAD_REGSPEC_1);
        if(rc != NO_ERROR) {
            return(rc);
        }
        break;
    }

    rc = GenInfWriteString(Context,OutputFile,RootSpec,AddQuotesNone);
    if(rc == NO_ERROR) {
        rc = GenInfWriteChar(Context,OutputFile,TEXT(','));
        if(rc == NO_ERROR) {
            rc = GenInfWriteString(Context,OutputFile,SubkeySpec,AddQuotesNormal);
            if((rc == NO_ERROR) && Value) {
                rc = GenInfWriteChar(Context,OutputFile,TEXT(','));
                if(rc == NO_ERROR) {
                    rc = GenInfWriteString(Context,OutputFile,Value,AddQuotesNormal);
                }
            }
        }
    }

    return(rc);
}


DWORD
InfRecordAddReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR     Subkey,
    IN     LPCTSTR     Value,       OPTIONAL
    IN     DWORD       DataType,
    IN     PVOID       Data,
    IN     DWORD       DataLength,
    IN     BOOL        SetNoClobberFlag
    )
{
    DWORD rc;
    DWORD Flags;
    PTSTR p;
    DWORD d;
    int LineLen;
    TCHAR NumStr[24];

    //
    // Figure out flags based on data type.
    // The flags dword is built as two halves depending on whether
    // data is string or binary in nature.
    //
    // We do this before we write out the actual line
    // since that routine might also write a warning if a bogus root key
    // is specified.
    //
    switch(DataType) {

    case REG_SZ:
        Flags = FLG_ADDREG_TYPE_SZ;
        break;

    case REG_EXPAND_SZ:
        Flags = FLG_ADDREG_TYPE_EXPAND_SZ;
        break;

    case REG_MULTI_SZ:
        Flags = FLG_ADDREG_TYPE_MULTI_SZ;
        break;

    case REG_DWORD:
        Flags = FLG_ADDREG_TYPE_DWORD;
        break;

    //case REG_NONE:
    //    Flags = FLG_ADDREG_TYPE_NONE;
    //    break;

    case REG_NONE:
        Flags = FLG_ADDREG_KEYONLY;
        break;

    default:
        //
        // Arbitrary binary data. Better hope the data type doesn't overflow
        // 16 bits.
        //
        if(DataType > 0xffff) {
            Context->SawBogusOp = TRUE;
            rc = FlushGenInfLineBuf(Context,Context->FileHandle);
            if(rc != NO_ERROR) {
                return(rc);
            }
            rc = WriteText(Context->FileHandle,MSG_INF_BAD_REGSPEC_2);
            if(rc != NO_ERROR) {
                return(rc);
            }
            DataType = REG_BINARY;
        }
        Flags = FLG_ADDREG_BINVALUETYPE | (DataType << 16);
        break;
    }

    rc = pInfRegLineCommon(Context,Context->FileHandle,Key,Subkey,Value);
    if(rc != NO_ERROR) {
        return(rc);
    }
    if(Flags ==  FLG_ADDREG_KEYONLY) {
        rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    //
    // _stprintf(NumStr,TEXT(",%0#10lx"),Flags | 0x00000002); // Force NO_CLOBBER
    //
    // _stprintf(NumStr,TEXT(",%0#10lx"),Flags);
    wsprintf(NumStr,
             TEXT(",%#08lx"),
             SetNoClobberFlag? (Flags | 0x00000002) : Flags);

    rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Now we need to write out the data itself.
    // How we do this is dependent on the data type.
    //
    switch(DataType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        //
        // Single string. Ignore data length.
        //
        rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
        if(rc == NO_ERROR) {
            rc = GenInfWriteString(Context,Context->FileHandle,Data,AddQuotesNormal);
        }
        break;

    case REG_DWORD:
        //
        // Write out as a dword.
        //
        wsprintf(NumStr,TEXT(",%u"),*(DWORD UNALIGNED *)Data);
        rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
        break;

    case REG_MULTI_SZ:
        //
        // Write out each string.
        //
        for(p=Data; (rc==NO_ERROR) && *p; p+=lstrlen(p)+1) {
            rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
            if(rc == NO_ERROR) {
                rc = GenInfWriteString(Context,Context->FileHandle,p,AddQuotesNormal);
            }
        }

        break;

    case REG_NONE:
        //
        //  Don't create a value entry
        //
        break;

    default:
        //
        // Treat as binary. If we have any data at all start a new line.
        //
        if(DataLength) {
            rc = GenInfWriteString(Context,Context->FileHandle,TEXT(",\\\r\n     "),AddQuotesNone);
        }

        LineLen = 0;
        for(d=0; (rc==NO_ERROR) && (d<DataLength); d++) {

            if(LineLen == 25) {
                rc = GenInfWriteString(Context,Context->FileHandle,TEXT(",\\\r\n     "),AddQuotesNone);
                LineLen = 0;
            }

            if(rc == NO_ERROR) {
                if(LineLen) {
                    rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
                }
                if(rc == NO_ERROR) {
                    wsprintf(NumStr,TEXT("%02x"),((PBYTE)Data)[d]);
                    rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
                    LineLen++;
                }
            }
        }

        break;
    }

    if(rc == NO_ERROR) {
        rc = GenInfWriteString(Context,Context->FileHandle,TEXT("\r\n"),AddQuotesNone);
        if(rc == NO_ERROR) {
            rc = FlushGenInfLineBuf(Context,Context->FileHandle);
        }
    }

    return(rc);
}


#if 0
DWORD
InfRecordDelReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR      Subkey,
    IN     LPCTSTR      Value    OPTIONAL
    )
{
    DWORD rc;

    rc = pInfRegLineCommon(Context,Context->DelRegFile,Key,Subkey,Value);
    if(rc == NO_ERROR) {
        rc = GenInfWriteString(Context,Context->DelRegFile,TEXT("\r\n"),AddQuotesNone);
        if(rc == NO_ERROR) {
            rc = FlushGenInfLineBuf(Context,Context->DelRegFile);
        }
    }

    return(rc);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\protect.c ===
#include "precomp.h"
#include <tlhelp32.h>

#ifndef MYASSERT
#define MYASSERT(x)
#endif


typedef HANDLE (WINAPI * CREATETOOLHELP32SNAPSHOT)(DWORD Flags, DWORD ProcessId);
typedef BOOL (WINAPI * MODULE32FIRST)(HANDLE Snapshot, LPMODULEENTRY32 lpme);
typedef BOOL (WINAPI * MODULE32NEXT)(HANDLE Snapshot, LPMODULEENTRY32 lpme);


BOOL
pIsLegalPage (
    IN      DWORD Protect
    )
{
    //
    // Page must be actually in memory to protect it, and it
    // cannot be any type of write-copy.
    //

    if ((Protect & PAGE_GUARD) ||
        (Protect == PAGE_NOACCESS) ||
        (Protect == PAGE_WRITECOPY) ||
        (Protect == PAGE_EXECUTE_WRITECOPY)
        ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pIsKnownSection (
    IN      const IMAGE_SECTION_HEADER *Section,
    IN      const IMAGE_NT_HEADERS *NtHeaders
    )
{
    //
    // Return TRUE if section is code or code data
    //

    if (Section->Characteristics & (IMAGE_SCN_MEM_EXECUTE|
                                    IMAGE_SCN_MEM_DISCARDABLE|
                                    IMAGE_SCN_MEM_WRITE|
                                    IMAGE_SCN_MEM_READ)
        ) {
        return TRUE;
    }

    //
    // Return TRUE if section is resources
    //

    if (NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress ==
        Section->VirtualAddress
        ) {
        return TRUE;
    }

    //
    // Unknown section
    //

    return FALSE;
}


VOID
pPutRegionInSwapFile (
    IN      PVOID Address,
    IN      DWORD Size
    )
{
    MEMORY_BASIC_INFORMATION mbi;
    DWORD PageSize;
    PVOID EndPtr;
    PVOID RegionEnd;
    DWORD d;
    DWORD OldPermissions;
    volatile DWORD *v;
    SYSTEM_INFO si;

    //
    // Get system virtual page size
    //

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    //
    // Compute the pointer to the end of the region
    //

    EndPtr = (PBYTE) Address + Size;

    //
    // For each page in the region, mark it as e/r/w, modify it, and restore the permissions
    //

    while (Address < EndPtr) {

        d = (DWORD)VirtualQuery (Address, &mbi, sizeof(mbi));

        if (d == sizeof(mbi)) {

            //
            // We assume the module wasn't loaded with one of the following
            // conditions (which break as a result of VirtualProtect)
            //

            RegionEnd = (PBYTE) mbi.BaseAddress + mbi.RegionSize;

            if (RegionEnd > EndPtr) {
                RegionEnd = EndPtr;
            }

            if (mbi.State == MEM_COMMIT && pIsLegalPage (mbi.Protect)) {

                //
                // Switch to e/r/w
                //

                if (VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        PAGE_EXECUTE_READWRITE,
                        &OldPermissions
                        )) {

                    //
                    // Touch every page in the region.
                    //

                    for (Address = mbi.BaseAddress; Address < RegionEnd ; Address = (PBYTE) Address + PageSize) {
                        v = Address;
                        *v = *v;
                    }

                    //
                    // Switch back
                    //

                    VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        OldPermissions,
                        &d
                        );
                }
            }

            Address = RegionEnd;

        } else {
            MYASSERT (FALSE);
            break;
        }
    }
}


VOID
pProtectModule (
    HANDLE Module
    )
{
    TCHAR Path[MAX_PATH];
    BOOL IsNetDrive;
    const IMAGE_DOS_HEADER *DosHeader;
    const IMAGE_NT_HEADERS *NtHeaders;
    const IMAGE_SECTION_HEADER *SectHeader;
    UINT u;

    
    IsNetDrive = FALSE;

    //
    // Get module info
    //

    if( MyGetModuleFileName (Module, Path, MAX_PATH)){

        //
        // Determine if the module is running on the net
        //
    
        
        if (Path[0] == TEXT('\\')) {
            IsNetDrive = TRUE;
        } else if (GetDriveType (Path) == DRIVE_REMOTE) {
            IsNetDrive = TRUE;
        }

    }
    

    if (!IsNetDrive) {
        return;
    }

    //
    // Enumerate all sections in the PE header
    //

    DosHeader = (const IMAGE_DOS_HEADER *) Module;
    NtHeaders = (const IMAGE_NT_HEADERS *) ((PBYTE) Module + DosHeader->e_lfanew);

    for (u = 0 ; u < NtHeaders->FileHeader.NumberOfSections ; u++) {
        SectHeader = IMAGE_FIRST_SECTION (NtHeaders) + u;

        if (pIsKnownSection (SectHeader, NtHeaders)) {
            pPutRegionInSwapFile (
                (PBYTE) Module + SectHeader->VirtualAddress,
                SectHeader->Misc.VirtualSize
                );
        }
    }
}


VOID
ProtectAllModules (
    VOID
    )
{
    HANDLE Library;
    HANDLE Snapshot;
    MODULEENTRY32 me32;
    CREATETOOLHELP32SNAPSHOT fnCreateToolhelp32Snapshot;
    MODULE32FIRST fnModule32First;
    MODULE32NEXT fnModule32Next;

    //
    // Load toohelp dynamically (for NT 4, NT 3.51 compatibility)
    //

    Library = LoadLibrary (TEXT("toolhelp.dll"));
    if (!Library) {
        return;
    }

    (FARPROC) fnCreateToolhelp32Snapshot = GetProcAddress (Library, "CreateToolhelp32Snapshot");
    (FARPROC) fnModule32First = GetProcAddress (Library, "Module32First");
    (FARPROC) fnModule32Next = GetProcAddress (Library, "Module32Next");

    if (!fnCreateToolhelp32Snapshot || !fnModule32First || !fnModule32Next) {
        FreeLibrary (Library);
        return;
    }

    //
    // Protect each loaded module
    //

    Snapshot = fnCreateToolhelp32Snapshot (TH32CS_SNAPMODULE, 0);
    MYASSERT (Snapshot != INVALID_HANDLE_VALUE);

    if (Snapshot == INVALID_HANDLE_VALUE) {
        return;
    }

    me32.dwSize = sizeof (me32);
    if (fnModule32First (Snapshot, &me32)) {
        do {
            pProtectModule (me32.hModule);
        } while (fnModule32Next (Snapshot, &me32));
    }

    //
    // Done
    //

    CloseHandle (Snapshot);

    FreeLibrary (Library);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\params.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Params.c

Abstract:

    Routines to write parameters file for use by text mode setup.

Author:

    Ted Miller (tedm) 4 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define DEF_INF_BUFFER_SIZE (1<<15) //32KB
#define EMPTY_STRING TEXT("")

// Global used in WriteParamsFile and AddExternalParams
TCHAR ActualParamFile[MAX_PATH] = {'\0'};

//
// boot loader timeout value, in string form
//
TCHAR Timeout[32];

#ifdef PRERELEASE
//
// if we're in PRERELEASE mode, we will make a /debug entry
// in the OSLOADOPTIONSVARAPPEND entry.
//
BOOL AppendDebugDataToBoot = TRUE;
#endif

#if defined(UNICODE) && defined(_X86_)
extern TCHAR g_MigDllAnswerFilePath[MAX_PATH];
#endif

DWORD
PatchWinntSifFile(
    IN LPCTSTR Filename
    );

BOOL
AppendParamsFile(
    IN HWND    ParentWindow,
    IN LPCTSTR ParametersFileIn,
    IN LPCTSTR ParametersFileOut
    );

BOOL
WriteCompatibilityData(
    IN LPCTSTR FileName
    );

VOID
WriteGUIModeInfOperations(
    IN LPCTSTR FileName
    );

BOOL
AddGUIModeCompatibilityInfsToCopyList();

BOOL
WriteTextmodeClobberData (
    IN LPCTSTR FileName
    );

VOID
SaveProxyForOobe(
    IN LPCTSTR FileName
    );

#if defined(_X86_)

VOID
SaveDriveLetterInformation (
    IN LPCTSTR FileName
    );


#endif


PCTSTR
pGetPfPath (
    IN      HKEY hKey,
    IN      PCTSTR ValueName
    )
{
    DWORD Size;
    LONG rc;
    PBYTE Data;
    DWORD Type;
    UINT DriveType;
    TCHAR RootPath[] = TEXT("?:\\");
    PTSTR QuotedData;

    rc = RegQueryValueEx (
            hKey,
            ValueName,
            NULL,           // lpReserved
            &Type,
            NULL,
            &Size
            );

    if (rc != ERROR_SUCCESS) {
        return NULL;
    }

    if (Type != REG_SZ && Type != REG_EXPAND_SZ) {
        return NULL;
    }

    Data = MALLOC(Size + sizeof (TCHAR));
    if (!Data) {
        return NULL;
    }

    rc = RegQueryValueEx (
            hKey,
            ValueName,
            NULL,           // lpReserved
            NULL,           // type
            Data,
            &Size
            );

    if (rc != ERROR_SUCCESS) {
        FREE(Data);
        return NULL;
    }

    *((PTSTR) (Data + Size)) = 0;

    //
    // Verify data is to a local path
    //

    RootPath[0] = *((PCTSTR) Data);
    if (RootPath[0] == TEXT('\\')) {
        DriveType = DRIVE_NO_ROOT_DIR;
    } else {
        DriveType = GetDriveType (RootPath);
    }

    if (DriveType != DRIVE_FIXED) {
        FREE(Data);
        return NULL;
    }

    QuotedData = (PTSTR) MALLOC(Size + sizeof (TCHAR) * 3);
    if (!QuotedData) {
        FREE(Data);
        return NULL;
    }

    *QuotedData = TEXT('\"');
    lstrcpy (QuotedData + 1, (PCTSTR) Data);
    lstrcat (QuotedData, TEXT("\""));

    FREE(Data);

    return (PCTSTR) QuotedData;
}


BOOL
WriteHeadlessParameters(
    IN LPCTSTR FileName
    )


/*++

Routine Description:

    This routine writes the headless-specific parameters into the file
    that is used to pass information to text mode setup.

Arguments:

    FileName - specifies the full Win32 filename to use for the file.

Return Value:

    Boolean value indicating whether the file was written successfully.
    If not, the user will have been informed about why.

--*/

{
BOOL    ReturnVal = TRUE;

//
// ISSUE - why MAX_PATH*2 ?
//
TCHAR Text[MAX_PATH*2];

    //
    // Check the global and see if anyone has set any headless parameters.
    //
    if( HeadlessSelection[0] != TEXT('\0') ) {

        //
        // Write the settings into the unattend file so textmode will
        // fire up through up a headless port.
        //
        if( !WritePrivateProfileString(WINNT_DATA,WINNT_U_HEADLESS_REDIRECT,HeadlessSelection,FileName)) {
            ReturnVal = FALSE;
        }

        if( HeadlessBaudRate == 0 ) {
            wsprintf( Text, TEXT("%d"), 9600 );
        } else {
            wsprintf( Text, TEXT("%d"), HeadlessBaudRate );
        }

        if( !WritePrivateProfileString(WINNT_DATA,WINNT_U_HEADLESS_REDIRECTBAUDRATE,Text,FileName)) {
            ReturnVal = FALSE;
        }

    }





    return( ReturnVal );

}

BOOL WritePidToParametersFile(LPCTSTR Section, LPCTSTR Key, LPCTSTR FileName)
{
    BOOL b = FALSE;
    LPTSTR Line = NULL;
    LPTSTR pid;
    if (g_EncryptedPID)
    {
        pid = g_EncryptedPID;
    }
    else
    {
        pid = ProductId;
    }
    Line = GlobalAlloc(GPTR, (lstrlen(pid) + 3) * sizeof(TCHAR));
    if (Line)
    {
        *Line = TEXT('\"');
        lstrcpy(&Line[1], pid);
        lstrcat(Line,TEXT("\""));
        b = WritePrivateProfileString(Section,Key,Line,FileName);
        GlobalFree(Line);
    }
    return b;
}


BOOL
MigrateUnattendDataEntries(
    IN LPCTSTR  FileName,
    IN LPTSTR    UnattendedScriptFile
    )
/*++
Routine Description:

    This routine writes out the keys under [Data] section of an unattend file
    in to the winnt.sif file. This routine is specific to the following keys
    AutoPartition and
    UseBIOSToBoot
    
Arguments:

    FileName - specifies the full Win32 filename to use for the file.
    
    UnattendedScriptFile - Unattend Script File.

Return Value:

   TRUE/FALSE
--*/
{    
    BOOL ReturnVal = FALSE;
    //
    // If Unattend file exists then migrate the keys under [Data] section.
    //
    if (UnattendedScriptFile){        
        CONST ULONG BufSize = 256;
        PTSTR TmpString = (PTSTR)MALLOC(BufSize * sizeof (TCHAR));
        ReturnVal = TRUE;

        if( NULL != TmpString){   
            //
            // Array of keys to be checked 
            //
            LPCTSTR KeysToBeMigrated[] = { WINNT_D_AUTO_PART,
                                           WINNT_D_BIOSTOBOOT
                                           }; 
            LPCTSTR WinntDataSection = WINNT_DATA;
            ULONG i = 0;
            
            for(i=0; i < ARRAYSIZE(KeysToBeMigrated); i++){
                if(GetPrivateProfileString(WinntDataSection,
                                           KeysToBeMigrated[i],
                                           EMPTY_STRING,
                                           TmpString,
                                           BufSize,
                                           UnattendedScriptFile)){

                    if (!WritePrivateProfileString( WinntDataSection, 
                                                    KeysToBeMigrated[i], 
                                                    TmpString, 
                                                    FileName)) {
                            DWORD LastError = GetLastError();
                            DebugLog (  Winnt32LogError, 
                                        TEXT("MigrateUnattendDatEntries : Error writing to file %1, Section: %2, Key: %3"), 
                                        0, 
                                        FileName,
                                        WinntDataSection,
                                        KeysToBeMigrated[i]);
                            
                            ReturnVal = FALSE;
                            SetLastError(LastError);
                    }                                        
                }
                
            }
            FREE(TmpString);
            
        }else{
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ReturnVal = FALSE;
        }
                
    }
    SetLastError(ERROR_INVALID_PARAMETER);
    return ReturnVal;
   
}


BOOL
DoWriteParametersFile(
    IN HWND    ParentWindow,
    IN LPCTSTR FileName
    )

/*++

Routine Description:

    This routine generates a parameters file that is used to pass information
    to text mode setup.

Arguments:

    ParentWindow - supplies window handle of window to be used as the
        parent/owner in case this routine puts up UI.

    FileName - specifies the full Win32 filename to use for the file.

Return Value:

    Boolean value indicating whether the file was written successfully.
    If not, the user will have been informed about why.

--*/

{
    TCHAR FullPath[MAX_PATH], *t;
    TCHAR Text[MAX_PATH*2];
    LPTSTR OptionalDirString,OptDir;
    UINT OptionalDirLength;
    DWORD d=NO_ERROR;
    PVOID p;
    BOOL b;
    LONG l;
    HKEY hKey;
    PCTSTR PfPath;
    LONG rc;

    LPCTSTR WinntDataSection = WINNT_DATA;
    LPCTSTR WinntSetupSection = WINNT_SETUPPARAMS;
    LPCTSTR WinntAccessSection = WINNT_ACCESSIBILITY;
    LPCTSTR WinntSetupDataSection = TEXT("SetupData");
#if defined(REMOTE_BOOT)
    LPCTSTR WinntUserDataSection = TEXT("UserData");
#endif // defined(REMOTE_BOOT)
    LPCTSTR WinntUniqueId = WINNT_D_UNIQUEID;
    LPCTSTR WinntNull = WINNT_A_NULL;
    LPCTSTR WinntUserSection = WINNT_USERDATA;

    if( !FileName )
        d=ERROR_INVALID_PARAMETER;

    //
    // Make sure path for file is present, and form its fully qualified name.
    //
    if(d == NO_ERROR){
        StringCchCopy(FullPath, ARRAYSIZE(FullPath), FileName);
        if((t=_tcsrchr(FullPath,TEXT('\\')))) {
            *t= 0;
            d = CreateMultiLevelDirectory(FullPath);
        }else
            d=ERROR_INVALID_PARAMETER;

    }
    if(d != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_DIR_CREATE_FAILED,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            FullPath
            );

        return(FALSE);
    }

    //
    // Get rid of any existing parameters file.
    //
    DeleteFile(FileName);

#ifdef _X86_

    if (!ISNT()) {

        //
        // If this is a 9x machine, we need to preserve the drive letters, even
        // if it is an NT clean install.
        //

        SaveDriveLetterInformation (FileName);

    }

#endif
    
    //
    // Value indicating that this is winnt/winnt32-based installation,
    // and on amd64/x86, value to indicate that this is a floppyless operation
    // as apropriate.
    //
    b = WritePrivateProfileString(WinntDataSection,WINNT_D_MSDOS,TEXT("1"),FileName);
    if (b && HideWinDir) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("HideWinDir"),TEXT("1"),FileName);
    }

    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        if(b && Floppyless) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_FLOPPY,TEXT("1"),FileName);
        }

        if (b && BuildCmdcons) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_CMDCONS,TEXT("1"),FileName);
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } // if (!IsArc())

    if(b && RunFromCD && !MakeLocalSource) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_LOCALSRC_CD,TEXT("1"),FileName);
    }   
    if (b) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_AUTO_PART,ChoosePartition?TEXT("0"):TEXT("1"),FileName);
    }

    if (b && UseSignatures) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("UseSignatures"),WINNT_A_YES,FileName);
    }
    if (b && InstallDir[0] && (ISNT() || !Upgrade)) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_INSTALLDIR,InstallDir,FileName);
    }
    if (b  && EulaComplete) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_EULADONE,TEXT("1"),FileName);
    }
    if (b  && NoLs && !MakeLocalSource) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_NOLS,TEXT("1"),FileName);
    }

    if (b  && UseBIOSToBoot) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("UseBIOSToBoot"),TEXT("1"),FileName);
    }

    if (b && WriteAcpiHalValue && Upgrade) {
        if (AcpiHalValue) {
            b = WritePrivateProfileString(WinntDataSection,TEXT("AcpiHAL"),TEXT("1"),FileName);
        } else {
            b = WritePrivateProfileString(WinntDataSection,TEXT("AcpiHAL"),TEXT("0"),FileName);
        }
    }
    if (b  && IgnoreExceptionPackages) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("IgnoreExceptionPackages"),TEXT("1"),FileName);
    }

#ifdef PRERELEASE
    if (b && AppendDebugDataToBoot) {
        if (!AsrQuickTest) {
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVarAppend"),TEXT("/Debug"),FileName);
        }
        else {
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVarAppend"),TEXT("/Debug /Baudrate=115200"),FileName);
        }
    }
#endif

    if (b && AsrQuickTest) {
        wsprintf(Text, TEXT("%d"), AsrQuickTest);
        b = WritePrivateProfileString(WinntDataSection,TEXT("AsrMode"),Text,FileName);
    }

    if (b && (RunningBVTs || AsrQuickTest)) {
        if (lDebugBaudRate == 1394) {
            // kd via 1394
            lstrcpy(Text, TEXT("/debug /debugport=1394"));
        } else if (lDebugComPort == 0) {
            wsprintf(Text, TEXT("/debug /baudrate=%d"), lDebugBaudRate);
        } else {
            wsprintf(Text, TEXT("/debug /baudrate=%d /debugport=com%d"), lDebugBaudRate, lDebugComPort);
        }

        // write the string to OsLoadOptions so "textmode" setup to run under the debugger
        b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptions"),Text,FileName);

        if (b) {
            // write the string to OsLoadOptionsVar so guimode setup to run under the debugger
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVar"),Text,FileName);

            if (b) {
                // also run guimode's setup.exe under NTSD. The -isd switch is needed to ensure that setup.exe starts
                // without a global system manifest since winlogon spawns it with the CREATE_IGNORE_SYSTEM_DEFAULT flag,
                // and ntsd normall calls CreateProcess which would undo the above flag.
                b = WritePrivateProfileString(WinntSetupDataSection,TEXT("SetupCmdlinePrepend"),TEXT("ntsd -isd -odgGx"),FileName);
            }
        }
    }

    if (b && Timeout[0]) {

        b = WritePrivateProfileString(WinntSetupDataSection,WINNT_S_OSLOADTIMEOUT,Timeout,FileName);
    }

    if(b) {
        //
        // Write upgrade stuff. WinntUpgrade and Win95Upgrade will both be set,
        // and at most one of them will be set to yes.
        //
        if(b = WritePrivateProfileString(WinntDataSection,WINNT_D_NTUPGRADE,WINNT_A_NO,FileName)) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN95UPGRADE,WINNT_A_NO,FileName);
        }
        if(b) {
            wsprintf(Text,TEXT("%x"),GetVersion());
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_VER,Text,FileName);
            if(b && Upgrade) {
                b = WritePrivateProfileString(
                        WinntDataSection,
                        ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                        WINNT_A_YES,
                        FileName
                        );


                MyGetWindowsDirectory(Text,MAX_PATH);
                Text[2] = 0;

                b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_DRIVE,Text,FileName);
                if(b) {
                    Text[2] = TEXT('\\');
                    b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_PATH,Text+2,FileName);
                }
            }
        }
    }

    //
    // Flags for Accessible Setup
    //
    AccessibleSetup = FALSE;

    if(!Upgrade) {
        if(b && AccessibleMagnifier) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_MAGNIFIER,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
        if(b && AccessibleReader) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_READER,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
        if(b && AccessibleKeyboard) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_KEYBOARD,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
    }

    if(b && AccessibleSetup && !UnattendedOperation) {
        UnattendedOperation = TRUE;
        UnattendedShutdownTimeout = 0;
        UnattendedScriptFile = MALLOC(MAX_PATH * sizeof(TCHAR));
        b = (UnattendedScriptFile != NULL);
        if(b) {
            lstrcpy(UnattendedScriptFile,NativeSourcePaths[0]);
            ConcatenatePaths(UnattendedScriptFile,AccessibleScriptFile,MAX_PATH);
        }
    }

    if(!b) {
        goto c1;
    }

    //
    // Value indicating we're automatically and quietly skipping missing files.
    //
    if(AutoSkipMissingFiles) {
        b = WritePrivateProfileString(WinntSetupSection,WINNT_S_SKIPMISSING,TEXT("1"),FileName);
        if(!b) {
            goto c1;
        }
    }

    //
    // Command to be executed at end of GUI setup, if any.
    //
    if(CmdToExecuteAtEndOfGui) {

        b = WritePrivateProfileString(
                WinntSetupSection,
                WINNT_S_USEREXECUTE,
                CmdToExecuteAtEndOfGui,
                FileName
                );


        if(!b) {
            goto c1;
        }
    }

    //
    // Ensure that Plug and Play state in upgraded os will be the same as the
    // original.  Enables per-device settings to be preserved in the NT5+
    // upgrade scenario.
    //
    if (ISNT() && (BuildNumber > NT40) && Upgrade) {
        LPTSTR buffer = NULL;

        if (MigrateDeviceInstanceData(&buffer)) {
            WritePrivateProfileSection(WINNT_DEVICEINSTANCES,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }

        if (MigrateClassKeys(&buffer)) {
            WritePrivateProfileSection(WINNT_CLASSKEYS,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }

        if (MigrateHashValues(&buffer)) {
            WritePrivateProfileSection(WINNT_DEVICEHASHVALUES,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }
    }

    //
    // Remember udf info. If there's a database file, stick a * on the end
    // of the ID before writing it.
    //
    if(UniquenessId) {

        d = lstrlen(UniquenessId);
        if(d >= (MAX_PATH-1)) {
            d--;
        }
        lstrcpyn(Text,UniquenessId,MAX_PATH-1);
        if(UniquenessDatabaseFile) {
            Text[d] = TEXT('*');
            Text[d+1] = 0;
        }

        b = WritePrivateProfileString(WinntDataSection,WINNT_D_UNIQUENESS,Text,FileName);
        if(!b) {
            goto c1;
        }
        if(UniquenessDatabaseFile) {

            if ('\0' == LocalSourceDirectory[0]) {
                MessageBoxFromMessage(
                            ParentWindow,
                            MSG_UDF_INVALID_USAGE,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            UniquenessDatabaseFile
                            );
                goto c0;
            }

            lstrcpyn(Text,LocalSourceDirectory,MAX_PATH);
            ConcatenatePaths(Text,WINNT_UNIQUENESS_DB,MAX_PATH);

            CreateMultiLevelDirectory(LocalSourceDirectory);
            b = CopyFile(UniquenessDatabaseFile,Text,FALSE);
            if(!b) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_UDF_FILE_INVALID,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    UniquenessDatabaseFile
                    );

                goto c0;
            }
        }
    }

    //
    // If any optional dirs are present then we want to generate
    // an entry in the sif file that contains a line that specifies them
    // in the form dir1*dir2*...*dirn
    //
    OptionalDirLength = 0;
    OptionalDirString = NULL;

    for(d=0; d<OptionalDirectoryCount; d++) {
        //
        // Ignore temp-only and oem directories here.
        //
        if(OptionalDirectoryFlags[d] & (OPTDIR_OEMSYS | OPTDIR_TEMPONLY | OPTDIR_OVERLAY)) {
            continue;
        }

        if (OptionalDirectoryFlags[d] & (OPTDIR_DEBUGGER)) {
            // hardcode the dest dir to "Debuggers"
            OptDir = TEXT("Debuggers");
        } else {
            if (OptionalDirectoryFlags[d] & OPTDIR_USE_TAIL_FOLDER_NAME) {
                //
                // create all copydir: directories in a subdirectory under target %windir%
                //
                OptDir = _tcsrchr (OptionalDirectories[d], TEXT('\\'));
                if (OptDir) {
                    OptDir++;
                } else {
                    OptDir = OptionalDirectories[d];
                }
            } else {
                OptDir = OptionalDirectories[d];
            }
        }

        //
        // support ".." syntax
        //
        while (_tcsstr(OptDir,TEXT("..\\"))) {
            OptDir += 3;
        }

        if(OptionalDirString) {

            p = REALLOC(
                    OptionalDirString,
                    (lstrlen(OptDir) + 2 + OptionalDirLength) * sizeof(TCHAR)
                    );
        } else {
            p = MALLOC((lstrlen(OptDir)+2)*sizeof(TCHAR));
        }

        if(!p) {
            if(OptionalDirString) {
                FREE(OptionalDirString);
            }
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto c1;
        }

        OptionalDirString = p;

        if(OptionalDirLength) {
            lstrcat(OptionalDirString,OptDir);
        } else {
            lstrcpy(OptionalDirString,OptDir);
        }

        lstrcat(OptionalDirString,TEXT("*"));
        OptionalDirLength = lstrlen(OptionalDirString);
    }

    if(OptionalDirString) {
        //
        // Remove trailing * if any
        //
        d = lstrlen(OptionalDirString);
        if(d && (OptionalDirString[d-1] == TEXT('*'))) {
            OptionalDirString[d-1] = 0;
        }

        b = WritePrivateProfileString(
                WinntSetupSection,
                WINNT_S_OPTIONALDIRS,
                OptionalDirString,
                FileName
                );

        d = GetLastError();

        FREE(OptionalDirString);

        if(!b) {
            SetLastError(d);
            goto c1;
        }
    }

    //
    // Slap a unique identifier into the registry.
    // We'll use this in unattended upgrade during text mode
    // to find this build.
    //
    // Pretty simple: we'll use a string that derives
    // from the sysroot, and some unique value based on
    // the current tick count.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\Setup"),
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            &d
            );

    if(l != NO_ERROR) {
        SetLastError(l);
        goto c2;
    }

    d = MyGetWindowsDirectory(Text,MAX_PATH);
    if((d + 5) > MAX_PATH) {
        d = MAX_PATH - 5;
    }

    Text[d++] = TEXT('\\');
    Text[d++] = (TCHAR)(((GetTickCount() & 0x00f) >> 0) + 'A');
    Text[d++] = (TCHAR)(((GetTickCount() & 0x0f0) >> 4) + 'A');
    Text[d++] = (TCHAR)(((GetTickCount() & 0xf00) >> 8) + 'A');
    Text[d++] = 0;

    //
    // Set the value in the registry.
    //
    l = RegSetValueEx(hKey,WinntUniqueId,0,REG_SZ,(CONST BYTE *)Text,d*sizeof(TCHAR));
    if(l == NO_ERROR) {
        l = RegFlushKey (hKey);
    }

    RegCloseKey(hKey);
    if(l != NO_ERROR) {
        SetLastError(l);
        goto c2;
    }

    //
    // Stick the value in winnt.sif so we can correlate
    // later when we go to upgrade.
    //
    b = WritePrivateProfileString(WinntDataSection,WinntUniqueId,Text,FileName);
    if(!b) {
        goto c1;
    }

    //
    // Now write information about the source path(s) we used.
    // Use SourcePath[0].
    //
    // If the name starts with \\ then we assume it's UNC and
    // just use it directly. Otherwise we call MyGetDriveType on it
    // and if it's a network drive we get the UNC path.
    // Otherwise we just go ahead and save as-is.
    // Also save the type.
    //
    if((SourcePaths[0][0] == TEXT('\\')) && (SourcePaths[0][1] == TEXT('\\'))) {

        d = DRIVE_REMOTE;
        lstrcpy(Text,SourcePaths[0]);

    } else {
        if(GetFullPathName(SourcePaths[0],MAX_PATH,FullPath,(LPTSTR *)&p)) {
            if(FullPath[0] == TEXT('\\')) {
                //
                // Assume UNC, since a full path should normally start
                // with a drive letter.
                //
                d = DRIVE_REMOTE;
                lstrcpy(Text,FullPath);
            } else {
                d = MyGetDriveType(FullPath[0]);
                if((d == DRIVE_REMOTE) && (FullPath[1] == TEXT(':')) && (FullPath[2] == TEXT('\\'))) {
                    //
                    // Get actual UNC path.
                    //
                    FullPath[2] = 0;
                    l = MAX_PATH;

                    if(WNetGetConnection(FullPath,Text,(LPDWORD)&l) == NO_ERROR) {

                        l = lstrlen(Text);
                        if(l && (Text[l-1] != TEXT('\\')) && FullPath[3]) {
                            Text[l] = TEXT('\\');
                            Text[l+1] = 0;
                        }
                        StringCchCat(Text, ARRAYSIZE(Text), FullPath+3);
                    } else {
                        //
                        // Strange case.
                        //
                        FullPath[2] = TEXT('\\');
                        lstrcpy(Text,FullPath);
                        d = DRIVE_UNKNOWN;
                    }

                } else {
                    //
                    // Use as-is.
                    //
                    if(d == DRIVE_REMOTE) {
                        d = DRIVE_UNKNOWN;
                    }
                    lstrcpy(Text,FullPath);
                }
            }
        } else {
            //
            // Type is unknown. Just use as-is.
            //
            d = DRIVE_UNKNOWN;
            lstrcpy(Text,SourcePaths[0]);
        }
    }

    //
    // In the preinstall case ignore all the above and
    // force gui setup to search for a CD.
    // This particular combination of values will do it.
    //
    if(OemPreinstall) {

    //
    // marcw (7-22-97) - Changed to fix alpha build break.
    //                   FirstFloppyDriveLetter is defined on amd64/X86s only.
    //
        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            Text[0] = FirstFloppyDriveLetter;
            Text[1] = TEXT(':');
            Text[2] = TEXT('\\');
            Text[3] = 0;
#endif // defined(_AMD64_) || defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            lstrcpy(Text,TEXT("A:\\"));
#endif // UNICODE
        } // if (!IsArc())

        if (LocalSourceWithPlatform[0]) {

            ConcatenatePaths(
                Text,
                &LocalSourceWithPlatform[lstrlen(LocalSourceDirectory)],
                MAX_PATH
                );

        }

        d = DRIVE_CDROM;
    }

    b = WritePrivateProfileString(WinntDataSection,WINNT_D_ORI_SRCPATH,Text,FileName);
    if(!b) {
        goto c1;
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot upgrade, write the source path to SetupSourceDevice
    // under [SetupData]. We do NOT want the platform path here. Also write the
    // path to the machine directory to TargetNtPartition under [SetupData]. This
    // is just whatever \DosDevices\C: translates to. Finally, write the computer
    // name to ComputerName under [UserData].
    //
    if (RemoteBoot) {

        DWORD len;

        MYASSERT(d == DRIVE_REMOTE);
        MYASSERT((*Text == TEXT('\\')) && (*(Text + 1) == TEXT('\\')));

        lstrcpy(FullPath, TEXT("\\Device\\LanmanRedirector"));
        ConcatenatePaths(FullPath, Text+1, MAX_PATH);

        p = _tcsrchr(FullPath,TEXT('\\'));
        MYASSERT(p != NULL);
        *(LPTSTR)p = 0;

        b = WritePrivateProfileString(
                WinntSetupDataSection,
                TEXT("SetupSourceDevice"),
                FullPath,
                FileName);
        if(!b) {
            goto c1;
        }

        MyGetWindowsDirectory(Text, MAX_PATH);
        Text[2] = 0;
        len = QueryDosDevice(Text, Text, MAX_PATH);
        if (len == 0) {
            goto c1;
        }
        b = WritePrivateProfileString(
                WinntSetupDataSection,
                TEXT("TargetNtPartition"),
                Text,
                FileName);
        if(!b) {
            goto c1;
        }

        len = MAX_PATH;
        b = GetComputerName(Text, &len);
        if(!b) {
            goto c1;
        }
        b = WritePrivateProfileString(
                WinntUserDataSection,
                WINNT_US_COMPNAME,
                Text,
                FileName);
        if(!b) {
            goto c1;
        }
    }
#endif // defined(REMOTE_BOOT)

    wsprintf(Text,TEXT("%u"),d);
    WritePrivateProfileString(WinntDataSection,WINNT_D_ORI_SRCTYPE,Text,FileName);
    if(!b) {
        goto c1;
    }
#ifdef _X86_
    //
    // NT 4 and Win95 for NEC98 have 2 types Drive assing.
    //  - NEC DOS Type(A: HD, B:HD,...X:FD)
    //  - PC-AT Type(A:FD, B:FD, C:HD, D:HD, ....)
    //
    // Upgrade setup should be keep above drive assign and All setup should
    // be keep FT information.
    // Because some Applications have drive letter in own data file or registry.
    // NT5 setup for NEC98 have Drive assign type in winnt.sif section[data].
    // And this key is "DriveAssign_Nec98".
    // Value is "yes", It means NEC DOS Type assign.
    // Value is "no", It means PC-AT Type.
    // Now, This Key defined this place, but near future, this key move into
    // \nt\public\sdk\inc\setupbat.h, I hope.
    //
    // \textmode\kernel\spsetup.c has same defines.
    //

#define WINNT_D_DRIVEASSIGN_NEC98_W L"DriveAssign_Nec98"
#define WINNT_D_DRIVEASSIGN_NEC98_A "DriveAssign_Nec98"

#ifdef UNICODE
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_W
#else
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_A
#endif

    if (IsNEC98()){
        if (IsDriveAssignNEC98() == TRUE){
            WritePrivateProfileString(WinntDataSection, WINNT_D_DRIVEASSIGN_NEC98, WINNT_A_YES, FileName);
        } else {
            WritePrivateProfileString(WinntDataSection, WINNT_D_DRIVEASSIGN_NEC98, WINNT_A_NO, FileName);

        }
    }
#endif
    //
    // At this point we process the file, and surround all values with
    // double-quotes. This gets around certain problems in the various
    // inf parsers used in later stages of setup. Do this BEFORE appending
    // the unattend stript file, because some of the stuff in there expects
    // to be treated as multiple values, which double quotes ruin.
    //
    WritePrivateProfileString(NULL,NULL,NULL,FileName);
    d = PatchWinntSifFile(FileName);
    if(d != NO_ERROR) {
        SetLastError(d);
        goto c1;
    }

    //
    // Language options
    // Note: we don't want these values surrounded by double-quotes.
    //
    if( SaveLanguageParams( FileName ) ) {
        FreeLanguageData();
    } else {
        goto c1;
    }

    //
    // Append unattend script file if necessary.
    //
    if(UnattendedOperation && UnattendedScriptFile) {
        if (!MigrateUnattendDataEntries(FileName, UnattendedScriptFile)){
            goto c1;
        }
        
        if(!AppendParamsFile(ParentWindow,UnattendedScriptFile,FileName)) {
           return(FALSE);
        }
    }

#if defined(UNICODE) && defined(_X86_)
    //
    // Append any migdll info.
    //
    if (Upgrade && ISNT() && *g_MigDllAnswerFilePath && FileExists (g_MigDllAnswerFilePath, NULL)) {
        AppendParamsFile (ParentWindow, g_MigDllAnswerFilePath, FileName);
    }


#endif

    //
    // append DynamicUpdate data
    //
    if (!DynamicUpdateWriteParams (FileName)) {
        goto c1;
    }

    //
    // If we're explicitly in unattended mode then it's possible that
    // there is no [Unattended] section in winnt.sif yet, such as if
    // the user used the /unattend switch without specifying a file,
    // or if the file he did specify didn't have an [Unattended] section
    // for some reason.
    //
    // Also, make all upgrades unattended.
    //
    // Text mode setup kicks into unattended mode based on the presence
    // of the [Unattended] section.
    //
    if(UnattendedOperation || Upgrade) {
        if(!WritePrivateProfileString(WINNT_UNATTENDED,TEXT("unused"),TEXT("unused"),FileName)) {
            goto c1;
        }
    }

    //
    // Since several conditions can turn on UnattendedOperation, we keep track
    // of whether the user actually specified the "/unattend" switch separately.
    //
    if( UnattendSwitchSpecified ) {
        if(!WritePrivateProfileString(WinntDataSection,WINNT_D_UNATTEND_SWITCH,WINNT_A_YES,FileName)) {
            goto c1;
        }
    }

    //
    // set the NTFS conversion flag
    //
    GetPrivateProfileString(WINNT_UNATTENDED,TEXT("FileSystem"),TEXT(""),Text,sizeof(Text)/sizeof(TCHAR),FileName);
    if (_tcslen(Text) == 0) {
        if (ForceNTFSConversion) {
            if(!WritePrivateProfileString(WinntDataSection,TEXT("FileSystem"),TEXT("ConvertNTFS"),FileName)) {
                goto c1;
            }
        }
    }




    //
    // Headless Stuff.
    //
    if( !WriteHeadlessParameters( FileName ) ) {
        goto c1;
    }



    if ( (Upgrade) &&
         !(ISNT() && (BuildNumber <= NT351)) ) {

        //
        // Save current Program Files directory
        //

        rc = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                0,        //ulOptions (reserved)
                KEY_READ,
                &hKey
                );

        if (rc != ERROR_SUCCESS) {
            goto c1;
        }

        PfPath = pGetPfPath (hKey, TEXT("ProgramFilesDir"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_PROGRAMFILESDIR,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

        PfPath = pGetPfPath (hKey, TEXT("CommonFilesDir"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_COMMONPROGRAMFILESDIR,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

#ifdef WX86

        PfPath = pGetPfPath (hKey, TEXT("ProgramFilesDir (x86)"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_PROGRAMFILESDIR_X86,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

        PfPath = pGetPfPath (hKey, TEXT("CommonFilesDir (x86)"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_COMMONPROGRAMFILESDIR_X86,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

#endif

        RegCloseKey(hKey);
    }

    //
    // value indicating the product ID
    //  we need to write this in after appending the unattend file data, since the
    //  product ID in the unattend file may have been incorrect, but this product ID
    //  has already been verified as valid. we need to make sure we surround the product ID with quotes
    //
    if (b ) {
        // This will overwrite any existing "ProductID" entry. Which may have been added
        // by merging the unattend file.
        // If we don't do this. GUI mode overwrites the "ProductKey" with the entry
        // under "ProductID".
       b = WritePidToParametersFile(WinntUserSection,WINNT_US_PRODUCTID,FileName);
       if (!b) {
          goto c1;
       }

       b = WritePidToParametersFile(WinntUserSection,WINNT_US_PRODUCTKEY,FileName);
       if (!b) {
          goto c1;
       }
    }

    //
    // Do not save the proxy settings if we are running under WINPE.
    //
    if (!IsWinPEMode()){
        SaveProxyForOobe(FileName);
    }

    return(TRUE);


c3:
    FREE((PVOID) PfPath);
    RegCloseKey(hKey);

c2:
    MessageBoxFromMessageAndSystemError(
        ParentWindow,
        MSG_REGISTRY_ACCESS_ERROR,
        GetLastError(),
        AppTitleStringId,
        MB_OK | MB_ICONERROR | MB_TASKMODAL,
        NULL
        );
    goto c0;

c1:
    MessageBoxFromMessageAndSystemError(
        ParentWindow,
        MSG_BOOT_FILE_ERROR,
        GetLastError(),
        AppTitleStringId,
        MB_OK | MB_ICONERROR | MB_TASKMODAL,
        FileName
        );
c0:
    return(FALSE);
}


DWORD
PatchWinntSifFile(
    IN LPCTSTR Filename
    )

/*++

Routine Description:

    This function works around the problems in the setupldr parser,
    which cannot handle unquoted strings. Each line in the given file
    is enclosed within quotation marks.

Arguments:

    Filename - Name of the WINNT.SIF file

Return Value:

    Boolean value indicating outcome. If FALSE the user is NOT
    informed about why; the caller must do that.

--*/

{
    PVOID Base;
    HANDLE hMap,hFile;
    DWORD Size;
    DWORD d;
    PCHAR End;
    PCHAR p,q;
    PCHAR o,a;
    PCHAR Buffer;
    int l1,l2;
    int tryagain=0;

    //
    // Open the file.
    //

    d = MapFileForRead(Filename,&Size,&hFile,&hMap,&Base);
    if(d != NO_ERROR) {
        return(FALSE);
    }

    //
    // Allocate the output buffer; the original size + extra space for quotes
    //
    Buffer = MALLOC(Size + Size / 4);
    if(!Buffer) {
        UnmapFile(hMap,Base);
        CloseHandle(hFile);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    o = Buffer;
    p = Base;
    End = p+Size;

    while(p < End) {
        //
        // Find end of line.
        //
        for(q=p; (q < End) && (*q != '\n'); q++) {
            NOTHING;
        }

        //
        // Find equals sign, if present
        //
        for(a=p; a<q; a++) {
            if(*a == '=') {
                break;
            }
        }
        if(a >= q) {
            a = NULL;
        }

        if(a) {

            a++;

            l1 = (int)(a - p);
            l2 = (int)(q - a);

            CopyMemory(o,p,l1);
            o += l1;
            *o++ = '\"';
            CopyMemory(o,a,l2);
            o += l2;
            if(*(o-1) == '\r') {
                o--;
            }
            *o++ = '\"';
            *o++ = '\r';
            *o++ = '\n';

        } else {

            l1 = (int)(q-p);
            CopyMemory(o,p,l1);
            o += l1;
            *o++ = '\n';
        }

        //
        // Skip to start of next line
        //
        p=q+1;
    }

    UnmapFile(hMap,Base);
    CloseHandle(hFile);

    SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);
    //
    // We try opening the file thrice to get around the problem of anti-virus software
    // that monitor files on the root of the system partition. The problem is that usually these
    // s/w examine the files we touch and in somecases open it with exclusive access.
    // We just need to wait for them to be done.
    //


    while( tryagain++ < 3 ){
        hFile = CreateFile(
                Filename,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
        if(hFile != INVALID_HANDLE_VALUE)
            break;
        Sleep(500);

    }


    if(hFile == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        FREE(Buffer);
        return(d);
    }

    d = WriteFile(hFile,Buffer,(DWORD)(o-Buffer),&Size,NULL) ? NO_ERROR : GetLastError();

    CloseHandle(hFile);
    FREE(Buffer);

    return(d);
}


BOOL
AppendParamsFile(
    IN HWND    ParentWindow,
    IN LPCTSTR ParametersFileIn,
    IN LPCTSTR ParametersFileOut
    )

/*++

Routine Description:

    Read an external file (such as an unattended script file)
    and copy it section by section into the winnt.sif parameters
    file. (The [Data] and [OemBootFiles] sections of the unattend file
    are ignored.)

Arguments:

    ParentWindow - supplies window handle of window to act as owner/parent
        if this routine has to put up ui, such as when the script file
        is bogus.

    ParametersFileIn - supplies win32 filename of the file, such as
        unattend.txt, being appended to winnt.sif.

    ParametersFileOut - supplies win32 filename of the winnt.sif file
        being generated.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed of why.

--*/

{
    TCHAR *SectionNames;
    TCHAR *SectionData;
    TCHAR *SectionName;
    DWORD SectionNamesSize;
    DWORD SectionDataSize;
    DWORD d;
    TCHAR TempFile[MAX_PATH] = TEXT("");
    PCTSTR RealInputFile = NULL;
    BOOL b;
    PVOID p;



    #define PROFILE_BUFSIZE 16384
    #define PROFILE_BUFGROW 4096

    //
    // Allocate some memory for the required buffers
    //
    SectionNames = MALLOC(PROFILE_BUFSIZE * sizeof(TCHAR));
    SectionData  = MALLOC(PROFILE_BUFSIZE * sizeof(TCHAR));

    if(!SectionNames || !SectionData) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        b = FALSE;
        goto c0;
    }

    *TempFile = 0;
    RealInputFile = ParametersFileIn;


    //
    // There is a bug in Win9x's GetPrivateProfileSection() Such that if the file
    // being queried exists on a read only share, it will not return the section strings.
    // This is bad.
    //
    // To work around this, on win9x, we are going to make a temporary copy of the inf
    // merge it in and then delete it.
    //
#ifdef _X86_
    if (!ISNT() && ParametersFileIn && FileExists (ParametersFileIn, NULL)) {

        GetSystemDirectory (TempFile, MAX_PATH);
        GetTempFileName (TempFile, TEXT("USF"), 0, TempFile);
        CopyFile (ParametersFileIn, TempFile, FALSE);
        RealInputFile = TempFile;
    }
#endif


    SectionNamesSize = PROFILE_BUFSIZE;
    SectionDataSize  = PROFILE_BUFSIZE;

    //
    // Retreive a list of section names in the unattend script file.
    //
    do {
        d = GetPrivateProfileString(
            NULL,
            NULL,
            TEXT(""),
            SectionNames,
            SectionNamesSize,
            RealInputFile
            );

        if(!d) {
            //
            // No section names. Bogus file.
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNATTEND_FILE_INVALID,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                ParametersFileIn
                );

            b = FALSE;
            goto c0;
        }

        if(d == (SectionNamesSize-2)) {
            //
            // Buffer was too small. Reallocate it and try again.
            //
            p = REALLOC(
                    SectionNames,
                    (SectionNamesSize+PROFILE_BUFGROW)*sizeof(TCHAR)
                    );

            if(!p) {
                MessageBoxFromMessage(
                    ParentWindow,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
                goto c0;
            }

            SectionNames = p;
            SectionNamesSize += PROFILE_BUFGROW;
        }
    } while(d == (SectionNamesSize-2));

    for(SectionName=SectionNames; *SectionName; SectionName+=lstrlen(SectionName)+1) {
        //
        // Ignore the [data] section in the source, as we do not
        // want copy it into the target, because this would overwrite
        // our internal settings.
        // Ignore also [OemBootFiles]
        //
        if(lstrcmpi(SectionName,WINNT_DATA) && lstrcmpi(SectionName,WINNT_OEMBOOTFILES)) {
            //
            // Fetch the entire section and write it to the target file.
            // Note that the section-based API call will leave double-quotes
            // intact when we retrieve the data, which is what we want.
            // Key-based API calls will strip quotes, which screws us.
            //
            while(GetPrivateProfileSection(
                    SectionName,
                    SectionData,
                    SectionDataSize,
                    RealInputFile
                    )                       == (SectionDataSize-2)) {

                //
                // Reallocate the buffer and try again.
                //
                p = REALLOC(
                        SectionData,
                        (SectionDataSize+PROFILE_BUFGROW)*sizeof(TCHAR)
                        );

                if(!p) {
                    MessageBoxFromMessage(
                        ParentWindow,
                        MSG_OUT_OF_MEMORY,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                    b = FALSE;
                    goto c0;
                }

                SectionData = 0;
                SectionDataSize += PROFILE_BUFGROW;
            }

            //
            // Write the entire section to the output file.
            //
            if(!WritePrivateProfileSection(SectionName,SectionData,ParametersFileOut)) {

                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_BOOT_FILE_ERROR,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    ParametersFileOut
                    );

                b = FALSE;
                goto c0;
            }
        }
    }

    b = TRUE;

c0:
    if(SectionNames) {
        FREE(SectionNames);
    }
    if(SectionData) {
        FREE(SectionData);
    }

    if (*TempFile) {

        DeleteFile (TempFile);
    }

    return(b);
}


BOOL
WriteParametersFile(
    IN HWND ParentWindow
    )
{
    TCHAR SysPartFile[MAX_PATH];
    DWORD d;
    BOOL  b;

    //
    // Write the file out onto the root of the system partition drive
    // and then move the file into place where it actually belongs.
    //
#if defined(REMOTE_BOOT)
    if (RemoteBoot) {
        //
        // For remote boot, put the file in the root of the machine directory
        // and leave it there.
        //
        StringCchCopy(SysPartFile, ARRAYSIZE(SysPartFile), MachineDirectory);
        StringCchCat(SysPartFile, ARRAYSIZE(SysPartFile), TEXT("\\"));
        StringCchCat(SysPartFile, ARRAYSIZE(SysPartFile), WINNT_SIF_FILE);
        StringCchCopy(ActualParamFile, ARRAYSIZE(ActualParamFile), SysPartFile);
    } else
#endif // defined(REMOTE_BOOT)
    {
        if (!BuildSystemPartitionPathToFile (WINNT_SIF_FILE, SysPartFile, MAX_PATH)) {
            return(FALSE); // this should never happen.
        }
    }

    if(!DoWriteParametersFile(ParentWindow,SysPartFile)) {
        return(FALSE);
    }

#if defined(REMOTE_BOOT)
    //
    // For remote boot, leave the file in the root of the machine directory.
    //

    if (!RemoteBoot)
#endif // defined(REMOTE_BOOT)
    {

        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            //
            // In the amd64/x86 case this file belongs on the boot media
            // somewhere. If we're generating floppyless boot media
            // then move the file into place. Otherwise there's no point.
            //
            // In the non-floppyless case we keep the file around until later
            // when the floppy-generation code gets to run.
            //
            if(MakeBootMedia) {

                if(Floppyless) {

                    BuildSystemPartitionPathToFile (LOCAL_BOOT_DIR, ActualParamFile, MAX_PATH);

                    d = CreateMultiLevelDirectory(ActualParamFile);
                    if(d != NO_ERROR) {

                        MessageBoxFromMessageAndSystemError(
                            ParentWindow,
                            MSG_DIR_CREATE_FAILED,
                            d,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            ActualParamFile
                            );

                        DeleteFile(SysPartFile);
                        return(FALSE);
                    }

                    ConcatenatePaths(ActualParamFile,WINNT_SIF_FILE,MAX_PATH);

                    //
                    // Move the file into its real location.
                    //
                    DeleteFile(ActualParamFile);

                    //
                    // On Windows 95, MoveFile fails in strange ways
                    // when the profile APIs have the file open (for instance,
                    // it will leave the src file and the dest file will be
                    // filled with garbage).
                    //
                    // Flush it.
                    //
                    WritePrivateProfileString(NULL,NULL,NULL,SysPartFile);

                    if (SysPartFile[0] == ActualParamFile[0]) {
                        b = MoveFile(SysPartFile,ActualParamFile);
                    } else {
                        b = CopyFile (SysPartFile, ActualParamFile, FALSE);
                        if (b) {
                            DeleteFile (SysPartFile);
                        }
                    }

                    if (!b) {
                        MessageBoxFromMessageAndSystemError(
                            ParentWindow,
                            MSG_BOOT_FILE_ERROR,
                            GetLastError(),
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            ActualParamFile
                            );

                        DeleteFile(SysPartFile);

                        return(FALSE);
                    }

                }
            } else {
                DeleteFile(SysPartFile);
            }
#endif // defined(_AMD64_) || defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // If we're making a local source, move the file there.
            // Otherwise just leave it on the root of the system partition.
            //
            if(MakeLocalSource) {

                d = CreateMultiLevelDirectory(LocalSourceWithPlatform);
                if(d != NO_ERROR) {

                    MessageBoxFromMessageAndSystemError(
                        ParentWindow,
                        MSG_DIR_CREATE_FAILED,
                        d,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL,
                        LocalSourceWithPlatform
                        );

                    DeleteFile(SysPartFile);
                    return(FALSE);
                }

                //
                // Move the file into its real location.
                //
                StringCchPrintf(ActualParamFile, ARRAYSIZE(ActualParamFile), TEXT("%s\\%s"),LocalSourceWithPlatform,WINNT_SIF_FILE);
                DeleteFile(ActualParamFile);
                if(!MoveFile(SysPartFile,ActualParamFile)) {

                    MessageBoxFromMessageAndSystemError(
                        ParentWindow,
                        MSG_BOOT_FILE_ERROR,
                        GetLastError(),
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL,
                        ActualParamFile
                        );

                    DeleteFile(SysPartFile);
                    return(FALSE);
                }
            }
#endif // UNICODE
        } // if (!IsArc())
    }

    return(TRUE);
}


#define MULTI_SZ_NEXT_STRING(x) ((x) + _tcslen(x) + 1)

BOOL
MergeINFFiles(
    IN      PCTSTR SourceFileName,
    IN      PCTSTR DestFileName
    )
{
    DWORD dwAttributes;
    PTSTR pSectionsBuffer = NULL;
    PTSTR pKeysBuffer = NULL;
    PTSTR pString = NULL;
    PTSTR pSection;
    PTSTR pKey;
    UINT sizeOfBuffer;
    UINT sizeOfSectionBuffer;
    BOOL bResult = FALSE;

    MYASSERT (SourceFileName && DestFileName);

    if(-1 == GetFileAttributes(SourceFileName)){
        return TRUE;
    }

    __try{
        //
        // Allocate buffer for sections names.
        //
        sizeOfBuffer = 0;
        do{
            if(pSectionsBuffer){
                FREE(pSectionsBuffer);
            }
            sizeOfBuffer += DEF_INF_BUFFER_SIZE;
            pSectionsBuffer = (PTSTR)MALLOC(sizeOfBuffer * sizeof (TCHAR));
            if(!pSectionsBuffer){
                __leave;
            }
        }while((sizeOfBuffer - 2) ==
               GetPrivateProfileSectionNames(pSectionsBuffer,
                                             sizeOfBuffer,
                                             SourceFileName));

        sizeOfSectionBuffer = DEF_INF_BUFFER_SIZE;
        pKeysBuffer = (PTSTR)MALLOC(sizeOfSectionBuffer * sizeof (TCHAR));
        if(!pKeysBuffer){
            __leave;
        }

        sizeOfBuffer = DEF_INF_BUFFER_SIZE;
        pString = (PTSTR)MALLOC(sizeOfBuffer * sizeof (TCHAR));
        if(!pString){
            __leave;
        }

        for(pSection = pSectionsBuffer; pSection[0]; pSection = MULTI_SZ_NEXT_STRING(pSection)){
            //
            // Allocate buffer for entries names;
            //
            while((sizeOfSectionBuffer - 2) ==
                   GetPrivateProfileString(pSection,
                                           NULL,
                                           EMPTY_STRING,
                                           pKeysBuffer,
                                           sizeOfSectionBuffer,
                                           SourceFileName)){
                if(pKeysBuffer){
                    FREE(pKeysBuffer);
                }
                sizeOfSectionBuffer += DEF_INF_BUFFER_SIZE;
                pKeysBuffer = (PTSTR)MALLOC(sizeOfSectionBuffer * sizeof (TCHAR));
                if(!pKeysBuffer){
                    __leave;
                }
            };


            for(pKey = pKeysBuffer; pKey[0]; pKey = MULTI_SZ_NEXT_STRING(pKey))
            {
                //
                // Allocate buffer for value string;
                //
                GetPrivateProfileString(pSection,
                                        pKey,
                                        EMPTY_STRING,
                                        pString,
                                        sizeOfBuffer,
                                        SourceFileName);

                if (!WritePrivateProfileString(pSection, pKey, pString, DestFileName)) {
                    __leave;
                }
            }
        }
        bResult = TRUE;
    }
    __finally{
        DWORD rc = GetLastError ();
        if(pSectionsBuffer){
            FREE(pSectionsBuffer);
        }
        if(pKeysBuffer){
            FREE(pKeysBuffer);
        }
        if(pString){
            FREE(pString);
        }
        SetLastError (rc);
    }

    return bResult;
}

BOOL
AddExternalParams (
    IN HWND ParentWindow
    )
{
    DWORD rc = ERROR_SUCCESS;
    static BOOL Done = FALSE;

    if(Done) {
        return(TRUE);
    }

    //
    // Append external parameters if necessary.
    //

    if(Upgrade && UpgradeSupport.WriteParamsRoutine) {
        rc = UpgradeSupport.WriteParamsRoutine(ActualParamFile);

        if (rc != ERROR_SUCCESS) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                ActualParamFile
                );
        }
    }

#if defined(UNICODE) && defined(_X86_)
    //
    // Merge NT migration unattented inf file with winnt.sif
    //
    if(Upgrade && !MergeINFFiles(g_MigDllAnswerFilePath, ActualParamFile)){
        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            g_MigDllAnswerFilePath
            );
    }
#endif

    //
    // write the compatibility stuff in these cases
    //
    // 1. upgrade from downlevel NT platform
    // 2. clean install
    // 3. upgrade from current NT platform and we have NT5 compatibility items
    //
    // note that win9x has it's own upgrade code path.
    //
    if( (ISNT() && (BuildNumber <= NT40) && Upgrade)
        || !Upgrade
        || (ISNT() && Upgrade && AnyNt5CompatDlls) ){

        //
        // Disable stuff for <= NT4 case, clean install (unsupported arch. etc.)
        // and NT5 upgrade with NT5 upgrade components set
        //

        WriteCompatibilityData( ActualParamFile );
        WriteGUIModeInfOperations( ActualParamFile );
        AddGUIModeCompatibilityInfsToCopyList();
    }

    if (ISNT() && Upgrade) {
        if (!WriteTextmodeClobberData (ActualParamFile)) {
            rc = GetLastError ();
        }
    }

    Done = TRUE;
    return rc == ERROR_SUCCESS;
}

BOOL
MyWritePrivateProfileString(
    LPCTSTR lpAppName,  // pointer to section name
    LPCTSTR lpKeyName,  // pointer to key name
    LPCTSTR lpString,   // pointer to string to add
    LPCTSTR lpFileName  // pointer to initialization filename
    )
/*
  Wrapper for WritePrivateProfileString to try more than once on instances
  where we can't write to the winnt.sif file. This commonly occurs when
  virus software monitors the root of C drive.

  The problem is that usually these s/w examine the files we touch and in somecases open it
  with exclusive access. We just need to wait for them to be done.

*/
{

    int i = 0;
    BOOL ret = FALSE;
    DWORD Err;

    while(i++ < 3){
#ifdef UNICODE
    #ifdef WritePrivateProfileStringW
        #undef WritePrivateProfileStringW

        if( !lpAppName && !lpKeyName && !lpString ){
            WritePrivateProfileStringW( lpAppName, lpKeyName, lpString, lpFileName);
            return FALSE;
        }

        if( ret = WritePrivateProfileStringW( lpAppName, lpKeyName, lpString, lpFileName) )
            break;
    #endif
#else
    #ifdef WritePrivateProfileStringA
        #undef WritePrivateProfileStringA

        if( !lpAppName && !lpKeyName && !lpString ){
            WritePrivateProfileStringA( lpAppName, lpKeyName, lpString, lpFileName);
            return FALSE;
        }

        if( ret = WritePrivateProfileStringA( lpAppName, lpKeyName, lpString, lpFileName) )
            break;
    #endif
#endif
    Sleep( 500 );

    }

    return ret;
}


VOID
FixWininetList(
    LPTSTR List
    )
{
    PTCHAR t = List;

    if (t != NULL)
    {
        while (*t)
        {
            if (*t == (TCHAR)' ')
            {
                *t = (TCHAR)';';
            }
            t++;
        }
    }

}

#ifdef UNICODE

LPWSTR
AnsiToText(
    LPCSTR Ansi
    )
{
    int    Length;
    LPWSTR Unicode = NULL;

    if (Ansi == NULL)
    {
        return NULL;
    }

    Length = MultiByteToWideChar(
        CP_ACP,
        0,
        Ansi,
        -1,
        NULL,
        0
        );

    if (Length > 0)
    {
        int i;

        Unicode = (LPWSTR) GlobalAlloc(GPTR, Length * sizeof(WCHAR));
        if (!Unicode) {
            return NULL;
        }

        i = MultiByteToWideChar(
            CP_ACP,
            0,
            Ansi,
            -1,
            Unicode,
            Length);

        if (i == 0)
        {
            GlobalFree(Unicode);
            Unicode = NULL;
        }
    }

    return Unicode;
}


#else

LPSTR AnsiToText(
    LPCSTR Ansi
    )

/*++

Note:

    Can't use DupString because the caller assume memory obtained from
    GlobalAlloc.

--*/

{
    LPSTR CopyOfAnsi = NULL;

    if (Ansi != NULL)
    {
        CopyOfAnsi = GlobalAlloc(GPTR, (strlen(Ansi)+1) * sizeof(CHAR));
        if (CopyOfAnsi)
        {
            strcpy(CopyOfAnsi, Ansi);
        }
    }

    return CopyOfAnsi;
}

#endif

BOOL
QuoteString(
    IN OUT LPTSTR* StringPointer
    )

/*++

Routine Description:

    Replace the input string with a double quoted one.

Arguments:

    StringPointer - pointer to a string allocated by GlobalAlloc. The input
    string is always free. If it is successful the new string, allocated
    by GlobalAlloc, is returned; otherwise, NULL is returned.

Return:

   TRUE - successfully quote a string

   FALSE - otherwise

--*/

{
    LPTSTR StringValue = *StringPointer;
    LPTSTR QuotedString;

    QuotedString = GlobalAlloc(GPTR, (lstrlen(StringValue) + 3) * sizeof(TCHAR));
    if (QuotedString)
    {
        wsprintf(QuotedString, TEXT("\"%s\""), StringValue);
        *StringPointer = QuotedString;
    }
    else
    {
        *StringPointer = NULL;
    }

    GlobalFree(StringValue);

    return (*StringPointer != NULL);

}


VOID
SaveProxyForOobe(
    IN LPCTSTR FileName
    )

/*++

Routine Description:

    Save the LAN http and https proxy settings, if any, for OOBE to use while
    it is running in 'SYSTEM' context.

Arguments:

    FileName - specifies the full Win32 filename for saving Setup settings.

--*/

{
    typedef BOOL (WINAPI* PINTERNETQUERYOPTION)(
        IN HINTERNET hInternet OPTIONAL,
        IN DWORD dwOption,
        OUT LPVOID lpBuffer OPTIONAL,
        IN OUT LPDWORD lpdwBufferLength
        );

    HMODULE WinInetLib;
    LPTSTR  ProxyList = NULL;
    LPTSTR  ProxyOverride = NULL;
    LPTSTR  AutoConfigUrl = NULL;
    LPTSTR  AutoConfigUrl2 = NULL;
    DWORD   ProxyFlags = 0;
    DWORD   AutoDiscoveryFlags = 0;
    TCHAR   NumberStr[25];
    BOOL    Captured = FALSE;

    WinInetLib = LoadLibrary(TEXT("WININET.DLL"));

    //
    // We prefer the INTERNET_OPTION_PER_CONNECTION_OPTION because we just
    // want to save the LAN proxy settings and we want to know the auto proxy
    // setting, but this option is not supported until IE 5.0
    //
    if (WinInetLib != NULL)
    {
        PINTERNETQUERYOPTION pInternetQueryOption;

        pInternetQueryOption = (PINTERNETQUERYOPTION) GetProcAddress(
            WinInetLib,
#ifdef UNICODE
            "InternetQueryOptionW"
#else
            "InternetQueryOptionA"
#endif
            );

        if (pInternetQueryOption)
        {
            INTERNET_PER_CONN_OPTION_LIST OptionList;
            INTERNET_PER_CONN_OPTION      Option[6];
            DWORD                         BufferLength = sizeof(OptionList);

            OptionList.dwSize = sizeof(OptionList);
            OptionList.pszConnection = NULL;
            OptionList.dwOptionCount = 6;

            ZeroMemory(&Option, sizeof(Option));

            Option[0].dwOption = INTERNET_PER_CONN_FLAGS;
            Option[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
            Option[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
            Option[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
            Option[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
            Option[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;

            OptionList.pOptions = Option;

            if (pInternetQueryOption(
                    NULL,
                    INTERNET_OPTION_PER_CONNECTION_OPTION,
                    &OptionList,
                    &BufferLength
                    ) == TRUE)
            {
                ProxyFlags = Option[0].Value.dwValue;
                ProxyList = Option[1].Value.pszValue;
                ProxyOverride = Option[2].Value.pszValue;
                AutoConfigUrl = Option[3].Value.pszValue;
                AutoDiscoveryFlags = Option[4].Value.dwValue;
                AutoConfigUrl2 = Option[5].Value.pszValue;
                Captured = TRUE;
            }
            else
            {

                INTERNET_PROXY_INFO* ProxyInfo = NULL;
                DWORD                BufferLength = 0;

                //
                // We obtain the ANSI string for INTERNET_OPTION_PROXY,
                // even if we call InternetQueryOptionW.
                //
                // Proxy list returned from INTERNET_OPTION_PER_CONNECTION are
                // delimited by ';', while that returned from INTERNET_OPTION_PROXY
                // are delimited by ' '.
                //
                if (pInternetQueryOption(
                    NULL,
                    INTERNET_OPTION_PROXY,
                    ProxyInfo,
                    &BufferLength
                    ) == FALSE
                    &&
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {

                    ProxyInfo = (INTERNET_PROXY_INFO*) GlobalAlloc(GPTR, BufferLength);

                    if (ProxyInfo)
                    {
                        if (pInternetQueryOption(
                                NULL,
                                INTERNET_OPTION_PROXY,
                                ProxyInfo,
                                &BufferLength
                                ) == TRUE)
                        {
                            //
                            // Map the values to INTERNET_OPTION_PER_CONN_OPTION
                            // We enable the auto proxy settings even though
                            // INTERNET_OPTION_PROXY doesn't have value relevant
                            // to auto proxy, because IE5 default to use auto proxy.
                            //
                            // PROXY_TYPE_DIRECT is always set because wininet
                            // return this flags whether inetcpl.cpl is set
                            // to use proxy or not.
                            //
                            ProxyFlags = PROXY_TYPE_DIRECT | PROXY_TYPE_AUTO_DETECT;
                            if (ProxyInfo->dwAccessType != INTERNET_OPEN_TYPE_DIRECT)
                            {
                                ProxyFlags |= PROXY_TYPE_PROXY;
                            }

                            ProxyList = AnsiToText((LPCSTR)ProxyInfo->lpszProxy);
                            FixWininetList(ProxyList);
                            ProxyOverride = AnsiToText((LPCSTR)ProxyInfo->lpszProxyBypass);
                            FixWininetList(ProxyOverride);
                            AutoDiscoveryFlags = 0;
                            Captured = TRUE;
                        }

                        GlobalFree(ProxyInfo);

                    }

                }

            }

        }

        FreeLibrary(WinInetLib);

    }

    if (Captured)
    {
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_ENABLE_OOBEPROXY,
            TEXT("1"),
            FileName
            );

        if (ProxyList && QuoteString(&ProxyList))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_PROXY_SERVER,
                ProxyList,
                FileName
                );

            GlobalFree(ProxyList);
        }


        //
        // Fix the ProxyOverride to not have any "\r\n"s
        //
        if (ProxyOverride) {
            ReplaceSubStr(ProxyOverride, TEXT("\r\n"), TEXT(";"));
        }

        if (ProxyOverride && QuoteString(&ProxyOverride))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_PROXY_BYPASS,
                ProxyOverride,
                FileName
                );
            GlobalFree(ProxyOverride);
        }

        if (AutoConfigUrl && QuoteString(&AutoConfigUrl))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_AUTOCONFIG_URL,
                AutoConfigUrl,
                FileName
                );
            GlobalFree(AutoConfigUrl);
        }

        if (AutoConfigUrl2 && QuoteString(&AutoConfigUrl2))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_AUTOCONFIG_SECONDARY_URL,
                AutoConfigUrl2,
                FileName
                );
            GlobalFree(AutoConfigUrl2);
        }

        wsprintf(NumberStr, TEXT("%u"), ProxyFlags);
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_FLAGS,
            NumberStr,
            FileName
            );

        wsprintf(NumberStr, TEXT("%u"), AutoDiscoveryFlags);
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_AUTODISCOVERY_FLAGS,
            NumberStr,
            FileName
            );
    }
    else
    {
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_ENABLE_OOBEPROXY,
            TEXT("0"),
            FileName
            );
    }

}





#ifdef _X86_
BOOL
IsDriveAssignNEC98(
    VOID
    )
{
    TCHAR  sz95KeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
    TCHAR  sz95ValueName[] = TEXT("ATboot");
    TCHAR  szNTKeyName[] = TEXT("System\\setup");
    TCHAR  szNTValueName[] = TEXT("DriveLetter");
    HKEY   hKey;
    DWORD  type95 = REG_BINARY;
    DWORD  typeNT = REG_SZ;
    TCHAR  szData[5];
    DWORD  dwSize = 5;
    DWORD  rc;

    if(ISNT()){
        rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  szNTKeyName,
                                  0,            //ulOptions (reserved)
                                  KEY_READ,
                                  &hKey);

        if (ERROR_SUCCESS != rc) {
            return TRUE;
        }
        //
        // Query key to get the subkey count and max string lengths
        //
        rc = RegQueryValueEx (hKey,
                              szNTValueName,
                              NULL,         // lpReserved
                              &typeNT,
                              (LPBYTE) szData,
                              &dwSize);

        if (ERROR_SUCCESS != rc) {
            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey);

        if (szData[0] != L'C'){
            // NEC DOS Type.
            return TRUE;
        }
    } else { // It will be Win9x
        rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  sz95KeyName,
                                  0,        //ulOptions (reserved)
                                  KEY_READ,
                                  &hKey);

        if (ERROR_SUCCESS != rc) {
            return TRUE;
        }
        //
        // Query key to get the subkey count and max string lengths
        //
        rc = RegQueryValueEx (hKey,
                              sz95ValueName,
                              NULL,         // lpReserved
                              &type95,
                              (LPBYTE) szData,
                              &dwSize);

        if (ERROR_SUCCESS != rc) {
            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey);
        if (szData[0] == 0){
            // NEC DOS Type.
            return TRUE;
        }
    }
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\sectorio.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sectorio.c

Abstract:

    Routines to perform low-level sector I/O on either Windows NT or
    Windows 95.

Author:

    Ted Miller (tedm) 1 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <tlhelp32.h>


//
// Define structures for use with Win9x VWIN32.
// Note: alignment must be on 1-byte boundaries for these structures.
//
#include <pshpack1.h>

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS;

typedef struct _DIOC_DISKIO {
    DWORD  StartSector;
    WORD   SectorCount;
    LPBYTE Buffer;
} DIOC_DISKIO;

#include <poppack.h>

//
// Local prot type
//
BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    );


//
// Define codes we care about for use with VWIN32
//
#define VWIN32_DIOC_DOS_IOCTL           1
#define VWIN32_DIOC_DOS_INT25           2
#define VWIN32_DIOC_DOS_INT26           3
#define VWIN32_DIOC_DOS_DRIVEINFO       6       // new in OSR2

#if defined(_X86_)

BOOL
pGetWin9xLockFlagState (
    IN      HANDLE VWin32Vxd,
    IN      TCHAR  Drive,
    OUT     PINT LockStatus
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    *LockStatus = 0;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440D;

    //
    // bx = 1-based drive number
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // cx = 0x86C (get lock flag state)
    //
    RegistersIn.reg_ECX = 0x86C;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if (b) {
        if (RegistersOut.reg_Flags & 1) {
            b = FALSE;
        } else {
            *LockStatus = RegistersOut.reg_EAX;
        }
    }

    return b;
}

#endif

typedef HANDLE(WINAPI *OPENTHREAD)(DWORD, BOOL, DWORD);


BOOL
pMakeThreadExclusive (
    BOOL Lock
    )
{
    HANDLE h;
    THREADENTRY32 e;
    DWORD thisThread;
    HANDLE threadHandle;
    OPENTHREAD openThreadFn;
    HMODULE lib;
    BOOL result = FALSE;

    lib = LoadLibrary (TEXT("kernel32.dll"));
    if (!lib) {
        goto c0;
    }

    openThreadFn = (OPENTHREAD) GetProcAddress (lib, "OpenThread");
    if (!openThreadFn) {
        //
        // Must be Win98 or Win98SE -- change thread priority as workaround
        //

        if (Lock) {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            Sleep (0);
        } else {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        }

        goto c1;
    }

    thisThread = GetCurrentThreadId();

    h = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);
    if (h == INVALID_HANDLE_VALUE) {
        goto c1;
    }

    e.dwSize = sizeof (e);

    if (Thread32First (h, &e)) {
        do {
            if (e.th32ThreadID != thisThread) {
                threadHandle = openThreadFn (THREAD_SUSPEND_RESUME, FALSE, e.th32ThreadID);
                if (threadHandle) {
                    if (Lock) {
                        SuspendThread (threadHandle);
                    } else {
                        ResumeThread (threadHandle);
                    }

                    CloseHandle (threadHandle);
                }
            }
        } while (Thread32Next (h, &e));
    }

    CloseHandle (h);
    result = TRUE;

c1:
    FreeLibrary (lib);

c0:
    return result;

}

#if defined(_X86_)

BOOL
ReadOrWriteSectorsWin9xOriginal(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    earlier than OSR2. Uses int25/26.

    This routine will fail on Windows NT.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = (DWORD)(TOUPPER(Drive) - TEXT('A'));
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            Write ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9xOsr2(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    OSR2 or later. Uses the new int21 function 7305 (Ext_ABSDiskReadWrite).

    This routine will fail on Windows NT and earlier versions of Windows 95.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = 0x7305;
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;
    RegistersIn.reg_EDX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_ESI = Write ? 1 : 0;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_DRIVEINFO,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
LockOrUnlockVolumeWin9x(
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    IN UINT   Level,
    IN BOOL   Lock
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    BOOL Pass;

    Pass = 0;

retry:
    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440d;

    //
    // bl = 1-based drive number
    // bh = lock level
    //
    RegistersIn.reg_EBX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_EBX |= (Level << 8);

    //
    // cl = lock or unlock volume code
    // ch = categoey, 8 on original Win95, 0x48 on OSR2
    //
    RegistersIn.reg_ECX = Lock ? 0x4a : 0x6a;
    RegistersIn.reg_ECX |= ((ISOSR2() && !Pass) ? 0x4800 : 0x800);

    //
    // dx = permissions
    //
    // bit 0 controls write operations (0 = disallowed)
    // bit 1 controls read operations  (0 = allowed)
    //
    RegistersIn.reg_EDX = 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    //
    // If OSR2, try form of call with 8 in ch instead of 48.
    //
    if(!b && ISOSR2() && !Pass) {
        Pass = 1;
        goto retry;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9x(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95.
    This routine will fail on Windows NT. After opening the VWIN32
    VxD, the routine determines whether to use the original algorithm
    or the OSR2 algorithm, and calls the appropriate worker routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set to something meaningful.

--*/

{
    HANDLE hVxd;
    BOOL b;
    DWORD d;
    INT level;
    INT retry = 100;

    //
    // This thread must be the exclusive thread in our process
    //

    pMakeThreadExclusive (TRUE);

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                Write ? GENERIC_WRITE : GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    //
    // Take out locks. We'll be as unrestrictive as possible.
    // The locking stuff is really funky. You have to pass in all kinds of
    // different parameters in OSR2 for reasons unknown. Also the
    // permissions bits are strangely encoded.
    //
    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,1,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c1;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,2,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c2;
    }

    //
    // Try to get the level 3 lock. Retry if something happened while
    // getting the lock. Fail after too many retries.
    //

    do {

        if(!LockOrUnlockVolumeWin9x(hVxd,Drive,3,TRUE)) {
            d = ERROR_SHARING_VIOLATION;
            b = FALSE;
            goto c3;
        }

        if (!pGetWin9xLockFlagState (hVxd, Drive, &level)) {
            // unexpected -- INT 21h call failed
            break;
        }

        if (!level) {
            // We successfully got a clean level 3 lock
            break;
        }

        LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
        retry--;

    } while (retry);

    if (!retry) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c3;
    }

    //
    // Go do it.
    //
    b = ISOSR2()
      ? ReadOrWriteSectorsWin9xOsr2(hVxd,Drive,StartSector,SectorCount,Buffer,Write)
      : ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);

    //
    // If it failed, and OSR2 routine is being used, fall back to Win95 API.  This is a workaround
    // for Compaq because they ship OSR2 without the new OSR2 sector API support!
    //

    if (!b && ISOSR2()) {
        b = ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
    }

    d = GetLastError();

    LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
c3:
    LockOrUnlockVolumeWin9x(hVxd,Drive,2,FALSE);
c2:
    LockOrUnlockVolumeWin9x(hVxd,Drive,1,FALSE);
c1:
    CloseHandle(hVxd);
c0:

    //
    // Resume all threads
    //

    pMakeThreadExclusive (FALSE);

    SetLastError(d);
    return(b);
}

#endif

BOOL
ReadOrWriteSectorsWinNt(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONGLONG Offset;
    LONG OffsetHigh;
    DWORD d;

#if defined(_X86_)

    if (IsNEC98() && (StartSector == 0) && (SectorCount == 1)){
	    return(NEC98_SpecialReadOrWriteNT(Drive, Buffer, Write));
    }

#endif

    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    Offset = (LONGLONG)StartSector * (LONGLONG)SectorSize;
    OffsetHigh = (LONG)(Offset >> 32);

    //
    // We're passing in a 64-bit offset so we have to check last error
    // to distinguish the error case.
    //
    if((SetFilePointer(h,(DWORD)Offset,&OffsetHigh,FILE_BEGIN) == 0xffffffff)
    && (GetLastError() != NO_ERROR)) {

        d = GetLastError();
        b = FALSE;
        goto c1;
    }

    b = Write
      ? WriteFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL)
      : ReadFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL);

    d = GetLastError();

c1:
    CloseHandle(h);
c0:
    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectors(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk. Allocates a properly
    aligned buffer and decides whether to call NT- or Win9x-specific
    i/o routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. There are no alignment requirements on ths buffer.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    Last error is undisturbed from the operation that caused any failure.

--*/

{
    LPBYTE AlignedBuffer;
    LPBYTE p;
    BOOL b;
    DWORD_PTR d;

    //
    // Allocate a buffer we will align on a sector boundary.
    //
    if(AlignedBuffer = MALLOC((SectorCount * SectorSize) + (SectorSize - 1))) {

        if(d = (DWORD_PTR)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD_PTR)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }

        if(Write) {
            CopyMemory(p,Buffer,SectorCount*SectorSize);
        }

#if defined(_X86_)

        b = ISNT()
          ? ReadOrWriteSectorsWinNt(Drive,StartSector,SectorCount,SectorSize,p,Write)
          : ReadOrWriteSectorsWin9x(Drive,StartSector,SectorCount,p,Write);

#elif defined(_AMD64_)

        b = ReadOrWriteSectorsWinNt(Drive,StartSector,SectorCount,SectorSize,p,Write);

#else
#error "Invalid Architeture"
#endif

        d = GetLastError();

        if(b && !Write) {
            CopyMemory(Buffer,p,SectorCount*SectorSize);
        }

        FREE(AlignedBuffer);

    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError((DWORD)d);
    return(b);
}


BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    )

/*++

Routine Description:

    Read a set of disk sectors off a disk device.

Arguments:

    Drive - supplies drive letter of device to be read from.

    StartSector - supplies logical sector number of first sector to be read.

    SectorCount - supplies number of sectors to be read.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from.

    Buffer - if successful, receives data from the disk. There are no
        alignment requirements on ths buffer.

Return Value:

    Boolean value indicating whether the disk was read successfully.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,FALSE));
}


BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    )

/*++

Routine Description:

    Write data to a set of disk sectors.

Arguments:

    Drive - supplies drive letter of device to be written to.

    StartSector - supplies logical sector number of first sector to be written.

    SectorCount - supplies number of sectors to be written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be written to.

    Buffer - supplies data to be written. There are no alignment requirements
        on ths buffer.

Return Value:

    Boolean value indicating whether the disk was successfully written.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,TRUE));
}


MEDIA_TYPE
GetMediaTypeNt(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS NT.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the largest media that the device driver indicates the
    drive can support.

    LastError is not set or preserved.

--*/

{
    TCHAR DeviceName[7];
    HANDLE h;
    BOOL b;
    BYTE Buffer[5000];
    DWORD Size;
    DWORD d;
    UINT u;
    PDISK_GEOMETRY Geometry;
    MEDIA_TYPE MediaTypeOrder[] = { FixedMedia,             // Fixed hard disk media
                                    RemovableMedia,         // Removable media other than floppy
                                    F3_120M_512,            // 3.5", 120M Floppy
                                    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
                                    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
                                    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
                                    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
                                    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
                                    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
                                    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
                                    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
                                    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
                                    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
                                    Unknown,                // Format is unknown
                                    -1
                                  };


    //
    // We don't return drive information for NT
    //
    if (DriveInfo) {
        memset(DriveInfo, 0, sizeof(WINNT32_DRIVE_INFORMATION));
    }

    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);

    h = CreateFile(
            DeviceName,
            FILE_READ_ATTRIBUTES,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_MEDIA_TYPES,
            NULL,
            0,
            Buffer,
            sizeof(Buffer),
            &Size,
            NULL
            );

    CloseHandle(h);

    if(!b) {
        return(Unknown);
    }

    Geometry = (PDISK_GEOMETRY)Buffer;

    //
    // Inefficient, but it works.
    //
    for(u=0; MediaTypeOrder[u] != -1; u++) {
        for(d=0; d<Size/sizeof(DISK_GEOMETRY); d++) {
            if(Geometry[d].MediaType == MediaTypeOrder[u]) {
                return(Geometry[d].MediaType);
            }
        }
    }

    //
    // We don't know what it is; assume it's some hot new type.
    //
    return(Size ? Geometry[0].MediaType : Unknown);
}

#if defined(_X86_)

MEDIA_TYPE
GetMediaTypeWin9x(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS 9x.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the device type in the recommended BPB returned by
    the device driver for the drive.

    LastError is not set or preserved.

--*/

{
    HANDLE hVxd;
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    MEDIA_TYPE type;

    #include <pshpack1.h>
    struct {
        BYTE SpecialFunctions;
        BYTE DeviceType;
        WORD DeviceAttributes;
        WORD CylinderCount;
        BYTE MediaType;
        WORD BytesPerSector;
        BYTE SectorsPerCluster;
        WORD ReservedSectors;
        BYTE FatCount;
        WORD RootDirEntries;
        WORD SectorCount;
        BYTE MediaDescriptor;
        WORD SectorsPerFat;
        WORD SectorsPerTrack;
        WORD Heads;
        DWORD HiddenSectors;
        DWORD LargeSectorCount;
    } DeviceParams;
    #include <poppack.h>

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    memset(&DeviceParams, 0, sizeof(DeviceParams));

    //
    // Set up registers for IOCTL call.
    //
    RegistersIn.reg_EAX = 0x440d;                   // IOCTL
    RegistersIn.reg_EBX = (Drive - TEXT('A')) + 1;  // 1-based drive in bl
    RegistersIn.reg_ECX = 0x860;                    // category = 8, func = get device params
    RegistersIn.reg_EDX = (DWORD)&DeviceParams;

    DeviceParams.SpecialFunctions = 0;

    b = DeviceIoControl(
            hVxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    CloseHandle(hVxd);

    if(!b && !(RegistersOut.reg_Flags & 1)) {
        return(Unknown);
    }

    if (DriveInfo) {
        memset(DriveInfo, 0, sizeof(WINNT32_DRIVE_INFORMATION));

        DriveInfo->CylinderCount = (DWORD)(DeviceParams.CylinderCount);
        DriveInfo->HeadCount = (DWORD)(DeviceParams.Heads);
        DriveInfo->SectorsPerTrack = (DWORD)(DeviceParams.SectorsPerTrack);
        DriveInfo->BytesPerSector = DeviceParams.BytesPerSector;
        DriveInfo->SectorCount = (ULONGLONG)((DriveInfo->CylinderCount *
                                                DriveInfo->HeadCount * DriveInfo->SectorsPerTrack));
    }

    switch(DeviceParams.DeviceType) {
    case 0:
        type = F5_360_512;      // close enough
        break;

    case 1:
        type = F5_1Pt2_512;
        break;

    case 2:
        type = F3_720_512;
        break;

    case 5:
        type = FixedMedia;
        break;

    case 7:
        type = F3_1Pt44_512;
        break;

    case 8:
        type = RemovableMedia;
        break;

    case 9:
        type = F3_2Pt88_512;
        break;

    default:
        type = Unknown;
        break;
    }

    return(type);
}

#endif

MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )
{

#if defined(_X86_)

    return(ISNT() ? GetMediaTypeNt(Drive, DriveInfo) : GetMediaTypeWin9x(Drive, DriveInfo));

#elif defined(_AMD64_)

    return GetMediaTypeNt(Drive, DriveInfo);

#else
#error "Invalid Architecture"
#endif

}

#if defined(_X86_)

BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )
/*++

Routine Description:

    NEC98 specialn routine to boot sctor read or write sectors on a disk
    under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONG OffsetHigh = 0;
    DWORD d;
    LPBYTE AlignedBuffer;
    LPBYTE p;

    //
    // Form root path
    //
    DrivePath[0] = Drive;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare);
    if(AlignedBuffer = MALLOC(SectorSize + SectorSize - 1)) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }
    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
	    goto c0;
    }
    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? (GENERIC_WRITE | GENERIC_READ) : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c1;
    }
    if (b = ReadFile(h, p, SectorSize, &BytesXferred, NULL)){
    	if (Write){
    	    CopyMemory(p, Buffer, 512);
    	    SetFilePointer(h,(DWORD)0, &OffsetHigh,FILE_BEGIN);
    	    b = WriteFile(h, p, SectorSize, &BytesXferred,NULL);
    	} else { // read
    	    CopyMemory(Buffer, p, 512);
    	}
    }
    d = GetLastError();

    CloseHandle(h);
c1:
    FREE(AlignedBuffer);
c0:
    SetLastError(d);
    return(b);
}

//
// Maximum partition size addressable by regular INT13
// Max capacity = sector size * cylinders (10 bits) * heads (8 bits) *
//                sectors / track (6 bits)
//
#define MAX_INT13_PARTITION_CAPACITY  8455716864L   //  (512 * 1024 * 256 * 63) = 7.8GB
#define FAT32_BPB_HEADS_FIELD_OFFSET  0x1A
#define FAT32_BPB_SECTORSPERTRACK_FIELD_OFFSET  0x18

typedef BOOL (*PGET_DISK_FREE_SPACE_EX) (
    LPCTSTR,
    PULONGLONG,
    PULONGLONG,
    PULONGLONG
    );


BOOL
GetDriveSize9x(
    TCHAR DriveLetter,
    PULONGLONG DriveSize
    )
/*++

Routine Description:

    Gets the total size of the given drive.

    NOTE : First tries GetDriveFreeSpaceEx(...) if available and if
        unsuccessful, tries to compute drive size using INT21h.

Arguments:

    DriveLetter :   Drive letter.

    DriveSize : Recieves the drive size in bytes.

Return Value:

    TRUE, if drive size was determined otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

    if (DriveSize && !ISNT()) {
        ULONGLONG TotalDriveSize = 0;

        if (ISOSR2()) {
            HMODULE Kernel32Handle = GetModuleHandle(TEXT("kernel32.dll"));

            if (Kernel32Handle) {
                PGET_DISK_FREE_SPACE_EX GetDiskFreeSpaceExPtr;

                GetDiskFreeSpaceExPtr = (PGET_DISK_FREE_SPACE_EX)
                        GetProcAddress(Kernel32Handle, "GetDiskFreeSpaceEx");

                if (GetDiskFreeSpaceExPtr) {
                    TCHAR   DriveName[MAX_PATH];
                    ULONGLONG FreeBytes = 0, TotalSize = 0, ActualFreeBytes = 0;

                    DriveName[0] = DriveLetter;
                    DriveName[1] = TEXT(':');
                    DriveName[2] = TEXT('\\');
                    DriveName[3] = 0;

                    Result = GetDiskFreeSpaceExPtr(DriveName,
                                &FreeBytes,
                                &TotalSize,
                                &ActualFreeBytes);

                    if (Result) {
                        TotalDriveSize = TotalSize;
                    }
                }
            }
        }

        if (!Result) {
            WINNT32_DRIVE_INFORMATION   DriveInfo = {0};

            GetMediaType(DriveLetter, &DriveInfo);

            if (DriveInfo.SectorCount) {
                TotalDriveSize = DriveInfo.SectorCount * DriveInfo.BytesPerSector;
                Result = TRUE;
            }
        }

        if (Result) {
            *DriveSize = TotalDriveSize;
        }
    }

    return Result;
}

#endif

BOOL
PatchBootCode(
    IN      WINNT32_SYSPART_FILESYSTEM  FileSystem,
    IN      TCHAR   DriveLetter,
    IN OUT  PUCHAR  BootCode,
    IN      DWORD   BootCodeSize
    )
/*++

Routine Description:

    Patches the boot code if there is any inconsistent data
    with the correct data

    NOTE : Currently we update only FAT32 BPB for invalid head
           count.

Arguments:

    FileSystem  :   File system type to look into the buffer

    DriveLetter :   Drive letter.

    BootCode    :   The actual boot code

    BootCodeSize:   Size of the boot code in bytes

Return Value:

    TRUE, if boot code was patched successfully, otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

#if defined(_X86_)

    if (BootCode && (FileSystem != Winnt32FsUnknown)) {
        switch (FileSystem) {
            case Winnt32FsFat32:
                if (!ISNT() && (BootCodeSize >= (FAT32_BPB_HEADS_FIELD_OFFSET + sizeof(WORD)))) {
                    ULONGLONG DriveSize = 0;
                    PWORD NumberOfHeads = (PWORD)(BootCode + FAT32_BPB_HEADS_FIELD_OFFSET);
                    PWORD SectorsPerTrack = (PWORD)(BootCode + FAT32_BPB_SECTORSPERTRACK_FIELD_OFFSET);
                    TCHAR Buffer[MAX_PATH * 2];

                    Result = GetDriveSize9x(DriveLetter, &DriveSize);

                    if (Result) {
                        WINNT32_DRIVE_INFORMATION DriveInfo = {0};

                        //
                        // Get the drive information
                        //
                        GetMediaType(DriveLetter, &DriveInfo);

                        //
                        // dump the drive information
                        //
                        if (DriveInfo.BytesPerSector) {
                            _stprintf(Buffer,
                                TEXT("Drive Information (INT 21H):\r\nCylinders:%d,Heads:%d,Sectors/Track:%d,Sectors:%I64d,Bytes/Sector:%d"),
                                DriveInfo.CylinderCount,
                                DriveInfo.HeadCount,
                                DriveInfo.SectorsPerTrack,
                                DriveInfo.SectorCount,
                                DriveInfo.BytesPerSector);

                            DebugLog (Winnt32LogInformation, Buffer, 0);

                            //
                            // The heads value better match what we got from GetMediaType(...)
                            // If not, we patch it to the correct one.
                            //
                            if (DriveInfo.HeadCount && (((DWORD)(*NumberOfHeads)) != DriveInfo.HeadCount)) {

                                _stprintf(Buffer,
                                    TEXT("Drive Information (BPB): Size=%I64u, Heads=%u, Sectors/Track=%u"),
                                    DriveSize,
                                    (*NumberOfHeads),
                                    (*SectorsPerTrack));

                                DebugLog(Winnt32LogInformation,
                                    TEXT("PatchBootCode: Existing %1"),
                                    0,
                                    Buffer);

                                //
                                // update the heads value
                                //
                                *NumberOfHeads = (WORD)(DriveInfo.HeadCount);

                                _stprintf(Buffer,
                                    TEXT("Drive Information (BPB): Size=%I64u, Heads=%u, Sectors/Track=%u"),
                                    DriveSize,
                                    (*NumberOfHeads),
                                    (*SectorsPerTrack));

                                DebugLog(Winnt32LogInformation,
                                    TEXT("PatchBootCode: New %1"),
                                    0,
                                    Buffer);
                            }
                        } else {
                            DebugLog(Winnt32LogError,
                                TEXT("PatchBootCode:Failed to get the drive information"),
                                0);
                        }
                    } else {
                        DebugLog(Winnt32LogError,
                            TEXT("PatchBootCode:Failed to get the drive size"),
                            0);
                    }
                }

                break;

            default :
                break;
        }
    }

#endif

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_APPTITLE                    1
#define IDS_LARGEFONTSIZE               2
#define IDS_LARGEFONTNAME               3
#define IDS_MULTIPLE                    4
#define IDS_EXAMINE_SOURCE              5
#define IDS_LOADINGINF                  6
#define IDS_BUILDING_COPY_LIST          7
#define IDS_CHECKING_SPACE              8
#define IDS_FIND_NT_FILES               9
#define IDS_INSPECTING                  10
#define IDS_REMOVING_OLD_TEMPFILES      11
#define IDS_MICROSOFT_WINDOWS           12
#define IDS_REBOOT_MESSAGE              13
#define IDS_APPTITLE_ASRV               14
#define IDS_APPTITLE_DAT                15
#define IDS_APPTITLE_SRV                16
#define IDS_APPTITLE_WKS                17
#define IDS_BOOTFLOP_WKS                18
#define IDS_BOOTFLOP_SRV                19
#define IDS_FLOPPY_N_WKS                20
#define IDS_FLOPPY_N_SRV                21
#define IDS_SETTING_NVRAM               22
#define IDS_BOOTMSG_FAT_NTLDR_MISSING   23
#define IDS_BOOTMSG_FAT_DISKERROR       24
#define IDS_BOOTMSG_FAT_PRESSKEY        25
#define IDS_COMMENT                     26
#define IDS_VISIBLE_NARRATOR_CONTROL    27
#define IDS_RECOVERY_CONSOLE            28
#define IDS_APPTITLE_BLADE              29
#define IDS_CANCEL_SETUP                30
#define IDS_WINPE_INSTALLATION          31
#define IDS_APPTITLE_SBS                32
#define IDB_WELCOME                     101
#define IDD_UPGRADE                     102
#define IDB_ARROW                       102
#define IDD_DONE0                       103
#define IDB_CHECK                       103
#define IDD_OPTIONS                     104
#define IDB_WIZARD1                     105
#define IDB_OEM                         105
#define IDD_ADVANCED                    106
#define IDB_CDKEY                       106
#define IDD_WORKING1                    107
#define IDB_HEADER                      108
#define IDA_COMP_MAGNIFY                109
#define IDD_COPYING                     110
#define IDA_FILECOPY                    111
#define IDD_DONE                        112
#define IDD_COPYERROR                   113
#define IDD_CLEANING                    114
#define IDD_NOTDONE                     115
#define IDB_WATERMARK                   116
#define IDB_TEST                        117
#define IDD_FLOPPY                      118
#define IDB_WATERMARK16                 119
#define IDB_WATERMARK256                120
#define IDI_ACCESS                      121
#define IDI_GLOBE                       122
#define IDI_SETUP                       123
#define IDD_ADVANCED2                   124
#define IDD_CLEANING2                   125
#define IDD_COPYING2                    126
#define IDD_DONE2                       127
#define IDD_FLOPPY2                     128
#define IDD_NOTDONE2                    129
#define IDD_OPTIONS2                    130
#define IDD_WELCOME2                    131
#define IDD_WORKING12                   132
#define IDD_LANGUAGE                    133
#define IDD_WELCOME                     134
#define IDD_ACCESSIBILITY               135
#define IDD_COMPATIBILITY               136
#define IDD_COMPATIBILITY_TEXT          137
#define IDI_WATCH_OUT                   138
#define IDI_ERROR_ICON                  139
#define IDI_FLAGS                       140
#define IDR_SHUTDOWN                    140
#define IDI_ADVANCED                    141
#define IDR_NOSHUTDOWN                  141
#define IDD_EULA                        143
#define IDD_PID_CD                      144
#define IDD_PID_OEM                     145
#define IDD_NTFS_CONVERT                146
#define IDI_HDISK                       147
#define IDD_ADVANCED3                   148
#define IDI_INSTALL                     148
#define IDD_DISKSPACE                   149
#define IDD_SRVCOMP                     150
#define IDB_HEARDER2                    151
#define IDA_COMPGLOB                    152
#define IDD_DYNAMICSETUP                153
#define IDD_DYNAMICSETUP2               154
#define IDD_DYNAMICSETUP3               155
#define IDD_DYNAMICSETUP_MANUAL         156
#define IDD_EMPTY                       157
#define IDD_PID_SELECT                  158
#define IDI_NOTE                        159
#define IDT_TITLE                       1000
#define IDC_ANIMATE                     1000
#define IDC_CHECK1                      1001
#define IDC_USEFLOPPIES                 1001
#define IDC_FAREAST_LANG                1001
#define IDC_EDIT1                       1002
#define IDC_INSTALL_DIR                 1002
#define IDC_DISKDIAG                    1002
#define IDC_SOURCE                      1003
#define IDB_ADVANCED                    1004
#define IDC_CONVERT                     1004
#define IDC_HEADLESS_PORT               1004
#define IDC_NOUPGRADE                   1005
#define IDC_UPGRADE                     1005
#define IDB_BROWSE                      1005
#define IDB_ACCESSIBILITY               1006
#define IDC_MAKELOCALSOURCEFROMCD       1007
#define IDC_SYSPARTDRIVE                1008
#define IDC_KEYBOARD                    1008
#define IDT_SYSPARTTEXT                 1009
#define IDC_VOICE                       1009
#define IDT_WORKING                     1010
#define IDC_READER                      1010
#define IDC_CHOOSE_INSTALLPART          1010
#define IDC_SOURCE2                     1011
#define IDB_BROWSE2                     1012
#define IDT_EDIT1                       1012
#define IDT_EULA_LIC_TEXT               1012
#define IDC_BOOT16                      1012
#define IDC_ENABLE_HEADLESS             1012
#define IDC_PROGRESS                    1013
#define IDT_BOOT16TEXT                  1013
#define IDT_HEADLESS_PORT               1013
#define IDT_SOURCE1                     1014
#define IDT_SOURCE2                     1015
#define IDT_SOURCE3                     1016
#define IDT_SOURCE4                     1017
#define IDT_SOURCE5                     1018
#define IDT_SOURCE6                     1019
#define IDT_SOURCE7                     1020
#define IDT_SOURCE8                     1021
#define IDT_SOURCE9                     1022
#define IDT_SIZE2                       1022
#define IDS_DETAILS                     1023
#define IDT_ERROR_TEXT                  1024
#define IDT_ELAPSED_TIME2               1024
#define IDC_HEADER_BOTTOM               1025
#define IDC_MAGNIFIER                   1027
#define IDT_SUPERTITLE                  1028
#define IDT_SUBTITLE                    1029
#define IDC_BUTTON1                     1030
#define IDB_LANGUAGE                    1030
#define IDT_EDIT_PID1                   1030
#define IDT_DETAIL_TEXT                 1030
#define IDC_LIST1                       1031
#define IDC_LIST                        1031
#define IDT_EDIT_PID2                   1031
#define IDC_ROOT_LIST                   1032
#define IDT_EDIT_PID3                   1032
#define IDC_DETAILS                     1033
#define IDT_EDIT_PID4                   1033
#define IDC_TEXT                        1034
#define IDT_EDIT_PID5                   1034
#define IDC_DIALOG_ICON                 1035
#define IDC_NOSHUTDOWN                  1035
#define IDC_RADIO1                      1035
#define IDC_BOOT16_1                    1035
#define IDC_INTRO_TEXT                  1036
#define IDC_BOOT16_2                    1036
#define IDC_HAVE_DISK                   1037
#define IDC_CHECK2                      1037
#define IDC_BOOT16_3                    1037
#define IDS_SERVICE_STOP                1038
#define IDC_RADIO2                      1038
#define IDS_COMPAT_ERR                  1038
#define IDS_SERVICE_DISABLE             1039
#define IDC_COMBO1                      1039
#define IDS_COMPAT_WRN                  1039
#define IDC_ACCESS_ICON                 1040
#define IDS_NO_REBOOT                   1040
#define IDC_SAVE_AS                     1041
#define IDC_PROGRESS1                   1041
#define IDS_COMPAT_ERR_WRN              1041
#define IDS_RISCBootString              1042
#define IDC_SCROLLBAR1                  1043
#define IDS_COMPAT_NOPROBLEMS           1043
#define IDT_DISKMSG0                    1044
#define IDS_COMPAT_PENDING_REBOOT       1044
#define IDT_DISKMSG1                    1045
#define IDS_COMPAT_REPORTHEADER         1045
#define IDT_DISKMSG2                    1046
#define IDNORESTART                     1047
#define IDC_READER_TEXT                 1048
#if 0
#define IDS_SRV_APP_DIRECTORY           1049
#define IDS_PRO_APP_DIRECTORY           1050
#endif
#define IDC_DIRECTORY                   1051
#define IDS_FILE_MASK_TYPES             1051
#define IDS_DEFAULT_COMPATIBILITY_REPORT_NAME 1052
#define IDT_DYNSETUP_DIALING            1052
#define IDT_INSTALLTYPE                 1052
#define IDT_DYNSETUP_TIME               1053
#define IDS_APPTITLE_CHECKUPGRADE       1053
#define IDC_IF_EXPRESS                  1053
#define IDC_INSTALLCOMBO                1053
#define IDS_COMPAT_CHECKUPGRADE         1054
#define IDR_DYNSETUP_RETRY              1054
#define IDT_DYNSETUP_DOWNLOADING        1054
#define IDR_DYNSETUP_MANUAL             1055
#define IDS_SIZE_GBYTES                 1055
#define IDC_EXPRESS                     1055
#define IDT_DYNSETUP_PROCESSING         1055
#define IDS_SIZE_MBYTES                 1056
#define IDR_DYNSETUP_SKIP               1056
#define IDC_ADVANCED                    1056
#define IDS_SIZE_KBYTES                 1057
#define IDC_IF_ADVANCED                 1057
#define IDC_NOTE_TEXT_CLEAN             1057
#define IDS_SIZE_BYTES                  1058
#define IDC_COPY_BMP                    1058
#define IDC_NOTE_CLEAN                  1058
#define IDS_COMPAT_DIVIDER              1059
#define IDC_COPY_BMP2                   1059
#define IDS_COMPAT_STRT_MENU            1060
#define IDC_COPY_BMP3                   1060
#define IDS_BB_COPYING                  1061
#define IDS_TIMEESTIMATE_UNKNOWN        1062
#define IDS_ESC_TOCANCEL                1063
#define IDS_TIMEESTIMATE_MINUTES        1064
#define IDS_TIMEESTIMATE_LESSTHENONEMINUTE 1065
#define IDS_ESC_TOCANCEL_DOWNLOAD       1066
#define IDS_RESTART_SETUP               1067
#define IDB_HEADER2                     1090
#define IDT_LABEL1                      2000
#define IDT_LABEL2                      2001
#define IDT_LABEL3                      2002
#define IDT_LABEL4                      2003
#define IDT_LABEL5                      2004
#define IDT_LABEL6                      2005
#define IDT_LABEL7                      2006
#define IDT_LABEL8                      2007
#define IDT_LABEL9                      2008
#define IDT_SIZE                        2008
#define IDC_UPGRADE_OR_INSTALL          2009
#define IDT_ELAPSED_TIME                2009
#define IDC_IF_UPGRADE                  2010
#define IDC_IF_NEW_COPY                 2011
#define IDC_WHAT_TO_DO                  2012
#define IDS_CERTSRV_UPGRADE_WARNING     2013
#define IDS_INSTALLTYPE_EXPRESS         2014
#define IDS_INSTALLTYPE_CUSTOM          2015
#define IDS_INSTALL_EXPRESS             2016
#define IDS_INSTALL_CUSTOM              2017
#define IDS_PROCESSOR_UPGRADE_WARNING   2018
#define IDS_BB_REBOOT_TXT               2019
#define IDB_SYSPARSE                    2020
#define IDD_SYSPARSE                    2021
#define IDC_BITMAP                      2022
#define IDD_RESTART                     2022
#define IDD_DYNAMICSETUP4               2023
#define IDD_DYNAMICSETUP5               2024
#define IDS_INTEL_PROCESSOR_PTE_WARNING  2025
#define IDS_DESCRIPTION_SERVICEPACKS    2026
#define IDS_SHUTDOWN_REMOTE             2711
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  2712
#define IDS_SHUTDOWN_OTHERUSERS         2713
#define IDS_RESTART_OTHERUSERS          2714
#define IDC_NOTE_TEXT_UPG               2715
#define IDC_NOTE_UPG                    2716
#define IDS_ESC_TOCANCEL_REBOOT         2717
#define IDS_DRWATSON_LCID               2718
#define IDS_DRWATSON_ERRORTEXT          2719
#define IDD_REPORT_HELP                 3000
#define IDI_CHECKMARK                   3001
#define IDC_CATEGORY                    3002
#define IDC_TEXT1                       3003
#define IDC_CRITICAL_ISSUES             3004
#define IDC_ALL_ISSUES                  3005
#define IDC_NO_REPORT                   3006
#define IDC_NAMES                       3007
#define IDC_TEXT2                       3007
#define IDC_TEXT3                       3008
#define IDC_STATIC                      -1
#define ID_RETRY_MESSAGE                65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        160
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1059
#define _APS_NEXT_SYMED_VALUE           142
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\security.c ===
#include "precomp.h"
#pragma hdrstop


#ifdef UNICODE

BOOL
MyCheckTokenMembership (
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
/*++

Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

    It was copied from advapi32\security.c

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


--*/
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    NTSTATUS AccessStatus = 0;
    PACL Dacl = NULL;

#define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,              // don't open as self
                    &EffectiveToken
                    );

        //
        // if there is no thread token, try the process token
        //

        if (Status == STATUS_NO_TOKEN)
        {
            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &ProcessToken
                        );
            //
            // If we have a process token, we need to convert it to an
            // impersonation token
            //

            if (NT_SUCCESS(Status))
            {
                BOOL Result;
                Result = DuplicateToken(
                            ProcessToken,
                            SecurityImpersonation,
                            &EffectiveToken
                            );

                CloseHandle(ProcessToken);
                if (!Result)
                {
                    return(FALSE);
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * RtlLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    RtlCreateSecurityDescriptor(
        SecDesc,
        SECURITY_DESCRIPTOR_REVISION
        );

    //
    // Fill in fields of security descriptor
    //

    RtlSetOwnerSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );
    RtlSetGroupSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );

    Status = RtlCreateAcl(
                Dacl,
                SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                MEMBER_ACCESS,
                SidToCheck
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                SecDesc,
                TRUE,   // DACL present
                Dacl,
                FALSE   // not defaulted
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtAccessCheck(
                SecDesc,
                EffectiveToken,
                MEMBER_ACCESS,
                &GenericMapping,
                PrivilegeSet,
                &PrivilegeSetLength,
                &AccessGranted,
                &AccessStatus
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //

    if ((AccessStatus == STATUS_SUCCESS) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }




Cleanup:
    if (!ARGUMENT_PRESENT(TokenHandle) && (EffectiveToken != NULL))
    {
        (VOID) NtClose(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    if (!NT_SUCCESS(Status))
    {
        SetLastError (RtlNtStatusToDosError (Status));
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

#endif

BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
#ifdef UNICODE

    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // On non-NT platforms the user is administrator.
    //
    if(!ISNT()) {
        return(TRUE);
    }

    b = AllocateAndInitializeSid (
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

    if (b) {
        //
        // See if the user has the administrators group.
        //
        if (!MyCheckTokenMembership (NULL, AdministratorsGroup, &b)) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);
    }

    return(b);

#else

    return TRUE;

#endif
}



BOOL
DoesUserHavePrivilege(
    PCTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // On non-NT platforms the user has all privileges
    //
    if(!ISNT()) {
        return(TRUE);
    }

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if(!memcmp(&Luid,&Privileges->Privileges[i].Luid,sizeof(LUID))) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        LocalFree((HLOCAL)Privileges);
    }

    CloseHandle(Token);

    return(b);
}


BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // On non-NT platforms the user already has all privileges
    //
    if(!ISNT()) {
        return(TRUE);
    }

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\rsrcutil.c ===
#include "precomp.h"
#pragma hdrstop


//
// the following is not in the SDK
//
#include <pshpack2.h>
#include <poppack.h>
#include <winuserp.h>


//
// When Winnt32.exe is launched over a network, these two parameters have valid
// values and need to be taken into consideration before displaying any dialog box
//

extern HWND Winnt32Dlg;
extern HANDLE WinNT32StubEvent;

PCTSTR
GetStringResource (
    IN UINT Id
    )
{
    LONG rc;
    PCTSTR MsgBuf;

    if (HIWORD (Id)) {
        // From string
        rc = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|
                    FORMAT_MESSAGE_ARGUMENT_ARRAY|
                    FORMAT_MESSAGE_FROM_STRING,
                UIntToPtr( Id ),
                0,
                0,
                (PVOID) &MsgBuf,
                0,
                NULL
                );
    }
    else {
        // From resource
        rc = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|
                    FORMAT_MESSAGE_ARGUMENT_ARRAY|
                    FORMAT_MESSAGE_FROM_HMODULE,
                (PVOID) hInst,
                (DWORD) Id,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                NULL
                );
    }

    if (rc == 0) {
        return NULL;
    }

    return MsgBuf;
}


VOID
FreeStringResource (
    IN PCTSTR String
    )
{
    if (String) {
        LocalFree ((HLOCAL) String);
    }
}


VOID
SaveTextForSMS(
    IN PCTSTR Buffer
    )
{
    CHAR    AnsiBuffer[5000];


    if(LastMessage) {
        FREE( LastMessage );
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        Buffer,
        -1,
        AnsiBuffer,
        sizeof(AnsiBuffer),
        NULL,
        NULL
        );
    if(LastMessage = MALLOC(strlen(AnsiBuffer)+1)) {
        strcpy( LastMessage, AnsiBuffer);
    }
#else
    LastMessage = DupString( Buffer );
#endif
}


VOID
SaveMessageForSMS(
    IN DWORD MessageId,
    ...
    )
{
    va_list arglist;
    TCHAR   Buffer[5000];


    va_start(arglist,MessageId);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        &arglist
        );

    SaveTextForSMS(Buffer);

    va_end(arglist);
}


int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR   Caption[512];
    TCHAR   Buffer[5000];
    HWND    Parent;


    if(!LoadString(hInst,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        Args
        );

    SaveTextForSMS(Buffer);

    //
    // In batch mode, we don't want to wait on the user.
    //
    if(BatchMode) {
        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // Force ourselves into the foreground manually to guarantee that we get
    // a chance to set our palette. Otherwise the message box gets the
    // palette messages and color in our background bitmap can get hosed.
    // We assume the parent is a wizard page.
    //
    if(Window && IsWindow(Window)) {
        Parent = GetParent(Window);
        if(!Parent) {
            Parent = Window;
        }
    } else {
        Parent = NULL;
    }

    SetForegroundWindow(Parent);

    //
    // If we're just checking upgrades
    // then throw this message into the compatibility list.
    // NOTE: there's no reason not ot do this on Win9x as well
    //
    if( CheckUpgradeOnly) {
    PCOMPATIBILITY_DATA CompData;

        CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
        if (CompData == NULL) {
            return 0;
        }

        ZeroMemory( CompData, sizeof(COMPATIBILITY_DATA) );

        CompData->Description = DupString( Buffer );
        CompData->Flags = COMPFLAG_STOPINSTALL;
        if( !CompatibilityData.Flink ) {
            InitializeListHead( &CompatibilityData );
        }

        InsertTailList( &CompatibilityData, &CompData->ListEntry );
        CompatibilityCount++;
        IncompatibilityStopsInstallation = TRUE;

        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // always make sure the window is visible
    //
    if (Window && !IsWindowVisible (Window)) {
        //
        // if this window is the wizard handle or one of its pages
        // then use a special message to restore it
        //
        if (WizardHandle && 
            (WizardHandle == Window || IsChild (WizardHandle, Window))
            ) {
            SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            //
            // the window is one of the billboard windows;
            // just leave it alone or weird things may happen
            //
        }
    }
    return(MessageBox(Window,Buffer,Caption,Style));
}


int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    int i;

    //
    // before displaying any dialog, make sure Winnt32.exe wait dialog is gone
    //
    if (Winnt32Dlg) {
        DestroyWindow (Winnt32Dlg);
        Winnt32Dlg = NULL;
    }
    if (WinNT32StubEvent) {
        SetEvent (WinNT32StubEvent);
        WinNT32StubEvent = NULL;
    }

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionStringId,Style,&arglist);

    va_end(arglist);

    return(i);
}


int
MessageBoxFromMessageWithSystem(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN HMODULE  hMod
    )
{
    TCHAR Caption[512];
    TCHAR Buffer[5000];
    HWND Parent;
    DWORD i;


    if(!LoadString(hInst,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    i = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
        hMod,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        NULL
        );

    if (i == 0) {
        return -1;
    }

    SaveTextForSMS(Buffer);

    //
    // In batch mode, we don't want to wait on the user.
    //
    if(BatchMode) {
        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // Force ourselves into the foreground manually to guarantee that we get
    // a chance to set our palette. Otherwise the message box gets the
    // palette messages and color in our background bitmap can get hosed.
    // We assume the parent is a wizard page.
    //
    if(Window && IsWindow(Window)) {
        Parent = GetParent(Window);
        if(!Parent) {
            Parent = Window;
        }
    } else {
        Parent = NULL;
    }

    SetForegroundWindow(Parent);

    return(MessageBox(Window,Buffer,Caption,Style));
}


int
MessageBoxFromMessageAndSystemError(
    IN HWND  Window,
    IN DWORD MessageId,
    IN DWORD SystemMessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    TCHAR Caption[500];
    TCHAR Buffer1[2000];
    TCHAR Buffer2[1000];
    int i;

    //
    // Fetch the non-system part. The arguments are for that part of the
    // message -- the system part has no inserts.
    //
    va_start(arglist,Style);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer1,
        sizeof(Buffer1) / sizeof(TCHAR),
        &arglist
        );

    va_end(arglist);

    //
    // Now fetch the system part.
    //
    i = (int)FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                SystemMessageId,
                0,
                Buffer2,
                sizeof(Buffer2) / sizeof(TCHAR),
                NULL
                );

    if(!i) {
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_UNKNOWN_SYSTEM_ERROR,
            0,
            Buffer2,
            sizeof(Buffer2) / sizeof(TCHAR),
            (va_list *)&SystemMessageId
            );
    }

    //
    // Now display the message, which is made up of two parts that get
    // inserted into MSG_ERROR_WITH_SYSTEM_ERROR.
    //
    i = MessageBoxFromMessage(
            Window,
            MSG_ERROR_WITH_SYSTEM_ERROR,
            FALSE,
            CaptionStringId,
            Style,
            Buffer1,
            Buffer2
            );

    return(i);
}


HPALETTE
CreateDIBPalette(
    IN  LPBITMAPINFO  BitmapInfo,
    OUT int          *ColorCount
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    LPBITMAPINFOHEADER BitmapInfoHeader;
    LPLOGPALETTE LogicalPalette;
    HPALETTE Palette;
    int i;
    DWORD d;

    BitmapInfoHeader = (LPBITMAPINFOHEADER)BitmapInfo;

    //
    // No palette needed for >= 16 bpp
    //
    *ColorCount = (BitmapInfoHeader->biBitCount <= 8)
                ? (1 << BitmapInfoHeader->biBitCount)
                : 0;

    if(*ColorCount) {
        LogicalPalette = MALLOC(sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * (*ColorCount)));
        if(!LogicalPalette) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        LogicalPalette->palVersion = 0x300;
        LogicalPalette->palNumEntries = (WORD)*ColorCount;

        for(i=0; i<*ColorCount; i++) {
            LogicalPalette->palPalEntry[i].peRed   = BitmapInfo->bmiColors[i].rgbRed;
            LogicalPalette->palPalEntry[i].peGreen = BitmapInfo->bmiColors[i].rgbGreen;
            LogicalPalette->palPalEntry[i].peBlue  = BitmapInfo->bmiColors[i].rgbBlue;
            LogicalPalette->palPalEntry[i].peFlags = 0;
        }

        Palette = CreatePalette(LogicalPalette);
        d = GetLastError();
        FREE(LogicalPalette);
        SetLastError(d);
    } else {
        Palette = NULL;
    }

    return(Palette);
}


HBITMAP
LoadResourceBitmap(
    IN  HINSTANCE hInst,
    IN  LPCTSTR   Id,
    OUT HPALETTE *Palette
    )

/*++

Routine Description:

    Bitmaps in resources are stored as DIBs. When fetched via LoadBitmap()
    they are converted to DDBs and a color conversion takes place based on
    whatever logical palette happens to be currently selected into whatever
    DC gets used internally for the conversion.

    This routine fetches the color data from the DIB in the resources and
    ensures that the DIB is converted into a DDB using accurate color data.
    It is essentially a color-accurate replacement for LoadBitmap().

Arguments:

    hInst - supplies instance handle for module containing the bitmap resource.

    Id - supplies the id of the bitmap resource.

    Palette - if successful, receives a handle to a palette for the bitmap.

Return Value:

    If successful, handle to the loaded bitmap (DIB).
    If not, NULL is returned. Check GetLastError().

--*/

{
    DWORD d;
    BOOL b;
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;
    BITMAPINFOHEADER *BitmapInfoHeader;
    HDC hdc;
    int ColorCount;
    HBITMAP Bitmap;
    HPALETTE PreviousPalette;

    Bitmap = NULL;

    BlockHandle = FindResource(hInst,Id,RT_BITMAP);
    if(!BlockHandle) {
        d = GetLastError();
        goto c0;
    }

    MemoryHandle = LoadResource(hInst,BlockHandle);
    if(!MemoryHandle) {
        d = GetLastError();
        goto c0;
    }

    BitmapInfoHeader = LockResource(MemoryHandle);
    if(!BitmapInfoHeader) {
        d = GetLastError();
        goto c1;
    }

    hdc = GetDC(NULL);
    if(!hdc) {
        d = GetLastError();
        goto c2;
    }

#if 0 // steveow - fix palette problem
    if(*Palette = CreateDIBPalette((BITMAPINFO *)BitmapInfoHeader,&ColorCount)) {
        PreviousPalette = SelectPalette(hdc,*Palette,FALSE);
        RealizePalette(hdc);
    } else {
        PreviousPalette = NULL;
    }
#else
    ColorCount = 16;
    PreviousPalette = NULL;
#endif
    //
    // This routine creates a DDB from the DIB (the name is confusing).
    //
    Bitmap = CreateDIBitmap(
                hdc,
                BitmapInfoHeader,
                CBM_INIT,
                (LPBYTE)BitmapInfoHeader + BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD)),
                (BITMAPINFO *)BitmapInfoHeader,
                DIB_RGB_COLORS
                );

    if(!Bitmap) {
        d = GetLastError();
        goto c3;
    }

c3:
    if(PreviousPalette) {
        SelectObject(hdc,PreviousPalette);
    }
    if(!Bitmap) {
        DeleteObject(*Palette);
        *Palette = NULL;
    }
    ReleaseDC(NULL,hdc);
c2:
    UnlockResource(MemoryHandle);
c1:
    FreeResource(MemoryHandle);
c0:
    if(!Bitmap) {
        SetLastError(d);
    }
    return(Bitmap);
}


BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    )

/*++

Routine Description:

    Retreives device-independent bitmap data and a color table from a
    bitmap in a resource.

Arguments:

    hInst - supplies instance handle for module containing the bitmap resource.

    Id - supplies the id of the bitmap resource.

    Palette - if successful, receives a handle to a palette for the bitmap.

    ColorCount - if successful, receives the number of entries in the
        palette for the bitmap.

    BitmapData - if successful, receives a pointer to the bitmap info
        header structure in the resources. This is in read-only memory
        so the caller should not try to modify it.

Return Value:

    If successful, handle to the loaded bitmap (DIB).
    If not, NULL is returned. Check GetLastError().

--*/

{
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;

    //
    // None of FindResource(), LoadResource(), or LockResource()
    // need to have cleanup routines called in Win32.
    //
    BlockHandle = FindResource(hInst,Id,RT_BITMAP);
    if(!BlockHandle) {
        return(FALSE);
    }

    MemoryHandle = LoadResource(hInst,BlockHandle);
    if(!MemoryHandle) {
        return(FALSE);
    }

    *BitmapData = LockResource(MemoryHandle);
    if(*BitmapData == NULL) {
        return(FALSE);
    }

    *Palette = CreateDIBPalette((LPBITMAPINFO)*BitmapData,ColorCount);
    return(TRUE);
}


PVOID
FindControlInDialog(
    IN PVOID Template,
    IN UINT  ControlId
    )
{
    PVOID p;
    DLGTEMPLATE *pTemplate;
    DLGTEMPLATE2 *pTemplate2;
    DLGITEMTEMPLATE *pItem;
    DLGITEMTEMPLATE2 *pItem2;
    WORD ItemCount;
    DWORD Style;
    WORD i;
    BOOL bDialogEx;

    if (!Template) // validate
        return NULL;
    p = Template;

    //
    // Skip fixed part of template
    //
    if(((DLGTEMPLATE2 *)p)->wSignature == 0xffff) {

        pTemplate2 = p;

        ItemCount = pTemplate2->cDlgItems;
        Style = pTemplate2->style;

        p = pTemplate2 + 1;
        bDialogEx = TRUE;

    } else {

        pTemplate = p;

        ItemCount = pTemplate->cdit;
        Style = pTemplate->style;

        p = pTemplate + 1;
        bDialogEx = FALSE;
    }

    //
    // Skip menu. First word=0 means no menu
    // First word=0xffff means one more word follows
    // Else it's a nul-terminated string
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip class, similar to menu
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip title
    //
    p = (PWCHAR)p + lstrlenW(p) + 1;

    if(Style & DS_SETFONT) {
        //
        // Skip point size and typeface name
        //
        p = (WORD *)p + 1;
        if (bDialogEx)
        {
            // Skip weight, italic, and charset.
            p = (WORD *)p + 1;
            p = (BYTE *)p + 1;
            p = (BYTE *)p + 1;
        }
        p = (PWCHAR)p + lstrlenW(p) + 1;
    }

    //
    // Now we have a pointer to the first item in the dialog
    //
    for(i=0; i<ItemCount; i++) {

        //
        // Align to next DWORD boundary
        //
        p = (PVOID)(((ULONG_PTR)p + sizeof(DWORD) - 1) & (~((ULONG_PTR)sizeof(DWORD) - 1)));
        if (bDialogEx)
        {
            pItem2 = p;

            if(pItem2->dwID == (WORD)ControlId) {
                break;
            }

            //
            // Skip to next item in dialog.
            // First is class, which is either 0xffff plus one more word,
            // or a unicode string. After that is text/title.
            //
            p = pItem2 + 1;
        }
        else
        {
            pItem = p;

            if(pItem->id == (WORD)ControlId) {
                break;
            }

            //
            // Skip to next item in dialog.
            // First is class, which is either 0xffff plus one more word,
            // or a unicode string. After that is text/title.
            //
            p = pItem + 1;
        }
        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        //
        // Skip creation data.
        //
        p = (PUCHAR)p + *(WORD *)p;
        p = (WORD *)p + 1;
    }

    if(i == ItemCount) {
        p = NULL;
    }

    return(p);
}


UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    )
{
    HRSRC hRsrc;
    PVOID p;
    HGLOBAL hGlobal;
    PVOID pItem;
    UINT i;

    i = 0;

    if(hRsrc = FindResource(hInst,Dialog,RT_DIALOG)) {
        if(hGlobal = LoadResource(hInst,hRsrc)) {
            if(p = LockResource(hGlobal)) {


                if(pItem = FindControlInDialog(p,ControlId)) {
                    if(((DLGTEMPLATE2 *)p)->wSignature == 0xffff) {
                        i = ((DLGITEMTEMPLATE2*)pItem)->y;
                    }
                    else
                    {
                        i = ((DLGITEMTEMPLATE*)pItem)->y;
                    }
                }

                UnlockResource(hGlobal);
            }
            FreeResource(hGlobal);
        }
    }

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\sources.inc ===
MAJORCOMP=setup

TARGETPATH=..\..\$(_OBJ_DIR)
TARGETTYPE=DYNLINK

DLLDEF=$(O)\winnt32.def
DLLENTRY=_DllMainCRTStartup

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES= $(PASS0_HEADERDIR);   \
          $(PASS0_SOURCEDIR);   \
          ..;                   \
          ..\..\..\inc;         \
          ..\..\..\..\inc;      \
          ..\..\faulth;         \
          $(ADMIN_INC_PATH);    \
          $(BASE_INC_PATH);     \
          $(WINDOWS_INC_PATH);  \
          $(TERMSRV_INC_PATH);  \

#          $(SDK_INC_PATH);      \
#          $(SDK_INC_PATH)\crt;  \


#
# We use various NT APIs to do stuff like arc name translations and
# NV-RAM manipulation. The x86 version has to run on Win95, so we can't
# link to ntdll.dll (when running on NT x86 the code does loadlib/getprocaddr
# for the routines it needs). On non-x86 we want ntdll to come last
# in the link order so we don't get crt routines from it (the set of crt
# routines exported from it varies from release to release) so we play
# a little build trickery to get it right.
#
NO_NTDLL=1
USE_LIBCMT=1
UMTYPE=windows
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET
!if $(386)
SUBSYSTEM_VERSION=4.00
!ENDIF

SOURCES=..\arc.c        \
        ..\argvw.c      \
        ..\cleanup.c    \
        ..\comp.c       \
        ..\copylist.c   \
        ..\debug.c      \
        ..\delnode.c    \
        ..\diamond.c    \
        ..\dll.c        \
        ..\dynsetup.c   \
        ..\dynupdt.c    \
        ..\eula.c       \
        ..\incompat.c   \
        ..\inf.c        \
        ..\inspect.c    \
        ..\internal.c   \
        ..\misc.c       \
        ..\msg.mc       \
        ..\options.c    \
        ..\params.c     \
        ..\regmigrt.c   \
        ..\rsrcutil.c   \
        ..\security.c   \
        ..\sticky.c     \
        ..\util.c       \
        ..\winnt32.c    \
        ..\winnt32.rc   \
        ..\dscheck.c    \
        ..\web.cpp      \
        ..\wizard.c     \
        ..\cmdcons.c    \
        ..\lang.c       \
        ..\sxs.c        \

TARGETLIBS=\
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\cfgmgr32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(BASE_LIB_PATH)\patchbc.lib             \
           $(PROJECT_LIB_PATH)\pnpsif.lib           \
           $(SDK_LIB_PATH)\mpr.lib      \
           $(SDK_LIB_PATH)\version.lib  \
           $(SDK_LIB_PATH)\winspool.lib \
           $(SDK_LIB_PATH)\imm32.lib \
           $(PROJECT_LIB_PATH)\pencrypt.lib \
           $(PROJECT_ROOT)\ntsetup\pidgen\lib\trial\$(O)\pidgen.lib   \
           $(PROJECT_ROOT)\mspatch\api\statica\$(O)\mspatchz.lib \

PRECOMPILED_INCLUDE=precomp.h


#
# Definition of DOWNLOAD_DETAILS
#
!ifdef DOWNLOAD_DETAILS
C_DEFINES=$(C_DEFINES) -DDOWNLOAD_DETAILS
!endif

#
# Definition of PRERELEASE
#

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\sxs.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntsetup\winnt32\dll\sxs.h

Abstract:

    SideBySide support in the winnt32 phase of ntsetup.

Author:

    Jay Krell (JayKrell) March 2001

Revision History:

--*/

#pragma once

struct _SXS_CHECK_LOCAL_SOURCE;
typedef struct _SXS_CHECK_LOCAL_SOURCE SXS_CHECK_LOCAL_SOURCE, *PSXS_CHECK_LOCAL_SOURCE;

struct _SXS_CHECK_LOCAL_SOURCE {
    // IN
    HWND            ParentWindow;
};

BOOL
SxsCheckLocalSource(
    PSXS_CHECK_LOCAL_SOURCE p
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\syspart.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Command-line param that allows someone to force a particular drive
// to be the system partition. Useful in certain preinstall scenarios.
//
TCHAR ForcedSystemPartition;

#define WINNT_DONT_MATCH_PARTITION 0
#define WINNT_MATCH_PARTITION_NUMBER  1
#define WINNT_MATCH_PARTITION_STARTING_OFFSET  2

#define BUFFERSIZE 1024

//
// NT-specific routines we use from ntdll.dll and kernel32.dll
//
//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenSymLinkRoutine)(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerSymLinkRoutine)(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerDirRoutine) (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenDirRoutine) (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//WINBASEAPI
HANDLE
(WINAPI *pFindFirstVolume) (
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *pFindNextVolume)(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *pFindVolumeClose)(
    HANDLE hFindVolume
    );

//WINBASEAPI
BOOL
(WINAPI *pGetVolumeNameForVolumeMountPoint)(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
);

DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
);

BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
);


DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
);










BOOL
ArcPathToNtPath(
    IN  LPCTSTR ArcPath,
    OUT LPTSTR  NtPath,
    IN  UINT    NtPathBufferLen
    )
{
    WCHAR arcPath[256];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

    lstrcpyW(arcPath,L"\\ArcName\\");
#ifdef UNICODE
    lstrcpynW(arcPath+9,ArcPath,(sizeof(arcPath)/sizeof(WCHAR))-9);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        ArcPath,
        -1,
        arcPath+9,
        (sizeof(arcPath)/sizeof(WCHAR))-9
        );
#endif

    UnicodeString.Buffer = arcPath;
    UnicodeString.Length = lstrlenW(arcPath)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {

            Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

#ifdef UNICODE
            lstrcpyn(NtPath,Buffer,NtPathBufferLen);
#else
            WideCharToMultiByte(CP_ACP,0,Buffer,-1,NtPath,NtPathBufferLen,NULL,NULL);
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN TCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    UINT i;
    DWORD d;

    LPTSTR BootFiles[] = { TEXT("BOOT.INI"),
                           TEXT("NTLDR"),
                           TEXT("NTDETECT.COM"),
                           NULL
                         };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether all NT boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,TEXT("%c:\\%s"),Drive,BootFiles[i]);

        d = GetFileAttributes(FileName);
        if(d == (DWORD)(-1)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD
QueryHardDiskNumber(
    IN  TCHAR   DriveLetter
    )

{
    TCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    )
{
    DWORD       DriveNum;
    TCHAR       DosName[7];
    TCHAR       Name[MAX_PATH];
    DISK_GEOMETRY DiskGeom;
    PARTITION_INFORMATION PartitionInfo;
    HANDLE      h;
    BOOL        b;
    DWORD       Bytes;
    PUCHAR      UnalignedBuffer,Buffer;
    unsigned    i;
    BOOL Rewrite;
    BOOL FoundIt;

    //
    // This concept is n/a for PC98 and the stuff below
    // won't work on Win9x.
    //
    if(IsNEC98() || !ISNT()) {
        return(TRUE);
    }

    //
    // Get geometry info and partition info for this drive.
    // We get geometry info because we need the bytes per sector info.
    //
    wsprintf(DosName,TEXT("\\\\.\\%c:"),DriveLetter);

    h = CreateFile(
            DosName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0,
            &DiskGeom,
            sizeof(DISK_GEOMETRY),
            &Bytes,
            NULL
            );

    if(!b || (DiskGeom.BytesPerSector < 512)) {
        CloseHandle(h);
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            &PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &Bytes,
            NULL
            );

    CloseHandle(h);
    if(!b) {
        return(FALSE);
    }

    //
    // Figure out which physical drive this partition is on.
    //
    DriveNum = QueryHardDiskNumber(DriveLetter);
    if(DriveNum == (DWORD)(-1)) {
        if (OsVersion.dwMajorVersion >= 5) {
            //
            // if QueryHardDiskNumber failed, it's likely the volume is on a dynamic disk
            // so in this case we better don't try to make (wrong) guesses;
            // just bail out
            //
            return FALSE;
        }
        // Have to do it the old-fashioned way. Convert to an NT path
        // and parse the result.
        //
        if(!QueryDosDevice(DosName+4,Name,MAX_PATH)) {
            return(FALSE);
        }

        if( _tcsnicmp( Name, TEXT("\\device\\harddisk"), 16 )) {
            //
            // We have no idea what this name represents. Punt.
            //
            return(FALSE);
        }

        DriveNum = _tcstoul(Name+16,NULL,10);
    }

    //
    // Allocate a buffer and align it.
    //
    UnalignedBuffer = MALLOC(2*DiskGeom.BytesPerSector);
    if(!UnalignedBuffer) {
        return(FALSE);
    }

    Buffer = (PVOID)(((DWORD_PTR)UnalignedBuffer + (DiskGeom.BytesPerSector - 1)) & ~((DWORD_PTR)(DiskGeom.BytesPerSector - 1)));

    //
    // Now we open up the physical drive and read the partition table.
    // We try to locate the partition by matching start offsets.
    // Note that active status is only meaningful for primary partitions.
    //
    wsprintf(Name,TEXT("\\\\.\\PhysicalDrive%u"),DriveNum);

    h = CreateFile(
            Name,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        FREE(UnalignedBuffer);
        return(FALSE);
    }

    if(!ReadFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL)) {
        FREE(UnalignedBuffer);
        CloseHandle(h);
        return(FALSE);
    }

    Rewrite = FALSE;
    FoundIt = FALSE;
    for(i=0; i<4; i++) {

        if(*(DWORD *)(Buffer + 0x1be + 8 + (i*16))
        == (DWORD)(PartitionInfo.StartingOffset.QuadPart / DiskGeom.BytesPerSector)) {

            FoundIt = TRUE;
            if(Buffer[0x1be+(i*16)] != 0x80) {
                //
                // Not already active, or active for some other bios unit #,
                // so we need to whack it.
                //
                Buffer[0x1be+(i*16)] = 0x80;
                Rewrite = TRUE;
            }
        } else {
            if(Buffer[0x1be+(i*16)]) {
                //
                // Not inactive, and needs to be, so whack it.
                //
                Buffer[0x1be+(i*16)] = 0;
                Rewrite = TRUE;
            }
        }
    }

    if(FoundIt) {
        if(Rewrite) {

            Bytes = 0;
            if(SetFilePointer(h,0,&Bytes,FILE_BEGIN) || Bytes) {
                b = FALSE;
            } else {
                b = WriteFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL);
            }
        } else {
            b = TRUE;
        }
    } else {
        b = FALSE;
    }

    CloseHandle(h);
    FREE(UnalignedBuffer);
    return(b);
}


BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    With there being differences in the IO system mapping and introduction of Volumes for NT 50
    this has now become complicated. Listed below are the algorithms
    
    
    NT 5.0 Beta 2 and above :
    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Go Through all of the volumes in the system with FindFirstVolume/FindNextVolume/FindVolumeClose.
        3. Take off the trailing backslash to the name returne to get \\?\Volume{guid}.
        4. IOCTL_STORAGE_GET_DEVICE_NUMBER with \\?\Volume{guid} => Check for FILE_DEVICE_DISK. Remember the partition number. Goto 6
        5. If IOCTL_STORAGE_GET_DEVICE_NUMBER fails then use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS which returns a list of harddisks.  
           For each harddisk remember the starting offset and goto 6.
        6. Check Harddisk # by using \\.\PhysicalDrive# with IOCTL_DISK_GET_DRIVE_LAYOUT.  If the signature matches then this is the disk we boot from.
        7. To find the partition that we boot from we look for boot indicator. If we used 2 we try to match the partition number stored in 6 
           else if 3 we try to match the starting offset.Then you have a \\?\Volume{guid}\ name for the SYSTEM volume. 
        8. Call GetVolumeNameForVolumeMountPoint with A:\, B:\, C:\, ... and check the result of the form \\?\Volume{guid}\ against your match 
           to see what the drive letter is.
           
           Important: Since the *Volume* APIs are post Beta2 we do dynamic loading of kernel32.dll based on the build number returned.

    Versions below NT 5.0 Beta 2
                                                                                                                                    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Enumerate the \?? directory and look for all entries that begin with PhysicalDrive#. 
	    3. For each of the Disks look for a match with the signature above and if they match then find out the partition number used to boot 
           using IOCTL_DISK_GET_DRIVE_LAYOUT and the BootIndicator bit.
	    4. On finding the Boot partition create a name of the form \Device\Harddisk#\Partition#
	    5. Then go through c:,d:...,z: calling QueryDosDeviceName and look for a match. That would be your system partition drive letter

    
    
Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[4];
    BOOL  GotIt=FALSE;
    TCHAR Buffer[512];
    TCHAR Drive;
    BOOL b;
    TCHAR SysPartSig[100], PartitionNum[MAX_PATH], SysVolGuid[MAX_PATH];
    TCHAR DriveVolGuid[MAX_PATH];
    


    if(ForcedSystemPartition) {
        //
        // NT5 for NEC98 can't boot up from ATA Card and 
        // removable drive. We need check dive type.
        //
        if (IsNEC98() &&
            ((MyGetDriveType(ForcedSystemPartition) != DRIVE_FIXED) ||
             // Drive is not Fixed.
             !IsValidDrive(ForcedSystemPartition))){
            // HD format type is not NEC98.
            return(FALSE);
        }
        *SysPartDrive = ForcedSystemPartition;
        return(TRUE);
    }

    if(IsNEC98()) {
        if(!MyGetWindowsDirectory(Buffer,sizeof(Buffer)/sizeof(TCHAR)))
            return FALSE;
        *SysPartDrive = Buffer[0];
        return(TRUE);
    }

    if(!ISNT()) {
        *SysPartDrive = TEXT('C');
        return(TRUE);
    }


    // Code for NT starts here
        
    //Get signature from registry - Step 1 listed above
    
    if( (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\EisaAdapter"),SysPartSig) != ERROR_SUCCESS )
        && (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\MultiFunctionAdapter"),SysPartSig) != ERROR_SUCCESS ) ){  
        GotIt = FALSE;
        goto c0;
    }

    
    if( ISNT() && (BUILDNUM() >= 1877) ){
    
        //Get the SystemVolumeGUID - steps 2 through 7 listed above ( Beta 2 and after )

        if( GetSystemVolumeGUID( SysPartSig, SysVolGuid ) != ERROR_SUCCESS ){  
            GotIt = FALSE;
            goto c0;
        }


    
    
    }else{

        if( GetNT4SystemPartition( SysPartSig, PartitionNum )  != ERROR_SUCCESS){
            GotIt = FALSE;
            goto c0;
        }

    }


    DriveName[1] = TEXT(':');
    
    // 
    //  Enumerate all drive letters and compare their device names
    //

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

            if( BUILDNUM() >= 1877){ //Versions Beta2 and after
                DriveName[2] = '\\';
                DriveName[3] = 0;

                if((pGetVolumeNameForVolumeMountPoint)((LPWSTR)DriveName, (LPWSTR)DriveVolGuid, MAX_PATH*sizeof(TCHAR))){
                    if(!lstrcmp(DriveVolGuid, SysVolGuid) ){
                        GotIt = TRUE;       // Found it
                        break;
                    }


                }


            }else{
                DriveName[2] = 0;
                if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
    
                    if( !lstrcmpi(Buffer, PartitionNum) ) {
                        GotIt = TRUE;       // Found it
                        break;
                    }
                }
            }//Versions earlier than Beta 2
        }
    }

    
    // This helps for some builds ~1500 < buildnum < 1877 that are in a tough spot

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }


c0:
    if(GotIt) {
        *SysPartDrive = Drive;
#if defined(REMOTE_BOOT)
    } else if (RemoteBoot) {
        GotIt = TRUE;
        *SysPartDrive = TEXT('C');
#endif
    }
    return(GotIt);
}


DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
)

/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \\?\Volume{guid} name for the system partition.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysVolGuid - If successful, will contain a name of form \\?\Volume{guid} for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    HANDLE hVolume, h;
    TCHAR VolumeName[MAX_PATH];
    PTSTR q;
    TCHAR driveName[30];
    BOOL b,ret, DoExtent, MatchFound;
    STORAGE_DEVICE_NUMBER   number;
    DWORD Err,cnt;
    PVOLUME_DISK_EXTENTS Extent;
    PDISK_EXTENT Start, i;
    DWORD ExtentSize, bytes;
    PVOID p;
    ULONG PartitionNumToCompare;
    LARGE_INTEGER StartingOffToCompare;
    DWORD ioctlCode;

    Err = NO_ERROR;

    //Enuberate all volumes

    hVolume = (pFindFirstVolume)( (LPWSTR)VolumeName, MAX_PATH );
    if( hVolume == INVALID_HANDLE_VALUE ){
        return GetLastError();
    }

    MatchFound = FALSE;

    do{

        //Remove trailing backslash

        DoExtent = FALSE;
            
        if( q=_tcsrchr( VolumeName,TEXT('\\')) ){
            *q = 0;
        }else{
            continue;
        }


        //Open the volume

        h = CreateFile(VolumeName, GENERIC_READ, FILE_SHARE_READ |
                       FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            continue; // Move on to next volume
        }

        //Get the disk number

        ret = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);

        if( !ret ){
            
            // Try using IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS if the above failed

            Extent = MALLOC(1024);
            ExtentSize = 1024;
            if(!Extent) {
                CloseHandle( h );
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            
            

            ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS;
retry:
        
            ret = DeviceIoControl( h, ioctlCode,
                    NULL,0,(PVOID)Extent,ExtentSize,&bytes,NULL);
        
            if(!ret) {
        
                if((Err=GetLastError()) == ERROR_MORE_DATA) {
        
                    ExtentSize += 1024;
                    if(p = REALLOC((PVOID)Extent, ExtentSize)) {
                        (PVOID)Extent = p;
                    } else {
                        CloseHandle( h );
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto cleanup;
                    }
                    goto retry;
                } else {
                    if (ioctlCode == IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS) {
                        ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN;
                        goto retry;
                    }
                    CloseHandle( h );
                    continue;
                }
            }else{
                DoExtent = TRUE;
            }

        }
        
        // Done with the handle this time around

        CloseHandle( h );

        if( !DoExtent ){

             //
            //  Check to see if this is a disk and not CDROM etc.
            //

            if( number.DeviceType == FILE_DEVICE_DISK ){
                
                // Remember the partition number
                PartitionNumToCompare = number.PartitionNumber;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), number.DeviceNumber );


                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&PartitionNumToCompare, WINNT_MATCH_PARTITION_NUMBER  ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
                
            }
            // Move on ..
            continue;
            
        }else{
            // Go through all disks and try for match

            Start = Extent->Extents;
            cnt = 0;      
            for( i = Start; cnt < Extent->NumberOfDiskExtents; i++ ){
                cnt++;
                // Remember the starting offset
                StartingOffToCompare = i->StartingOffset;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), i->DiskNumber );
                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&StartingOffToCompare, WINNT_MATCH_PARTITION_STARTING_OFFSET ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
            }
            
        }
        
        if( MatchFound )
            break;
        

    }while( (pFindNextVolume)( hVolume, (LPWSTR)VolumeName, MAX_PATH ));


cleanup:

    if( hVolume != INVALID_HANDLE_VALUE )
        (pFindVolumeClose)( hVolume );

    return Err;



}



BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
)
/*++

Routine Description:

    This routine compares the given disk signature with the one for the specified physical disk.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    DriveName -  Physical Drive name of the form \\.\PhysicalDrive#
    
    Compare   -  A pointer to a storage variable. The type depends on the value of Action
    
    Action    -  Should be one of the following
                
                WINNT_DONT_MATCH_PARTITION - Once disk signatures match it returns the boot partition number in Compare. Compare should be a PULONG.
                       
                WINNT_MATCH_PARTITION_NUMBER - Once disk signatures match it tries to match the boot partition number with the number passed in
                                               through Compare. Compare should be PULONG.
                
                WINNT_MATCH_PARTITION_STARTING_OFFSET - Once disk signatures match it tries to match the boot partition starting offset with the 
                                                        starting offset number passed in through Compare. Compare should be PLARGE_INTEGER.

Return Value:

    Returns TRUE if successful in getting a match.
    

--*/

{

    TCHAR temp[30];
    BOOL b,Found = FALSE;
    PLARGE_INTEGER Starting_Off;
    PPARTITION_INFORMATION Start, i;
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    DWORD DriveLayoutSize;
    DWORD cnt;
    DWORD DataSize;
    LPTSTR p;
    PULONG Disk_Num;
    ULONG Sig;
    


    if(!Compare )
        return FALSE;

    if ((Action != WINNT_DONT_MATCH_PARTITION) &&
        (Action != WINNT_MATCH_PARTITION_NUMBER) &&
        (Action != WINNT_MATCH_PARTITION_STARTING_OFFSET))
        return FALSE;

    if( (Action==WINNT_MATCH_PARTITION_STARTING_OFFSET) && Compare )
        Starting_Off = (PLARGE_INTEGER) Compare;
    else
        Disk_Num = (PULONG) Compare;
    




    // On any failure return FALSE



    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                DriveName,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    
    if(hDisk == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    //
    // Get partition information.
    //
    DriveLayout = MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        goto cleanexit;
    }
    
    
retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            if(p = REALLOC((PVOID)DriveLayout,DriveLayoutSize)) {
                (PVOID)DriveLayout = p;
            } else {
                goto cleanexit;
            }
            goto retry;
        } else {
            goto cleanexit;
        }
    }else{

        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        /*
        _ultot( DriveLayout->Signature, temp, 16 );
        if( lstrcmpi( temp, Signature ) )
            goto cleanexit;
        */

        Sig = _tcstoul( Signature, NULL, 16 ); 
        if( Sig != DriveLayout->Signature )
            goto cleanexit;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            
            
            if( i->BootIndicator == TRUE ){
                if( Action == WINNT_DONT_MATCH_PARTITION ){
                    *Disk_Num = i->PartitionNumber;
                    Found = TRUE;
                    goto cleanexit;

                }


                if( Action == WINNT_MATCH_PARTITION_NUMBER ){
                    if( *Disk_Num == i->PartitionNumber ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }else{
                    if( Starting_Off->QuadPart == i->StartingOffset.QuadPart ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }
                
                break;
            }
            
        }



    }

cleanexit:

    if( hDisk != INVALID_HANDLE_VALUE )
        CloseHandle( hDisk );


    return Found;
}












DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
)
/*++

Routine Description:

    This routine fetches the disk signature for the first disk that the BIOS sees. This has to be the disk that we boot from on x86s.
    It is at location <AdapterKeyName>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier

Arguments:

    Signature -  If successful will contain the signature of the disk we boot off from in Hex.

Return Value:

    Returns ERROR_SUCCESS if successful, otherwise it contains the error code.
    

--*/
{

    DWORD Err, dwSize;
    HKEY hkey, BusKey, Controller, SystemDiskKey;
    int busnumber;
    TCHAR BusString[20], Identifier[100];



    Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        AdapterKeyName,
                        0,
                        KEY_READ,
                        &hkey );

    if( Err != ERROR_SUCCESS )
        return Err;

    
    // Start enumerating the buses

    for( busnumber=0; ;busnumber++){

        wsprintf( BusString, TEXT("%d"), busnumber );

        Err = RegOpenKeyEx( hkey,
                        BusString,
                        0,
                        KEY_READ,
                        &BusKey );

        

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( hkey );
            return Err;
        }
        
        Err = RegOpenKeyEx( BusKey,
                        TEXT("DiskController"),
                        0,
                        KEY_READ,
                        &Controller );

        
        RegCloseKey(BusKey);        // Not needed anymore

        
        if( Err != ERROR_SUCCESS )  // Move on to next bus
            continue;

        RegCloseKey( hkey );        // Not needed anymore

        Err = RegOpenKeyEx( Controller,
                        TEXT("0\\DiskPeripheral\\0"),
                        0,
                        KEY_READ,
                        &SystemDiskKey );

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( Controller );
            return Err;
        }

        RegCloseKey( Controller );  // Not needed anymore


        dwSize = sizeof(Identifier);
        Err = RegQueryValueEx( SystemDiskKey,
                               TEXT("Identifier"),
                               NULL,
                               NULL,
                               (PBYTE) Identifier,
                               &dwSize);

        if( Err != ERROR_SUCCESS  ){
            RegCloseKey( SystemDiskKey );
            return Err;
        }

        if( Identifier && (lstrlen(Identifier) > 9 ) ){
            lstrcpy( Signature,Identifier+9);
            *_tcsrchr( Signature,TEXT('-') ) = 0;
            RegCloseKey( SystemDiskKey );
            return ERROR_SUCCESS;
        }
        else{
            RegCloseKey( SystemDiskKey );
            return Err;
        }


         
    }

    // Should never get here


    RegCloseKey( hkey );
    
    return ERROR_PATH_NOT_FOUND;
    

}




BOOL
InitializeArcStuff(
    IN HWND Parent
    )
{
    HMODULE NtdllLib, Kernel32Lib;

    if(ISNT()) {
        //
        // On NT ntdll.dll had better be already loaded.
        //
        NtdllLib = LoadLibrary(TEXT("NTDLL"));
        if(!NtdllLib) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            return(FALSE);

        }

        (FARPROC)NtOpenSymLinkRoutine = GetProcAddress(NtdllLib,"NtOpenSymbolicLinkObject");
        (FARPROC)NtQuerSymLinkRoutine = GetProcAddress(NtdllLib,"NtQuerySymbolicLinkObject");
        (FARPROC)NtOpenDirRoutine = GetProcAddress(NtdllLib,"NtOpenDirectoryObject");
        (FARPROC)NtQuerDirRoutine = GetProcAddress(NtdllLib,"NtQueryDirectoryObject");

        

        if(!NtOpenSymLinkRoutine || !NtQuerSymLinkRoutine || !NtOpenDirRoutine || !NtQuerDirRoutine) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            FreeLibrary(NtdllLib);

            return(FALSE);
        }

        //
        // We don't need the extraneous handle any more.
        //
        FreeLibrary(NtdllLib);


        if(BUILDNUM() >= 1877){
            
            //Load the kernel32.dll stuff too

            Kernel32Lib = LoadLibrary(TEXT("KERNEL32"));
            if(!Kernel32Lib) {
    
                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                return(FALSE);

            }

            (FARPROC)pFindFirstVolume = GetProcAddress(Kernel32Lib,"FindFirstVolumeW");
            (FARPROC)pFindNextVolume = GetProcAddress(Kernel32Lib,"FindNextVolumeW");
            (FARPROC)pFindVolumeClose = GetProcAddress(Kernel32Lib,"FindVolumeClose");
            (FARPROC)pGetVolumeNameForVolumeMountPoint = GetProcAddress(Kernel32Lib,"GetVolumeNameForVolumeMountPointW");

            if(!pFindFirstVolume || !pFindNextVolume ) {

                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                FreeLibrary(Kernel32Lib);
    
                return(FALSE);
            }

            FreeLibrary(Kernel32Lib);


        }


    }
                  
    if(!x86DetermineSystemPartition(Parent,&SystemPartitionDriveLetter)) {

        MessageBoxFromMessage(
            Parent,
            MSG_SYSTEM_PARTITION_INVALID,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    SystemPartitionDriveLetters[0] = SystemPartitionDriveLetter;
    SystemPartitionDriveLetters[1] = 0;

    LocalBootDirectory[0] = SystemPartitionDriveLetter;
    LocalBootDirectory[1] = TEXT(':');
    LocalBootDirectory[2] = TEXT('\\');
    lstrcpy(LocalBootDirectory+3,LOCAL_BOOT_DIR);
    if(IsNEC98()) {
        LocalBackupDirectory[0] = SystemPartitionDriveLetter;
        LocalBackupDirectory[1] = TEXT(':');
        LocalBackupDirectory[2] = TEXT('\\');
        lstrcpy(LocalBackupDirectory+3,LOCAL_BACKUP_DIR);
    }

    return(TRUE);
}






DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
)
/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \Device\Harddisk#\Partition# name of the system partition
    on systems prior to NT 5 Beta 2.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysPart -  If successful, will contain a name of form \Device\Harddisk#\Partition# for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UCHAR DirInfoBuffer[ BUFFERSIZE ];
    TCHAR DirName[20];
    TCHAR ObjName[1024];
    TCHAR Buffer[1024];
    WCHAR pSignature[512];
    ULONG Context = 0;
    ULONG ReturnedLength, PartNum;
    LPTSTR Num_Str;
    
    
    RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

#ifdef UNICODE
    lstrcpyW( pSignature,Signature);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        Signature,
        -1,
        pSignature,
        (sizeof(pSignature)/sizeof(WCHAR))
        );
    
#endif

    //We open the \?? Directory
    
    lstrcpy( DirName, TEXT("\\DosDevices") );
    
    
    UnicodeString.Buffer = (PWSTR)DirName;
    UnicodeString.Length = lstrlenW(UnicodeString.Buffer)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = (*NtOpenDirRoutine)( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status ))
        return(Status);

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
    
    // Go through the directory looking for all instances beginning with PhysicalDrive#

    for (Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {
    
    
        
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES))
            break;
        

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer[0];
        
        
        while( TRUE ){

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }


            memmove( ObjName, DirInfo->Name.Buffer, DirInfo->Name.Length );
            ObjName[DirInfo->Name.Length/(sizeof(WCHAR))] = 0;

            if( _tcsstr(ObjName, TEXT("PhysicalDrive") )){

                Num_Str = ObjName+13;

                wsprintf(Buffer,TEXT("\\\\.\\%s"),ObjName);
                if( DoDiskSignaturesCompare( (LPCTSTR)pSignature, Buffer, &PartNum, WINNT_DONT_MATCH_PARTITION ) ){
                    wsprintf(SysPart,TEXT("\\Device\\Harddisk%s\\Partition%lu"),Num_Str, PartNum);
                    Status = ERROR_SUCCESS;
                    goto cleanup;

                }
            }

            

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );




        }
        


        RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

        
    
    }

cleanup:
    CloseHandle( DirectoryHandle );
    return( Status );
}
    
#if defined(UNICODE)

#define EMPTY_STRING L""
#define DEF_INF_BUFFER_SIZE 1024
#define MULTI_SZ_NEXT_STRING(x) ((x) + wcslen(x) + 1)
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif

BOOL
GetSystemRootNtPath(
    OUT LPWSTR  NtPath,
    IN  USHORT  NtPathBufferLen
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

#define SYSTEM_ROOT_NAME        L"\\SystemRoot"
    UnicodeString.Buffer = SYSTEM_ROOT_NAME;
    UnicodeString.Length = (ARRAYSIZE(SYSTEM_ROOT_NAME) - 1) * sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = NtPath;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = NtPathBufferLen;

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {
            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL 
DoesCurrentSystemHasThirdPartyKernel(
    VOID
    )
{
    WCHAR BootIniName[16];
    PWSTR pSectionsBuffer = NULL;
    PWSTR pKeysBuffer = NULL;
    PWSTR pString = NULL;
    PWSTR pNtPathString = NULL;
    PWSTR pNtPathSystemRoot = NULL;
    PWSTR pKey = NULL;
    PWSTR pDirectory;
    UINT  sizeOfSectionBuffer = 0;
    UINT  sizeOfBuffer = 0;
    UINT  directoryNameSize;
    BOOL  bResult = FALSE;

    wsprintfW(BootIniName, L"%c:\\BOOT.INI", SystemPartitionDriveLetter);

    __try{
        do{
            if(pKeysBuffer){
                FREE(pKeysBuffer);
            }
            sizeOfSectionBuffer += DEF_INF_BUFFER_SIZE;
            pKeysBuffer = (PWSTR)MALLOC(sizeOfSectionBuffer * sizeof (WCHAR));
            if(!pKeysBuffer){
                __leave;
            }
            pKeysBuffer[0] = '\0';
        }while((sizeOfSectionBuffer - 2) == 
                GetPrivateProfileStringW(L"operating systems",
                                         NULL,
                                         EMPTY_STRING,
                                         pKeysBuffer,
                                         sizeOfSectionBuffer,
                                         BootIniName));

        if(!pKeysBuffer[0]){
            __leave;
        }
        
        sizeOfBuffer = DEF_INF_BUFFER_SIZE;
        pString = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
        if(!pString){
            __leave;
        }
        pNtPathString = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
        if(!pNtPathString){
            __leave;
        }
        
        for(pKey = pKeysBuffer; pKey[0]; pKey = MULTI_SZ_NEXT_STRING(pKey))
        {
            GetPrivateProfileStringW(L"operating systems",
                                     pKey,
                                     EMPTY_STRING,
                                     pString,
                                     sizeOfBuffer,
                                     BootIniName);

            _wcslwr(pString);

            if(!wcsstr(pString, L"/kernel")){
                continue;
            }
            
            pDirectory = wcschr(pKey, '\\');
            MYASSERT(pDirectory);
            
            if(pDirectory){
                directoryNameSize = wcslen(pDirectory) * sizeof(WCHAR);
                pDirectory[0] = '\0';
            }
            else{
                directoryNameSize = 0;
            }

            if(!ArcPathToNtPath(pKey, pNtPathString, sizeOfBuffer - directoryNameSize)){
                MYASSERT(FALSE);
                continue;
            }
            
            if(pDirectory){
                pDirectory[0] = '\\';
                wcscat(pNtPathString, pDirectory);
            }
            
            if(!pNtPathSystemRoot){
                pNtPathSystemRoot = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
                if(!pNtPathSystemRoot){
                    __leave;
                }
                if(!GetSystemRootNtPath(pNtPathSystemRoot, sizeOfBuffer * sizeof (WCHAR))){
                    MYASSERT(FALSE);
                }
            }
            
            if(!_wcsicmp(pNtPathString, pNtPathSystemRoot)){
                bResult = TRUE;
                __leave;
            }
        }
    }
    __finally{
        DWORD rc = GetLastError();

        if(pKeysBuffer){
            FREE(pKeysBuffer);
        }
        if(pString){
            FREE(pString);
        }
        if(pNtPathString){
            FREE(pNtPathString);
        }
        if(pNtPathSystemRoot){
            FREE(pNtPathSystemRoot);
        }
        
        SetLastError (rc);
    }

    return bResult;
}
#endif

BOOL 
SystemKernelCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    BOOL bResult = TRUE;
    PWSTR Buffer;

#if defined(UNICODE) && defined(_X86_)
    COMPATIBILITY_ENTRY CompEntry;

    if(!DoesCurrentSystemHasThirdPartyKernel()){
        return FALSE;
    }

    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        hInst,
        MSG_SYSTEM_HAS_THIRD_PARTY_KERNEL,
        0,
        (PWSTR)&Buffer,
        0,
        NULL
        );
    
    CompEntry.Description = Buffer;
    CompEntry.HtmlName = TEXT("compdata\\krnlchk.htm");
    CompEntry.TextName = TEXT("compdata\\krnlchk.htm");
    CompEntry.RegKeyName = NULL;
    CompEntry.RegValName = NULL;
    CompEntry.RegValDataSize = 0;
    CompEntry.RegValData = NULL;
    CompEntry.SaveValue = NULL;
    CompEntry.Flags = 0;
    CompEntry.InfName = NULL;
    CompEntry.InfSection = NULL;

    bResult = CompatibilityCallback(&CompEntry, Context);

    LocalFree(Buffer);
#endif

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\sticky.c ===
#include "precomp.h"
#pragma hdrstop

typedef LONG NTSTATUS;
#include <ntdskreg.h>
#include <ntddft.h>


UCHAR
QueryDriveLetter(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    UCHAR                       c;
    TCHAR                       name[80];
    TCHAR                       result[80];
    TCHAR                       num[10];
    DWORD                       i, j;
    HANDLE                      h;
    BOOL                        b;
    DWORD                       bytes;
    PARTITION_INFORMATION       partInfo;
    DWORD                       em;

    layout = MALLOC(4096);
    if (!layout) {
        return 0;
    }

    em = SetErrorMode(0);
    SetErrorMode( em | SEM_FAILCRITICALERRORS );

    for (c = 'C'; c <= 'Z'; c++) {

        name[0] = (TCHAR)c;
        name[1] = (TCHAR)':';
        name[2] = (TCHAR)'\0';

        if (QueryDosDevice(name, result, ARRAYSIZE(result)) < 17) {
            continue;
        }

        j = 0;
        for (i = 16; result[i] && j < ARRAYSIZE(num); i++) {
            if (result[i] == (TCHAR)'\\') {
                break;
            }
            num[j++] = result[i];
        }
        if(j == ARRAYSIZE(num)){
            continue;// or return 0;
        }

        num[j] = (TCHAR)'\0';

        wsprintf(name, TEXT("\\\\.\\PhysicalDrive%s"), num);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, layout,
                            4096, &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (layout->Signature != Signature) {
            continue;
        }

        wsprintf(name, TEXT("\\\\.\\%c:"), c);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (partInfo.StartingOffset.QuadPart == Offset) {
            break;
        }
    }

    FREE(layout);

    SetErrorMode( em );

    return (c <= 'Z') ? c : 0;
}


VOID
ForceStickyDriveLetters(
    )

{
    LONG                error;
    HKEY                key;
    TCHAR               name[10];
    UCHAR               driveLetter;
    UINT                driveType;
    TCHAR               targetPath[MAX_PATH];
    DWORD               type;
    DWORD               size;
    PBYTE               registryValue;
    PDISK_CONFIG_HEADER header;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    ULONG               i, j;
    PDISK_PARTITION     diskPartition;
    DWORD d;

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\DISK"), 0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE, &key);
    if (error != ERROR_SUCCESS) {
#ifdef _X86_ 
	if (IsNEC98() && Upgrade){
	    error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				   TEXT("SYSTEM\\DISK"),
				   0,
				   NULL,
				   REG_OPTION_NON_VOLATILE,
				   KEY_QUERY_VALUE | KEY_SET_VALUE,
				   NULL,
				   &key,
				   &d
		);
	    if (error != ERROR_SUCCESS) {
		return;
	    }
	}else{
	    return;
	}
#else
        return;
#endif
    }

    name[1] = (TCHAR)':';
    name[2] = (TCHAR)'\\';
    name[3] = (TCHAR)'\0';
    for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
        name[0] = (TCHAR)driveLetter;
        name[2] = (TCHAR)'\\';
        driveType = GetDriveType(name);
        if (driveType != DRIVE_REMOVABLE && driveType != DRIVE_CDROM) {
            continue;
        }

        name[2] = (TCHAR)'\0';
        if (!QueryDosDevice(name, targetPath, MAX_PATH)) {
            continue;
        }

        RegSetValueEx(key, targetPath, 0, REG_SZ, (PBYTE)name, 3*sizeof(TCHAR));
    }

    error = RegQueryValueEx(key, TEXT("Information"), NULL, &type, NULL,
                            &size);
    if (error != ERROR_SUCCESS) {
        RegCloseKey(key);
        return;
    }

    registryValue = MALLOC(size);
    if (!registryValue) {
        RegCloseKey(key);
        return;
    }

    error = RegQueryValueEx(key, TEXT("Information"), NULL, &type,
                            registryValue, &size);
    if (error != ERROR_SUCCESS) {
        FREE(registryValue);
        RegCloseKey(key);
        return;
    }

    header = (PDISK_CONFIG_HEADER) registryValue;
    diskRegistry = (PDISK_REGISTRY) ((PCHAR) header +
                                     header->DiskInformationOffset);

    diskDescription = &diskRegistry->Disks[0];
    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {

        for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

            diskPartition = &diskDescription->Partitions[j];

            if (diskPartition->AssignDriveLetter &&
                !diskPartition->DriveLetter) {

                driveLetter = QueryDriveLetter(diskDescription->Signature,
                                               diskPartition->StartingOffset.QuadPart);
                if (driveLetter) {
                    diskPartition->DriveLetter = driveLetter;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    RegSetValueEx(key, TEXT("Information"), 0, type, registryValue, size);

    FREE(registryValue);
    RegCloseKey(key);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\sxs.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntsetup\winnt32\dll\sxs.h

Abstract:

    SideBySide support in the winnt32 phase of ntsetup.

Author:

    Jay Krell (JayKrell) March 2001

Revision History:

Environment:

    winnt32 -- Win9x ANSI (down to Win95gold) or NT Unicode
               libcmt statically linked in, _tcs* ok
--*/
#include "precomp.h"
#pragma hdrstop
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "tchar.h"
#include "sxs.h"
#include "msg.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#define CHECK_FOR_MINIMUM_ASSEMBLIES 0
#define CHECK_FOR_OBSOLETE_ASSEMBLIES 1
#define EMPTY_LEAF_DIRECTORIES_ARE_OK 1

const static TCHAR rgchPathSeperators[] = TEXT("\\/");

#define PRESERVE_LAST_ERROR(code) \
    do { DWORD PreserveLastError = Success ? NO_ERROR : GetLastError(); \
        do { code ; } while(0); \
        if (!Success) SetLastError(PreserveLastError); \
    } while(0)

#define StringLength    _tcslen
#define StringCopy      _tcscpy
#define StringAppend    _tcscat
#define FindLastChar    _tcsrchr

BOOL
SxspIsPathSeperator(
    TCHAR ch
    )
{
    return (_tcschr(rgchPathSeperators, ch) != NULL);
}

VOID
__cdecl
SxspDebugOut(
    LPCTSTR Format,
    ...
    )
{
    //
    // DebugLog directly doesn't quite work out, because
    // it wants %1 formatting, where we have GetLastError().
    // Unless we duplicate all of our messages..
    //
    TCHAR Buffer[2000];
    va_list args;
    const BOOL Success = TRUE; // PRESERVE_LAST_ERROR

    Buffer[0] = 0;

    va_start(args, Format);
#pragma prefast(suppress:53, Buffer is always nul-terminated)
    _vsntprintf(Buffer, NUMBER_OF(Buffer), Format, args);
    va_end(args);
    if (Buffer[0] != 0)
    {
        LPTSTR End;
        SIZE_T Length;

        Buffer[NUMBER_OF(Buffer) - 1] = 0;

        PRESERVE_LAST_ERROR(OutputDebugString(Buffer));

        Length = StringLength(Buffer);
        End = Buffer + Length - 1;
        while (*End == ' ' || *End == '\t' || *End == '\n' || *End == '\r')
            *End-- = 0;
        DebugLog(Winnt32LogError, TEXT("%1"), 0, Buffer);
    }
}

VOID
SxspRemoveTrailingPathSeperators(
    LPTSTR s
    )
{
    if (s != NULL && s[0] != 0)
    {
        LPTSTR t;
        //
        // This is inefficient, in order to be mbcs correct,
        // but there aren't likely to be more than one or two.
        //
        while ((t = _tcsrchr(s, rgchPathSeperators[0])) != NULL && *(t + 1) == 0)
        {
            *t = 0;
        }
    }
}

VOID
SxspGetPathBaseName(
    LPCTSTR Path,
    LPTSTR  Base
    )
{
    LPCTSTR Dot = FindLastChar(Path, '.');
    LPCTSTR Slash = FindLastChar(Path, rgchPathSeperators[0]);
    //
    // beware \foo.txt\bar
    // beware \bar
    // beware bar
    // beware .bar
    // beware \.bar
    //
    *Base = 0;
    if (Slash == NULL)
        Slash = Path;
    else
        Slash += 1;
    if (Dot == NULL || Dot < Slash)
        Dot = Path + StringLength(Path);
    CopyMemory(Base, Slash, (Dot - Slash) * sizeof(*Base));
    Base[Dot - Slash] = 0;
}

BOOL
SxspIsDotOrDotDot(
    PCTSTR s
    )
{
    return (s[0] == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)));
}

const static LPCTSTR DotManifestExtensions[] =
    { TEXT(".Man"), TEXT(".Dll"), TEXT(".Manifest"), TEXT(".Policy") };
const static LPCTSTR DotCatalogExtensions[] = { TEXT(".Cat") };

BOOL
SxspGetSameNamedFileWithExtensionFromList(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR         Directory,
    CONST LPCTSTR   Extensions[],
    SIZE_T          NumberOfExtensions,
    LPTSTR          File
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspGetSameNamedFileWithExtensionFromList");
    LPTSTR FileEnd = NULL;
    PTSTR Base = NULL;
    DWORD FileAttributes = 0;
    SIZE_T i = 0;
    BOOL Success = FALSE;

    File[0] = 0;

    StringCopy(File, Directory);
    SxspRemoveTrailingPathSeperators(File);
    Base = File + StringLength(File) + 1;
    SxspGetPathBaseName(Directory, Base);
    Base[-1] = rgchPathSeperators[0];
    FileEnd = Base + StringLength(Base);

    for (i = 0 ; i != NumberOfExtensions ; ++i)
    {
        StringCopy(FileEnd, Extensions[i]);
        FileAttributes = GetFileAttributes(File);
        if (FileAttributes != INVALID_FILE_ATTRIBUTES)
        {
            if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                return TRUE;
            }
        }
        else
        {
            const DWORD LastError = GetLastError();
            if (LastError != ERROR_FILE_NOT_FOUND
                && LastError != ERROR_PATH_NOT_FOUND
                )
            {
                SxspDebugOut(
                    TEXT("SXS: %s(%s):GetFileAttributes(%s):%lu\n"),
                    T_FUNCTION,
                    Directory,
                    File,
                    LastError
                    );
                MessageBoxFromMessage(
                    Context->ParentWindow,
                    LastError,
                    TRUE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
                File[0] = 0;
                Success = FALSE;
                goto Exit;
            }
        }
    }
    File[0] = 0;
    Success = TRUE;
Exit:
    return Success;
}

BOOL
SxspCheckFile(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR File
    )
{
    BYTE        Buffer[512];
    static BYTE Zeroes[sizeof(Buffer)];
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesRead = 0;
    BOOL Success = FALSE;

    FileHandle = CreateFile(
        File,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(TEXT("SXS: unable to open file %s, error %lu\n"), File, LastError);
        MessageBoxFromMessageAndSystemError(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_OPEN_FAILED,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    if (!ReadFile(FileHandle, Buffer, sizeof(Buffer), &BytesRead, NULL))
    {
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(TEXT("SXS: ReadFile(%s) failed %lu\n"), File, LastError);
        MessageBoxFromMessageAndSystemError(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_READ_FAILED,
            LastError,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    if (memcmp(Buffer, Zeroes, BytesRead) == 0)
    {
        SxspDebugOut(TEXT("SXS: File %s is all zeroes\n"), File);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_IS_ALL_ZEROES,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    Success = TRUE;
Exit:
    if (FileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(FileHandle);
    return Success;
}

BOOL
SxspCheckLeafDirectory(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR Directory
    )
{
    TCHAR File[MAX_PATH];
    BOOL Success = TRUE; // NOTE backwardness
    const static struct {
        const LPCTSTR* Extensions;
        SIZE_T  NumberOfExtensions;
        ULONG   Error;
    } x[] = {
        {
            DotManifestExtensions,
            NUMBER_OF(DotManifestExtensions),
            MSG_SXS_ERROR_DIRECTORY_IS_MISSING_MANIFEST
        },
        {
            DotCatalogExtensions,
            NUMBER_OF(DotCatalogExtensions),
            MSG_SXS_ERROR_DIRECTORY_IS_MISSING_CATALOG
        }
    };
    SIZE_T i;

    for (i = 0 ; i != NUMBER_OF(x) ; ++i)
    {
        if (SxspGetSameNamedFileWithExtensionFromList(Context, Directory, x[i].Extensions, x[i].NumberOfExtensions, File))
        {
            if (File[0] == 0)
            {
                TCHAR Base[MAX_PATH];

                SxspGetPathBaseName(Directory, Base);

                SxspDebugOut(TEXT("SXS: Missing manifest or catalog in %s\n"), Directory);

                MessageBoxFromMessage(
                    Context->ParentWindow,
                    x[i].Error,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    Directory,
                    Base
                    );
                Success = FALSE;
                //goto Exit;
                // keep looping, to possibly report more errors (manifest and catalog)
            }
            else
            {
                if (!SxspCheckFile(Context, File))
                    Success = FALSE;
                // keep looping, to possibly report more errors
            }
        }
    }
    // NOTE don't set Success = TRUE here.
//Exit:
    return Success;
}

BOOL
SxspFindAndCheckLeaves(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPTSTR                          Directory,
    SIZE_T                          DirectoryLength,
    LPWIN32_FIND_DATA               FindData
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspFindAndCheckLeaves");
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    BOOL   ChildrenDirectories = FALSE;
    BOOL   ChildrenFiles = FALSE;
    BOOL   Success = TRUE;

    //
    // first enumerate looking for any directories
    // recurse on each one
    // if none found, check it as a leaf
    //
    ConcatenatePaths(Directory, TEXT("*"), MAX_PATH);
    FindHandle = FindFirstFile(Directory, FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        CONST DWORD LastError = GetLastError();
        //
        // we already did a successful GetFileAttributes on this and
        // found it was a directory, so no error is expected here
        //
        SxspDebugOut(
            TEXT("SXS: %s(%s),FindFirstFile:%d\n"),
            T_FUNCTION, Directory, LastError
            );
        MessageBoxFromMessage(
            Context->ParentWindow,
            LastError,
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        Success = FALSE;
        goto Exit;
    }
    else
    {
        do
        {
            if (SxspIsDotOrDotDot(FindData->cFileName))
                continue;
            if (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                ChildrenDirectories = TRUE;
                Directory[DirectoryLength] = 0;
                ConcatenatePaths(Directory, FindData->cFileName, MAX_PATH);
                if (!SxspFindAndCheckLeaves(
                    Context,
                    Directory,
                    StringLength(Directory),
                    FindData
                    ))
                {
                    Success = FALSE;
                    // keep looping, in order to possibly report more errors
                }
            }
            else
            {
                ChildrenFiles = TRUE;
            }
        }
        while (FindNextFile(FindHandle, FindData));
        FindClose(FindHandle);
    }
    if (!ChildrenDirectories
#if EMPTY_LEAF_DIRECTORIES_ARE_OK /* currently yes */
        && ChildrenFiles
#endif
        )
    {
        Directory[DirectoryLength] = 0;
        if (!SxspCheckLeafDirectory(Context, Directory))
            Success = FALSE;
    }
#if !EMPTY_LEAF_DIRECTORIES_ARE_OK /* currently no */
    if (!ChildrenDirectories && !ChildrenFiles)
    {
        // report an error
    }
#endif
    // NOTE do not set Success = TRUE here
Exit:
    return Success;
}

#if CHECK_FOR_MINIMUM_ASSEMBLIES /* 0 */
//
// This data is very specific to Windows 5.1.
//
// All of these should be under all roots, assuming
// corporate deployers do not add roots to dosnet.inf.
//
const static LPCTSTR MinimumAssemblies[] =
{
    TEXT("6000\\Msft\\Windows\\Common\\Controls"),
    TEXT("1000\\Msft\\Windows\\GdiPlus"),
    TEXT("5100\\Msft\\Windows\\System\\Default")
};

#endif

#if CHECK_FOR_OBSOLETE_ASSEMBLIES

//
// This data is specific to Windows 5.1.
//
// None of these should be under any root, assuming
// corporate deployers don't use these names.
//
// People internally end up with obsolete assemblies because they
// copy newer drops on top of older drops, without deleting what is
// no longer in the drop.
//
const static LPCTSTR ObsoleteAssemblies[] =
{
    // This assembly was reversioned very early in its life, from 1.0.0.0 to 5.1.0.0.
    TEXT("1000\\Msft\\Windows\\System\\Default")
};

#endif

BOOL
SxspCheckRoot(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR                 Root
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspCheckRoot");
    DWORD FileAttributes = 0;
    DWORD LastError = 0;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    TCHAR RootStar[MAX_PATH];
    SIZE_T RootLength = 0;
    BOOL Empty = TRUE;
    BOOL Success = TRUE; // NOTE the backwardness
    SIZE_T i = 0;

    StringCopy(RootStar, Root);
    RootLength = StringLength(Root);

    //
    // check that the root exists
    //
    FileAttributes = GetFileAttributes(Root);
    if (FileAttributes == INVALID_FILE_ATTRIBUTES)
    {
        Success = FALSE;
        LastError = GetLastError();

        //
        // If the root is not found, then this isn't an error - there's just no 'asms'
        // to install (ie: they all got mushed into a cab)
        //
        if ((LastError == ERROR_FILE_NOT_FOUND) || (LastError == ERROR_PATH_NOT_FOUND))
        {
            LastError = ERROR_SUCCESS;
            SxspDebugOut(TEXT("SXS: (%s) - Directory %s does not exist, assuming no asms present.\n"),
                T_FUNCTION, Root);
                
            Success = TRUE;
            goto Exit;
        }
        
        SxspDebugOut(
            TEXT("SXS: %s(%s),GetFileAttributes:%d\n"),
            T_FUNCTION, Root, LastError
            );
        //if (LastError == ERROR_FILE_NOT_FOUND || LastError == ERROR_PATH_NOT_FOUND)
        {
            MessageBoxFromMessageAndSystemError(
                Context->ParentWindow,
                MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING,
                LastError,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                Root
                );
            goto Exit; // abort, otherwise we get many cascades, guaranteed
        }
        //else
        {
            /*
            MessageBoxFromMessage(
                Context->ParentWindow,
                LastError,
                TRUE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
            goto Exit;
            */
        }
    }
    //
    // check that the root is a directory
    //
    if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
    {
        SxspDebugOut(TEXT("SXS: %s is file instead of directory\n"), Root);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            Root
            );
        Success = FALSE;
        goto Exit;
    }

#if CHECK_FOR_MINIMUM_ASSEMBLIES /* We do NOT this, it is buggy wrt asms/wasms. */
    //
    // ensure all the mandatory assemblies exist
    // NOTE this check is only partial, but a more complete
    // check will be done when we enumerate and recurse
    //
    for (i = 0 ; i != NUMBER_OF(MinimumAssemblies) ; ++i)
    {
        RootStar[RootLength] = 0;
        ConcatenatePaths(RootStar, MinimumAssemblies[i], MAX_PATH);
        FileAttributes = GetFileAttributes(RootStar);
        if (FileAttributes == INVALID_FILE_ATTRIBUTES)
        {
            const DWORD LastError = GetLastError();
            SxspDebugOut(TEXT("SXS: required directory %s missing, or error %lu.\n"), RootStar, LastError);
            MessageBoxFromMessageAndSystemError(
                Context->ParentWindow,
                MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING,
                LastError,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
            // keep running, look for more errors
        }
        if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            SxspDebugOut(TEXT("SXS: %s is file instead of directory\n"), RootStar);
            MessageBoxFromMessage(
                Context->ParentWindow,
                MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
        }
    }
#endif

#if CHECK_FOR_OBSOLETE_ASSEMBLIES /* We do this; it somewhat against longstanding principle. */
    //
    // ensure none of the obsolete assemblies exist
    //
    for (i = 0 ; i != NUMBER_OF(ObsoleteAssemblies) ; ++i)
    {
        RootStar[RootLength] = 0;
        ConcatenatePaths(RootStar, ObsoleteAssemblies[i], MAX_PATH);
        FileAttributes = GetFileAttributes(RootStar);
        if (FileAttributes != INVALID_FILE_ATTRIBUTES)
        {
            //
            // We don't care if it's a file or directory or what
            // the directory contains. It's a fatal error no matter what.
            //
            SxspDebugOut(TEXT("SXS: obsolete %s present\n"), RootStar);
            MessageBoxFromMessage(
                Context->ParentWindow,
                MSG_SXS_ERROR_OBSOLETE_DIRECTORY_PRESENT,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
            // keep running, look for more errors
        }
    }
#endif

    //
    // enumerate and recurse
    //
    RootStar[RootLength] = 0;
    StringCopy(RootStar, Root);
    ConcatenatePaths(RootStar, TEXT("*"), MAX_PATH);
    FindHandle = FindFirstFile(RootStar, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // An error here is unexplainable.
        //
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(
            TEXT("SXS: %s(%s), FindFirstFile(%s):%d\n"),
            T_FUNCTION, Root, RootStar, LastError
            );
        MessageBoxFromMessage(
            Context->ParentWindow,
            LastError,
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        Success = FALSE;
        goto Exit;
    }
    do
    {
        if (SxspIsDotOrDotDot(FindData.cFileName))
            continue;
        //
        // REVIEW
        //  I think this is too strict.
        //  Corporate deployers might drop a readme.txt here.
        //
        if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            //RootStar[RootLength] = 0;
            //Context->ReportErrorMessage(Context, MSG_SXS_ERROR_NON_LEAF_DIRECTORY_CONTAINS_FILE, RootStar, FindData.cFileName);
        }
        else
        {
            //
            // now enumerate recursively, checking each leaf
            // munge the recursion slightly to save a function and stack space
            //   (usually we'd start at the root, instead of its first generation children)
            //
            Empty = FALSE;
            RootStar[RootLength] = 0;
            ConcatenatePaths(RootStar, FindData.cFileName, MAX_PATH);
            if (!SxspFindAndCheckLeaves(Context, RootStar, StringLength(RootStar), &FindData))
                Success = FALSE;
            // keep looping, to possibly report more errors
        }
    } while(FindNextFile(FindHandle, &FindData));
    FindClose(FindHandle);
    if (Empty)
    {
        SxspDebugOut(TEXT("SXS: directory %s empty\n"), Root);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_DIRECTORY_EMPTY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            Root
            );
        Success = FALSE;
        goto Exit;
    }
Exit:
    return Success;
}

BOOL
SxsCheckLocalSource(
    PSXS_CHECK_LOCAL_SOURCE Parameters
    )
/*
Late in winnt32
    enumerate ~ls\...\asms
    ensure asms is a directory
    ensure that everything one level down in asms is a directory (I didn't do this, seems too strict).
    enumerate asms recursively
    ensure every leaf directory has a .cat with the same base name as the directory
    ensure every leaf directory has a .man or .manifest with the same base name as the directory
    Read the first 512 bytes of every .cat/.man/.manifest.
        Ensure that they are not all zero.

    REVIEW also that required exist and obsolete assemblies do not
*/
{
    ULONG i;
    TCHAR FullPath[MAX_PATH];
    BOOL Success = TRUE;
    TCHAR LocalSourceDrive;

    //
    // ensure LocalSource is present/valid
    //
    if (!MakeLocalSource)
        return TRUE;
    LocalSourceDrive = (TCHAR)towupper(LocalSourceDirectory[0]);
    if (LocalSourceDrive != towupper(LocalSourceWithPlatform[0]))
        return TRUE;
    if (LocalSourceDrive < 'C' || LocalSourceDrive > 'Z')
        return TRUE;

    //
    // flush LocalSource where the Win32 api is simple (NT, not Win9x)
    //
    if (ISNT())
    {
        CONST TCHAR LocalSourceDrivePath[] = { '\\', '\\', '.', '\\', LocalSourceDrive, ':', 0 };
        CONST HANDLE LocalSourceDriveHandle =
            CreateFile(
                LocalSourceDrivePath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                NULL
                );
        if (LocalSourceDriveHandle != INVALID_HANDLE_VALUE)
        {
            FlushFileBuffers(LocalSourceDriveHandle);
            CloseHandle(LocalSourceDriveHandle);
        }
    }
    for(i = 0; i != OptionalDirectoryCount; ++i)
    {
        if ((OptionalDirectoryFlags[i] & OPTDIR_SIDE_BY_SIDE) != 0)
        {
            MYASSERT(
                (OptionalDirectoryFlags[i] & OPTDIR_PLATFORM_INDEP)
                ^ (OptionalDirectoryFlags[i] & OPTDIR_ADDSRCARCH)
                );
            switch (OptionalDirectoryFlags[i] & (OPTDIR_PLATFORM_INDEP | OPTDIR_ADDSRCARCH))
            {
            case OPTDIR_ADDSRCARCH:
                StringCopy(FullPath, LocalSourceWithPlatform);
                break;
            case OPTDIR_PLATFORM_INDEP:
                StringCopy(FullPath, LocalSourceDirectory);
                break;
            }
            ConcatenatePaths(FullPath, OptionalDirectories[i], MAX_PATH);
            if (!SxspCheckRoot(Parameters, FullPath))
                Success = FALSE;
                // keep looping, to possibly report more errors
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\util.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Interface for utility functions

Author:

    Ovidiu Temereanca (ovidiut) 08-Nov-2000

Revision History:

    <alias>  <date>      <comment>

--*/


typedef struct tagGENERIC_LIST {
    struct tagGENERIC_LIST* Next;
} GENERIC_LIST, *PGENERIC_LIST;

typedef struct tagSTRINGLIST {
    struct tagSTRINGLIST* Next;
    PTSTR String;
} STRINGLIST, *PSTRINGLIST;

typedef struct tagSDLIST {
    struct tagSDLIST* Next;
    PTSTR String;
    DWORD_PTR Data;
} SDLIST, *PSDLIST;


typedef struct {
    PTSTR FileName;
    TCHAR FullPath[MAX_PATH];
    WIN32_FIND_DATA FindData;
    //
    // private data
    //
    HANDLE Handle;
} FILEPATTERN_ENUM, *PFILEPATTERN_ENUM;


#define ENUM_FIRSTFILE  1
#define ENUM_NEXTFILE   2
#define ENUM_SUBDIRS    3
#define ENUM_SUBDIR     4

typedef struct tagFILEENUMLIST {
    struct tagFILEENUMLIST* Next;
    PTSTR Dir;
    DWORD EnumState;
    FILEPATTERN_ENUM Enum;
} FILEENUMLIST, *PFILEENUMLIST;


#define ECF_ENUM_SUBDIRS        0x0001
#define ECF_ABORT_ENUM_DIR      0x0002
#define ECF_STOP_ON_LONG_PATHS  0x0004


typedef struct {
    PTSTR FileName;
    PTSTR SubPath;
    PTSTR FullPath;
    PWIN32_FIND_DATA FindData;
    DWORD ControlFlags;
    //
    // private data
    //
    PCTSTR FilePattern;
    DWORD RootLen;
    PFILEENUMLIST DirCurrent;
    HANDLE Handle;
} FILEPATTERNREC_ENUM, *PFILEPATTERNREC_ENUM;



PTSTR
BuildPathEx (
    IN      PTSTR DestPath,
    IN      DWORD Chars,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );

#define BuildPath(d,p1,p2)  BuildPathEx(d,ARRAYSIZE(d),p1,p2)


PTSTR
DupString (
    IN      PCTSTR String
    );

PTSTR
DupMultiSz (
    IN PCTSTR MultiSz
    );

PTSTR
CreatePrintableString (
    IN      PCTSTR MultiSz
    );

PWSTR
AnsiToUnicode (
    IN      PCSTR SzAnsi
    );

PWSTR
MultiSzAnsiToUnicode (
    IN      PCSTR MultiSzAnsi
    );

PSTR
UnicodeToAnsi (
    IN      PCWSTR Unicode
    );

BOOL
EnumFirstFilePattern (
    OUT     PFILEPATTERN_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern
    );

BOOL
EnumNextFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    );

VOID
AbortEnumFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    );

BOOL
EnumFirstFilePatternRecursive (
    OUT     PFILEPATTERNREC_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD ControlFlags
    );

BOOL
EnumNextFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    );

VOID
AbortEnumFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    );

BOOL
CreateDir (
    IN      PCTSTR DirName
    );

PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    );

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    );

BOOL
FindStringCell (
    IN      PSTRINGLIST StringList,
    IN      PCTSTR String,
    IN      BOOL CaseSensitive
    );

VOID
DeleteStringList (
    IN      PSTRINGLIST List
    );

PFILEENUMLIST
CreateFileEnumCell (
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD Attributes,
    IN      DWORD EnumState
    );

VOID
DeleteFileEnumCell (
    IN      PFILEENUMLIST Cell
    );

BOOL
InsertList (
    IN OUT  PGENERIC_LIST* List,
    IN      PGENERIC_LIST NewList
    );

VOID
DeleteFileEnumList (
    IN      PFILEENUMLIST NewList
    );

PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    );

VOID
GetCurrentWinnt32RegKey (
    OUT     PTSTR Key,
    IN      INT Chars
    );

BOOL
IsFileVersionLesser (
    IN      PCTSTR FileToCompare,
    IN      PCTSTR FileToCompareWith
    );

BOOL
CopyTree (
    IN      PCTSTR SourceRoot,
    IN      PCTSTR DestRoot
    );

BOOL
StringToInt (
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    );

BOOL
CheckForFileVersionEx (
    LPCTSTR FileName,
    LPCTSTR FileVer,                OPTIONAL
    LPCTSTR BinProductVer,          OPTIONAL
    LPCTSTR LinkDate                OPTIONAL
    );

BOOL
GetLinkDate (
    IN      PCTSTR FilePath,
    OUT     PDWORD LinkDate
    );

VOID
FixMissingKnownDlls (
    OUT     PSTRINGLIST* MissingKnownDlls,
    IN      PCTSTR RestrictedCheckList      OPTIONAL
    );

VOID
UndoFixMissingKnownDlls (
    IN      PSTRINGLIST MissingKnownDlls
    );

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    );

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    );

#ifdef UNICODE
#define IsPatternMatch(pattern,string)  IsPatternMatchW(pattern,string)
#else
#define IsPatternMatch(pattern,string)  IsPatternMatchA(pattern,string)
#endif


BOOL
Winnt32GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL
Winnt32GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL
ReplaceSubStr(
    IN OUT LPTSTR SrcStr,
    IN LPTSTR SrcSubStr,
    IN LPTSTR DestSubStr
    );

#ifdef UNICODE

#define Winnt32GetDiskFreeSpaceNew Winnt32GetDiskFreeSpaceNewW

#else

#define Winnt32GetDiskFreeSpaceNew Winnt32GetDiskFreeSpaceNewA

#endif

VOID
RemoveTrailingWack (
    PTSTR String
    );

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    );

DWORD
MyGetFullPathName (
    IN      PCTSTR FileName,    // file name
    IN      DWORD BufferLength, // size of path buffer
    IN      PTSTR Buffer,       // path buffer
    OUT     PTSTR* FilePart     // address of file name in path
    );

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    );

//
// Macro to make ansi vs unicode string handling
// a little easier
//
#ifdef UNICODE
#define NewAnsiString(x)        UnicodeToAnsi(x)
#define NewPortableString(x)    AnsiToUnicode(x)
#else
#define NewAnsiString(x)        DupString(x)
#define NewPortableString(x)    DupString(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\util.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Utilitaries for winnt32.

Author:


Revision History:

    Ovidiu Temereanca (ovidiut) 24-Jul-2000

--*/

#include "precomp.h"
#include <mbstring.h>
#pragma hdrstop


VOID
MyWinHelp(
    IN HWND  Window,
    IN UINT  Command,
    IN ULONG_PTR Data
    )
{
    TCHAR Buffer[MAX_PATH];
    LPTSTR p;
    HANDLE FindHandle;
    BOOL b;
    WIN32_FIND_DATA FindData;
    LPCTSTR HelpFileName = TEXT("winnt32.hlp");

    //
    // The likely scenario is that a user invokes winnt32 from
    // a network share. We'll expect the help file to be there too.
    //
    b = FALSE;
    if(MyGetModuleFileName(NULL,Buffer,ARRAYSIZE(Buffer))
    && (p = _tcsrchr(Buffer,TEXT('\\'))))
    {
        //
        // skip the slash (one TCHAR)
        //
        p++;
        if (SUCCEEDED (StringCchCopy (p, Buffer + ARRAYSIZE(Buffer) - p, HelpFileName))) {

            //
            // See whether the help file is there. If so, use it.
            //
            FindHandle = FindFirstFile(Buffer,&FindData);
            if(FindHandle != INVALID_HANDLE_VALUE) {

                FindClose(FindHandle);
                b = WinHelp(Window,Buffer,Command,Data);
            }
        }
    }

    if(!b) {
        //
        // Try just the base help file name.
        //
        b = WinHelp(Window,HelpFileName,Command,Data);
    }

    if(!b) {
        //
        // Tell user.
        //
        MessageBoxFromMessage(
            Window,
            MSG_CANT_OPEN_HELP_FILE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION,
            HelpFileName
            );
    }
}


BOOL
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    TRUE if the 2 paths were successfully concatenated, without any truncation
    FALSE otherwise

--*/

{
    BOOL NeedBackslash = TRUE;
    PTSTR p;
    BOOL b = FALSE;

    if (!Path1 || BufferSizeChars < 1) {
        MYASSERT (FALSE);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    p = _tcsrchr (Path1, TEXT('\\'));
    if(p && *(++p) == 0) {

        if (p >= Path1 + BufferSizeChars) {
            //
            // buffer already overflowed
            //
            MYASSERT (FALSE);
            SetLastError (ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        NeedBackslash = FALSE;

    } else {
        p = _tcschr (Path1, 0);
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary.
    // We verified above that we have enough space for this
    //
    if(NeedBackslash) {
        *p++ = TEXT('\\');
        *p = 0;
    }

    //
    // Append second part of string to first part if it fits.
    //
    if (Path2) {
        MYASSERT (Path1 + BufferSizeChars >= p);
        if (FAILED (StringCchCopy (p, Path1 + BufferSizeChars - p, Path2))) {
            //
            // why is the buffer so small?
            //
            MYASSERT (FALSE);
            *p = 0;
            return FALSE;
        }
    } else {
        *p = 0;
    }

    return TRUE;
}


LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = MALLOC((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}

PTSTR
DupMultiSz (
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

    Make a duplicate of a MultiSz.

Arguments:

    MultiSz - supplies pointer to the multi-string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCTSTR p;
    PTSTR q;
    DWORD size = sizeof (TCHAR);

    for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
        size += (lstrlen (p) + 1) * sizeof(TCHAR);
    }
    if (q = MALLOC (size)) {
        CopyMemory (q, MultiSz, size);
    }

    return q;
}


PTSTR
CreatePrintableString (
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

    Creates a string of the form (str1, str2, ..., strN) from a MultiSz

Arguments:

    MultiSz - supplies pointer to the MultiSz string to represent.

Return Value:

    Pointer to the new string string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCTSTR p;
    PTSTR q, r;
    DWORD size = 3 * sizeof (TCHAR);

    for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
        size += (lstrlen (p) + 1) * sizeof(TCHAR);
    }
    if (r = MALLOC (size)) {
        q = r;
        *q++ = TEXT('(');
        for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
            if (q - r > 1) {
                *q++ = TEXT(',');
            }
            q += wsprintf (q, TEXT("%s"), p);
        }
        *q++ = TEXT(')');
        *q = 0;
    }
    return r;
}


PSTR
UnicodeToAnsi (
    IN      PCWSTR Unicode
    )

/*++

Routine Description:

    Makes an ANSI duplicate of a UNICODE string.

Arguments:

    Unicode - supplies pointer to the UNICODE string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PSTR p;
    DWORD size;

    if (!Unicode) {
        return NULL;
    }

    size = (lstrlenW (Unicode) + 1) * sizeof(WCHAR);
    if (p = MALLOC (size)) {
        if (!WideCharToMultiByte (
                CP_ACP,
                0,
                Unicode,
                -1,
                p,
                size,
                NULL,
                NULL
                )) {
            FREE (p);
            p = NULL;
        }
    }

    return p;
}


PWSTR
AnsiToUnicode (
    IN      PCSTR SzAnsi
    )

/*++

Routine Description:

    Makes a UNICODE duplicate of an ANSI string.

Arguments:

    SzAnsi - supplies pointer to the ANSI string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PWSTR q;
    DWORD size;

    if (!SzAnsi) {
        return NULL;
    }

    size = strlen (SzAnsi) + 1;

    if (q = MALLOC (size * sizeof(WCHAR))) {
        if (!MultiByteToWideChar (
                CP_ACP,
                0,
                SzAnsi,
                size,
                q,
                size
                )) {
            FREE (q);
            q = NULL;
        }
    }

    return q;
}

PWSTR
MultiSzAnsiToUnicode (
    IN      PCSTR MultiSzAnsi
    )

/*++

Routine Description:

    Makes a UNICODE duplicate of a multi-sz ANSI string.

Arguments:

    MultiSzAnsi - supplies pointer to the multisz ANSI string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCSTR p;
    PWSTR q;
    DWORD size = 1;

    if (!MultiSzAnsi) {
        return NULL;
    }

    for (p = MultiSzAnsi; *p; p = _mbschr (p, 0) + 1) {
        size += strlen (p) + 1;
    }

    if (q = MALLOC (size * sizeof(WCHAR))) {
        if (!MultiByteToWideChar (
                CP_ACP,
                0,
                MultiSzAnsi,
                size,
                q,
                size
                )) {
            FREE (q);
            q = NULL;
        }
    }

    return q;
}


UINT
MyGetDriveType(
    IN      TCHAR Drive
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    Drive - supplies drive letter whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    //
    MYASSERT (Drive);

    DriveName[0] = Drive;
    rc = GetDriveType(DriveName);

#ifdef _X86_ //NEC98
    //
    // NT5 for NEC98 can not access AT formated HD during setup.
    // We need except these type.
    if (IsNEC98() && ISNT() && (rc == DRIVE_FIXED) && BuildNumber <= NT40) {
        //
        // Check ATA Card?
        //
        {
            HANDLE hDisk;

            DriveNameNt[4] = Drive;
            hDisk =   CreateFile( DriveNameNt,
                                  GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hDisk == INVALID_HANDLE_VALUE) {
                return(DRIVE_UNKNOWN);
            }
            if (CheckATACardonNT4(hDisk)){
                CloseHandle(hDisk);
                return(DRIVE_REMOVABLE);
            }
            CloseHandle(hDisk);
        }
        if (!IsValidDrive(Drive)){
            // HD format is not NEC98 format.
            return(DRIVE_UNKNOWN);
        }
    }
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (!IsNEC98() && (Drive < L'C'))) {
        return(rc);
    }
#else //NEC98
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (Drive < L'C')) {
        return(rc);
    }
#endif

    //
    // DRIVE_REMOVABLE on NT.
    //

    //
    // Disallow use of removable media (e.g. Jazz, Zip, ...).
    //


    DriveNameNt[4] = Drive;

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk != INVALID_HANDLE_VALUE) {

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(MediaInfo),
                &DataSize,
                NULL
                );

        //
        // It's really a hard disk if the media type is removable.
        //
        if(b && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }

        CloseHandle(hDisk);
    }


    return(rc);
}


#ifdef UNICODE

UINT
MyGetDriveType2 (
    IN      PCWSTR NtVolumeName
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    NtVolumeName - supplies device name whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    HANDLE hDisk;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
    Status = NtOpenFile (
                &hDisk,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS( Status )) {
        return DRIVE_NO_ROOT_DIR;
    }

    //
    // Determine if this is a network or disk file system. If it
    // is a disk file system determine if this is removable or not
    //
    Status = NtQueryVolumeInformationFile(
                hDisk,
                &IoStatusBlock,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation
                );
    if (!NT_SUCCESS (Status)) {
        rc = DRIVE_UNKNOWN;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        rc = DRIVE_REMOTE;
    } else {
        switch (DeviceInfo.DeviceType) {

            case FILE_DEVICE_NETWORK:
            case FILE_DEVICE_NETWORK_FILE_SYSTEM:
                rc = DRIVE_REMOTE;
                break;

            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                rc = DRIVE_CDROM;
                break;

            case FILE_DEVICE_VIRTUAL_DISK:
                rc = DRIVE_RAMDISK;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    rc = DRIVE_REMOVABLE;
                } else {
                    rc = DRIVE_FIXED;
                }
                break;

            default:
                rc = DRIVE_UNKNOWN;
                break;
        }
    }

    if(rc == DRIVE_REMOVABLE) {

        //
        // DRIVE_REMOVABLE on NT.
        // Disallow use of removable media (e.g. Jazz, Zip, ...).
        //
        Status = NtDeviceIoControlFile(
                        hDisk,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        &MediaInfo,
                        sizeof(DISK_GEOMETRY)
                        );
        //
        // It's really a hard disk if the media type is removable.
        //
        if(NT_SUCCESS (Status) && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }
    }

    NtClose (hDisk);

    return(rc);
}

#endif

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/

{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    if(!ISNT()) {
        return(FALSE);
    }

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}

#ifdef UNICODE

BOOL
GetPartitionInfo2 (
    IN  PCWSTR                 NtVolumeName,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    NtVolumeName - supplies NT volume name whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    HANDLE hDisk;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL b = FALSE;
    DWORD DataSize;

    //
    // Open the file
    //
    INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
    Status = NtOpenFile (
                &hDisk,
                (ACCESS_MASK)FILE_READ_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    if (NT_SUCCESS (Status)) {

        Status = NtDeviceIoControlFile (
                    hDisk,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_PARTITION_INFO,
                    NULL,
                    0,
                    PartitionInfo,
                    sizeof(PARTITION_INFORMATION)
                    );

        NtClose (hDisk);

        b = NT_SUCCESS (Status);
    }

    return(b);
}

#endif

BOOL
IsDriveNTFT(
    IN      TCHAR Drive,
    IN      PCTSTR NtVolumeName
    )

/*++

Routine Description:

    Determine whether a drive is any kind of NTFT set.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter to check; optional
    NtVolumeName - supplies volume name to check; required if Drive not specified

Return Value:

    Boolean value indicating whether the drive is NTFT.

--*/

{
    PARTITION_INFORMATION PartitionInfo;

    if(!ISNT()) {
        return(FALSE);
    }

    //
    // If we can't open the drive, assume not NTFT.
    //
    if (Drive) {
        if(!GetPartitionInfo(Drive,&PartitionInfo)) {
            return(FALSE);
        }
    } else {
#ifdef UNICODE
        if(!GetPartitionInfo2 (NtVolumeName, &PartitionInfo)) {
            return(FALSE);
        }
#else
        MYASSERT (FALSE);
        return(FALSE);
#endif
    }

    //
    // It's FT if the partition type is marked NTFT (ie, high bit set).
    //

    if((IsRecognizedPartition(PartitionInfo.PartitionType)) &&
       ((PartitionInfo.PartitionType & PARTITION_NTFT) != 0)) {

#if defined(_IA64_)
        //
        // This check is dependant on the EFI system partition type not being
        // a recognized type.  It's unlikely that we'd start recognizing it
        // before we start requiring GPT partitions on the system disk, but
        // just in case we'll assert before returning true for an ESP.
        //

        ASSERT(PartitionInfo.PartitionType != 0xef);
#endif

        return TRUE;
    } else {

        return FALSE;
    }
}


BOOL
IsDriveVeritas(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
{
    TCHAR name[3];
    TCHAR Target[MAX_PATH];

    if(ISNT()) {
        //
        // Check for Veritas volume, which links to \Device\HarddiskDmVolumes...
        //
        if (Drive) {
            name[0] = Drive;
            name[1] = TEXT(':');
            name[2] = 0;
            if(!QueryDosDevice(name,Target,MAX_PATH)) {
                return FALSE;
            }
        } else {
            lstrcpy (Target, NtVolumeName);
        }
        if(!_tcsnicmp(Target,TEXT("\\Device\\HarddiskDm"),ARRAYSIZE("\\Device\\HarddiskDm") - 1)) {
            return(TRUE);
        }
    }
    return(FALSE);
}


//
// Get Harddisk BPS
// I970721
//
ULONG
GetHDBps(
    HANDLE hDisk
    )
{
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    b = DeviceIoControl(
           hDisk,
           IOCTL_DISK_GET_DRIVE_GEOMETRY,
           NULL,
           0,
           &MediaInfo,
           sizeof(MediaInfo),
           &DataSize,
           NULL
           );

    if(!b) {
       return(0);
    } else {
        return(MediaInfo.BytesPerSector);
    }

}


#ifdef UNICODE

#ifdef _WIN64

//
// define IOCTL_VOLUME_IS_PARTITION since we don't include ntddvol.h
//
#define IOCTL_VOLUME_IS_PARTITION CTL_CODE(IOCTL_VOLUME_BASE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
/*++

Routine Description:

    Finds out whether the given volume is soft partition
    or not (i.e. does it have an underlying partition).

    NOTE : We just use the IOCTL_VOLUME_IS_PARTITION.

Arguments:

    Drive - supplies drive letter for the volume

    NtVolumeName - supplies NT volume name


Return Value:

    TRUE if the volume is soft partition otherwise FALSE.

--*/

{
    BOOL SoftPartition;
    HANDLE VolumeHandle = INVALID_HANDLE_VALUE;
    ULONG DataSize;

    //
    //  Assume that the partition is a soft one.
    //  If we cannot determine whether or not the partition is a soft partition, then assume it is a soft
    //  partition. This will prevent us from placing $win_nt$.~ls in such a drive.
    //
    SoftPartition = TRUE;

    if (Drive) {
        TCHAR Name[] = TEXT("\\\\.\\?:");
        BOOL Result;

        Name[4] = Drive;

        VolumeHandle = CreateFile(Name,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            INVALID_HANDLE_VALUE);

        if (VolumeHandle != INVALID_HANDLE_VALUE) {
            Result = DeviceIoControl(VolumeHandle,
                        IOCTL_VOLUME_IS_PARTITION,
                        NULL,
                        0,
                        NULL,
                        0,
                        &DataSize,
                        NULL);

            SoftPartition = !Result;

            CloseHandle(VolumeHandle);
        }
    } else {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        UNICODE_STRING DeviceName;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Open the file
        //
        INIT_OBJA (&Obja, &DeviceName, NtVolumeName);

        Status = NtOpenFile (&VolumeHandle,
                    (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);

        if (NT_SUCCESS (Status)) {
            Status = NtDeviceIoControlFile(VolumeHandle,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_VOLUME_IS_PARTITION,
                            NULL,
                            0,
                            NULL,
                            0);

            if (NT_SUCCESS(Status)) {
                SoftPartition = FALSE;
            }

            NtClose(VolumeHandle);
        }
    }

    return SoftPartition;
}

#else

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
{
    TCHAR                       name[] = TEXT("\\\\.\\?:");
    PARTITION_INFORMATION       partInfo;
    DWORD                       bytes;
    BOOL                        SoftPartition = TRUE;
    BOOL                        b;
    HANDLE                      h = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    LARGE_INTEGER               SoftPartitionStartingOffset;
    ULONG                       bps;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    if( !IsDriveVeritas( Drive, NtVolumeName ) ) {
        return( FALSE );
    }
    //
    //  Assume that the partition is a soft one.
    //  If we cannot determine whether or not the partition is a soft partition, then assume it is a soft
    //  partition. This will prevent us from placing $win_nt$.~ls in such a drive.
    //
    SoftPartition = TRUE;

    if (Drive) {
        name[4] = Drive;

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
#if DBG
            GetLastError();
#endif
            goto Exit;
        }

        b = DeviceIoControl(
               h,
               IOCTL_DISK_GET_DRIVE_GEOMETRY,
               NULL,
               0,
               &MediaInfo,
               sizeof(MediaInfo),
               &DataSize,
               NULL
               );

        if(!b) {
#if DBG
            GetLastError();
#endif
            goto CleanUp;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        if (!b) {
#if DBG
            GetLastError();
#endif
            goto CleanUp;
        }

    } else {
        //
        // Open the file
        //
        INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
        Status = NtOpenFile (
                    &h,
                    (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );
        if (!NT_SUCCESS (Status)) {
            goto Exit;
        }
        Status = NtDeviceIoControlFile(
                        h,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        &MediaInfo,
                        sizeof(DISK_GEOMETRY)
                        );
        if (!NT_SUCCESS (Status)) {
            goto CleanUp;
        }
        Status = NtDeviceIoControlFile(
                        h,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0,
                        &partInfo,
                        sizeof(PARTITION_INFORMATION)
                        );
        if (!NT_SUCCESS (Status)) {
            goto CleanUp;
        }
    }

    bps = MediaInfo.BytesPerSector;

    //
    //  Find out the number of bytes per sector of the drive
    //
    //
    //   A soft partition always starts at sector 29 (0x1d)
    //
    SoftPartitionStartingOffset.QuadPart = 29*bps;
    SoftPartition = ( partInfo.StartingOffset.QuadPart == SoftPartitionStartingOffset.QuadPart );

CleanUp:
    if (Drive) {
        CloseHandle(h);
    } else {
        NtClose (h);
    }
Exit:
    return( SoftPartition );
}

#endif // WIN64

BOOL
MyGetDiskFreeSpace (
    IN      PCWSTR NtVolumeName,
    IN      PDWORD SectorsPerCluster,
    IN      PDWORD BytesPerSector,
    IN      PDWORD NumberOfFreeClusters,
    IN      PDWORD TotalNumberOfClusters
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING VolumeName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;

    INIT_OBJA (&Obja, &VolumeName, NtVolumeName);

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    //
    // Determine the size parameters of the volume.
    //
    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (SizeInfo.TotalAllocationUnits.HighPart) {
        SizeInfo.TotalAllocationUnits.LowPart = (ULONG)-1;
    }
    if (SizeInfo.AvailableAllocationUnits.HighPart) {
        SizeInfo.AvailableAllocationUnits.LowPart = (ULONG)-1;
    }

    *SectorsPerCluster = SizeInfo.SectorsPerAllocationUnit;
    *BytesPerSector = SizeInfo.BytesPerSector;
    *NumberOfFreeClusters = SizeInfo.AvailableAllocationUnits.LowPart;
    *TotalNumberOfClusters = SizeInfo.TotalAllocationUnits.LowPart;

    return TRUE;
}

#endif


BOOL
IsDriveNTFS(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Determine whether a drive is any kind of NTFT set.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter to check.

Return Value:

    Boolean value indicating whether the drive is NTFT.

--*/

{
    TCHAR       DriveName[4];
    TCHAR       Filesystem[256];
    TCHAR       VolumeName[MAX_PATH];
    DWORD       SerialNumber;
    DWORD       MaxComponent;
    DWORD       Flags;
    BOOL        b;

    if(!ISNT()) {
        return(FALSE);
    }

    MYASSERT (Drive);

    DriveName[0] = Drive;
    DriveName[1] = TEXT(':');
    DriveName[2] = TEXT('\\');
    DriveName[3] = 0;

    b = GetVolumeInformation(
            DriveName,
            VolumeName,
            ARRAYSIZE(VolumeName),
            &SerialNumber,
            &MaxComponent,
            &Flags,
            Filesystem,
            ARRAYSIZE(Filesystem)
            );

    if(!b || !lstrcmpi(Filesystem,TEXT("NTFS"))) {
        return( TRUE );
    }

    return( FALSE );
}


DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}


VOID
GenerateCompressedName(
    IN  LPCTSTR Filename,
    OUT LPTSTR  CompressedName
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise assume there is a 3-character extension and replace the
    third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - receives compressed form. This routine assumes
        that this buffer is MAX_PATH TCHARs in size.

Return Value:

    None.

--*/

{
    LPTSTR p,q;

    //
    // Leave room for the worst case, namely where there's no extension
    // (and we thus have to append ._).
    //
    lstrcpyn(CompressedName,Filename,MAX_PATH-2);

    p = _tcsrchr(CompressedName,TEXT('.'));
    q = _tcsrchr(CompressedName,TEXT('\\'));
    if(q < p) {
        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore. p points to the dot so include that in the length.
        //
        if(lstrlen(p) < 4) {
            lstrcat(CompressedName,TEXT("_"));
        } else {
            //
            // Assume there are 3 characters in the extension and replace
            // the final one with an underscore.
            //
            p[3] = TEXT('_');
            MYASSERT (!p[4]);
        }
    } else {
        //
        // No dot, just add ._.
        //
        lstrcat(CompressedName,TEXT("._"));
    }
}


DWORD
CreateMultiLevelDirectory(
    IN LPCTSTR Directory
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It can handle either paths of form x:... or \\?\Volume{...

Arguments:

    Directory - supplies fully-qualified Win32 pathspec of directory to create

Return Value:

    Win32 error code indicating outcome.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTCHAR p,q;
    TCHAR c;
    BOOL Done;
    DWORD d = ERROR_SUCCESS;
    INT Skip=0;

    if (FAILED(StringCchCopy(Buffer,ARRAYSIZE(Buffer),Directory))) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // If it already exists do nothing. (We do this before syntax checking
    // to allow for remote paths that already exist. This is needed for
    // remote boot machines.)
    //
    d = GetFileAttributes(Buffer);
    if(d != (DWORD)(-1)) {
        return((d & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    //
    // Check path format
    //
    c = (TCHAR)CharUpper((LPTSTR)Buffer[0]);
    if(((c < TEXT('A')) || (c > TEXT('Z')) || (Buffer[1] != TEXT(':'))) && c != TEXT('\\')) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (c != TEXT('\\')) {
        //
        // Ignore drive roots, which we allow to be either x:\ or x:.
        //
        if(Buffer[2] != TEXT('\\')) {
            return(Buffer[2] ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS);
        }
        q = Buffer + 3;
        if(*q == 0) {
            return(ERROR_SUCCESS);
        }
    } else {
        //
        // support \\server\share[\xxx] format
        //
        q = NULL;
        if (Buffer[1] != TEXT('\\') || Buffer[1] != 0 && Buffer[2] == TEXT('\\')) {
            return(ERROR_INVALID_PARAMETER);
        }
        q = _tcschr (&Buffer[2], TEXT('\\'));
        if (!q) {
            return(ERROR_INVALID_PARAMETER);
        }
        if (q[1] == TEXT('\\')) {
            return(ERROR_INVALID_PARAMETER);
        }
        q = _tcschr (&q[1], TEXT('\\'));
        if (!q) {
            return(ERROR_SUCCESS);
        }
        q++;

#ifdef UNICODE
        //
        // Hack to make sure the system partition case works on IA64 (arc)
        // We believe this should be the only case where we use a
        // GlobalRoot style name as the other cases deal with OEM partitions etc.
        // which we should never touch. WE skip over by the length of
        // SystemPartitionVolumeGuid. We take care of the \ present at the end.
        //

        if (SystemPartitionVolumeGuid != NULL && _wcsnicmp (Buffer, SystemPartitionVolumeGuid, (wcslen(SystemPartitionVolumeGuid)-1)) == 0 ){

            Skip = wcslen(SystemPartitionVolumeGuid)-1;


        } else if (_wcsnicmp (Buffer, L"\\\\?\\Volume{", LENGTHOF("\\\\?\\Volume{")) == 0 &&
                   lstrlenW (Buffer) > 47 &&
                   Buffer[47] == L'}') {
            //
            // skip over the VolumeGUID part
            //
            Skip = 48;
        }

        if (Skip > 0) {
            if (Buffer[Skip] == 0) {
                return ERROR_SUCCESS;
            }
            q = Buffer + Skip + 1;
        }

#endif

    }


    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if(p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(CreateDirectory(Buffer,NULL)) {
            d = ERROR_SUCCESS;
        } else {
            d = GetLastError();
            if(d == ERROR_ALREADY_EXISTS) {
                d = ERROR_SUCCESS;
            }
        }

        if(d == ERROR_SUCCESS) {
            //
            // Put back the path sep and move to the next component.
            //
            if(!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while(!Done);

    return(d);
}


BOOL
ForceFileNoCompress(
    IN LPCTSTR Filename
    )

/*++

Routine Description:

    This routine makes sure that a file on a volume that supports per-file
    compression is not compressed. The caller need not ensure that the volume
    actually supports this, since this routine will query the attributes of
    the file before deciding whether any operation is actually necessary,
    and the compressed attribute will not be set on volumes that don't support
    per-file compression.

    It assumed that the file exists. If the file does not exist, this routine
    will fail.

Arguments:

    Filename - supplies the filename of the file to mke uncompressed.

Return Value:

    Boolean value indicating outcome. If FALSE, last error is set.

--*/

{
    ULONG d;
    HANDLE h;
    BOOL b;
    USHORT u;
    DWORD Attributes;

    Attributes = GetFileAttributes(Filename);
    if(Attributes == (DWORD)(-1)) {
        return(FALSE);
    }

    if(!(Attributes & FILE_ATTRIBUTE_COMPRESSED)) {
        return(TRUE);
    }

    //
    // Temporarily nullify attributes that might prevent opening
    // the file for read-write access.
    //
    // We preserve the 'standard' attributes that the file might have,
    // to be restored later.
    //
    Attributes &= (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE);
    SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);

    h = CreateFile(
            Filename,
            FILE_READ_DATA | FILE_WRITE_DATA,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        SetFileAttributes(Filename,Attributes);
        return(FALSE);
    }

    u = 0;
    b = DeviceIoControl( h,
                         FSCTL_SET_COMPRESSION,
                         &u,
                         sizeof(u),
                         NULL,
                         0,
                         &d,
                         FALSE);
    d = GetLastError();
    CloseHandle(h);
    SetFileAttributes(Filename,Attributes);
    SetLastError(d);

    return(b);
}


BOOL
IsCurrentOsServer(
    void
    )
{
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Size;
    TCHAR Value[100];
    DWORD Type;


    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
            0,
            NULL,
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &d
            );

    if (l != NO_ERROR) {
        return FALSE;
    }

    Size = sizeof(Value);

    l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Value,&Size);

    RegCloseKey(hKey);

    if (l != NO_ERROR) {
        return FALSE;
    }

    if (lstrcmpi(Value,TEXT("winnt")) == 0) {
        return FALSE;
    }

    return TRUE;
}


BOOL
IsCurrentAdvancedServer(
    void
    )
{
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Size;
    TCHAR Value[100];
    DWORD Type;


    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
            0,
            NULL,
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &d
            );

    if (l != NO_ERROR) {
        return FALSE;
    }

    Size = sizeof(Value);

    l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Value,&Size);

    RegCloseKey(hKey);

    if (l != NO_ERROR) {
        return FALSE;
    }

    if (lstrcmpi(Value,TEXT("lanmannt")) == 0) {
        return TRUE;
    }

    return FALSE;
}


BOOL
ConcatenateFile(
    IN      HANDLE OpenFile,
    IN      LPTSTR FileName
    )
/*++

Routine Description:

    This routine will go load the named file, and concatenate its
    contents into the open file.

Arguments:

    OpenFile    Handle to the open file
    FileName    The name of the file we're going to concatenate.

Return Value:

    TRUE        Everything went okay.
    FALSE       We failed.

--*/

{
    DWORD       rc;
    HANDLE      hFile, hFileMapping;
    DWORD       FileSize, BytesWritten;
    PVOID       pFileBase;
    BOOL        ReturnValue = FALSE;

    //
    // Open the file...
    //
    rc = MapFileForRead (
            FileName,
            &FileSize,
            &hFile,
            &hFileMapping,
            &pFileBase
            );
    if (rc == NO_ERROR) {
        //
        // Write the file...
        //
        if (!WriteFile( OpenFile, pFileBase, FileSize, &BytesWritten, NULL )) {
            rc = GetLastError ();
            ReturnValue = FALSE;
        }

        UnmapFile (hFileMapping, pFileBase);
        CloseHandle (hFile);
    }

    if (!ReturnValue) {
        SetLastError (rc);
    }

    return( ReturnValue );
}


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }


    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesDirectoryExist (
    IN      PCTSTR DirSpec
    )

/*++

Routine Description:

    Determine if a directory exists and is accessible.
    This routine works even with the root of drives or with the root of
    network shares (like \\server\share).

Arguments:

    DirSpec - supplies full path of dir to check for existance;

Return Value:

    TRUE if the dir exists and is accessible.

--*/

{
    TCHAR pattern[MAX_PATH];
    BOOL b = FALSE;

    if (DirSpec) {
        if (BuildPathEx (pattern, ARRAYSIZE(pattern), DirSpec, TEXT("*"))) {

            WIN32_FIND_DATA fd;
            UINT oldMode;
            HANDLE h;

            oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

            h = FindFirstFile (pattern, &fd);
            if (h != INVALID_HANDLE_VALUE) {
                FindClose (h);
                b = TRUE;
            }

            SetErrorMode (oldMode);
        }
    }
    return b;
}

#if defined(_AMD64_) || defined(_X86_)

BOOLEAN
IsValidDrive(
    IN      TCHAR Drive
    )

/*++

Routine Description:

    This routine check formatted disk type
    NEC98 of NT4 has supported NEC98 format and PC-AT format.
    But BIOS is handling only NEC98 format.
    So We need setup Boot stuff to ONLY NEC98 formated HD.

Arguments:
    Drive    Drive letter.

Return Value:

    TRUE        Dive is NEC98 format.
    FALSE       Drive is not NEC98 format.

--*/

{
    HANDLE hDisk;
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    PUCHAR pBuffer,pUBuffer;
    WCHAR Buffer[128];
    WCHAR DevicePath[128];
    WCHAR DriveName[3];
    WCHAR DiskNo;
    STORAGE_DEVICE_NUMBER   number;
    PWCHAR p;
    ULONG bps;
    NTSTATUS Sts;
    DWORD DataSize,ExtentSize;
    BOOL b;
    PVOLUME_DISK_EXTENTS Extent;


    if (!ISNT())
        return TRUE;

    HardDiskName[4] = Drive;
    DriveName[0] = Drive;
    DriveName[1] = ':';
    DriveName[2] = 0;
    if(QueryDosDeviceW(DriveName, Buffer, ARRAYSIZE(Buffer))) {
        if (BuildNumber <= NT40){ //check NT Version
            //
            // QueryDosDevice in NT3.51 is buggy.
            // This API return "\\Harddisk\...." or
            // "\\harddisk\...."
            // We need work around.
            //
            p = wcsstr(Buffer, L"arddisk");
            if (!p) {
                return FALSE;
            }
            DiskNo = (*(p + LENGTHOF(L"arddisk")) - 0x30);
        } else {
            hDisk = CreateFile(
                HardDiskName,
                0,
                FILE_SHARE_WRITE, NULL,
                OPEN_EXISTING, 0, NULL
                );
            if(hDisk == INVALID_HANDLE_VALUE) {
                return FALSE;
            }
            b = DeviceIoControl(hDisk, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                            &number, sizeof(number), &DataSize, NULL);
            if (b) {
                DiskNo = (TCHAR) number.DeviceNumber;
            } else {
                Extent = malloc(1024);
                ExtentSize = 1024;
                if(!Extent) {
                    CloseHandle( hDisk );
                    return FALSE;
                }
                b = DeviceIoControl(hDisk, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                    NULL, 0,
                                    (PVOID)Extent, ExtentSize, &DataSize, NULL);
                if (!b) {
                    free(Extent);
                    CloseHandle( hDisk );
                    return FALSE;
                }
                if (Extent->NumberOfDiskExtents != 1){
                    free(Extent);
                    CloseHandle( hDisk );
                    return FALSE;
                }
                DiskNo = (TCHAR)Extent->Extents->DiskNumber;
                free(Extent);
            }
            CloseHandle(hDisk);
        }
        if (FAILED (StringCchPrintfW (DevicePath, ARRAYSIZE(DevicePath), L"\\\\.\\PHYSICALDRIVE%u", DiskNo))) {
            MYASSERT (FALSE);
            return FALSE;
        }
        hDisk =   CreateFileW( DevicePath,
                               GENERIC_READ|GENERIC_WRITE,
                               FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        if ((bps = GetHDBps(hDisk)) == 0){
            CloseHandle(hDisk);
            return FALSE;
        }
        pUBuffer = MALLOC(bps * 2);
        if (!pUBuffer) {
            CloseHandle(hDisk);
            return FALSE;
        }
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps);
        Sts = SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_READSEC);
        if(!NT_SUCCESS(Sts)) {
            FREE(pUBuffer);
            CloseHandle(hDisk);
            return FALSE;
        }
        if (!(pBuffer[4] == 'I'
           && pBuffer[5] == 'P'
           && pBuffer[6] == 'L'
           && pBuffer[7] == '1')){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            return FALSE;
        }
        FREE(pUBuffer);
        CloseHandle(hDisk);
        return TRUE;
    }
    return FALSE;
}

#endif

#ifdef _X86_

BOOLEAN
CheckATACardonNT4(
    IN      HANDLE hDisk
    )
{
//
// NT4, NT3.51 for NEC98.
// NEC98 does not handle to boot from PCMCIA ATA card disk.
// So we need to check ATA Disk.
//
// Return
//         TRUE is ATA Card
//        FALSE is Other
//

#define IOCTL_DISK_GET_FORMAT_MEDIA CTL_CODE(IOCTL_DISK_BASE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define  FORMAT_MEDIA_98      0  // TYPE NEC98
#define  FORMAT_MEDIA_AT      1  // TYPE PC-AT
#define  FORMAT_MEDIA_OTHER   2  // Unknown

    struct _OutBuffer {
        ULONG    CurrentFormatMedia;
        ULONG    InitializeFormatMedia;
    } OutBuffer;
    DWORD ReturnedByteCount;

    if (!(DeviceIoControl(hDisk, IOCTL_DISK_GET_FORMAT_MEDIA,  NULL,
                              0,
                              &OutBuffer,
                              sizeof(struct _OutBuffer),
                              &ReturnedByteCount,
                              NULL
                              ) )){
        return FALSE;
    }

    if (OutBuffer.InitializeFormatMedia == FORMAT_MEDIA_AT){
        return TRUE;
    }
        return FALSE;
}


#endif


BOOL
IsMachineSupported(
    OUT PCOMPATIBILITY_ENTRY CompEntry
    )

/*++

Routine Description:

    This function determines whether or not the machine is supported by the version
    of NT to be installed.

Arguments:

    CompEntry - If the machine is not supported, the Compatability Entry
                is updated to describe why the machine is not supported.

Return Value:

    Boolean value indicating whether the machine is supported.

--*/

{
    TCHAR       SetupLogPath[MAX_PATH];
    TCHAR       KeyName[MAX_PATH];
    TCHAR       HalName[MAX_PATH];
    LPTSTR      p;
    LPTSTR      szHalDll = TEXT("hal.dll");
    LPTSTR      SectionName;
    LPTSTR      UnsupportedName;
    BOOL        b;

    //
    //  Assume that the machine is supported
    //
    b = TRUE;

#ifdef _X86_

    try {
        ULONG Name0, Name1, Name2, Family, Flags;
        _asm {
            push    ebx             ;; save ebx
            mov     eax, 0          ;; get processor vendor
            _emit   00fh            ;; CPUID(0)
            _emit   0a2h            ;;
            mov     Name0,  ebx     ;; Name[0-3]
            mov     Name1,  edx     ;; Name[4-7]
            mov     Name2,  ecx     ;; Name[8-11]
            mov     eax, 1          ;; get family/model/stepping and features
            _emit   00fh            ;; CPUID(1)
            _emit   0a2h
            mov     Family, eax     ;; save family/model/stepping
            mov     Flags, edx      ;; save flags returned by CPUID
            pop     ebx             ;; restore ebx
        }

        //
        // Check the cmpxchg8b flag in the flags returned by CPUID.
        //

        if ((Flags  & 0x100) == 0) {

            //
            // This processor doesn't support the CMPXCHG instruction
            // which is required for Whistler.
            //
            // Some processors actually do support it but claim they
            // don't because of a bug in NT 4.   See if this processor
            // is one of these.
            //

            if (!(((Name0 == 'uneG') &&
                  (Name1 == 'Teni') &&
                  (Name2 == '68xM') &&
                  (Family >= 0x542)) ||
                  (Name0 == 'tneC') &&
                  (Name1 == 'Hrua') &&
                  (Name2 == 'slua') &&
                  (Family >= 0x500))) {
                b = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // If this processor doesn't support CPUID, we don't
        // run on it.
        //

        b = FALSE;
    }

    if (!b) {
        CompEntry->HtmlName = TEXT("cpufeat.htm");
        CompEntry->TextName = TEXT("cpufeat.txt");
        SectionName = TEXT("UnsupportedArchitectures");
        UnsupportedName = TEXT("missprocfeat");
    }

#endif // _X86_

    if( b && ISNT() ) {
        //
        //  Build the path to setup.log
        //
        MyGetWindowsDirectory( SetupLogPath, ARRAYSIZE(SetupLogPath) );
        ConcatenatePaths( SetupLogPath, TEXT("repair\\setup.log"), ARRAYSIZE(SetupLogPath));
        //
        // Find out the actual name of the hal installed
        //

        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            //
            //  On BIOS, look for %windir%\system32\hal.dll in the section
            //  [Files.WinNt]
            //
            GetSystemDirectory( KeyName, MAX_PATH );
            ConcatenatePaths(KeyName, szHalDll, MAX_PATH );
            SectionName = TEXT("Files.WinNt");

            //
            // While we are at it, see if this is Windows 2000 or higher
            // to see if the hal should be preserved or not
            //
#ifdef UNICODE
            if (BUILDNUM() >= 2195) {

                PCHAR   halName;

                halName = FindRealHalName( KeyName );
                if (halName) {

                    WriteAcpiHalValue = TRUE;
#if defined(_AMD64_)
                    if (!strcmp(halName,"hal")) {
#else
                    if (!strcmp(halName,"halacpi") ||
                        !strcmp(halName,"halmacpi") ||
                        !strcmp(halName,"halaacpi")) {
#endif
                        AcpiHalValue = TRUE;
                    }
                }
            }
#endif // UNICODE

#endif // defined(_AMD64_) || defined(_X86_)
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            //  On ARC, look for hal.dll in the section [Files.SystemPartition]
            //
            lstrcpy( KeyName, szHalDll );
            SectionName = TEXT("Files.SystemPartition");
#endif // UNICODE
        } // if (!IsArc())
        GetPrivateProfileString( SectionName,
                                 KeyName,
                                 TEXT(""),
                                 HalName,
                                 sizeof(HalName)/sizeof(TCHAR),
                                 SetupLogPath );
        //
        //  GetPrivateProfileString() will strip the first and last '"' from the logged value,
        //  so find the next '"' character and replace it with NUL, and we will end up with
        //  the actual hal name.
        //
        if( lstrlen(HalName) &&
            ( p = _tcschr( HalName, TEXT('"') ) )
          ) {
            *p = TEXT('\0');
            //
            //  Find out if the hal is listed in [UnsupportedArchitectures] (dosnet.inf)
            //
            SectionName = TEXT("UnsupportedArchitectures");
            b = !InfDoesLineExistInSection( MainInf,
                                            SectionName,
                                            HalName );
            UnsupportedName = HalName;
        }
    }

    //
    // If architecture is not supported, look up the description.
    //

    if( !b ) {
        CompEntry->Description = (LPTSTR)InfGetFieldByKey( MainInf,
                                                           SectionName,
                                                           UnsupportedName,
                                                           0 );
    }
    return( b );
}


BOOL
UnsupportedArchitectureCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )

/*++

Routine Description:

    Check if the machine is no longer supported by Windows NT.
    This routine is meaningful only when run on NT -- it always succeeds
    on Win95.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns always TRUE.

--*/


{
    COMPATIBILITY_ENTRY CompEntry;

    CompEntry.Description = TEXT("MCA");//BUGBUG: must be changed
#ifdef _X86_
    CompEntry.HtmlName = TEXT("mca.htm");
    CompEntry.TextName = TEXT("mca.txt");
#else
    CompEntry.HtmlName = TEXT("");
    CompEntry.TextName = TEXT("");
#endif
    CompEntry.RegKeyName = NULL;
    CompEntry.RegValName = NULL;
    CompEntry.RegValDataSize = 0;
    CompEntry.RegValData = NULL;
    CompEntry.SaveValue = NULL;
    CompEntry.Flags = 0;
    CompEntry.InfName = NULL;
    CompEntry.InfSection = NULL;

    if( !IsMachineSupported( &CompEntry ) ) {
        if(!CompatibilityCallback(&CompEntry, Context)){
            DWORD Error;
            Error = GetLastError();
        }
    }
    return( TRUE );
}


BOOL
GetUserPrintableFileSizeString(
    IN DWORDLONG Size,
    OUT LPTSTR Buffer,
    IN DWORD BufferSize
    )
/*++

Routine Description:

    Takes a size and comes up with a printable version of this size,
    using the appropriate size format (ie., KB, MB, GB, Bytes, etc.)

Arguments:

    Size - size to be converted (in bytes)
    Buffer - string buffer to receive the data
    BufferSize - indicates the buffer size, *in characters*

Return Value:

    TRUE indicates success, FALSE indicates failure.  If we fail,
    call GetLastError() to get extended failure status.

--*/

{
    LPTSTR  NumberString;
    UINT uResource;
    TCHAR ResourceString[100];
    DWORD cb;
    DWORD d;
    BOOL RetVal = FALSE;
    DWORDLONG TopPart;
    DWORDLONG BottomPart;

    //
    // Determine which resource string to use
    //
    if (Size < 1024) {
        uResource = IDS_SIZE_BYTES;
        TopPart = 0;
        BottomPart = 1;
        wsprintf(ResourceString, TEXT("%u"), Size);
    } else if (Size < (1024 * 1024)) {

        uResource = IDS_SIZE_KBYTES;
        TopPart = (Size%1024)*100;
        BottomPart = 1024;

        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD) (Size / 1024),
                 (DWORD)(TopPart/BottomPart));
    } else if (Size < (1024 * 1024 * 1024)) {
        uResource = IDS_SIZE_MBYTES;
        TopPart = (Size%(1024*1024))*100;
        BottomPart = 1024*1024;
        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD)(Size / (1024 * 1024)),
                 (DWORD)(TopPart/BottomPart) );
    } else {
        uResource = IDS_SIZE_GBYTES;
        TopPart = (Size%(1024*1024*1024))*100;
        BottomPart = 1024*1024*1024;
        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD)(Size / (1024 * 1024 * 1024)),
                 (DWORD)(TopPart/BottomPart) );
    }

    // Format the number string
    cb = GetNumberFormat(LOCALE_USER_DEFAULT, 0, ResourceString, NULL, NULL, 0);
    NumberString = (LPTSTR) MALLOC((cb + 1) * sizeof(TCHAR));
    if (!NumberString) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        RetVal = FALSE;
        goto e0;
    }

    if (!GetNumberFormat(LOCALE_USER_DEFAULT, 0, ResourceString, NULL, NumberString, cb)) {
        *NumberString = 0;
    }

    if (!LoadString(hInst, uResource, ResourceString, ARRAYSIZE(ResourceString))) {
        ResourceString[0] = 0;
    }

    RetVal = SUCCEEDED (StringCchPrintf (Buffer, BufferSize, ResourceString, NumberString));
    d = RetVal ? ERROR_SUCCESS : ERROR_INSUFFICIENT_BUFFER;

    FREE(NumberString);
e0:
    SetLastError(d);
    return(RetVal);

}


BOOL
BuildSystemPartitionPathToFile (
    IN      PCTSTR FileName,
    OUT     PTSTR Path,
    IN      INT BufferSizeChars
    )
{
    //
    // must have a root
    //
    if(SystemPartitionDriveLetter) {
        Path[0] = SystemPartitionDriveLetter;
        Path[1] = TEXT(':');
        Path[2] = 0;
    } else {
#ifdef UNICODE
        if (SystemPartitionVolumeGuid) {
            if (FAILED (StringCchCopy (Path, BufferSizeChars, SystemPartitionVolumeGuid))) {
                //
                // why is the buffer so small?
                //
                MYASSERT (FALSE);
                return FALSE;
            }
        }
        else
#endif
        {
            MYASSERT (FALSE);
            return FALSE;
        }
    }
    return ConcatenatePaths (Path, FileName, BufferSizeChars);
}


PTSTR
BuildPathEx (
    IN      PTSTR DestPath,
    IN      DWORD Chars,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )
{
    PTSTR p;
    INT i;
    BOOL haveWack = FALSE;

    p = _tcsrchr (Path1, TEXT('\\'));
    if (p && !p[1]) {
        haveWack = TRUE;
    }
    if (*Path2 == TEXT('\\')) {
        if (haveWack) {
            Path2++;
        } else {
            haveWack = TRUE;
        }
    }
    if (FAILED (StringCchPrintfEx (DestPath, Chars, &p, NULL, STRSAFE_NULL_ON_FAILURE, haveWack ? TEXT("%s%s") : TEXT("%s\\%s"), Path1, Path2))) {
        //
        // why is the buffer so small?
        //
        MYASSERT (Chars > sizeof(PTSTR) / sizeof (TCHAR));
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return NULL;
    }
    return p;
}


BOOL
EnumFirstFilePattern (
    OUT     PFILEPATTERN_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern
    )
{
    TCHAR pattern[MAX_PATH];

    //
    // fail if invalid args are passed in
    // or if [Dir+Backslash] doesn't fit into [Enum->FullPath]
    //
    if (!Dir || !FilePattern || lstrlen (Dir) >= ARRAYSIZE (Enum->FullPath)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!BuildPath (pattern, Dir, FilePattern)) {
        return FALSE;
    }

    Enum->Handle = FindFirstFile (pattern, &Enum->FindData);
    if (Enum->Handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    lstrcpy (Enum->FullPath, Dir);
    //
    // set up other members
    //
    Enum->FileName = _tcschr (Enum->FullPath, 0);
    *Enum->FileName++ = TEXT('\\');
    *Enum->FileName = 0;
    if (FAILED (StringCchCopy (
                    Enum->FileName,
                    ARRAYSIZE (Enum->FullPath) - (Enum->FileName - Enum->FullPath),
                    Enum->FindData.cFileName
                    ))) {
        //
        // file name too long, skip it
        //
        DebugLog (
            Winnt32LogWarning,
            TEXT("Ignoring object %1\\%2 (name too long)"),
            0,
            Enum->FullPath,
            Enum->FindData.cFileName
            );
        return EnumNextFilePattern (Enum);
    }

    if (Enum->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if (!lstrcmp (Enum->FindData.cFileName, TEXT (".")) ||
            !lstrcmp (Enum->FindData.cFileName, TEXT (".."))) {
            return EnumNextFilePattern (Enum);
        }
    }
    return TRUE;
}

BOOL
EnumNextFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    )
{
    while (FindNextFile (Enum->Handle, &Enum->FindData)) {

        if (Enum->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (!lstrcmp (Enum->FindData.cFileName, TEXT (".")) ||
                !lstrcmp (Enum->FindData.cFileName, TEXT (".."))) {
                continue;
            }
        }

        if (FAILED (StringCchCopy (
                        Enum->FileName,
                        ARRAYSIZE (Enum->FullPath) - (Enum->FileName - Enum->FullPath),
                        Enum->FindData.cFileName
                        ))) {
            //
            // file name too long, skip it
            //
            continue;
        }
        //
        // found a valid object, return it
        //
        return TRUE;
    }

    AbortEnumFilePattern (Enum);
    return FALSE;
}

VOID
AbortEnumFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    )
{
    if (Enum->Handle != INVALID_HANDLE_VALUE) {

        //
        // preserve error code
        //
        DWORD rc = GetLastError ();

        FindClose (Enum->Handle);
        Enum->Handle = INVALID_HANDLE_VALUE;

        SetLastError (rc);
    }
}


BOOL
EnumFirstFilePatternRecursive (
    OUT     PFILEPATTERNREC_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD ControlFlags
    )
{
    PFILEENUMLIST dir;

    dir = CreateFileEnumCell (Dir, FilePattern, 0, ENUM_FIRSTFILE);
    if (!dir) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Enum->FilePattern = DupString (FilePattern);
    if (!Enum->FilePattern) {
        DeleteFileEnumCell (dir);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Enum->DirCurrent = dir;
    Enum->FindData = &dir->Enum.FindData;
    Enum->RootLen = lstrlen (Dir) + 1;
    Enum->ControlFlags = ControlFlags;
    Enum->Handle = INVALID_HANDLE_VALUE;
    return EnumNextFilePatternRecursive (Enum);
}

BOOL
EnumNextFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    )
{
    TCHAR pattern[MAX_PATH];
    WIN32_FIND_DATA fd;
    PFILEENUMLIST dir;

    while (Enum->DirCurrent) {
        if (Enum->ControlFlags & ECF_ABORT_ENUM_DIR) {
            //
            // caller wants to abort enum of this subdir
            // remove the current node from list
            //
            Enum->ControlFlags &= ~ECF_ABORT_ENUM_DIR;
            dir = Enum->DirCurrent->Next;
            DeleteFileEnumCell (Enum->DirCurrent);
            Enum->DirCurrent = dir;
            if (dir) {
                Enum->FindData = &dir->Enum.FindData;
            }
            continue;
        }
        switch (Enum->DirCurrent->EnumState) {
        case ENUM_FIRSTFILE:
            if (EnumFirstFilePattern (&Enum->DirCurrent->Enum, Enum->DirCurrent->Dir, Enum->FilePattern)) {
                Enum->DirCurrent->EnumState = ENUM_NEXTFILE;
                Enum->FullPath = Enum->DirCurrent->Enum.FullPath;
                Enum->SubPath = Enum->FullPath + Enum->RootLen;
                Enum->FileName = Enum->DirCurrent->Enum.FileName;
                return TRUE;
            }
            Enum->DirCurrent->EnumState = ENUM_SUBDIRS;
            break;
        case ENUM_NEXTFILE:
            if (EnumNextFilePattern (&Enum->DirCurrent->Enum)) {
                Enum->FullPath = Enum->DirCurrent->Enum.FullPath;
                Enum->SubPath = Enum->FullPath + Enum->RootLen;
                Enum->FileName = Enum->DirCurrent->Enum.FileName;
                return TRUE;
            }
            Enum->DirCurrent->EnumState = ENUM_SUBDIRS;
            //
            // fall through
            //
        case ENUM_SUBDIRS:
            if (BuildPath (pattern, Enum->DirCurrent->Dir, TEXT("*"))) {
                Enum->Handle = FindFirstFile (pattern, &fd);
                if (Enum->Handle != INVALID_HANDLE_VALUE) {
                    do {
                        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                            if (!lstrcmp (fd.cFileName, TEXT (".")) ||
                                !lstrcmp (fd.cFileName, TEXT (".."))) {
                                continue;
                            }
                            if (!BuildPath (pattern, Enum->DirCurrent->Dir, fd.cFileName)) {
                                //
                                // dir name too long
                                //
                                if (Enum->ControlFlags & ECF_STOP_ON_LONG_PATHS) {
                                    AbortEnumFilePatternRecursive (Enum);
                                    //
                                    // error already set by BuildPath
                                    //
                                    return FALSE;
                                }
                                //
                                // just skip it
                                //
                                DebugLog (
                                    Winnt32LogWarning,
                                    TEXT("Ignoring dir %1 (path too long)"),
                                    0,
                                    Enum->DirCurrent->Dir
                                    );
                                continue;
                            }
                            if (!InsertList (
                                    (PGENERIC_LIST*)&Enum->DirCurrent,
                                    (PGENERIC_LIST) CreateFileEnumCell (
                                                        pattern,
                                                        Enum->FilePattern,
                                                        fd.dwFileAttributes,
                                                        Enum->ControlFlags & ECF_ENUM_SUBDIRS ?
                                                            ENUM_SUBDIR : ENUM_FIRSTFILE
                                                        )
                                    )) {
                                AbortEnumFilePatternRecursive (Enum);
                                return FALSE;
                            }
                        }
                    } while (FindNextFile (Enum->Handle, &fd));
                    FindClose (Enum->Handle);
                    Enum->Handle = INVALID_HANDLE_VALUE;
                }
            } else {
                //
                // dir name too long
                //
                if (Enum->ControlFlags & ECF_STOP_ON_LONG_PATHS) {
                    AbortEnumFilePatternRecursive (Enum);
                    //
                    // error already set by BuildPath
                    //
                    return FALSE;
                }
                //
                // just skip it
                //
                DebugLog (
                    Winnt32LogWarning,
                    TEXT("Ignoring dir %1 (path too long)"),
                    0,
                    Enum->DirCurrent->Dir
                    );
            }
            //
            // remove the current node from list
            //
            dir = Enum->DirCurrent->Next;
            DeleteFileEnumCell (Enum->DirCurrent);
            Enum->DirCurrent = dir;
            if (dir) {
                Enum->FindData = &dir->Enum.FindData;
            }
            break;
        case ENUM_SUBDIR:
            Enum->FullPath = Enum->DirCurrent->Dir;
            Enum->SubPath = Enum->FullPath + Enum->RootLen;
            Enum->FileName = _tcsrchr (Enum->FullPath, TEXT('\\')) + 1;
            Enum->DirCurrent->EnumState = ENUM_FIRSTFILE;
            return TRUE;
        }
    }
    return FALSE;
}

VOID
AbortEnumFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    )
{
    //
    // preserve error code
    //
    DWORD rc = GetLastError ();

    if (Enum->DirCurrent) {
        DeleteFileEnumList (Enum->DirCurrent);
        Enum->DirCurrent = NULL;
    }
    if (Enum->Handle != INVALID_HANDLE_VALUE) {
        FindClose (Enum->Handle);
        Enum->Handle = INVALID_HANDLE_VALUE;
    }

    SetLastError (rc);
}


BOOL
CopyTree (
    IN      PCTSTR SourceRoot,
    IN      PCTSTR DestRoot
    )
{
    DWORD rc;
    FILEPATTERNREC_ENUM e;
    TCHAR destFile[MAX_PATH];
    PTSTR p;
    BOOL b = TRUE;

    if (EnumFirstFilePatternRecursive (&e, SourceRoot, TEXT("*"), ECF_STOP_ON_LONG_PATHS)) {
        do {
            if (!BuildPath (destFile, DestRoot, e.SubPath)) {
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                break;
            }
            p = _tcsrchr (destFile, TEXT('\\'));
            if (!p) {
                continue;
            }
            *p = 0;
            rc = CreateMultiLevelDirectory (destFile);
            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                break;
            }
            *p = TEXT('\\');
            SetFileAttributes (destFile, FILE_ATTRIBUTE_NORMAL);
            if (!CopyFile (e.FullPath, destFile, FALSE)) {
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                break;
            }
        } while (EnumNextFilePatternRecursive (&e));
    }

    return b;
}


PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    )
{
    PSTRINGLIST p = MALLOC (sizeof (STRINGLIST));
    if (p) {
        ZeroMemory (p, sizeof (STRINGLIST));
        if (String) {
            p->String = DupString (String);
            if (!p->String) {
                FREE (p);
                p = NULL;
            }
        } else {
            p->String = NULL;
        }
    }
    return p;
}

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    )
{
    if (Cell) {
        FREE (Cell->String);
        FREE (Cell);
    }
}


VOID
DeleteStringList (
    IN      PSTRINGLIST List
    )
{
    PSTRINGLIST p, q;

    for (p = List; p; p = q) {
        q = p->Next;
        DeleteStringCell (p);
    }
}


BOOL
FindStringCell (
    IN      PSTRINGLIST StringList,
    IN      PCTSTR String,
    IN      BOOL CaseSensitive
    )
{
    PSTRINGLIST p;
    INT i;

    if (!StringList || !String) {
        return FALSE;
    }
    for (p = StringList; p; p = p->Next) {
        i = CaseSensitive ? _tcscmp (String, p->String) : _tcsicmp (String, p->String);
        if (i == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

PFILEENUMLIST
CreateFileEnumCell (
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD Attributes,
    IN      DWORD EnumState
    )
{
    PFILEENUMLIST p = MALLOC (sizeof (FILEENUMLIST));
    if (p) {
        ZeroMemory (p, sizeof (FILEENUMLIST));
        p->Enum.FindData.dwFileAttributes = Attributes;
        p->EnumState = EnumState;
        p->Enum.Handle = INVALID_HANDLE_VALUE;
        p->Dir = DupString (Dir);
        if (!p->Dir) {
            FREE (p);
            p = NULL;
        }
    }
    return p;
}

VOID
DeleteFileEnumCell (
    IN      PFILEENUMLIST Cell
    )
{
    if (Cell) {
        FREE (Cell->Dir);
        AbortEnumFilePattern (&Cell->Enum);
        FREE (Cell);
    }
}


BOOL
InsertList (
    IN OUT  PGENERIC_LIST* List,
    IN      PGENERIC_LIST NewList
    )
{
    PGENERIC_LIST p;

    if (!NewList) {
        return FALSE;
    }
    if (*List) {
        for (p = *List; p->Next; p = p->Next) ;
        p->Next = NewList;
    } else {
        *List = NewList;
    }
    return TRUE;
}


VOID
DeleteFileEnumList (
    IN      PFILEENUMLIST NewList
    )
{
    PFILEENUMLIST p, q;

    for (p = NewList; p; p = q) {
        q = p->Next;
        DeleteFileEnumCell (p);
    }
}

PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    )
{
    SIZE_T len1, len2;
    PCTSTR end;

    MYASSERT (Separator);
    MYASSERT (!_istleadbyte (Separator));
    MYASSERT (SubStr);
    MYASSERT (!_tcschr (SubStr, Separator));

    len1 = lstrlen (SubStr);
    MYASSERT (SubStr[len1] == 0);

    while (String) {
        end = _tcschr (String, Separator);
        if (end) {
            len2 = end - String;
        } else {
            len2 = lstrlen (String);
        }
        if ((len1 == len2) &&
            (CaseSensitive ?
                !_tcsncmp (String, SubStr, len1) :
                !_tcsnicmp (String, SubStr, len1)
            )) {
            break;
        }
        if (end) {
            String = end + 1;
        } else {
            String = NULL;
        }
    }

    return String;
}

VOID
GetCurrentWinnt32RegKey (
    OUT     PTSTR Key,
    IN      INT Chars
    )
{
    INT i = _sntprintf (
                Key,
                Chars,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\%u.%u"),
                VER_PRODUCTMAJORVERSION,
                VER_PRODUCTMINORVERSION
                );
    MYASSERT (i > 0);
}


BOOL
GetFileVersionEx (
    IN      PCTSTR FilePath,
    OUT     PTSTR FileVersion,
    IN      INT CchFileVersion
    )
{
    DWORD dwLength, dwTemp;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    BOOL b = FALSE;

    if (FileExists (FilePath, NULL)) {
        if (dwLength = GetFileVersionInfoSize ((PTSTR)FilePath, &dwTemp)) {
            if (lpData = LocalAlloc (LPTR, dwLength)) {
                if (GetFileVersionInfo ((PTSTR)FilePath, 0, dwLength, lpData)) {
                    if (VerQueryValue (lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                        if (SUCCEEDED(StringCchPrintf (
                                FileVersion,
                                CchFileVersion,
                                TEXT("%u.%u.%u.%u"),
                                (UINT)HIWORD(VsInfo->dwFileVersionMS),
                                (UINT)LOWORD(VsInfo->dwFileVersionMS),
                                (UINT)HIWORD(VsInfo->dwFileVersionLS),
                                (UINT)LOWORD(VsInfo->dwFileVersionLS)
                                ))) {
                            b = TRUE;
                        } else {
                            //
                            // why is the buffer so small?
                            //
                            MYASSERT (FALSE);
                        }
                    }
                }
                LocalFree (lpData);
            }
        }
    }

    return b;
}

BOOL
IsFileVersionLesser (
    IN      PCTSTR FileToCompare,
    IN      PCTSTR FileToCompareWith
    )
{
    TCHAR version[20];

    if (GetFileVersion (FileToCompareWith, version) && CheckForFileVersion (FileToCompare, version)) {
        DebugLog (
            Winnt32LogInformation,
            TEXT("File %1 has a smaller version (%2) than %3"),
            0,
            FileToCompare,
            version,
            FileToCompareWith
            );
        return TRUE;
    }

    return FALSE;
}


BOOL
FindPathToInstallationFileEx (
    IN      PCTSTR FileName,
    OUT     PTSTR PathToFile,
    IN      INT PathToFileBufferSize,
    OUT     PBOOL Compressed                OPTIONAL
    )
{
    DWORD i;
    DWORD attr;
    BOOL b;
    HANDLE h;
    WIN32_FIND_DATA fd;
    PTSTR p, q;

    if (!FileName || !*FileName) {
        return FALSE;
    }

    //
    // Search for installation files in this order:
    // 1. AlternateSourcePath (specified on the cmd line with /M:Path)
    // 2. Setup Update files (downloaded from the web)
    // 3. NativeSourcePath(s)
    // 4. SourcePath(s)
    //
    if (AlternateSourcePath[0]) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, AlternateSourcePath, FileName)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
    }

    if (g_DynUpdtStatus->UpdatesPath[0]) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, g_DynUpdtStatus->UpdatesPath, FileName)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
    }

    for (i = 0; i < SourceCount; i++) {
        if (!BuildPathEx (PathToFile, PathToFileBufferSize, NativeSourcePaths[i], FileName)) {
            continue;
        }
        p = CharPrev (PathToFile, _tcschr (PathToFile, 0));
        *p = TEXT('?');
        b = FALSE;
        h = FindFirstFile (PathToFile, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                q = CharPrev (fd.cFileName, _tcschr (fd.cFileName, 0));
                *p = *q;
                if (Compressed) {
                    *Compressed = (*q == TEXT('_'));
                }
                b = TRUE;
            }
            FindClose (h);
        }
        if (b) {
            return TRUE;
        }
    }

    for (i = 0; i < SourceCount; i++) {
        if (!BuildPathEx (PathToFile, PathToFileBufferSize, SourcePaths[i], FileName)) {
            continue;
        }
        p = CharPrev (PathToFile, _tcschr (PathToFile, 0));
        *p = TEXT('?');
        b = FALSE;
        h = FindFirstFile (PathToFile, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                q = CharPrev (fd.cFileName, _tcschr (fd.cFileName, 0));
                *p = *q;
                if (Compressed) {
                    *Compressed = (*q == TEXT('_'));
                }
                b = TRUE;
            }
            FindClose (h);
        }
        if (b) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
FindPathToWinnt32File (
    IN      PCTSTR FileRelativePath,
    OUT     PTSTR PathToFile,
    IN      INT PathToFileBufferSize
    )
{
    DWORD i;
    DWORD attr;
    TCHAR cdFilePath[MAX_PATH];
    PTSTR p;

    if (!FileRelativePath || !*FileRelativePath || PathToFileBufferSize <= 0) {
        return FALSE;
    }

    if (FileRelativePath[1] == TEXT(':') && FileRelativePath[2] == TEXT('\\') ||
        FileRelativePath[0] == TEXT('\\') && FileRelativePath[1] == TEXT('\\')) {
        //
        // assume either a DOS or a UNC full path was supplied
        //
        attr = GetFileAttributes (FileRelativePath);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            if (lstrlen (FileRelativePath) >= PathToFileBufferSize) {
                return FALSE;
            }
            lstrcpy (PathToFile, FileRelativePath);
            return TRUE;
        }
    }

    if (!MyGetModuleFileName (NULL, cdFilePath, ARRAYSIZE(cdFilePath)) ||
        !(p = _tcsrchr (cdFilePath, TEXT('\\')))) {
        return FALSE;
    }
    //
    // hop over the backslash
    //
    p++;
    if (FAILED (StringCchCopy (p, cdFilePath + ARRAYSIZE(cdFilePath) - p, FileRelativePath))) {
        cdFilePath[0] = 0;
    }

    //
    // Search for winnt32 files in this order:
    // 1. AlternateSourcePath (specified on the cmd line with /M:Path
    // 2. Setup Update files (downloaded from the web)
    // 3. NativeSourcePath(s)
    // 4. SourcePath(s)
    //
    if (AlternateSourcePath[0]) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, AlternateSourcePath, FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }

            p = _tcsrchr (PathToFile, TEXT('\\'));
            if (p) {
                //
                // try the root of /M too, for backwards compatibility with W2K
                //
                if (BuildPathEx (PathToFile, PathToFileBufferSize, AlternateSourcePath, p + 1)) {
                    attr = GetFileAttributes (PathToFile);
                    if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                        return TRUE;
                    }
                }
            }
        }
    }


    if (g_DynUpdtStatus && g_DynUpdtStatus->Winnt32Path[0]) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, g_DynUpdtStatus->Winnt32Path, FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                //
                // check file version relative to the CD version
                //
                if (!IsFileVersionLesser (PathToFile, cdFilePath)) {
                    return TRUE;
                }
            }
        }
    }

#ifndef UNICODE
    //
    // on Win9x systems, first check if the file was downloaded in %windir%\winnt32
    // load it from there if it's present
    //
    if (g_LocalSourcePath) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, g_LocalSourcePath, FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
    }
#endif

    for (i = 0; i < SourceCount; i++) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, NativeSourcePaths[i], FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
    }

    for (i = 0; i < SourceCount; i++) {
        if (BuildPathEx (PathToFile, PathToFileBufferSize, SourcePaths[i], FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
    }

    attr = GetFileAttributes (cdFilePath);
    if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
        if (SUCCEEDED (StringCchCopy (PathToFile, PathToFileBufferSize, cdFilePath))) {
            return TRUE;
        }
    }

    PathToFile[0] = 0;
    return FALSE;
}

BOOL
CreateDir (
    IN      PCTSTR DirName
    )
{
    return CreateDirectory (DirName, NULL) || GetLastError () == ERROR_ALREADY_EXISTS;
}


BOOL
GetLinkDate (
    IN      PCTSTR FilePath,
    OUT     PDWORD LinkDate
    )
{
    HANDLE hFile;
    HANDLE hFileMapping;
    PVOID pFileBase;
    DWORD fileSize;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_NT_HEADERS pNtHeaders;
    DWORD rc;

    rc = MapFileForRead (FilePath, &fileSize, &hFile, &hFileMapping, &pFileBase);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    __try {
        if (fileSize < sizeof (IMAGE_DOS_HEADER)) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        dosHeader = (PIMAGE_DOS_HEADER)pFileBase;
        if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        if ((DWORD)dosHeader->e_lfanew + sizeof (IMAGE_NT_HEADERS) > fileSize) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        pNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pFileBase + dosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        *LinkDate = pNtHeaders->FileHeader.TimeDateStamp;
        rc = ERROR_SUCCESS;
    } __finally {
        UnmapFile (hFileMapping, pFileBase);
        CloseHandle (hFile);
        SetLastError (rc);
    }

    return rc == ERROR_SUCCESS;
}



BOOL
CheckForFileVersionEx (
    LPCTSTR FileName,
    LPCTSTR FileVer,                OPTIONAL
    LPCTSTR BinProductVer,          OPTIONAL
    LPCTSTR LinkDate                OPTIONAL
    )
/*
    Arguments -

        FileName - Full path to the file to check
        Filever  - Version value to check against of the for x.x.x.x
        BinProductVer - Version value to check against of the for x.x.x.x
        LinkDate - Link date of executable

    Function will check the actual file against the fields specified. The depth of the check
    is as deep as specified in "x.x.x.x" i..e if FileVer = 3.5.1 and actual version on the file
    is 3.5.1.4 we only compare upto 3.5.1.

    Return values -

    TRUE - If the version of the file is <= FileVer which means that the file is an incompatible one

    else we return FALSE

*/

{
    TCHAR Buffer[MAX_PATH];
    TCHAR temp[MAX_PATH];
    DWORD dwLength, dwTemp;
    UINT DataLength;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    LPTSTR s,e;
    DWORD Vers[5],File_Vers[5];//MajVer, MinVer;
    INT i, Depth;
    BOOL bEqual, bError = FALSE;
    DWORD linkDate, fileLinkDate;
    BOOL bIncompatible;
    BOOL bIncompFileVer, bIncompBinProdVer;

    if (!ExpandEnvironmentStrings( FileName, Buffer, ARRAYSIZE(Buffer))) {
        return FALSE;
    }

    if(!FileExists(Buffer, NULL)) {
        return FALSE;
    }

    bIncompatible = FALSE;

    if(FileVer && *FileVer || BinProductVer && *BinProductVer) {
        //
        // we need to read the version info
        //
        if(dwLength = GetFileVersionInfoSize( Buffer, &dwTemp )) {
            if(lpData = LocalAlloc( LPTR, dwLength )) {
                if(GetFileVersionInfo( Buffer, 0, dwLength, lpData )) {
                    if (VerQueryValue( lpData, TEXT("\\"), &VsInfo, &DataLength )) {

                        if (FileVer && *FileVer) {
                            File_Vers[0] = (HIWORD(VsInfo->dwFileVersionMS));
                            File_Vers[1] = (LOWORD(VsInfo->dwFileVersionMS));
                            File_Vers[2] = (HIWORD(VsInfo->dwFileVersionLS));
                            File_Vers[3] = (LOWORD(VsInfo->dwFileVersionLS));
                            if (FAILED (StringCchCopy (temp, ARRAYSIZE(temp), FileVer))) {
                                MYASSERT(FALSE);
                            }
                            //
                            //Parse and get the depth of versioning we look for
                            //
                            s = e = temp;
                            bEqual = FALSE;
                            i = 0;
                            if (*e == TEXT('=')) {
                                bEqual = TRUE;
                                e++;
                                s++;
                            }
                            while (e) {
                                if (((*e < TEXT('0')) || (*e > TEXT('9'))) &&
                                    (*e != TEXT('.')) &&
                                    (*e != TEXT('\0'))
                                    ) {
                                    MYASSERT (FALSE);
                                    bError = TRUE;
                                    break;
                                }
                                if (*e == TEXT('\0')) {
                                    *e = 0;
                                    Vers[i] = _ttoi(s);
                                    break;
                                }
                                if (*e == TEXT('.')) {
                                    *e = 0;
                                    Vers[i++] = _ttoi(s);
                                    s = e+1;
                                }
                                e++;
                            }// while

                            if (!bError) {
                                Depth = i + 1;
                                if (Depth > 4) {
                                    Depth = 4;
                                }
                                for (i = 0; i < Depth; i++) {
                                    if (File_Vers[i] == Vers[i]) {
                                        continue;
                                    }
                                    if (bEqual) {
                                        break;
                                    }
                                    if (File_Vers[i] > Vers[i]) {
                                        break;
                                    }
                                    bIncompatible = TRUE;
                                    break;
                                }
                                if (i == Depth) {
                                    //
                                    // everything matched - the file is incompatible
                                    //
                                    bIncompatible = TRUE;
                                }
                            }
                        } else {
                            bIncompatible = TRUE;
                        }
                        if (!bError && bIncompatible && BinProductVer && *BinProductVer) {
                            //
                            // reset status
                            //
                            bIncompatible = FALSE;
                            File_Vers[0] = (HIWORD(VsInfo->dwProductVersionMS));
                            File_Vers[1] = (LOWORD(VsInfo->dwProductVersionMS));
                            File_Vers[2] = (HIWORD(VsInfo->dwProductVersionLS));
                            File_Vers[3] = (LOWORD(VsInfo->dwProductVersionLS));
                            if (FAILED (StringCchCopy (temp, ARRAYSIZE(temp), BinProductVer))) {
                                MYASSERT(FALSE);
                            }
                            //
                            //Parse and get the depth of versioning we look for
                            //
                            s = e = temp;
                            bEqual = FALSE;
                            i = 0;
                            if (*e == TEXT('=')) {
                                bEqual = TRUE;
                                e++;
                                s++;
                            }
                            while (e) {
                                if (((*e < TEXT('0')) || (*e > TEXT('9'))) &&
                                    (*e != TEXT('.')) &&
                                    (*e != TEXT('\0'))
                                    ) {
                                    MYASSERT (FALSE);
                                    bError = TRUE;
                                    break;
                                }
                                if (*e == TEXT('\0')) {
                                    *e = 0;
                                    Vers[i] = _ttoi(s);
                                    break;
                                }
                                if (*e == TEXT('.')) {
                                    *e = 0;
                                    Vers[i++] = _ttoi(s);
                                    s = e+1;
                                }
                                e++;
                            }// while

                            if (!bError) {
                                Depth = i + 1;
                                if (Depth > 4) {
                                    Depth = 4;
                                }
                                for (i = 0; i < Depth; i++) {
                                    if (File_Vers[i] == Vers[i]) {
                                        continue;
                                    }
                                    if (bEqual) {
                                        break;
                                    }
                                    if (File_Vers[i] > Vers[i]) {
                                        break;
                                    }
                                    bIncompatible = TRUE;
                                    break;
                                }
                                if (i == Depth) {
                                    //
                                    // everything matched - the file is incompatible
                                    //
                                    bIncompatible = TRUE;
                                }
                            }
                        }
                    }
                }
                LocalFree( lpData );
            }
        }
    } else {
        bIncompatible = TRUE;
    }

    if (!bError && bIncompatible && LinkDate && *LinkDate) {
        bEqual = FALSE;
        if (*LinkDate == TEXT('=')) {
            LinkDate++;
            bEqual = TRUE;
        }
        bIncompatible = FALSE;
        if (StringToInt (LinkDate, &linkDate)) {
            if (GetLinkDate (Buffer, &fileLinkDate)) {
                if (fileLinkDate == linkDate ||
                    !bEqual && fileLinkDate < linkDate
                    ) {
                    bIncompatible = TRUE;
                }
            }
        }
    }
    if (bError) {
        bIncompatible = FALSE;
    }
    return bIncompatible;
}

BOOL
StringToInt (
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if((*Field == TEXT('0')) &&
       ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


BOOLEAN
CheckForFileVersion (
    LPCTSTR FileName,
    LPCTSTR FileVer
    )
{
    return (BOOLEAN)CheckForFileVersionEx (FileName, FileVer, NULL, NULL);
}


VOID
FixMissingKnownDlls (
    OUT     PSTRINGLIST* MissingKnownDlls,
    IN      PCTSTR RestrictedCheckList      OPTIONAL
    )
{
    PCTSTR regStr;
    HKEY key;
    DWORD rc;
    DWORD index;
    TCHAR dllValue[MAX_PATH];
    TCHAR dllName[MAX_PATH];
    DWORD type;
    DWORD size1;
    DWORD size2;
    TCHAR systemDir[MAX_PATH];
    TCHAR dllPath[MAX_PATH];
    BOOL bCheck;

    if (!GetSystemDirectory (systemDir, ARRAYSIZE(systemDir))) {
        return;
    }

#ifdef UNICODE
    regStr = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs";
#else
    regStr = "SYSTEM\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs";
#endif
    rc = RegOpenKey (HKEY_LOCAL_MACHINE, regStr, &key);
    if (rc == ERROR_SUCCESS) {
        index = 0;
        size1 = ARRAYSIZE(dllValue);
        size2 = ARRAYSIZE(dllName);
        while (RegEnumValue (
                    key,
                    index++,
                    dllValue,
                    &size1,
                    NULL,
                    &type,
                    (LPBYTE)dllName,
                    &size2
                    ) == ERROR_SUCCESS) {
            if (type == REG_SZ) {
                bCheck = TRUE;
                if (RestrictedCheckList) {
                    PCTSTR fileName = RestrictedCheckList;
                    while (*fileName) {
                        if (!lstrcmpi (fileName, dllName)) {
                            break;
                        }
                        fileName = _tcschr (fileName, 0) + 1;
                    }
                    if (*fileName == 0) {
                        //
                        // we are not interested in this dll
                        //
                        bCheck = FALSE;
                    }
                }
                if (bCheck) {
                    if (!BuildPath (dllPath, systemDir, dllName) ||
                        !FileExists (dllPath, NULL)) {

                        DebugLog (
                            Winnt32LogWarning,
                            TEXT("The KnownDll %1\\%2 has a name too long or it doesn't exist"),
                            0,
                            systemDir,
                            dllName
                            );
                        //
                        // OK, we found a bogus reg entry; remove the value and remember the data
                        //
                        if (RegDeleteValue (key, dllValue) == ERROR_SUCCESS) {
                            InsertList (
                                (PGENERIC_LIST*)MissingKnownDlls,
                                (PGENERIC_LIST)CreateStringCell (dllValue)
                                );
                            InsertList (
                                (PGENERIC_LIST*)MissingKnownDlls,
                                (PGENERIC_LIST)CreateStringCell (dllName)
                                );
                        }
                    }
                }
            }
            size1 = ARRAYSIZE(dllValue);
            size2 = ARRAYSIZE(dllName);
        }
        RegCloseKey (key);
    }
}


VOID
UndoFixMissingKnownDlls (
    IN      PSTRINGLIST MissingKnownDlls
    )
{
    PCTSTR regStr;
    HKEY key;
    DWORD rc;
    PSTRINGLIST p, q;

#ifdef UNICODE
    regStr = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs";
#else
    regStr = "SYSTEM\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs";
#endif
    rc = RegOpenKey (HKEY_LOCAL_MACHINE, regStr, &key);
    if (rc == ERROR_SUCCESS) {
        p = MissingKnownDlls;
        while (p) {
            q = p->Next;
            if (q) {
                RegSetValueEx (
                        key,
                        p->String,
                        0,
                        REG_SZ,
                        (const PBYTE)q->String,
                        (lstrlen (q->String) + 1) * sizeof (TCHAR)
                        );
                p = q->Next;
            } else {
                p = NULL;
            }
        }
        RegCloseKey (key);
    }
    DeleteStringList (MissingKnownDlls);
}

#ifndef UNICODE

/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

#define MBCHAR  INT

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strPattern)) == '*') {
                strStr = _mbsinc (strPattern);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

#endif

// Wierd logic here required to make builds work, as this is defined
// in another file that gets linked in on x86

#ifdef _WIN64

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}


#endif

typedef BOOL (WINAPI * GETDISKFREESPACEEXA)(
  PCSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

typedef BOOL (WINAPI * GETDISKFREESPACEEXW)(
  PCWSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

BOOL
Winnt32GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  On Win9x GetDiskFreeSpace never return free/total space more than 2048MB.
  Winnt32GetDiskFreeSpaceNew use GetDiskFreeSpaceEx to calculate real number of free/total clusters.
  Has same  declaration as GetDiskFreeSpaceA.

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXA pGetDiskFreeSpaceExA;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceA(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DebugLog (
            Winnt32LogError,
            TEXT("Winnt32GetDiskFreeSpaceNewA: GetDiskFreeSpaceA failed on drive %1"),
            0,
            DriveName);
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExA = (GETDISKFREESPACEEXA)GetProcAddress(hKernel32, "GetDiskFreeSpaceExA");
    if(pGetDiskFreeSpaceExA &&
       pGetDiskFreeSpaceExA(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DebugLog (
            Winnt32LogWarning,
            pGetDiskFreeSpaceExA?
                    TEXT("Winnt32GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA is failed"):
                    TEXT("Winnt32GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA function is not in kernel32.dll"),
            0);
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    return TRUE;
}

BOOL
Winnt32GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  Correct NumberOfFreeClusters and TotalNumberOfClusters out parameters
  with using GetDiskFreeSpace and GetDiskFreeSpaceEx

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXW pGetDiskFreeSpaceExW;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceW(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DebugLog (
            Winnt32LogError,
            TEXT("Winnt32GetDiskFreeSpaceNewW: GetDiskFreeSpaceW failed on drive %1"),
            0,
            DriveName);
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExW = (GETDISKFREESPACEEXW)GetProcAddress(hKernel32, "GetDiskFreeSpaceExW");
    if(pGetDiskFreeSpaceExW &&
       pGetDiskFreeSpaceExW(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DebugLog (
            Winnt32LogWarning,
            pGetDiskFreeSpaceExW?
                    TEXT("Winnt32GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW is failed"):
                    TEXT("Winnt32GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW function is not in kernel32.dll"),
            0);
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    return TRUE;
}

BOOL
ReplaceSubStr(
    IN OUT LPTSTR SrcStr,
    IN LPTSTR SrcSubStr,
    IN LPTSTR DestSubStr
    )
/*++

Routine Description:

    Replaces the source substr with the destination substr in the source
    string.

    NOTE : SrcSubStr needs to be longer than or equal in length to
           DestSubStr.

Arguments:

    SrcStr : The source to operate upon. Also receives the new string.

    SrcSubStr : The source substring to search for and replace.

    DestSubStr : The substring to replace with for the occurences
        of SrcSubStr in SrcStr.

Return Value:

    TRUE if successful, otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

    //
    // Validate the arguments
    //
    if (SrcStr && SrcSubStr && *SrcSubStr &&
        (!DestSubStr || (_tcslen(SrcSubStr) >= _tcslen(DestSubStr)))) {
        if (!DestSubStr || _tcsicmp(SrcSubStr, DestSubStr)) {
            ULONG SrcStrLen = _tcslen(SrcStr);
            ULONG SrcSubStrLen = _tcslen(SrcSubStr);
            ULONG DestSubStrLen = DestSubStr ? _tcslen(DestSubStr) : 0;
            LPTSTR DestStr = malloc((SrcStrLen + 1) * sizeof(TCHAR));

            if (DestStr) {
                LPTSTR CurrDestStr = DestStr;
                LPTSTR PrevSrcStr = SrcStr;
                LPTSTR CurrSrcStr = _tcsstr(SrcStr, SrcSubStr);

                while (CurrSrcStr) {
                    //
                    // Skip starting substr & copy previous unmatched pattern
                    //
                    if (PrevSrcStr != CurrSrcStr) {
                        _tcsncpy(CurrDestStr, PrevSrcStr, (CurrSrcStr - PrevSrcStr));
                        CurrDestStr += (CurrSrcStr - PrevSrcStr);
                        *CurrDestStr = TEXT('\0');
                    }

                    //
                    // Copy destination substr
                    //
                    if (DestSubStr) {
                        _tcscpy(CurrDestStr, DestSubStr);
                        CurrDestStr += DestSubStrLen;
                        *CurrDestStr = TEXT('\0');
                    }

                    //
                    // Look for next substr
                    //
                    CurrSrcStr += SrcSubStrLen;
                    PrevSrcStr = CurrSrcStr;
                    CurrSrcStr = _tcsstr(CurrSrcStr, SrcSubStr);
                }

                //
                // Copy remaining src string if any
                //
                if (!_tcsstr(PrevSrcStr, SrcSubStr)) {
                    _tcscpy(CurrDestStr, PrevSrcStr);
                }

                //
                // Copy the new string back to the src string
                //
                _tcscpy(SrcStr, DestStr);

                free(DestStr);
                Result = TRUE;
            }
        } else {
            Result = TRUE;
        }
    }

    return Result;
}

VOID
RemoveTrailingWack (
    PTSTR String
    )
{
    if (String) {
        PTSTR p = _tcsrchr (String, TEXT('\\'));
        if (p && p[1] == 0) {
            *p = 0;
        }
    }
}

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}


DWORD
MyGetFullPathName (
    IN      PCTSTR FileName,  // file name
    IN      DWORD BufferLength, // size of path buffer
    IN      PTSTR Buffer,       // path buffer
    OUT     PTSTR* FilePart     // address of file name in path
    )
{
    DWORD d = GetFullPathName (FileName, BufferLength, Buffer, FilePart);
    return d < BufferLength ? d : 0;
}

DWORD
MyGetModuleFileName (
    IN      HMODULE Module,
    OUT     PTSTR Buffer,
    IN      DWORD BufferLength
    )
{
    DWORD d = GetModuleFileName (Module, Buffer, BufferLength);
    Buffer[BufferLength - 1] = 0;
    return d < BufferLength ? d : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\web.cpp ===
#include <windows.h>
#include <ole2.h>
#include <exdisp.h>
#include <htiframe.h>

#define INITGUID

#include <initguid.h>
#include <shlguid.h>
#include <mshtml.h>
#include <comdef.h>


const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)



extern "C"
BOOL
IsIE3Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowserApp,
                           (void **)&pwb );
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


extern "C"
BOOL
IsIE4Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowser2,
                           (void **)&pwb );

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


extern "C"
BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowserApp *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowserApp,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {

        // turn off chrome
        hr = pwb->put_MenuBar(FALSE);
        hr = pwb->put_StatusBar(FALSE);
//        hr = pwb->put_ToolBar(FALSE);

        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}


extern "C"
BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    HWND    hwndIE;
    int dx, dy;
    IWebBrowser2 *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowser2,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {
        DWORD dwFlags;
        ITargetFrame2* ptgf;

        //
        //  this marks this window as a third party window,
        //  so that the window is not reused.
        //
        pwb->put_RegisterAsBrowser(VARIANT_TRUE);

        IHTMLWindow2 *phw;
        IServiceProvider *psp;

        if (SUCCEEDED(pwb->QueryInterface(IID_IServiceProvider, (void**) &psp)) && psp) {
            if (SUCCEEDED(psp->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void**)&phw))) {
                VARIANT var;
                var.vt = VT_BOOL;
                var.boolVal = 666;
                phw->put_opener(var);
                phw->Release();
            } else
                MessageBox(NULL, TEXT("QueryInterface of IID_IHTMLWindow2 FAILED!!!!!"), NULL, MB_ICONERROR);
            psp->Release();
        }

        // turn off chrome
        pwb->put_MenuBar(FALSE);
        pwb->put_StatusBar(FALSE);
//        pwb->put_ToolBar(FALSE);
        pwb->put_AddressBar(FALSE);
//      pwb->put_Resizable(FALSE);


        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        pwb->get_HWND((LONG_PTR*)&hwndIE);
        SetForegroundWindow(hwndIE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\ansi\precomp.h ===
#include "winnt32.h"
#include "msg.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\unsupdrv.c ===
#include "precomp.h"
#pragma hdrstop

#ifdef UNICODE

#define DRIVER_VALUE_ENTRY  TEXT("Driver");


BOOL
IsServiceToBeDisabled(
    IN  PVOID   NtCompatInfHandle,
    IN  LPTSTR  ServiceName
    )
{
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    BOOL serviceDisabled = FALSE;

    //
    // iterate through all compdata structures
    //
    Next = CompatibilityData.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD(Next, COMPATIBILITY_DATA, ListEntry);
            Next = CompData->ListEntry.Flink;
            //
            // now look for services that match our service name
            //
            if (CompData->Type == TEXT('s') && lstrcmpi (CompData->ServiceName, ServiceName) == 0) {
                //
                // make sure the service is marked to be disabled
                //
                if ((CompData->RegValDataSize == sizeof (DWORD)) &&
                    (*(PDWORD)CompData->RegValData == SERVICE_DISABLED)
                    ) {
                    //
                    // we found it!
                    //
                    serviceDisabled = TRUE;
                    break;
                }
            }
        }
    }

    return serviceDisabled;
}


BOOL
IsDriverCopyToBeSkipped(
    IN  PVOID   NtCompatInfHandle,
    IN  LPTSTR  ServiceName,
    IN  LPTSTR  FilePath
    )
{
    LONG    LineCount;
    LONG    i;
    LPTSTR  SectionName = TEXT("DriversToSkipCopy");
    LPTSTR  FileName;
    BOOL    DisableCopy;

    if ((!NtCompatInfHandle) || (!FilePath)) {
        MYASSERT(FALSE);
        return TRUE;
    }

    FileName = _tcsrchr( FilePath, TEXT('\\') );
    if (!FileName) {
        FileName = FilePath;
    }
    else {
        FileName++;
    }
    
    //
    //  Check if the driver is listed under [DriversToSkipCopy] in ntcompat.inf.
    //

    if( (LineCount = InfGetSectionLineCount( NtCompatInfHandle,
                                             SectionName )) == -1 ) {
        //
        //  section doesn't exist.
        //
        return( FALSE );
    }

    DisableCopy = FALSE;
    for( i = 0; i < LineCount; i++ ) {
        LPTSTR  p;

        p = (LPTSTR)InfGetFieldByIndex( NtCompatInfHandle,
                                        SectionName,
                                        i,
                                        0 );

        if( p && !lstrcmpi( p, FileName ) ) {

            DisableCopy = TRUE;
            break;
        }
    }
    
    return( DisableCopy );
}


BOOL
LoadHwdbLib (
    OUT     HMODULE* HwdbLib,
    OUT     PHWDB_ENTRY_POINTS HwdbEntries
    )
{
    TCHAR pathSupportLib[MAX_PATH];
    HMODULE hwdbLib;
    DWORD rc;

    if (!FindPathToWinnt32File (S_HWDB_DLL, pathSupportLib, MAX_PATH)) {
        return FALSE;
    }

    hwdbLib = LoadLibraryEx (pathSupportLib, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hwdbLib) {
        return FALSE;
    }
    HwdbEntries->HwdbInitialize = (PHWDBINITIALIZE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBINITIALIZE);
    HwdbEntries->HwdbTerminate = (PHWDBTERMINATE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBTERMINATE);
    HwdbEntries->HwdbOpen = (PHWDBOPEN) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBOPEN);
    HwdbEntries->HwdbClose = (PHWDBCLOSE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBCLOSE);
    HwdbEntries->HwdbHasAnyDriver = (PHWDBHASANYDRIVER) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBHASANYDRIVER);

    if (!HwdbEntries->HwdbInitialize ||
        !HwdbEntries->HwdbTerminate ||
        !HwdbEntries->HwdbOpen ||
        !HwdbEntries->HwdbClose ||
        !HwdbEntries->HwdbHasAnyDriver
        ) {
        ZeroMemory (HwdbEntries, sizeof (*HwdbEntries));
        rc = GetLastError ();
        FreeLibrary (hwdbLib);
        SetLastError (rc);
        return FALSE;
    }

    *HwdbLib = hwdbLib;
    return TRUE;
}

BOOL
pAnyPnpIdSupported (
    IN      PCTSTR PnpIDs
    )
{
    HMODULE hwdbLib;
    HANDLE hwdbDatabase;
    HWDB_ENTRY_POINTS hwdbEntries;
    TCHAR hwdbPath[MAX_PATH];
    BOOL unsupported;
    BOOL b = TRUE;

    if (!FindPathToWinnt32File (S_HWCOMP_DAT, hwdbPath, MAX_PATH)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("%1 not found"), 0, S_HWCOMP_DAT);
        return b;
    }

    if (!LoadHwdbLib (&hwdbLib, &hwdbEntries)) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("LoadHwdbLib failed (rc=%u)"),
            0,
            GetLastError ()
            );
        return b;
    }

    if (hwdbEntries.HwdbInitialize (NULL)) {
        hwdbDatabase = hwdbEntries.HwdbOpen (hwdbPath);
        if (hwdbDatabase) {
            b = hwdbEntries.HwdbHasAnyDriver (hwdbDatabase, PnpIDs, &unsupported);
            hwdbEntries.HwdbClose (hwdbDatabase);
        }
        hwdbEntries.HwdbTerminate ();
    }

    FreeLibrary (hwdbLib);

    return b;
}


PTSTR
pGetDevicePnpIDs (
    IN      PCTSTR DeviceRegKey
    )
{
    LONG rc;
    HKEY deviceKey;
    DWORD type;
    DWORD size1, size2;
    PTSTR pnpIds;
    PTSTR p = NULL;

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            DeviceRegKey,
            0,
            KEY_QUERY_VALUE,
            &deviceKey
            );
    if (rc != ERROR_SUCCESS) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("Failed to open device key %s (rc=%u)"),
            0,
            DeviceRegKey,
            rc
            );
        return p;
    }

    __try {
        size1 = 0;
        rc = RegQueryValueEx (
                deviceKey,
                TEXT("HardwareID"),
                NULL,
                &type,
                NULL,
                &size1
                );
        if (rc == ERROR_SUCCESS) {
            if (type != REG_MULTI_SZ && type != REG_BINARY) {
                size1 = 0;
                DebugLog (
                    Winnt32LogWarning,
                    TEXT("Unexpected type of %s of %s (type=%u)"),
                    0,
                    TEXT("HardwareID"),
                    DeviceRegKey,
                    type
                    );
            }
        } else {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't find value %s of %s (rc=%u)"),
                0,
                TEXT("HardwareID"),
                DeviceRegKey,
                rc
                );
        }
        size2 = 0;
        rc = RegQueryValueEx (
                deviceKey,
                TEXT("CompatibleIDs"),
                NULL,
                &type,
                NULL,
                &size2
                );
        if (rc == ERROR_SUCCESS) {
            if (type != REG_MULTI_SZ && type != REG_BINARY) {
                size2 = 0;
                DebugLog (
                    Winnt32LogWarning,
                    TEXT("Unexpected type of %s of %s (type=%u)"),
                    0,
                    TEXT("CompatibleIDs"),
                    DeviceRegKey,
                    type
                    );
            }
        } else {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't find value %s of %s (rc=%u)"),
                0,
                TEXT("CompatibleIDs"),
                DeviceRegKey,
                rc
                );
        }
        if (size1 + size2 < sizeof (TCHAR)) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't get list of PnpIDs for %s"),
                0,
                DeviceRegKey
                );
            __leave;
        }
        pnpIds = MALLOC (size1 + size2);
        if (!pnpIds) {
            __leave;
        }
        pnpIds[0] = 0;
        p = pnpIds;

        if (size1 >= sizeof (TCHAR)) {
            rc = RegQueryValueEx (
                    deviceKey,
                    TEXT("HardwareID"),
                    NULL,
                    NULL,
                    (LPBYTE)pnpIds,
                    &size1
                    );
            if (rc == ERROR_SUCCESS) {
                pnpIds += size1 / sizeof (TCHAR) - 1;
            }
        }
        if (size2 >= sizeof (TCHAR)) {
            rc = RegQueryValueEx (
                    deviceKey,
                    TEXT("CompatibleIDs"),
                    NULL,
                    NULL,
                    (LPBYTE)pnpIds,
                    &size2
                    );
        }
    }
    __finally {
        RegCloseKey (deviceKey);
    }

    return p;
}


BOOL
pAllServicedDevicesSupported (
    IN  HKEY    ServiceKey
    )
{
    LONG rc;
    HKEY enumSubKey;
    DWORD nextInstance;
    DWORD instance;
    TCHAR buf[20];
    DWORD type;
    DWORD size;
    PTSTR enumSuffixStr;
    HKEY deviceKey;
    PTSTR deviceKeyStr;
    PTSTR pnpIds;
    BOOL unsupported;
    BOOL b = TRUE;

    rc = RegOpenKeyEx (
            ServiceKey,
            TEXT("Enum"),
            0,
            KEY_QUERY_VALUE,
            &enumSubKey
            );
    if (rc != ERROR_SUCCESS) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("Failed to open Enum subkey (rc=%u)"),
            0,
            rc
            );
        return b;
    }

    __try {
        size = sizeof (nextInstance);
        rc = RegQueryValueEx (
                enumSubKey,
                TEXT("NextInstance"),
                NULL,
                &type,
                (LPBYTE)&nextInstance,
                &size
                );
        if (rc != ERROR_SUCCESS) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Failed to open %s value (rc=%u)"),
                0,
                TEXT("NextInstance"),
                rc
                );
            __leave;
        }
        if (type != REG_DWORD) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Unexpected value type for %s (type=%u)"),
                0,
                TEXT("NextInstance"),
                type
                );
            __leave;
        }

        for (instance = 0; b && instance < nextInstance; instance++) {
            wsprintf (buf, TEXT("%lu"), instance);
            rc = RegQueryValueEx (
                    enumSubKey,
                    buf,
                    NULL,
                    &type,
                    NULL,
                    &size
                    );
            if (rc != ERROR_SUCCESS || type != REG_SZ) {
                continue;
            }
            enumSuffixStr = MALLOC (size);
            if (!enumSuffixStr) {
                __leave;
            }
            rc = RegQueryValueEx (
                    enumSubKey,
                    buf,
                    NULL,
                    NULL,
                    (LPBYTE)enumSuffixStr,
                    &size
                    );
            if (rc == ERROR_SUCCESS) {

                size = sizeof ("SYSTEM\\CurrentControlSet\\Enum") + lstrlen (enumSuffixStr) + 1;
                deviceKeyStr = MALLOC (size * sizeof (TCHAR));
                if (!deviceKeyStr) {
                    __leave;
                }

                BuildPathEx (deviceKeyStr, size, TEXT("SYSTEM\\CurrentControlSet\\Enum"), enumSuffixStr);

                pnpIds = pGetDevicePnpIDs (deviceKeyStr);

                FREE (deviceKeyStr);

                if (!pAnyPnpIdSupported (pnpIds)) {
                    b = FALSE;
                }

                FREE (pnpIds);
            }

            FREE (enumSuffixStr);
        }
    }
    __finally {
        RegCloseKey (enumSubKey);
    }

    return b;
}

BOOL
IsInfInLayoutInf(
    IN PCTSTR InfPath
    )

/*++

Routine Description:

    Determine if an INF file is shiped in-box with the operating system.
    This is acomplished by looking up the INF name in the [SourceDisksFiles]
    section of layout.inf

Arguments:

    InfPath - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an in-box INF.  If FALSE, it's not an in-box INF, this
    could be an OEM<n>.INF or an inf illegaly copied into the INF directory.

--*/

{
    BOOL bInBoxInf = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT SourceId;
    PCTSTR infFileName;

    if (SetupapiGetSourceFileLocation) {

        hInf = SetupapiOpenInfFile(TEXT("layout.inf"), NULL, INF_STYLE_WIN4, NULL);

        if (hInf != INVALID_HANDLE_VALUE) {

            infFileName = _tcsrchr(InfPath, TEXT('\\') );
            if (infFileName) {
                infFileName++;
            } else {
                infFileName = InfPath;
            }

            if(SetupapiGetSourceFileLocation(hInf,
                                          NULL,
                                          infFileName,
                                          &SourceId,
                                          NULL,
                                          0,
                                          NULL)) {
                bInBoxInf = TRUE;
            }

            SetupapiCloseInfFile(hInf);
        }
    }

    return bInBoxInf;
}

BOOL
pIsOEMService (
    IN  PCTSTR  ServiceKeyName,
    OUT PTSTR OemInfPath,           OPTIONAL
    IN  INT BufferSize              OPTIONAL
    )
{
    ULONG BufferLen = 0;
    PTSTR Buffer = NULL;
    PTSTR p;
    DEVNODE DevNode;
    CONFIGRET cr;
    HKEY hKey;
    TCHAR InfPath[MAX_PATH];
    DWORD dwType, dwSize;
    BOOL IsOemService = FALSE;

    //
    // See how larger of a buffer we need to hold the list of device
    // instance Ids for this service.
    //
    cr = CM_Get_Device_ID_List_Size(&BufferLen,
                                    ServiceKeyName,
                                    CM_GETIDLIST_FILTER_SERVICE);

    if (cr != CR_SUCCESS) {
        //
        // Encountered an error so just bail out.
        //
        goto clean0;
    }

    if (BufferLen == 0) {
        //
        // No devices are using this service, so just bail out.
        //
        goto clean0;
    }

    Buffer = MALLOC(BufferLen*sizeof(TCHAR));

    if (Buffer == NULL) {
        goto clean0;
    }

    //
    // Get the list of device instance Ids for this service.
    //
    cr = CM_Get_Device_ID_List(ServiceKeyName,
                               Buffer,
                               BufferLen,
                               CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE);

    if (cr != CR_SUCCESS) {
        //
        // failed to get the list of devices for this service.
        //
        goto clean0;
    }

    //
    // Enumerate through the list of devices using this service.
    //
    for (p = Buffer; !IsOemService && *p; p += (lstrlen(p) + 1)) {

        //
        // Get a DevNode from the device instance Id.
        //
        cr = CM_Locate_DevNode(&DevNode, p, 0);

        if (cr != CR_SUCCESS) {
            continue;
        }
        
        //
        // Open the device's SOFTWARE key so we can get it's INF path.
        //
        cr = CM_Open_DevNode_Key(DevNode,
                                 KEY_READ,
                                 0,
                                 RegDisposition_OpenExisting,
                                 &hKey,
                                 CM_REGISTRY_SOFTWARE);

        if (cr != CR_SUCCESS) {
            //
            // Software key doesn't exist?  
            //
            continue;
        }

        dwType = REG_SZ;
        dwSize = sizeof(InfPath);
        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfPath,
                            &dwSize) != ERROR_SUCCESS) {
            //
            // If there is no InfPath in the SOFTWARE key then we don't know
            // what INF this device is using.
            //
            RegCloseKey(hKey);
            continue;
        }

        if (!IsInfInLayoutInf(InfPath)) {

            IsOemService = TRUE;

            if (OemInfPath) {
                StringCchCopy (OemInfPath, BufferSize, InfPath);
            }
        }

        RegCloseKey(hKey);
    }

clean0:
    if (Buffer) {
        FREE(Buffer);
    }

    return IsOemService;
}


BOOL
IsDeviceSupported(
    IN  PVOID   TxtsetupSifHandle,
    IN  HKEY    ServiceKey,
    IN  LPTSTR  ServiceKeyName,
    OUT LPTSTR  FileName,
    IN  INT     CchFileName
    )
{
    ULONG   Error;
    ULONG   Type;
    BYTE    Buffer[ (MAX_PATH + 1)*sizeof(TCHAR) ];
    PBYTE   Data;
    ULONG   cbData;
    BOOL    b = TRUE;
    LPTSTR  DriverPath;
    LPTSTR  DriverName;
    LONG    LineCount;
    LONG    i;
    BOOL    DeviceSupported;

    Data = Buffer;
    cbData = sizeof( Buffer );
    Error = RegQueryValueEx( ServiceKey,
                             TEXT("ImagePath"),
                             NULL,
                             &Type,
                             Data,
                             &cbData );

    if( (Error == ERROR_PATH_NOT_FOUND) ||
        (Error == ERROR_FILE_NOT_FOUND) ) {
        //
        //  ImagePath does not exist.
        //  In this case the driver name is <service name>.sys
        //
        StringCbCopy((PTSTR)Buffer, sizeof(Buffer), ServiceKeyName );
        StringCbCat((PTSTR)Buffer, sizeof(Buffer), TEXT(".sys") );
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_MORE_DATA ) {
        Data = (PBYTE)MALLOC( cbData );
        if( Data == NULL ) {
            //
            // We failed the malloc.  Just assume the device
            // isn't supported.
            //
            return( FALSE );
        }

        Error = RegQueryValueEx( ServiceKey,
                                 TEXT("ImagePath"),
                                 NULL,
                                 &Type,
                                 Data,
                                 &cbData );
    }

    if( Error != ERROR_SUCCESS ) {
        //
        //  We can' retrieve the drivers information.
        //  Assume that the device is supported
        //
        if( Data != Buffer ) {
            FREE( Data );
        }
        return( TRUE );
    }

    DriverPath = (LPTSTR)Data;

    DriverName = _tcsrchr( DriverPath, TEXT('\\') );
    if( DriverName != NULL ) {
        DriverName++;
    } else {
        DriverName = DriverPath;
    }

    //
    //  Search for the driver name on the following sections of txtsetup.sif:
    //          [SCSI.load]
    //

    if( (LineCount = InfGetSectionLineCount( TxtsetupSifHandle,
                                             TEXT("SCSI.load") )) == -1 ) {
        //
        //  We can't retrieve the drivers information.
        //  Assume that the device is supported
        //
        if( Data != Buffer ) {
            FREE( Data );
        }
        return( TRUE );
    }

    DeviceSupported = FALSE;
    for( i = 0; i < LineCount; i++ ) {
        LPTSTR  p;

        p = (LPTSTR)InfGetFieldByIndex( TxtsetupSifHandle,
                                        TEXT("SCSI.load"),
                                        i,
                                        0 );
        if( p == NULL ) {
            continue;
        }
        if( !lstrcmpi( p, DriverName ) ) {
            DeviceSupported = TRUE;
            break;
        }
    }
    //
    // NTBUG9: 505624
    // verify if there is inbox support for ALL devices
    // currently supported by this driver
    // If there's any that doesn't have support,
    // then the OEM driver must be migrated
    //
    if (DeviceSupported) {

        if (pIsOEMService (ServiceKeyName, NULL, 0)) {

            if (!pAllServicedDevicesSupported (ServiceKey)) {
                DeviceSupported = FALSE;
            }
        }
    }

#if defined(_AMD64_) || defined(_X86_)

    //
    // one more thing: check if this device is supplied by OEMs via answer file (NTBUG9: 306041)
    //
    if (!DeviceSupported) {
        POEM_BOOT_FILE p;
        for (p = OemBootFiles; p; p = p->Next) {
            if (!lstrcmpi (p->Filename, DriverName)) {
                DeviceSupported = TRUE;
                break;
            }
        }
    }
#endif

    if( !DeviceSupported ) {
        LPTSTR  q;

        CharLower( DriverPath );
        q = _tcsstr( DriverPath, TEXT("system32") );
        
        //Note, since this entire function (IsDeviceSupported) is only called in 
        //one place, we assume the FileName pointer points to a buffer of size MAX_PATH
        if( q == NULL ) {
            StringCchCopy( FileName, CchFileName, TEXT("system32\\drivers\\") );
            StringCchCat( FileName, CchFileName, DriverName );
        } else {
            StringCchCopy( FileName, CchFileName, q );
        }
    }
    if( Data != Buffer ) {
        FREE( Data );
    }
    return( DeviceSupported );
}

VOID
FreeHardwareIdList(
    IN PUNSUPORTED_PNP_HARDWARE_ID HardwareIdList
    )
{
    PUNSUPORTED_PNP_HARDWARE_ID p, q;

    p = HardwareIdList;
    while( p != NULL ) {
        FREE( p->Id );
        FREE( p->Service );
        FREE( p->ClassGuid );
        q = p->Next;
        FREE( p );
        p = q;
    }
}

VOID
FreeFileInfoList(
    IN PUNSUPORTED_DRIVER_FILE_INFO FileInfoList
    )
{
    PUNSUPORTED_DRIVER_FILE_INFO p, q;

    p = FileInfoList;
    while( p != NULL ) {
        FREE( p->FileName );
        FREE( p->TargetDirectory );
        q = p->Next;
        FREE( p );
        p = q;
    }
}

VOID
FreeInstallInfoList(
    IN PUNSUPORTED_DRIVER_INSTALL_INFO InstallInfoList
    )
{
    PUNSUPORTED_DRIVER_INSTALL_INFO p, q;

    p = InstallInfoList;
    while( p != NULL ) {
        FREE( p->InfRelPath );
        FREE( p->InfFileName );
        FREE( p->InfOriginalFileName );
        if (p->CatalogRelPath) {
            FREE(p->CatalogRelPath);
        }
        if (p->CatalogFileName) {
            FREE(p->CatalogFileName);
        }
        if (p->CatalogOriginalFileName) {
            FREE(p->CatalogOriginalFileName);
        }
        q = p->Next;
        FREE( p );
        p = q;
    }
}

VOID
FreeRegistryInfoList(
    IN PUNSUPORTED_DRIVER_REGKEY_INFO RegistryInfoList
    )
{
    PUNSUPORTED_DRIVER_REGKEY_INFO p, q;

    p = RegistryInfoList;
    while( p != NULL ) {
        FREE( p->KeyPath );
        q = p->Next;
        FREE( p );
        p = q;
    }
}


BOOL
BuildHardwareIdInfo(
    IN  LPTSTR                       ServiceName,
    OUT PUNSUPORTED_PNP_HARDWARE_ID* HardwareIdList
    )
{
    ULONG BufferLen;
    DEVNODE DevNode;
    PTSTR Buffer, Service, Id, HwId, DevId;
    PBYTE  Value;
    ULONG ValueSize;
    PUNSUPORTED_PNP_HARDWARE_ID TempList, Entry;
    BOOL Result;
    DWORD Type;

    if (CM_Get_Device_ID_List_Size(&BufferLen,
                                          ServiceName,
                                          CM_GETIDLIST_FILTER_SERVICE
                                          ) != CR_SUCCESS ||
        (BufferLen == 0)) {

        return ( FALSE );
    }

    Result = TRUE;
    Value = NULL;
    TempList = NULL;
    Buffer = MALLOC(BufferLen * sizeof(TCHAR));
    if (Buffer == NULL) {

        Result = FALSE;
        goto Clean;
    }
    ValueSize = REGSTR_VAL_MAX_HCID_LEN * sizeof(TCHAR);
    Value = MALLOC(ValueSize);
    if (Value == NULL) {

        Result = FALSE;
        goto Clean;
    }
    if (CM_Get_Device_ID_List(ServiceName,
                              Buffer,
                              BufferLen,
                              CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                              ) != CR_SUCCESS) {

        Result = FALSE;
        goto Clean;
    }

    for (DevId = Buffer; *DevId; DevId += lstrlen(DevId) + 1) {

        if (CM_Locate_DevNode(&DevNode, DevId, 0) == CR_SUCCESS) {

            ValueSize = REGSTR_VAL_MAX_HCID_LEN * sizeof(TCHAR);
            if (CM_Get_DevNode_Registry_Property(DevNode, CM_DRP_HARDWAREID, &Type, Value, &ValueSize, 0) == CR_SUCCESS &&
                Type == REG_MULTI_SZ) {

                for( HwId = (PTSTR)Value;
                     ( (ULONG_PTR)HwId < (ULONG_PTR)(Value + ValueSize) ) && ( lstrlen( HwId ) );
                     HwId += lstrlen( HwId ) + 1 ) {

                    Entry = MALLOC( sizeof( UNSUPORTED_PNP_HARDWARE_ID ) );
                    Id = DupString( HwId );
                    Service = DupString( ServiceName );

                    if( (Entry == NULL) || (Id == NULL) || (Service == NULL) ) {

                        if( Entry != NULL ) {
                            FREE( Entry );
                        }
                        if( Id != NULL ) {
                            FREE( Id );
                        }
                        if( Service != NULL ) {
                            FREE( Service );
                        }
                        Result = FALSE;
                        goto Clean;
                    }
                    //
                    // Add the new entry to the front of the list.
                    // 
                    Entry->Id = Id;
                    Entry->Service = Service;
                    Entry->ClassGuid = NULL;
                    Entry->Next = TempList;
                    TempList = Entry;
                }
            }
        }
    }

Clean:

    if ( Buffer ) {
    
        FREE( Buffer );
    }
    if ( Value ) {

        FREE( Value );
    }
    if (Result == TRUE) {

        *HardwareIdList = TempList;
    } else if ( TempList ) {

        FreeHardwareIdList( TempList );
    }

    return ( Result );
}


BOOL
BuildDriverFileInformation(
    IN  LPTSTR                        FilePath,
    OUT PUNSUPORTED_DRIVER_FILE_INFO* FileInfo
    )

{
    TCHAR   FullPath[ MAX_PATH + 1 ];
    LPTSTR  p, q, r;
    PUNSUPORTED_DRIVER_FILE_INFO TempFileInfo = NULL;

    *FileInfo = NULL;
    StringCchCopy( FullPath, ARRAYSIZE(FullPath), FilePath );
    p = _tcsrchr( FullPath, TEXT('\\') );
    if(!p)
        return FALSE;
    *p = TEXT('\0');
    p++;
    q = DupString( FullPath );
    r = DupString( p );
    TempFileInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_FILE_INFO ) );

    if( ( q == NULL ) || ( r == NULL ) || ( TempFileInfo == NULL ) ) {
        goto clean0;
    }

    TempFileInfo->Next = NULL;
    TempFileInfo->FileName = r;
    TempFileInfo->TargetDirectory = q;
    *FileInfo = TempFileInfo;
    return( TRUE );

clean0:
    if( q != NULL ) {
        FREE( q );
    }
    if( r != NULL ) {
        FREE( r );
    }
    if( TempFileInfo != NULL ) {
        FREE( TempFileInfo );
    }
    return( FALSE );
}

BOOL
pDoesCatalogExist (
    IN      PTSTR CatalogPath,
    IN      PTSTR CatName
    )
{
    TCHAR path[MAX_PATH];

    return BuildPath(path, CatalogPath, CatName) && FileExists (path, NULL);
}

BOOL
BuildDriverInstallInformation(
    IN  LPTSTR                           ServiceKeyName,
    OUT PUNSUPORTED_DRIVER_INSTALL_INFO* InstallInfo
    )
{
    TCHAR infName[MAX_PATH];
    TCHAR catName[MAX_PATH];
    TCHAR infPath[MAX_PATH];
    TCHAR catalogPath[MAX_PATH];
    LPTSTR  p, q, r, s, t, u;
    PUNSUPORTED_DRIVER_INSTALL_INFO TempInstallInfo = NULL;
    DWORD size;
    PSP_INF_INFORMATION info;
    SP_ORIGINAL_FILE_INFO ofi;
    BOOL b = FALSE;

    if (BUILDNUM() >= NT51) {
        return TRUE;
    }
    if (!pIsOEMService (ServiceKeyName, infName, ARRAYSIZE(infName))) {
        return TRUE;
    }

    if (!SetupapiGetInfInformation (infName, INFINFO_DEFAULT_SEARCH, NULL, 0, &size)) {
        return FALSE;
    }
    info = (PSP_INF_INFORMATION) MALLOC(size);
    if (!info) {
        return FALSE;
    }

    __try {
        if (!SetupapiGetInfInformation (infName, INFINFO_DEFAULT_SEARCH, info, size, NULL)) {
            __leave;
        }
        if (!SetupapiQueryInfFileInformation (info, 0, infPath, ARRAYSIZE(infPath), NULL)) {
            __leave;
        }
        //
        // the INF is supposed to be under %windir%
        // reuse a buffer
        //
        size = MyGetWindowsDirectory (catalogPath, ARRAYSIZE(catalogPath));
        if (!size || size >= ARRAYSIZE(catalogPath)) {
            __leave;
        }
        if (_tcsnicmp (infPath, catalogPath, size) || infPath[size] != TEXT('\\')) {
            __leave;
        }
        //
        // then cut the %windir% part and the filename
        //
        p = _tcsrchr (infPath, TEXT('\\'));
        if (!p) {
            __leave;
        }
        *p = 0;
        MoveMemory (infPath, infPath + size + 1, (p + 1 - (infPath + size + 1)) * sizeof (TCHAR));

        ofi.cbSize = sizeof(ofi);
        if (!SetupapiQueryInfOriginalFileInformation ||
            !SetupapiQueryInfOriginalFileInformation (info, 0, NULL, &ofi)) {
            //
            // use the current INF name
            //
            StringCchCopy (ofi.OriginalInfName, ARRAYSIZE(ofi.OriginalInfName), infName);
            ofi.OriginalCatalogName[0] = 0;
        }

        b = TRUE;
    }
    __finally {
        FREE(info);
    }

    if (!b) {
        return b;
    }

    if (ofi.OriginalCatalogName[0]) {
        //
        // get actual catalog name
        //
        lstrcpy (catName, infName);
        p = _tcsrchr (catName, TEXT('.'));
        if (!p) {
            p = _tcsrchr (catName, 0);
        }
        if (FAILED(StringCchCopy (p, catName + ARRAYSIZE(catName) - p, TEXT(".cat")))) {
            return FALSE;
        }
        //
        // get actual catalog location under %systemroot%
        //
        lstrcpy (catalogPath, TEXT("system32\\CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}"));
        //
        // check if the catalog actually exists
        //
        if (!pDoesCatalogExist (catalogPath, catName)) {
            //
            // just ignore it; driver will be treated as unsigned
            //
            ofi.OriginalCatalogName[0] = 0;
        }
    }

    if (!ofi.OriginalCatalogName[0]) {
        catName[0] = 0;
        catalogPath[0] = 0;
    }

    //
    // add the OEM .INF and .CAT files to the list
    //

    *InstallInfo = NULL;
    p = DupString(infPath);
    q = DupString(infName);
    r = DupString(ofi.OriginalInfName);
    s = catalogPath[0] ? DupString(catalogPath) : NULL;
    t = catName[0] ? DupString(catName) : NULL;
    u = ofi.OriginalCatalogName[0] ? DupString(ofi.OriginalCatalogName) : NULL;

    TempInstallInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_INSTALL_INFO ) );

    if(!(p && q && r &&
        (!catalogPath[0] || s) && (!catName[0] || t) && (!ofi.OriginalCatalogName[0] || u) && TempInstallInfo)) {
        goto clean0;
    }

    TempInstallInfo->Next = NULL;
    TempInstallInfo->InfRelPath = p;
    TempInstallInfo->InfFileName = q;
    TempInstallInfo->InfOriginalFileName = r;
    TempInstallInfo->CatalogRelPath = s;
    TempInstallInfo->CatalogFileName = t;
    TempInstallInfo->CatalogOriginalFileName = u;
    *InstallInfo = TempInstallInfo;
    return( TRUE );

clean0:
    if( q != NULL ) {
        FREE( q );
    }
    if( r != NULL ) {
        FREE( r );
    }
    if( s != NULL ) {
        FREE( s );
    }
    if( t != NULL ) {
        FREE( t );
    }
    if( u != NULL ) {
        FREE( u );
    }
    if( TempInstallInfo != NULL ) {
        FREE( TempInstallInfo );
    }
    return( FALSE );
}

BOOL
BuildDriverRegistryInformation(
    IN  LPTSTR                          ServiceName,
    OUT PUNSUPORTED_DRIVER_REGKEY_INFO* RegInfo
    )

{
    TCHAR   KeyPath[ MAX_PATH + 1 ];
    LPTSTR  p=NULL;
    PUNSUPORTED_DRIVER_REGKEY_INFO TempRegInfo = NULL;

    *RegInfo = NULL;
    StringCchCopy( KeyPath, ARRAYSIZE(KeyPath), TEXT( "SYSTEM\\CurrentControlSet\\Services\\" ) );
    if (FAILED(StringCchCat( KeyPath, ARRAYSIZE(KeyPath), ServiceName ))) {
        goto clean0;
    }

    p = DupString( KeyPath );
    TempRegInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_REGKEY_INFO ) );

    if( ( p == NULL ) || ( TempRegInfo == NULL ) ) {
        goto clean0;
    }

    TempRegInfo->Next = NULL;
    TempRegInfo->PredefinedKey = HKEY_LOCAL_MACHINE;
    TempRegInfo->KeyPath = p;
    TempRegInfo->MigrateVolatileKeys = FALSE;
    *RegInfo = TempRegInfo;
    return( TRUE );

clean0:
    if( p != NULL ) {
        FREE( p );
    }
    if( TempRegInfo != NULL ) {
        FREE( TempRegInfo );
    }
    return( FALSE );
}

VOID
FreeDriverInformationList(
    IN OUT  PUNSUPORTED_DRIVER_INFO* DriverInfo
    )
{
    while( *DriverInfo != NULL ) {
        PUNSUPORTED_DRIVER_INFO    p;

        p = *DriverInfo;
        *DriverInfo = p->Next;

        if( p->DriverId != NULL ) {
            FREE( p->DriverId );
        }

        if( p->KeyList != NULL ) {
            FreeRegistryInfoList( p->KeyList );
        }

        if( p->FileList != NULL ) {
            FreeFileInfoList( p->FileList );
        }

        if (p->InstallList) {
            FreeInstallInfoList (p->InstallList);
        }

        if( p-> HardwareIdsList != NULL ) {
            FreeHardwareIdList( p-> HardwareIdsList );
        }
        FREE( p );
    }
    *DriverInfo = NULL;
}


BOOL
BuildDriverInformation(
    IN  HKEY                     ServiceKey,
    IN  LPTSTR                   ServiceName,
    IN  LPTSTR                   FilePath,
    OUT PUNSUPORTED_DRIVER_INFO* DriverInfo
    )
{
    ULONG   Error;
    BOOL    b1, b2, b3, b4;

    PUNSUPORTED_PNP_HARDWARE_ID     TempIdInfo = NULL;
    PUNSUPORTED_DRIVER_INFO         TempFiltersInfo = NULL;
    PUNSUPORTED_DRIVER_FILE_INFO    TempFileInfo = NULL;
    PUNSUPORTED_DRIVER_INSTALL_INFO TempInstallInfo = NULL;
    PUNSUPORTED_DRIVER_REGKEY_INFO  TempRegInfo = NULL;
    PUNSUPORTED_DRIVER_INFO         TempDriverInfo = NULL;

    *DriverInfo = NULL;
    //
    //  Get hardware id info
    //
    b1 = BuildHardwareIdInfo( ServiceName,
                              &TempIdInfo );

    //
    //  Then get the file information
    //
    b2 = BuildDriverFileInformation( FilePath,
                                     &TempFileInfo );

    //
    //  Then get the install (INF&CAT) information
    //
    b3 = BuildDriverInstallInformation(ServiceName,
                                       &TempInstallInfo );

    //
    //  Then get the registry information
    //
    b4 = BuildDriverRegistryInformation( ServiceName,
                                         &TempRegInfo );

    if( !b1 || !b2 || !b3 || !b4) {
        goto cleanup1;
    }

    TempDriverInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_INFO ) );
    if( TempDriverInfo == NULL ) {
        goto cleanup1;
    }

    TempDriverInfo->Next = NULL;
    TempDriverInfo->DriverId = DupString( ServiceName );
    TempDriverInfo->KeyList = TempRegInfo;
    TempDriverInfo->FileList = TempFileInfo;
    TempDriverInfo->InstallList = TempInstallInfo;
    TempDriverInfo->HardwareIdsList = TempIdInfo;


    TempDriverInfo->Next = *DriverInfo;
    *DriverInfo = TempDriverInfo;
    return( TRUE );

cleanup1:

    if( TempIdInfo != NULL ) {
        FreeHardwareIdList( TempIdInfo );
    }

    if( TempFileInfo != NULL ) {
        FreeFileInfoList( TempFileInfo );
    }

    if( TempInstallInfo != NULL ) {
        FreeInstallInfoList( TempInstallInfo );
    }

    if( TempRegInfo != NULL ) {
        FreeRegistryInfoList( TempRegInfo );
    }

    return( FALSE );
}


BOOL
BuildUnsupportedDriverList(
    IN  PVOID                    TxtsetupSifHandle,
    OUT PUNSUPORTED_DRIVER_INFO* DriverList
    )

{
    ULONG   Error;
    HKEY    ScsiKey;
    ULONG   SubKeys;
    ULONG   i;
    LPTSTR  szScsiPath = TEXT("HARDWARE\\DEVICEMAP\\Scsi");


    *DriverList = NULL;

    //
    //  Find out if there is a SCSI miniport driver on this machine.
    //

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szScsiPath,
                          0,
                          KEY_READ,
                          &ScsiKey );
    if( Error != ERROR_SUCCESS ) {
        //
        //  Nothing to migrate
        //
        return( TRUE );
    }

    //
    //  Find out the number of subkeys under HKLM\HARDWARE\DEVICEMAP\Scsi.
    //

    Error = RegQueryInfoKey ( ScsiKey,
                              NULL,
                              NULL,
                              NULL,
                              &SubKeys,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if( (Error != ERROR_SUCCESS) || (SubKeys == 0) ) {
        //
        //  If we can't determine the number of subkeys, or if there is no
        //  subkey, then there is nothing to migrate, and we assume that all
        //  SCSI drivers are supported on NT.
        //
        RegCloseKey( ScsiKey );
        return( TRUE );
    }

    //
    //  Each subkey of HKLM\HARDWARE\DEVICEMAP\Scsi points to a service that controls
    //  a SCSI device. We check each one of them to find out the ones that are controlled
    //  by a driver that is not on the NT product.
    //
    for( i = 0; i < SubKeys; i++ ) {
        TCHAR       SubKeyName[ MAX_PATH + 1 ];
        TCHAR       ServiceKeyPath[ MAX_PATH + 1 ];
        ULONG       Length;
        FILETIME    LastWriteTime;
        HKEY        Key;
        BYTE        Data[ 512 ];
        ULONG       DataSize;
        ULONG       Type;
        PUNSUPORTED_DRIVER_INFO DriverInfo, p;
        BOOL        DeviceAlreadyFound;
        TCHAR       FilePath[ MAX_PATH + 1 ];

        Length = sizeof( SubKeyName ) / sizeof( TCHAR );
        Error = RegEnumKeyEx( ScsiKey,
                              i,
                              SubKeyName,
                              &Length,
                              NULL,
                              NULL,
                              NULL,
                              &LastWriteTime );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            continue;
        }

        Error = RegOpenKeyEx( ScsiKey,
                              SubKeyName,
                              0,
                              KEY_READ,
                              &Key );
        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            continue;
        }

        DataSize = sizeof( Data );
        Error = RegQueryValueEx( Key,
                                 TEXT("Driver"),
                                 NULL,
                                 &Type,
                                 Data,
                                 &DataSize );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            RegCloseKey( Key );
            continue;
        }
        RegCloseKey( Key );

        //
        //  Find out if this device is supported on NT 5.0
        //
        StringCchCopy( ServiceKeyPath, ARRAYSIZE(ServiceKeyPath), TEXT("SYSTEM\\CurrentControlSet\\Services\\" ) );        
        
        if (FAILED(StringCchCat( ServiceKeyPath, ARRAYSIZE(ServiceKeyPath), (LPTSTR)Data ))) 
        {
            //
            //  Assume it is supported, since there is nothing else we can do here.
            //
            continue;
        }

        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              ServiceKeyPath,
                              0,
                              KEY_READ,
                              &Key );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Assume it is supported, since there is nothing else we can do here.
            //
            continue;
        }

        if( IsDeviceSupported( TxtsetupSifHandle,
                               Key,
                               (LPTSTR)Data,
                               FilePath,
                               ARRAYSIZE(FilePath)
                             ) ) {
            RegCloseKey( Key );
            continue;
        }

        //
        //  Find out if this device  is already in our list
        //
        DeviceAlreadyFound = FALSE;
        for( p = (PUNSUPORTED_DRIVER_INFO)*DriverList; p && !DeviceAlreadyFound; p = p->Next ) {
            if( !lstrcmpi( p->DriverId, (LPTSTR)Data ) ) {
                DeviceAlreadyFound = TRUE;
            }
        }
        if( DeviceAlreadyFound ) {
            RegCloseKey( Key );
            continue;
        }

        //
        //  Find out if the device is listed in the section [ServicesToDisable] in dosnet.inf
        //
        if( IsServiceToBeDisabled( NtcompatInf,
                                   (LPTSTR)Data ) ) {
            RegCloseKey( Key );
            continue;
        }

        //
        // Find out if the file is listed in the [DriversToSkipCopy] section in
        // ntcompat.inf.
        //
        if( IsDriverCopyToBeSkipped( NtcompatInf,
                                     (LPTSTR)Data,
                                     FilePath ) ) {
	    RegCloseKey( Key );
            continue;
        }


        //
        //  The driver for this device is not supported and needs to be migrated.
        //
        DriverInfo = NULL;

        if( !BuildDriverInformation( Key,
                                     (LPTSTR)Data,
                                     FilePath,
                                     &DriverInfo ) ) {
            //
            // If we cannot build the driver information for this device, then
            // we inform the user that we detected an unsupported device, but that
            // we cannot migrate it. The user will have to provide the OEM disk
            // for this device during setupldr or textmode setup phases.
            //
            RegCloseKey( Key );
            FreeDriverInformationList( DriverList );
            return( FALSE );
        }

        DriverInfo->Next = (PUNSUPORTED_DRIVER_INFO)*DriverList;
        (PUNSUPORTED_DRIVER_INFO)*DriverList = DriverInfo;
        RegCloseKey( Key );
    }
    RegCloseKey( ScsiKey );

    return( TRUE );
}


DWORD
DumpRegInfoToInf(
    IN PUNSUPORTED_DRIVER_REGKEY_INFO RegList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szAddReg = TEXT("AddReg.");
    PUNSUPORTED_DRIVER_REGKEY_INFO p;

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szAddReg ) + lstrlen( DriverId ) + 1)*sizeof(TCHAR) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szAddReg );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = RegList; p != NULL; p = p->Next ) {
#if 0
        Error = DumpRegInfoToInfWorker( p->PredefinedKey,
                                        p->KeyPath,
                                        Context );
#endif
        Error = DumpRegKeyToInf( Context,
                                 p->PredefinedKey,
                                 p->KeyPath,
                                 TRUE,
                                 TRUE,
                                 TRUE,
                                 p->MigrateVolatileKeys );

        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


DWORD
DumpFileInfoToInf(
    IN PUNSUPORTED_DRIVER_FILE_INFO   FileList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szFiles = TEXT("Files.");
    PUNSUPORTED_DRIVER_FILE_INFO p;
    TCHAR   Line[ MAX_PATH ];

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szFiles ) + lstrlen( DriverId ) + 1)*sizeof(TCHAR) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szFiles );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = FileList; p != NULL; p = p->Next ) {
        StringCchCopy(Line, ARRAYSIZE(Line), p->FileName );
        StringCchCat(Line, ARRAYSIZE(Line), TEXT(",") );
        StringCchCat(Line, ARRAYSIZE(Line), p->TargetDirectory );
        Error = WriteText(Context->FileHandle,MSG_INF_SINGLELINE,Line);
        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


DWORD
DumpInstallInfoToAnswerFile (
    IN      PUNSUPORTED_DRIVER_INSTALL_INFO InstallInfo,
    IN      PCTSTR DriverId
    )
{
    PUNSUPORTED_DRIVER_INSTALL_INFO p;
    DWORD d;
    INT len;
    PTSTR buffer, append;
    TCHAR number[12];

    if (!ActualParamFile[0] || !FileExists (ActualParamFile, NULL)) {
        MYASSERT(FALSE);
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // start by writing the list of driver sections as
    // [Data]
    // OEMDrivers=<driver-section-1>,<driver-section-2>,...
    //

    len = 0;
    for (p = InstallInfo; p; p = p->Next) {
        if (len) {
            len++;      // for the comma
        }
        len += LENGTHOF("MigDrv.") + lstrlen (DriverId);
    }

    buffer = MALLOC((len + 1) * sizeof (TCHAR));
    if (!buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    append = buffer;
    for (p = InstallInfo; p; p = p->Next) {
        if (append > buffer) {
            *append++ = TEXT(',');
        }
        append += _sntprintf (append, len + 1 - (append - buffer), TEXT("MigDrv.%s"), DriverId);
    }

    d = ERROR_SUCCESS;

    if (!WritePrivateProfileString (
            WINNT_DATA,
            WINNT_OEMDRIVERS,
            buffer,
            ActualParamFile
            )) {
        d = GetLastError ();
    }

    if (d == ERROR_SUCCESS) {

        //
        // then for each section, write the mig info as in
        // [driver-section]
        // OemDriverPathName=<path> (path to the driver (may use environment variables)
        // OemInfName=<inf name> name of the inf to be installed from the above
        //            directory (there can be one or more infs in this directory, so
        //            this is a comma separated list)
        // OemDriverFlags=<flags>
        //
        for (p = InstallInfo; p; p = p->Next) {

            _sntprintf (buffer, len + 1, TEXT("MigDrv.%s"), DriverId);
            _sntprintf (number, ARRAYSIZE(number), TEXT("%u"), SETUP_OEM_MIGRATED_DRIVER);

            if (!WritePrivateProfileString (
                    buffer,
                    WINNT_OEMDRIVERS_PATHNAME,
                    IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
                    ActualParamFile
                    ) ||
                !WritePrivateProfileString (
                    buffer,
                    WINNT_OEMDRIVERS_INFNAME,
                    p->InfOriginalFileName ? p->InfOriginalFileName : p->InfFileName,
                    ActualParamFile
                    ) ||
                !WritePrivateProfileString (
                    buffer,
                    WINNT_OEMDRIVERS_FLAGS,
                    number,
                    ActualParamFile
                    )) {
                d = GetLastError ();
                break;
            }

        }

    }

    FREE(buffer);

    if (d != ERROR_SUCCESS) {
        //
        // try to clean up
        //
        WritePrivateProfileString (
            WINNT_DATA,
            WINNT_OEMDRIVERS,
            TEXT(""),
            ActualParamFile
            );
    }

    return d;
}

DWORD
DumpHardwareIdsToInf(
    IN PUNSUPORTED_PNP_HARDWARE_ID    HwIdList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szHardwareIds = TEXT("HardwareIds.");
    PUNSUPORTED_PNP_HARDWARE_ID p;
    LPTSTR  Line;
    ULONG   Length;

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szHardwareIds ) + lstrlen( DriverId ) + 1)*sizeof( TCHAR ) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szHardwareIds );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = HwIdList; p != NULL; p = p->Next ) {
        Length = (lstrlen( p->Id ) + lstrlen( p->Service ) + 3)*sizeof(TCHAR);
        if( p->ClassGuid ) {
            Length += (lstrlen( p->ClassGuid) + 1 )*sizeof(TCHAR);
        }
        Line = MALLOC( Length );
        if( Line == NULL ) {
            goto c0;
        }
        lstrcpy( Line, p->Id );
        lstrcat( Line, TEXT("=") );
        lstrcat( Line, p->Service );
        if( p->ClassGuid ) {
            lstrcat( Line, TEXT(",") );
            lstrcat( Line, p->ClassGuid );
        }
        Error = WriteText(Context->FileHandle,MSG_INF_SINGLELINE,Line);
        FREE( Line );

        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


BOOL
SaveUnsupportedDriverInfo(
    IN HWND ParentWindow,
    IN LPTSTR FileName,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    )
{
    HKEY Key;
    DWORD d;
    LONG l = ERROR_SUCCESS;
    TCHAR Path[MAX_PATH];
    PINFFILEGEN   InfContext;
    TCHAR SectionName[MAX_PATH];
    PUNSUPORTED_DRIVER_INFO p;

#if defined(_AMD64_) || defined(_X86_)
    if(Floppyless) {
        //These are both size MAX_PATH
        lstrcpy(Path,LocalBootDirectory);
    } else {
        Path[0] = FirstFloppyDriveLetter;
        Path[1] = TEXT(':');
        Path[2] = 0;
    }
#else
    //These are both size MAX_PATH
    lstrcpy(Path,LocalSourceWithPlatform);
#endif

    l = InfStart( FileName,
                  Path,
                  &InfContext);

    if(l != ERROR_SUCCESS) {
        return(FALSE);
    }

    for( p = DriverList; p != NULL; p = p->Next ) {
        if( p->KeyList != NULL ) {
            l = DumpRegInfoToInf( p->KeyList,p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
        if( p->FileList ) {
            l = DumpFileInfoToInf( p->FileList, p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
        if (p->InstallList) {
            l = DumpInstallInfoToAnswerFile(p->InstallList, p->DriverId);
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }

        if( p->HardwareIdsList ) {
            l = DumpHardwareIdsToInf( p->HardwareIdsList, p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
    }
    if( DriverList != NULL ) {
        l = InfCreateSection( TEXT("Devices"), &InfContext );
        if(l != NO_ERROR) {
            goto c0;
        }
        for( p = DriverList; p != NULL; p = p->Next ) {
            l = WriteText(InfContext->FileHandle,MSG_INF_SINGLELINE,p->DriverId);
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
    }

c0:
    InfEnd( &InfContext );
    if( l != ERROR_SUCCESS ) {
        StringCchCat( Path, ARRAYSIZE(Path), TEXT("\\") );
        if (SUCCEEDED(StringCchCat( Path, ARRAYSIZE(Path), FileName )))
        {
            DeleteFile( Path );
        }
        return( FALSE );
    }
    return(TRUE);
}

BOOL
MigrateUnsupportedNTDrivers(
    IN HWND   ParentWindow,
    IN PVOID  TxtsetupSifHandle
    )

{
    BOOL    b;
    PUNSUPORTED_DRIVER_INFO UnsupportedDriverList = NULL;

    b = BuildUnsupportedDriverList( TxtsetupSif, &UnsupportedDriverList );
    if( !CheckUpgradeOnly && b ) {
        if( UnsupportedDriverList ) {
            b = SaveUnsupportedDriverInfo( ParentWindow, WINNT_UNSUPDRV_INF_FILE, UnsupportedDriverList );
            if( b ) {
                b = AddUnsupportedFilesToCopyList( ParentWindow, UnsupportedDriverList );
                if( !b ) {
                    TCHAR   Path[ MAX_PATH + 1 ];
                    //
                    //  If we failed to add the files to the copy list, then
                    //  delete unsupdrv.inf since there is no point in migrating
                    //  these drivers.
                    //
#if defined(_AMD64_) || defined(_X86_)
                    if(Floppyless) {
                        //These are both size MAX_PATH
                        lstrcpy(Path,LocalBootDirectory);
                    } else {
                        Path[0] = FirstFloppyDriveLetter;
                        Path[1] = TEXT(':');
                        Path[2] = 0;
                    }
#else
                        //These are both size MAX_PATH
                        lstrcpy(Path,LocalSourceWithPlatform);
#endif
                    StringCchCat( Path, ARRAYSIZE(Path), TEXT("\\") );
                    if (SUCCEEDED(StringCchCat( Path, ARRAYSIZE(Path), WINNT_UNSUPDRV_INF_FILE )))
                    {
                        DeleteFile( Path );
                    }
                }
            }
        }
        FreeDriverInformationList( &UnsupportedDriverList );
    }
    if( !b ) {
        //
        // Inform the user that unsupported drivers could not be migrated.
        //
        MessageBoxFromMessage( ParentWindow,
                               MSG_CANT_MIGRATE_UNSUP_DRIVERS,
                               FALSE,
                               AppTitleStringId,
                               MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                             );
    }
    return( b );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\winnt32.c ===
#include "precomp.h"
#pragma hdrstop
#if defined(_X86_) //NEC98 I970721
#include <stdlib.h>
#include <stdio.h>
#include <winbase.h>
#include <n98boot.h>
#endif // PC98

#include <pencrypt.h>
#include <winsta.h>
#include <ntverp.h>
#include <undo.h>
#include "errorrep.h"
#include "faulth.h"

void PrepareBillBoard(HWND hwnd);
void TerminateBillBoard();
void CreateMainWindow();
UINT GetMediaProductBuildNumber (VOID);
void CopyExtraBVTDirs();

HWND BackgroundWnd2 = NULL;

//
// Misc globals.
//
HINSTANCE hInst;
DWORD TlsIndex;

//
// Upgrade information block
//

WINNT32_PLUGIN_INIT_INFORMATION_BLOCK info;



#if defined(_AMD64_) || defined(_X86_)
WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK Win9xInfo;
#if defined(_X86_)
PWINNT32_PLUGIN_SETAUTOBOOT_ROUTINE W95SetAutoBootFlag;
#endif
#endif

//
// This is the title of the application. It changes dynamically depending on
// whether we're on server or workstation, etc.
//
UINT AppTitleStringId = IDS_APPTITLE;

//
// Flag indicating whether we are initiating an MSI-install.
//
BOOL RunFromMSI = FALSE;

//
// Flag indicating whether we are initiating an Typical install
// Initialize to Typical install.
DWORD dwSetupFlags = UPG_FLAG_TYPICAL;
//
// Flag indicating whether we are initiating an upgrade.
//
BOOL Upgrade = TRUE;

//
// Flag to say if we need to write the AcpiHAL value to the winnt.sif file
//
BOOL WriteAcpiHalValue = FALSE;

//
// What should we write as the value for the AcpiHalValue
//
BOOL AcpiHalValue = FALSE;

//
// Flag indicating whether we're installing/upgrading to NT Server
//
BOOL Server;

//
// Flag to indicate if we are running BVT's
//
BOOL RunningBVTs = FALSE;

//
// When running BVT's, what baudrate should we set the debugger to?
//
LONG lDebugBaudRate = 115200;

//
// When running BVT's, what comport should we set the debugger to?
//
LONG lDebugComPort = 0;

//
// When running BVT's, should we copy the symbols locally?
//
BOOL CopySymbols = TRUE;

//
// Flag to indicate if we are running ASR tests
//
DWORD AsrQuickTest = 0;

//
// Flags for product type and flavor for upgrade modules
//

PRODUCTTYPE UpgradeProductType = UNKNOWN;
UINT ProductFlavor = UNKNOWN_PRODUCTTYPE;

//
// Global flag indicating whether the entire overall program operation
// was successful. Also a flag indicating whether to shut down automatically
// when the wizard is done in the non-unattended case.
//
BOOL GlobalResult = FALSE;
BOOL AutomaticallyShutDown = TRUE;

//
// Global OS version info.
//
OSVERSIONINFO OsVersion;
DWORD OsVersionNumber = 0;


//
// Flags indicating how we were run and whether to create
// a local source.
//
BOOL RunFromCD;
BOOL MakeLocalSource;
BOOL UserSpecifiedMakeLocalSource = FALSE;
BOOL NoLs = FALSE;
TCHAR UserSpecifiedLocalSourceDrive;
//
// the default for MLS is CD1 only
//
DWORD MLSDiskID = 1;

//
// advanced install options
//
BOOL ChoosePartition = TRUE;
BOOL UseSignatures = TRUE;
TCHAR InstallDir[MAX_PATH];

//
// SMS support
//
typedef DWORD (*SMSPROC) (char *, char*, char*, char*, char *, char *, char *, BOOL);
PSTR LastMessage = NULL;

#if defined(REMOTE_BOOT)
//
// Flag indicating whether we're running on a remote boot client.
//
BOOL RemoteBoot;

//
// Path to the machine directory for a remote boot client.
//
TCHAR MachineDirectory[MAX_PATH];
#endif // defined(REMOTE_BOOT)

//
// Flags indicating which Accessibility utilities to use
//
BOOL AccessibleMagnifier;
BOOL AccessibleKeyboard;
BOOL AccessibleVoice;
BOOL AccessibleReader;

//
// Build number we're upgrading from
//
DWORD BuildNumber = 0;

//
// Are any of the Accesssibility utilities enabled?
//
BOOL AccessibleSetup;

//
// Name of unattended script file to be used for Accessible Setup
//
TCHAR AccessibleScriptFile[MAX_PATH] = TEXT("setupacc.txt");

//
// Flags and values relating to unattended operation.
//
BOOL UnattendedOperation;
BOOL UnattendSwitchSpecified = FALSE;
PTSTR UnattendedScriptFile;
UINT UnattendedShutdownTimeout;
BOOL BatchMode;

//
// Source paths and count of paths.
//
TCHAR SourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
UINT SourceCount;

//
// source paths to current architecture's files
//
TCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];

TCHAR *UserSpecifiedOEMShare = NULL;

//
// Local source information.
//
TCHAR LocalSourceDrive;
DWORD LocalSourceDriveOffset;
TCHAR LocalSourceDirectory[MAX_PATH];
TCHAR LocalSourceWithPlatform[MAX_PATH];
TCHAR LocalBootDirectory[MAX_PATH];
#if defined(_AMD64_) || defined(_X86_)
TCHAR LocalBackupDirectory[MAX_PATH];
TCHAR FirstFloppyDriveLetter;
#endif



LONGLONG LocalSourceSpaceRequired;
LONGLONG WinDirSpaceFor9x = 0l;
BOOL BlockOnNotEnoughSpace = TRUE;
UINT UpgRequiredMb;
UINT UpgAvailableMb;
BOOL UpginfsUpdated = FALSE;

//
// Optional directory stuff.
//
UINT OptionalDirectoryCount;
TCHAR OptionalDirectories[MAX_OPTIONALDIRS][MAX_PATH];
UINT OptionalDirectoryFlags[MAX_OPTIONALDIRS];

//
// Name of INF. Constructed so we don't have to realloc anything.
// Note the default.
// Also, handles to dosnet.inf and txtsetup.sif.
//
TCHAR InfName[] = TEXT("DOSNET.INF");
PVOID MainInf;
TCHAR FullInfName[MAX_PATH];
PVOID TxtsetupSif;
PVOID NtcompatInf;

//
// Array of drive letters for all system partitions.
// Note that on amd64/x86 there will always be exactly one.
// The list is 0-terminated.
//
TCHAR SystemPartitionDriveLetters[27];
TCHAR SystemPartitionDriveLetter;

#ifdef UNICODE
UINT SystemPartitionCount;
PWSTR* SystemPartitionNtNames;
PWSTR SystemPartitionNtName;
#else
//
// if running on Win9x, there may be a LocalSourcePath passed as parameter
//
PCSTR g_LocalSourcePath;
#endif

//
// UDF stuff
//
LPCTSTR UniquenessId;
LPCTSTR UniquenessDatabaseFile;

//
// Variables relating to the multi string of options that are passed
// to plugin DLLs (Like Win9xUpg)
//
LPTSTR  UpgradeOptions;
DWORD   UpgradeOptionsLength;
DWORD   UpgradeOptionsSize;


//
// Compliance related variables
//
BOOL    NoCompliance = FALSE;

//
// Variables to hold messages concerning reason that the upgrade cannot be completed.
//
#define MSG_UPGRADE_OK 0
#define MSG_LAST_REASON 0
#define FAILREASON(x) MSG_##x,
DWORD UpgradeFailureMessages[] = {
    UPGRADEFAILURES /*,*/ MSG_UPGRADE_INIT_ERROR
};
#undef FAILREASON

UINT UpgradeFailureReason = 0;


TCHAR UpgradeSourcePath[MAX_PATH];



//
// Internal override to version checking. Useful for making quick
// privates for foreign language versions.
//
BOOL SkipLocaleCheck = FALSE;

//
// override for the win9x virus scanner check.
//
BOOL SkipVirusScannerCheck = FALSE;

BOOL UseBIOSToBoot = FALSE;

//
// Preinstall stuff
//
BOOL OemPreinstall;
#if defined(_AMD64_) || defined(_X86_)
POEM_BOOT_FILE OemBootFiles;
#endif

//
// Miscellaneous other command line parameters.
//
LPCTSTR CmdToExecuteAtEndOfGui;
BOOL AutoSkipMissingFiles;
BOOL HideWinDir;
TCHAR ProductId[64] = TEXT("\0");
UINT  PIDDays = 0;
LPTSTR g_EncryptedPID = NULL;
BOOL g_bDeferPIDValidation = FALSE;

//
// Flag indicating that the user cancelled.
// Handle for mutex used to guarantee that only one error dialog
// is on the screen at once.
//
BOOL Cancelled;
HANDLE UiMutex;

//
// Flag indicating user is aborting. This flag suppresses the final screen in
// cancel mode. I.E. The unsuccssessful completion page.
// win9xupg ReportOnly mode.
//
BOOL Aborted;

//
// Floppy-related stuff.
// Defined, but not used for ARC based machines.
//
BOOL MakeBootMedia = TRUE;
BOOL Floppyless = TRUE;

//
// Upgrade extension DLL.
//
UPGRADE_SUPPORT UpgradeSupport;

//
// Only check to see if we can upgrade or not.
//
BOOL CheckUpgradeOnly;
BOOL CheckUpgradeOnlyQ;
//
// Specifies that winnt32 runs as an "Upgrade Advisor"
// and not all installation files are available
//
BOOL UpgradeAdvisorMode;

//
// Build the command console.
//
BOOL BuildCmdcons;

//
// Are we doing the PID encyption?
//
BOOL PIDEncryption = FALSE;
BOOL g_Quiet      = FALSE;
#define WINNT_U_ENCRYPT  TEXT("ENCRYPT")

#ifdef RUN_SYSPARSE
// Remove this before RTM.
// Be default run sysparse
BOOL NoSysparse = FALSE;
PROCESS_INFORMATION piSysparse = { NULL, NULL, 0, 0};
LRESULT SysParseDlgProc( IN HWND hdlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam);
HWND GetBBhwnd();
#endif

// Name of module for Program compatibility.
static const TCHAR ShimEngine_ModuleName[] = TEXT("Shimeng.dll");

//
// Log Functions
//

SETUPOPENLOG fnSetupOpenLog = NULL;
SETUPLOGERROR fnSetupLogError = NULL;
SETUPCLOSELOG fnSetupCloseLog = NULL;

//
//  Unsupported driver list
//  This list contains the information about the unsupported drivers that needs
//  to be migrated on a clean install or upgrade.
//
// PUNSUPORTED_DRIVER_INFO UnsupportedDriverList = NULL;

//
// When Winnt32.exe is launched over a network, these two parameters have valid
// values and need to be taken into consideration before displaying any dialog box
//

HWND Winnt32Dlg = NULL;
HANDLE WinNT32StubEvent = NULL;
HINSTANCE hinstBB = NULL;

//
// List of required privileges (on NT) to run this app
//

#ifdef UNICODE

PCTSTR g_RequiredPrivileges[] = {
    SE_SHUTDOWN_NAME,
    SE_BACKUP_NAME,
    SE_RESTORE_NAME,
    SE_SYSTEM_ENVIRONMENT_NAME
};

#define COUNT_OF_PRIVILEGES     (ARRAYSIZE(g_RequiredPrivileges))

#endif


//
// Definition for dynamically-loaded InitiateSystemShutdownEx API
//

typedef
(WINAPI *PFNINITIATESYSTEMSHUTDOWNEX)(LPTSTR,
                                      LPTSTR,
                                      DWORD,
                                      BOOL,
                                      BOOL,
                                      DWORD);


//
// Routines from Setupapi.dll
//

//
// ISSUE: be careful when using this routine on NT4, as it may fail;
// setupapi on NT4 doesn't understand LZX compression, currently used to compress files
//
DWORD
(*SetupapiDecompressOrCopyFile)(
    IN  PCTSTR  SourceFileName,
    OUT PCTSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    );

HINF
(*SetupapiOpenInfFile)(
    IN  LPCTSTR FileName,
    IN  LPCTSTR InfClass,    OPTIONAL
    IN  DWORD   InfStyle,
    OUT PUINT   ErrorLine    OPTIONAL
    );

VOID
(*SetupapiCloseInfFile)(
    IN HINF InfHandle
    );

BOOL
(*SetupapiFindFirstLine)(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

BOOL
(*SetupapiFindNextLine)(
    IN  PINFCONTEXT Context1,
    OUT PINFCONTEXT Context2
    );

BOOL
(*SetupapiFindNextMatchLine)(
    IN  PINFCONTEXT Context1,
    IN  PCTSTR Key,
    OUT PINFCONTEXT Context2
    );

LONG
(*SetupapiGetLineCount)(
    IN HINF   InfHandle,
    IN LPCTSTR Section
    );

DWORD
(*SetupapiGetFieldCount)(
    IN  PINFCONTEXT Context
    );

BOOL
(*SetupapiGetStringField)(
    IN  PINFCONTEXT Context,
    DWORD FieldIndex,
    PTSTR ReturnBuffer,
    DWORD ReturnBufferSize,
    PDWORD RequiredSize
    );

BOOL
(*SetupapiGetLineByIndex)(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

HSPFILEQ
(*SetupapiOpenFileQueue) (
    VOID
    );

BOOL
(*SetupapiCloseFileQueue) (
    IN HSPFILEQ QueueHandle
    );

BOOL
(*SetupapiQueueCopy) (
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

BOOL
(*SetupapiCommitFileQueue) (
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

UINT
(*SetupapiDefaultQueueCallback) (
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

PVOID
(*SetupapiInitDefaultQueueCallback) (
    HWND OwnerWindow
);

VOID
(*SetupapiTermDefaultQueueCallback) (
    PVOID Context
);

#ifdef UNICODE

BOOL
(*SetupapiGetSourceFileLocation) (
    HINF InfHandle,          // handle of an INF file
    PINFCONTEXT InfContext,  // optional, context of an INF file
    PCTSTR FileName,         // optional, source file to locate
    PUINT SourceId,          // receives the source media ID
    PTSTR ReturnBuffer,      // optional, receives the location
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

BOOL
(*SetupapiGetInfInformation) (
    LPCVOID InfSpec,         // handle or filename of the INF file
    DWORD SearchControl,     // how to search for the INF file
    PSP_INF_INFORMATION ReturnBuffer, // optional, receives the INF info
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

BOOL
(*SetupapiQueryInfFileInformation) (
    PSP_INF_INFORMATION InfInformation, // structure that contains the INF info
    UINT InfIndex,           // index of the file to investigate
    PTSTR ReturnBuffer,      // optional, receives the information
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

BOOL
(*SetupapiQueryInfOriginalFileInformation) (
    PSP_INF_INFORMATION InfInformation,         // structure that contains the INF information
    UINT InfIndex,                              // index of the file to investigate
    PSP_ALTPLATFORM_INFO AlternatePlatformInfo, // optional, receives the alternate platform information
    PSP_ORIGINAL_FILE_INFO OriginalFileInfo     // original file information
);

#endif

//
//srclient.dll (SystemRestore) functions
//
DWORD
(*SRClientDisableSR) (
    LPCWSTR pszDrive
    );



//
// NEC98 Specific local function
//

VOID
DeleteNEC98DriveAssignFlag(
    VOID
    );

BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    );

VOID
LocateFirstFloppyDrive(
    VOID
    );

VOID
W95SetABFwFresh(
    int bBootDrvLtr
    );

BOOL
NEC98CheckDMI(
    VOID
    );

VOID
DisableSystemRestore( void );

//
//
//

BOOL
GetArgsFromUnattendFile(
    VOID
    )
/*++

Routine Description:

    This routine read relevent arguments from any specified unattended file.
    Specifically we are concerned here with oem preinstall stuff and whether
    to upgrade.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the unattend file the user specified is
    valid. If not, the user will have been told about why.

    If the user specified no unattend file on the command line, then the
    return value is TRUE.

--*/

{
    DWORD d;
    TCHAR Buffer[2*MAX_PATH];
    BOOL b = TRUE;
    PVOID InfHandle;
    LPCTSTR p;
    BOOL userDDU = FALSE;
#if defined(_AMD64_) || defined(_X86_)
    POEM_BOOT_FILE FileStruct,Previous;
#endif

    if(UnattendedScriptFile) {

        d = GetFileAttributes(UnattendedScriptFile);
        if(d == (DWORD)(-1)) {

            MessageBoxFromMessage(
                NULL,
                MSG_UNATTEND_FILE_INVALID,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                UnattendedScriptFile
                );

            return(FALSE);
        }

        //
        // Before we do much else, we should make sure the user has given
        // us a valid answer file.  We can't check everything, but a quick
        // and dirty sanity check would be to go ahead and call LoadInfFile
        // and see what he says about it.
        //

        switch(LoadInfFile(UnattendedScriptFile,FALSE,&InfHandle)) {
            case NO_ERROR:
                break;
            case ERROR_NOT_ENOUGH_MEMORY:

                MessageBoxFromMessage(
                    NULL,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                return(FALSE);
                break;

            default:

                MessageBoxFromMessage(
                    NULL,
                    MSG_UNATTEND_FILE_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    UnattendedScriptFile
                    );

                return(FALSE);
                break;
        }

        //
        // Check upgrade.
        //
        // In previous versions of NT the default was not to upgrade if
        // the value wasn't present at all. In addition there was an upgrade
        // type of "single" which meant to upgrade only if there was only one
        // NT build on the machine.
        //
        // We preserve the original default behavior but don't bother with
        // dealing with the "single" semantics -- just accept "single" as
        // a synonym for "yes".
        //

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            ISNT() ? WINNT_U_NTUPGRADE : WINNT_U_WIN95UPGRADE,
            WINNT_A_NO,
            Buffer,
            ARRAYSIZE(Buffer),
            UnattendedScriptFile
            );

        Upgrade = ((lstrcmpi(Buffer,WINNT_A_YES) == 0) || (lstrcmpi(Buffer,TEXT("single")) == 0));

#if defined(REMOTE_BOOT)
        //
        // Remote boot machines MUST upgrade.
        //

        if (RemoteBoot) {
            Upgrade = TRUE;
        }
#endif // defined(REMOTE_BOOT)

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            WINNT_OEMPREINSTALL,
            WINNT_A_NO,
            Buffer,
            ARRAYSIZE(Buffer),
            UnattendedScriptFile
            );

        if(!lstrcmpi(Buffer,WINNT_A_YES)) {
            //
            // NTBUG9: 770278
            // block setup if they specify both Upgrade and OemPreinstall
            //
            if (Upgrade) {
                MessageBoxFromMessage(
                    NULL,
                    MSG_UNATTEND_FILE_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    UnattendedScriptFile
                    );
                return FALSE;
            }

            OemPreinstall = TRUE;

            //
            // Add oem system directory to the list of optional directories.
            //
            // The user may have specified a different location for the $OEM$
            // directory, so we need to look in the unattend file for that.
            //
            GetPrivateProfileString(
                WINNT_UNATTENDED,
                WINNT_OEM_DIRLOCATION,
                WINNT_A_NO,
                Buffer,
                ARRAYSIZE(Buffer),
                UnattendedScriptFile
                );
            if( lstrcmpi( Buffer, WINNT_A_NO ) ) {
                //
                // make sure the location ends with "\$oem$".  If it
                // doesn't, then append it ourselves.
                //
                _tcsupr( Buffer );
                if( !_tcsstr(Buffer, TEXT("$OEM$")) ) {
                    if (!ConcatenatePaths( Buffer, TEXT("$OEM$"), ARRAYSIZE(Buffer) )) {
                        DebugLog (
                            Winnt32LogError,
                            TEXT("The unattend file %1 specifies a path too long for key %2"),
                            0,
                            UnattendedScriptFile,
                            WINNT_OEM_DIRLOCATION
                            );
                        return FALSE;
                    }
                }
                UserSpecifiedOEMShare = DupString( Buffer );

                RememberOptionalDir( UserSpecifiedOEMShare, OPTDIR_OEMSYS );
            } else {
                RememberOptionalDir(WINNT_OEM_DIR,OPTDIR_OEMSYS | OPTDIR_ADDSRCARCH);
            }

            if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
                //
                // Remember all oem boot files and then unload the inf.
                //
                Previous = NULL;
                for(d=0; b && (p=InfGetFieldByIndex(InfHandle,WINNT_OEMBOOTFILES,d,0)); d++) {
                    if(FileStruct = MALLOC(sizeof(OEM_BOOT_FILE))) {
                        FileStruct->Next = NULL;
                        if(FileStruct->Filename = DupString(p)) {
                            if(Previous) {
                                Previous->Next = FileStruct;
                            } else {
                                OemBootFiles = FileStruct;
                            }
                            Previous = FileStruct;
                        } else {
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                    }
                }

                if(!b) {
                    MessageBoxFromMessage(
                        NULL,
                        MSG_OUT_OF_MEMORY,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );
                }
#endif // defined(_AMD64_) || defined(_X86_)
            }  // if (!IsArc())

        }

        GetPrivateProfileString(
            WINNT_USERDATA,
            WINNT_US_PRODUCTID,
            WINNT_A_NO,
            Buffer,
            ARRAYSIZE(Buffer),
            UnattendedScriptFile
            );

        if( lstrcmpi( Buffer, WINNT_A_NO ) == 0 )
        {
            GetPrivateProfileString(
                WINNT_USERDATA,
                WINNT_US_PRODUCTKEY,
                WINNT_A_NO,
                Buffer,
                ARRAYSIZE(Buffer),
                UnattendedScriptFile
                );
        }

        // Buffer contains the Product ID or WINNT_A_NO if none in the unattend file
        // Is the PID encrypted?
        // We would only need to check for the exact length, but since we can defer
        // the decryption of an encrypted PID until GUI mode, 2 time the length should be saver
        if (lstrlen(Buffer) > (4 + MAX_PID30_EDIT*5)*2)
        {
            LPTSTR szDecryptedPID = NULL;
            HRESULT hr = ValidateEncryptedPID(Buffer, &szDecryptedPID);
            DebugLog (Winnt32LogInformation, TEXT("ValidateEncryptedPID returned: <hr=0x%1!lx!>"), 0, hr);
            if (FAILED(hr) || (hr == S_OK))
            {
                // if FAILED(hr) assume Crypto is not installed correct.
                // If we encrypted the data, but the encrypted data did not contain valid data
                // the function does not return a FAILED(hr) and does not return S_OK;
                // It returns 0x01 to 0x04, depending on what failure.
                // In the case we get a failure from Crypto ( it returns FAILED(hr))
                // we want to defer the checking of the PID until GUI mode
                // for that we need to save the encrypted PID

                // First assume we defer PID validation.
                g_bDeferPIDValidation = TRUE;
                g_EncryptedPID = GlobalAlloc(GPTR, (lstrlen(Buffer) + 1) *sizeof(TCHAR));
                if (g_EncryptedPID)
                {
                    // Save the decrypted PID we need to write it to winnt.sif
                    lstrcpy(g_EncryptedPID, Buffer);
                }
                // Only if the PID could be decrypted and falls in to the time interval
                // do we save the decrypted PID.
                if (hr == S_OK)
                {
                    lstrcpyn(ProductId, szDecryptedPID, ARRAYSIZE(ProductId));
                    g_bDeferPIDValidation = FALSE;
                }
            }
            // else we could encrypt the data, but something is wrong
            //
            if (szDecryptedPID)
            {
                GlobalFree(szDecryptedPID);
            }
        }
        else if (lstrcmpi(Buffer, WINNT_A_NO))
        {
            lstrcpyn(ProductId, Buffer, ARRAYSIZE(ProductId));
        }
        else
        {
            *ProductId = TEXT('\0');
        }

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            TEXT("FileSystem"),
            TEXT(""),
            Buffer,
            ARRAYSIZE(Buffer),
            UnattendedScriptFile
            );

        ForceNTFSConversion = !lstrcmpi(Buffer, TEXT("ConvertNTFS"));

        if (!g_DynUpdtStatus->Disabled && !g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            //
            // will Setup do the Dynamic Updates step at all?
            //
            if (GetPrivateProfileString(
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESDISABLE,
                    TEXT(""),
                    Buffer,
                    ARRAYSIZE(Buffer),
                    UnattendedScriptFile
                    )
#ifdef PRERELEASE
                || GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        TEXT("disabledynamicupdates"),
                        TEXT(""),
                        Buffer,
                        ARRAYSIZE(Buffer),
                        UnattendedScriptFile
                        )
#endif
                    ) {
                userDDU = TRUE;
                if( !lstrcmpi( Buffer, WINNT_A_YES ) ) {
                    g_DynUpdtStatus->Disabled = TRUE;
                    g_DynUpdtStatus->UserSpecifiedUpdates = FALSE;
                }
            }
        }
        if (!g_DynUpdtStatus->Disabled && !g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            //
            // get location of previously downloaded files (if any)
            //
            if (GetPrivateProfileString(
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESHARE,
                    TEXT(""),
                    Buffer,
                    ARRAYSIZE(Buffer),
                    UnattendedScriptFile
                    )) {

                if (MyGetFullPathName (
                            Buffer,
                            ARRAYSIZE(g_DynUpdtStatus->DynamicUpdatesSource),
                            g_DynUpdtStatus->DynamicUpdatesSource,
                            NULL) &&
                    DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {

                    RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
                    g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;

                } else {
                    b = FALSE;
                }
            } else {
                if (!userDDU) {
                    g_DynUpdtStatus->Disabled = TRUE;
                }
            }
        }

        UnloadInfFile(InfHandle);
    }

    return(b);
}


BOOL
ParseArguments(
    VOID
    )

/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /batch                      suppress message boxes

    /cmd:command_line           command to execute at end of gui setup

    /copydir:dirname            tree copy directory from source into %systemroot%
                                Note that this supports ".." syntax to backtrack
                                one directory

    /copysource:dirname         copy directory for use as source

    /debug[level][:filename]    maintain debug log at level, defaults to warning level 2
                                and file c:\winnt32.log

    /DynamicUpdatesDisable      disable dynamic setup

    /s:source                   specify source

    /syspart:letter             force a drive to be considered the system partition

    /tempdrive:letter           manually specify drive for local source

    /udf:id[,file]              uniqueness id and optional udf

    /unattend[num][:file]       unattended mode with optional countdown
                                and unattend file. (The countdown is ignored
                                on Win95.) 'Unattended' is also accepted.

    /nodownload                 not documented; on Win9x installs over the net,
                                do NOT download program files to a temporary directory and restart
                                from there. Effective in winnt32.exe only; here it's ignored

    /local                      not documented; used by winnt32.exe only; ignored in winnt32a|u.dll

    /#                          introduces undoc'ed/internal switches. Handed off
                                to internal switch handler in internal.c.

    /restart                    specified when winnt32.exe was restarted as a result
                                of updating one of the underlying modules; internal only

    /nosysparse                 suppress running sysparse.

    /E:"PID:days"               To encrypt the PID and add a delta of days,
                                needs to have /Unattend:file specified.

Arguments:

    None. Arguments are retreived via GetCommandLine().

Return Value:

    None.

--*/

{
    LPTSTR Arg;
    LPTSTR BadParam = NULL;
    LPTSTR Colon;
    LPTSTR p;
    BOOL Valid;
    LPCTSTR DebugFileLog;
    LONG DebugLevel;
    BOOL b;
    unsigned u;
    int argc;
    LPTSTR *argv;
    DWORD d;
    WIN32_FIND_DATA fd;
    DWORD attr;
    TCHAR buffer[MAX_PATH];

    argv = CommandLineToArgv(&argc);

    //
    // Skip program name. We should always get back argc as at least 1,
    // but be robust anyway.
    //
    if(argc) {
        argc--;
        argv++;
    }

    DebugFileLog = NULL;
    DebugLevel = 0;
    Valid = TRUE;

    while(argc--) {

        Arg = *argv++;

        if((*Arg == TEXT('/')) || (*Arg == TEXT('-'))) {

            switch(_totupper(Arg[1])) {

            case TEXT('B'):

                if(!_tcsnicmp(Arg+1,TEXT("batch"),LENGTHOF("batch"))) {
                    BatchMode = TRUE;
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('C'):

                if(!_tcsnicmp(Arg+1,TEXT("copydir:"),LENGTHOF("copydir:"))) {
                    if(Arg[9]) {
                        RememberOptionalDir(Arg+9, OPTDIR_PLATFORM_SPECIFIC_FIRST);
                    } else {
                        Valid = FALSE;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("copysource:"),LENGTHOF("copysource:"))) {
                    if(Arg[12]) {
                        TCHAR TempString[MAX_PATH];

                        RememberOptionalDir(Arg+12, OPTDIR_TEMPONLY| OPTDIR_ADDSRCARCH);
#if defined(_WIN64)
                        //
                        // Add the i386\<optional dir> folder if it exists. This helps in the lang folder case where
                        // we advocate in the network install case to explicitly specify /copysource:lang

                        lstrcpy( TempString, TEXT("..\\I386"));
                        if (!ConcatenatePaths ( TempString, Arg+12, ARRAYSIZE(TempString))) {
                            Valid = FALSE;
                            break;
                        }


                        //Also check if an I386 equivalent WOW directory exists

                        AddCopydirIfExists( TempString, OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP );

#endif

                    } else {
                        Valid = FALSE;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("cmd:"),LENGTHOF("cmd:"))) {
                    if(CmdToExecuteAtEndOfGui) {
                        Valid = FALSE;
                    } else {
                        CmdToExecuteAtEndOfGui = Arg+5;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("checkupgradeonly"),LENGTHOF("checkupgradeonly"))) {
                    CheckUpgradeOnly = TRUE;
                    UnattendedOperation = TRUE;

                    //
                    // Tell the win9X upgrade dll to generate a
                    // report.
                    //
                    InternalProcessCmdLineArg( TEXT("/#U:ReportOnly") );
                    InternalProcessCmdLineArg( TEXT("/#U:PR") );


                    //
                    // See if the user wants this to run *really*
                    // quietly...
                    //
                    if(!_tcsnicmp(Arg+1,TEXT("checkupgradeonlyq"),LENGTHOF("checkupgradeonlyq"))) {
                        //
                        // Yep.  Tell everyone to go through quietly...
                        //
                        CheckUpgradeOnlyQ = TRUE;
                        InternalProcessCmdLineArg( TEXT("/#U:CheckUpgradeOnlyQ") );
                    }

                } else if(!_tcsnicmp(Arg+1,TEXT("cmdcons"),LENGTHOF("cmdcons"))) {
                    BuildCmdcons = TRUE;
                    NoCompliance = TRUE;    // disable the compliance checking
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('D'):

                if (_tcsicmp(Arg+1,WINNT_U_DYNAMICUPDATESDISABLE) == 0
#ifdef PRERELEASE
                    || _tcsicmp(Arg+1,TEXT("disabledynamicupdates")) == 0
#endif
                    ) {
                    g_DynUpdtStatus->Disabled = TRUE;
                    break;
                }

                if (!_tcsnicmp (Arg + 1, WINNT_U_DYNAMICUPDATESHARE, LENGTHOF(WINNT_U_DYNAMICUPDATESHARE)) &&
                    Arg[LENGTHOF(WINNT_U_DYNAMICUPDATESHARE) + 1] == TEXT(':')) {
                    //
                    // Updated files specified on the command line
                    //
                    if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                        Valid = FALSE;
                        break;
                    }

                    if (!MyGetFullPathName (
                            Arg + 1 + LENGTHOF(WINNT_U_DYNAMICUPDATESHARE) + 1,
                            ARRAYSIZE(g_DynUpdtStatus->DynamicUpdatesSource),
                            g_DynUpdtStatus->DynamicUpdatesSource,
                            NULL) ||
                        !DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {

                        Valid = FALSE;
                        break;
                    }

                    RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
                    g_DynUpdtStatus->UserSpecifiedUpdates = !g_DynUpdtStatus->Disabled;
                    break;
                }

                if (!_tcsnicmp (Arg + 1, WINNT_U_DYNAMICUPDATESPREPARE, LENGTHOF(WINNT_U_DYNAMICUPDATESPREPARE)) &&
                    Arg[LENGTHOF(WINNT_U_DYNAMICUPDATESPREPARE) + 1] == TEXT(':')) {

                    if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                        Valid = FALSE;
                        break;
                    }

                    if (!MyGetFullPathName (
                            Arg + 1 + LENGTHOF(WINNT_U_DYNAMICUPDATESPREPARE) + 1,
                            ARRAYSIZE(g_DynUpdtStatus->DynamicUpdatesSource),
                            g_DynUpdtStatus->DynamicUpdatesSource,
                            NULL) ||
                        !DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {

                        Valid = FALSE;
                        break;
                    }

                    RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);

                    g_DynUpdtStatus->PrepareWinnt32 = TRUE;
                    g_DynUpdtStatus->UserSpecifiedUpdates = !g_DynUpdtStatus->Disabled;
                    break;
                }

                if(DebugFileLog || _tcsnicmp(Arg+1,TEXT("debug"),LENGTHOF("debug"))) {
                    Valid = FALSE;
                    break;
                }

                DebugLevel = _tcstol(Arg+6,&Colon,10);
                if((DebugLevel == -1) || (*Colon && (*Colon != TEXT(':')))) {
                    Valid = FALSE;
                    break;
                }

                if(Colon == Arg+6) {
                    //
                    // No debug level specified, use default
                    //
                    DebugLevel = Winnt32LogInformation;
                }

                if(*Colon) {
                    //
                    // Log file name was specified.
                    //
                    Colon++;
                    if(*Colon) {
                        DebugFileLog = Colon;
                    } else {
                        Valid = FALSE;
                        break;
                    }
                }
                break;

            case TEXT('E'):

                //
                // Take care of headless parameters.
                //
                if( !_tcsnicmp(Arg+1,WINNT_U_HEADLESS_REDIRECT,LENGTHOF(WINNT_U_HEADLESS_REDIRECT)) ) {
                    if( Arg[LENGTHOF(WINNT_U_HEADLESS_REDIRECT)+2] ) {
                        if (FAILED (StringCchCopy (
                                HeadlessSelection,
                                ARRAYSIZE(HeadlessSelection),
                                Arg+(LENGTHOF(WINNT_U_HEADLESS_REDIRECT)+2)
                                ))) {
                            Valid = FALSE;
                        }
                    } else {
                        Valid = FALSE;
                    }
                } else if( !_tcsnicmp(Arg+1,WINNT_U_HEADLESS_REDIRECTBAUDRATE,LENGTHOF(WINNT_U_HEADLESS_REDIRECTBAUDRATE)) ) {
                    if( Arg[LENGTHOF(WINNT_U_HEADLESS_REDIRECTBAUDRATE)+2] ) {
                        HeadlessBaudRate = _tcstoul(Arg+(LENGTHOF(WINNT_U_HEADLESS_REDIRECTBAUDRATE)+2),NULL,10);
                    } else {
                        Valid = FALSE;
                    }
                }
                else if ( _tcsnicmp(Arg+1,WINNT_U_ENCRYPT,LENGTHOF(WINNT_U_ENCRYPT)) == 0 )
                {
                    LPTSTR pTmp;
                    pTmp = &Arg[LENGTHOF(WINNT_U_ENCRYPT)+1];
                    Valid = FALSE;
                    // Make sure we have /Encrypt:
                    if (*pTmp == TEXT(':'))
                    {
                        pTmp++;
                        while (*pTmp && (*pTmp != TEXT(':')))
                        {
                            pTmp = CharNext(pTmp);
                        }
                        if (*pTmp == TEXT(':'))
                        {
                            *pTmp = TEXT('\0');
                            ++pTmp;
                            PIDDays = _tcstoul(pTmp, NULL, 10);
                            Valid = ((PIDDays >= 5) && (PIDDays <= 60));
                        }
                        // Save the product ID.
                        if (FAILED (StringCchCopy (
                                        ProductId,
                                        ARRAYSIZE(ProductId),
                                        &Arg[LENGTHOF(WINNT_U_ENCRYPT)+2]
                                        ))) {
                            Valid = FALSE;
                            break;
                        }
                        PIDEncryption = TRUE;
                    }
                }else{
                     Valid = FALSE;
                }
                break;

            case TEXT('L'):
                if (_tcsicmp (Arg+1, TEXT("local"))) {
                    Valid = FALSE;
                }
                break;

            case TEXT('M'):
                //
                // Alternate source for missing files
                //
                if(Arg[2] == TEXT(':')) {
                    if (!MyGetFullPathName (Arg+3, ARRAYSIZE(AlternateSourcePath), AlternateSourcePath, NULL) ||
                        !DoesDirectoryExist (AlternateSourcePath)) {

                        Valid = FALSE;
                        break;
                    }

                    //
                    // If the user is using the /M switch, he's got privates
                    // that he wants to use.  It's possible that some of these
                    // privates will be in the driver cab, inwhich case, he'd
                    // have to make a copy of the cab with his private.  Unreasonable.
                    // We can get around this by simply copying all the files
                    // from the user-specified private directory (/M<foobar>)
                    // into the local source.  textmode and guimode will look
                    // for files before extractifi ming them from the CAB.  All we
                    // need to do here is add the user's directory to the master
                    // copy list.
                    //
                    RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);

                    //
                    // If we're using privates, go ahead and copy the
                    // source local.
                    //
                    MakeLocalSource = TRUE;
                    UserSpecifiedMakeLocalSource = TRUE;
                } else if( !_tcsnicmp( Arg+1, TEXT("MakeLocalSource"), 15)) {
                    //
                    // check if there are any options for this switch
                    //
                    if (Arg[16] && Arg[16] != TEXT(':')) {
                        Valid = FALSE;
                        break;
                    }
                    MakeLocalSource = TRUE;
                    UserSpecifiedMakeLocalSource = TRUE;
                    if (!Arg[16]) {
                        break;
                    }
                    if (!Arg[17]) {
                        //
                        // add this for W2K backwards compatibility
                        //
                        break;
                    }
                    if (!_tcsicmp (Arg + 17, TEXT("all"))) {
                        //
                        // copy ALL CDs
                        //
                        MLSDiskID = 0;
                    } else {
                        DWORD chars;
                        if (!_stscanf (Arg + 17, TEXT("%u%n"), &MLSDiskID, &chars) || Arg[17 + chars] != 0) {
                            Valid = FALSE;
                        }
                    }
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('N'):
                //
                // Possibly a /noreboot or /nosysparse?
                //
                if( !_tcsnicmp( Arg+1, TEXT("noreboot"), LENGTHOF("noreboot"))
                    //
                    // add this hack for W2K backwards compatibility
                    //
                    && (!Arg[LENGTHOF("noreboot") + 1] ||
                        Arg[LENGTHOF("noreboot") + 1] == TEXT(':') && !Arg[LENGTHOF("noreboot") + 2]) ) {
                    AutomaticallyShutDown = FALSE;
                }
#ifdef RUN_SYSPARSE
                else if( !_tcsicmp( Arg+1, TEXT("nosysparse"))) {
                    NoSysparse = TRUE;
                }
#endif
                else if( _tcsicmp( Arg+1, TEXT("nodownload"))) {
                    Valid = FALSE;
                }
                break;

            case TEXT('Q'):
                g_Quiet = TRUE;
                break;

            case TEXT('R'):
                if (!_tcsnicmp (Arg + 1, TEXT("Restart"), LENGTHOF("Restart"))) {
                    g_DynUpdtStatus->Winnt32Restarted = TRUE;
                    if (Arg[LENGTHOF("Restart") + 1] == TEXT(':')) {
                        lstrcpy (g_DynUpdtStatus->RestartAnswerFile, Arg + LENGTHOF("Restart:") + 1);
                    } else if (Arg[LENGTHOF("Restart") + 1]) {
                        Valid = FALSE;
                    }
                } else {
                    Valid = FALSE;
                }

                break;

            case TEXT('S'):

                if((Arg[2] == TEXT(':')) && Arg[3]) {
                    //
                    // Ignore extraneous sources
                    //
                    if(SourceCount < MAX_SOURCE_COUNT) {
                        if (GetFullPathName (
                                Arg+3,
                                ARRAYSIZE(NativeSourcePaths[SourceCount]),
                                NativeSourcePaths[SourceCount],
                                NULL
                                )) {
                            SourceCount++;
                        } else {
                            Valid = FALSE;
                        }
                    }
                } else {
                    if(!_tcsnicmp(Arg+1,TEXT("syspart:"),LENGTHOF("syspart:"))
                    && Arg[1 + LENGTHOF("syspart:")]
                    && (_totupper(Arg[1 + LENGTHOF("syspart:")]) >= TEXT('A'))
                    && (_totupper(Arg[1 + LENGTHOF("syspart:")]) <= TEXT('Z'))
                    && !ForcedSystemPartition) {
#ifdef _X86_
                        if (IsNEC98()){
                            if (!IsValidDrive(Arg[1 + LENGTHOF("syspart:")])){
                               Valid = FALSE;
                               break;
                            }
                        }
#endif
                        ForcedSystemPartition = (TCHAR)_totupper(Arg[1 + LENGTHOF("syspart:")]);

                    } else {
                        Valid = FALSE;
                    }
                }
                break;

            case TEXT('T'):

                if(_tcsnicmp(Arg+1,TEXT("tempdrive:"),LENGTHOF("tempdrive:"))
                || !(UserSpecifiedLocalSourceDrive = (TCHAR)_totupper(Arg[1 + LENGTHOF("tempdrive:")]))
                || (UserSpecifiedLocalSourceDrive < TEXT('A'))
                || (UserSpecifiedLocalSourceDrive > TEXT('Z'))) {

                    Valid = FALSE;
                }
                break;

            case TEXT('U'):

                if (_tcsicmp (Arg+1, TEXT("UpgradeAdvisor")) == 0) {
                    UpgradeAdvisorMode = TRUE;
                    break;
                }

                //
                // Accept unattend and unattended as synonyms
                //
                b = FALSE;
                if(!_tcsnicmp(Arg+1,TEXT("unattended"),LENGTHOF("unattended"))) {
                    b = TRUE;
                    u = 1 + LENGTHOF("unattended");
                } else {
                    if(!_tcsnicmp(Arg+1,TEXT("unattend"),LENGTHOF("unattend"))) {
                        b = TRUE;
                        u = 1 + LENGTHOF("unattend");
                    }
                }

                if(b) {
                    if(!CheckUpgradeOnly && UnattendedOperation) {
                        Valid = FALSE;
                        break;
                    }

                    UnattendedOperation = TRUE;
                    UnattendSwitchSpecified = TRUE;

                    UnattendedShutdownTimeout = _tcstoul(Arg+u,&Colon,10);
                    if(UnattendedShutdownTimeout == (DWORD)(-1)) {
                        UnattendedShutdownTimeout = 0;
                    }

                    if(*Colon == 0) {
                        break;
                    }

                    if(*Colon++ != TEXT(':')) {
                        Valid = FALSE;
                        break;
                    }

                    if(*Colon) {
                        // UnattendedScriptFile = Colon;
                        //
                        // Get the name of the unattended script file
                        //
                        UnattendedScriptFile = MALLOC(MAX_PATH*sizeof(TCHAR));
                        if(UnattendedScriptFile) {
                            if(!GetFullPathName(
                                Colon,
                                MAX_PATH,
                                UnattendedScriptFile,
                                &p)) {

                                Valid = FALSE;
                            }
                        } else {
                            Valid = FALSE;
                        }

                    } else {
                        Valid = FALSE;
                    }

                } else if(!_tcsnicmp(Arg+1,TEXT("udf:"),LENGTHOF("udf:"))) {

                    if(!Arg[1 + LENGTHOF("udf:")] || (Arg[1 + LENGTHOF("udf:")] == TEXT(',')) || UniquenessId) {
                        Valid = FALSE;
                        break;
                    }

                    //
                    // Get p to point to the filename if there is one specified,
                    // and terminate the ID part.
                    //
                    if(p = _tcschr(Arg+LENGTHOF("udf:")+2,TEXT(','))) {
                        *p++ = 0;
                        if(*p == 0) {
                            Valid = FALSE;
                            break;
                        }
                    }

                    UniquenessId = Arg + LENGTHOF("udf:") + 1;
                    UniquenessDatabaseFile = p;
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('#'):

                InternalProcessCmdLineArg(Arg);
                break;

            default:

                Valid = FALSE;
                break;
            }
        } else {
            Valid = FALSE;
        }
        if(!Valid && !BadParam) {
            BadParam = Arg;
        }
    }

    if(Valid) {
        if( DebugLevel == 0 ) {
            DebugLevel = Winnt32LogInformation;
        }
        if( DebugFileLog == NULL ) {
            MyGetWindowsDirectory (buffer, ARRAYSIZE(buffer));
            if (ConcatenatePaths (buffer, S_WINNT32LOGFILE, ARRAYSIZE(buffer))) {
                DebugFileLog = DupString (buffer);
            }
        }
        if( DebugFileLog )
            StartDebugLog(DebugFileLog,DebugLevel);

        // If we do PID encryption (/Encrypt on the command line)
        // we don't read the unattend file. We will write the encrypted PID to it later.
        if (!PIDEncryption)
        {
            Valid = GetArgsFromUnattendFile();
        }
    }
    else
    {
        //
        // try to log the invalid argument pointed by BadParam
        // this may not actually work if the log wasn't initialized yet
        //
        DebugLog (
            Winnt32LogError,
            TEXT("Error: Invalid argument [%1]"),
            0,
            BadParam
            );

        if (PIDEncryption)
        {
            // Invalid encrypt command line, Time frame invalid
            if (!g_Quiet)
            {
                MessageBoxFromMessage(
                    NULL,
                    MSG_INVALID_TIME_FRAME,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );
            }
        }
        else if(BatchMode) {
            //
            // Tell SMS about bad paramters
            //
            SaveMessageForSMS( MSG_INVALID_PARAMETER, BadParam );

        } else {
            //
            // Show user the valid command line parameters
            //
            MyWinHelp(NULL,HELP_CONTEXT,IDH_USAGE);
        }
    }

    return(Valid);
}


BOOL
RememberOptionalDir(
    IN LPCTSTR Directory,
    IN UINT    Flags
    )

/*++

Routine Description:

    This routine adds a directory to the list of optional directories
    to be copied. If the directory is already present it is not added
    again.

Arguments:

    Directory - supplies name of directory to be copied.

    Flags - supplies flags for the directory. If the directory already
        existed in the list, the current flags are NOT overwritten.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can assume that
    we've overflowed the number of allowed optional dirs.

--*/

{
    UINT u;

    //
    // See if we have room.
    //
    if(OptionalDirectoryCount == MAX_OPTIONALDIRS) {
        return(FALSE);
    }

    //
    // If already there, do nothing.
    //
    for(u=0; u<OptionalDirectoryCount; u++) {
        if(!lstrcmpi(OptionalDirectories[u],Directory)) {
            return(TRUE);
        }
    }

    //
    // OK, add it.
    //
    DebugLog (Winnt32LogInformation, TEXT("Optional Directory <%1> added"), 0, Directory);
    lstrcpy(OptionalDirectories[OptionalDirectoryCount],Directory);
    OptionalDirectoryFlags[OptionalDirectoryCount] = Flags;
    OptionalDirectoryCount++;
    return(TRUE);
}


BOOL
CheckBuildNumber(
    )

/*++

Routine Description:

    This routine checks the build number of the NT system we're currently
    running.  Note that the build number is stored in a global variable
    because we'll need it again later.

Arguments:

    None.

Return Value:

    Boolean value indicating whether to allow an upgrade from this build.

--*/

{
    return( BuildNumber <= NT40 || BuildNumber >= NT50B1 );
}


BOOL
LoadSetupapi(
    VOID
    )
{
    TCHAR Name[MAX_PATH], *p;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    HMODULE Setupapi;
    BOOL WeLoadedLib = FALSE;
    BOOL    b = FALSE;
    PCTSTR Header;


    //
    // Use the setupapi.dll that was loaded by an upgrade module
    //

    Setupapi = GetModuleHandle (TEXT("SETUPAPI.DLL"));

    if (!Setupapi) {

        //
        // Upgrade module did not load SETUPAPI.DLL, so we must load it.
        // If setupapi.dll is in the system directory, use the one that's there.
        //
        if (GetSystemDirectory(Name,ARRAYSIZE(Name)) &&
            ConcatenatePaths(Name,TEXT("SETUPAPI.DLL"),ARRAYSIZE(Name))) {

            FindHandle = FindFirstFile(Name,&FindData);
            if(FindHandle == INVALID_HANDLE_VALUE) {
                //
                // Not there. Fetch the dll out of the win95 upgrade
                // support directory.
                //
                if(MyGetModuleFileName(NULL,Name,ARRAYSIZE(Name)) && (p = _tcsrchr(Name,TEXT('\\')))){
                    *p= 0;
                    if (ConcatenatePaths(Name,WINNT_WIN95UPG_95_DIR,ARRAYSIZE(Name)) &&
                        ConcatenatePaths(Name,TEXT("SETUPAPI.DLL"),ARRAYSIZE(Name))) {

                        Setupapi = LoadLibraryEx(Name,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
                    }
                }

            } else {
                //
                // Already in system directory.
                //
                FindClose(FindHandle);
                Setupapi = LoadLibrary(TEXT("SETUPAPI.DLL"));
            }

            if (Setupapi) {
                WeLoadedLib = TRUE;
            }
        }
    }

    if(Setupapi) {
#ifdef UNICODE
        b = (((FARPROC)SetupapiDecompressOrCopyFile = GetProcAddress(Setupapi,"SetupDecompressOrCopyFileW")) != NULL);
        b = b && ((FARPROC)SetupapiOpenInfFile = GetProcAddress(Setupapi,"SetupOpenInfFileW"));
        b = b && ((FARPROC)SetupapiGetLineCount = GetProcAddress(Setupapi,"SetupGetLineCountW"));
        b = b && ((FARPROC)SetupapiGetStringField = GetProcAddress(Setupapi,"SetupGetStringFieldW"));
        b = b && ((FARPROC)SetupapiGetLineByIndex = GetProcAddress(Setupapi,"SetupGetLineByIndexW"));
        b = b && ((FARPROC)SetupapiFindFirstLine = GetProcAddress(Setupapi,"SetupFindFirstLineW"));
        b = b && ((FARPROC)SetupapiFindNextMatchLine = GetProcAddress(Setupapi,"SetupFindNextMatchLineW"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiQueueCopy = GetProcAddress(Setupapi,"SetupQueueCopyW"));
        b = b && ((FARPROC)SetupapiCommitFileQueue = GetProcAddress(Setupapi,"SetupCommitFileQueueW"));
        b = b && ((FARPROC)SetupapiDefaultQueueCallback = GetProcAddress(Setupapi,"SetupDefaultQueueCallbackW"));
        //
        // needed in unsupdrv.c
        //
        b = b && ((FARPROC)SetupapiGetInfInformation = GetProcAddress(Setupapi,"SetupGetInfInformationW"));
        b = b && ((FARPROC)SetupapiQueryInfFileInformation = GetProcAddress(Setupapi,"SetupQueryInfFileInformationW"));
        (FARPROC)SetupapiGetSourceFileLocation = GetProcAddress(Setupapi,"SetupGetSourceFileLocationW");
        (FARPROC)SetupapiQueryInfOriginalFileInformation = GetProcAddress(Setupapi,"SetupQueryInfOriginalFileInformationW");


#else
        b = (((FARPROC)SetupapiDecompressOrCopyFile = GetProcAddress(Setupapi,"SetupDecompressOrCopyFileA")) != NULL);
        b = b && ((FARPROC)SetupapiOpenInfFile = GetProcAddress(Setupapi,"SetupOpenInfFileA"));
        b = b && ((FARPROC)SetupapiGetLineCount = GetProcAddress(Setupapi,"SetupGetLineCountA"));
        b = b && ((FARPROC)SetupapiGetStringField = GetProcAddress(Setupapi,"SetupGetStringFieldA"));
        b = b && ((FARPROC)SetupapiGetLineByIndex = GetProcAddress(Setupapi,"SetupGetLineByIndexA"));
        b = b && ((FARPROC)SetupapiFindFirstLine = GetProcAddress(Setupapi,"SetupFindFirstLineA"));
        b = b && ((FARPROC)SetupapiFindNextMatchLine = GetProcAddress(Setupapi,"SetupFindNextMatchLineA"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiQueueCopy = GetProcAddress(Setupapi,"SetupQueueCopyA"));
        b = b && ((FARPROC)SetupapiCommitFileQueue = GetProcAddress(Setupapi,"SetupCommitFileQueueA"));
        b = b && ((FARPROC)SetupapiDefaultQueueCallback = GetProcAddress(Setupapi,"SetupDefaultQueueCallbackA"));

#endif
        b = b && ((FARPROC)SetupapiCloseInfFile = GetProcAddress(Setupapi,"SetupCloseInfFile"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiOpenFileQueue = GetProcAddress(Setupapi,"SetupOpenFileQueue"));
        b = b && ((FARPROC)SetupapiCloseFileQueue = GetProcAddress(Setupapi,"SetupCloseFileQueue"));
        b = b && ((FARPROC)SetupapiInitDefaultQueueCallback = GetProcAddress(Setupapi,"SetupInitDefaultQueueCallback"));
        b = b && ((FARPROC)SetupapiTermDefaultQueueCallback = GetProcAddress(Setupapi,"SetupTermDefaultQueueCallback"));
        b = b && ((FARPROC)SetupapiGetFieldCount = GetProcAddress(Setupapi,"SetupGetFieldCount"));


        b = b && ((FARPROC)SetupapiFindNextLine = GetProcAddress(Setupapi,"SetupFindNextLine"));

        (FARPROC)fnSetupOpenLog  = GetProcAddress(Setupapi, "SetupOpenLog");

#ifdef UNICODE
        (FARPROC)fnSetupLogError = GetProcAddress(Setupapi, "SetupLogErrorW");
#else
        (FARPROC)fnSetupLogError = GetProcAddress(Setupapi, "SetupLogErrorA");
#endif

        (FARPROC)fnSetupCloseLog = GetProcAddress(Setupapi, "SetupCloseLog");
    }

    //
    // If the below if() fails, we must be on a platform that has
    // a setupapi.dll without the new log API.  In that case, neither
    // upgrade DLLs have loaded their own setupapi, so we don't care
    // about logging, and we eat the error.
    //

    if (fnSetupOpenLog && fnSetupLogError && fnSetupCloseLog) {
        if (!Winnt32Restarted ()) {
            //
            // Log APIs exist, so delete setupact.log and setuperr.log, write header
            //

            fnSetupOpenLog (TRUE);

            Header = GetStringResource (MSG_LOG_BEGIN);
            if (Header) {
                fnSetupLogError (Header, LogSevInformation);
                FreeStringResource (Header);
            }

            fnSetupCloseLog();
        }
    }



    if(!b) {

        if (WeLoadedLib) {
            FreeLibrary(Setupapi);
        }

        MessageBoxFromMessage(
            NULL,
            MSG_CANT_LOAD_SETUPAPI,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            TEXT("setupapi.dll")
            );
    }

    return b;
}


VOID
LoadUpgradeSupport(
    VOID
    )

/*++

Routine Description:

    This routine loads the Win95 upgrade dll or the NT upgrade dll and
    retreives its significant entry points.

Arguments:

    None.

Return Value:

--*/

{
    DWORD d;
    DWORD i;
    LPTSTR *sourceDirectories;
    HKEY hKey;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwSize;
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    TCHAR dst[MAX_PATH];
    TCHAR src[MAX_PATH];

    ZeroMemory(&UpgradeSupport,sizeof(UpgradeSupport));

    if (!ISNT()) {
        //
        // Don't load on server
        //

        // assert that the Server global variable is accurate
        MYASSERT (UpgradeProductType != UNKNOWN);

        if (Server) {
            return;
        }

        //
        // Form full Win95 path of DLL.
        //
        if (!BuildPath(buffer, WINNT_WIN95UPG_95_DIR, WINNT_WIN95UPG_95_DLL)) {
            buffer[0] = 0;
        }
    } else {
        //
        // Form full NT path of DLL.
        //
        if (!BuildPath(buffer, WINNT_WINNTUPG_DIR, WINNT_WINNTUPG_DLL)) {
            buffer[0] = 0;
        }
    }

    if (buffer[0] &&
        FindPathToWinnt32File (buffer, UpgradeSupport.DllPath, ARRAYSIZE(UpgradeSupport.DllPath))) {
        //
        // Load the library. Use LoadLibraryEx to get the system to resolve DLL
        // references starting in the dir where w95upg.dll is, instead of the
        // directory where winnt32.exe is.
        //
        // If we're upgrading from NT5, use the system's setupapi.
        //
        //
        // HACK HACK HACK - see NTBUG9: 354926
        // some OEM machines have KnownDlls registered, but actually missing
        // this leads to a failure of LoadLibrary
        // we need a workaround for this
        //
        PSTRINGLIST missingKnownDlls = NULL;
        FixMissingKnownDlls (&missingKnownDlls, TEXT("imagehlp.dll\0"));
        if (!ISNT()) {
            UpgradeSupport.DllModuleHandle = LoadLibraryEx(
                                                    UpgradeSupport.DllPath,
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH
                                                    );
        } else {
            UpgradeSupport.DllModuleHandle = LoadLibraryEx(
                                                    UpgradeSupport.DllPath,
                                                    NULL,
                                                    (BuildNumber > NT40) ? 0 : LOAD_WITH_ALTERED_SEARCH_PATH
                                                    );
        }
        if (missingKnownDlls) {
            DWORD rc = GetLastError ();
            UndoFixMissingKnownDlls (missingKnownDlls);
            SetLastError (rc);
        }
    } else {
        //
        // just for display purposes, use default path
        //
        MyGetModuleFileName (NULL, UpgradeSupport.DllPath, ARRAYSIZE(UpgradeSupport.DllPath));
        p = _tcsrchr (UpgradeSupport.DllPath, TEXT('\\'));
        if (p) {
            *p = 0;
        }
        ConcatenatePaths (UpgradeSupport.DllPath, buffer, ARRAYSIZE(buffer));
        SetLastError (ERROR_FILE_NOT_FOUND);
    }

    if(!UpgradeSupport.DllModuleHandle) {

        d = GetLastError();
        if(d == ERROR_DLL_NOT_FOUND) {
            d = ERROR_FILE_NOT_FOUND;
        }

        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_UPGRADE_DLL_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );

        goto c0;
    } else {
        DebugLog (Winnt32LogInformation, TEXT("Loaded upgrade module: <%1>"), 0, UpgradeSupport.DllPath);
    }

    //
    // Get entry points.
    //
    (FARPROC)UpgradeSupport.InitializeRoutine  = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_INIT_NAME
                                                        );

    (FARPROC)UpgradeSupport.GetPagesRoutine    = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_GETPAGES_NAME
                                                        );

    (FARPROC)UpgradeSupport.WriteParamsRoutine = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_WRITEPARAMS_NAME
                                                        );

    (FARPROC)UpgradeSupport.CleanupRoutine     = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_CLEANUP_NAME
                                                        );

#ifdef _X86_
    if (IsNEC98()){
    (FARPROC)W95SetAutoBootFlag                = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_SETAUTOBOOT_NAME
                                                        );
    }
    info.Boot16 = &g_Boot16;


    if (!ISNT()) {

        (FARPROC)UpgradeSupport.OptionalDirsRoutine = GetProcAddress (
                                                            UpgradeSupport.DllModuleHandle,
                                                            WINNT32_PLUGIN_GETOPTIONALDIRS_NAME
                                                            );
    }
#endif

    if(!UpgradeSupport.InitializeRoutine
    || !UpgradeSupport.GetPagesRoutine
    || !UpgradeSupport.WriteParamsRoutine
    || !UpgradeSupport.CleanupRoutine) {

        //
        // Entry points couldn't be found. The upgrade dll is corrupt.
        //
        MessageBoxFromMessage(
            NULL,
            MSG_UPGRADE_DLL_CORRUPT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );

        goto c1;
    }

    //
    // Fill in the info structure. This will be passed to the DLL's init routine.
    //
    info.Size                       = sizeof(info);
    info.UnattendedFlag             = &UnattendedOperation;
    info.CancelledFlag              = &Cancelled;
    info.AbortedFlag                = &Aborted;
    info.UpgradeFlag                = &Upgrade;
    info.LocalSourceModeFlag        = &MakeLocalSource;
    info.CdRomInstallFlag           = &RunFromCD;
    info.UnattendedScriptFile       = &UnattendedScriptFile;
    info.UpgradeOptions             = &UpgradeOptions;
    info.NotEnoughSpaceBlockFlag    = &BlockOnNotEnoughSpace;
    info.LocalSourceDrive           = &LocalSourceDriveOffset;
    info.LocalSourceSpaceRequired   = &LocalSourceSpaceRequired;
    info.ForceNTFSConversion        = &ForceNTFSConversion;
    info.ProductFlavor              = &ProductFlavor;
    info.SetupFlags                 = &dwSetupFlags;
    //
    // Version info fields
    //

    info.ProductType = &UpgradeProductType;
    info.BuildNumber = VER_PRODUCTBUILD;
    info.ProductVersion = VER_PRODUCTVERSION_W;

#if DBG
    info.Debug = TRUE;
#else
    info.Debug = FALSE;
#endif

#ifdef PRERELEASE
    info.PreRelease = TRUE;
#else
    info.PreRelease = FALSE;
#endif

    //
    // Source directories
    //

    sourceDirectories = (LPTSTR *) MALLOC(sizeof(LPTSTR) * MAX_SOURCE_COUNT);
    if (sourceDirectories) {
        for (i=0;i<MAX_SOURCE_COUNT;i++) {
            sourceDirectories[i] = NativeSourcePaths[i];
        }
    }

    info.SourceDirectories      = sourceDirectories;
    info.SourceDirectoryCount   = &SourceCount;

    info.UnattendSwitchSpecified = &UnattendSwitchSpecified;
    info.DUCompletedSuccessfully = &g_DynUpdtStatus->Successful;

    if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        if (!ISNT()) {

            //
            // Fill in win9xupg specific information. This is done so that the win9xupg
            // team can add more parameters to the structure without disturbing other
            // upgrade dll writers. If a paramter is needed in both cases, it should
            // be placed in the info structure above.
            //

            Win9xInfo.Size = sizeof (Win9xInfo);
            Win9xInfo.BaseInfo = &info;
            Win9xInfo.WinDirSpace = &WinDirSpaceFor9x;
            Win9xInfo.RequiredMb = &UpgRequiredMb;
            Win9xInfo.AvailableMb = &UpgAvailableMb;
            Win9xInfo.DynamicUpdateLocalDir = g_DynUpdtStatus->WorkingDir;
            Win9xInfo.DynamicUpdateDrivers = g_DynUpdtStatus->SelectedDrivers;
            Win9xInfo.UpginfsUpdated = &UpginfsUpdated;

            //
            // Save the location of the original location of w95upg.dll. Because of dll
            // replacement, this may be different than the actual w95upg.dll location
            // used.
            //
            MyGetModuleFileName (NULL, UpgradeSourcePath, ARRAYSIZE(UpgradeSourcePath));
            p = _tcsrchr (UpgradeSourcePath, TEXT('\\'));
            if (p) {
                *p = 0;
            }

            if (!ConcatenatePaths (UpgradeSourcePath, WINNT_WIN95UPG_95_DIR, ARRAYSIZE(UpgradeSourcePath))) {
                d = ERROR_INSUFFICIENT_BUFFER;
            } else {
                Win9xInfo.UpgradeSourcePath = UpgradeSourcePath;

                //
                // Copy over optional directories just as we did with source directories above.
                //
                sourceDirectories = (LPTSTR *) MALLOC(sizeof(LPTSTR) * MAX_OPTIONALDIRS);
                if (sourceDirectories) {
                    for (i=0;i<MAX_OPTIONALDIRS;i++) {
                    sourceDirectories[i] = OptionalDirectories[i];
                    }
                }

                Win9xInfo.OptionalDirectories = sourceDirectories;
                Win9xInfo.OptionalDirectoryCount = &OptionalDirectoryCount;
                Win9xInfo.UpgradeFailureReason = &UpgradeFailureReason;

                //
                // Read disk sectors routine. Win9xUpg uses this when looking for other os installations.
                //
                Win9xInfo.ReadDiskSectors = ReadDiskSectors;

                d = UpgradeSupport.InitializeRoutine((PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK) &Win9xInfo);
            }
        }
        else {
            d = UpgradeSupport.InitializeRoutine(&info);
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        //
        // Call the DLL's init routine and get-pages routine. If either fails tell the user.
        //
        d = UpgradeSupport.InitializeRoutine(&info);
#endif // UNICODE
    } // if (!IsArc())

    if(d == NO_ERROR) {
        d = UpgradeSupport.GetPagesRoutine(
                &UpgradeSupport.AfterWelcomePageCount,
                &UpgradeSupport.Pages1,
                &UpgradeSupport.AfterOptionsPageCount,
                &UpgradeSupport.Pages2,
                &UpgradeSupport.BeforeCopyPageCount,
                &UpgradeSupport.Pages3
                );
    }


    //
    // By returning ERROR_REQUEST_ABORTED, an upgrade dll can refuse to upgrade the machine.
    // In this case, no message will be generated by this routine and the option to upgrade
    // will be grayed out on the wizard page. In the case of all other error messages, winnt32
    // will warn the user that the upgrade dll failed to initialize. The upgrade.dll is expected
    // to provide whatever UI is necessary before returning from its init routine.
    //
    if (UpgradeFailureReason > REASON_LAST_REASON) {
        UpgradeFailureReason = REASON_LAST_REASON;
    }

    if(d == NO_ERROR) {
        return;
    }

    if (d != ERROR_REQUEST_ABORTED) {
        SkipVirusScannerCheck = TRUE;
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_UPGRADE_INIT_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

c1:
        FreeLibrary(UpgradeSupport.DllModuleHandle);
        ZeroMemory (&UpgradeSupport, sizeof (UpgradeSupport));
    }

c0:
    Upgrade = FALSE;
    return;
}


#ifdef _X86_

BOOL
CheckVirusScanners (
    VOID
    )

/*++

Routine Description:

    This routine is used to check for virus scanners on win9x machines that can
    impeed setup (either in a clean install or upgrade case.) The function simply
    calls an entry point within the w95upg.dll and that module performs the
    actual check.

Arguments:

    None.

Return Value:

    TRUE if no virus scanners were detected that could cause problems. FALSE if a virus
    scanner was detected that could cause setup to fail. We rely on the w95upg.dll code
    to provide an appropriate message to the user before returning to us.

--*/

{
    HANDLE dllHandle;
    PWINNT32_PLUGIN_VIRUSSCANNER_CHECK_ROUTINE virusScanRoutine;

    //
    // This check is win9xupg specific.
    //
    if (ISNT()) {
        return TRUE;
    }
    dllHandle = GetModuleHandle (WINNT_WIN95UPG_95_DLL);
    //
    // If the module was not loaded, we'll skip this check.
    //
    if (!dllHandle) {
        return TRUE;
    }
    //
    // Get entry points.
    //
    (FARPROC) virusScanRoutine  = GetProcAddress(dllHandle, WINNT32_PLUGIN_VIRUSSCANCHECK_NAME);
    if (!virusScanRoutine) {
        //
        // corrupt dll or something
        //
        return FALSE;
    }

    //
    // Now, simply call the routine. It will handle the actuall checking as well as informing the user.
    //
    return virusScanRoutine ();
}

#endif


BOOL
ValidateSourceLocation(
    VOID
    )
/*++

Routine Description:

    This routine checks the initial source location to see if it's
    valid.  The first source location must be valid for setup to
    work, and this catches typos by the user.  It cannot detect
    transient network conditions, so this is not foolproof.

    We check this by looking for a required file, dosnet.inf, at
    the source location.

Arguments:

    None.

Return Value:

    TRUE if the source location appears valid

--*/
{
    TCHAR FileName[MAX_PATH];
    WIN32_FIND_DATA fd;

    if (FAILED (StringCchCopy (FileName, ARRAYSIZE(FileName), NativeSourcePaths[0])) ||
        !ConcatenatePaths(FileName, InfName, ARRAYSIZE(FileName))) {

        return FALSE;
    }

    if (!FileExists( FileName, &fd) || (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return FALSE;
    }
    //
    // also look for system32\ntdll.dll as a second check
    //
    if (FAILED (StringCchCopy (FileName, ARRAYSIZE(FileName), NativeSourcePaths[0])) ||
        !ConcatenatePaths(FileName, TEXT("system32\\ntdll.dll"), ARRAYSIZE(FileName))) {
        return(FALSE);
    }

    return FileExists( FileName, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


VOID
pRemoveOutdatedBackupImage (
    VOID
    )
{
    REMOVEUNINSTALLIMAGE removeFn;
    HMODULE lib;
    UINT build;

    //
    // Is this current build > build we plan to install?
    //

    if (!ISNT() || !Upgrade) {
        return;
    }

    build = GetMediaProductBuildNumber();

    if (!build) {
        return;
    }

    if (build == BuildNumber) {
        return;
    }

    //
    // Attempt to remove uninstall image
    //

    lib = LoadLibraryA ("osuninst.dll");
    if (!lib) {
        return;
    }

    removeFn = (REMOVEUNINSTALLIMAGE) GetProcAddress (lib, "RemoveUninstallImage");

    if (removeFn) {
        removeFn();
    }

    FreeLibrary (lib);
}


BOOL
GetProductType (
    VOID
    )
{
    TCHAR buffer[256];

    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, ARRAYSIZE(InfName))) {
            FullInfName[0] = 0;
            return FALSE;
        }
    }
    //
    // get some data from the main inf
    //
    if (!GetPrivateProfileString (
            TEXT("Miscellaneous"),
            TEXT("ProductType"),
            TEXT(""),
            buffer,
            ARRAYSIZE(buffer),
            FullInfName
            )) {
        DebugLog (
            Winnt32LogError,
            TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
            0,
            TEXT("ProductType"),
            TEXT("Miscellaneous"),
            FullInfName
            );
        return FALSE;
    }
    // Test for valid product type (0 == pro, 6 == sbs)
    if (buffer[0] < TEXT('0') || buffer[0] > TEXT('6') || buffer[1]) {
        DebugLog (
            Winnt32LogError,
            TEXT("Invalid %1 value (%2) in %3"),
            0,
            TEXT("ProductType"),
            buffer,
            FullInfName
            );
        return FALSE;
    }

    ProductFlavor = buffer[0] - TEXT('0');
    Server = (ProductFlavor != PROFESSIONAL_PRODUCTTYPE && ProductFlavor != PERSONAL_PRODUCTTYPE);
    UpgradeProductType = Server ? NT_SERVER : NT_WORKSTATION;
    return TRUE;
}


UINT
GetMediaProductBuildNumber (
    VOID
    )
{
    TCHAR buffer[256];
    PCTSTR p;
    PTSTR q;
    UINT build;

    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, MAX_PATH)) {
            return 0;
        }
    }
    //
    // get some data from the main inf
    //
    if (!GetPrivateProfileString (
            TEXT("Version"),
            TEXT("DriverVer"),
            TEXT(""),
            buffer,
            ARRAYSIZE(buffer),
            FullInfName
            )) {
        DebugLog (
            Winnt32LogError,
            TEXT("Version key in [DriverVer] section is missing from %1; aborting operation"),
            0,
            FullInfName
            );
        return 0;
    }

    p = _tcschr (buffer, TEXT(','));
    if (p) {
        //
        // p should point to ",<major>.<minor>.<build>.0" -- extract <build>
        //

        p = _tcschr (p + 1, TEXT('.'));
        if (p) {
            p = _tcschr (p + 1, TEXT('.'));
            if (p) {
                p = _tcsinc (p);
                q = _tcschr (p, TEXT('.'));
                if (q) {
                    *q = 0;
                } else {
                    p = NULL;
                }
            }
        }
    }

    if (p) {
        build = _tcstoul (p, &q, 10);
        if (*q) {
            p = NULL;
        }
    }

    if (!p || build < NT51B2) {
        DebugLog (
            Winnt32LogError,
            TEXT("Unexpected data %1, found in Version key in [DriverVer] section of %2; aborting operation"),
            0,
            buffer,
            FullInfName
            );
        return 0;
    }

    return build;
}

typedef HANDLE (WINAPI * PWINSTATIONOPENSERVERW)(LPWSTR);
typedef BOOLEAN (WINAPI * PWINSTATIONCLOSESERVER)(HANDLE);


UINT GetLoggedOnUserCount()
{
    UINT iCount = 0;
    HMODULE hwinsta;
    PWINSTATIONOPENSERVERW pfnWinStationOpenServerW;
    PWINSTATIONENUMERATEW pfnWinStationEnumerateW;
    PWINSTATIONFREEMEMORY pfnWinStationFreeMemory;
    PWINSTATIONCLOSESERVER pfnWinStationCloseServer;

    /*
     *  Get handle to winsta.dll
     */
    hwinsta = LoadLibraryA("WINSTA");
    if (hwinsta != NULL)
    {
        pfnWinStationOpenServerW = (PWINSTATIONOPENSERVERW)GetProcAddress(hwinsta, "WinStationOpenServerW");
        pfnWinStationEnumerateW = (PWINSTATIONENUMERATEW)GetProcAddress(hwinsta, "WinStationEnumerateW");
        pfnWinStationFreeMemory = (PWINSTATIONFREEMEMORY)GetProcAddress(hwinsta, "WinStationFreeMemory");
        pfnWinStationCloseServer = (PWINSTATIONCLOSESERVER)GetProcAddress(hwinsta, "WinStationCloseServer");

        if (pfnWinStationOpenServerW    &&
            pfnWinStationEnumerateW     &&
            pfnWinStationFreeMemory     &&
            pfnWinStationCloseServer)
        {
            HANDLE hServer;

            //  Open a connection to terminal services and get the number of sessions.
            hServer = pfnWinStationOpenServerW((LPWSTR)SERVERNAME_CURRENT);
            if (hServer != NULL)
            {
                PLOGONIDW pLogonIDs;
                ULONG ulEntries;

                if (pfnWinStationEnumerateW(hServer, &pLogonIDs, &ulEntries))
                {
                    ULONG ul;
                    PLOGONIDW pLogonID;

                    /*
                     * Iterate the sessions looking for active and disconnected sessions only.
                     * Then match the user name and domain (case INsensitive) for a result.
                     */
                    for (ul = 0, pLogonID = pLogonIDs; ul < ulEntries; ul++, pLogonID++)
                    {
                        if ((pLogonID->State == State_Active)       ||
                            (pLogonID->State == State_Disconnected) ||
                            (pLogonID->State == State_Shadow))
                        {
                            iCount++;
                        }
                    }

                    /*
                     * Free any resources used.
                     */
                    pfnWinStationFreeMemory(pLogonIDs);
                }

                pfnWinStationCloseServer(hServer);
            }
        }

        FreeLibrary(hwinsta);
    }

    return iCount;
}

// From winuser.h, but since we cannot define WINVER >= 0x0500 I copied it here.
#define SM_REMOTESESSION        0x1000

BOOL DisplayExitWindowsWarnings(uExitWindowsFlags)
{
    BOOL bRet = TRUE;
    BOOL fIsRemote = GetSystemMetrics(SM_REMOTESESSION);
    UINT iNumUsers = GetLoggedOnUserCount();
    UINT uID = 0;

    switch (uExitWindowsFlags)
    {
        case EWX_POWEROFF:
        case EWX_SHUTDOWN:
        {
            if (fIsRemote)
            {
                // We are running as part of a terminal server session
                if (iNumUsers > 1)
                {
                    // Warn the user if remote shut down w/ active users
                    uID = IDS_SHUTDOWN_REMOTE_OTHERUSERS;
                }
                else
                {
                    // Warn the user if remote shut down (won't be able to restart via TS client!)
                    uID = IDS_SHUTDOWN_REMOTE;
                }
            }
            else
            {
                if (iNumUsers > 1)
                {
                    //  Warn the user if more than one user session active
                    uID = IDS_SHUTDOWN_OTHERUSERS;
                }
            }
        }
        break;

        case EWX_REBOOT:
        {
            //  Warn the user if more than one user session active.
            if (iNumUsers > 1)
            {
                uID = IDS_RESTART_OTHERUSERS;
            }
        }
        break;
    }

    if (uID != 0)
    {
        TCHAR szTitle[MAX_PATH] = TEXT("");
        TCHAR szMessage[MAX_PATH] = TEXT("");

        LoadString(hInst, IDS_APPTITLE, szTitle, sizeof(szTitle)/sizeof(szTitle[0]));
        LoadString(hInst, uID, szMessage, sizeof(szMessage)/sizeof(szMessage[0]));

        if (MessageBox(NULL,
                       szMessage,
                       szTitle,
                       MB_ICONEXCLAMATION | MB_YESNO | MB_SYSTEMMODAL | MB_SETFOREGROUND) == IDNO)
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

#define SETUP_MEMORY_MIN_REQUIREMENT ((ULONG_PTR)(50<<20)) //50MB
#define SETUP_DISK_MIN_REQUIREMENT ((ULONG_PTR)(70<<20)) //70MB

BOOL
pIsEnoughVMAndDiskSpace(
    OUT     ULARGE_INTEGER * OutRemainFreeSpace,    OPTIONAL
    IN      BOOL bCheckOnlyRAM                      OPTIONAL
    )
{
    PVOID pMemory;
    TCHAR winDir[MAX_PATH];
    TCHAR winDrive[] = TEXT("?:\\");
    ULARGE_INTEGER RemainFreeSpace = {0, 0};
    DWORD sectorPerCluster;
    DWORD bytesPerSector;
    ULARGE_INTEGER numberOfFreeClusters = {0, 0};
    ULARGE_INTEGER totalNumberOfClusters = {0, 0};
    BOOL bResult = TRUE;


    if(OutRemainFreeSpace){
        OutRemainFreeSpace->QuadPart = 0;
    }



    pMemory = VirtualAlloc(NULL, SETUP_MEMORY_MIN_REQUIREMENT, MEM_COMMIT, PAGE_NOACCESS);
    if(!pMemory){
        return FALSE;
    }

    if(!bCheckOnlyRAM){
        if (!MyGetWindowsDirectory(winDir, ARRAYSIZE(winDir))) {
            bResult = FALSE;
            goto exit;
        }

        winDrive[0] = winDir[0];
        bCheckOnlyRAM = GetDriveType(winDrive) != DRIVE_FIXED;
    }
    if(!bCheckOnlyRAM){
        if(Winnt32GetDiskFreeSpaceNew(winDrive,
                               &sectorPerCluster,
                               &bytesPerSector,
                               &numberOfFreeClusters,
                               &totalNumberOfClusters)){

            RemainFreeSpace.QuadPart = sectorPerCluster * bytesPerSector;
            RemainFreeSpace.QuadPart *= numberOfFreeClusters.QuadPart;

            if(OutRemainFreeSpace){
                OutRemainFreeSpace->QuadPart = RemainFreeSpace.QuadPart;
            }

            if(RemainFreeSpace.QuadPart < SETUP_DISK_MIN_REQUIREMENT){
                bResult = FALSE;
            }
        }
        else{
            MYASSERT(FALSE);
        }

    }

exit:
    VirtualFree(pMemory, SETUP_MEMORY_MIN_REQUIREMENT, MEM_DECOMMIT);


    return bResult;
}


LPTOP_LEVEL_EXCEPTION_FILTER pLastExceptionFilter = NULL;

LONG MyFilter(EXCEPTION_POINTERS *pep)
{
    static BOOL		fGotHere = FALSE;
    PSETUP_FAULT_HANDLER pSetupFH = NULL;
    HMODULE hmodFaultRep = NULL;
    PFAULTHCreate pfnCreate = NULL;
    PFAULTHDelete pfnDelete = NULL;
    DWORD dwRetRep = EXCEPTION_CONTINUE_SEARCH;
    DWORD dwLength;
    TCHAR faulthDllPath[MAX_PATH];
    TCHAR additionalFiles[DW_MAX_ADDFILES];
    TCHAR title[DW_MAX_ERROR_CWC];
    TCHAR errortext[DW_MAX_ERROR_CWC];
    TCHAR lcid[10];
    LCID  dwlcid;


    if( fGotHere) {
        goto c0;
    }

    fGotHere = TRUE;
    // No way to upload then quit
    if( !IsNetConnectivityAvailable()) {
        DebugLog (Winnt32LogWarning, TEXT("Warning: Faulthandler did not find netconnectivity."), 0);
        goto c0;
    }

    if( !FindPathToWinnt32File( TEXT(SETUP_FAULTH_APPNAME),faulthDllPath,ARRAYSIZE(faulthDllPath))) {
        DebugLog (Winnt32LogWarning, TEXT("Warning: Could not find faulthandler %1"), 0, TEXT(SETUP_FAULTH_APPNAME));
        goto c0;
    }

    additionalFiles[0] = TEXT('0');
    //The buffer size should be able to hold both files. Be careful when adding more!
    MYASSERT( 2*MAX_PATH < ARRAYSIZE(additionalFiles));

    if (MyGetWindowsDirectory (additionalFiles, ARRAYSIZE(additionalFiles))) {
        ConcatenatePaths (additionalFiles, S_WINNT32LOGFILE, ARRAYSIZE(additionalFiles));
    }
    dwLength = lstrlen( additionalFiles);

    // Check for case where we could not get winnt32.log
    if( dwLength > 0) {
        dwLength++;   //Reserve space for pipe
    }

    if (MyGetWindowsDirectory (additionalFiles+dwLength, ARRAYSIZE(additionalFiles)-dwLength)) {
        ConcatenatePaths (additionalFiles+dwLength, S_DEFAULT_NT_COMPAT_FILENAME, ARRAYSIZE(additionalFiles)-dwLength);
        // If we at least got the first file then add the separator.
        if( dwLength) {
            additionalFiles[dwLength-1] = TEXT('|');
        }
    }

    hmodFaultRep = LoadLibrary(faulthDllPath);

    if (hmodFaultRep == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not load faulthandler %1."), 0, TEXT(SETUP_FAULTH_APPNAME));
        goto c0;
    }

    pfnCreate = (PFAULTHCreate)GetProcAddress(hmodFaultRep, FAULTH_CREATE_NAME);
    pfnDelete = (PFAULTHDelete)GetProcAddress(hmodFaultRep, FAULTH_DELETE_NAME);
    if (pfnCreate == NULL || pfnDelete == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not get faulthandler exports."), 0);
        goto c0;
    }

    pSetupFH = (*pfnCreate)();

    if( pSetupFH == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not get faulthandler object."), 0);
        goto c0;
    }

    if( pSetupFH->IsSupported(pSetupFH) == FALSE) {
        DebugLog (Winnt32LogError, TEXT("Error: Dr Watson not supported."), 0);
        goto c0;
    }

    title[0] = TEXT('\0');
    lcid[0] = TEXT('\0');
    errortext[0] = TEXT('\0');
    LoadString(hInst, IDS_APPTITLE, title, sizeof(title)/sizeof(title[0]));
    LoadString(hInst, IDS_DRWATSON_ERRORTEXT, errortext, sizeof(errortext)/sizeof(errortext[0]));
    LoadString(hInst, IDS_DRWATSON_LCID, lcid, sizeof(lcid)/sizeof(lcid[0]));
    if( !StringToInt( lcid, &dwlcid)) {
        dwlcid = 1033;
    }

    pSetupFH->SetLCID(pSetupFH, dwlcid);
    pSetupFH->SetURLA(pSetupFH, SETUP_URL);
#ifdef UNICODE
    pSetupFH->SetAdditionalFilesW(pSetupFH, additionalFiles);
    pSetupFH->SetAppNameW(pSetupFH, title);
    pSetupFH->SetErrorTextW(pSetupFH, errortext);
#else
    pSetupFH->SetAdditionalFilesA(pSetupFH, additionalFiles);
    pSetupFH->SetAppNameA(pSetupFH, title);
    pSetupFH->SetErrorTextA(pSetupFH, errortext);
#endif
    CloseDebugLog(); //Close log file or else it cannot be uploaded.
    dwRetRep = pSetupFH->Report(pSetupFH, pep, 0);

    (*pfnDelete)(pSetupFH);

    // Pass the error to the default unhandled exception handler
    // which will terminate the process.

    dwRetRep = EXCEPTION_EXECUTE_HANDLER;

c0:
    if (hmodFaultRep != NULL) {
        FreeLibrary(hmodFaultRep);
    }
    SetUnhandledExceptionFilter( pLastExceptionFilter);
    return dwRetRep;
}

#ifdef TEST_EXCEPTION
struct {
    DWORD dwException;
    DWORD dwSetupArea;
} exceptionInfo;

void DoException( DWORD dwSetupArea)
{
    TCHAR _testBuffer[10];
    TCHAR *_ptestCh = 0;

    if( exceptionInfo.dwSetupArea == dwSetupArea) {
        switch( exceptionInfo.dwException) {
        case 1:
            *_ptestCh = TEXT('1');
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Access violation"),MB_OK);
            break;
        case 2:
            {
                DWORD i;
                for( i =0; i < 0xffffffff;i++) {
                    _testBuffer[i] = TEXT('1');

                }
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Buffer Overflow"),MB_OK);
            break;
        case 3:
            {
                LPVOID  pv;
                DWORD   i;

                for (i = 0; i < 0xffffffff; i++) {
                    pv = MALLOC(2048);
                }
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Stack Overflow"),MB_OK);
            break;
        case 4:
            {
typedef DWORD (*FAULT_FN)(void);
                FAULT_FN    pfn;
                BYTE        rgc[2048];

                FillMemory(rgc, sizeof(rgc), 0);
                pfn = (FAULT_FN)(DWORD_PTR)rgc;
                (*pfn)();
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Invalid Instruction"),MB_OK);
            break;
        case 5:
            for(;dwSetupArea;dwSetupArea--) ;
            exceptionInfo.dwSetupArea = 4/dwSetupArea;
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Divide by zero"),MB_OK);
            break;
        default:
            break;
        }
    }
}

void GetTestException( void)
{
    TCHAR exceptionType[32];
    TCHAR exceptionSetupArea[32];

    exceptionType[0] = TEXT('\0');
    exceptionSetupArea[0] = TEXT('\0');
    exceptionInfo.dwException = 0;
    exceptionInfo.dwSetupArea = 0;

    GetPrivateProfileString( TEXT("Exception"),
                             TEXT("ExceptionType"),
                             TEXT("none"),
                             exceptionType,
                             sizeof(exceptionType)/sizeof(exceptionType[0]),
                             TEXT("c:\\except.inf"));

    GetPrivateProfileString( TEXT("Exception"),
                             TEXT("ExceptionSetupArea"),
                             TEXT("none"),
                             exceptionSetupArea,
                             sizeof(exceptionSetupArea)/sizeof(exceptionSetupArea[0]),
                             TEXT("c:\\except.inf"));

    StringToInt( exceptionType, &exceptionInfo.dwException);
    StringToInt( exceptionSetupArea, &exceptionInfo.dwSetupArea);
}

#endif

HRESULT WriteEncryptedPIDtoUnattend(LPTSTR szPID)
{
    HRESULT hr = E_FAIL;
    LPTSTR szLine = NULL;
    HANDLE hFile;

    szLine = GlobalAlloc(GPTR, (lstrlen(szPID) + 3)*sizeof(TCHAR));   // + 3 for 2 " and \0
    if (szLine)
    {
        wsprintf(szLine, TEXT("\"%s\""), szPID);
        if (WritePrivateProfileString(WINNT_USERDATA, WINNT_US_PRODUCTKEY, szLine, UnattendedScriptFile) &&
            WritePrivateProfileString(WINNT_USERDATA, WINNT_US_PRODUCTID, NULL, UnattendedScriptFile))
        {
            hr = S_OK;
        }
        else
        {
            // Error message, Unable to write
            if (!g_Quiet)
            {
                MessageBoxFromMessage(
                    NULL,
                    MSG_WRITE_FAILURE_UNATTEND,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );
            }
        }
        GlobalFree(szLine);
        if (hr == S_OK)
        {
            hFile = CreateFile(UnattendedScriptFile,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                SYSTEMTIME st;
                FILETIME   ft;
                ZeroMemory(&st, sizeof(st));
                st.wDay = 1;
                st.wMonth = 4;
                st.wYear = 2002;

                SystemTimeToFileTime(&st, &ft);  // converts to file time format
                LocalFileTimeToFileTime(&ft, &ft); // Make sure we get this as UTC
                SetFileTime(hFile, &ft, &ft, &ft);	// Set it.
                CloseHandle(hFile);
            }
        }
    }
    return hr;
}

DWORD
winnt32 (
    IN      PCSTR LocalSourcePath,      OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    )

/*++

Routine Description:

  winnt32 is the main setup routine.

Arguments:

  LocalSourcePath - Specifies the local path of installation in case
                    this DLL is running from a local directory
                    after download; always ANSI if not NULL

  Dlg - Specifies the handle of the welcome dialog displayed by
        the stub; it will stay on screen untill the wizard dialog
        appears; may be NULL

  WinNT32Stub - Specifies the handle of an event that will be
                signaled before the Wizard appears on the screen;
                may be NULL

  RestartCmdLine - Receives a pointer to a command line to be executed
                   by the caller after this function returns;
                   always ANSI

Return Value:

  none

--*/

{
    HMODULE SMSHandle = NULL;
    SMSPROC InstallStatusMIF = NULL;
    HANDLE Mutex;
    BOOL b;
    TCHAR Text[MAX_PATH];
    PCTSTR Footer;
    DWORD i;
    BOOL rc = ERROR_SUCCESS;
    BOOL bScreenSaverOn = FALSE;
    PCTSTR skuPersonal;
#if !defined(UNICODE)
    ULARGE_INTEGER RemainFreeSpace;
#endif
#ifdef UNICODE
    PTSTR privName[COUNT_OF_PRIVILEGES];
    DWORD privSize[COUNT_OF_PRIVILEGES];
    DWORD langId[COUNT_OF_PRIVILEGES];
#endif


#ifdef TEST_EXCEPTION
    GetTestException();
    DoException( 1);
#endif

// Initialize these variables because the exceptionfilter calls FindPathToWinnt32File
#ifndef UNICODE
        //
        // if running on Win9x, there may be a LocalSourcePath passed as parameter
        // use that
        //
    g_LocalSourcePath = LocalSourcePath;
#endif

    AlternateSourcePath[0] = 0;
    g_DynUpdtStatus = NULL;
    SourceCount = 0;
    pLastExceptionFilter = SetUnhandledExceptionFilter(MyFilter);


#ifdef TEST_EXCEPTION
    DoException( 2);
#endif

    SetErrorMode(SEM_FAILCRITICALERRORS);


    InitCommonControls();

#if !defined(UNICODE)
    //
    // Check virtual memory requirements (only for regular Win9x winnt32 execution)
    //
    if(!IsWinPEMode()){
        RemainFreeSpace.QuadPart = 0;
        if(!pIsEnoughVMAndDiskSpace(&RemainFreeSpace, FALSE)){
            if(!RemainFreeSpace.QuadPart){
                MessageBoxFromMessage(
                    NULL,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
            }
            else{
                MessageBoxFromMessage(
                    NULL,
                    MSG_COPY_ERROR_DISKFULL,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
            }
            rc = -1;
            goto EXITNOW;
        }
    }
#endif
    if(GetModuleHandle(ShimEngine_ModuleName)){
        MessageBoxFromMessage(
            NULL,
            MSG_RUNNING_UNDER_COMPATIBILITY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        rc = -1;
        goto EXITNOW;
    }

    //
    // Init Dynamic update status
    //
    g_DynUpdtStatus = MALLOC (sizeof (*g_DynUpdtStatus));
    if (!g_DynUpdtStatus) {
        rc = -1;
        goto EXITNOW;
    }

    //
    // start with all defaults
    //
    ZeroMemory (g_DynUpdtStatus, sizeof (*g_DynUpdtStatus));
    g_DynUpdtStatus->Connection = INVALID_HANDLE_VALUE;

#if defined(REMOTE_BOOT)
    g_DynUpdtStatus->Disabled = TRUE;
#endif

    //
    // If we are running WINNT32 under WINPE we disable Dynamic Update as WINPE
    // is primarily for OEM's and Dynamic Update feature is not meant for OEM's
    //
    if (IsWinPEMode()){
        g_DynUpdtStatus->Disabled = TRUE;
    }

    // Save the screen saver state
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &bScreenSaverOn ,0);
    // Disable the screen saver
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL ,0);
    //
    // Gather os version info, before we parse arguments
    // since we use ISNT() function
    //
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersion);
    BuildNumber = OsVersion.dwBuildNumber;
    OsVersionNumber = OsVersion.dwMajorVersion*100 + OsVersion.dwMinorVersion;
    //
    // Parse/check arguments first.
    //
    if (!ParseArguments()) {
        rc = 1;
        goto c0;
    }

    // if we are running to encrypt the PID into an unattend file, don't log the command line.
    if (!PIDEncryption)
    {
        DebugLog (Winnt32LogInformation, TEXT("The command line is: <%1>"), 0, GetCommandLine ());
    }
    //
    // also log the location of the upgrade module
    //
    if (MyGetModuleFileName (hInst, Text, ARRAYSIZE(Text))) {
        DebugLog (Winnt32LogInformation, TEXT("Main module path: <%1>"), 0, Text);
    }

    if (CheckUpgradeOnly)
    {
        AppTitleStringId = IDS_APPTITLE_CHECKUPGRADE;
    }

    //
    // If we didn't get any source paths on the command line,
    // make one up here. The path will be the path where we were run from.
    //
    if(!SourceCount) {

        PTSTR p;

        if (!MyGetModuleFileName (NULL, NativeSourcePaths[0],ARRAYSIZE(NativeSourcePaths[0])) ||
            !(p = _tcsrchr (NativeSourcePaths[0], TEXT('\\')))) {

            rc = 1;
            MessageBoxFromMessage(
                NULL,
                GetLastError(),
                TRUE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );

            goto c1;
        }

        //
        // check if running from a private build
        //
        *p = 0;
        if ((p = _tcsrchr (NativeSourcePaths[0], TEXT('\\'))) != NULL &&
            lstrcmpi (p + 1, INTERNAL_WINNT32_DIR) == 0
            ) {
            *p = 0;
        }

        SourceCount = 1;
    }


    //
    // setup the SourcePaths array from the legacy source paths array
    //
    for (i = 0; i < MAX_SOURCE_COUNT; i++) {
        if (NativeSourcePaths[i]) {
            LPTSTR p;
            MYASSERT (ARRAYSIZE(SourcePaths[i]) == ARRAYSIZE(NativeSourcePaths[i]));
            lstrcpy(SourcePaths[i], NativeSourcePaths[i]);
            p = _tcsrchr (SourcePaths[i], TEXT('\\'));
            if (p) {
                *++p = TEXT('\0');
            }
        }
    }

    //
    // Validate the source location
    //
    if (!ValidateSourceLocation()) {
            rc = 1;
            MessageBoxFromMessage(
                       NULL,
                       MSG_INVALID_SOURCEPATH,
                       FALSE,
                       IDS_APPTITLE,
                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                       NULL );
            goto c0;

    }

    //
    //At this point we have the NativeSourcePaths setup and it si safe for operations involving it to be called
    //
    if (PIDEncryption)
    {
        rc = 1;
        if (UnattendedScriptFile)
        {
            BOOL bDontCare, bSelect;
            GetSourceInstallType(0);
            if (ValidatePidEx(ProductId, &bDontCare, &bSelect) && bSelect)
            {
                LPTSTR szEncryptedPID = NULL;
                HRESULT hr = PrepareEncryptedPID(ProductId, PIDDays, &szEncryptedPID);
                if (hr != S_OK)
                {
                    DebugLog (Winnt32LogInformation, TEXT("PrepareEncryptedPID failed: <hr=0x%1!lX!>"), 0, hr);
                    // Error Excryption failed
                    if (!g_Quiet)
                    {
                        MessageBoxFromMessage(
                            NULL,
                            MSG_ENCRYPT_FAILURE,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                            );
                    }
                }
                else
                {
                    if (WriteEncryptedPIDtoUnattend(szEncryptedPID) == S_OK)
                    {
                        DebugLog (Winnt32LogInformation, TEXT("Encrypted PID succeeded"), 0);
                        if (!g_Quiet)
                        {
                            MessageBoxFromMessage(
                                NULL,
                                MSG_ENCRYPT_SUCCESS,
                                FALSE,
                                AppTitleStringId,
                                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                                );
                        }
                    }
                    if (szEncryptedPID)
                    {
                        GlobalFree(szEncryptedPID);
                    }
                    rc = 0;
                }
            }
            else
            {
                if (!g_Quiet)
                {
                    MessageBoxFromMessage(
                        NULL,
                        MSG_INVALID_PID,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                        );
                }
            }
        }
        else
        {
            // No unattend switch specified
            if (!g_Quiet)
            {
                MessageBoxFromMessage(
                    NULL,
                    MSG_ENCRYPT_NOUNATTEND,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );
            }
        }
        goto c0;
    }

    if( RunningBVTs ){
        CopyExtraBVTDirs();
    }

    if (!DynamicUpdateInitialize ()) {
        DebugLog (
            Winnt32LogError,
            TEXT("DynamicUpdateInitialize failed: no dynamic update processing will be done"),
            0
            );
        g_DynUpdtStatus->Disabled = TRUE;
    }

    if (!GetProductType()) {
        MessageBoxFromMessage(
            NULL,
            MSG_INVALID_INF_FILE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
            FullInfName[0] ? FullInfName : InfName
            );
        rc = 1;
        goto c0;
    }

    if (!g_DynUpdtStatus->Disabled) {
        if (Winnt32Restarted ()) {
            DebugLog (Winnt32LogWarning, TEXT("\r\n*** Winnt32 restarted ***\r\n"), 0);
            if (g_DynUpdtStatus->RestartAnswerFile[0]) {
#ifdef PRERELEASE
                TCHAR buf[MAX_PATH];
                if (MyGetWindowsDirectory (buf, ARRAYSIZE(buf))) {
                    if (ConcatenatePaths (buf, S_RESTART_TXT, ARRAYSIZE(buf)) &&
                        CopyFile (g_DynUpdtStatus->RestartAnswerFile, buf, FALSE)) {
                        DebugLog (DynUpdtLogLevel, TEXT("Winnt32 restart file backed up to %1"), 0, buf);
                    }
                }
#endif
            } else {
                DebugLog (DynUpdtLogLevel, TEXT("No restart file is used"), 0);
            }
        }
    }

    //
    // Init support for SMS.
    //
    try {
        if( SMSHandle = LoadLibrary( TEXT("ISMIF32")) ) {
            InstallStatusMIF = (SMSPROC)GetProcAddress(SMSHandle,"InstallStatusMIF");
        }
        if(LastMessage = MALLOC(1))
            LastMessage[0] = '\0';
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    Winnt32Dlg = Dlg;
    WinNT32StubEvent = WinNT32Stub;

    // If the user specified /cmdcons (install the recovery consol) , don't show the
    // billboards.
    if (!BuildCmdcons && !CheckUpgradeOnly)
    {
        CreateMainWindow();
        PrepareBillBoard(BackgroundWnd2);
        if (hinstBB)
        {
            if (!LoadString (
                    hInst,
                    IDS_ESC_TOCANCEL,
                    Text,
                    ARRAYSIZE(Text)
                    )) {
                Text[0] = 0;
            }
            BB_SetInfoText(Text);

            UpdateWindow (BackgroundWnd2);
        }
        else
        {
            // If we could not load the billboard dll, destroy the backbround window
            // This window is currently only here to catch pressing ESC and forward
            // this to the wizard dialog proc. If the wizard is always visible, this
            // is not needed.
            DestroyWindow(BackgroundWnd2);
            BackgroundWnd2 = NULL;
        }
    }
    if (!LoadString (hInst, IDS_TIMEESTIMATE_UNKNOWN, Text, ARRAYSIZE(Text)))
    {
        Text[0] = 0;
    }
    // BB_SetTimeEstimateText does nothing if the billboard dll is not loaded.
    BB_SetTimeEstimateText((PTSTR)Text);

    //
    // Only let one of this guy run.
    // account for TS case (make the mutex global)
    //
#ifdef UNICODE
    _snwprintf (Text, ARRAYSIZE(Text), TEXT("Global\\%s"), TEXT("Winnt32 Is Running"));
    Text[ARRAYSIZE(Text) - 1] = 0;
    Mutex = CreateMutex(NULL,FALSE,Text);
    // NT4 without TS does not support the "Global\Mutex name", make sure that
    // if we could not create the Mutext that the error code is ERROR_PATH_NOT_FOUND
    // If that is the case fall back and use the name with out the Global prefix.
    if ((Mutex == NULL) && (GetLastError() == ERROR_PATH_NOT_FOUND)) {
#else
    Mutex = NULL;
    if(Mutex == NULL) {
#endif

        Mutex = CreateMutex(NULL,FALSE,TEXT("Winnt32 Is Running"));
        if(Mutex == NULL) {
            rc = 1;
            //
            // An error (like out of memory) has occurred.
            // Bail now.
            //
            MessageBoxFromMessage(
                NULL,
                MSG_OUT_OF_MEMORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );

            goto c0;
        }
    }

    //
    // Make sure we are the only process with a handle to our named mutex.
    //
    if ((Mutex == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {

        rc = 1;
        MessageBoxFromMessage(
            NULL,
            MSG_ALREADY_RUNNING,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
            );

        goto c1;
    }

    //
    // Ensure that the user has privilege/access to run this app.
    //
    if(!IsUserAdmin()) {

        rc = 1;
        MessageBoxFromMessage(
           NULL,
           MSG_NOT_ADMIN,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONSTOP | MB_TASKMODAL
           );

        goto c1;
    }

#ifdef UNICODE

    rc = 0;
    for (i = 0; i < COUNT_OF_PRIVILEGES; i++) {
        if (!DoesUserHavePrivilege(g_RequiredPrivileges[i])) {
            rc = 1;
            break;
        }
    }

    if (rc) {
       for (i = 0; i < COUNT_OF_PRIVILEGES; i++) {
            privSize[i] = 0;
            LookupPrivilegeDisplayName (NULL, g_RequiredPrivileges[i], NULL, &privSize[i], &langId[i]);
            privName[i] = MALLOC ((privSize[i] + 1) * sizeof (TCHAR));
            if (privName[i]) {
                privName[i][0] = privName[i][privSize[i]] = 0;
                LookupPrivilegeDisplayName (NULL, g_RequiredPrivileges[i], privName[i], &privSize[i], &langId[i]);
            }
        }

        MYASSERT (COUNT_OF_PRIVILEGES >= 4);
        MessageBoxFromMessage(
            NULL,
            MSG_PRIVILEGE_NOT_HELD,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONSTOP | MB_TASKMODAL,
            privName[0],
            privName[1],
            privName[2],
            privName[3]
            );

        goto c1;
    }

#endif

#if 0
    //
    // Don't run if we're a TS client.
    //
    if( (ISNT()) &&
        (BuildNumber >= NT40) ) {

        //
        // From winuser.h
        //
        #define SM_REMOTESESSION        0x1000

        if( GetSystemMetrics(SM_REMOTESESSION) == TRUE ) {

            rc = 1;
            //
            // Someone is trying to run us inside of a TerminalServer client!!
            // Bail.
            //
            MessageBoxFromMessage(
               NULL,
               MSG_TS_CLIENT_FAIL,
               FALSE,
               IDS_APPTITLE,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL
               );

            goto c1;
        }
    }
#endif


    //
    // inititialize com
    //

    CoInitialize(NULL);

#if defined(REMOTE_BOOT)
    //
    // Determine whether this is a remote boot client.
    //

    RemoteBoot = FALSE;
    *MachineDirectory = 0;
    if (ISNT()) {
        HMODULE hModuleKernel32 = LoadLibrary(TEXT("kernel32"));
        if (hModuleKernel32) {
            BOOL (*getSystemInfoEx)(
                    IN SYSTEMINFOCLASS dwSystemInfoClass,
                    OUT LPVOID lpSystemInfoBuffer,
                    IN OUT LPDWORD nSize);
            (FARPROC)getSystemInfoEx = GetProcAddress(
                                            hModuleKernel32,
#if defined(UNICODE)
                                            "GetSystemInfoExW"
#else
                                            "GetSystemInfoExA"
#endif
                                            );
            if (getSystemInfoEx != NULL) {
                BOOL flag;
                DWORD size = sizeof(BOOL);
                if (getSystemInfoEx(SystemInfoRemoteBoot, &flag, &size)) {
                    RemoteBoot = flag;
                    size = sizeof(MachineDirectory);
                    if (!getSystemInfoEx(
                            SystemInfoRemoteBootServerPath,
                            MachineDirectory,
                            &size)) {
                        DWORD error = GetLastError();
                        MYASSERT( !"GetSystemInfoExW failed!" );
                    } else {
                        PTCHAR p;
                        p = _tcsrchr(MachineDirectory, TEXT('\\'));
                        MYASSERT(p != NULL);
                        if (p) {
                            *p = 0;
                        }
                    }
                }
            }
            FreeLibrary(hModuleKernel32);
        }
    }
#endif // defined(REMOTE_BOOT)


#ifdef _X86_

    if (IsNEC98 ()) {
        //
        // don't install on NEC98 machines (#141004)
        //
        MessageBoxFromMessage(
            NULL,
            MSG_PLATFORM_NOT_SUPPORTED,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONSTOP | MB_TASKMODAL
            );
        rc = 1;
        goto c1;
    }

    //
    // Check setup sources and platform.
    // NEC98 NT5 have 98PNTN16.DLL.
    // I use this file for check platform NEC98 or x86.
    //
    {


#define WINNT_NEC98SPECIFIC_MODULE TEXT("98PTN16.DLL")

        TCHAR MyPath[MAX_PATH];
        int CheckNEC98Sources=FALSE;
        WIN32_FIND_DATA fdata;
        PTSTR p;
        HANDLE h;

        if( !MyGetModuleFileName (NULL, MyPath, ARRAYSIZE(MyPath)) || !(p=_tcsrchr (MyPath, TEXT('\\')))) {
            rc = 1;
            goto c1;
        }
        p = 0;
        if (ConcatenatePaths (MyPath, WINNT_NEC98SPECIFIC_MODULE, ARRAYSIZE(MyPath)) &&
            (h = FindFirstFile(MyPath, &fdata)) != INVALID_HANDLE_VALUE) {

            CloseHandle (h);
            CheckNEC98Sources=TRUE;
        }

        if(CheckNEC98Sources){
            if (!IsNEC98()){
                rc = 1;
                MessageBoxFromMessage(
                    NULL,
                    MSG_INCORRECT_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );

                goto c1;
            }
        } else {
            if (IsNEC98()){
                rc = 1;
                MessageBoxFromMessage(
                    NULL,
                    MSG_INCORRECT_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );
                goto c1;
            }
        }
    }

    //
    // Some NEC98 Windows NT4 system is installed DMITOOL
    // This AP block the CreateFile API
    // Setup need to check this AP
    //
    if (IsNEC98() && ISNT()){
        if (NEC98CheckDMI() == TRUE){
            rc = 1;
            MessageBoxFromMessage(
                NULL,
            MSG_NEC98_NEED_UNINSTALL_DMITOOL,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );
            goto c1;
        }
    }

    LocateFirstFloppyDrive();

    //
    // Fix up boot messages.
    // NEC98 FAT16/FAT32 boot code does't have message area.
    //
    if (!IsNEC98())
    {
        if(!PatchTextIntoBootCode()) {
            rc = 1;
            MessageBoxFromMessage(
                NULL,
                MSG_BOOT_TEXT_TOO_LONG,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
            goto c1;
        }
    }
    //
    // Disallow installing/upgrading on a 386 or 486
    // 3.51 and Win9x ran on 386's so this check is still necessary.
    //
    {
        SYSTEM_INFO SysInfo;
        PCTSTR DestinationPlatform;

        GetSystemInfo(&SysInfo);
        if (SysInfo.dwProcessorType == PROCESSOR_INTEL_386 ||
            SysInfo.dwProcessorType == PROCESSOR_INTEL_486) {
            rc = 1;
            MessageBoxFromMessage(
                NULL,
                MSG_REQUIRES_586,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );

            goto c1;
        }

#ifdef UNICODE
        
#ifdef _X86_
        //
        // 32-bit to 64-bit AMD should only be clean install.
        //
        
        DestinationPlatform = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"),0);

        if (lstrcmpi (DestinationPlatform, TEXT("amd64")) == 0)
        {
            Upgrade = FALSE;
        }
        else
#endif
        
        //
        // Disallow amd64 and IA64 machines from running an x86
        // version of winnt32.exe.
        //
        {
            ULONG_PTR p;
            NTSTATUS status;

            status = NtQueryInformationProcess (
                        NtCurrentProcess (),
                        ProcessWow64Information,
                        &p,
                        sizeof (p),
                        NULL
                        );
            if (NT_SUCCESS (status) && p) {

                HMODULE hModuleKernel32 = LoadLibrary(TEXT("kernel32"));

                //
                // 64-bit to 32-bit clean install is allowed on AMD64
                //

                RtlZeroMemory (&SysInfo, sizeof (SysInfo));

                if (hModuleKernel32 != NULL) {

                    typedef VOID (WINAPI *PFNGetNativeSystemInfo)(PSYSTEM_INFO);
                    PFNGetNativeSystemInfo pfnGetNativeSystemInfo;

                    pfnGetNativeSystemInfo = (PFNGetNativeSystemInfo)GetProcAddress (hModuleKernel32, "GetNativeSystemInfo");
                    if (pfnGetNativeSystemInfo != NULL) {
                        pfnGetNativeSystemInfo (&SysInfo);
                    }

                    FreeLibrary(hModuleKernel32);
                }

                if (SysInfo.dwProcessorType == PROCESSOR_AMD_X8664) {
                    Upgrade = FALSE;
                } else {

                    rc = 1;
                    //
                    // 32-bit code running on Win64
                    //

                    MessageBoxFromMessage(
                        NULL,
                        MSG_NO_CROSS_PLATFORM,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                        );

                    goto c1;
                }
            }
        }
#endif
    }

#endif // _X86_

    if (!g_DynUpdtStatus->Disabled) {
        if (g_DynUpdtStatus->PrepareWinnt32) {
            if (!g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                //
                // no share to update was specified
                //
                MessageBoxFromMessage(
                   NULL,
                   MSG_NO_UPDATE_SHARE,
                   FALSE,
                   AppTitleStringId,
                   MB_OK | MB_ICONSTOP | MB_TASKMODAL
                   );
                rc = 1;
                goto c1;
            }
        } else {
            //
            // spec change: even if /unattend is specified, still do DU
            //
#if 0
            if (UnattendedOperation && !g_DynUpdtStatus->UserSpecifiedUpdates) {
                //
                // if unattended, disable Dynamic Setup page by default
                //
                g_DynUpdtStatus->Disabled = TRUE;
            }
#endif
        }
    }

    //
    // Load extension/downlevel DLLs.
    //

    // Don't load upgrade support if we're running in WinPE.
    //
    if (!IsWinPEMode()) {
        LoadUpgradeSupport();
    }
    else {
         ZeroMemory(&UpgradeSupport, sizeof(UpgradeSupport));
         Upgrade = FALSE;
    }

    //
    // Load setupapi. Do this *AFTER* we load upgrade support,
    // because one of the upgrade support dlls might link to or load
    // setupapi.dll. That dll might be picky but we can use any old
    // setupapi.dll for what we need.
    //
    if (!LoadSetupapi()) {
        rc = 1;
        goto c1;
    }


#ifdef _X86_

    //
    // If this is a win9x machine, check to ensure that there are no
    // virus scanners that could block a successful upgrade _or_
    // clean install.
    //
    if (!ISNT() && !SkipVirusScannerCheck && !CheckVirusScanners()) {

        rc = 1;
        goto c1;
    }

#endif

    if(!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
        if(!InitializeArcStuff(NULL)) {
            rc = 1;
            goto c1;
        }
#endif // defined(_AMD64_) || defined(_X86_)
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        if(!ArcInitializeArcStuff(NULL)) {
            rc = 1;
            goto c1;
        }
#endif // UNICODE
    } // if (!IsArc())

    //
    // Don't allow upgrades from early NT 5 builds.
    //
    if( !CheckBuildNumber() ) {

        MessageBoxFromMessage(
           NULL,
           MSG_CANT_UPGRADE_FROM_BUILD_NUMBER,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONSTOP | MB_TASKMODAL
           );

        Upgrade = FALSE;
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot client, it MUST upgrade. It cannot install a new
    // version of the OS. If upgrade has been disabled for some reason, stop now.
    //

    if (RemoteBoot && !Upgrade) {
        rc = 1;
        MessageBoxFromMessage(
            NULL,
            MSG_REQUIRES_UPGRADE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
            );
        goto c1;
    }
#endif // defined(REMOTE_BOOT)

    //if(UnattendedOperation && UnattendedScriptFile && !FetchArguments()) {
    //    rc = 1;
    //    goto c1;
    //}

    //
    // Set up various other option defaults.
    //
    InitVariousOptions();


    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // Make sure the Source files and target operating system
        // are of the same locale.  If they aren't, we'll disable
        // ability to upgrade.
        //
        // Init the locale engine.
        //
        //
        if( InitLanguageDetection( NativeSourcePaths[0], TEXT("intl.inf") ) ) {

            if( !SkipLocaleCheck && (Upgrade || UpgradeFailureReason) && !IsLanguageMatched) {

                //
                // Tell the user we can't upgrade then kill his ability to do so.
                //
                MessageBoxFromMessage( NULL,
                                       MSG_UPGRADE_LANG_ERROR,
                                       FALSE,
                                       IDS_APPTITLE,
                                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                       NULL );

                Upgrade = FALSE;
            }
        }

        //
        // Now that we have done the language check, go ahead and see if we have a message
        // to give to the user about why they cannot upgrade.
        //
        if (IsLanguageMatched && UpgradeFailureReason && UpgradeFailureMessages[UpgradeFailureReason]) {

                //
                // Tell the user we can't upgrade then kill his ability to do so.
                //
                MessageBoxFromMessage( NULL,
                                       UpgradeFailureMessages[UpgradeFailureReason],
                                       FALSE,
                                       IDS_APPTITLE,
                                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                       NULL );

                Upgrade = FALSE;
        }


        //
        // Check to see if we're on a cluster.  If so, and the user
        // didn't specify a tempdrive, then it's possible for us to
        // select a shared disk, which may not be available for us
        // when we come back up into textmode.  Warn the user.
        //
        // Note that we need to wait until now because RunFromCD
        // doesn't get set until InitVariousOptions().
        //
        if( ISNT() &&
            (RunFromCD == FALSE) &&
            (!UserSpecifiedLocalSourceDrive) ) {
        int         i;
        HMODULE     ClusApiHandle;
        FARPROC     MyProc;
        HANDLE      hCluster;
        BOOL        OnCluster = FALSE;

            try {
                if( ClusApiHandle = LoadLibrary( TEXT("clusapi") ) ) {

                    if( MyProc = GetProcAddress(ClusApiHandle,"OpenCluster")) {

                        hCluster = (HANDLE)MyProc(NULL);

                        if( hCluster != NULL ) {
                            //
                            // Fire.
                            //
                            OnCluster = TRUE;

                            if( MyProc = GetProcAddress( ClusApiHandle, "CloseCluster")) {
                                MyProc( hCluster );
                            }
                        }
                    }

                    FreeLibrary( ClusApiHandle );
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }

            if( OnCluster ) {
                i = MessageBoxFromMessage( NULL,
                                           MSG_CLUSTER_WARNING,
                                           FALSE,
                                           IDS_APPTITLE,
                                           MB_OKCANCEL | MB_ICONEXCLAMATION,
                                           NULL );
                if(i == IDCANCEL) {
                    rc = 1;
                    goto c1;
                }
            }
        }
    }

    //
    // setup source install type(retail,oem,or select)
    //
    GetSourceInstallType(0);

    if (FAILED (StringCchCopy (InstallDir, ARRAYSIZE(InstallDir), DEFAULT_INSTALL_DIR ))) {
        MYASSERT (FALSE);
    }

    //
    // Create a mutex to serialize error ui.
    //
    UiMutex = CreateMutex(NULL,FALSE,NULL);
    if(!UiMutex) {
        rc = 1;
        MessageBoxFromMessage(
            NULL,
            GetLastError(),
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        goto c1;
    }

    //
    // Attempt to disable the PM engine from powering down
    // the machine while the wizard is going.  The API we're
    // going to call doesn't exist on all versions of Windows,
    // so manually try and load the entry point.  If we fail,
    // so be it.
    //
    {
        typedef     EXECUTION_STATE (WINAPI *PTHREADPROC) (IN EXECUTION_STATE esFlags);
        HMODULE     Kernel32Handle;
        PTHREADPROC MyProc;

        if( Kernel32Handle = LoadLibrary( TEXT("kernel32") ) ) {

            if( MyProc = (PTHREADPROC)GetProcAddress(Kernel32Handle,"SetThreadExecutionState")) {

                MyProc( ES_SYSTEM_REQUIRED |
                        ES_DISPLAY_REQUIRED |
                        ES_CONTINUOUS );
            }

            FreeLibrary( Kernel32Handle );
        }
    }

    //
    // Go off and do it.
    //

    if (Winnt32Dlg) {
        DestroyWindow (Winnt32Dlg);
        Winnt32Dlg = NULL;
    }
    if (WinNT32StubEvent) {
        SetEvent (WinNT32StubEvent);
        WinNT32StubEvent = NULL;
    }

    if( BuildCmdcons ) {
        // if we were told to build a cmdcons boot we do this instead
        if (!IsArc()) {
#if defined(_AMD64_) || defined(_X86_)
            if (ISNT()) {
                CalcThroughput();
                DoBuildCmdcons();
            } else {
                //
                // We don't support building a cmdcons from Win9x.
                //
                MessageBoxFromMessage( NULL,
                                   MSG_CMDCONS_WIN9X,
                                   FALSE,
                                   IDS_APPTITLE,
                                   MB_OK | MB_ICONEXCLAMATION,
                                   NULL );

                GlobalResult = FALSE;
            }
#endif
        } else {
#ifdef UNICODE
            //
            // We don't support building a cmdcons on Alpha platforms.
            //
            MessageBoxFromMessage( NULL,
                                   MSG_CMDCONS_RISC,
                                   FALSE,
                                   IDS_APPTITLE,
                                   MB_OK | MB_ICONEXCLAMATION,
                                   NULL );
            GlobalResult = FALSE;
#endif
        }

    } else if (g_DynUpdtStatus->PrepareWinnt32) {

        if (!DynamicUpdateProcessFiles (&b)) {
            MessageBoxFromMessage (
                NULL,
                MSG_PREPARE_SHARE_FAILED,
                FALSE,
                IDS_APPTITLE,
                MB_OK | MB_ICONEXCLAMATION,
                NULL
                );
            rc = 1;
        }
        //
        // clean up stuff
        //
        if (g_DynUpdtStatus->WorkingDir[0]) {
            MyDelnode (g_DynUpdtStatus->WorkingDir);
        }

    } else {
        if (g_DynUpdtStatus->Disabled) {
            DebugLog (Winnt32LogInformation, NULL, LOG_DYNUPDT_DISABLED);
        }
        CalcThroughput();
        Wizard();
    }

    //
    // Back from the wizard. Either clean up or shut down, as appropriate.
    //
    if(GlobalResult) {

#ifdef _X86_
        MYASSERT (SystemPartitionDriveLetter);
        MarkPartitionActive(SystemPartitionDriveLetter);

        if(IsNEC98()){
            // If System is NT and NEC98 Driver assign.
            // We need delete registry key "DriveLetter=C" in setupreg.hive
            if (ISNT() && (IsDriveAssignNEC98() == TRUE)){
                DeleteNEC98DriveAssignFlag();
            }

            //
            // If floppyless setup, set AUTO-BOOT flag in boot sector on NEC98
            //
            if((Floppyless || UnattendedOperation)) {
                SetAutomaticBootselector();
            }
        }
#endif

        //
        // Uninstall: blow away existing backup of OS, if we are upgrading to
        // a newer build.
        //

        pRemoveOutdatedBackupImage();

        //
        // SMS: report success
        //
        if(InstallStatusMIF) {

            PSTR    Buffer;

            FormatMessageA(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hInst,
                MSG_SMS_SUCCEED,
                0,
                (PSTR)&Buffer,
                0,
                NULL
                );

            InstallStatusMIF(
                "setupinf",
                "Microsoft",
                "Windows NT",
                "5.0",
                "",
                "",
                Buffer,
                TRUE
                );

            LocalFree( Buffer );
        }

        //
        // Close the log if it was open
        //

        if (fnSetupCloseLog) {
            Footer = GetStringResource (MSG_LOG_END);
            if (Footer) {
                fnSetupOpenLog (FALSE);
                fnSetupLogError (Footer, LogSevInformation);
                FreeStringResource (Footer);
                fnSetupCloseLog();
            }

        }

        //
        // Success. Attempt to shut down the system. On NT we have
        // a cool API that does this with a countdown. On Win95 we don't.
        // On NT5 and beyond, we have an even cooler API that takes
        // a reason for shutting down.  Don't statically link to it
        // or else this will fall over when run from an NT4 machine.
        //
        if(AutomaticallyShutDown) {

#ifdef RUN_SYSPARSE
            DWORD ret;
            // Wait up to 90 seconds for sysparse to finish
            if (!NoSysparse && piSysparse.hProcess) {
                ret = WaitForSingleObject( piSysparse.hProcess, 0);
                if( ret != WAIT_OBJECT_0) {
                    DialogBox(
                        hInst,
                        MAKEINTRESOURCE(IDD_SYSPARSE),
                        GetBBhwnd(),
                        SysParseDlgProc
                        );
                }
                CloseHandle(piSysparse.hProcess);
                CloseHandle(piSysparse.hThread);
                piSysparse.hProcess = NULL;
            }
#endif

            //
            // On upgrades we disable System Restore. This saves us space in GUI mode by cleaning out its cache.
            // We do this only at the point where we reboot. In the /noreboot case we decide to ignore this
            // Not many people would run into that as it is a commandline option. The routine chaecks for presence of
            // srclient.dll and only does this on the platforms it is present in.
            //

            DisableSystemRestore();

            // reset the screen saver to what we found when we entered winnt32
            // This is in the reboot case
            SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bScreenSaverOn, NULL,0);

            if(ISNT()) {

                HINSTANCE hAdvapi = GetModuleHandle(TEXT("advapi32.dll"));
                PFNINITIATESYSTEMSHUTDOWNEX pfnShutdownEx = NULL;
                LPCSTR lpProcName;

                if (UnattendedOperation || DisplayExitWindowsWarnings(EWX_REBOOT))
                {
#ifdef UNICODE
                    lpProcName = "InitiateSystemShutdownExW";
#else
                    lpProcName = "InitiateSystemShutdownExA";
#endif

                    LoadString(hInst,IDS_REBOOT_MESSAGE,Text,ARRAYSIZE(Text));

                    if (hAdvapi) {
                        pfnShutdownEx = (PFNINITIATESYSTEMSHUTDOWNEX)
                            GetProcAddress(hAdvapi,
                            lpProcName);
                    }


                    //
                    // We checked up front whether we have the privilege,
                    // so getting it should be no problem. If we can't,
                    // then just let shutdown fail -- it will tell us why it failed.
                    //
                    EnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

                    if (pfnShutdownEx) {
                        b = pfnShutdownEx(NULL,
                            Text,
                            UnattendedShutdownTimeout,
                            UnattendedShutdownTimeout != 0,
                            TRUE,
                                SHTDN_REASON_FLAG_PLANNED |
                                SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                                (Upgrade ? SHTDN_REASON_MINOR_UPGRADE : SHTDN_REASON_MINOR_INSTALLATION)
                            );
                        //
                        // on 5.1, force a shutdown even if the machine was locked
                        // to maintain W2K compatibility
                        // only do this if an unattended install was in progress
                        //
                        if (!b && (GetLastError () == ERROR_MACHINE_LOCKED) && UnattendSwitchSpecified) {
                            b = pfnShutdownEx (
                                    NULL,
                                    Text,
                                    0,
                                    TRUE,
                                    TRUE,
                                        SHTDN_REASON_FLAG_PLANNED |
                                        SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                                        (Upgrade ? SHTDN_REASON_MINOR_UPGRADE : SHTDN_REASON_MINOR_INSTALLATION)
                                    );
                        }
                    }
                    else {
                        b = InitiateSystemShutdown(NULL,
                            Text,
                            UnattendedShutdownTimeout,
                            UnattendedShutdownTimeout != 0,
                            TRUE);
                    }
                }
            } else {
                b = ExitWindowsEx(EWX_REBOOT,0);
                if(!b) {
                    b = ExitWindowsEx(EWX_REBOOT | EWX_FORCE,0);
                }
            }

            if(!b) {

                rc = 1;
                MessageBoxFromMessageAndSystemError(
                    NULL,
                    MSG_REBOOT_FAILED,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING | MB_TASKMODAL
                    );

                goto c2;
            }
        }
    } else {
        if (CheckUpgradeOnly) {
            //
            // perform some DU cleanup here since the cleanup routine
            // doesn't get called in /checkupgradeonly mode
            //
            if (g_DynUpdtStatus->ForceRemoveWorkingDir || !g_DynUpdtStatus->PreserveWorkingDir) {
                if (g_DynUpdtStatus->WorkingDir[0] && !g_DynUpdtStatus->RestartWinnt32) {
                    MyDelnode (g_DynUpdtStatus->WorkingDir);
                }

                GetCurrentWinnt32RegKey (Text, ARRAYSIZE(Text));
                if (ConcatenatePaths (Text, WINNT_U_DYNAMICUPDATESHARE, ARRAYSIZE(Text))) {
                    RegDeleteKey (HKEY_LOCAL_MACHINE, Text);
                }
            }

        } else {

            if (!g_DynUpdtStatus->RestartWinnt32 && !g_DynUpdtStatus->PrepareWinnt32) {
                rc = 1;
            }
        }
    }

c2:
    CloseHandle(UiMutex);
c1:
    //
    // Destroy the mutex.
    //
    CloseHandle(Mutex);
c0:

    // reset the screen saver to what we found when we entered winnt32
    // This is if we don't reboot. e.g.: user canceled
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bScreenSaverOn, NULL,0);
    //
    // destroy the welcome dialog if still active
    //
    if (Dlg) {
        DestroyWindow (Dlg);
        Dlg = NULL;
    }
    //
    // and release the original process if launched over a network
    //
    if (WinNT32Stub) {
        SetEvent (WinNT32Stub);
        WinNT32Stub = NULL;
    }

    if (g_EncryptedPID)
    {
        GlobalFree(g_EncryptedPID);
        g_EncryptedPID = NULL;
    }

    //
    // SMS: report failure
    //
    if(!GlobalResult && !g_DynUpdtStatus->RestartWinnt32 && InstallStatusMIF) {

        PSTR    Buffer = NULL;

        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_SMS_FAIL,
            0,
            (PSTR)&Buffer,
            0,
            (va_list *)&LastMessage
            );

        InstallStatusMIF(
            "setupinf",
            "Microsoft",
            "Windows NT",
            "5.1",
            "",
            "",
            Buffer,
            FALSE
            );

        LocalFree (Buffer);
    }

    if(SMSHandle) {
        FreeLibrary( SMSHandle );
    }

    //
    // Now clean up our debug log if we're only checking
    // the upgrade scenario.
    //
    if( CheckUpgradeOnly ) {
        GatherOtherLogFiles();
    }

    //
    // Close the debug log.
    //
    CloseDebugLog();
    TerminateBillBoard();

    if (BackgroundWnd2)
    {
        DestroyWindow (BackgroundWnd2);
        BackgroundWnd2 = NULL;
    }
    if (hinstBB)
    {
        FreeLibrary(hinstBB);
        hinstBB = NULL;
    }

    if (RestartCmdLine) {
#ifdef UNICODE
        if (g_DynUpdtStatus->RestartCmdLine) {
            INT i = 0;
            INT size = (lstrlenW (g_DynUpdtStatus->RestartCmdLine) + 1) * sizeof (g_DynUpdtStatus->RestartCmdLine[0]);
            PSTR ansi = HeapAlloc (GetProcessHeap (), 0, size);
            if (ansi) {
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        g_DynUpdtStatus->RestartCmdLine,
                        size / sizeof (g_DynUpdtStatus->RestartCmdLine[0]),
                        ansi,
                        size,
                        NULL,
                        NULL
                        );
            }
            HeapFree (GetProcessHeap (), 0, g_DynUpdtStatus->RestartCmdLine);

            if (i == 0 && ansi) {
                HeapFree (GetProcessHeap (), 0, ansi);
                ansi = NULL;
            }
            *RestartCmdLine = ansi;
        } else {
            *RestartCmdLine = NULL;
        }
#else
        *RestartCmdLine = g_DynUpdtStatus->RestartCmdLine;
#endif
        g_DynUpdtStatus->RestartCmdLine = NULL;
    } else {
        if (g_DynUpdtStatus->RestartCmdLine) {
            HeapFree (GetProcessHeap (), 0, g_DynUpdtStatus->RestartCmdLine);
        }
    }

    //
    // unload the upgrade dll, if it was loaded
    //
    if (UpgradeSupport.DllModuleHandle) {
        FreeLibrary(UpgradeSupport.DllModuleHandle);
    }

    if (g_DynUpdtStatus) {
        FREE (g_DynUpdtStatus);
        g_DynUpdtStatus = NULL;
    }

EXITNOW:
    SetUnhandledExceptionFilter( pLastExceptionFilter);
    return rc;
}


BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;
    BOOLEAN b = FALSE;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }

    if(LookupPrivilegeValue( NULL,
                           Privilege, // (LPWSTR)SE_SECURITY_NAME,
                           &( LuidAndAttributes.Luid ) ) ) {

        LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
        TokenPrivileges.PrivilegeCount = 1;
        TokenPrivileges.Privileges[0] = LuidAndAttributes;

        if( AdjustTokenPrivileges( TokenHandle,
                                    FALSE,
                                    &TokenPrivileges,
                                    0,
                                    NULL,
                                    NULL ) &&
            GetLastError() == NO_ERROR ) {

            b = TRUE;
        }
    }

    CloseHandle (TokenHandle);

    return b;
}

#if defined(_AMD64_) || defined(_X86_)

BOOL
IsNEC98(
    VOID
    )
{

#if defined(_X86_)
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);

#else

    return FALSE;

#endif

}

#endif

#ifdef _X86_
//
// winnt32.exe Floppyless setup for PC-9800
// setting automatic bootselector main function
//
VOID
SetAutomaticBootselector(
    VOID
    )
{
//
// This function check System.
// If System is NT, call SetAutomaticBootselectorNT(),
// If System is 95, call SetAutomaticBootselector95(),
//

    if (ISNT()){
        SetAutomaticBootselectorNT();
    } else {
        // Now I run on Win95 or Memphis.
        SetAutomaticBootselector95();
    }
}

VOID
SetAutomaticBootselectorNT(
    VOID
    )
{
    // must use WIN32 function.
    ULONG i;
    ULONG bps = 512;
    PUCHAR pBuffer,pUBuffer;
    WCHAR DevicePath[128];
    HANDLE hDisk;
    NTSTATUS Sts;
    DISK_GEOMETRY MediaInfo;
    DWORD DataSize;
            struct _NEC98_partition_table {
                BYTE BootableFlag;
                BYTE SystemType;
                BYTE Reserve[2];
                BYTE IPLStartSector;
                BYTE IPLStartHead;
                WORD IPLStartCylinder;
                BYTE StartSector;
                BYTE StartHead;
                WORD StartCylinder;
                BYTE EndSector;
                BYTE EndHead;
                WORD EndCylinder;
                CHAR SystemName[16];
            } *PartitionTable;
            LONG StartSector;
    LONG HiddenSector;
    BOOL b;

    //
    // Determine the number of hard disks attached to the system
    // and allocate space for an array of Disk Descriptors.
    // BUGBUG - the number of a maximum of 40 drives below
    // seems to be arbitrary
    //
    for(i=0; i<40; i++){
        swprintf(DevicePath,L"\\\\.\\PHYSICALDRIVE%u",i);
        hDisk =   CreateFileW( DevicePath,
                              0,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            continue;
        }
        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        CloseHandle(hDisk);
        //
        // It's really a hard disk.
        //
        if(b == 0){
            continue;
        }
        if(MediaInfo.MediaType == RemovableMedia) {
            continue;
        }

        hDisk =   CreateFileW( DevicePath,
                              GENERIC_READ|GENERIC_WRITE,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            continue;
        }

        if (CheckATACardonNT4(hDisk)){
            CloseHandle(hDisk);
            continue;
        }

        bps = GetHDBps(hDisk);
        if (!bps || bps < 8){
            CloseHandle(hDisk);
            continue;
        }
        pUBuffer = MALLOC(bps * 3);
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps * 2);
        Sts = SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_READSEC);
        if(!NT_SUCCESS(Sts)) {
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }

        //
        // If PC-AT HD, No action.
        //

        if (!(pBuffer[4] == 'I'
           && pBuffer[5] == 'P'
           && pBuffer[6] == 'L'
           && pBuffer[7] == '1')){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }
        if ((pBuffer[bps - 5] == 0) && pBuffer[bps - 6] == 0){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }

        //
        //  Clear BootRecord
        //
        pBuffer[bps - 5] = 0x00;
        pBuffer[bps - 6] = 0x00;

        SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_WRITESEC);
        FREE(pUBuffer);
        CloseHandle(hDisk);
    }
    MYASSERT (SystemPartitionDriveLetter);
    HiddenSector = CalcHiddenSector((TCHAR)SystemPartitionDriveLetter, (SHORT)bps);
    if(GetSystemPosition(&hDisk, &MediaInfo ) != 0xff) {
        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        pUBuffer = MALLOC(bps * 3);
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps * 2);
        bps = MediaInfo.BytesPerSector;
        Sts = SpReadWriteDiskSectors(hDisk,0,2,bps,pBuffer, NEC_READSEC);
        PartitionTable = (struct _NEC98_partition_table *)(pBuffer + 512);

        if(NT_SUCCESS(Sts)) {

            //
            // Update BootRecord
            //

            for (i = 0; i <16; i++, PartitionTable++){
                if (((PartitionTable->SystemType) & 0x7f) == 0)
                    break;
                StartSector =
                    (((PartitionTable->StartCylinder * MediaInfo.TracksPerCylinder)
                    + PartitionTable->StartHead) * MediaInfo.SectorsPerTrack)
                    + PartitionTable->StartSector;
                if (StartSector == HiddenSector){
                    pBuffer[bps - 5] = (UCHAR)i;
                    pBuffer[bps - 6] = 0x80;
                    PartitionTable->BootableFlag |= 0x80;
                    Sts = SpReadWriteDiskSectors(hDisk,0,2,bps,pBuffer, NEC_WRITESEC);
                }
            }
        }
        FREE(pUBuffer);
        CloseHandle(hDisk);
    }
}
// I970721
VOID
SetAutomaticBootselector95(
    VOID
    )
{

    int bBootDrvLtr;


    if(!W95SetAutoBootFlag) {

        //
        // Entry points couldn't be found. The upgrade dll is corrupt.
        //
        MessageBoxFromMessage(
            NULL,
            MSG_UPGRADE_DLL_CORRUPT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );
    } else {
        MYASSERT (SystemPartitionDriveLetter);
        bBootDrvLtr = (int)SystemPartitionDriveLetter;
        if (Upgrade)
            W95SetAutoBootFlag(bBootDrvLtr);
        else {
            W95SetABFwFresh(bBootDrvLtr);
        }
    }

}

#endif

#if defined(_AMD64_) || defined(_X86_)

//
// disksectors read and write function
// I970721
//
NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOL    ReadWriteSec
    )

/*++

Routine Description:

    Reads or writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    DWORD IoSize, IoSize2;
    OVERLAPPED Offset;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    Offset.Offset = SectorNumber * BytesPerSector;
    Offset.OffsetHigh = 0;
    Offset.hEvent = NULL;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //
    if ( ReadWriteSec == NEC_READSEC){
        (NTSTATUS)Status = ReadFile(
                               Handle,
                               AlignedBuffer,
                               IoSize,
                               &IoSize2,
                               &Offset
                           );
        } else {
        (NTSTATUS)Status = WriteFile(
                               Handle,
                               AlignedBuffer,
                               IoSize,
                               &IoSize2,
                               &Offset
                           );
        }

    return(Status);
}

//
// Get WindowsNT System Position
// I970721
//
UCHAR
GetSystemPosition(
    PHANDLE phDisk,
    PDISK_GEOMETRY pSystemMediaInfo
    )
{

    HANDLE Handle;
    DWORD DataSize;
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    WCHAR Buffer[128];
    WCHAR DevicePath[128];
    WCHAR DriveName[3];
    WCHAR DiskNo;
    UCHAR Position = 0xff, i, errorpt=0;
    PWCHAR p, stop;
    STORAGE_DEVICE_NUMBER   number;
    DWORD ExtentSize, err_no;
    BOOL b;
    PVOLUME_DISK_EXTENTS Extent;


    MYASSERT (SystemPartitionDriveLetter);
    HardDiskName[4] = SystemPartitionDriveLetter;
    DriveName[0] = SystemPartitionDriveLetter;
    DriveName[1] = ':';
    DriveName[2] = 0;
    if(QueryDosDeviceW(DriveName,Buffer,ARRAYSIZE(Buffer))) {

        //
        // Get SystemPartition Harddisk Geometry
        //
        Handle = CreateFile(
                    HardDiskName,
                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
                    );

        if(Handle != INVALID_HANDLE_VALUE) {
            DeviceIoControl(
                Handle,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                pSystemMediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        //
        // Get SystemPartition Potition
        //
            if (BuildNumber <= NT40){ //check NT Version
                p = wcsstr(Buffer,L"\\Partition");
                Position = (UCHAR)wcstol((p + LENGTHOF("\\Partition")) ,&stop ,10);
                //
                // QueryDosDevice in NT3.51 is buggy.
                // This API return "\\Harddisk\...." or
                // "\\harddisk\...."
                // We need work around.
                //
                p = wcsstr(Buffer,L"arddisk");
                DiskNo = (*(p + LENGTHOF("arddisk")) - L'0');
            } else {
                b = DeviceIoControl(Handle, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                            &number, sizeof(number), &DataSize, NULL);
                if (b) {
                    Position = (UCHAR) number.PartitionNumber;
                    DiskNo = (UCHAR) number.DeviceNumber;
                } else {
                    Extent = malloc(1024);
                    ExtentSize = 1024;
                    if(!Extent) {
                        CloseHandle( Handle );
                        return(Position);
                    }
                    b = DeviceIoControl(Handle, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                        NULL, 0,
                                        (PVOID)Extent, ExtentSize, &DataSize, NULL);
                    if (!b) {
                        free(Extent);
                        CloseHandle( Handle );
                        return(Position);
                    }
                    if (Extent->NumberOfDiskExtents != 1){
                        free(Extent);
                        CloseHandle( Handle );
                        return(Position);
                    }
                    DiskNo = (TCHAR)Extent->Extents->DiskNumber;
                    Position = 0;
                    free(Extent);
                }
            }
            CloseHandle(Handle);
            swprintf(DevicePath,L"\\\\.\\PHYSICALDRIVE%u",DiskNo);
            *phDisk = CreateFileW( DevicePath, GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL
                );
        }
    }
    return(Position);
}

VOID
LocateFirstFloppyDrive(
    VOID
    )
{
    UINT rc;
    TCHAR i;

    if(!IsNEC98()) {
        FirstFloppyDriveLetter = TEXT('A');
        return;
    }

    //
    // MyGetDriveType returns DRIVE_REMOVABLE, if drive is floppy.
    //
    for(i = TEXT('A'); i <= TEXT('Y'); i++) {

        if((rc = MyGetDriveType(i)) == DRIVE_REMOVABLE) {
            FirstFloppyDriveLetter = i;
            return;
        }
    }

    //
    // None found yet, set it to Z
    //
    FirstFloppyDriveLetter = TEXT('Z');
}

#endif

#if defined(_X86_)

VOID
DeleteNEC98DriveAssignFlag(
    VOID
    )
{
    TCHAR HiveName[MAX_PATH];
    TCHAR tmp[256];
    LONG  res;
    HKEY hhive;

    if (FAILED (StringCchCopy (HiveName,ARRAYSIZE(HiveName),LocalBootDirectory)) ||
        !ConcatenatePaths(HiveName,TEXT("setupreg.hiv"),ARRAYSIZE(HiveName))) {

        MYASSERT(FALSE);
        HiveName[0] = 0;
    }

    if(!AdjustPrivilege(SE_RESTORE_NAME)){
        MYASSERT(FALSE);
        //LOG((LOG_WARNING, "DeleteNEC98DriveAssignFlag: AdjustPrivilege(SE_RESTORE_NAME) failed"));
        //return;
    }
    res = RegLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"), HiveName);
    if (res != ERROR_SUCCESS){
        return;
    }
    res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("$WINNT32\\setup"), 0, KEY_ALL_ACCESS, &hhive);
    if (res != ERROR_SUCCESS){
        RegUnLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"));
        return;
    }
    res = RegDeleteValue(hhive, TEXT("DriveLetter"));
    res = RegCloseKey(hhive);
    res = RegUnLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"));

}

VOID
W95SetABFwFresh(
    int bBootDrvLtr
    )
{
//
// These items are used to call 98ptn32.dll.
//
//
// Almost below codes are copied from win95upg\w95upg\init9x\init9x.c
//


typedef BOOL (CALLBACK WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE)(int, WORD);
typedef WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE * PWIN95_PLUGIN_98PTN32_SETBOOTFLAG;

#define WIN95_98PTN32_SETBOOTFLAG_W   L"SetBootable95ptn32"
#define WIN95_98PTN32_SETBOOTFLAG_A   "SetBootable95ptn32"
#define NEC98_DLL_NAME_W            L"98PTN32.DLL"
#define NEC98_DLL_NAME_A            "98PTN32.DLL"
#ifdef UNICODE
#define WIN95_98PTN32_SETBOOTFLAG  WIN95_98PTN32_SETBOOTFLAG_W
#define NEC98_DLL_NAME  NEC98_DLL_NAME_W
#else
#define WIN95_98PTN32_SETBOOTFLAG  WIN95_98PTN32_SETBOOTFLAG_A
#define NEC98_DLL_NAME  NEC98_DLL_NAME_A
#endif
#define SB_BOOTABLE   0x0001
#define SB_UNBOOTABLE 0x0002
#define MSK_BOOTABLE  0x000f
#define SB_AUTO       0x0010
#define MSK_AUTO      0x00f0

    TCHAR MyPath[MAX_PATH], *p;
    HINSTANCE g_Pc98ModuleHandle = NULL;
    PWIN95_PLUGIN_98PTN32_SETBOOTFLAG   SetBootFlag16;


    //
    // Obtain PC-98 helper routine addresses
    // Generate directory of WINNT32
    //
    if( !MyGetModuleFileName (NULL, MyPath, ARRAYSIZE(MyPath)) || (!(p =_tcsrchr(MyPath, TEXT('\\')))))
        return;
    *p= 0;
    if (!ConcatenatePaths (MyPath, NEC98_DLL_NAME, ARRAYSIZE(MyPath))) {
        return;
    }

    //
    // Load library
    //
    g_Pc98ModuleHandle = LoadLibraryEx(
                            MyPath,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if(!g_Pc98ModuleHandle){
        return;
    }

    //
    // Get entry points
    //

    (FARPROC)SetBootFlag16 = GetProcAddress (g_Pc98ModuleHandle, (const char *)WIN95_98PTN32_SETBOOTFLAG);
    if(!SetBootFlag16){
        FreeLibrary(g_Pc98ModuleHandle);
        return;
    }

    //
    // Set auto boot flag on System drive use 16 bit DLL.
    //

   SetBootFlag16(bBootDrvLtr, SB_BOOTABLE | SB_AUTO);
   FreeLibrary(g_Pc98ModuleHandle);
}

//
// Some NEC98 Windows NT4 system is installed DMITOOL
// This AP block the CreateFile API
// Setup need to check this AP
//
// Return
//      TRUE ... DMITOOL is installed
//      False .. DMITOOL is not installed

BOOL
NEC98CheckDMI()
{
    HKEY hKey;
    LONG Error;
    TCHAR buf[100];
    DWORD bufsize = sizeof(buf);

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\NEC\\PcAssistant\\Common"),
                      0, KEY_READ, &hKey) != ERROR_SUCCESS ) {
        return(FALSE);
    }
    if (RegQueryValueEx(hKey, TEXT("Ver"), NULL,
                        NULL, (unsigned char *)buf,
                        &bufsize ) != ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        return(FALSE);
    }
    RegCloseKey( hKey );
    //
    // We need check major Version is '2.
    //
    if (bufsize >= sizeof (buf[0]) && (TCHAR)*buf != (TCHAR)'2')
        return(FALSE);
    return(TRUE);

}
#endif


typedef BOOL (WINAPI* INITBILLBOARD)(HWND , LPCTSTR, DWORD);
typedef BOOL (WINAPI* TERMBILLBOARD)();

void PrepareBillBoard(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    INITBILLBOARD pinitbb;
    BOOL bMagnifierRunning = FALSE;

    // Check if Magnifier is running.
    HANDLE hEvent = CreateEvent(NULL, TRUE, TRUE, TEXT("MSMagnifierAlreadyExistsEvent"));
    bMagnifierRunning = (!hEvent || GetLastError() == ERROR_ALREADY_EXISTS);
    if (hEvent)
    {
        CloseHandle(hEvent);
    }
    // If the Magnifier is not set yet, set it.
    if (!AccessibleMagnifier)
    {
        AccessibleMagnifier = bMagnifierRunning;
    }

    if (!bMagnifierRunning && FindPathToWinnt32File (
#ifndef UNICODE
            TEXT("winntbba.dll"),
#else
            TEXT("winntbbu.dll"),
#endif
            szPath,
            ARRAYSIZE(szPath)
            )) {
        hinstBB = LoadLibrary (szPath);
        if (hinstBB)
        {

            pinitbb = (INITBILLBOARD)GetProcAddress(hinstBB, "InitBillBoard");
            if (pinitbb)
            {
                // Set no billboard text, just the background
                if (!(*pinitbb)(hwnd, TEXT(""), ProductFlavor))
                {
                    FreeLibrary(hinstBB);
                    hinstBB = NULL;
                }
            }
        }
    }
}


void TerminateBillBoard()
{
    TERMBILLBOARD pTermBillBoard;
    if (hinstBB)
    {
        if (pTermBillBoard = (TERMBILLBOARD)GetProcAddress(hinstBB, "TermBillBoard"))
            pTermBillBoard ();
    }
}

//
// This function is here so that when the wizard is hidden and the users
// task switches between other apps and setup, that we can handle the
// ESC key and forward it to the wizard dialog proc.
LRESULT
CALLBACK
MainBackgroundWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {

        case WM_CHAR:
            if (wParam == VK_ESCAPE)
            {
                // Forward this to the wizard dlg proc.
                SendMessage(WizardHandle, uMsg, wParam, lParam);
                return 0;
            }
            break;
    }
    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}

void CreateMainWindow()
{
    RECT rect;
    WNDCLASSEX wcx;
    TCHAR Caption[512];

    GetWindowRect (GetDesktopWindow(), &rect);

    ZeroMemory (&wcx, sizeof (wcx));
    wcx.cbSize = sizeof (wcx);
    wcx.style = CS_HREDRAW | CS_VREDRAW| CS_NOCLOSE;
    wcx.lpfnWndProc = MainBackgroundWndProc;
    wcx.hInstance = hInst;
    wcx.lpszClassName = TEXT("Winnt32Background");

    RegisterClassEx (&wcx);

    if (!LoadString (
            hInst,
            AppTitleStringId,
            Caption,
            ARRAYSIZE(Caption)
            )) {
        Caption[0] = 0;
    }

    BackgroundWnd2 = CreateWindowEx (
                          WS_EX_APPWINDOW,
                          TEXT("Winnt32Background"),
                          Caption,
                          WS_CLIPCHILDREN|WS_POPUP|WS_VISIBLE,
                          rect.left,
                          rect.top,
                          rect.right,
                          rect.bottom,
                          NULL,
                          NULL,
                          hInst,
                          0
                          );

}


VOID
DisableSystemRestore( void )
/*
    Description:
        Procedure to disable system restore on upgrades. This way we save a lot of space
        as disabling system restore will clear out the old files under
        System Volume Information\_restore.{guid}".

*/
{

    HMODULE SRClient = NULL;


    if( Upgrade ){

        SRClient = LoadLibrary(TEXT("SRCLIENT.DLL"));

        if( !SRClient )
            return;
        else{

            if( ((FARPROC)SRClientDisableSR = GetProcAddress( SRClient, "DisableSR")) != NULL){

                //Call the routine

                SRClientDisableSR( NULL );

                DebugLog(Winnt32LogInformation, TEXT("System Restore was disabled"), 0);


            }
        }

        FreeLibrary( SRClient );
    }
    return;
}

#ifdef RUN_SYSPARSE
VOID
pCenterWindowOnDesktop (
    HWND WndToCenter
    )

/*++

Routine Description:

    Centers a dialog relative to the 'work area' of the desktop.

Arguments:

    WndToCenter - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}


LRESULT
SysParseDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DWORD ElapsedTime = 0;
    static UINT_PTR timer = 0;
    DWORD ret;

    switch(msg) {
    case WM_INITDIALOG:
        pCenterWindowOnDesktop( hdlg);
        timer = SetTimer( hdlg, WMX_SYSPARSE_DONE, 1000, NULL);
        if ( !timer) {
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );
    case WM_TIMER:
        ElapsedTime++;
        ret = WaitForSingleObject( piSysparse.hProcess, 0);
        if ( ret == WAIT_OBJECT_0) {
            KillTimer (hdlg, timer);
            EndDialog(hdlg,TRUE);
        } else if ( ElapsedTime >= 90) {
            KillTimer (hdlg, timer);
            TerminateProcess( piSysparse.hProcess, ERROR_TIMEOUT);
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );
    default:
        break;
    }

    return( FALSE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\winnt32.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <winioctl.h>
#include <setupbat.h>
#include <setupapi.h>
#include <winnls.h>
#include <shlwapi.h>
#include <winspool.h>
#include <wininet.h>

#include <tchar.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>

#include <winnt32p.h>
#include <pidgen.h>
#include <locale.h>
#include <ntverp.h>
#include <patchapi.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <imagehlp.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#include "resource.h"

#include "util.h"
#include "hwdb.h"
#include "wsdu.h"
#include "dynupdt.h"
#include "diamond.h"

//
// moved to precomp.h
//
//#include "msg.h"
#include "helpids.h"

#include "comp.h"
#include "compliance.h"

#include "mgdlllib.h"


#ifdef PRERELEASE
#define TRY
#define EXCEPT(e)   goto __skip;
#define _exception_code() 0
#define END_EXCEPT  __skip:;
#else
#define TRY         __try
#define EXCEPT(e)   __except (e)
#define END_EXCEPT
#endif

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define LENGTHOF(a)         (ARRAYSIZE(a) - 1)

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)
#define UNATTENDED(btn)     if((UnattendedOperation) && (!CancelPending)) PostMessage(hdlg,WMX_UNATTENDED,btn,0)
#define CHECKUPGRADEONLY()  if(CheckUpgradeOnly) return( FALSE )
#define CHECKUPGRADEONLY_Q()  if(CheckUpgradeOnlyQ) return( FALSE )
#define SetDialogFocus(_hwnd, _hwndchild) SendMessage(_hwnd, WM_NEXTDLGCTL, (WPARAM)_hwndchild, MAKELPARAM(TRUE, 0))
#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))
#define HIULONG(_val_)      ((ULONG)(_val_>>32))
#define LOULONG(_val_)      ((ULONG)_val_)
#define TYPICAL()     (dwSetupFlags & UPG_FLAG_TYPICAL)


extern HINSTANCE hInst;
extern UINT AppTitleStringId;
extern DWORD TlsIndex;
extern HINSTANCE hinstBB;
extern HWND WizardHandle;
extern BOOL g_DeleteRunOnceFlag;
HWND GetBBhwnd();
HWND GetBBMainHwnd();


#define S_WINNT32_WARNING               TEXT("Winnt32RunOnceWarning")
// #define RUN_SYSPARSE 1

//
// Flag indicating whether we are initiating an MSI-Install.
//
extern BOOL RunFromMSI;
//
// Flag indicating whether we are initiating an Typical install
//
extern DWORD dwSetupFlags;
//
// Flag indicating whether we are initiating an upgrade.
//
extern BOOL Upgrade;

//
// Flag to say if we need to write the AcpiHAL value to the winnt.sif file
//
extern BOOL WriteAcpiHalValue;

//
// What should we write as the value for the AcpiHalValue
//
extern BOOL AcpiHalValue;

//
// Flag indicating whether we're installing/upgrading to NT Server
//
extern BOOL Server;

//
// Flag to indicate if we are running BVT's
//
extern BOOL RunningBVTs;

//
// When running BVT's, what baudrate should we set the debugger to?
//
extern LONG lDebugBaudRate;

//
// When running BVT's, what comport should we set the debugger to?
//
extern LONG lDebugComPort;

//
// When running BVT's, should we copy the symbols locally?
//
extern BOOL CopySymbols;

//
// Flag to indicate if we are running ASR tests
//
extern DWORD AsrQuickTest;

//
// Product type and flavor for upgrade modules
//
extern PRODUCTTYPE UpgradeProductType;
extern UINT ProductFlavor;

//
// fat to ntfs conversion flag
//
extern BOOL ForceNTFSConversion;
extern BOOL NTFSConversionChanged;

//
// 16 bit environment boot (Win9x upgrade only)
//
typedef enum {
    BOOT16_AUTOMATIC,
    BOOT16_YES,
    BOOT16_NO
} BOOT16_OPTIONS;
extern UINT g_Boot16;

//
// Global flag indicating whether the entire overall program operation
// was successful. Also a flag indicating whether to shut down automatically
// when the wizard is done in the non-unattended case.
//
extern BOOL GlobalResult;
extern BOOL AutomaticallyShutDown;

//
// Global OS version info.
//
extern OSVERSIONINFO OsVersion;
extern DWORD OsVersionNumber;
#define BUILDNUM()  (OsVersion.dwBuildNumber)
#ifdef UNICODE
#define ISNT()      (TRUE)
#define ISOSR2()    (FALSE)
#else
#define ISNT()      (FALSE)
#define ISOSR2()    (LOWORD(OsVersion.dwBuildNumber) > 1080)
#endif

extern WINNT32_PLUGIN_INIT_INFORMATION_BLOCK info;

//
// Flags indicating how we were run and whether to create
// a local source.
//
extern BOOL RunFromCD;
extern BOOL MakeLocalSource;
extern BOOL UserSpecifiedMakeLocalSource;
extern BOOL NoLs;
extern TCHAR UserSpecifiedLocalSourceDrive;
extern LONG SourceInstallType; // uses InstallType enum
extern DWORD MLSDiskID;

//
// Used for win9xupg reporting (reportonly mode)
//
extern UINT UpgRequiredMb;
extern UINT UpgAvailableMb;

//
// advanced install options
//
extern BOOL ChoosePartition;
extern BOOL UseSignatures;
extern TCHAR InstallDir[MAX_PATH];
extern TCHAR HeadlessSelection[MAX_PATH];
extern ULONG HeadlessBaudRate;
#ifdef PRERELEASE
extern BOOL AppendDebugDataToBoot;
#endif

//
// SMS support
//
extern PSTR LastMessage;

#if defined(REMOTE_BOOT)
//
// Flag indicating whether we're running on a remote boot client.
//
extern BOOL RemoteBoot;

//
// Path to the machine directory for a remote boot client.
//
extern TCHAR MachineDirectory[MAX_PATH];
#endif // defined(REMOTE_BOOT)

//
// Flags indicating which Accessibility utilities to use
//
extern BOOL AccessibleMagnifier;
extern BOOL AccessibleKeyboard;
extern BOOL AccessibleVoice;
extern BOOL AccessibleReader;

//
// Build number we're upgrading from
//
extern DWORD BuildNumber;
#define     NT351   1057
#define     NT40    1381
#define     NT50B1  1671
#define     NT50B3  2031
#define     NT50    2195
#define     NT51B2  2462
#define     NT51    2600

//
// Are any of the Accesssibility utilities enabled?
//
extern BOOL AccessibleSetup;

//
// Flags and values relating to unattended operation.
//
extern BOOL UnattendedOperation;
extern BOOL UnattendSwitchSpecified;
extern PTSTR UnattendedScriptFile;
extern UINT UnattendedShutdownTimeout;
extern UINT UnattendedCountdown;
extern BOOL BatchMode;

//
// Name of unattended script file to be used for Accessible Setup
//
extern TCHAR AccessibleScriptFile[MAX_PATH];

//
// Name of inf file and handles to dosnet.inf and txtsetup.sif.
//
extern TCHAR InfName[MAX_PATH];
extern PVOID MainInf;
extern TCHAR FullInfName[MAX_PATH];
extern PVOID TxtsetupSif;
extern PVOID NtcompatInf;

BOOL
GetMainInfValue (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      DWORD FieldNumber,
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    );

//
// Language options stuff
//
extern BOOL    IntlInfProcessed;
extern DWORD   PrimaryLocale;

// Global used in WriteParamsFile and AddExternalParams
extern TCHAR ActualParamFile[MAX_PATH];

BOOL InitLangControl(HWND hdlg, BOOL bFarEast);
BOOL IsFarEastLanguage(DWORD LangIdx);
BOOL SelectFarEastLangGroup(BOOL bSelect);

void BB_SetProgressText(LPTSTR szText);
void BB_SetTimeEstimateText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);

extern
BOOL
ReadIntlInf(
    IN HWND   hdlg
    );

extern
VOID
SaveLanguageDirs(
    );

extern
BOOL
SaveLanguageParams(
    IN LPCTSTR FileName
    );

extern
VOID
FreeLanguageData(
    );

VOID
CleanUpOldLocalSources(
    IN HWND hdlg
    );

BOOL
InspectFilesystems(
    IN HWND hdlg
    );

BOOL
LoadInfWorker(
    IN  HWND     hdlg,
    IN  LPCTSTR  FilenamePart,
    OUT PVOID   *InfHandle,
    IN  BOOL     Winnt32File
    );

BOOL
FindLocalSourceAndCheckSpace(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

BOOL
EnoughMemory(
    IN HWND hdlg,
    IN BOOL QuickTest
    );

//
// Optional directory stuff.
//
#define MAX_OPTIONALDIRS    20
extern UINT OptionalDirectoryCount;
extern TCHAR OptionalDirectories[MAX_OPTIONALDIRS][MAX_PATH];
extern UINT OptionalDirectoryFlags[MAX_OPTIONALDIRS];

#define OPTDIR_TEMPONLY                 0x00000001
#define OPTDIR_OEMSYS                   0x00000002
#define OPTDIR_OVERLAY                  0x00000004
#define OPTDIR_ADDSRCARCH               0x00000008
#define OPTDIR_ABSOLUTE                 0x00000010
#define OPTDIR_DEBUGGER                 0x00000020  // speficies that this optional dir is to be copied to %windir%\Debuggers
// OPTDIR_PLATFORM_INDEP becomes DIR_IS_PLATFORM_INDEPEND and FILE_IN_PLATFORM_INDEPEND_DIR
#define OPTDIR_PLATFORM_INDEP           0x00000040
#define OPTDIR_IN_LOCAL_BOOT            0x00000080
#define OPTDIR_SUPPORT_DYNAMIC_UPDATE   0x00000100
#define OPTDIR_USE_TAIL_FOLDER_NAME     0x00000200
#define OPTDIR_PLATFORM_SPECIFIC_FIRST  0x00000400
#define OPTDIR_DOESNT_SUPPORT_PRIVATES  0x00000800
#define OPTDIR_SIDE_BY_SIDE             0x00001000

//
// Source paths and count of paths.
//
extern TCHAR SourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern TCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern UINT SourceCount;
extern TCHAR *UserSpecifiedOEMShare;
//
// Local source information.
//
#define DEFAULT_INSTALL_DIR     TEXT("\\WINDOWS")
#define INTERNAL_WINNT32_DIR    TEXT("winnt32")

#define LOCAL_SOURCE_DIR_A      "$WIN_NT$.~LS"
#define LOCAL_SOURCE_DIR_W      L"$WIN_NT$.~LS"
#define TEXTMODE_INF_A          "TXTSETUP.SIF"
#define TEXTMODE_INF_W          L"TXTSETUP.SIF"
#define NTCOMPAT_INF_A          "COMPDATA\\NTCOMPAT.INF"
#define NTCOMPAT_INF_W          L"COMPDATA\\NTCOMPAT.INF"
#define DRVINDEX_INF_A          "DRVINDEX.INF"
#define DRVINDEX_INF_W          L"DRVINDEX.INF"
#define SETUPP_INI_A            "SETUPP.INI"
#define SETUPP_INI_W            L"SETUPP.INI"
#define PID_SECTION_A           "Pid"
#define PID_SECTION_W           L"Pid"
#define PID_KEY_A               "Pid"
#define PID_KEY_W               L"Pid"
#define OEM_INSTALL_RPC_A       "OEM"
#define OEM_INSTALL_RPC_W       L"OEM"
#define SELECT_INSTALL_RPC_A    "270"
#define SELECT_INSTALL_RPC_W    L"270"
#define MSDN_INSTALL_RPC_A      "335"
#define MSDN_INSTALL_RPC_W      L"335"
#define MSDN_PID30_A            "MD97J-QC7R7-TQJGD-3V2WM-W7PVM"
#define MSDN_PID30_W            L"MD97J-QC7R7-TQJGD-3V2WM-W7PVM"

#define INF_FILE_HEADER         "[Version]\r\nSignature = \"$Windows NT$\"\r\n\r\n"


#ifdef UNICODE
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_W
#define TEXTMODE_INF            TEXTMODE_INF_W
#define NTCOMPAT_INF            NTCOMPAT_INF_W
#define DRVINDEX_INF            DRVINDEX_INF_W
#define SETUPP_INI              SETUPP_INI_W
#define PID_SECTION             PID_SECTION_W
#define PID_KEY                 PID_KEY_W
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_W
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_W
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_W
#define MSDN_PID30              MSDN_PID30_W
#else
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_A
#define TEXTMODE_INF            TEXTMODE_INF_A
#define NTCOMPAT_INF            NTCOMPAT_INF_A
#define DRVINDEX_INF            DRVINDEX_INF_A
#define SETUPP_INI              SETUPP_INI_A
#define PID_SECTION             PID_SECTION_A
#define PID_KEY                 PID_KEY_A
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_A
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_A
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_A
#define MSDN_PID30              MSDN_PID30_A
#endif

#if defined(_AMD64_) || defined(_X86_)
#define LOCAL_BOOT_DIR_A        "$WIN_NT$.~BT"
#define LOCAL_BOOT_DIR_W        L"$WIN_NT$.~BT"
#define AUX_BS_NAME_A           "$LDR$"
#define AUX_BS_NAME_W           L"$LDR$"
#define FLOPPY_COUNT            4
//
// Local BACKUP information, on NEC98.
//
#define LOCAL_BACKUP_DIR_A      "$WIN_NT$.~BU"
#define LOCAL_BACKUP_DIR_W      L"$WIN_NT$.~BU"
#ifdef UNICODE
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_W
#define AUX_BS_NAME             AUX_BS_NAME_W
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_W
#else
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_A
#define AUX_BS_NAME             AUX_BS_NAME_A
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_A
#endif
extern TCHAR LocalBackupDirectory[MAX_PATH];
extern TCHAR FirstFloppyDriveLetter;
#endif

extern DWORD LocalSourceDriveOffset;

extern TCHAR LocalSourceDrive;
extern TCHAR LocalSourceDirectory[MAX_PATH];
extern TCHAR LocalSourceWithPlatform[MAX_PATH];
extern TCHAR LocalBootDirectory[MAX_PATH];
extern BOOL  BlockOnNotEnoughSpace;
extern LONGLONG LocalSourceSpaceRequired;
extern LONGLONG WinDirSpaceFor9x;
extern BOOL UpginfsUpdated;
extern BOOL Win95upgInfUpdated;

//
// wizard stuff
//

// wizard page size
#define WIZ_PAGE_SIZE_X 317
#define WIZ_PAGE_SIZE_Y 179

#define BBSTEP_NONE                         0
#define BBSTEP_COLLECTING_INFORMATION       1
#define BBSTEP_DYNAMIC_UPDATE               2
#define BBSTEP_PREPARING                    3

typedef struct _PAGE_COMMON_DATA {

    DLGPROC DialogProcedure;

    UINT BillboardStep;

    //
    // State to initialize buttons to.
    //
    DWORD Buttons;

    UINT Flags;

} PAGE_COMMON_DATA, *PPAGE_COMMON_DATA;


typedef struct _PAGE_CREATE_DATA {
    //
    // If these are specified, then a range of pages may come
    // from somewhere else. Otherwise, it's one page whose
    // resource id is given below.
    //
    LPPROPSHEETPAGE *ExternalPages;
    PUINT ExternalPageCount;

    UINT Template;

    PAGE_COMMON_DATA CommonData;

} PAGE_CREATE_DATA, *PPAGE_CREATE_DATA;


typedef struct _PAGE_RUNTIME_DATA {

    PAGE_COMMON_DATA CommonData;

    //
    // Per-page (private) data
    //
    DWORD PerPageData;

} PAGE_RUNTIME_DATA, *PPAGE_RUNTIME_DATA;


typedef struct _BITMAP_DATA {
    CONST BITMAPINFOHEADER *BitmapInfoHeader;
    PVOID                   BitmapBits;
    HPALETTE                Palette;
    UINT                    PaletteColorCount;
    BOOL                    Adjusted;
} BITMAP_DATA, *PBITMAP_DATA;


#define WIZPAGE_FULL_PAGE_WATERMARK 0x00000001
#define WIZPAGE_SEPARATOR_CREATED   0x00000002
#define WIZPAGE_NEW_HEADER          0x00000004


//
// compatibility data
//

typedef struct _COMPATIBILITY_DATA {
    //
    // general
    //
    LIST_ENTRY ListEntry;
    //
    // what type of entry
    //
    TCHAR    Type;
    //
    // service-driver data
    //
    LPCTSTR  ServiceName;
    //
    // registry data
    //
    LPCTSTR  RegKey;
    LPCTSTR  RegValue;
    LPCTSTR  RegValueExpect;
    //
    // file data
    //
    LPCTSTR  FileName;
    LPCTSTR  FileVer;
    //
    // common
    //
    LPCTSTR  Description;
    LPCTSTR  HtmlName;
    LPCTSTR  TextName;
    LPTSTR   RegKeyName;
    LPTSTR   RegValName;
    LPVOID   RegValData;
    DWORD    RegValDataSize;
    LPVOID   SaveValue;
    DWORD    Flags;
    LPCTSTR  InfName;
    LPCTSTR  InfSection;

    HMODULE                 hModDll;
    PCOMPAIBILITYHAVEDISK   CompHaveDisk;

} COMPATIBILITY_DATA, *PCOMPATIBILITY_DATA;

extern LIST_ENTRY CompatibilityData;
extern DWORD CompatibilityCount;
extern DWORD IncompatibilityStopsInstallation;
extern BOOL AnyNt5CompatDlls;

BOOL
AnyBlockingCompatibilityItems (
    VOID
    );

//
// Plug and Play device migration routines.
// (linked into winnt.dll from pnpsif.lib)
//
BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );

//
// Array of drive letters for all system partitions.
// Note that on amd64/x86 there will always be exactly one.
// The list is 0-terminated.
//
extern TCHAR SystemPartitionDriveLetters[27];
extern TCHAR SystemPartitionDriveLetter;

#ifdef UNICODE
extern UINT SystemPartitionCount;
extern PWSTR* SystemPartitionNtNames;
extern PWSTR SystemPartitionNtName;
extern PWSTR SystemPartitionVolumeGuid;
#else
extern PCSTR g_LocalSourcePath;
#endif

//
// UDF stuff
//
extern LPCTSTR UniquenessId;
extern LPCTSTR UniquenessDatabaseFile;

//
// Preinstall stuff
//
extern BOOL OemPreinstall;

#if defined(_AMD64_) || defined(_X86_)
typedef struct _OEM_BOOT_FILE {
    struct _OEM_BOOT_FILE *Next;
    LPCTSTR Filename;
} OEM_BOOT_FILE, *POEM_BOOT_FILE;

extern POEM_BOOT_FILE OemBootFiles;
#endif

extern TCHAR ForcedSystemPartition;

//
// Miscellaneous other command line parameters.
//
extern LPCTSTR CmdToExecuteAtEndOfGui;
extern BOOL AutoSkipMissingFiles;
extern BOOL HideWinDir;
extern TCHAR ProductId[64];

//
// Flag indicating that the user cancelled.
// Flag indicating that a succssessful abort should be performed.
// Handle for mutex used to guarantee that only one error dialog
// is on the screen at once.
//
extern BOOL Cancelled;
extern BOOL CancelPending;
extern BOOL Aborted;
extern HANDLE UiMutex;

//
// This indicates that well give the user some detailed data-throughput
// info.
//
extern BOOL DetailedCopyProgress;
extern ULONGLONG TotalDataCopied;

//
// Upgrade Options variables. Used to pass a multistring of
// upgrade command line options to the plugin DLLs.
//
extern LPTSTR UpgradeOptions;
extern DWORD  UpgradeOptionsLength;
extern DWORD  UpgradeOptionsSize;

BOOL
AppendUpgradeOption (
    IN      PCTSTR String
    );

#if defined(_AMD64_) || defined(_X86_)
//
// Win9x upgrade report status
//

extern UINT g_UpgradeReportMode;
#endif

//
// Compliance variables
//
extern BOOL   NoCompliance;
extern BOOL   NoBuildCheck;

// UpgradeOnly is true is the media is CCP media and only valid
// to upgrade a system.  eula.c will use this to ensure that an
// FPP pid is not used with CCP media and vice-versa
extern BOOL   UpgradeOnly;

extern BOOL   SkipLocaleCheck;
extern BOOL   SkipVirusScannerCheck;

extern BOOL   UseBIOSToBoot;

//
// TargetNativeLangID : this is native language ID of running system
//
extern LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
extern LANGID SourceNativeLangID;

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//                     1. if SourceNativeLangID == TargetNativeLangID
//
//                     2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
extern BOOL IsLanguageMatched;

BOOL
InitLanguageDetection(
    LPCTSTR SourcePath,
    LPCTSTR InfFile
    );



//
// Routines from Setupapi.dll
//

//
// ISSUE: be careful when using this routine on NT4, as it may fail;
// setupapi on NT4 doesn't understand LZX compression, currently used to compress files
//
extern
DWORD
(*SetupapiDecompressOrCopyFile)(
    IN  PCTSTR  SourceFileName,
    OUT PCTSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    );

extern
HINF
(*SetupapiOpenInfFile)(
    IN  LPCTSTR FileName,
    IN  LPCTSTR InfClass,    OPTIONAL
    IN  DWORD   InfStyle,
    OUT PUINT   ErrorLine    OPTIONAL
    );

extern
VOID
(*SetupapiCloseInfFile)(
    IN HINF InfHandle
    );

extern
BOOL
(*SetupapiFindFirstLine)(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiFindNextLine)(
    PINFCONTEXT ContextIn,
    PINFCONTEXT ContextOut
    );

extern
BOOL
(*SetupapiFindNextMatchLine)(
    PINFCONTEXT ContextIn,
    PCTSTR Key,
    PINFCONTEXT ContextOut
    );

extern
LONG
(*SetupapiGetLineCount)(
    IN HINF   InfHandle,
    IN LPCTSTR Section
    );

extern
DWORD
(*SetupapiGetFieldCount)(
    IN  PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiGetStringField)(
    IN  PINFCONTEXT Context,
    DWORD FieldIndex,
    PTSTR ReturnBuffer,
    DWORD ReturnBufferSize,
    PDWORD RequiredSize
    );

extern
BOOL
(*SetupapiGetLineByIndex)(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

extern
HSPFILEQ
(*SetupapiOpenFileQueue) (
    VOID
    );

extern
BOOL
(*SetupapiCloseFileQueue) (
    IN HSPFILEQ QueueHandle
    );

extern
BOOL
(*SetupapiQueueCopy) (
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

extern
BOOL
(*SetupapiCommitFileQueue) (
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

extern
UINT
(*SetupapiDefaultQueueCallback) (
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

extern
PVOID
(*SetupapiInitDefaultQueueCallback) (
    HWND OwnerWindow
);

extern
VOID
(*SetupapiTermDefaultQueueCallback) (
    PVOID Context
);

#ifdef UNICODE

extern
BOOL
(*SetupapiGetSourceFileLocation) (
    HINF InfHandle,          // handle of an INF file
    PINFCONTEXT InfContext,  // optional, context of an INF file
    PCTSTR FileName,         // optional, source file to locate
    PUINT SourceId,          // receives the source media ID
    PTSTR ReturnBuffer,      // optional, receives the location
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

extern
BOOL
(*SetupapiGetInfInformation) (
    LPCVOID InfSpec,         // handle or filename of the INF file
    DWORD SearchControl,     // how to search for the INF file
    PSP_INF_INFORMATION ReturnBuffer, // optional, receives the INF info
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

extern
BOOL
(*SetupapiQueryInfFileInformation) (
    PSP_INF_INFORMATION InfInformation, // structure that contains the INF info
    UINT InfIndex,           // index of the file to investigate
    PTSTR ReturnBuffer,      // optional, receives the information
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

extern
BOOL
(*SetupapiQueryInfOriginalFileInformation) (
    PSP_INF_INFORMATION InfInformation,         // structure that contains the INF information
    UINT InfIndex,                              // index of the file to investigate
    PSP_ALTPLATFORM_INFO AlternatePlatformInfo, // optional, receives the alternate platform information
    PSP_ORIGINAL_FILE_INFO OriginalFileInfo     // original file information
);

#endif

//
// Custom window messages. Define so they don't overlap with
// any being used by plug-in dll's.
//
#define WMX_EDITCONTROLSTATE    (WMX_PLUGIN_FIRST-1)
#define WMX_INSPECTRESULT       (WMX_PLUGIN_FIRST-2)
//#define WMX_SETPROGRESSTEXT     (WMX_PLUGIN_FIRST-3)
#define WMX_ERRORMESSAGEUP      (WMX_PLUGIN_FIRST-4)
#define WMX_I_AM_VISIBLE        (WMX_PLUGIN_FIRST-5)
#define WMX_COPYPROGRESS        (WMX_PLUGIN_FIRST-6)
#define WMX_I_AM_DONE           (WMX_PLUGIN_FIRST-7)
#define WMX_FINISHBUTTON        (WMX_PLUGIN_FIRST-8)
#define WMX_UNATTENDED          (WMX_PLUGIN_FIRST-9)
#define WMX_NEXTBUTTON          (WMX_PLUGIN_FIRST-10)
#define WMX_BACKBUTTON          (WMX_PLUGIN_FIRST-11)
#define WMX_VALIDATE            (WMX_PLUGIN_FIRST-12)
#define WMX_SETUPUPDATE_PREPARING       (WMX_PLUGIN_FIRST-13)
#define WMX_SETUPUPDATE_DOWNLOADING     (WMX_PLUGIN_FIRST-14)
#define WMX_SETUPUPDATE_PROCESSING      (WMX_PLUGIN_FIRST-15)
#define WMX_SETUPUPDATE_DONE            (WMX_PLUGIN_FIRST-16)
#define WMX_SETUPUPDATE_CANCEL          (WMX_PLUGIN_FIRST-17)
#define WMX_SETUPUPDATE_INIT_RETRY      (WMX_PLUGIN_FIRST-18)
#define WMX_SETUPUPDATE_THREAD_DONE     (WMX_PLUGIN_FIRST-19)
#ifdef RUN_SYSPARSE
#define WMX_SYSPARSE_DONE               (WMX_PLUGIN_FIRST-20)
#endif    
#define WMX_DYNAMIC_UPDATE_COMPLETE     (WMX_PLUGIN_FIRST-21)


//
// Helper macro for uppercasing
//
#define TOUPPER(x)  (TCHAR)CharUpper((LPTSTR)x)



//
// Routine that does everything by starting the wizard.
//
VOID
Wizard(
    VOID
    );


//
// Routine that builds a cmdcons installation.
//
VOID
DoBuildCmdcons(
    VOID
    );


VOID
FixUpWizardTitle(
    IN HWND Wizard
    );

//
// Cleanup routine and globals used by the cleanup stuff.
//
DWORD
StartCleanup(
    IN PVOID ThreadParameter
    );

#if defined(_AMD64_) || defined(_X86_)

BOOL
RestoreBootSector(
    VOID
    );

BOOL
RestoreBootIni(
    VOID
    );

BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    );
#define NEC98SAVEBOOTFILES      0
#define NEC98RESTOREBOOTFILES   1

BOOL
IsDriveAssignNEC98(
    VOID
    );

//
// Check ATA Drive
//

BOOLEAN
CheckATACardonNT4(
    HANDLE hDisk
    );


//
// Check formatted drive type
//
BOOLEAN
IsValidDrive(
    TCHAR Drive
    );

#endif // defined(_AMD64_) || defined(_X86_)

BOOL
RestoreNvRam(
    VOID
    );


//
// Thread that inspects sources, loads infs, builds the copy list,
// checks disk space, etc. And some worker routines.
//

DWORD
InspectAndLoadThread(
    IN PVOID ThreadParam
    );

BOOL
InspectSources(
    IN HWND ParentWnd
    );


BOOL
BuildCopyListWorker(
    IN HWND hdlg
    );

BOOL
FindLocalSourceAndCheckSpaceWorker(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

UINT
GetTotalFileCount(
    VOID
    );

DWORD
StartCopyingThread(
    IN PVOID ThreadParameter
    );

VOID
CancelledMakeSureCopyThreadsAreDead(
    VOID
    );

DWORD
DoPostCopyingStuff(
    IN PVOID ThreadParam
    );

//
// File copy error routine and outcomes.
//
UINT
FileCopyError(
    IN HWND    ParentWindow,
    IN LPCTSTR SourceFilename,
    IN LPCTSTR TargetFilename,
    IN UINT    Win32Error,
    IN BOOL    MasterList
    );

#define COPYERR_SKIP    1
#define COPYERR_EXIT    2
#define COPYERR_RETRY   3


//
// Routine to add an optional directory to the list of dirs
// we copy.
//
BOOL
RememberOptionalDir(
    IN LPCTSTR Directory,
    IN UINT    Flags
    );

//
// Resource utility routines.
//

PCTSTR
GetStringResource (
    IN UINT Id              // ID or pointer to string name
    );

VOID
FreeStringResource (
    IN PCTSTR String
    );

VOID
SaveMessageForSMS(
    IN DWORD MessageId,
    ...
    );

VOID
SaveTextForSMS(
    IN PCTSTR Buffer
    );

int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    );

int
MessageBoxFromMessageWithSystem(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN HMODULE  hMod
    );

int
MessageBoxFromMessageAndSystemError(
    IN HWND  Window,
    IN DWORD MessageId,
    IN DWORD SystemMessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

HBITMAP
LoadResourceBitmap(
    IN  HINSTANCE hInst,
    IN  LPCTSTR   Id,
    OUT HPALETTE *Palette
    );

BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    );

UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    );

//
// Security routines.
//
BOOL
IsUserAdmin(
    VOID
    );

BOOL
DoesUserHavePrivilege(
    PCTSTR PrivilegeName
    );

BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    );

//
// Inf routines.
//
DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle
   );

VOID
UnloadInfFile(
   IN PVOID InfHandle
   );

LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   );

LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   );

LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   );

BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   );

BOOL
InfDoesEntryExistInSection (
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Entry
   );

LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    );


typedef struct {
    // Caller members (read-only)
    PCTSTR FieldZeroData;
    unsigned LineIndex;

    // Internal members
    PVOID InfHandle;
    PCTSTR SectionName;
} INF_ENUM, *PINF_ENUM;

BOOL
EnumFirstInfLine (
    OUT     PINF_ENUM InfEnum,
    IN      PVOID InfHandle,
    IN      PCTSTR InfSection
    );

BOOL
EnumNextInfLine (
    IN OUT  PINF_ENUM InfEnum
    );

VOID
AbortInfLineEnum (
    IN      PINF_ENUM InfEnum           // ZEROED
    );

//
// Routines to manipulate parameters files like unattend.txt,
// the param file we pass to text mode setup, etc.
//
BOOL
WriteParametersFile(
    IN HWND ParentWindow
    );

BOOL
AddExternalParams(
    IN HWND ParentWindow
    );

//
// Miscellaenous utility routines.
//
LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    );

VOID
MyWinHelp(
    IN HWND  Window,
    IN UINT  Command,
    IN ULONG_PTR Data
    );

BOOL
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

LPTSTR
DupString(
    IN LPCTSTR String
    );

UINT
MyGetDriveType(
    IN TCHAR Drive
    );

#ifdef UNICODE
UINT
MyGetDriveType2 (
    IN      PCWSTR NtDeviceName
    );

BOOL
MyGetDiskFreeSpace (
    IN      PCWSTR NtVolumeName,
    IN      PDWORD SectorsPerCluster,
    IN      PDWORD BytesPerSector,
    IN      PDWORD NumberOfFreeClusters,
    IN      PDWORD TotalNumberOfClusters
    );

#endif

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    );

BOOL
IsDriveNTFT(
    IN TCHAR Drive,
    IN      PCTSTR NtVolumeName
    );

BOOL
IsDriveVeritas(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );

#ifdef UNICODE

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );
#else

#define IsSoftPartition(d,n)    (FALSE)

#endif

BOOL
IsDriveNTFS(
    IN TCHAR Drive
    );

BOOL
IsMachineSupported(
    OUT PCOMPATIBILITY_ENTRY CompEntry
    );

BOOL
GetAndSaveNTFTInfo(
    IN HWND ParentWindow
    );

VOID
ForceStickyDriveLetters(
    );

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

VOID
GenerateCompressedName(
    IN  LPCTSTR Filename,
    OUT LPTSTR  CompressedName
    );

DWORD
CreateMultiLevelDirectory(
    IN LPCTSTR Directory
    );

VOID
MyDelnode(
    IN LPCTSTR Directory
    );

BOOL
ForceFileNoCompress(
    IN LPCTSTR Filename
    );

BOOL
IsCurrentOsServer(
    void
    );

BOOL
IsCurrentAdvancedServer(
    void
    );

BOOL
IsNTFSConversionRecommended(
    void
    );


BOOL
ForceBootFilesUncompressed(
    IN HWND ParentWindow,
    IN BOOL TellUserAboutError
    );

BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    );

BOOL
GetUserPrintableFileSizeString(
    IN DWORDLONG Size,
    OUT LPTSTR Buffer,
    IN DWORD BufferSize
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
DoesDirectoryExist (
    IN      PCTSTR DirSpec
    );

BOOL
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCTSTR FileName,
    OUT     PTSTR DriverCabName,        OPTIONAL
    IN      DWORD BufferChars           OPTIONAL
    );

BOOL
BuildSystemPartitionPathToFile (
    IN      PCTSTR FileName,
    OUT     PTSTR Path,
    IN      INT BufferSizeChars
    );

BOOL
FindPathToInstallationFileEx (
    IN      PCTSTR FileName,
    OUT     PTSTR PathToFile,
    IN      INT PathToFileBufferSize,
    OUT     PBOOL Compressed                OPTIONAL
    );

#define FindPathToInstallationFile(n,p,s)   FindPathToInstallationFileEx(n,p,s,NULL)


BOOL
FindPathToWinnt32File (
    IN      PCTSTR FileRelativePath,
    OUT     PTSTR PathToFile,
    IN      INT PathToFileBufferSize
    );

BOOL
GetFileVersionEx (
    IN      PCTSTR FilePath,
    OUT     PTSTR FileVersion,
    IN      INT CchFileVersion
    );

#define GetFileVersion(f,v) GetFileVersionEx(f,v,ARRAYSIZE(v))


//
// #define to use MyPrivateProfileString to get around virus checkers monitoring operations to C
// drive that cause us to fail WritePrivateProfileString
// The problem is that usually these s/w examine the files we touch and in somecases open it
// with exclusive access. We just need to wait for them to be done.
//


BOOL
MyWritePrivateProfileString(
    LPCTSTR lpAppName,  // pointer to section name
    LPCTSTR lpKeyName,  // pointer to key name
    LPCTSTR lpString,   // pointer to string to add
    LPCTSTR lpFileName  // pointer to initialization filename
    );


#ifdef UNICODE
    #define WritePrivateProfileStringW(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#else
    #define WritePrivateProfileStringA(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#endif

//
// Routines having to do with advanced program options
//
VOID
InitVariousOptions(
    VOID
    );

VOID
DoOptions(
    IN HWND Parent
    );

VOID
DoLanguage(
    IN HWND Parent
    );

VOID
DoAccessibility(
    IN HWND Parent
    );

BOOL
BrowseForDosnetInf(
    IN  HWND    hdlg,
    IN  LPCTSTR InitialPath,
    OUT TCHAR   NewPath[MAX_PATH]
    );

BOOL
IsValid8Dot3(
    IN LPCTSTR Path
    );

//
// Routines having to do with eula and pid
//
#define MAX_PID30_EDIT                       5
extern LPTSTR g_EncryptedPID;
extern BOOL g_bDeferPIDValidation;

extern BOOL EulaComplete;

typedef enum InstallType
{
   SelectInstall,
   OEMInstall,
   RetailInstall
};

VOID
GetSourceInstallType(
    OUT OPTIONAL PDWORD InstallVariation
    );

BOOL
SetPid30(
    HWND hdlg,
    LONG ExpectedPidType,
    LPTSTR pProductId
    );

#ifdef UNICODE
PCHAR
FindRealHalName(
    TCHAR *pHalFileName
    );
#endif

//
// Debugging and logging
//
typedef enum {
    Winnt32LogSevereError,
    Winnt32LogError,
    Winnt32LogWarning,
    Winnt32LogInformation,
    Winnt32LogDetailedInformation,
    Winnt32LogMax
#define WINNT32_HARDWARE_LOG 0x40000000
} Winnt32DebugLevel;

extern Winnt32DebugLevel DebugLevel;

BOOL
StartDebugLog(
    IN LPCTSTR           DebugFileLog,
    IN Winnt32DebugLevel Level
    );

VOID
CloseDebugLog(
    VOID
    );

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    ...
    );

BOOL
DebugLog2(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    IN va_list           ArgList
    );

BOOL
DynUpdtDebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,
    IN UINT              MessageId,
    ...
    );

BOOL
ConcatenateFile(
    IN HANDLE   hOpenFile,
    IN  LPTSTR  FileName
    );

VOID
GatherOtherLogFiles(
    VOID
    );

//
// Memory allocation.
//
#define MALLOC(s)       malloc(s)
#define FREE(b)         free((PVOID)b)
#define REALLOC(b,s)    realloc((b),(s))


//
// Floppy-related stuff.
//
extern BOOL MakeBootMedia;
extern BOOL Floppyless;

//
// boot loader timeout value, in string form
//
extern TCHAR Timeout[32];

#if defined(_AMD64_) || defined(_X86_)
UINT
FloppyGetTotalFileCount(
    VOID
    );

DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    );

//
// Routine to lay NT boot code, munge boot.ini, create aux boot sector, etc.
//
BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    );

BOOL
PatchTextIntoBootCode(
    VOID
    );


VOID
MigrateBootIniData();

//
// Drive information abstraction
//
typedef struct _WINNT32_DRIVE_INFORMATION {
    DWORD       CylinderCount;
    DWORD       HeadCount;
    DWORD       SectorsPerTrack;
    ULONGLONG   SectorCount;
    WORD        BytesPerSector;
} WINNT32_DRIVE_INFORMATION, *PWINNT32_DRIVE_INFORMATION;

//
// Routine to get drive form-factor/type.
//
MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo OPTIONAL
    );

//
// Disk sector I/O routines
//
BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    );

BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    );

BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    );

//
// Enum for filesystems we recognize
//
typedef enum {
    Winnt32FsUnknown,
    Winnt32FsFat,
    Winnt32FsFat32,
    Winnt32FsNtfs
} WINNT32_SYSPART_FILESYSTEM;

//
// Hardcoded constant for sector size, and sizes
// of bootcode areas for various filesystems.
//
#define WINNT32_SECTOR_SIZE             512

#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_NTFS_BOOT_SECTOR_COUNT  16

#define WINNT32_MAX_BOOT_SIZE           (16*WINNT32_SECTOR_SIZE)

BOOL
PatchBootCode(
    IN      WINNT32_SYSPART_FILESYSTEM  FileSystem,
    IN      TCHAR   Drive,
    IN OUT  PUCHAR  BootCode,
    IN      DWORD   BootCodeSize
    );

#endif // defined(_AMD64_) || defined(_X86_)

//
// ARC/NV-RAM stuff
//

#if defined _IA64_
#define SETUPLDR_FILENAME L"SETUPLDR.EFI"

#elif defined _X86_
#define SETUPLDR_FILENAME L"arcsetup.exe"

#else
#define SETUPLDR_FILENAME L"SETUPLDR"

#endif

BOOL
SetUpNvRam(
    IN HWND ParentWindow
    );

DWORD
DriveLetterToArcPath(
    IN  WCHAR   DriveLetter,
    OUT LPWSTR *ArcPath
    );


//
// Implement a terminalserver-safe GetWindowsDirectory()
//
UINT
MyGetWindowsDirectory(
    LPTSTR  MyBuffer,
    UINT    Size
    );


//
// Upgrade stuff
//

typedef struct _UPGRADE_SUPPORT {
    TCHAR DllPath[MAX_PATH];
    HINSTANCE DllModuleHandle;

    UINT AfterWelcomePageCount;
    LPPROPSHEETPAGE Pages1;

    UINT AfterOptionsPageCount;
    LPPROPSHEETPAGE Pages2;

    UINT BeforeCopyPageCount;
    LPPROPSHEETPAGE Pages3;

    PWINNT32_PLUGIN_INIT_ROUTINE InitializeRoutine;
    PWINNT32_PLUGIN_GETPAGES_ROUTINE GetPagesRoutine;
    PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE WriteParamsRoutine;
    PWINNT32_PLUGIN_CLEANUP_ROUTINE CleanupRoutine;
    PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE OptionalDirsRoutine;

} UPGRADE_SUPPORT, *PUPGRADE_SUPPORT;

extern UPGRADE_SUPPORT UpgradeSupport;

//
// Only check to see if we can upgrade or not.
//
extern BOOL CheckUpgradeOnly;
extern BOOL CheckUpgradeOnlyQ;
extern BOOL UpgradeAdvisorMode;

BOOL
InitializeArcStuff(
    IN HWND Parent
    );

BOOL
ArcInitializeArcStuff(
    IN HWND Parent
    );


//
// Test to see if we're on an ARC based machine

#ifdef UNICODE

#if defined(_X86_)
BOOL
IsArc(
    VOID
    );
#elif defined(_AMD64_)
#define IsArc() FALSE
#elif defined(_IA64_)
#define IsArc() TRUE
#else
#error "No Target Architecture"
#endif

#if defined(EFI_NVRAM_ENABLED)
BOOL
IsEfi(
    VOID
    );
#else
#define IsEfi() FALSE
#endif

VOID
MigrateBootVarData(
    VOID
    );

#else

#define IsArc() FALSE
#define MigrateBootVarData()

#endif

//
// Build the command console.
//
extern BOOL BuildCmdcons;


#ifdef RUN_SYSPARSE
//
// NoSysparse. Set to true if we don't want to run sysparse.exe
// This hack should be removed before RTM.
//
extern BOOL NoSysparse;
extern PROCESS_INFORMATION piSysparse;
#endif

//
// Internal/undoc'ed stuff
//
extern UINT NumberOfLicensedProcessors;
extern BOOL IgnoreExceptionPackages;

//
// Where to get missing files.
//

extern TCHAR AlternateSourcePath[MAX_PATH];


VOID
InternalProcessCmdLineArg(
    IN LPCTSTR Arg
    );

//
// Get Harddisk BPS
//
ULONG
GetHDBps(
    HANDLE hDisk
    );

#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

#define ALIGN(p,val)                                        \
                                                            \
    (PVOID)((((ULONG_PTR)(p) + (val) - 1)) & (~((ULONG_PTR)(val) - 1)))

#if defined(_AMD64_) || defined(_X86_)
//
// PC-98 stuff
//
VOID
SetAutomaticBootselector(
    VOID
    );

VOID
SetAutomaticBootselectorNT(
    VOID
    );
VOID
SetAutomaticBootselector95(
    VOID
    );

//
// read/write disk sectors
//
NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOL    Write
    );

#define NEC_WRITESEC    TRUE
#define NEC_READSEC     FALSE

//
// Get WindowsNT System Position
//
UCHAR
GetSystemPosition(
    PHANDLE phDisk,
    PDISK_GEOMETRY SystemMediaInfo
    );

BOOL
IsNEC98(
    VOID
    );

LONG
CalcHiddenSector(
    IN TCHAR SystemPartitionDriveLetter,
    IN SHORT Bps
    );

#endif

//
//  Registry migration stuff
//

//
// Context structure used for generating inf files (infgen.c)
//
#define INFLINEBUFLEN   512

typedef struct _INFFILEGEN {

    TCHAR FileName[MAX_PATH];
    HANDLE FileHandle;

    BOOL SawBogusOp;

    TCHAR LineBuf[INFLINEBUFLEN];
    unsigned LineBufUsed;

} INFFILEGEN, *PINFFILEGEN;


DWORD
InfStart(
    IN  LPCTSTR       InfName,
    IN  LPCTSTR       Directory,
    OUT PINFFILEGEN   *Context
    );

DWORD
InfEnd(
    IN OUT PINFFILEGEN *Context
    );

DWORD
InfCreateSection(
    IN     LPCTSTR      SectionName,
    IN OUT PINFFILEGEN  *Context
    );

DWORD
InfRecordAddReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR     Subkey,
    IN     LPCTSTR     Value,       OPTIONAL
    IN     DWORD       DataType,
    IN     PVOID       Data,
    IN     DWORD       DataLength,
    IN     BOOL        SetNoClobberFlag
    );

ULONG
DumpRegKeyToInf(
    IN  PINFFILEGEN InfContext,
    IN  HKEY        PredefinedKey,
    IN  LPCTSTR     FullKeyPath,
    IN  BOOL        DumpIfEmpty,
    IN  BOOL        DumpSubKeys,
    IN  BOOL        SetNoClobberFlag,
    IN  BOOL        DumpNonVolatileKey
    );

DWORD
WriteText(
    IN HANDLE FileHandle,
    IN UINT   MessageId,
    ...
    );


//
//  Unsupported driver migration stuff
//


//
//  Structure used to build a list of files associated to and usupported
//  driver that was detected on the NT system to be upgraded.
//
typedef struct _UNSUPORTED_PNP_HARDWARE_ID {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_PNP_HARDWARE_ID *Next;

    //
    //  String that represents the hardware id of a PNP device.
    //
    LPTSTR Id;

    //
    // Service for the device
    //
    LPTSTR Service;

    //
    // GUID for this device, if any
    //
    LPTSTR ClassGuid;

} UNSUPORTED_PNP_HARDWARE_ID, *PUNSUPORTED_PNP_HARDWARE_ID;


typedef struct _UNSUPORTED_DRIVER_FILE_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_FILE_INFO *Next;

    //
    //  Pointer to the file name
    //
    LPTSTR FileName;

    //
    // Pointer to the path relative to %SystemRoot% where the file
    // should be installed.
    //
    LPTSTR TargetDirectory;

} UNSUPORTED_DRIVER_FILE_INFO, *PUNSUPORTED_DRIVER_FILE_INFO;

typedef struct _UNSUPORTED_DRIVER_INSTALL_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_INSTALL_INFO *Next;

    //
    // Pointer to the path relative to %SystemRoot%
    // where the actual inf file is currently installed
    //
    LPTSTR InfRelPath;
    //
    //  Pointer to the actual INF file name
    //
    LPTSTR InfFileName;
    //
    //  Pointer to the original INF file name (optional)
    //
    LPTSTR InfOriginalFileName;
    //
    // Pointer to the path relative to %SystemRoot%
    // where the actual catalog file is currently installed (optional)
    //
    LPTSTR CatalogRelPath;
    //
    //  Pointer to the actual catalog name (optional)
    //
    LPTSTR CatalogFileName;
    //
    //  Pointer to the original catalog name (optional)
    //
    LPTSTR CatalogOriginalFileName;

} UNSUPORTED_DRIVER_INSTALL_INFO, *PUNSUPORTED_DRIVER_INSTALL_INFO;


typedef struct _UNSUPORTED_DRIVER_REGKEY_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_REGKEY_INFO *Next;

    //
    //  A predefined key
    //
    HKEY PredefinedKey;

    //
    //  Path to the key to be migrated, relative to a predefined key.
    //
    LPTSTR KeyPath;

    //
    //  Undicates whether or not volatile keys should be migrated
    //
    BOOL MigrateVolatileKeys;

} UNSUPORTED_DRIVER_REGKEY_INFO, *PUNSUPORTED_DRIVER_REGKEY_INFO;


typedef struct _UNSUPORTED_DRIVER_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_INFO *Next;

    //
    //  A string that identifies the driver to be migrated (such as aic78xx)
    //
    LPTSTR DriverId;

    //
    //  Points to the list of files associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_REGKEY_INFO KeyList;

    //
    //  Points to the list of keys associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_FILE_INFO FileList;

    //
    //  Points to the list of install info associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_INSTALL_INFO InstallList;

    //
    //  Points to the list of hardware ids associated to the unsupported driver
    //
    PUNSUPORTED_PNP_HARDWARE_ID HardwareIdsList;


} UNSUPORTED_DRIVER_INFO, *PUNSUPORTED_DRIVER_INFO;


//
//  Unsupported driver list
//  This list contains the information about the unsupported drivers that needs
//  to be migrated on a clean install or upgrade.
//
// extern PUNSUPORTED_DRIVER_INFO UnsupportedDriverList;


BOOL
BuildUnsupportedDriverList(
    IN  PVOID                    TxtsetupSifHandle,
    OUT PUNSUPORTED_DRIVER_INFO* DriverList
    );

BOOL
SaveUnsupportedDriverInfo(
    IN HWND                    ParentWindow,
    IN LPTSTR                  FileName,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
AddUnsupportedFilesToCopyList(
    IN HWND ParentWindow,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
MigrateUnsupportedNTDrivers(
    IN HWND   ParentWindow,
    IN PVOID  TxtsetupSifHandle
    );


// Error codes and Function to check schema version for NT5 DC Upgrades

#define  DSCHECK_ERR_SUCCESS           0
#define  DSCHECK_ERR_FILE_NOT_FOUND    1
#define  DSCHECK_ERR_FILE_COPY         2
#define  DSCHECK_ERR_VERSION_MISMATCH  3
#define  DSCHECK_ERR_CREATE_DIRECTORY  4

BOOL
ISDC(
    VOID
    );

BOOL
IsNT5DC();

int
CheckSchemaVersionForNT5DCs(
    IN HWND  ParentWnd
    );

//
// Diagnostic/debug functions in debug.c
//

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if ASSERTS_ON

#ifndef MYASSERT

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#endif

#else

#define MYASSERT(x)

#endif


#if defined(_AMD64_) || defined(_X86_)

VOID
ProtectAllModules (
    VOID
    );

#endif


BOOL
WriteHeadlessParameters(
    IN LPCTSTR FileName
    );



//
// Setup Log prototypes in setupapi.dll
//

typedef BOOL(WINAPI * SETUPOPENLOG)(BOOL Erase);
typedef BOOL(WINAPI * SETUPLOGERROR)(PCTSTR MessageString, LogSeverity Severity);
typedef VOID(WINAPI * SETUPCLOSELOG)(VOID);

//
// Default throughput (5 KB/msec)
//
#define DEFAULT_IO_THROUGHPUT   (5 * 1024)

extern DWORD dwThroughPutSrcToDest;
extern DWORD dwThroughPutHDToHD;
void CalcThroughput();

// Should allow 1K for strings for localization
#define MAX_STRING 1024

BOOL
SaveAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
AddCopydirIfExists(
    IN LPTSTR pszPathToCopy,
    IN UINT Flags
    );

BOOL
IsNetConnectivityAvailable (
    VOID
    );

BOOL
ValidatePidEx(LPTSTR PID, BOOL *pbStepup, BOOL *bSelect);


#ifdef PRERELEASE
#define TEST_EXCEPTION 1
#endif

#define SETUP_FAULTH_APPNAME "drw\\faulth.dll"
//#define SETUP_URL     "officewatson"
#define SETUP_URL       "watson.microsoft.com"

#define S_WINNT32LOGFILE                TEXT("WINNT32.LOG")
#define S_DEFAULT_NT_COMPAT_FILENAME    TEXT("UPGRADE.TXT")

#ifdef TEST_EXCEPTION
void DoException( DWORD dwSetupArea);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\wizard.c ===
#include "precomp.h"
#pragma hdrstop

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif


typedef struct
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
}   DLGTEMPLATEEX, FAR *LPDLGTEMPLATEEX;

//
// We'll use this to disable passing through dialog boxes because we're
// unattended.
//
BOOL CancelPending = FALSE;

//
// This indicates that well give the user some detailed data-throughput
// info.
//
BOOL DetailedCopyProgress = FALSE;

//
// This indicates that one may only upgade (I.E. CCP media)
//
BOOL UpgradeOnly = FALSE;

//
// Points to thread that does the machine inspection.
//
HANDLE InspectionThreadHandle;

#if defined(_X86_)
//
// Win9x upgrade report status
//

UINT g_UpgradeReportMode;
#endif

//
// Stuff used for watermarking
//
WNDPROC OldWizardProc;
UINT WatermarkHeaderHeight;
BITMAP_DATA Watermark;
BITMAP_DATA Header;
BITMAP_DATA Header2;
HWND WizardHandle;
HWND BackgroundWnd = NULL;

HWND GetBBhwnd();
BOOL StartStopBB(BOOL bStart);
void BB_SetProgressText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam);
BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow);
void SetBBStep(int iStep);

typedef enum {
    Phase_Unknown = -1,
    Phase_DynamicUpdate = 0,
    Phase_HwCompatDat,
    Phase_UpgradeReport,
    Phase_FileCopy,
    Phase_Reboot,
    Phase_RestOfSetup
} SetupPhases;

typedef struct _SETUPPHASE {
    DWORD   Time;
    BOOL    Clean;
    DWORD   OS;
} SETUPPHASE;

#define ALLOS (VER_PLATFORM_WIN32_WINDOWS | VER_PLATFORM_WIN32_NT)

#define TIME_DYNAMICUPDATE  300
#define TIME_HWCOMPDAT      120
#define TIME_UPGRADEREPORT  600
#define TIME_REBOOT         15
// 13 minnutes for text mode, 37 minutes for GUI mode.
#define TIME_RESTOFSETUP    (13+37)*60

SETUPPHASE SetupPhase[] = {
    { 0,                  TRUE, ALLOS },                         // DynamicUpdate
    { TIME_HWCOMPDAT,     FALSE, VER_PLATFORM_WIN32_WINDOWS }, // HwCompatDat
    { TIME_UPGRADEREPORT, FALSE, VER_PLATFORM_WIN32_WINDOWS }, // UpgradeReport
    {   0,                TRUE,  ALLOS },                      // FileCopy
    { TIME_REBOOT,        TRUE, ALLOS },                       // Reboot
    { TIME_RESTOFSETUP,   TRUE, ALLOS }                       // RestOfSetup
};

void SetTimeEstimates();
DWORD CalcTimeRemaining(UINT Phase);
void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime);
void SetRemainingTime(DWORD TimeInSeconds);
DWORD GetFileCopyEstimate();
DWORD GetHwCompDatEstimate();
DWORD GetUpgradeReportEstimate();
DWORD GetDynamicUpdateEstimate();
DWORD GetRestOfSetupEstimate();

UINT CurrentPhase = Phase_Unknown;
ULONG RemainingTime = 0;
//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontSupertitle,
    DlgFontSubtitle,
    DlgFontStart
} MyDlgFont;

INT_PTR SetNextPhaseWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
INT_PTR
TimeEstimateWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
WelcomeWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
EulaWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
SelectPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
OemPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CdPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef _X86_
INT_PTR
Win9xUpgradeReportPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
DynSetupWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup2WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup3WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup4WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup5WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
RestartWizPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#if 0

INT_PTR
ServerWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#endif

INT_PTR
CompatibilityWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
NTFSConvertWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
OptionsWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
Working1WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#if defined(_AMD64_) || defined(_X86_)
INT_PTR
FloppyWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
CopyingWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CleaningWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
NotDoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
AdjustWatermarkBitmap(
    IN HANDLE hdlg,
    IN HDC    hdc,
    IN OUT PBITMAP_DATA  BitmapData,
    IN BOOL FullPage
    );

//
// Page descriptors. Put this after function declarations so the initializers
// work properly and the compiler doesn't complain.
//
PAGE_CREATE_DATA ProtoPages[] = {

    {
        NULL,NULL,
        IDD_WELCOME,
        {
            WelcomeWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    },
    {
        NULL,NULL,
        IDD_EULA,
        {
            EulaWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_CD,
        {
            CdPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_OEM,
        {
            OemPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_SELECT,
        {
            SelectPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_OPTIONS,
        {
            OptionsWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },

    {
        NULL,NULL,
        IDD_NTFS_CONVERT,
        {
            NTFSConvertWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
#if 0
    {
        NULL,NULL,
        IDD_SRVCOMP,
        {
            ServerWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
#endif
#ifdef _X86_
    {
        NULL,NULL,
        IDD_REPORT_HELP,
        {
            Win9xUpgradeReportPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
#endif

    {
        NULL,NULL,
        IDD_DYNAMICSETUP,
        {
            DynSetupWizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP2,
        {
            DynSetup2WizPage,
            BBSTEP_DYNAMIC_UPDATE
        }
    },
    {
        NULL,NULL,
        IDD_RESTART,
        {
            RestartWizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP3,
        {
            DynSetup3WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP4,
        {
            DynSetup4WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP5,
        {
            DynSetup5WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_EMPTY,
        {
            TimeEstimateWizPage,
            BBSTEP_PREPARING,
            0
        }
    },
    {
        NULL,NULL,
        IDD_EMPTY,
        {
            SetNextPhaseWizPage,
            BBSTEP_PREPARING,
            0
        }
    },
    {
        &UpgradeSupport.Pages1,
        &UpgradeSupport.AfterWelcomePageCount
    },

    {
        &UpgradeSupport.Pages2,
        &UpgradeSupport.AfterOptionsPageCount
    },

    {
        NULL,NULL,
        IDD_WORKING1,
        {
            Working1WizPage,
            BBSTEP_PREPARING
        }
    },


    {
        NULL,NULL,
        IDD_COMPATIBILITY,
        {
            CompatibilityWizPage,
            BBSTEP_PREPARING,
            PSWIZB_NEXT
        }
    },

    {
        &UpgradeSupport.Pages3,
        &UpgradeSupport.BeforeCopyPageCount
    },

#if defined(_AMD64_) || defined(_X86_)
    {
        NULL,NULL,
        IDD_FLOPPY,
        {
            FloppyWizPage,
            BBSTEP_PREPARING
        }
    },
#endif

    {
        NULL,NULL,
        IDD_COPYING,
        {
            CopyingWizPage,
            BBSTEP_PREPARING
        }
    },

    {
        NULL,NULL,
        IDD_DONE,
        {
            DoneWizPage,
            BBSTEP_PREPARING,
            PSWIZB_FINISH,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    },

    {
        NULL,NULL,
        IDD_CLEANING,
        {
            CleaningWizPage,
            BBSTEP_NONE
        }
    },

    {
        NULL,NULL,
        IDD_NOTDONE,
        {
            NotDoneWizPage,
            BBSTEP_NONE,
            PSWIZB_FINISH,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    }
};


//
// LTR/RTL layout
//

typedef DWORD(WINAPI * PSETLAYOUT)(HDC, DWORD);
#define _LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008

PSETLAYOUT g_SetLayout;
DWORD g_OldLayout;



VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont = NULL;
    static HFONT StartFont = NULL;
    HFONT Font;
    LOGFONT LogFont;
    TCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontStart:
        if (!StartFont)
        {
            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0))
            {
                if(GetObject(Font,sizeof(LOGFONT),&LogFont))
                {
                    if(hdc = GetDC(hdlg))
                    {

                        LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 10 / 72);

                        StartFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = StartFont;
        break;

    case DlgFontTitle:

        if(!BigBoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    //
                    // Now we're using the Arial Black font, so we don't need
                    // to make it bold.
                    //
                    // LogFont.lfWeight = FW_BOLD;

                    //
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.
                    //
                    if(!LoadString(hInst,IDS_LARGEFONTNAME,LogFont.lfFaceName,LF_FACESIZE)) {
                        lstrcpy(LogFont.lfFaceName,TEXT("MS Serif"));
                    }

                    if(LoadString(hInst,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
                        FontSize = _tcstoul(FontSizeString,NULL,10);
                    } else {
                        FontSize = 18;
                    }

                    if(hdc = GetDC(hdlg)) {

                        LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontSupertitle:

        if(!BoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    LogFont.lfWeight = FW_BOLD;

                    if(hdc = GetDC(hdlg)) {
                        BoldFont = CreateFontIndirect(&LogFont);
                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    case DlgFontSubtitle:
    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if(Font) {
        SendDlgItemMessage(hdlg,ControlId,WM_SETFONT,(WPARAM)Font,0);
    }
}

VOID
pMoveButtons(
    HWND WizardHandle,
    UINT Id,
    LONG cx,
    LONG cy
    )

/*++

Routine Description:

  pMoveButtons moves a window by a delta, to reposition a control when the
  wizard changes size.

Arguments:

  WizardHandle - Specifies the main wizard window
  Id           - Specifies the child control ID that exists in the main
                 wizard window
  cx           - Specifies the horizontal delta
  cy           - Specifies the vertical delta

Return Value:

  None.

--*/

{
    HWND Button;
    RECT Rect;

    Button = GetDlgItem(WizardHandle,Id);

    if( !Button )
        return;

    GetClientRect( Button, &Rect );
    MapWindowPoints(Button, WizardHandle, (LPPOINT)&Rect,2);

    Rect.left += cx;
    Rect.top += cy;

    SetWindowPos( Button, NULL, Rect.left, Rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW );

    return;

}


BOOL
CALLBACK
pVerifyChildText (
    HWND WizardPage,
    HWND HiddenPage,
    INT Id
    )
{
    TCHAR text1[512];
    TCHAR text2[512];
    HWND hwnd1;
    HWND hwnd2;

    hwnd1 = GetDlgItem (WizardPage, Id);
    hwnd2 = GetDlgItem (HiddenPage, Id);

    if (!hwnd1 && !hwnd2) {
        return TRUE;
    }

    if (!hwnd1 || !hwnd2) {
        return FALSE;
    }

    text1[0] = 0;
    GetWindowText (hwnd1, text1, ARRAYSIZE(text1));

    text2[0] = 0;
    GetWindowText (hwnd2, text2, ARRAYSIZE(text2));

    if (lstrcmp (text1, text2)) {
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
HiddenDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND wizardPage;
    HRSRC dlgResInfo;
    HGLOBAL dlgRes;
    PVOID dlgTemplate;
    INT_PTR result = 0;
    static BOOL recursiveCall;

    switch (uMsg) {

    case WM_INITDIALOG:
        //
        // Verify text in this dialog is the same as the parent. If it is not
        // the same, then the code pages differ because of an OS bug,
        // and we have to force the English page dimensions.
        //

        wizardPage = *((HWND *) lParam);

        if (!recursiveCall) {

            if (!pVerifyChildText (wizardPage, hwndDlg, IDT_SUPERTITLE) ||
                !pVerifyChildText (wizardPage, hwndDlg, IDT_SUBTITLE) ||
                !pVerifyChildText (wizardPage, hwndDlg, IDT_TITLE)
                ) {

                //
                // Load the English resource if possible, then recursively call
                // ourselves to get the correct rect
                //

                __try {
                    //
                    // Find the resource
                    //

                    dlgResInfo = FindResourceEx (
                                    hInst,
                                    RT_DIALOG,
                                    MAKEINTRESOURCE(IDD_WELCOME),
                                    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)
                                    );

                    if (!dlgResInfo) {
                        __leave;
                    }

                    dlgRes = LoadResource (hInst, dlgResInfo);

                    if (!dlgRes) {
                        __leave;
                    }

                    dlgTemplate = LockResource (dlgRes);
                    if (!dlgTemplate) {
                        __leave;
                    }

                    //
                    // Create another hidden dialog (indirectly)
                    //

                    recursiveCall = TRUE;

                    result = DialogBoxIndirectParam (
                                hInst,
                                (LPCDLGTEMPLATE) dlgTemplate,
                                GetParent (hwndDlg),
                                HiddenDlgProc,
                                lParam
                                );

                    recursiveCall = FALSE;
                }
                __finally {
                    MYASSERT (result);
                }

                EndDialog (hwndDlg, result);
                break;
            }
        }

        //
        // If we get here it is because we need to use this dialog's size
        //

        GetClientRect (hwndDlg, (RECT *) lParam);
        EndDialog (hwndDlg, 1);
        break;

    }

    return 0;
}

VOID
pGetTrueClientRect(
    HWND hdlg,
    PRECT rc
    )

/*++

Routine Description:

  pGetTrueClientRect creates a hidden dialog box to retreive the proper
  dimensions of a dialog template. These dimensions are used to drive wizard
  resizing for when the system Wizard font does not match the property sheet
  font.

Arguments:

  hdlg - Specifies the wizard page

  rc - Receives the wizard page rectangle coordinates (window coordinates)

Return Value:

  None.

--*/

{

    HWND WizardHandle;
    static RECT pageRect;
    static BOOL initialized;

    if (initialized) {
        CopyMemory (rc, &pageRect, sizeof (RECT));
        return;
    }

    //
    // Initialize by creating a hidden window
    //

    WizardHandle = GetParent(hdlg);

    // send the wizard page handle to the HiddenDlgProc
    MYASSERT (sizeof (HWND *) <= sizeof (RECT));
    *((HWND *) rc) = hdlg;

    if (!DialogBoxParam (
            hInst,
            MAKEINTRESOURCE(IDD_WELCOME),
            WizardHandle,
            HiddenDlgProc,
            (LPARAM) rc
            )){

        //
        // On failure, do not alter the size of the page -- use current
        // rectangle for resizing
        //

        GetClientRect( hdlg, rc );
    }

    CopyMemory (&pageRect, rc, sizeof (RECT));
    initialized = TRUE;

    return;

}


VOID
ResizeWindowForFont(
    HWND hdlg
    )

/*++

Routine Description:

  ResizeWindowForFont takes a wizard page and makes sure that the page and
  its parent is sized properly.

Arguments:

  hdlg - Specifies the wizard page (a window within the main wizard)

Return Value:

  None.

--*/

{

    RECT WizardRect;
    RECT PageRect;
    RECT NewWizardRect;
    RECT NewWizardClientRect;
    RECT WizardClientRect;
    RECT BorderRect;
    RECT NewPageRect;
    RECT Sep;
    HWND Seperator, WizardHandle;
    LONG MarginX, MarginY, ButtonSpace, LineThickness;
    LONG x, y, cx, cy;
    static BOOL ParentResized = FALSE;

    WizardHandle = GetParent (hdlg);

    Seperator = GetDlgItem(WizardHandle,0x3026);
    if(!Seperator) {
        return;
    }

    //
    // Save original page dimensions, compute new page width/height
    //

    GetWindowRect (hdlg, &PageRect);
    pGetTrueClientRect (hdlg, &NewPageRect);

    //
    // Move page
    //

    SetWindowPos (
        hdlg,
        NULL,
        0,
        0,
        NewPageRect.right,
        NewPageRect.bottom,
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW
        );

    //
    // Has the parent already been resized? If so, we're done.
    //

    if (ParentResized) {
        return;
    }

    //
    // Is this wizard hidden? It might be width or height of zero.
    // Delay parent resizing until the next page.
    //

    GetWindowRect (WizardHandle, &WizardRect);
    if (((WizardRect.right - WizardRect.left) < 1) ||
        ((WizardRect.bottom - WizardRect.top) < 1)
        ) {
        return;
    }

    ParentResized = TRUE;

    //
    // Adjust width/height into coordinates. Resize the main wizard if we haven't done so yet.
    //

    MapWindowPoints (hdlg, NULL, (LPPOINT)&NewPageRect, 2);

    //
    // Get window rects (in window coordinates) of:
    //
    //  - the whole wizard
    //  - the wizard's client area
    //  - the page rectangle
    //  - the separator bar rectangle

    GetWindowRect (WizardHandle, &WizardRect);
    GetClientRect (WizardHandle, &WizardClientRect);
    MapWindowPoints (WizardHandle, NULL, (LPPOINT)&WizardClientRect, 2);
    GetWindowRect (Seperator, &Sep);

    //
    // Calculate various margins, thickness and borders
    //

    MarginX = WizardClientRect.right - PageRect.right;
    MarginY = Sep.top - PageRect.bottom;

    ButtonSpace = WizardClientRect.bottom - Sep.bottom;
    LineThickness = Sep.bottom - Sep.top;
    BorderRect.right = (WizardRect.right - WizardClientRect.right);
    BorderRect.bottom = (WizardRect.bottom - WizardClientRect.bottom);
    BorderRect.left = (WizardClientRect.left - WizardRect.left);
    BorderRect.top = (WizardClientRect.top - WizardRect.top);

    //
    // Find the new bottom right corner
    //

    x = (NewPageRect.right + MarginX + BorderRect.right);
    y = (NewPageRect.bottom + MarginY + ButtonSpace + LineThickness + BorderRect.bottom);

    //
    // Compute the new window coordinates
    //

    NewWizardRect.top = WizardRect.top;
    NewWizardRect.left =  WizardRect.left;
    NewWizardRect.right = x;
    NewWizardRect.bottom = y;

    //
    // Manually calculate client coordinates
    //

    NewWizardClientRect.left = NewWizardRect.left + BorderRect.left;
    NewWizardClientRect.right = NewWizardRect.right - BorderRect.right;
    NewWizardClientRect.top = NewWizardRect.top + BorderRect.top;
    NewWizardClientRect.bottom = NewWizardRect.bottom - BorderRect.bottom;

    //
    // Calculate new seperator position
    //

    x = Sep.left - WizardClientRect.left;
    y = NewWizardClientRect.bottom - NewWizardClientRect.top;
    y -= ButtonSpace - LineThickness;
    cx = (NewWizardClientRect.right - NewWizardClientRect.left);
    cx -= 2*(Sep.left - WizardClientRect.left);
    cy = Sep.bottom-Sep.top;

    //
    // Move/resize the seperator
    //

    SetWindowPos( Seperator, NULL, x, y, cx, cy, SWP_NOZORDER | SWP_NOREDRAW );

    //
    // Compute the new button coordinates
    //

    cx = NewWizardRect.right - WizardRect.right;
    cy = NewWizardRect.bottom - WizardRect.bottom;

    pMoveButtons( WizardHandle, 0x3023, cx, cy );
    pMoveButtons( WizardHandle, 0x3024, cx, cy );
    pMoveButtons( WizardHandle, 0x3025, cx, cy );
    pMoveButtons( WizardHandle, IDCANCEL, cx, cy );
    pMoveButtons( WizardHandle, IDHELP, cx, cy );

    //
    // Resize the wizard window
    //

    cx = (NewWizardRect.right - NewWizardRect.left);
    cy = (NewWizardRect.bottom-NewWizardRect.top);

    SetWindowPos( WizardHandle, NULL, 0, 0, cx, cy, SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);


    return;

}

VOID
CenterWindowRelativeToWindow(
    HWND hwndtocenter,
    HWND hwndcenteron
    )

/*++

Routine Description:

    Centers a dialog on the desktop.

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;
    UINT uiHeight = 0;

    GetWindowRect(GetDesktopWindow(), &rcWindow);
    uiHeight = rcWindow.bottom - rcWindow.top;

    if (hwndcenteron == NULL)
        Parent = GetDesktopWindow();
    else
        Parent = hwndcenteron;

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwndtocenter,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    if (uiHeight > 480)
        x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    else
    {
        RECT rcParentWindow;

        GetWindowRect(Parent, &rcParentWindow);
        x = point.x + rcParentWindow.right - rcParentWindow.left + 1 - w;
    }
    MoveWindow(hwndtocenter,x,y,w,h,FALSE);
}


int
CALLBACK
Winnt32SheetCallback(
    IN HWND   DialogHandle,
    IN UINT   Message,
    IN LPARAM lParam
    )
{
    HMENU menu;
    DLGTEMPLATE *DlgTemplate;
    LPDLGTEMPLATEEX pDlgTemplateEx;

    switch(Message) {

    case PSCB_PRECREATE:
        //
        // Make sure we get into the foreground.
        //
        DlgTemplate = (DLGTEMPLATE *)lParam;
        pDlgTemplateEx = (LPDLGTEMPLATEEX)DlgTemplate;
        if (pDlgTemplateEx->wSignature == 0xFFFF) {
            pDlgTemplateEx->dwStyle &= ~DS_CONTEXTHELP;
            pDlgTemplateEx->dwStyle |= DS_SETFOREGROUND;

        } else {

            DlgTemplate->style &= ~DS_CONTEXTHELP;
            DlgTemplate->style |= DS_SETFOREGROUND;
        }


        break;



    case PSCB_INITIALIZED:
        //
        // Load the watermark bitmap and override the dialog procedure for the wizard.
        //

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_WELCOME),
            &Watermark.Palette,
            &Watermark.PaletteColorCount,
            &Watermark.BitmapInfoHeader
            );

        Watermark.BitmapBits = (LPBYTE)Watermark.BitmapInfoHeader
                            + Watermark.BitmapInfoHeader->biSize + (Watermark.PaletteColorCount * sizeof(RGBQUAD));
        Watermark.Adjusted = FALSE;

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_HEADER),
            &Header.Palette,
            &Header.PaletteColorCount,
            &Header.BitmapInfoHeader
            );

        Header.BitmapBits = (LPBYTE)Header.BitmapInfoHeader
                            + Header.BitmapInfoHeader->biSize + (Header.PaletteColorCount * sizeof(RGBQUAD));
        Header.Adjusted = FALSE;

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_HEADER2),
            &Header2.Palette,
            &Header2.PaletteColorCount,
            &Header2.BitmapInfoHeader
            );

        Header2.BitmapBits = (LPBYTE)Header2.BitmapInfoHeader
                            + Header2.BitmapInfoHeader->biSize + (Header2.PaletteColorCount * sizeof(RGBQUAD));
        Header2.Adjusted = FALSE;

        // innitialize WHH so we know that it is invalid, and will not draw the separator
        // until WHH is non-zero
        WatermarkHeaderHeight = 0;

        //
        // Get rid of close item on system menu.
        // Also need to process WM_SYSCOMMAND to eliminate use
        // of Alt+F4.
        //
        if(menu = GetSystemMenu(DialogHandle,FALSE)) {
            EnableMenuItem(menu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
        }

        OldWizardProc = (WNDPROC)SetWindowLongPtr(DialogHandle,DWLP_DLGPROC,(LONG_PTR)WizardDlgProc);
        break;
    }

    return(0);
}


VOID
pSetDisplayOrientation (
    IN      HDC hdc
    )

/*++

Routine Description:

  pSetDisplayOrientation sets the OS to treat BitBlts in left-to-right and
  top-to-bottom and no bitmap flip orientation. We expect our bitmaps to be
  localized to the proper orientation.

  This function loads the SetLayout API dynamically, so that winnt32 can run
  on very old OSes (such as Win95 gold). The resources are not cleaned up,
  because the LoadLibrary is to gdi32.dll, which is held until the process
  dies anyhow.

Arguments:

  hdc - Specifies the device context that will be used for the BitBlt (or
        equivalent) operation.

Return Value:

  None.

Remarks:

  The current orientation is saved to g_OldLayout, so don't call this function
  again until pRestoreDisplayOrientation is called.

--*/

{
    DWORD flags;
    HINSTANCE lib;
    static BOOL initialized;

    if (!initialized) {
        lib = LoadLibrary (TEXT("gdi32.dll"));
        MYASSERT (lib);

        if (lib) {
            (FARPROC) g_SetLayout = GetProcAddress (lib, "SetLayout");
        }

        initialized = TRUE;
    }

    if (g_SetLayout) {
        g_OldLayout = g_SetLayout (hdc, _LAYOUT_BITMAPORIENTATIONPRESERVED);
    }
}


VOID
pRestoreDisplayOrientation (
    IN      HDC hdc
    )

/*++

Routine Description:

  pRestoreDisplayOrientation returns the render layout to whatever the OS
  wants it to be.

Arguments:

  hdc - Specifies the device context that was passed to
        pSetDisplayOrientation.

Return Value:

  None.

--*/

{
    if (g_SetLayout) {
        g_SetLayout (hdc, g_OldLayout);
    }
}


BOOL
PaintWatermark(
    IN HWND hdlg,
    IN HDC  DialogDC,
    IN UINT XOffset,
    IN UINT YOffset,
    IN UINT FullPage
    )
{
    PBITMAP_DATA BitmapData;
    HPALETTE OldPalette;
    RECT rect;
    int Height,Width;

    //
    // Don't show watermark on NT3.51. It looks awful.
    // Returning FALSE causes the system to do its standard
    // background erasing.
    //
#if 0
    if(OsVersion.dwMajorVersion < 4) {
        return(FALSE);
    }
#endif

    if (FullPage & WIZPAGE_FULL_PAGE_WATERMARK)
    {
        BitmapData = &Watermark;
    }
    else if (FullPage & WIZPAGE_NEW_HEADER)
    {
        BitmapData = &Header2;
    }
    else
    {
        BitmapData = &Header;
    }


    //
    // The correct palette is already realized in foreground from
    // WM_xxxPALETTExxx processing in dialog procs.
    //
#if 0 // fix palette problem
    OldPalette = SelectPalette(DialogDC,BitmapData->Palette,TRUE);
#endif

    Width = BitmapData->BitmapInfoHeader->biWidth - (2*XOffset);


    //
    // For full-page watermarks, the height is the height of the bitmap.
    // For header watermarks, the height is the header area's height.
    // Also account for the y offset within the source bitmap.
    //
    Height = (FullPage ? BitmapData->BitmapInfoHeader->biHeight : WatermarkHeaderHeight) - YOffset;

    //
    // Set the display orientation to left-to-right
    //

    pSetDisplayOrientation (DialogDC);

    //
    // Display the bitmap
    //

    SetDIBitsToDevice(
        DialogDC,
        0,                                          // top
        0,                                          // left
        Width,                                      // width
        Height,                                     // height
        XOffset,                                    // X origin (lower left)
        0,                                          // Y origin (lower left)
        0,                                          // start scan line
        BitmapData->BitmapInfoHeader->biHeight,     // # of scan lines
        BitmapData->BitmapBits,                     // bitmap image
        (BITMAPINFO *)BitmapData->BitmapInfoHeader, // bitmap header
        DIB_RGB_COLORS                              // bitmap type
        );

    //
    // Return to normal display orientation
    //

    pRestoreDisplayOrientation (DialogDC);

    //
    // Fill in area below the watermark if needed. We do this by removing the area
    // we filled with watermark from the clipping area, and passing a return code
    // back from WM_ERASEBKGND indicating that we didn't erase the background.
    // The dialog manager will do its default thing, which is to fill the background
    // in the correct color, but won't touch what we just painted.
    //
    GetClientRect (hdlg, &rect);

    if((Height < rect.bottom) || (Width+(int)XOffset < rect.right)) {
        ExcludeClipRect(DialogDC,0,0,Width+XOffset,Height);
        return(FALSE);
    }

    return(TRUE);
}


VOID
AdjustWatermarkBitmap(
    IN HANDLE hdlg,
    IN HDC    hdc,
    IN OUT PBITMAP_DATA  BitmapData,
    IN BOOL FullPage
    )
{
    RECT rect;
    RECT rect2;
    HWND Separator;
    PVOID Bits;
    HBITMAP hDib;
    HBITMAP hOldBitmap;
    BITMAPINFO *BitmapInfo;
    HDC MemDC;
    int i;
    BOOL b;
    INT Scale;

    if(BitmapData->Adjusted) {
        return;
    }

    //
    // Determine whether the bitmap needs to be stretched.
    // If the width is within 10 pixels and the height is within 5
    // then we don't worry about stretching.
    //
    // Note that 0x3026 is the identifier of the bottom divider in
    // the template. This is kind of slimy but it works.
    //
    Separator = GetDlgItem(hdlg,0x3026);
    if(!Separator) {
        goto c0;
    }

    // NOTE: The bitmap resoures is about the size of the dialog.
    // That is the only reason why the below GetClientRect makes sence.
    // This should be changed to have only the relevant part of the bitmap.
    // Or we have to find something in the case where a none DBCS setup runs
    // on a DBCS system. Here the wizard page are sized incorrect. They are wider
    // then needed and smaller (adjusted when adding the pages).
    GetClientRect(Separator,&rect2);
    MapWindowPoints(Separator,hdlg,(LPPOINT)&rect2,2);
    GetClientRect(hdlg,&rect);

    b = TRUE;
    i = rect.right - BitmapData->BitmapInfoHeader->biWidth;
    if((i < -5) || (i > 5)) {
        b = FALSE;
    }
    i = rect2.top - BitmapData->BitmapInfoHeader->biHeight;
    if((i < -3) || (i > 0)) {
        b = FALSE;
    }

    if(b) {
        goto c0;
    }

    //
    // Create a copy of the existing bitmap's header structure.
    // We then modify the width and height and leave everything else alone.
    //
    BitmapInfo = MALLOC(BitmapData->BitmapInfoHeader->biSize + (BitmapData->PaletteColorCount * sizeof(RGBQUAD)));
    if(!BitmapInfo) {
        goto c0;
    }

    CopyMemory(
        BitmapInfo,
        BitmapData->BitmapInfoHeader,
        BitmapData->BitmapInfoHeader->biSize + (BitmapData->PaletteColorCount * sizeof(RGBQUAD))
        );

    if (!FullPage) {
        Scale = (rect.right + 1) * 100 / BitmapInfo->bmiHeader.biWidth;
        rect2.top = BitmapInfo->bmiHeader.biHeight * Scale / 100;
    }

    BitmapInfo->bmiHeader.biHeight = rect2.top;
    BitmapInfo->bmiHeader.biWidth = rect.right + 1;

    hDib = CreateDIBSection(NULL,BitmapInfo,DIB_RGB_COLORS,&Bits,NULL,0);
    if(!hDib) {
        goto c1;
    }

    //
    // Create a "template" memory DC and select the DIB we created
    // into it. Passing NULL to CreateCompatibleDC creates a DC into which
    // any format bitmap can be selected. We don't want to use the dialog's
    // DC because if the pixel depth of the watermark bitmap differs from
    // the screen, we wouldn't be able to select the dib into the mem dc.
    //
    MemDC = CreateCompatibleDC(NULL);
    if(!MemDC) {
        goto c2;
    }

    hOldBitmap = SelectObject(MemDC,hDib);
    if(!hOldBitmap) {
        goto c3;
    }

    //
    // Do the stretch operation from the source bitmap onto
    // the dib.
    //
    SetStretchBltMode(MemDC,COLORONCOLOR);
    i = StretchDIBits(
            MemDC,
            0,0,
            rect.right+1,
            rect2.top,
            0,0,
            BitmapData->BitmapInfoHeader->biWidth,
            BitmapData->BitmapInfoHeader->biHeight,
            BitmapData->BitmapBits,
            (BITMAPINFO *)BitmapData->BitmapInfoHeader,
            DIB_RGB_COLORS,
            SRCCOPY
            );

    if(i == GDI_ERROR) {
        goto c4;
    }

    //
    // Got everything we need, set up pointers to use new bitmap data.
    //
    BitmapData->BitmapBits = Bits;
    BitmapData->BitmapInfoHeader = (BITMAPINFOHEADER *)BitmapInfo;

    b = TRUE;

c4:
    SelectObject(MemDC,hOldBitmap);
c3:
    DeleteDC(MemDC);
c2:
    if(!b) {
        DeleteObject(hDib);
    }
c1:
    if(!b) {
        FREE(BitmapInfo);
    }
c0:
    BitmapData->Adjusted = TRUE;

    if (!FullPage){
    WatermarkHeaderHeight = BitmapData->BitmapInfoHeader->biHeight;
    }
    return;
}

// NOTE: Need to add this, since it is only defined for _WIN32_IE >= 0x0400
// And if we do that, the propertysheet structure changes, which we cannot do
// or the upgrade DLLs need to change too. And I don't know what other side
// effects that will have.
// So I copied this define from commctrl.h
#define PBM_SETBARCOLOR         (WM_USER+9)             // lParam = bar color


BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    HWND CurrentPage;
    PPAGE_RUNTIME_DATA WizPage;
    static RECT rect;
    static BOOL Visible = TRUE;
    static BOOL First = TRUE;       // used to keep bitmap from being painted twice
    static DWORD MsecPerProcessTick;
    static DWORD PreviousRemainingTime = 0;
    static DWORD RemainungTimeMsecInThisPhase = 0;
    static UINT  StepSize;

    switch(msg) {
    case WM_CHAR:
        if (wParam == VK_ESCAPE)
        {
            // Make this a Cancel button message, so that the wizard can do its work.
            b = (BOOL)CallWindowProc(OldWizardProc,hdlg,WM_COMMAND,IDCANCEL,0);
        }
        else {
        b = FALSE;
        }
        break;

#if 0 // fix palette problem
    case WM_PALETTECHANGED:
        //
        // If this is our window we need to avoid selecting and realizing
        // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
        // and WM_PALETTECHANGED.
        //
        if((HWND)wParam == hdlg) {
            return(FALSE);
        }
        //
        // FALL THROUGH
        //
    case WM_QUERYNEWPALETTE:
        {
            HDC hdc;
            HPALETTE pal;

            hdc = GetDC(hdlg);

            if((CurrentPage = PropSheet_GetCurrentPageHwnd(hdlg))
               &&  (WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(CurrentPage,DWLP_USER))
               && WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
                pal = SelectPalette(hdc,Watermark.Palette,(msg == WM_PALETTECHANGED));
            } else
            {
                if (WizPage->CommonData.Flags & WIZPAGE_NEW_HEADER)
                    pal = SelectPalette(hdc,Header2.Palette,(msg == WM_PALETTECHANGED));
                else
                    pal = SelectPalette(hdc,Header.Palette,(msg == WM_PALETTECHANGED));
            }
            RealizePalette(hdc);
            InvalidateRect(hdlg,NULL,TRUE);
            if(pal) {
                SelectPalette(hdc,pal,TRUE);
            }
            ReleaseDC(hdlg,hdc);
        }
        return(TRUE);
#endif
        case WM_ERASEBKGND:
        {
            if((CurrentPage = PropSheet_GetCurrentPageHwnd(hdlg))
            &&  (WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(CurrentPage,DWLP_USER))) {

                if(WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Watermark, TRUE);
                }
                else if (WizPage->CommonData.Flags & WIZPAGE_NEW_HEADER)
                {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Header2, FALSE);
                }
                else
                {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Header, FALSE);
                }
                b = PaintWatermark(
                        hdlg,
                        (HDC)wParam,
                        0,0,
                        WizPage->CommonData.Flags
                        );

            } else {
                b = FALSE;
            }
        }
        break;

        // Set the progress text
        // Indicates what setup is doing.
    case WMX_SETPROGRESSTEXT:
        BB_SetProgressText((PTSTR)lParam);
        b = TRUE;
        break;

    case WMX_BB_SETINFOTEXT:
        BB_SetInfoText((PTSTR)lParam);
        b = TRUE;
        break;

        // The next messages are private progess messages, which get translated to the
        // Windows progress messages, Could not use the windows messages direct, because
        // for some reason this get send by the wizard too and would confuse the
        // progress on the billboard.
    case WMX_PBM_SETRANGE:
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETRANGE, wParam, lParam));

            StepSize = 10; // default for StepIt if SetStep is not called.

            RemainingTime = CalcTimeRemaining(CurrentPhase); // In seconds
            SetRemainingTime(RemainingTime);

            //
            // Time per tick is in milli seconds
            // make sure we do not divide by 0 (NTBUG9: 381151)
            //
            if (HIWORD(lParam) > LOWORD(lParam)) {
                MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(HIWORD(lParam)-LOWORD(lParam)) ) + 1;
            }
            RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
            PreviousRemainingTime = RemainungTimeMsecInThisPhase;
            b= TRUE;
            break;
    case WMX_PBM_SETPOS:
            if (wParam != 0)
            {
                DWORD Delta = (MsecPerProcessTick * (DWORD)wParam);
                DWORD TimeInPhase = (SetupPhase[CurrentPhase].Time * 1000);
                // position on progress bar changes to wParam ticks.
                if (Delta > TimeInPhase)
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = TimeInPhase - Delta;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETPOS, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_DELTAPOS:
            if (wParam != 0)
            {
                // position on progress bar changes by wParam ticks.
                DWORD Delta = (MsecPerProcessTick * (DWORD)wParam);
                if (RemainungTimeMsecInThisPhase > Delta)
                {
                    RemainungTimeMsecInThisPhase -= Delta;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_DELTAPOS, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_SETSTEP:
            StepSize = (UINT)wParam;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETSTEP, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_STEPIT:
            // position on progress bar changes by StepSize ticks.
            {
                DWORD Delta = (MsecPerProcessTick * StepSize);
                if (RemainungTimeMsecInThisPhase > Delta)
                {
                    RemainungTimeMsecInThisPhase -= Delta;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
            }
            UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);

            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_STEPIT, wParam, lParam));
            b= TRUE;
            break;

    case WMX_PBM_SETBARCOLOR:
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETBARCOLOR, wParam, lParam));
            b= TRUE;
            break;

            // Enabled, disable, show, hide the progress gauge on the billboard
            // wParam should be SW_SHOW or SW_HIDE
    case WMX_BBPROGRESSGAUGE:
        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ShowProgressGaugeWnd((UINT)wParam));
        b= TRUE;
        break;

        // Advance the setup phase.
    case WMX_BB_ADVANCE_SETUPPHASE:
        if (CurrentPhase < Phase_RestOfSetup)
        {
            CurrentPhase++;
        }
        SetRemainingTime(CalcTimeRemaining(CurrentPhase));
        b = TRUE;
        break;

        // Start, stop the billboard text.
        // This start, stops the billboard text and shows, hides the wizard pages
    case WMX_BBTEXT:
        if (hinstBB)
        {

            if (wParam != 0)
            {
                if (Visible)
                {
                    // Get the current position of the wizard
                    // We restore this position when we need to show it.
                    GetWindowRect(hdlg, &rect);

                    if (!SetWindowPos(hdlg,
                                        GetBBhwnd(),
                                        0,0,0,0,
                                        SWP_NOZORDER))
                    {
                        DebugLog(Winnt32LogWarning,
                                 TEXT("Warning: Wizard, SetWindowPos to 0,0,0,0 failed with GetLastError=%d"),
                                 0,
                                 GetLastError());
                    }

                    SetActiveWindow(GetBBhwnd());

                    Visible = FALSE;
                }
            }
            else
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }

            if (!StartStopBB((wParam != 0)))
            {
                if (!Visible)
                {
                    DebugLog(Winnt32LogWarning,
                             TEXT("Warning: Could not start the billboard text, make Wizard visible"),
                             0);
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }
        }
        else
        {
            if (!Visible)
            {
                SetWindowPos(hdlg,
                    HWND_TOP,
                    rect.left,
                    rect.top,
                    rect.right-rect.left,
                    rect.bottom-rect.top,
                    SWP_SHOWWINDOW);
            }
            Visible = TRUE;
        }
        return TRUE;

    case WM_SYSCOMMAND:
        if (!ISNT()) {
            switch (wParam & 0xFFF0) {
            case SC_MINIMIZE:
                ShowWindow (WizardHandle, SW_HIDE);
                PostMessage (BackgroundWnd, msg, wParam, lParam);
                return 0;

            case SC_RESTORE:
                ShowWindow (WizardHandle, SW_SHOW);
                return 0;
            }
        }

        b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;

    case WMX_ACTIVATEPAGE:
        if (!First) {
            InvalidateRect(hdlg,NULL,TRUE);
        } else {
            First = FALSE;
        }

        b = TRUE;
        break;

    case WM_ACTIVATE:
            // If someone wants to active (set the focus to our hiden window) don't
            if ((LOWORD(wParam)== WA_ACTIVE) || (LOWORD(wParam)== WA_CLICKACTIVE))
            {
                if (!Visible)
                {
                    InvalidateRect(GetBBhwnd(),NULL, TRUE);
                    return 0;
                }
            }
            b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;

    default:
        b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;
    }

    return(b);
}


//
// This DlgProc gets called for all wizard pages.  It may then call a DlgProc
// for the specific page we're on.
//
INT_PTR
WizardCommonDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LONG NextPageOverrideId=0;
    static UINT AdvanceDirection = 0;
    PPAGE_RUNTIME_DATA WizPage;
    NMHDR *Notify;
    BOOL b;
    int i;
    RECT rc1,rc2;
    static BOOL PreviouslyCancelled = FALSE;
    static BOOL center = TRUE;

    WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // lParam points at the PROPSHEETPAGE used for this page.
        //
        WizPage = (PPAGE_RUNTIME_DATA)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)WizPage);

#if (IDT_TITLE != ID_TITLE_TEXT) || (IDT_SUBTITLE != ID_SUBTITLE_TEXT)
#error Title and Subtitle text control IDs are out of sync!
#endif

        //
        // Set large font for the title string in the dialog.
        // Set bold font for subtitle in the dialog.
        //
        SetDialogFont(hdlg,IDT_TITLE,DlgFontTitle);
        SetDialogFont(hdlg,IDT_SUBTITLE,DlgFontSubtitle);
        SetDialogFont(hdlg,IDT_SUPERTITLE,DlgFontSupertitle);
        break;

    case WM_ERASEBKGND:

        GetClientRect(GetParent(hdlg),&rc1);
        MapWindowPoints(GetParent(hdlg),NULL,(POINT *)&rc1,2);
        GetClientRect(hdlg,&rc2);
        MapWindowPoints(hdlg,NULL,(POINT *)&rc2,2);

        b = PaintWatermark(
                hdlg,
                (HDC)wParam,
                rc2.left-rc1.left,
                rc2.top-rc1.top,
                WizPage->CommonData.Flags
                );

        return(b);

    case WM_CTLCOLORSTATIC:
        //
        // We want to let text that is over the background bitmap paint
        // transparently. Other text should not be painted transparently,
        // because there are static text fields that we update to indicate
        // progress, and if it's drawn transparently we end up with text
        // piling up on top of other text, which is messy and unreadable.
        //
        if(WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
            b = TRUE;
        } else {
            GetWindowRect((HWND)lParam,&rc1);
            ScreenToClient(hdlg,(POINT *)&rc1);
            b = (rc1.top < (LONG)WatermarkHeaderHeight);
        }

        // B320610: In some languages the background on the icon on the EULA page is
        // not drawn correct. If we exclude the icon from here, everythign is fine.
        if(b && (GetDlgCtrlID((HWND) lParam) != (int)IDC_DIALOG_ICON)) {
            SetBkMode((HDC)wParam,TRANSPARENT);
            SetBkColor((HDC)wParam,GetSysColor(COLOR_3DFACE));
            return((BOOL)PtrToUlong(GetStockObject(HOLLOW_BRUSH)));
        }
        else {
            return(0);
        }

    case WM_NOTIFY:

        Notify = (NMHDR *)lParam;
        switch(Notify->code) {

        case PSN_QUERYCANCEL:
            //
            // We want to ask the user whether he's sure he wants to cancel.
            //
            // If there's presently a file copy error being displayed, then
            // in general the user can't get to the cancel button on the
            // wizard, since the wizard is used as the parent/owner for the
            // error dialog. So we should be guaranteed to be able to grab the
            // UI mutex without contention.
            //
            // But, there could be a race condition. If the user hits
            // the cancel button on the wizard just as a copy error occurrs,
            // then the copy thread could get there first and grab the
            // ui mutex. This would cause us to block here waiting for the user
            // to dismiss the file error dialog -- but the file error dialog
            // wants to use the wizard as its parent/owner, and blammo,
            // we have a deadlock.
            //
            // To get around this, we use a 0 timeout on the wait for
            // the ui mutex. We either get ownership of the mutex or
            // we know that there's already an error dialog up already.
            // In the latter case we just ignore the cancel request.
            //
            // If a file copy error occurs then the error path code simulates
            // a press of the cancel button. In that case when we get here the
            // Cancelled flag has already been set, no no need for additional
            // confirmation now.
            //

            AdvanceDirection = 0;
            if(Cancelled) {
                i = IDYES;
            } else {
                i = WaitForSingleObject(UiMutex,0);
                if((i == WAIT_OBJECT_0) && !Cancelled) {
                    BOOL bCancel = TRUE;
                    BOOL bHandled;
                    //
                    // Got the ui mutex, it's safe to diaplay ui.  But first,
                    // signal not to pass through dialog boxes anymore just
                    // because we're unattended (e.g. the finish dialog).
                    //
                    // Ask the page first if it wants to treat this cancel message
                    //
                    bHandled = (BOOL) CallWindowProc (
                                        (WNDPROC)WizPage->CommonData.DialogProcedure,
                                        hdlg,
                                        WMX_QUERYCANCEL,
                                        0,
                                        (LPARAM)&bCancel
                                        );
                    if (!bHandled || bCancel) {
                        CancelPending = TRUE;
                        if( CheckUpgradeOnly ) {
                            //
                            // If we're running the upgrade checker, just
                            // cancel.
                            //
                            i = IDYES;
                        } else {
                            i = MessageBoxFromMessage(
                                    hdlg,
                                    MSG_SURE_EXIT,
                                    FALSE,
                                    AppTitleStringId,
                                    MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2
                                    );
                        }


                        if(i == IDYES) {
                            Cancelled = TRUE;
                        }
                        CancelPending = FALSE;
                    }
                    ReleaseMutex(UiMutex);
                } else {
                    //
                    // Can't get ui mutex or user already cancelled,
                    // ignore the cancel request.
                    //
                    i = IDNO;
                }
            }

            //
            // Set DWLP_MSGRESULT to TRUE to prevent the cancel operation.
            // If we're going to allow the cancel operation, don't actually
            // do it here, but instead jump to our special clean-up/cancel
            // page, which does some work before actually exiting.
            //
            // Note: we need to avoid jumping to the cleanup page more than
            // once, which can happen if the user cancels on a page with a
            // worker thread. When the user cancels, we run through this code,
            // which sets the Cancelled flag and jumps to the cleanup page.
            // Some time later the worker thread, which is still hanging around,
            // posts a message to its page when it's done. The page sees the
            // Cancelled flag set and turns around and posts a cancel message,
            // which puts us here again. See WMX_INSPECTRESULT in the
            // Working1WizPage dialog proc.
            //
            if((i == IDYES) && !PreviouslyCancelled) {
                PreviouslyCancelled = TRUE;
                PropSheet_SetCurSelByID(GetParent(hdlg),IDD_CLEANING);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
            return(TRUE);

        case PSN_SETACTIVE:
/*
            //
            // Add separator at top of page if not there already.
            // Can't do this at WM_INITDIALOG time because positions aren't
            // set up properly yet and the mapping fails.
            //
            if(!(WizPage->CommonData.Flags & WIZPAGE_SEPARATOR_CREATED)) {


        if (WatermarkHeaderHeight != 0){
            GetClientRect(hdlg,&rc1);

                    MapWindowPoints(hdlg,GetParent(hdlg),(POINT *)&rc1,2);

                    CreateWindowEx(
            WS_EX_STATICEDGE | WS_EX_NOPARENTNOTIFY,
            TEXT("Static"),
            TEXT("HeaderSeparator"),
            WS_CHILD | WS_VISIBLE | ((OsVersion.dwMajorVersion < 4) ? SS_BLACKRECT : SS_SUNKEN),
            0,
            WatermarkHeaderHeight - rc1.top,
            rc1.right-rc1.left,2,
            hdlg,
            (HMENU)IDC_HEADER_BOTTOM,
            hInst,
            0
            );

            WizPage->CommonData.Flags |= WIZPAGE_SEPARATOR_CREATED;

//      } else {
//          PostMessage(GetParent(hdlg),PSN_SETACTIVE,wParam,lParam);
        }
            }
*/
            //
            // Scale windows to proper size, then set up buttons and ask real
            // dialog whether it wants to be activated.
            //
            ResizeWindowForFont (hdlg);

            if (center) {
                CenterWindowRelativeToWindow (GetParent (hdlg), GetBBhwnd());
                center = FALSE;
            }

            if(WizPage->CommonData.Buttons != (DWORD)(-1)) {
                PropSheet_SetWizButtons(GetParent(hdlg),WizPage->CommonData.Buttons);
            }
            SetWindowLongPtr(
                hdlg,
                DWLP_MSGRESULT,
                CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,WMX_ACTIVATEPAGE,TRUE,AdvanceDirection) ? 0 : -1
                );
            //
            // update billboard step
            //
            if (WizPage->CommonData.BillboardStep) {
                SetBBStep (WizPage->CommonData.BillboardStep);
            }
            PostMessage(GetParent(hdlg),WMX_ACTIVATEPAGE,0,0);
            PostMessage(GetParent(hdlg),WMX_I_AM_VISIBLE,0,0);
            return(TRUE);

        case PSN_KILLACTIVE:
            //
            // Page is being deactivated. Ask real dlg proc.
            //
            SetWindowLongPtr(
                hdlg,
                DWLP_MSGRESULT,
                CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,WMX_ACTIVATEPAGE,FALSE,AdvanceDirection) ? 0 : -1
                );

            return(TRUE);

        case PSN_WIZFINISH:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:

            //
            // set the button id
            //
            switch(Notify->code) {
                case PSN_WIZFINISH:
                    i = WMX_FINISHBUTTON;
                    break;

                case PSN_WIZBACK:
                    i = WMX_BACKBUTTON;
                    break;

                case PSN_WIZNEXT:

                    i = WMX_NEXTBUTTON;
                    break;
            }
            //
            // Tell the page-specific dialog proc about it.
            //
            CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,i,0,(LPARAM)&NextPageOverrideId);
            //
            // Allow user to use these buttons.  Remember which button was chosen.
            //
            AdvanceDirection = Notify->code;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,NextPageOverrideId);
            return(TRUE);

        default:
            //
            // Unknown code, pass it on.
            //
            break;
        }
        break;

    case WMX_UNATTENDED:

        PropSheet_PressButton(GetParent(hdlg),wParam);
        break;

    case WM_NCPAINT:
    //
    // we delay drawing the separator until here in some cases, because
    // we must make sure that the header bitmap has been adjusted correctly,
    // and then we can place the separator relative to the header bitmap
    //
/*
        if(!(WizPage->CommonData.Flags & WIZPAGE_SEPARATOR_CREATED)) {
        if (WatermarkHeaderHeight){
                GetClientRect(hdlg,&rc1);

                MapWindowPoints(hdlg,GetParent(hdlg),(POINT *)&rc1,2);

                CreateWindowEx(
                    WS_EX_STATICEDGE | WS_EX_NOPARENTNOTIFY,
                    TEXT("Static"),
                    TEXT("HeaderSeparator"),
                    WS_CHILD | WS_VISIBLE | ((OsVersion.dwMajorVersion < 4) ? SS_BLACKRECT : SS_SUNKEN),
                    0,
                    WatermarkHeaderHeight - rc1.top,
                    rc1.right-rc1.left,2,
                    hdlg,
                    (HMENU)IDC_HEADER_BOTTOM,
                    hInst,
                    0
                    );

                WizPage->CommonData.Flags |= WIZPAGE_SEPARATOR_CREATED;
        }
    }
*/
    default:

        break;
    }

    if(WizPage) {
        return((BOOL)CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,msg,wParam,lParam));
    } else {
        return(b);
    }
}


BOOL
GrowWizardArray(
    IN OUT PUINT               ArraySize,
    IN     UINT                PageCount,
    IN OUT LPPROPSHEETPAGE    *PagesArray,
    IN OUT PPAGE_RUNTIME_DATA *DataArray
    )
{
    PVOID p;
    BOOL b;
    #define _INCR 3

    if(*ArraySize == PageCount) {

        b = FALSE;

        if(p = REALLOC(*PagesArray,(*ArraySize+_INCR) * sizeof(PROPSHEETPAGE))) {
            *PagesArray = p;
            if(p = REALLOC(*DataArray,(*ArraySize+_INCR) * sizeof(PAGE_RUNTIME_DATA))) {
                *DataArray = p;

                *ArraySize += _INCR;
                b = TRUE;
            }
        }

        #undef _INCR

        if(!b) {
            FREE(*PagesArray);
            FREE(*DataArray);

            MessageBoxFromMessage(
                NULL,
                MSG_OUT_OF_MEMORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
        }

    } else {
        b = TRUE;
    }

    return(b);
}


VOID
FixUpWizardTitle(
    IN HWND Wizard
    )
{
    HWND TabControl;
    int Count,i;
    TCHAR Title[250];
    TC_ITEM ItemData;

    LoadString(hInst,AppTitleStringId,Title,sizeof(Title)/sizeof(Title[0]));

    TabControl = PropSheet_GetTabControl(Wizard);
    Count = TabCtrl_GetItemCount(TabControl);

    ItemData.mask = TCIF_TEXT;
    ItemData.pszText = Title;

    for(i=0; i<Count; i++) {
        TabCtrl_SetItem(TabControl,i,&ItemData);
    }
}

#if ASSERTS_ON

VOID
EnsureCorrectPageSize(
    PROPSHEETPAGE PropSheetPage
    )
{
    LPDLGTEMPLATE pDlgTemplate;
    LPDLGTEMPLATEEX pDlgTemplateEx;
    HRSRC hRes;
    HGLOBAL hDlgTemplate;

    pDlgTemplate = NULL;

    if (PropSheetPage.dwFlags & PSP_DLGINDIRECT) {
        pDlgTemplate = (LPDLGTEMPLATE) PropSheetPage.pResource;
        goto UseTemplate;
    } else {
        hRes = FindResource(PropSheetPage.hInstance, PropSheetPage.pszTemplate, RT_DIALOG);
        if (hRes) {
            hDlgTemplate = LoadResource(PropSheetPage.hInstance, hRes);
            if (hDlgTemplate) {
                pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
                if (pDlgTemplate) {
UseTemplate:
                    pDlgTemplateEx = (LPDLGTEMPLATEEX)pDlgTemplate;
                    if (pDlgTemplateEx->wSignature == 0xFFFF) {
                        MYASSERT(pDlgTemplateEx->cx == WIZ_PAGE_SIZE_X && pDlgTemplateEx->cy==WIZ_PAGE_SIZE_Y);
                    } else {
                        MYASSERT(pDlgTemplate->cx == WIZ_PAGE_SIZE_X && pDlgTemplate->cy == WIZ_PAGE_SIZE_Y);
                    }
                    if (PropSheetPage.dwFlags & PSP_DLGINDIRECT)
                        return;
                    UnlockResource(hDlgTemplate);
                }

            }
        }
    }
}

#endif

LRESULT
CALLBACK
BackgroundWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    HBRUSH Brush, OldBrush;
    INT i;
    INT y1, y2;
    INT Height;

    switch (uMsg) {

    case WM_ACTIVATE:
        if (LOWORD (wParam) == WA_ACTIVE) {
            InvalidateRect (hwnd, NULL, FALSE);
        }
        break;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {

        case SC_MINIMIZE:
            ShowWindow (hwnd, SW_MINIMIZE);
            return 0;

        case SC_RESTORE:
        case SC_CLOSE:
            ShowWindow (hwnd, SW_RESTORE);
            PostMessage (WizardHandle, uMsg, wParam, lParam);
            return 0;

        default:
            MYASSERT (FALSE);
        }

        break;

    case WM_PAINT:
        hdc = BeginPaint (hwnd, &ps);

        //SelectObject (hdc, GetStockObject (BLACK_BRUSH));
        SelectObject (hdc, GetStockObject (NULL_PEN));

        GetClientRect (hwnd, &rect);
        Height = rect.bottom - rect.top;

        for (i = 0 ; i < 256 ; i++) {
            Brush = CreateSolidBrush (RGB(0, 0, i));

            if (Brush != NULL) {
                OldBrush = (HBRUSH) SelectObject (hdc, Brush);

                y1 = rect.top + Height * i / 256;
                y2 = rect.top + Height * (i + 1) / 256;
                Rectangle (hdc, rect.left, y1, rect.right + 1, y2 + 1);

                SelectObject (hdc, OldBrush);
                DeleteObject (Brush);
            }
        }

        EndPaint (hwnd, &ps);
        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}

typedef HWND (CALLBACK* GETBBHWND)(void);
typedef BOOL (CALLBACK* SETSTEP)(int);
typedef BOOL (CALLBACK *STOPBILLBOARD)();
typedef BOOL (CALLBACK *STARTBILLBOARD)();
typedef BOOL (WINAPI* SETPROGRESSTEXT)(LPCTSTR szText);
typedef BOOL (WINAPI* SETTIMEESTIMATE)(LPCTSTR szText);
typedef BOOL (WINAPI* SETINFOTEXT)(LPCTSTR szText);
typedef LRESULT (WINAPI* PROGRESSGAUGEMSG)(UINT msg, WPARAM wparam, LPARAM lparam);
typedef BOOL (WINAPI* SHOWPROGRESSGAUGEWINDOW)(UINT uiShow);

BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow)
{
    static SHOWPROGRESSGAUGEWINDOW fpShowGauge = NULL;
    BOOL bRet = FALSE;;

    if (fpShowGauge == NULL)
    {
        if (hinstBB)
        {
            fpShowGauge = (SHOWPROGRESSGAUGEWINDOW )GetProcAddress(hinstBB, "ShowProgressGaugeWindow");
        }
    }
    if (fpShowGauge != NULL)
    {
        bRet = fpShowGauge(nCmdShow);
    }
    return bRet;
}
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static PROGRESSGAUGEMSG fpProgressGaugeMsg = NULL;
    LRESULT lresult = 0;

    if (fpProgressGaugeMsg == NULL)
    {
        if (hinstBB)
        {
            fpProgressGaugeMsg = (PROGRESSGAUGEMSG )GetProcAddress(hinstBB, "ProgressGaugeMsg");
        }
    }
    if (fpProgressGaugeMsg != NULL)
    {
        lresult = fpProgressGaugeMsg(msg, wparam, lparam);
    }
    return lresult;
}
void BB_SetProgressText(LPTSTR szText)
{
    static SETPROGRESSTEXT fpSetProgressText = NULL;
    if (fpSetProgressText == NULL)
    {
        if (hinstBB)
        {
            fpSetProgressText = (SETPROGRESSTEXT )GetProcAddress(hinstBB, "SetProgressText");
        }
    }
    if (fpSetProgressText != NULL)
    {
        fpSetProgressText(szText);
    }
}
void BB_SetTimeEstimateText(LPTSTR szText)
{
    static SETTIMEESTIMATE fpSetTimeEstimate = NULL;
    if (fpSetTimeEstimate == NULL)
    {
        if (hinstBB)
        {
            fpSetTimeEstimate = (SETTIMEESTIMATE)GetProcAddress(hinstBB, "SetTimeEstimate");
        }
    }
    if (fpSetTimeEstimate != NULL)
    {
        fpSetTimeEstimate(szText);
    }
}
void BB_SetInfoText(LPTSTR szText)
{
    static SETINFOTEXT fpSetInfoText = NULL;
    if (fpSetInfoText == NULL)
    {
        if (hinstBB)
        {
            fpSetInfoText = (SETINFOTEXT )GetProcAddress(hinstBB, "SetInfoText");
        }
    }
    if (fpSetInfoText != NULL)
    {
        fpSetInfoText(szText);
    }
}

BOOL StartStopBB(BOOL bStart)
{
    static STARTBILLBOARD fpStart = NULL;
    static STOPBILLBOARD fpStop = NULL;
    BOOL bRet = FALSE;

    if ((fpStart == NULL) || (fpStop == NULL))
    {
        if (hinstBB)
        {
            fpStop = (STARTBILLBOARD )GetProcAddress(hinstBB, "StopBillBoard");
            fpStart = (STOPBILLBOARD )GetProcAddress(hinstBB, "StartBillBoard");
        }
    }
    if ((fpStart != NULL) && (fpStop != NULL))
    {
        if (bStart)
            bRet = fpStart();
        else
            bRet = fpStop();

    }
    return bRet;
}

HWND GetBBhwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;

    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}

HWND GetBBMainHwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;

    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBMainHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}


void SetBBStep(int iStep)
{
    static SETSTEP psetstep = NULL;
    if (psetstep == NULL)
    {
        if (hinstBB)
        {
            psetstep = (SETSTEP )GetProcAddress(hinstBB, "SetStep");
        }
    }
    if (psetstep)
        psetstep(iStep);
}


VOID
Wizard(
    VOID
    )
{
    UINT ArraySize;
    LPPROPSHEETPAGE PropSheetPages;
    PPAGE_RUNTIME_DATA PageData;
    UINT u;
    UINT i;
    UINT PageCount;
    PROPSHEETHEADER Sheet;
    WNDCLASSEX wcx;
    RECT rect;
    TCHAR Caption[512];
    LONG l;

    ArraySize = 5;
    PropSheetPages = MALLOC(ArraySize * sizeof(PROPSHEETPAGE));
    if(!PropSheetPages) {
        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return;
    }

    PageData = MALLOC(ArraySize * sizeof(PAGE_RUNTIME_DATA));
    if(!PageData) {
        FREE(PropSheetPages);

        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return;
    }

    PageCount = 0;

    //
    // Now loop through the array of protopages, adding ones we supply, and
    // ranges of pages supplied externally.
    //
    for(u=0; u<(sizeof(ProtoPages)/sizeof(ProtoPages[0])); u++) {

        if(ProtoPages[u].ExternalPages) {
            //
            // Supplied externally. If there are any pages, add them now.
            //
            for(i=0; i<*ProtoPages[u].ExternalPageCount; i++) {

                if(!GrowWizardArray(&ArraySize,PageCount,&PropSheetPages,&PageData)) {
                    return;
                }

                PropSheetPages[PageCount] = (*ProtoPages[u].ExternalPages)[i];

                ZeroMemory(&PageData[PageCount],sizeof(PAGE_RUNTIME_DATA));
                PageData[PageCount].CommonData.DialogProcedure = PropSheetPages[PageCount].pfnDlgProc;
                PropSheetPages[PageCount].pfnDlgProc = WizardCommonDlgProc;

                PageData[PageCount].CommonData.Buttons = (DWORD)(-1);

                PageCount++;
            }
        } else {
            //
            // Supplied internally. Add now.
            //
            if(!GrowWizardArray(&ArraySize,PageCount,&PropSheetPages,&PageData)) {
                return;
            }

            ZeroMemory(&PropSheetPages[PageCount],sizeof(PROPSHEETPAGE));
            ZeroMemory(&PageData[PageCount],sizeof(PAGE_RUNTIME_DATA));

            PageData[PageCount].CommonData = ProtoPages[u].CommonData;

            PropSheetPages[PageCount].dwSize = sizeof(PROPSHEETPAGE);
            PropSheetPages[PageCount].dwFlags = PSP_USETITLE;
            PropSheetPages[PageCount].hInstance = hInst;
            PropSheetPages[PageCount].pszTemplate = MAKEINTRESOURCE(ProtoPages[u].Template);
            PropSheetPages[PageCount].pszTitle = MAKEINTRESOURCE(AppTitleStringId);
            PropSheetPages[PageCount].pfnDlgProc = WizardCommonDlgProc;

            PageCount++;
        }

    }

    for(u=0; u<PageCount; u++) {

#if ASSERTS_ON
        //
        // Make sure that the page size is correct
        //
        // PW: Why??? Localization should be able to resize this.
        // This would also prevent us from resizing the pages
        // in the case where we are running an none DBCS setup
        // on a DBCS system.
        // We need to resize the pages, because the fonts for the
        // page and the frame are different. When comctrl calcs
        // the size of the frame it comes up short for the font
        // used in the page.
        //
        EnsureCorrectPageSize(PropSheetPages[u]);
#endif

        //
        // Set pointers to runtime page data.
        //
        PropSheetPages[u].lParam = (LPARAM)&PageData[u];
    }

    //
    // Set up the property sheet header structure.
    //
    ZeroMemory(&Sheet,sizeof(PROPSHEETHEADER));

    Sheet.dwSize = sizeof(PROPSHEETHEADER);
    Sheet.dwFlags = PSH_WIZARD | PSH_PROPSHEETPAGE | PSH_USECALLBACK;
    Sheet.hInstance = hInst;
    Sheet.nPages = PageCount;
    Sheet.ppsp = PropSheetPages;
    Sheet.pfnCallback = Winnt32SheetCallback;
#if 0
    //
    // Create background (for Win9x only currently)
    //
    if (!ISNT()) {
        GetWindowRect (GetDesktopWindow(), &rect);

        ZeroMemory (&wcx, sizeof (wcx));
        wcx.cbSize = sizeof (wcx);
        wcx.style = CS_NOCLOSE;
        wcx.lpfnWndProc = BackgroundWndProc;
        wcx.hInstance = hInst;
        wcx.lpszClassName = TEXT("Winnt32Background");

        RegisterClassEx (&wcx);

        if (!LoadString (
                hInst,
                AppTitleStringId,
                Caption,
                sizeof(Caption)/sizeof(TCHAR)
                )) {
            Caption[0] = 0;
        }

        BackgroundWnd = CreateWindowEx (
                              WS_EX_APPWINDOW,
                              TEXT("Winnt32Background"),
                              Caption,
                              WS_DISABLED|WS_CLIPCHILDREN|WS_POPUP|WS_VISIBLE,
                              rect.left,
                              rect.top,
                              rect.right,
                              rect.bottom,
                              NULL,
                              NULL,
                              hInst,
                              0
                              );

        Sheet.hwndParent = BackgroundWnd;

        UpdateWindow (BackgroundWnd);
    }
#else
    Sheet.hwndParent = GetBBhwnd();
#endif
    //
    // Do it.
    //
    __try{
        i = (UINT)PropertySheet(&Sheet);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        i = 0;
        MessageBoxFromMessage(
            NULL,
            MSG_RESTART_TO_RUN_AGAIN,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
    }

    if (BackgroundWnd) {
        DestroyWindow (BackgroundWnd);
        BackgroundWnd = NULL;
    }

    if(i == (UINT)(-1)) {

        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
    }

    FREE(PageData);
    FREE(PropSheetPages);
}

BOOL
GetComplianceIds(
    DWORD SourceSku,
    DWORD DestinationType,
    DWORD DestinationVersion,
    PDWORD pSourceId,
    PDWORD pDestId
    )
{

    BOOL bError = FALSE;

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTSDTC:
            *pSourceId = MSG_TYPE_NTSDTC51;
            break;
        case COMPLIANCE_SKU_NTSFULL:
        case COMPLIANCE_SKU_NTSU:
            *pSourceId = MSG_TYPE_NTS51;
            break;
        case COMPLIANCE_SKU_NTSEFULL:
        case COMPLIANCE_SKU_NTSEU:
            *pSourceId = MSG_TYPE_NTAS51;
            break;
        case COMPLIANCE_SKU_NTWFULL:
        case COMPLIANCE_SKU_NTW32U:
            *pSourceId = MSG_TYPE_NTPRO51;
            break;
        case COMPLIANCE_SKU_NTWPFULL:
        case COMPLIANCE_SKU_NTWPU:
            *pSourceId = MSG_TYPE_NTPER51;
            break;
        case COMPLIANCE_SKU_NTSB:
        case COMPLIANCE_SKU_NTSBU:
            *pSourceId = MSG_TYPE_NTBLA51;
            break;
		case COMPLIANCE_SKU_NTSBS:
		case COMPLIANCE_SKU_NTSBSU:
			*pSourceId = MSG_TYPE_NTSBS51;
			break;
		default:
            bError = TRUE;
    };

    switch (DestinationType) {
        case COMPLIANCE_INSTALLTYPE_WIN31:
            *pDestId = MSG_TYPE_WIN31;
            break;
        case COMPLIANCE_INSTALLTYPE_WIN9X:
            switch (OsVersionNumber) {
                case 410:
                    *pDestId = MSG_TYPE_WIN98;
                    break;
                case 490:
                    *pDestId = MSG_TYPE_WINME;
                    break;
                default:
                    *pDestId = MSG_TYPE_WIN95;
                    break;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTW:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTPROPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTPRO;
                } else {
                    *pDestId = MSG_TYPE_NTPRO51;
                }
            } else {
                *pDestId = MSG_TYPE_NTW;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTS:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTSPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTS2;
                } else {
                    *pDestId = MSG_TYPE_NTS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTS;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTASPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTAS;
                } else {
                    *pDestId = MSG_TYPE_NTAS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTSE;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (DestinationVersion < 1381) {
                *pDestId = MSG_TYPE_NTSCITRIX;
            } else {
                *pDestId = MSG_TYPE_NTSTSE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            if (DestinationVersion <= 2195) {
                *pDestId = MSG_TYPE_NTSDTC;
            } else {
                *pDestId = MSG_TYPE_NTSDTC51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTPER51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTBLA51;
            }
			break;
		case COMPLIANCE_INSTALLTYPE_NTSBS:
			if (DestinationVersion < 2195) {
				bError = TRUE;
			} else if (DestinationVersion == 2195) {
				*pDestId = MSG_TYPE_NTSBS50;
			} else {
				*pDestId = MSG_TYPE_NTSBS51;
			}
            break;
        default:
            bError = TRUE;

    };

    return (!bError);

}


INT_PTR
WelcomeWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    LONG l;
    static BOOL WantToUpgrade; // need to remember if "Upgrade" is in the listbox
    BOOL noupgradeallowed = FALSE;
    UINT srcsku,reason,desttype,destversion;
    TCHAR reasontxt[200];
    PTSTR p;
    TCHAR buffer[MAX_PATH];
    TCHAR win9xInf[MAX_PATH];
    BOOL    CompliantInstallation = FALSE;
    BOOLEAN CleanInstall = FALSE;

    UINT skuerr[] = {
        0,               // COMPLIANCE_SKU_NONE
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTW32U
        0,               // COMPLIANCE_SKU_NTWU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSEFULL
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSEU
        0,               // COMPLIANCE_SKU_NTSSEU
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSDTC
        0,               // COMPLIANCE_SKU_NTSDTCU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWPFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTWPU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSB
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSBU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSBS
        MSG_SKU_UPGRADE  // COMPLIANCE_SKU_NTSBSU
    } ;


    UINT skureason[] = {
        0, //MSG_SKU_REASON_NONE;
        MSG_SKU_VERSION, //COMPLIANCEERR_VERSION;
        MSG_SKU_SUITE, //COMPLIANCEERR_SUITE;
        MSG_SKU_TYPE, // COMPLIANCEERR_TYPE;
        MSG_SKU_VARIATION, //COMPLIANCEERR_VARIATION;
        MSG_SKU_UNKNOWNTARGET, //COMPLIANCEERR_UNKNOWNTARGET
        MSG_SKU_UNKNOWNSOURCE, //COMPLIANCEERR_UNKNOWNSOURCE
        MSG_CANT_UPGRADE_FROM_BUILD_NUMBER //COMPLIANCEERR_VERSION (Old on New Builds)
    } ;

    switch(msg) {

    case WM_COMMAND:

        b = FALSE;
        //
        // Check for buttons.
        //
        if(HIWORD(wParam) == CBN_SELCHANGE)
        {
            TCHAR szLoadText[MAX_STRING];
            if (0 == SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_GETCURSEL, 0, 0) && WantToUpgrade)
            {
                dwSetupFlags |= UPG_FLAG_TYPICAL;
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), SW_SHOW);
                if(LoadString(hInst,IDS_INSTALLTYPE_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
                InvalidateRect(hdlg,NULL,TRUE);
            }
            else
            {
                dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), SW_HIDE);
                if(LoadString(hInst,IDS_INSTALLTYPE_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
                InvalidateRect(hdlg,NULL,TRUE);
            }
            b = TRUE;
        }
        break;

    case WM_INITDIALOG:
        //
        // Center the wizard
        //

        WizardHandle = GetParent (hdlg);

#ifdef _X86_

        if (!ISNT()) {
            //
            // NOTE: Win98, Win98 SE and WinME don't work properly with a wizard
            //       that can minimize.  So while the minimize functionality is
            //       useful, we can't allow it on anything other than Win95,
            //       OSR1 or OSR2.
            //

            if (BUILDNUM() <= 1080) {
                l = GetWindowLong (WizardHandle, GWL_STYLE);
                l |= WS_MINIMIZEBOX|WS_SYSMENU;
                SetWindowLong (WizardHandle, GWL_STYLE, l);
            }

            ProtectAllModules();        // protects modules from 0xC0000006
        }
#endif

        //
        // We're about to check if upgrades are allowed.
        // Remember if the user wants an upgrade (this would be via an unattend
        // mechanism).
        //
        WantToUpgrade = Upgrade;

        if (ISNT()){
            if(!AdjustPrivilege(SE_RESTORE_NAME)){
                MYASSERT(FALSE);
            }
        }

        if (!NoCompliance) {
            TCHAR SourceName[200];
            UINT srcid, destid;
            TCHAR DestName[200];

            CompliantInstallation = IsCompliant(
                        &UpgradeOnly,
                        &noupgradeallowed,
                        &srcsku,
                        &desttype,
                        &destversion,
                        &reason);

            DebugLog(Winnt32LogInformation, TEXT("Upgrade only = %1"), 0, UpgradeOnly?TEXT("Yes"):TEXT("No"));
            DebugLog(Winnt32LogInformation, TEXT("Upgrade allowed = %1"), 0, noupgradeallowed?TEXT("No"):TEXT("Yes"));
            if (GetComplianceIds(
                    srcsku,
                    desttype,
                    destversion,
                    &srcid,
                    &destid))
            {
                  FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      hInst,
                      srcid,
                      0,
                      SourceName,
                      sizeof(SourceName) / sizeof(TCHAR),
                      NULL
                      );
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1"), 0, SourceName);

                  FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      hInst,
                      destid,
                      0,
                      DestName,
                      sizeof(DestName) / sizeof(TCHAR),
                      NULL
                      );
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1"), 0, DestName);
            }
            else
            {
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
            }
            DebugLog(Winnt32LogInformation, TEXT("Current Version = %1!ld!"), 0, destversion);
            if (!CompliantInstallation)
            {
                DebugLog(Winnt32LogInformation, TEXT("Reason = %1!ld!"), 0, reason);
            }
            //
            // Do only clean installs in WinPE mode & don't
            // shut down automatically once Winnt32.exe completes
            //
            if (IsWinPEMode()) {
                noupgradeallowed = TRUE;
                AutomaticallyShutDown = FALSE;
            }

            CleanInstall = CompliantInstallation ? TRUE : FALSE;

            if (!CompliantInstallation) {
                //
                // if they aren't compliant, we won't let them upgrade.
                // we also won't let them do a clean install from winnt32
                //

                b = TRUE;
                switch(reason) {
                    case COMPLIANCEERR_UNKNOWNTARGET:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_UNKNOWNTARGET,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONERROR | MB_TASKMODAL
                              );
                        break;

                    case COMPLIANCEERR_UNKNOWNSOURCE:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_UNKNOWNSOURCE,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONERROR | MB_TASKMODAL
                              );
                        break;
                    case COMPLIANCEERR_SERVICEPACK5:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_SERVICEPACK,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONWARNING | MB_TASKMODAL
                              );
                        break;

                    default:
                        b = FALSE;
                        break;
                };

                if (b) {
                    //
                    // let setup continue if they did /CheckUpgradeOnly
                    // so they can see the message in the report
                    //
                    if (CheckUpgradeOnly) {
                        break;
                    }
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    return FALSE;
                }
                // If we add this part to the message, it sound bad and is not needed.
                if (reason == COMPLIANCEERR_VERSION)
                {
                    reasontxt[0] = TEXT('\0');
                }
                else
                {
                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        skureason[reason],
                        0,
                        reasontxt,
                        sizeof(reasontxt) / sizeof(TCHAR),
                        NULL
                        );
                }

                //
                // don't warn again if winnt32 just restarted
                //
                if (!Winnt32Restarted ()) {
                    MessageBoxFromMessage(
                                          GetBBhwnd(),
                                          skuerr[srcsku],
                                          FALSE,
                                          AppTitleStringId,
                                          MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                          reasontxt
                                          );
                }

                if (UpgradeOnly) {
                    //
                    // let setup continue if they did /CheckUpgradeOnly
                    // so they can see the message in the report
                    //
                    if (CheckUpgradeOnly) {
                        break;
                    }
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    return(FALSE);
                }
                Upgrade = FALSE;
            } else if (Upgrade && noupgradeallowed) {
                Upgrade = FALSE;
                if (!UnattendedOperation && !BuildCmdcons && !IsWinPEMode() &&
                    //
                    // don't warn again if winnt32 just restarted
                    //
                    !Winnt32Restarted ()) {

                    //
                    // put up an error message for the user.
                    //

                    if (GetComplianceIds(
                            srcsku,
                            desttype,
                            destversion,
                            &srcid,
                            &destid)) {

                        if (srcid != destid) {
#ifndef UNICODE
                            if( Server)
#endif
                            {
                                // Unicode version is used on nt upgrade (ie nt 3.51 nt 4.0 ...)
                                // We need to display this message all the time.
                                //
                                // Ascii version is run on win9x upgrades.
                                // For workstation skus, the message is already displayed
                                // by the win9x upgrade module.
                                // On Server skus, we need to display the message since the upgrade module is not run.
                                //
                                FormatMessage(
                                      FORMAT_MESSAGE_FROM_HMODULE,
                                      hInst,
                                      srcid,
                                      0,
                                      SourceName,
                                      sizeof(SourceName) / sizeof(TCHAR),
                                      NULL
                                      );

                                FormatMessage(
                                      FORMAT_MESSAGE_FROM_HMODULE,
                                      hInst,
                                      destid,
                                      0,
                                      DestName,
                                      sizeof(DestName) / sizeof(TCHAR),
                                      NULL
                                      );

                                MessageBoxFromMessage(
                                            GetBBhwnd(),
                                            MSG_NO_UPGRADE_ALLOWED,
                                            FALSE,
                                            AppTitleStringId,
                                            MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                                            DestName,
                                            SourceName
                                            );
                            }
                        } else {

                            MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_CANT_UPGRADE_FROM_BUILD_NUMBER,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONWARNING | MB_TASKMODAL
                                  );
                        }
                    } else {
                        MessageBoxFromMessage(
                                      GetBBhwnd(),
                                      MSG_NO_UPGRADE_ALLOWED_GENERIC,
                                      FALSE,
                                      AppTitleStringId,
                                      MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL
                                      );
                    }
                }
            }
        } else {
                CleanInstall = !UpgradeOnly;
        }

        //
        // Set install type combo box.
        //
        if (!UpgradeSupport.DllModuleHandle) {
            MYASSERT(!Upgrade);
        }

        //
        // Upgrade defaults to TRUE.  If it's set to FALSE, then assume
        // something has gone wrong, so disable the user's ability to
        // upgrade.
        //


        if (UpgradeOnly && !Upgrade) {
            //
            // in this case upgrade isn't possible, but neither is clean install
            // post an error message and bail.
            //

            MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UPGRADE_OR_CLEAN,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONERROR | MB_TASKMODAL
                                  );
            //
            // let setup continue if they did /CheckUpgradeOnly
            // so they can see the message in the report
            //
            if (!CheckUpgradeOnly) {
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                break;
            }

        } else if (!Upgrade && WantToUpgrade && UnattendedOperation && !BuildCmdcons) {
            //
            // we can't do an upgrade and they wanted unattended upgrade.
            // let the user know and then bail out
            //
            //
            // don't warn again if winnt32 just restarted
            //
            if (!Winnt32Restarted ()) {
                TCHAR SourceName[200];
                UINT srcid, destid;
                TCHAR DestName[200];

                if (GetComplianceIds(
                        srcsku,
                        desttype,
                        destversion,
                        &srcid,
                        &destid) && (srcid != destid)) {
                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        srcid,
                        0,
                        SourceName,
                        sizeof(SourceName) / sizeof(TCHAR),
                        NULL
                        );

                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        destid,
                        0,
                        DestName,
                        sizeof(DestName) / sizeof(TCHAR),
                        NULL
                        );


                    MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UNATTENDED_UPGRADE_SPECIFIC,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                                  DestName,
                                  SourceName
                                  );
                } else {
                    MessageBoxFromMessage(
                                      GetBBhwnd(),
                                      MSG_NO_UNATTENDED_UPGRADE,
                                      FALSE,
                                      AppTitleStringId,
                                      MB_OK | MB_ICONERROR | MB_TASKMODAL
                                      );
                }
            }

            //
            // let setup continue if they did /CheckUpgradeOnly
            // so they can see the message in the report
            //
            if (!CheckUpgradeOnly) {
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                break;
            }
        }

        if (reason == COMPLIANCEERR_DTCWARNING) {
            DebugLog(Winnt32LogWarning,
                 TEXT("WARNING: Attempting to upgrade an OEM version with a retail version of this product."),
                 0);
            if( !UnattendedOperation) {
                int i;

                i = MessageBoxFromMessage(
                      GetBBhwnd(),
                      MSG_WARNING_DTCUPGRADE,
                      FALSE,
                      AppTitleStringId,
                      MB_OKCANCEL | MB_TASKMODAL | MB_DEFBUTTON2 | MB_ICONWARNING
                      );

                if( i == IDCANCEL) {
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    return FALSE;
                }
            }

        }
        MYASSERT(Upgrade || CleanInstall);
        {
            TCHAR szLoadText[MAX_STRING]; // need enclosing braces for this b/c of switch statement

            if (Upgrade)
            {
                if(LoadString(hInst,IDS_INSTALL_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)szLoadText);
                }
                else
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)TEXT("Express Upgrade"));
                }
            } else {
                WantToUpgrade = FALSE;
            }

            if (CleanInstall)
            {
                if(LoadString(hInst,IDS_INSTALL_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)szLoadText);
                }
                else
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)TEXT("Custom"));
                }
            }

            SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_SETCURSEL, 0, 0);


            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), Upgrade?SW_HIDE:SW_SHOW);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), Upgrade?SW_HIDE:SW_SHOW);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), Upgrade?SW_SHOW:SW_HIDE);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), Upgrade?SW_SHOW:SW_HIDE);
            if (Upgrade)
            {
                dwSetupFlags |= UPG_FLAG_TYPICAL;
                if(LoadString(hInst,IDS_INSTALLTYPE_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
            }
            else
            {
                dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                if(LoadString(hInst,IDS_INSTALLTYPE_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
            }
        }


        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();

        if(wParam) {

            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                        TEXT(""),
                        buffer,
                        sizeof(buffer) / sizeof(TCHAR),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    Upgrade = !lstrcmpi (buffer, WINNT_A_YES);
                    if (!Upgrade) {
                        dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                    }
                    return FALSE;
                }
            }
            //
            // Nothing to do. Advance page in unattended case.
            //
            if(UnattendedOperation && !CancelPending) {
                PostMessage (hdlg, WMX_UNATTENDED, PSBTN_NEXT, 0);
            }
            else
            {
                PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
            }
        } else {
            //
            // Deactivation. Set state of upgrade based on radio buttons.
            //
            Upgrade = (0 == SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_GETCURSEL, 0, 0)) && WantToUpgrade;

            //
            // On upgrade, delete the setup log files.
            //
            if (Upgrade) {
                TCHAR   FilePath[MAX_PATH];

                MyGetWindowsDirectory( FilePath, MAX_PATH );
                ConcatenatePaths( FilePath, TEXT("setupact.log"), MAX_PATH);
                DeleteFile( FilePath );
                MyGetWindowsDirectory( FilePath, MAX_PATH );
                ConcatenatePaths( FilePath, TEXT("setuperr.log"), MAX_PATH);
                DeleteFile( FilePath );
            }
        }
        b = TRUE;
        break;

    case WMX_I_AM_VISIBLE:
        // Force repainting first to make sure the page is visible.
        //
        // Set the focus on the NEXT button, people were unintentionally
        // changing the install type from upgrade to clean with wheel mouse
        SetFocus (GetDlgItem (GetParent(hdlg), 0x3024));
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


typedef BOOL (WINAPI *EnumProcessesFn)(DWORD * lpidProcess,
                                       DWORD   cb,
                                       DWORD * cbNeeded);

typedef BOOL (WINAPI *EnumProcessModulesFn)(HANDLE hProcess,
                                            HMODULE *lphModule,
                                            DWORD cb,
                                            LPDWORD lpcbNeeded);
#ifdef UNICODE
typedef DWORD (WINAPI *GetModuleBaseNameFn)(HANDLE hProcess,
                                            HMODULE hModule,
                                            LPWSTR lpBaseName,
                                            DWORD nSize);
#else
typedef DWORD (WINAPI *GetModuleBaseNameFn)(HANDLE hProcess,
                                            HMODULE hModule,
                                            LPSTR lpBaseName,
                                            DWORD nSize);
#endif // !UNICODE


#define DEF_PROCESSES_SIZE 1000
BOOL
pDoesProcessExist(
    IN LPCTSTR pProcessName
    )
{
    HMODULE hPSLib = NULL;
    EnumProcessesFn EnumProcesses;
    EnumProcessModulesFn EnumProcessModules;
    GetModuleBaseNameFn GetModuleBaseName;
    HANDLE  hProcess;
    HMODULE hModule;
    TCHAR   ProcessName[MAX_PATH];
    DWORD * pdwProcessesID = NULL;
    DWORD   dwBytesExist = 0;
    DWORD   dwBytesNeeded = 0;
    BOOL    bResult = FALSE;
    UINT    i;
    UINT    iLen;



    __try{
        hPSLib = LoadLibrary(TEXT("psapi.dll"));
        if(!hPSLib){
            __leave;
        }

        EnumProcesses = (EnumProcessesFn)GetProcAddress(hPSLib, "EnumProcesses");
        EnumProcessModules = (EnumProcessModulesFn)GetProcAddress(hPSLib, "EnumProcessModules");
        GetModuleBaseName = (GetModuleBaseNameFn)GetProcAddress(hPSLib,
                                                                "GetModuleBaseName"
#ifdef UNICODE
                                                                "W"
#else
                                                                "A"
#endif
                                                                );
        if(!EnumProcesses || !EnumProcessModules || !GetModuleBaseName){
            __leave;
        }

        do{
            if(pdwProcessesID){
                FREE(pdwProcessesID);
            }

            dwBytesExist += DEF_PROCESSES_SIZE;
            pdwProcessesID = (DWORD*)MALLOC(dwBytesExist);
            if(!pdwProcessesID){
                __leave;
            }

            if(!EnumProcesses(pdwProcessesID, dwBytesExist, &dwBytesNeeded)){
                __leave;
            }
        }while(dwBytesNeeded >= dwBytesExist);


        for(i = 0, iLen = dwBytesNeeded / sizeof(DWORD); i < iLen; i++){
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pdwProcessesID[i]);
            if(hProcess &&
               EnumProcessModules(hProcess, &hModule, sizeof(hModule), &dwBytesNeeded) &&
               GetModuleBaseName(hProcess, hModule, ProcessName, ARRAYSIZE(ProcessName)) &&
               !_tcsicmp(pProcessName, ProcessName)){
                CloseHandle(hProcess);
                bResult = TRUE;
                break;
            }
            CloseHandle(hProcess);
        }
    }
    __finally{
        if(pdwProcessesID){
            FREE(pdwProcessesID);
        }
        FreeLibrary(hPSLib);
    }

    return bResult;
}

INT_PTR
OptionsWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static BOOL bCopyFarEast = FALSE;
    static BOOL bUserSelectedCopyFarEast = FALSE;
    BOOL b;
    BOOL MultipleSource;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    TCHAR Buffer[4];
#ifdef RUN_SYSPARSE
    static BOOL FirstTime = TRUE;
#endif


    int status;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Enable autopartition picking feature only on personal and professional
        // when the user has not specified a /tempdrive and its not unattened mode
        //
        if (!Server && !UserSpecifiedLocalSourceDrive && !Upgrade && !UnattendedOperation) {
            ChoosePartition = FALSE;
        }

        b = FALSE;
        AccessibleMagnifier = pDoesProcessExist(TEXT("magnify.exe"));
        break;

    case WM_COMMAND:

        b = FALSE;
        //
        // Check for buttons.
        //
        if(HIWORD(wParam) == BN_CLICKED) {

            switch(LOWORD(wParam)) {

            case IDB_ACCESSIBILITY:

                DoAccessibility(hdlg);
                b = TRUE;
                break;

            case IDB_ADVANCED:

                DoOptions(hdlg);
                b = TRUE;
                break;
            case IDC_FAREAST_LANG:
                // Remember if the user put the check mark in it
                // If the control gets checked because a FE langauge was selected
                // windows does not send a BN_CLICKED message, so this does not get executed.
                bUserSelectedCopyFarEast = (IsDlgButtonChecked(hdlg,IDC_FAREAST_LANG) == BST_CHECKED);
                break;
            }
        }
        if(HIWORD(wParam) == CBN_SELCHANGE)
        {
            PrimaryLocale = (DWORD)SendDlgItemMessage( hdlg, IDC_COMBO1, CB_GETCURSEL, 0, 0 );
            // Only if we did not hide the window.
            // The window would be hidden if the current OS or the to be install language is
            // a FarEast Language.
            if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
            {
                if (IsFarEastLanguage(PrimaryLocale))
                {
                    // User seleted a FarEast Language,
                    // Select the check box and diable it.
                    CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_CHECKED);
                    EnableWindow(GetDlgItem(hdlg,IDC_FAREAST_LANG), FALSE);
                }
                else
                {
                    // Don't change the check mark, if the user checked it.
                    if (!bUserSelectedCopyFarEast)
                    {
                        // User seleted a non FarEast Language,
                        // Unselect the check box and enable it.
                        CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_UNCHECKED);
                    }
                    EnableWindow(GetDlgItem(hdlg,IDC_FAREAST_LANG), TRUE);
                }
            }
        }
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
#ifdef PRERELEASE
        if (wParam ){ // START IDWLOG. remove before ship

         TCHAR                 szDllPath[MAX_PATH];
         TCHAR                 szCommandString[MAX_PATH + 120];
         LPTSTR                lpDllPath;
         LPTSTR                lp;
         STARTUPINFO           si;
         PROCESS_INFORMATION   pi;

         //Initialize for Prefix

         szDllPath[0]=0;

         //
         // Launch idwlog.exe from the same directory as winnt32.exe.
         // INTERNAL: Tool to track the health of the build.
         // Ignore errors, NOT INCLUDED IN THE RETAIL release.
         // Remove this code before shipping
         //
         if ( FALSE == BuildCmdcons ) {
            if ( MyGetModuleFileName (NULL, szDllPath, MAX_PATH)) {

               for (lp=NULL,lpDllPath=szDllPath; *lpDllPath; lpDllPath=CharNext(lpDllPath)) {
                  // the char '\' is never a lead byte
                  if (*lpDllPath == TEXT('\\')) {
                     lp = lpDllPath;
                  }
               }


               _tcscpy(lp ? lp+1 : szDllPath , TEXT("IDWLOG.EXE -1"));

               _tcscpy(szCommandString, szDllPath);

               // If this is an Upgrade.
               _tcscat(szCommandString, Upgrade ? TEXT(" upgrade") : TEXT(""));

               // If this is from a CD
               _tcscat(szCommandString, RunFromCD ? TEXT(" cdrom") : TEXT(""));

               // If this is a MSI install
               _tcscat(szCommandString, RunFromMSI? TEXT(" MSI") : TEXT(""));


               // Start new JoeHol code.
               _tcscat(szCommandString, TEXT(" Path="));
               _tcscat(szCommandString, NativeSourcePaths[0] );


               ZeroMemory(&si,sizeof(si));
               si.cb = sizeof(si);
               if (CreateProcess( NULL,
                                  szCommandString,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  0,
                                  NULL,
                                  NULL,
                                  &si,
                                  &pi)
                  ) {
                  CloseHandle(pi.hProcess);
                  CloseHandle(pi.hThread);
               }
            }
         }
      } // END IDWLOG
#endif // PRERELEASE

#ifdef RUN_SYSPARSE
        if (FirstTime && wParam && !NoSysparse && (FALSE == BuildCmdcons) && !IsWinPEMode()) { // START sysparse. remove before RTM

            TCHAR                 szCommandString[MAX_PATH + 125];
            LPTSTR                lpDllPath;
            LPTSTR                lp;
            STARTUPINFO           si;
            //
            // Launch sysparse.exe from the same directory as winnt32.exe.
            //
            FirstTime = FALSE;
            if ( MyGetModuleFileName (NULL, szCommandString, MAX_PATH+125)) {
               for (lp=NULL,lpDllPath=szCommandString; *lpDllPath; lpDllPath=CharNext(lpDllPath)) {
                  // the char '\' is never a lead byte
                  if (*lpDllPath == TEXT('\\')) {
                     lp = lpDllPath;
                  }
               }

               _tcscpy(lp ? lp+1 : szCommandString , TEXT("SYSPARSE.EXE /donotrun1 /donotrun2 /n sysparse /w c:\\ /x /l /o /1 NA /2 NA /3 NA /4 NA /5 NA /6 NA /7 NA /8 NA /9 1 /m /a"));

               ZeroMemory(&si,sizeof(si));
               si.cb = sizeof(si);
               if (CreateProcess( NULL,
                                  szCommandString,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  0,
                                  NULL,
                                  NULL,
                                  &si,
                                  &piSysparse)
                  ) {
               } else {
                   piSysparse.hProcess = NULL;
                   DebugLog(Winnt32LogInformation, TEXT("Warning: Could not start sysparse.exe"), 0 );
               }
            } else {
                DebugLog(Winnt32LogInformation, TEXT("Warning: Could not find sysparse.exe - make sure it exists along with winnt32.exe"), 0 );
            }

        }
#endif

        //
        // Read intl.inf for the language options dialog.  We only do this if
        // it's the first activation and there's not a regional settings section
        // in the answer file.
        //
        if (wParam && !IntlInfProcessed &&
            !GetPrivateProfileString(
                WINNT_REGIONALSETTINGS,
                NULL,
                TEXT(""),
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR),
                UnattendedScriptFile)) {

            if (ReadIntlInf( hdlg ))
            {
                InitLangControl(hdlg, bCopyFarEast);
            }
        }

        if( Upgrade || TYPICAL()) {

            return( FALSE );
        }

        b = TRUE;

        if(wParam) {

            if (Winnt32RestartedWithAF ()) {
                if (LoadAdvancedOptions (g_DynUpdtStatus->RestartAnswerFile) &&
                    LoadLanguageOptions (g_DynUpdtStatus->RestartAnswerFile) &&
                    LoadAccessibilityOptions (g_DynUpdtStatus->RestartAnswerFile)
                    ) {
                    return FALSE;
                }
            }

            //
            // Activation.
            //
            PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
            ShowWindow( GetDlgItem(hdlg,IDC_ACCESS_ICON),   Upgrade ? SW_HIDE : SW_SHOW );
            ShowWindow( GetDlgItem(hdlg,IDT_LABEL1),        Upgrade ? SW_HIDE : SW_SHOW );
            ShowWindow( GetDlgItem(hdlg,IDB_ACCESSIBILITY), Upgrade ? SW_HIDE : SW_SHOW );

        } else {
            //
            // Deactivation.
            // Verify source if not canceling or backing up.  Stay here if the source
            // dir does not exist.
            //
            // Save so that we can init the checkbox to whatever this is.
            if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
            {
                bCopyFarEast = (IsDlgButtonChecked(hdlg,IDC_FAREAST_LANG) == BST_CHECKED);
                SelectFarEastLangGroup(bCopyFarEast );
            }

            if (!Cancelled && lParam != PSN_WIZBACK) {
                //
                // Determine if source edit control is disabled.  If it is disabled
                // and the multiple source dirs are invalid, reset the wizard page.
                //

                MultipleSource = !(SourceCount == 1);
                b = InspectSources (hdlg);

                if (!b && MultipleSource) {
                   // Reset the wizard page
                    CallWindowProc ((WNDPROC)OptionsWizPage, hdlg, WM_INITDIALOG, 0, 0);
                }

            }
        }

        break;

    case WMX_I_AM_VISIBLE:
        //
        // In the unattended case, this page might get reactivated because of an error,
        // in which case we don't want to automatically continue because we could
        // get into an infinite loop.
        //
        if(!WizPage->PerPageData) {
            WizPage->PerPageData = 1;
            UNATTENDED(PSBTN_NEXT);
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
Working1WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Animation = GetDlgItem(hdlg,IDA_COMP_MAGNIFY);
    int status;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Load the avi resource for the animation.
        //
        Animate_Open(Animation,MAKEINTRESOURCE(IDA_COMP_MAGNIFY));

        //
        // Set the subtitle correctly if we're only inspecting.
        //
        if( CheckUpgradeOnly ) {
            SetDlgItemText(hdlg,IDT_SUBTITLE,(PTSTR)TEXT("") );
        }

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:
        //
        // Start/stop the animation. In the activate case, also
        // start doing some meaningful work.
        //
        if(wParam) {
            DWORD ThreadId;

            Animate_Play(Animation,0,-1,-1);

            // Do schema version check for NT5 DCs
            // Do only if not already cancelled
            if (!Cancelled) {
                 // For NT5 DC upgrades, check for schema version match
                 if (Upgrade && ISNT() && IsNT5DC()) {
                     status  = CheckSchemaVersionForNT5DCs(hdlg);
                     if (status != DSCHECK_ERR_SUCCESS) {
                         // error in checking schema version for NT5 DCs.
                         // Setup cannot proceed, go to unsuccessful
                         // completion. all necessary message has already
                         // been raised

                         // do NOT cancel in CheckUpgradeOnly mode.
                         if (!CheckUpgradeOnly)
                         {
                             Cancelled = TRUE;
                             PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                             return( FALSE );
                         }
                     }
                 }
           }

            InspectionThreadHandle = CreateThread( NULL,
                                                   0,
                                                   InspectAndLoadThread,
                                                   hdlg,
                                                   0,
                                                   &ThreadId );

            if(InspectionThreadHandle) {
                b = TRUE;
                //
                // enable the billboard text if we can.
                // This will hide the wizard if the billboard text was enabled
                //
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
            } else {

                MessageBoxFromMessage(
                    hdlg,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
            }
        } else {
            Animate_Stop(Animation);
            b = TRUE;

        }
        break;

    case WMX_ERRORMESSAGEUP:
        //
        // Start/stop the animation control.
        //
        if(wParam) {
            Animate_Stop(Animation);
        } else {
            Animate_Play(Animation,0,-1,-1);
        }
        b = TRUE;
        break;

    case WMX_SETPROGRESSTEXT:
        //
        // lParam is the progress text.
        //
        SetDlgItemText(hdlg,IDT_WORKING,(PTSTR)lParam);
        b = TRUE;
        break;

    case WMX_INSPECTRESULT:

        //
        // We get here when the InspectionThread
        // sends us this message, so it's done.
        //
        if(InspectionThreadHandle) {
            CloseHandle(InspectionThreadHandle);
            InspectionThreadHandle = NULL;
        }

        if(Cancelled) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
        } else {

            if( !wParam ) {
                Cancelled = TRUE;
            }
            //
            // Advance or retreat.
            //
            PropSheet_SetWizButtons(
                GetParent(hdlg),
                wParam ? PSWIZB_NEXT : PSBTN_CANCEL
                );

            PropSheet_PressButton(
                GetParent(hdlg),
                wParam ? PSBTN_NEXT : PSBTN_CANCEL
                );
        }

        b = TRUE;
        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


#if defined(_AMD64_) || defined(_X86_)
INT_PTR
FloppyWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Gauge = GetDlgItem(hdlg,IDC_PROGRESS);
    HANDLE ThreadHandle;
    DWORD ThreadId;

    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Make sure the gas gauge is cleared out.
        //
        SendMessage(Gauge,PBM_SETPOS,0,0);

        //
        // Add border on NT3.51
        //
        if(OsVersion.dwMajorVersion < 4) {
            SetWindowLong(
                Gauge,
                GWL_STYLE,
                GetWindowLong(Gauge,GWL_STYLE) | WS_BORDER
                );
        }
        break;

    case WMX_ACTIVATEPAGE:
        if(wParam)
        {
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
            //
            // Activating. Only activate if we are supposed to create
            // boot floppies. Ask the floppy creation stuff how many total files
            // are to be copied and initialize the progress indicator.
            //
            if(!Floppyless) {

                if(!AddExternalParams(hdlg)) {
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    b = FALSE;
                    break;
                }

                SendMessage(hdlg,WMX_COPYPROGRESS,FloppyGetTotalFileCount(),0);

                ThreadHandle = CreateThread(
                                    NULL,
                                    0,
                                    FloppyWorkerThread,
                                    (PVOID)hdlg,
                                    0,
                                    &ThreadId
                                    );

                if(ThreadHandle) {
                    b = TRUE;
                } else {
                    //
                    // Can't get the copy thread going.
                    //
                    MessageBoxFromMessageAndSystemError(
                        hdlg,
                        MSG_CANT_START_COPYING,
                        GetLastError(),
                        AppTitleStringId,
                        MB_OK | MB_ICONWARNING
                        );

                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                }
            }
        } else {
            //
            // Deactivating.
            //
            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            b = TRUE;
        }
        break;

    case WMX_COPYPROGRESS:

        if(lParam) {
            //
            // Done copying. Advance to next page.
            //
            PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);

            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
        } else {
            if(wParam) {
                TCHAR buffer[MAX_PATH];
                //
                // This tells us how many files are to be copied.
                // Use it as an initialization message.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETPOS,0,0);

                // Show progress text on the billboard
                if (!LoadString (
                        hInst,
                        IDS_BB_COPYING,
                        buffer,
                        sizeof(buffer)/sizeof(TCHAR)
                        )) {
                    buffer[0] = 0;
                }
                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)buffer);
                // Show the progress gauge on the billboard
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);

            } else {
                //
                // This is a simple tick.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_DELTAPOS,1,0);
                // Do the same to the billoard progress
                SendMessage(GetParent(hdlg),WMX_PBM_DELTAPOS,1,0);
            }
        }
        b = TRUE;
        break;
    }

    return(b);
}
#endif

// Then nummber below are actually a little different for each SKU.
#if DBG
#define ALWAYS_COPY (13419*1024)
#define LOCALSOURCE_COPY (655322 *1024)
#else
#define ALWAYS_COPY (5020*1024)
#define LOCALSOURCE_COPY (209507 *1024)
#endif

INT_PTR
CopyingWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Gauge = GetDlgItem(hdlg,IDC_PROGRESS);
    HANDLE ThreadHandle;
    DWORD ThreadId;
    static DWORD StartCopyTime;
    static DWORD NumFile = 0;

    switch(msg) {

    case WM_INITDIALOG:

        //
        // Make sure the gas gauge is cleared out.
        //
        SendMessage(Gauge,PBM_SETPOS,0,0);

        //
        // Add border on NT3.51
        //
        if(OsVersion.dwMajorVersion < 4) {
            SetWindowLong(
                Gauge,
                GWL_STYLE,
                GetWindowLong(Gauge,GWL_STYLE) | WS_BORDER
                );
        }

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();

        if(wParam) {
            //
            // Activating -- initialize the source progress indicators and
            // start the copy thread. We do the source progress indicators here
            // to guarantee that the source count is right (it may fluctuate).
            //
            UINT i;

#if defined(_AMD64_) || defined(_X86_)
            //
            // Make sure we actually have something to copy.
            // Note that we'll always be copying for RISC.
            //
            if( (!MakeLocalSource) &&   // don't copy ~LS
                (!Floppyless) ) {       // don't copy ~BT

                DoPostCopyingStuff(hdlg);
                b = TRUE;
                break;
            }
#endif

            //
            // Before copying, allow extensions to write changes to the
            // textmode params file.
            //
            // It's legal for them to set a cancelled flag during
            // this call, so we'll need to check for that too.  This
            // looks a little odd, but info.CancelledFlag points to
            // Cancelled.  So we need to execute this block if his
            // function returns FALSE, or if he's set the Cancelled
            // flag.  In either case, we behave the same, we set
            // the Cancelled flag and proceed with a cancel.
            //
            //
            if ( (!AddExternalParams(hdlg)) ||
                 (Cancelled == TRUE) ) {
                //
                // Failed... cancel!
                //
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
                break;
            }

            if(SourceCount == 1) {
                //
                // Single-source case gets no details or anything.
                //
                for(i=0; i<MAX_SOURCE_COUNT; i++) {
                    ShowWindow(GetDlgItem(hdlg,IDT_LABEL1+i),SW_HIDE);
                    ShowWindow(GetDlgItem(hdlg,IDT_SOURCE1+i),SW_HIDE);
                }
                ShowWindow(GetDlgItem(hdlg,IDS_DETAILS),SW_HIDE);

            } else {
                //
                // Show label and file for each source we're using.
                // Disable the others.
                //
                for(i=0; i<MAX_SOURCE_COUNT; i++) {

                    ShowWindow(GetDlgItem(hdlg,IDT_LABEL1+i),SW_SHOW);
                    EnableWindow(GetDlgItem(hdlg,IDT_LABEL1+i),(i < SourceCount));

                    ShowWindow(GetDlgItem(hdlg,IDT_SOURCE1+i),SW_SHOW);
                    SetDlgItemText(hdlg,IDT_SOURCE1+i,TEXT(""));
                }
                ShowWindow(GetDlgItem(hdlg,IDS_DETAILS),SW_SHOW);
            }

            //
            // Show more detailed copy progress gauge.
            //
            StartCopyTime = GetTickCount();
            if( DetailedCopyProgress ) {
                //
                // How much have we copied?
                //
                ShowWindow( GetDlgItem(hdlg,IDT_SIZE),SW_SHOW );
                EnableWindow( GetDlgItem(hdlg,IDT_SIZE), TRUE );
                ShowWindow( GetDlgItem(hdlg,IDT_SIZE2),SW_SHOW );
                SetDlgItemText(hdlg,IDT_SIZE2,TEXT("0"));

                //
                // How long have we been at this?
                //
                ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME),SW_SHOW );
                EnableWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME), TRUE );
                ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME2),SW_SHOW );
                SetDlgItemText(hdlg,IDT_ELAPSED_TIME2,TEXT("00:00:00") );

            } else {
                //
                // Hide the details.
                //
               ShowWindow( GetDlgItem(hdlg,IDT_SIZE),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_SIZE2),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME2),SW_HIDE);
            }

            SendMessage(hdlg,WMX_COPYPROGRESS,GetTotalFileCount(),0);

            ThreadHandle = CreateThread(
                                NULL,
                                0,
                                StartCopyingThread,
                                (PVOID)hdlg,
                                0,
                                &ThreadId
                                );

            if(ThreadHandle) {
                b = TRUE;
            } else {
                //
                // Can't get the copy thread going.
                //
                MessageBoxFromMessageAndSystemError(
                    hdlg,
                    MSG_CANT_START_COPYING,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING
                    );

                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
            }
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);

        } else {
            //
            // Deactivating.
            //
            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            b = TRUE;
        }
        break;

    case WMX_COPYPROGRESS:

        if(lParam) {
            //
            // Done copying. On amd64/x86, set up boot.ini (etc).
            // Also save NTFT stuff.
            // Advance to next page.
            //
            ThreadHandle = CreateThread(NULL,0,DoPostCopyingStuff,hdlg,0,&ThreadId);
            if(ThreadHandle) {
                CloseHandle(ThreadHandle);
            } else {
                //
                // Just do it synchronously. Might look a little ugly but at least
                // it will get done.
                //
                DoPostCopyingStuff(hdlg);
            }
        } else {
            if(wParam) {
                TCHAR buffer[MAX_PATH];
                //
                // This tells us how many files are to be copied.
                // Use it as an initialization message.
                //
                CurrentPhase = Phase_FileCopy;
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETPOS,0,0);

                // Show progress text on the billboard
                if (!LoadString (
                        hInst,
                        IDS_BB_COPYING,
                        buffer,
                        sizeof(buffer)/sizeof(TCHAR)
                        )) {
                    buffer[0] = 0;
                }
                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)buffer);
                // Show the progress gauge on the billboard
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);
            } else {
                //
                // This is a simple tick.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_DELTAPOS,1,0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_DELTAPOS,1,0);
                //
                NumFile++;

                // Are giving the user detailed timings?
                //
                if( DetailedCopyProgress ) {
                TCHAR   MyString[256];
                DWORD   ElapsedTime = ((GetTickCount() - StartCopyTime) / 1000);

                    //
                    // Figure out elapsed time.
                    //
                    wsprintf( MyString, TEXT( "%02d:%02d:%02d" ),
                              (ElapsedTime / 3600),         // hours
                              ((ElapsedTime % 3600) / 60),  // minutes
                              (ElapsedTime % 60) );         // seconds
                    SetDlgItemText( hdlg, IDT_ELAPSED_TIME2, MyString );

                    //
                    // Figure out data throughput.
                    //
                    if (GetUserPrintableFileSizeString(
                                TotalDataCopied,
                                MyString,
                                sizeof(MyString)/sizeof(TCHAR))) {
                        SetDlgItemText( hdlg, IDT_SIZE2, MyString );
                    }
                }

            }
        }
        b = TRUE;
        break;

    case WMX_I_AM_DONE:
        //
        // Advance to next page or bail.
        //
        if(wParam) {
        TCHAR   MyString[256];
        TCHAR   Size[256];
        DWORD   ElapsedTime = ((GetTickCount() - StartCopyTime) / 1000);

            //
            // Figure out elapsed time.
            //
            if (GetUserPrintableFileSizeString(
                                        TotalDataCopied,
                                        Size,
                                        sizeof(Size)/sizeof(TCHAR))) {
                wsprintf( MyString, TEXT( "%s copied.  Elapsed time: %02d:%02d:%02d\r\n" ),
                          Size,                         // How much data did we copy?
                          (ElapsedTime / 3600),         // hours
                          ((ElapsedTime % 3600) / 60),  // minutes
                          (ElapsedTime % 60) );         // seconds

                //
                // Log our data throughput along with the time it took.
                //
                DebugLog( Winnt32LogInformation,
                      MyString,
                      0 );

            }

            PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        } else {
            Cancelled = TRUE;
            PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
        }

        // Set the remaining time to what ever is left for the other parts of setup.
        SetRemainingTime(CalcTimeRemaining(Phase_RestOfSetup));

        // Hide the billboard progress gauge.
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

        b = TRUE;
        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
DoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
#define ID_REBOOT_TIMER         (10)

    BOOL        b = FALSE;
    PWSTR       p;
        static UINT Countdown;
    TCHAR Text[MAX_PATH];

    switch(msg) {

    case WM_INITDIALOG:

        Countdown = TIME_REBOOT * 10;
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETRANGE,
                            0,
                            MAKELONG(0,Countdown) );
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETSTEP,
                            1,
                            0 );
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETPOS,
                            0,
                            0 );
        SetTimer( hdlg,
                  ID_REBOOT_TIMER,
                  100,
                  NULL );

        SetFocus(GetDlgItem(hdlg,IDNORESTART));

        return( FALSE );

    case WM_TIMER:

        if( Countdown )
            Countdown--;

        if( Cancelled == TRUE ) {

            //
            // Put a note in the debug log so that we know this was cancelled.
            //
            DebugLog (Winnt32LogInformation, NULL, MSG_WINNT32_CANCELLED);

            //
            // Clean up the timer.
            //
            KillTimer( hdlg, ID_REBOOT_TIMER );
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));



        } else {
            if( Countdown ) {
                SendDlgItemMessage( hdlg,
                                    IDC_PROGRESS1,
                                    PBM_STEPIT,
                                    0,
                                    0 );
                SendMessage(GetParent(hdlg),WMX_PBM_STEPIT,0,0);
            } else {
                if( !CancelPending )
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
            }

        }

        b = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        if( BuildCmdcons ) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        }

        if( CheckUpgradeOnly ) {
            AutomaticallyShutDown = FALSE;
            return( FALSE );
        }

        DebugLog (Winnt32LogInformation,
            TEXT("AutomaticallyShutDown: <%1!u!>"), 0, AutomaticallyShutDown);

        if ( AutomaticallyShutDown ) {
            if(LoadString(hInst,IDS_BB_REBOOT_TXT,Text,sizeof(Text) / sizeof(TCHAR)))
            {
                COLORREF colGauge;
                HDC hdc = GetDC(hdlg);

                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

                // See what color the grow bar should be for the reboot count down
                if ((UINT) GetDeviceCaps(hdc, BITSPIXEL) > 8)
                {
                    // High color
                    colGauge = RGB(255, 64, 0); // Orange
                }
                else
                {
                    // Low color
                    colGauge = RGB(255, 0, 0); // Red
                }
                ReleaseDC(hdlg, hdc);

                CurrentPhase = Phase_Reboot;
                if(!LoadString(hInst,IDS_ESC_TOCANCEL_REBOOT,Text,sizeof(Text) / sizeof(TCHAR)))
                {
                    *Text = TEXT('\0');
                }
                BB_SetInfoText(Text );   // Replace the ESC text
                StartStopBB(FALSE);         // Only stop the billoard text, don't make the wizard visibl

                // Show the grow bar on the billboard for the reboot count donw
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // Set the color to some red
                SendMessage(GetParent(hdlg), WMX_PBM_SETBARCOLOR, 0, (LPARAM)colGauge);
                // Setup the growbar ont eh billboard for the reboot count down.
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,Countdown));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);
                SendMessage(GetParent(hdlg),WMX_PBM_SETSTEP,1,0);
            }
        }
        //
        // Accept activation/deactivation.
        //
        b = TRUE;
        break;

    case WM_COMMAND:

        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDNORESTART)) {
            AutomaticallyShutDown = FALSE;
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        } else {
            return(FALSE);
        }
        break;


    case WMX_QUERYCANCEL:
        AutomaticallyShutDown = FALSE;
        *(BOOL*)lParam = FALSE; // Don't cancel setup, just don't reboot.
        b = TRUE;
        PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        break;


    case WMX_FINISHBUTTON:
        //
        // If we get here then we have been successful.
        // No other case indicates overall success.
        //

        //
        // Clean up the timer.
        //
        KillTimer( hdlg, ID_REBOOT_TIMER );
        DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));

        //
        // Let upgrade code do its cleanup.
        //
        if(UpgradeSupport.CleanupRoutine) {
            UpgradeSupport.CleanupRoutine();
        }

        GlobalResult = TRUE;
        b = TRUE;

        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
CleaningWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HWND Animation = GetDlgItem(hdlg,IDA_COMP_MAGNIFY);

    b = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Load the avi resource for the animation.
        //
        Animate_Open(Animation,MAKEINTRESOURCE(IDA_COMP_MAGNIFY));
        break;

    case WMX_ACTIVATEPAGE:

        if(wParam) {
            //
            // Disable the wizard cancel button.
            //
            EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
            PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

        } else {
            //
            // Kill the animation.
            //
            Animate_Stop(Animation);
        }
        b = TRUE;
        break;

    case WMX_I_AM_VISIBLE:

        Animate_Play(Animation,0,-1,-1);
        SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        //
        // Our inspection thread hasn't finished.  He'll be
        // looking for the 'Cancelled' flag and he'll stop processing
        // the infs (i.e. building the copylist) when he sees it.
        //
        // If we proceed before he exits though, winnt32.exe will unload
        // winnt32u.dll while our thread is running, causing an AV.  Let's
        // give him a reasonable amount of time to finish before we
        // proceed.
        //
        // On Alpha, we can also hit a race condition where we think we
        // need to clean up NVRAM but are still in the middle of writing
        // it (because it takes a really long time to write).  This
        // fixes that too.
        //
        if( InspectionThreadHandle ) {
            WaitForSingleObject( InspectionThreadHandle, 20 * (1000) );
            CloseHandle(InspectionThreadHandle);
            InspectionThreadHandle = NULL;
        }

        //
        // Start the restoration process.
        //
        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            StartCleanup,
                            hdlg,
                            0,
                            &ThreadId
                            );

        if(ThreadHandle) {
            CloseHandle(ThreadHandle);
        } else {
            //
            // Just do it synchronously. It won't look pretty
            // but it will at least get done.
            //
            StartCleanup(hdlg);
        }

        b = TRUE;
        break;

    case WMX_I_AM_DONE:

        //
        // Cleanup is done. Press the next button to advance to
        // the next page.
        //
        PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        break;
    }

    return(b);
}


INT_PTR
NotDoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;

    b = FALSE;
    switch(msg) {

    case WMX_ACTIVATEPAGE:

        //
        // Accept activation/deactivation.
        //
        b = TRUE;

#ifdef PRERELEASE
        {
            TCHAR DllPath[MAX_PATH];
            TCHAR *p, *q;
            STARTUPINFO StartupInfo;
            PROCESS_INFORMATION ProcessInfo;
            TCHAR szCommand [MAX_PATH + 120];

         //
         // Cancel IDWLOG
         // Remove this code before shipping
         //
         if ( MyGetModuleFileName (NULL, DllPath, MAX_PATH)) {

            for (q=NULL,p=DllPath; *p; p=CharNext(p)) {
               // the char '\' is never a lead byte
               if (*p == TEXT('\\')) {
                  q = p;
               }
            }
              lstrcpy(q ? q+1 : DllPath,TEXT("IDWLOG.EXE -0"));
              lstrcpy(szCommand,DllPath);

              ZeroMemory(&StartupInfo,sizeof(StartupInfo));
              StartupInfo.cb = sizeof(StartupInfo);
              if(CreateProcess(NULL, szCommand,NULL,NULL,FALSE,0,NULL,NULL,&StartupInfo,&ProcessInfo)) {
                 CloseHandle(ProcessInfo.hProcess);
                 CloseHandle(ProcessInfo.hThread);
              }
            }

        }
#endif // PRERELEASE
#ifdef RUN_SYSPARSE
        if (!NoSysparse && (FALSE == BuildCmdcons)  && piSysparse.hProcess && !IsWinPEMode()) {
            DWORD ret;
            ret = WaitForSingleObject( piSysparse.hProcess, 0);
            if( ret != WAIT_OBJECT_0) {
                TerminateProcess( piSysparse.hProcess, ERROR_TIMEOUT);
                CloseHandle(piSysparse.hProcess);
                CloseHandle(piSysparse.hThread);
                piSysparse.hProcess = NULL;
                DebugLog(Winnt32LogInformation, TEXT("Warning: Sysparse.exe did not finish, killing process."), 0 );
            }
        }
#endif
        if (Aborted || CheckUpgradeOnly || BatchMode) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        }
        break;

    }

    return(b);
}


void SetRemainingTime(DWORD TimeInSeconds)
{
    DWORD Minutes;
    TCHAR MinuteString[MAX_PATH];
    TCHAR TimeLeft[MAX_PATH];
    Minutes = ((TimeInSeconds)/60) +1;
    if (Minutes > 1)
    {
        if(!LoadString(hInst,IDS_TIMEESTIMATE_MINUTES,MinuteString, MAX_PATH))
        {
            lstrcpy(MinuteString,TEXT("Installation will complete in %d minutes or less."));
        }
        wsprintf(TimeLeft, MinuteString, Minutes);
    }
    else
    {
        if(!LoadString(hInst,IDS_TIMEESTIMATE_LESSTHENONEMINUTE,TimeLeft, MAX_PATH))
        {
            lstrcpy(TimeLeft,TEXT("Installation will complete in less then 1 minute."));
        }
    }
    BB_SetTimeEstimateText(TimeLeft);
}

void SetTimeEstimates()
{

    SetupPhase[Phase_DynamicUpdate].Time = GetDynamicUpdateEstimate();
    if (CheckUpgradeOnly)
    {
        // In CheckUpgradeOnly, we don't copy files and do continue setup.
        // and it can only be set from the command line, so the user can not change.
        SetupPhase[Phase_FileCopy].Time = 0;
        SetupPhase[Phase_RestOfSetup].Time = 0;
    }
    else
    {
        SetupPhase[Phase_FileCopy].Time = GetFileCopyEstimate();

        if (!Upgrade)
        {
            SetupPhase[Phase_HwCompatDat].Time = 0;
            SetupPhase[Phase_UpgradeReport].Time = 0;
        }
        else
        {
            if (!ISNT())
            {
                // Is there a way to find out if we need to update the hwcomp.dat file?
                SetupPhase[Phase_HwCompatDat].Time = GetHwCompDatEstimate();

                SetupPhase[Phase_UpgradeReport].Time = GetUpgradeReportEstimate();
            }
        }
        // Calc the time for the rest of setup.
        // The Win9x migration varies depending on the registery size.
        // The GetRestOfSetupEstimate takes care of that.
        SetupPhase[Phase_RestOfSetup].Time = GetRestOfSetupEstimate();
    }
}

// Returns the time remaining starting with the current "Phase"
DWORD CalcTimeRemaining(UINT Phase)
{
    UINT i;
    DWORD Time = 0;
    for (i = Phase; i<= Phase_RestOfSetup; i++)
    {
        if (SetupPhase[i].OS & OsVersion.dwPlatformId)
        {
            Time += SetupPhase[i].Time;
        }
    }
    return Time;
}

INT_PTR TimeEstimateWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    switch(msg)
    {
        case WMX_ACTIVATEPAGE:
            if(wParam)
            {
                SetTimeEstimates();
                CurrentPhase = Phase_DynamicUpdate;
                RemainingTime = CalcTimeRemaining(CurrentPhase);
                SetRemainingTime(RemainingTime);
            }
            break;

        default:

            b = FALSE;
            break;
    }

    return(b);
}

INT_PTR SetNextPhaseWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    switch(msg)
    {
        case WMX_ACTIVATEPAGE:
            if(wParam)
            {
                CurrentPhase++;
                while ((!SetupPhase[CurrentPhase].Clean & !Upgrade) ||
                       !(SetupPhase[CurrentPhase].OS & OsVersion.dwPlatformId))
                {
                    CurrentPhase++;
                }
                RemainingTime = CalcTimeRemaining(CurrentPhase);
                SetRemainingTime(RemainingTime);
            }
            break;

        default:

            b = FALSE;
            break;
    }

    return(b);
}

void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime)
{
    // If the previous displayed time is 1 minute old, update the time remaining.
    if ((*PreviousRemainingTime >= 60000) && ((*PreviousRemainingTime - 60000) > RemainungTimeMsecInThisPhase))
    {
        // Substract one minute.
        RemainingTime -= 60;
        *PreviousRemainingTime = RemainungTimeMsecInThisPhase;
        SetRemainingTime(RemainingTime);
    }
}

DWORD GetHwCompDatEstimate()
{
    return TIME_HWCOMPDAT;
}

DWORD GetUpgradeReportEstimate()
{
    return TIME_UPGRADEREPORT ;
}

DWORD GetDynamicUpdateEstimate()
{
    return 0;
}

DWORD GetFileCopyEstimate()
{
    // dosnet.inf and the TempDirSpace512 numbers look ok.
    //
    DWORD TimeEstimate = 1;
    UINT u;
    TCHAR infPath[MAX_PATH];
    TCHAR CopyEstimate[100];
    TCHAR *p;
    BOOL bFound = FALSE;
    DWORD AlwaysCopy = 0;
    DWORD LocalCopy = 0;
    DWORD Time;
    //
    // Get the numbers from dosnet.inf
    //
    if (AlternateSourcePath[0])
    {
        lstrcpy(infPath,AlternateSourcePath);
        ConcatenatePaths(infPath,InfName,MAX_PATH);
        bFound = FileExists(infPath, NULL);
    }
    if (!bFound)
    {
        u = 0;
        do
        {
            lstrcpy(infPath,NativeSourcePaths[u]);
            ConcatenatePaths(infPath,InfName,MAX_PATH);
            bFound = FileExists(infPath, NULL);
            u++;
        } while ((u<=SourceCount) && !bFound);
    }

    if (bFound)
    {
        // Get the diskspace numbers. We use them to determine the copy size and
        // with that determine the time estimate.
        // We don't need to worry about the cluster size, we only want the byte
        // amount copied. Therefore the 512byte cluster is good enough.
        //
        GetPrivateProfileString(TEXT("DiskSpaceRequirements"), TEXT("TempDirSpace512"),
                                TEXT("0"),
                                CopyEstimate, sizeof(CopyEstimate)/sizeof(TCHAR),
                                infPath);
        //
        // Now get the separate diskspace numbers.
        // If we have a comma, then there are 2 values.
        p = _tcschr(CopyEstimate,TEXT(','));
        if (p)
        {
            // Get the second value
            p++;
            AlwaysCopy = _tcstoul(p,NULL,10);
        }
        LocalCopy = _tcstoul(CopyEstimate,NULL,10);

    }
    else
    {
        // If we could not find the file, use some value.
        // Setup should fail later when we need the file.
        //
        AlwaysCopy = ALWAYS_COPY;
        LocalCopy = LOCALSOURCE_COPY;
    }

    //
    // To avoid divide by zero exception, if we could not
    // calculate throughput, assume it to be the default.
    //
    if (!dwThroughPutSrcToDest) {
        dwThroughPutSrcToDest = DEFAULT_IO_THROUGHPUT;
    }

    if (AlwaysCopy >= dwThroughPutSrcToDest)
    {
        TimeEstimate = AlwaysCopy / dwThroughPutSrcToDest;
        if (TimeEstimate >= 1000)
        {
            TimeEstimate = (TimeEstimate / 1000) + 1;
        }
        else
        {
            TimeEstimate = 1;
        }
    }


    if (MakeLocalSource && (LocalCopy >= dwThroughPutSrcToDest))
    {
        Time = LocalCopy / dwThroughPutSrcToDest;
        if (Time >= 1000)
        {
            Time = (Time / 1000) + 1;
        }
        else
        {
            Time = 1;
        }
        TimeEstimate += Time;
    }
    TimeEstimate = TimeEstimate * 125/100; // Add 25% for other overhead

    wsprintf(infPath, TEXT("Throughput src - dest is %d bytes per msec\r\n"), dwThroughPutSrcToDest);
    DebugLog(Winnt32LogInformation,infPath,0 );
    wsprintf(infPath, TEXT("Throughput HD - HD is %d bytes per msec\r\n"), dwThroughPutHDToHD);
    DebugLog(Winnt32LogInformation,infPath,0 );
    wsprintf(infPath, TEXT("%d bytes copied, should take %d Sec\r\n"), AlwaysCopy+LocalCopy, TimeEstimate);
    DebugLog(Winnt32LogInformation,infPath,0 );
    return TimeEstimate;
}

LPTSTR WinRegisteries[] = { TEXT("system.dat"),
                            TEXT("User.dat"),
                            TEXT("classes.dat"),
                            TEXT("")};

DWORD GetRestOfSetupEstimate()
{
    DWORD dwTime = TIME_RESTOFSETUP;
    DWORD dwSize = 0;
    TCHAR szRegPath[MAX_PATH];
    TCHAR szRegName[MAX_PATH];
    LPTSTR pRegName = NULL;
    UINT    index = 0;
    HANDLE          hFind;
    WIN32_FIND_DATA FindData;

    if (!ISNT() && Upgrade)
    {
        DebugLog(Winnt32LogInformation, TEXT("Calculating registery size"), 0 );
        if (GetWindowsDirectory(szRegPath, MAX_PATH))
        {
            dwTime = 0; // We calculate the time from the registery size.
            while (*WinRegisteries[index])
            {
                lstrcpy(szRegName, szRegPath);
                ConcatenatePaths( szRegName, WinRegisteries[index], MAX_PATH);
                hFind = FindFirstFile(szRegName, &FindData);
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    DebugLog (Winnt32LogInformation,
                              TEXT("%1 size is: %2!ld!"),
                              0,
                              szRegName,
                              FindData.nFileSizeLow
                              );
                    // Don't worry about the nFileSizeHigh,
                    // if that is used the registery is over 4GB
                    dwSize += FindData.nFileSizeLow;
                    FindClose(hFind);
                }
                index++;
            }
            if (dwSize > 3000000)
            {
                dwSize -= 3000000;
                dwTime += (dwSize/9000);
            }
            DebugLog (Winnt32LogInformation,
                      TEXT("Calculated time for Win9x migration = %1!ld! seconds"),
                      0,
                      dwTime + 120); // 120 = base time for Win9x migration
            // Now add the rest of time needed for setup.
            // This includes the base time we estimate for the Win9x migration (120 seconds)
            dwTime+= TIME_RESTOFSETUP;
        }
    }

    return dwTime;
}

#if defined(_X86_)

ULONGLONG
pSystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}


INT_PTR
Win9xUpgradeReportPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    INT mode;
    static BOOL getFromUi = FALSE;
    HKEY key;
    LONG rc;
    SYSTEMTIME lastReport;
    SYSTEMTIME currentTime;
    ULONGLONG lastReportIn100Ns;
    ULONGLONG currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD size;

    switch(msg) {

    case WM_INITDIALOG:
        break;

    case WMX_ACTIVATEPAGE:

        if(wParam) {
            //
            // Activation case
            //

            if (ISNT() || !Upgrade) {
                return FALSE;
            }

            if (CheckUpgradeOnly || UnattendedOperation) {
                g_UpgradeReportMode = IDC_ALL_ISSUES;
                return FALSE;
            }

            //
            // Dynamic update -- fetch caller's selection from answer file
            //

            if (Winnt32RestartedWithAF ()) {
                g_UpgradeReportMode = GetPrivateProfileInt (
                                            WINNT_UNATTENDED,
                                            WINNT_D_REPORTMODE,
                                            0,
                                            g_DynUpdtStatus->RestartAnswerFile
                                            );

                if (g_UpgradeReportMode == IDC_CRITICAL_ISSUES ||
                    g_UpgradeReportMode == IDC_ALL_ISSUES ||
                    g_UpgradeReportMode == IDC_NO_REPORT
                    ) {
                    //
                    // We got our answer -- skip page
                    //

                    return FALSE;
                }
            }

            //
            // Check the registry to see if the report has been
            // generated recently.
            //

            rc = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                    0,
                    KEY_READ,
                    &key
                    );

            if (rc == ERROR_SUCCESS) {
                size = sizeof (lastReport);
                rc = RegQueryValueEx (
                        key,
                        TEXT("LastReportTime"),
                        NULL,
                        NULL,
                        (PBYTE) (&lastReport),
                        &size
                        );

                RegCloseKey (key);

                if (rc == ERROR_SUCCESS) {
                    //
                    // Compare current time to report time
                    //

                    GetSystemTime (&currentTime);

                    lastReportIn100Ns = pSystemTimeToFileTime64 (&lastReport);
                    currentTimeIn100Ns = pSystemTimeToFileTime64 (&currentTime);

                    if (currentTimeIn100Ns > lastReportIn100Ns) {
                        //
                        // Compute difference in seconds
                        //

                        difference = currentTimeIn100Ns - lastReportIn100Ns;
                        difference /= (10 * 1000 * 1000);

                        if (difference < (30 * 60)) {
                            //
                            // Report was saved less than 30 minutes ago
                            // from compatibility checker; don't show it again.
                            //

                            DebugLog (
                                Winnt32LogInformation,
                                TEXT("Not showing report because /checkupgradeonly ran %1!i! seconds ago"),
                                0,
                                (INT) difference
                                );

                            g_UpgradeReportMode = IDC_NO_REPORT;
                            return FALSE;
                        }
                    }
                }
            }

            //
            // Validate the selection
            //

            if (g_UpgradeReportMode != IDC_CRITICAL_ISSUES &&
                g_UpgradeReportMode != IDC_ALL_ISSUES &&
                g_UpgradeReportMode != IDC_NO_REPORT
                ) {
                g_UpgradeReportMode = IDC_CRITICAL_ISSUES;
            }

            //
            // Update the UI
            //

            CheckDlgButton (
                hdlg,
                IDC_CRITICAL_ISSUES,
                g_UpgradeReportMode == IDC_CRITICAL_ISSUES ? BST_CHECKED : BST_UNCHECKED
                );

            CheckDlgButton (
                hdlg,
                IDC_ALL_ISSUES,
                g_UpgradeReportMode == IDC_ALL_ISSUES ? BST_CHECKED : BST_UNCHECKED
                );

            CheckDlgButton (
                hdlg,
                IDC_NO_REPORT,
                g_UpgradeReportMode == IDC_NO_REPORT ? BST_CHECKED : BST_UNCHECKED
                );

            SetFocus (GetDlgItem (hdlg, g_UpgradeReportMode));
            getFromUi = TRUE;

        } else {
            //
            // Deactivation case
            //

            if (!getFromUi) {
                return TRUE;
            }

            //
            // Get selection from UI
            //

            if (IsDlgButtonChecked (hdlg, IDC_CRITICAL_ISSUES) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_CRITICAL_ISSUES;
            } else if (IsDlgButtonChecked (hdlg, IDC_ALL_ISSUES) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_ALL_ISSUES;
            } else if (IsDlgButtonChecked (hdlg, IDC_NO_REPORT) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_NO_REPORT;
            }

            getFromUi = FALSE;
        }

        b = TRUE;
        break;
    }

    return(b);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\appcompattest\precomp.h ===
#include "winnt32.h"
#include "msg.h"
#include <mountmgr.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\unicode\precomp.h ===
#include "winnt32.h"
#include "msg.h"
#include <mountmgr.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\amd64\download.h ===
#include "..\i386\download.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\winnt32.h ===
#define IDS_APPNAME             1
#define IDS_DLLERROR            2
#define IDS_VERERROR            3
#define IDS_PATHERROR           4
#define IDD_SETUPINIT         101
#define IDB_INIT_WIN2000      102
#define IDC_BITMAP           1001
#define IDC_TEXT             1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\amd64\download.c ===
#include "..\i386\download.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\winnt32.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winnt32.c

Abstract:

    Stub loader for WinNT Setup program files.

Author:


Revisions:

    Ovidiu Temereanca (ovidiut)  09-Dec-1998

--*/

#include <windows.h>
#include <winver.h>
#include <ntverp.h>
#include <setupbat.h>
#include "winnt32.h"
#include "winnt32p.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

#if defined(_AMD64_) || defined(_X86_)

#if defined(_AMD64)

#include "amd64\download.h"

#else

#include "i386\download.h"

#endif

#define INTERNAL_WINNT32_DIR  TEXT("\\WINNT32")
#define MAX_RETRY_INTERVAL_SECONDS  3600L

#endif

#define MAX_UPGCHK_ELAPSED_SECONDS  (30 * 60)
#define S_CHKSUM_FILE           TEXT("DOSNET.INF")

#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))

#define ALLOC_TEXT(chars)       ((PTSTR)HeapAlloc (GetProcessHeap (), 0, ((chars) + 1) * sizeof (TCHAR)))
#define FREE(p)                 HeapFree (GetProcessHeap (), 0, p)
#define CHARS(string)           (sizeof (string) / sizeof ((string)[0]) - 1)

#define pFindEOS(String) pFindChar(String, 0)


PTSTR
FindLastWack (
    IN      PTSTR String
    )

/*++

Routine Description:

  FindLastWack returns a pointer to the last backslash character
  in the String

Arguments:

  String - Specifies the string

Return Value:

  The position of the last '\\' in the string or NULL if not found.

--*/

{
    PTSTR p;
    PTSTR LastChar = NULL;

    for(p = String; *p; p = CharNext(p)) {
        if(*p == TEXT('\\')) {      // the char '\' is never a lead byte
            LastChar = p;
        }
    }

    return LastChar;
}


PTSTR
DuplicateText (
    IN      PCTSTR Text
    )

/*++

Routine Description:

  DuplicateText allocates memory and then copies a source string into that memory.
  Caller is responsible for freeing that memory.

Arguments:

  Text - Specifies the source text

Return Value:

  A pointer to the duplicate string; NULL if not enough memory.

--*/

{
    PTSTR Dup;

    Dup = ALLOC_TEXT(lstrlen (Text));
    if (Dup) {
        lstrcpy (Dup, Text);
    }

    return Dup;
}


PTSTR
pFindChar (
    IN      PTSTR String,
    IN      UINT Char
    )

/*++

Routine Description:

  pFindChar returns a pointer to the first occurence of the Char
  in the String

Arguments:

  String - Specifies the string

  Char - Specifies the char to look for; can be null

Return Value:

  A pointer to the first occurence of the char in this string
  or NULL if not found

--*/

{
    while (*String) {

        if ((UINT)*String == Char) {
            return String;
        }

        String = CharNext (String);
    }

    return Char ? NULL : String;
}


VOID
ConcatenatePaths (
    IN      PTSTR LeadingPath,
    IN      PCTSTR TrailingPath
    )

/*++

Routine Description:

  ConcatenatePaths concatenates the two given paths, taking care to
  insert only one backslash between them. The resulting path is stored
  in LeadingPath.

Arguments:

  LeadingPath - Specifies the leading path

  TrailingPath - Specifies the trailing path

Return Value:

  none

--*/

{
    PTSTR p;

    //
    // check for "\" at the end of leading dir
    //
    p = FindLastWack (LeadingPath);
    if (!p) {
        p = pFindEOS (LeadingPath);
#pragma prefast(suppress:11, p is never NULL because 0 is ALWAYS found as the string terminator)
        *p++ = TEXT('\\');
    } else {
        if (*(p + 1) == 0) {
            p++;
        } else {
            p = pFindEOS (p);
            *p++ = TEXT('\\');
        }
    }
    //
    // check for "\" at the beginning of trailing dir
    //
    if (*TrailingPath == TEXT('\\')) {
        TrailingPath++;
    }
    lstrcpy (p, TrailingPath);
}


BOOL
GetFileVersion (
    IN      PCTSTR FilePath,
    OUT     PDWORD FileVersionMS,       OPTIONAL
    OUT     PDWORD FileVersionLS        OPTIONAL
    )
{
    DWORD dwLength, dwTemp;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    BOOL b = FALSE;

    if (GetFileAttributes (FilePath) != (DWORD)-1) {
        if (dwLength = GetFileVersionInfoSize ((PTSTR)FilePath, &dwTemp)) {
            if (lpData = LocalAlloc (LPTR, dwLength)) {
                if (GetFileVersionInfo ((PTSTR)FilePath, 0, dwLength, lpData)) {
                    if (VerQueryValue (lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                        if (FileVersionMS) {
                            *FileVersionMS = VsInfo->dwFileVersionMS;
                        }
                        if (FileVersionLS) {
                            *FileVersionLS = VsInfo->dwFileVersionLS;
                        }
                        b = TRUE;
                    }
                }
                LocalFree (lpData);
            }
        }
    }

    return b;
}

#if defined(_AMD64_) || defined(_X86_)

BOOL
pReRun (
    IN      PCTSTR StartDir,
    IN      PCTSTR WackExeName,
    IN      PCTSTR CmdLineArguments,
    IN      PCTSTR DefSourcesDir        OPTIONAL
    )

/*++

Routine Description:

  pReRun tries to launch a instance of this exe from a local drive,
  specifing an additional command line parameter (/S:<Source_Dir>).

Arguments:

  StartDir - Specifies the starting directory from where the instance will be launched

  WackExeName - Specifies the file name only of the EXE to launch, preceded
                by a backslash

  CmdLineArguments - Specifies the command line arguments initially supplied

  DefSourcesDir - Specifies the default directory containing instalation files

Return Value:

  TRUE if the launch was successful

--*/

{
    PTSTR CmdLine;
    INT Chars;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION pi;
    BOOL b = FALSE;
    DWORD rc;

    Chars = lstrlen (StartDir) + lstrlen (WackExeName) + CHARS(" ") + lstrlen (CmdLineArguments);
    if (DefSourcesDir) {
        Chars += CHARS(" /S:") + lstrlen (DefSourcesDir);
    }

    CmdLine = ALLOC_TEXT(Chars);
    if (!CmdLine) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    lstrcpy (CmdLine, StartDir);
    lstrcat (CmdLine, WackExeName);
    lstrcat (CmdLine, TEXT(" "));
    lstrcat (CmdLine, CmdLineArguments);
    if (DefSourcesDir) {
        lstrcat (CmdLine, TEXT(" /S:"));
        lstrcat (CmdLine, DefSourcesDir);
    }

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    b = CreateProcess (
            NULL,
            CmdLine,
            NULL,
            NULL,
            FALSE,
            NORMAL_PRIORITY_CLASS,
            NULL,
            StartDir,
            &StartupInfo,
            &pi
            );

    rc = GetLastError ();

    FREE (CmdLine);

    SetLastError (rc);
    return b;
}


BOOL
pCleanup (
    VOID
    )

/*++

Routine Description:

  pCleanup deletes all locally installed files and marks current running
  instance for deletion the next time system will reboot.

Arguments:

  none

Return Value:

  TRUE if the operation completed successfully; the machine will need to
  reboot before actual complete delete will take place.

--*/

{
    TCHAR RunningInstancePath[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    BOOL b;
    DWORD StartingTime;
    PCTSTR p;

    if (!GetModuleFileName (NULL, RunningInstancePath, MAX_PATH)) {
        return FALSE;
    }

    //
    // wait until WINNT32\WINNT32.EXE file can be deleted
    // or the retry interval of time elapses
    //
    if (!GetWindowsDirectory (Buffer, MAX_PATH)) {
        return FALSE;
    }

    if (FAILED(StringCbCat(Buffer, sizeof(Buffer), INTERNAL_WINNT32_DIR))) {
        return FALSE;
    }

    p = FindLastWack ((PTSTR)RunningInstancePath);
    if (!p) {
        return FALSE;
    }
    
    if (FAILED(StringCbCat (Buffer, sizeof(Buffer), p))) {
        return FALSE;
    }

    StartingTime = GetTickCount ();
    while (GetFileAttributes (Buffer) != (DWORD)-1) {
        //
        // try to delete it
        //
        if (DeleteNode (Buffer)) {
            break;
        }
        //
        // give up if time elapses
        //
        if (GetTickCount () - StartingTime > 1000L * MAX_RETRY_INTERVAL_SECONDS) {
            break;
        }
        //
        // nothing useful to do; let the other processes run
        //
        Sleep (0);
    }

    //
    // wait until WINNT32\SETUPLOG.EXE file can be deleted
    // or the retry interval of time elapses
    //
    if (!GetWindowsDirectory (Buffer, MAX_PATH)) {
        return FALSE;
    }
    
    StringCbCat (Buffer, sizeof(Buffer), INTERNAL_WINNT32_DIR);
    
    if (FAILED(StringCbCat (Buffer, sizeof(Buffer), TEXT("\\SETUPLOG.EXE")))) {
        return FALSE;
    }

    StartingTime = GetTickCount ();
    while (GetFileAttributes (Buffer) != (DWORD)-1) {
        if (DeleteNode (Buffer)) {
            break;
        }
        if (GetTickCount () - StartingTime > 1000L * MAX_RETRY_INTERVAL_SECONDS) {
            break;
        }
        Sleep (0);
    }

    if (!GetWindowsDirectory (Buffer, MAX_PATH)) {
        return FALSE;
    }
    
    if (FAILED(StringCbCat (Buffer, sizeof(Buffer), INTERNAL_WINNT32_DIR))) {
        return FALSE;
    }

    b = DeleteNode (Buffer);

    if (!GetWindowsDirectory (Buffer, MAX_PATH)) {
        return FALSE;
    }
    
    if (FAILED(StringCbCat (Buffer, sizeof(Buffer), TEXT("\\WININIT.INI")))) {
        return FALSE;
    }

    return
        WritePrivateProfileString (TEXT("rename"), TEXT("NUL"), RunningInstancePath, Buffer) && b;
}


BOOL
pShouldDownloadToLocalDisk (
    IN      PTSTR Path
    )

/*++

Routine Description:

  pShouldDownloadToLocalDisk returns TRUE if winnt32 files should be
  downloaded to a local disk first (like in the case of sources on
  a remote disk or on a CD)

Arguments:

  Path - Specifies the path

Return Value:

  TRUE if the specified path is on an untrusted media

--*/

{
    TCHAR ch;
    BOOL Remote = TRUE;
    UINT type;

    if (Path[1] == TEXT(':') && Path[2] == TEXT('\\')) {
        ch = Path[3];
        Path[3] = 0;
        type = GetDriveType (Path);
        Remote = (type == DRIVE_REMOTE) || (type == DRIVE_CDROM);
        Path[3] = ch;
    }
    return Remote;
}


VOID
pCenterWindowOnDesktop (
    HWND WndToCenter
    )

/*++

Routine Description:

    Centers a dialog relative to the 'work area' of the desktop.

Arguments:

    WndToCenter - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}


BOOL CALLBACK DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
)

/*++

Routine Description:

  This is the callback procedure for the dialog displayed while
  components are copied from the network

Arguments:

  Dlg - Specifies the dialog window handle

  Msg - Specifies the message

  wParam - Specifies the first param

  lParam - Specifies the second param

Return Value:

  Depends on the specific message.

--*/

{
    static HANDLE   Bitmap = NULL;
    static HCURSOR  Cursor = NULL;

    RECT rect;
    HWND Text;
    BITMAP bm;
    INT i;

    switch (Msg) {

    case WM_INITDIALOG:
        Cursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
        ShowCursor (TRUE);
        Bitmap = LoadBitmap (GetModuleHandle (NULL), MAKEINTRESOURCE(IDB_INIT_WIN2000));
        if (Bitmap) {
            if (GetObject (Bitmap, sizeof (bm), &bm)) {
                GetClientRect (Dlg, &rect);
                rect.right = bm.bmWidth;
                AdjustWindowRect (&rect, GetWindowLong (Dlg, GWL_STYLE), FALSE);
                SetWindowPos (
                    Dlg,
                    NULL,
                    0,
                    0,
                    rect.right - rect.left,
                    rect.bottom - rect.top,
                    SWP_NOMOVE | SWP_NOZORDER);
            }
            SendDlgItemMessage(Dlg, IDC_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)Bitmap);
        }
        GetClientRect (Dlg, &rect);
        i = rect.right - rect.left;
        Text = GetDlgItem (Dlg, IDC_TEXT);
        if (GetWindowRect (Text, &rect)) {
            i = (i - (rect.right - rect.left)) / 2;
            ScreenToClient (Dlg, (LPPOINT)&rect);
            SetWindowPos (
                Text,
                NULL,
                i,
                rect.top,
                0,
                0,
                SWP_NOSIZE | SWP_NOZORDER);
        }
        pCenterWindowOnDesktop (Dlg);
        return TRUE;

    case WM_DESTROY:
        ShowCursor (FALSE);
        if (Cursor) {
            SetCursor (Cursor);
            Cursor = NULL;
        }
        if (Bitmap) {
            DeleteObject (Bitmap);
            Bitmap = NULL;
        }
    }

    return FALSE;
}


#endif


INT
pStringICompareCharCount (
    IN      PCTSTR String1,
    IN      PCTSTR String2,
    IN      DWORD CharCount
    )

/*++

Routine Description:

  This routine behaves like _tcsnicmp.

Arguments:

  String1 - Specifies the first string

  String2 - Specifies the second string

  CharCount - Specifies the number of chars to compare at most

Return Value:

  0 if strings are equal; -1 if first string is lesser; 1 if first is greater

--*/

{
    TCHAR ch1, ch2;

    if (!CharCount) {
        return 0;
    }

    while (*String1) {
        ch1 = (TCHAR)CharUpper ((LPTSTR)*String1);
        ch2 = (TCHAR)CharUpper ((LPTSTR)*String2);
        if (ch1 - ch2) {
            return ch1 - ch2;
        }

        CharCount--;
        if (!CharCount) {
            return 0;
        }

        String1 = CharNext (String1);
        String2 = CharNext (String2);
    }

    return -(*String2);
}

VOID
pParseCmdLine (
    IN      PTSTR CmdStart,
    OUT     PTSTR* ArgValues,
    OUT     PTSTR pStr,
    OUT     INT *NumArgs,
    OUT     INT *NumBytes
    )

/*

Routine Description:

  pParseCmdLine parses the command line and sets up the ArgValues array.
  On entry, CmdStart should point to the command line,
  ArgValues should point to memory for the ArgValues array,
  pStr points to memory to place the text of the arguments.
  If these are NULL, then no storing (only counting)
  is done.  On exit, *NumArgs has the number of
  arguments (plus one for a final NULL argument),
  and *NumBytes has the number of bytes used in the buffer
  pointed to by args.

Arguments:

  CmdStart - Specifies the command line having the form:
             <progname><nul><args><nul>
  ArgValues - Receives the arguments array;
              NULL means don't build array
  pStr - Receives the argument text; NULL means don't store text

  NumArgs - Receives the number of ArgValues entries created

  NumBytes - Receives the number of bytes used in  buffer

Return Value:

  none

*/

{
    PTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *NumBytes = 0;
    *NumArgs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = CmdStart;
    if (ArgValues)
        *ArgValues++ = pStr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to NumBytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *NumBytes += sizeof(TCHAR);
            if (pStr)
                *pStr++ = *p;
        }
        /* append the terminating null */
        *NumBytes += sizeof(TCHAR);
        if (pStr)
            *pStr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *NumBytes += sizeof(TCHAR);
            if (pStr)
                *pStr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (pStr)
                *(pStr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (ArgValues)
            *ArgValues++ = pStr;         /* store ptr to arg */
        ++*NumArgs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (pStr)
                    *pStr++ = TEXT('\\');
                *NumBytes += sizeof(TCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (pStr)
                        *pStr++ = *p;
                *NumBytes += sizeof(TCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (pStr)
            *pStr++ = TEXT('\0');         /* terminate string */
        *NumBytes += sizeof(TCHAR);
    }

}


PTSTR*
pCommandLineToArgv (
    OUT     INT* NumArgs
    )

/*++

Routine Description:

  pCommandLineToArgv tokens the command line in an array of arguments
  created on the heap. The number of entries in this array of args is
  stored in *NumArgs. The caller is responsible for freeing this array.

Arguments:

  NumArgs - Receives the number of arguments in the array that is returned

Return Value:

  An array of pointer to individual arguments specified on the command line

--*/

{
    PTSTR CommandLine;
    TCHAR ModuleName[MAX_PATH];
    PTSTR Start;
    INT Size;
    PTSTR* Args;

    CommandLine = GetCommandLine();
    GetModuleFileName (NULL, ModuleName, MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that ArgValues[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for ArgValues[] vector and strings,
    // and store args and ArgValues ptrs in block we allocate
    //

    pParseCmdLine (Start, NULL, NULL, NumArgs, &Size);

    Args = (PTSTR*) LocalAlloc (
                        LMEM_FIXED | LMEM_ZEROINIT,
                        ((*NumArgs + 1) * sizeof(PTSTR)) + Size
                        );
    if (!Args) {
        return NULL;
    }

    pParseCmdLine (Start, Args, (PTSTR)(Args + *NumArgs), NumArgs, &Size);

    return Args;
}


VOID
GetCmdLineArgs (
    IN      PCTSTR CommandLine,
    OUT     BOOL* Cleanup,
    OUT     BOOL* NoDownload,
    OUT     PCTSTR* UnattendPrefix,
    OUT     PCTSTR* UnattendFileName,
    OUT     BOOL* DisableDynamicUpdates,
    OUT     PCTSTR* DynamicUpdatesShare,
    OUT     PCTSTR* RestartAnswerFile,
    OUT     BOOL* LocalWinnt32,
    OUT     BOOL* CheckUpgradeOnly,
    OUT     PTSTR RemainingArgs
    )

/*++

Routine Description:

  GetCmdLineArgs retrieves download-specific commands
  from the specified command line and stores them in supplied buffers.

Arguments:

  CommandLine - Specifies the command line to interpret

  Cleanup - Receives a bool indicating if a cleanup option
            was specified

  NoDownload - Receives a bool indicating if a no-download option
               was specified

  UnattendPrefix - Receives a pointer to the unattend command-line option, as
                   specified by the user (including the terminating column)
                   or NULL if not specified; caller is responsible
                   for freeing the memory

  UnattendFileName - Receives a pointer to the unattended file name
                     or NULL if not specified; caller is responsible
                     for freeing the memory

  DisableDynamicUpdates - Receives a bool set if DU is to be disabled

  DynamicUpdatesShare - Receives a pointer to the dynamic updates share;
                        caller is responsible for freeing the memory

  RestartAnswerFile - Receives a pointer to the /Restart: answer file

  LocalWinnt32 - Receives a bool indicating if a winnt32 runs from a local  disk
                 (after an automatic download)

  CheckUpgradeOnly - Receives a bool indicating if winnt32 runs in CheckUpgradeOnly mode

  RemainingArgs - Receives all remaining arguments not related
                  to the download operation

Return Value:

  none

--*/

{
    INT ArgCount;
    PTSTR *ArgValues, *CrtArg;
    PTSTR CurrentArg, p;
    BOOL PassOn;

    *Cleanup = FALSE;
    *NoDownload = FALSE;
    *UnattendPrefix = NULL;
    *UnattendFileName = NULL;
    *DisableDynamicUpdates = FALSE;
    *DynamicUpdatesShare = NULL;
    *RemainingArgs = 0;
    *LocalWinnt32 = FALSE;
    *CheckUpgradeOnly = FALSE;
    *RestartAnswerFile = NULL;

    CrtArg = ArgValues = pCommandLineToArgv (&ArgCount);

    //
    // Skip program name. We should always get back ArgCount as at least 1,
    // but be robust anyway.
    //
    if (ArgCount) {
        ArgCount--;
        CrtArg++;
    }

    while (ArgCount--) {
        CurrentArg = *CrtArg++;
        PassOn = TRUE;

        if ((*CurrentArg == TEXT('/')) || (*CurrentArg == TEXT('-'))) {

            if (lstrcmpi (CurrentArg + 1, TEXT("LOCAL")) == 0) {
                *LocalWinnt32 = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("CLEANUP")) == 0) {
                *Cleanup = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("NODOWNLOAD")) == 0) {
                *NoDownload = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("CHECKUPGRADEONLY")) == 0) {
                *CheckUpgradeOnly = TRUE;
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("UNATTEND"), 8) == 0) {
                p = pFindChar (CurrentArg + 1 + 8, TEXT(':'));
                if (p && *(p + 1)) {
                    p++;
                    *UnattendFileName = DuplicateText (p);
                    *p = 0;
                    *UnattendPrefix = DuplicateText (CurrentArg);
                    PassOn = FALSE;
                }
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("UNATTENDED"), 10) == 0) {
                p = pFindChar (CurrentArg + 1 + 10, TEXT(':'));
                if (p && *(p + 1)) {
                    p++;
                    *UnattendFileName = DuplicateText (p);
                    *p = 0;
                    *UnattendPrefix = DuplicateText (CurrentArg);
                    PassOn = FALSE;
                }
            } else if (lstrcmpi (CurrentArg + 1, WINNT_U_DYNAMICUPDATESDISABLE) == 0) {
                *DisableDynamicUpdates = TRUE;
            } else if (pStringICompareCharCount (CurrentArg + 1, WINNT_U_DYNAMICUPDATESHARE, sizeof (WINNT_U_DYNAMICUPDATESHARE_A) - 1) == 0 &&
                       CurrentArg[sizeof (WINNT_U_DYNAMICUPDATESHARE_A)] == TEXT(':')) {
                *DynamicUpdatesShare = DuplicateText (CurrentArg + 1 + sizeof (WINNT_U_DYNAMICUPDATESHARE_A));
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("RESTART:"), 8) == 0) {
                *RestartAnswerFile = DuplicateText (CurrentArg + 1 + 8);
            }
        }

        if (PassOn) {
            if (*RemainingArgs) {
                lstrcat(RemainingArgs, TEXT(" "));
            }
            lstrcat(RemainingArgs, CurrentArg);
        }
    }

    LocalFree ((HLOCAL) ArgValues);
}

BOOL
DoesDirExist (
    IN      PCTSTR Path
    )
{
    WIN32_FIND_DATA fd;
    TCHAR test[MAX_PATH];
    HANDLE h;
    BOOL b = FALSE;
    HRESULT hr;

    if (Path) {

        if (FAILED(StringCbCopy(test, sizeof(test), Path))) {
            return FALSE;
        }

        if (FAILED(StringCbCat(test, sizeof(test), TEXT("\\*")))) {
            return FALSE;
        }
        
        h = FindFirstFile (test, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose (h);
            b = TRUE;
        }
    }
    return b;
}

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}


BOOL
pComputeChecksum (
    IN      PCTSTR FileName,
    OUT     PDWORD Chksum
    )
{
    DWORD chksum, size, dwords, bytes;
    HANDLE hFile, hMap = NULL;
    PVOID viewBase = NULL;
    PDWORD base, limit;
    PBYTE base2;
    DWORD rc;
    BOOL b = FALSE;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    __try {
        size = GetFileSize (hFile, NULL);
        if (size == (DWORD)-1) {
            __leave;
        }
        hMap = CreateFileMapping (
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    size,
                    NULL
                    );
        if (!hMap) {
            __leave;
        }
        viewBase = MapViewOfFile (hMap, FILE_MAP_READ, 0, 0, size);
        if (!viewBase) {
            __leave;
        }

        dwords = size / sizeof (DWORD);
        base = (PDWORD)viewBase;
        limit = base + dwords;
        chksum = 0;
        while (base < limit) {
            chksum += *base;
            base++;
        }
        bytes = size % sizeof (DWORD);
        base2 = (PBYTE)base;
        while (bytes) {
            chksum += *base2;
            base2++;
            bytes--;
        }
        b = TRUE;
    }
    __finally {
        if (!b) {
            rc = GetLastError ();
        }
        if (viewBase) {
            UnmapViewOfFile (viewBase);
        }
        if (hMap) {
            CloseHandle (hMap);
        }
        CloseHandle (hFile);
        if (!b) {
            SetLastError (rc);
        }
    }

    if (b) {
        *Chksum = chksum;
    }
    return b;
}


BOOL
pGetFiletimeStamps (
    IN      PCTSTR FileName,
    OUT     PFILETIME CreationTime,
    OUT     PFILETIME LastWriteTime
    )
{
    WIN32_FIND_DATA fd;
    HANDLE h;

    h = FindFirstFile (FileName, &fd);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    FindClose (h);
    *CreationTime = fd.ftCreationTime;
    *LastWriteTime = fd.ftLastWriteTime;
    return TRUE;
}

PTSTR
pGetRecentDUShare (
    IN      DWORD MaxElapsedSeconds
    )
{
    SYSTEMTIME lastDownload, currentTime;
    ULONGLONG lastDownloadIn100Ns, currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD rc, size, type;
    HKEY key = NULL;
    BOOL b = FALSE;
    PTSTR duShare = NULL;
    TCHAR filePath[MAX_PATH];
    PTSTR p;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2], storedData[2];
    DWORD chksum, storedChksum;

    if (!GetModuleFileName (NULL, filePath, MAX_PATH)) {
        return NULL;
    }
    p = FindLastWack (filePath);
    if (!p) {
        return NULL;
    }

    p++; //now, p points after the wack.

    //Note that p cannot be greater than (filePath+MAX_PATH), since
    //we used GetModuleFileName() with MAX_PATH to put a string in the filePath buffer,
    //and FindLastWack() cannot go beyond the end of the string buffer.  
    if (FAILED(StringCchCopy(p, (filePath+ARRAYSIZE(filePath)) - p, S_CHKSUM_FILE))) {
        return NULL;
    }

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1\\DUShare"),
            0,
            KEY_READ,
            &key
            );

    if (rc == ERROR_SUCCESS) {
        size = sizeof (lastDownload);
        rc = RegQueryValueEx (
                key,
                TEXT("LastDownloadTime"),
                NULL,
                &type,
                (PBYTE) (&lastDownload),
                &size
                );
    }

    if (rc == ERROR_SUCCESS && type == REG_BINARY && size == sizeof (lastDownload)) {
        //
        // Compare current time to report time
        //

        GetSystemTime (&currentTime);

        lastDownloadIn100Ns = SystemTimeToFileTime64 (&lastDownload);
        currentTimeIn100Ns = SystemTimeToFileTime64 (&currentTime);

        if (currentTimeIn100Ns > lastDownloadIn100Ns) {
            //
            // Compute difference in seconds
            //
            difference = currentTimeIn100Ns - lastDownloadIn100Ns;
            difference /= (10 * 1000 * 1000);

            if (difference < MaxElapsedSeconds) {
                b = TRUE;
            }
        }
    }

    if (b) {
        rc = RegQueryValueEx (
                key,
                TEXT(""),
                NULL,
                &type,
                NULL,
                &size
                );
        if (rc == ERROR_SUCCESS && type == REG_SZ && size > 0) {
            duShare = ALLOC_TEXT (size / sizeof (TCHAR));
            if (duShare) {
                rc = RegQueryValueEx (
                        key,
                        TEXT(""),
                        NULL,
                        NULL,
                        (LPBYTE)duShare,
                        &size
                        );
                if (rc != ERROR_SUCCESS || !DoesDirExist (duShare)) {
                    FREE (duShare);
                    duShare = NULL;
                }
            }
        }
    }

    if (duShare) {
        b = FALSE;
        if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
            rc = RegQueryValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        &type,
                        (LPBYTE)storedData,
                        &size
                        );
            if (rc == ERROR_SUCCESS && type == REG_BINARY) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                if (data[0] == storedData[0] && data[1] == storedData[1]) {
                    b = TRUE;
                }
            }
        }
        if (b) {
            b = FALSE;
            if (pComputeChecksum (filePath, &chksum)) {
                rc = RegQueryValueEx (
                        key,
                        TEXT("Checksum"),
                        NULL,
                        &type,
                        (LPBYTE)&storedChksum,
                        &size
                        );
                if (rc == ERROR_SUCCESS && type == REG_DWORD && storedChksum == chksum) {
                    b = TRUE;
                }
            }
        }
        if (!b) {
            FREE (duShare);
            duShare = NULL;
        }
    }

    if (key) {
        RegCloseKey (key);
    }

    return duShare;
}

void
_stdcall
ModuleEntry(
    VOID
    )

/*++

Routine Description:

  ModuleEntry is the stub program that loads Windows 2000 Setup DLLs.

Arguments:

  none

Return Value:

  none. ExitProcess will set the process' exit code.

--*/

{
    TCHAR RunningInstancePath[MAX_PATH];
    TCHAR Temp[MAX_PATH];
    TCHAR Text1[MAX_PATH+sizeof("msvcrt.dll")];
    TCHAR Text2[MAX_PATH+MAX_PATH];
    TCHAR Text3[MAX_PATH];
    TCHAR *WackExeName, *p;
    TCHAR winnt32DllPath[MAX_PATH+MAX_PATH];
    HMODULE WinNT32;
    BOOL Downloaded;
    DWORD d;
    BOOL b;
    HWND Dlg = NULL;
    HANDLE WinNT32Stub = NULL;
    PWINNT32 winnt32;
    HKEY key;
    DWORD type;
    PCTSTR moduleName;
    PSTR restartCmdLine = NULL;
    PTSTR RemainingArgs, NewCmdLine, UnattendPrefix, UnattendFileName;
    PTSTR DynamicUpdatesShare;
    BOOL Cleanup, NoDownload, DisableDynamicUpdates, LocalWinnt32, CheckUpgradeOnly;
    PTSTR RestartAnswerFile;
    UINT CmdLineLen;
    PTSTR FileName;
    PCTSTR ExtraFiles[2];
    TCHAR cdFilePath[MAX_PATH+sizeof("win9xupg\\msvcrt.dll")];
    PTSTR duShare = NULL;
    UINT tcharsNeeded;
    HRESULT hr;

#if defined(_X86_)

    TCHAR DownloadDest[MAX_PATH] = TEXT("");
    TCHAR DefSourcesDir[MAX_PATH];
    BOOL IsWin9x;

    //
    // Check OS version. Disallow Win32s and NT < 4.00
    //
    d = GetVersion();
    if((d & 0xff) < 4) {

        if (LoadString (GetModuleHandle (NULL), IDS_VERERROR, Text1, sizeof(Text1)/sizeof(Text1[0]))
            && LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text2, sizeof(Text2)/sizeof(Text2[0])))
        {
            MessageBox (NULL, Text1, Text2, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);
        }

        ExitProcess (ERROR_OLD_WIN_VERSION);
    }

    IsWin9x = (d & 0x80000000) != 0;

#else

#define IsWin9x ((BOOL)FALSE)

#endif

    //
    // get this instance's path
    //
    if (!GetModuleFileName(NULL, RunningInstancePath, MAX_PATH)) {
        ExitProcess (GetLastError ());
    }
    WackExeName = FindLastWack (RunningInstancePath);
    if (!WackExeName) { // shut up PREfix.  This case should never happen.
        ExitProcess (ERROR_BAD_PATHNAME);
    }

    //
    // Ansi version on Win95. Unicode on NT.
    //
    moduleName = IsWin9x ? TEXT("WINNT32A.DLL") : TEXT("WINNT32U.DLL");
    winnt32DllPath[0] = 0;

    //
    // get command line options
    // allocate a bigger buffer for safety
    //
    RemainingArgs = ALLOC_TEXT(lstrlen(GetCommandLine()) * 2);
    if (!RemainingArgs) {
        ExitProcess (GetLastError ());
    }

    GetCmdLineArgs (
        GetCommandLine (),
        &Cleanup,
        &NoDownload,
        &UnattendPrefix,
        &UnattendFileName,
        &DisableDynamicUpdates,
        &DynamicUpdatesShare,
        &RestartAnswerFile,
        &LocalWinnt32,
        &CheckUpgradeOnly,
        RemainingArgs
        );

#if defined(_AMD64_) || defined(_X86_)

    if (Cleanup) {
        pCleanup ();
        ExitProcess (0);
    }

#if defined(_X86_)

    if (IsWin9x) {

        WinNT32Stub = CreateEvent (NULL, FALSE, FALSE, TEXT("_WinNT32_Stub_"));
        if (!WinNT32Stub) {
            ExitProcess (GetLastError ());
        }

        b = (GetLastError() == ERROR_SUCCESS);

        if (!NoDownload && !DynamicUpdatesShare && pShouldDownloadToLocalDisk (RunningInstancePath)) {

            Dlg = CreateDialog (GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SETUPINIT), NULL, DlgProc);

            GetWindowsDirectory (DownloadDest, MAX_PATH);
            StringCbCat (DownloadDest, sizeof(DownloadDest), INTERNAL_WINNT32_DIR);
            *WackExeName = 0;

            if (UnattendFileName &&
                GetFullPathName (UnattendFileName, MAX_PATH, Temp, &FileName) &&
                lstrcmpi (UnattendFileName, Temp)
                ) {
                ExtraFiles[0] = Temp;
                ExtraFiles[1] = NULL;
            } else {
                ExtraFiles[0] = NULL;
                FileName = UnattendFileName;
            }

            Downloaded = DownloadProgramFiles (
                                RunningInstancePath,
                                DownloadDest,
                                ExtraFiles
                                );

            *WackExeName = TEXT('\\');

            if (Downloaded) {
                //
                // get default sources dir
                //
               
                //this lstrcpy is ok, since both buffers are of size MAX_PATH
                lstrcpy (DefSourcesDir, RunningInstancePath);
                *FindLastWack (DefSourcesDir) = 0;
                p = FindLastWack (DefSourcesDir);
                if (p && lstrcmpi(p, INTERNAL_WINNT32_DIR) == 0) {
                    *p = 0;
                }

                if (FileName) {
                    CmdLineLen = lstrlen (RemainingArgs);
                    if (CmdLineLen > 0) {
                        //
                        // count the space between args
                        //
                        CmdLineLen += CHARS(" ");
                    }
                    CmdLineLen += lstrlen (UnattendPrefix);
                    CmdLineLen += lstrlen (FileName);
                    NewCmdLine = ALLOC_TEXT(CmdLineLen);
                    if (NewCmdLine) {
                        if (*RemainingArgs) {
                            lstrcpy (NewCmdLine, RemainingArgs);
                            lstrcat (NewCmdLine, TEXT(" "));
                        } else {
                            *NewCmdLine = 0;
                        }
                        lstrcat (NewCmdLine, UnattendPrefix);
                        lstrcat (NewCmdLine, FileName);

                        FREE (RemainingArgs);
                        RemainingArgs = NewCmdLine;
                        NewCmdLine = NULL;
                    }
                }
                //
                // append /LOCAL to the new processes command line
                // to let it know it's running from a local share
                //
                NewCmdLine = ALLOC_TEXT(lstrlen (RemainingArgs) + sizeof(TEXT(" /LOCAL"))/sizeof(TCHAR) + 1);
                if (NewCmdLine) {

                    //we have pre-calculated the size of the NewCmdLine buffer
                    wsprintf (NewCmdLine, TEXT("%s /%s"), RemainingArgs, TEXT("LOCAL"));

                    if (pReRun (DownloadDest, WackExeName, NewCmdLine, DefSourcesDir)) {
                        //
                        // the new process will do it; this one will just die
                        // but after the signal that the Setup Wizard is on
                        // anyway, if something goes very wrong,
                        // don't wait more than 10 sec.
                        // this should be enough for the wizard to appear
                        // (or any error message box) on any machine that installs W2K
                        //
                        WaitForSingleObject (WinNT32Stub, 10000);
                        CloseHandle (WinNT32Stub);
                        if (Dlg) {
                            DestroyWindow (Dlg);
                        }
                        d = 0;
                    } else {
                        d = GetLastError ();
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
                ExitProcess (d);
            }
        }

        if (!Dlg && WinNT32Stub) {
            CloseHandle (WinNT32Stub);
            WinNT32Stub = NULL;
        }
    }

#endif // defined(_X86_)

#endif // defined(_AMD64_) || defined(_X86_)

    if (RemainingArgs) {
        FREE(RemainingArgs);
        RemainingArgs = NULL;
    }
    if (UnattendPrefix) {
        FREE(UnattendPrefix);
        UnattendPrefix = NULL;
    }

    if (!DisableDynamicUpdates && !DynamicUpdatesShare) {
        PCTSTR af = NULL;
        if (RestartAnswerFile) {
            af = RestartAnswerFile;
        } else if (UnattendFileName) {
            if (GetFullPathName (UnattendFileName, MAX_PATH, Temp, &FileName)) {
                af = Temp;
            }
        }
        //
        // get the path from this answer file
        //
        if (af) {
            GetPrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESDISABLE,
                    TEXT(""),
                    Text2,
                    MAX_PATH,
                    af
                    );
            DisableDynamicUpdates = !lstrcmpi (Text2, WINNT_A_YES);

            if (!DisableDynamicUpdates) {
                if (GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESHARE,
                        TEXT(""),
                        Text2,
                        MAX_PATH,
                        af
                        )) {
                    DynamicUpdatesShare = DuplicateText (Text2);
                }
            }
        }
    }

    if (UnattendFileName) {
        FREE(UnattendFileName);
        UnattendFileName = NULL;
    }

    b = FALSE;
    if (!CheckUpgradeOnly && !DisableDynamicUpdates && !DynamicUpdatesShare) {
        DynamicUpdatesShare = pGetRecentDUShare (MAX_UPGCHK_ELAPSED_SECONDS);
        if (DynamicUpdatesShare) {
            b = TRUE;
        }
    }

    d = ERROR_SUCCESS;

    if (!DisableDynamicUpdates && DynamicUpdatesShare) {
        DWORD regFileVersionMS, regFileVersionLS;
        DWORD cdFileVersionMS, cdFileVersionLS;
        //
        // check if there is a replacement module newer than the CD version
        //
        if (GetFileAttributes (DynamicUpdatesShare) == (DWORD)-1) {
            if (!b) {
                d = GetLastError ();
                
                if (LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text3, sizeof(Text3)/sizeof(Text3[0]))
                    && LoadString (GetModuleHandle (NULL), IDS_PATHERROR, Text1, sizeof(Text1)/sizeof(Text1[0])))
                {
                    //Note: Text2 is 2*MAX_PATH, so it is large enough to hold the message defined in the
                    //resource string table, and one string of max size MAX_PATH.
                    wsprintf (Text2, Text1, DynamicUpdatesShare);
                    MessageBox (NULL, Text2, Text3, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);
                }
            }
        } else {

            //Note: DynamicUpdatesShare comes from the registry, so we have to treat it with caution
            StringCbCopy(Text2, sizeof(Text2), DynamicUpdatesShare);
            StringCbCat(Text2, sizeof(Text2), TEXT("\\WINNT32\\"));
            hr = StringCbCat(Text2, sizeof(Text2), moduleName);

            if (FAILED(hr)) {
                ExitProcess(ERROR_BUFFER_OVERFLOW);
            }

           
            if (GetFileAttributes (Text2) != (DWORD)-1 &&
                GetFileVersion (Text2, &regFileVersionMS, &regFileVersionLS)) 
            {
                tcharsNeeded = min(MAX_PATH, (INT)(WackExeName - RunningInstancePath + 2));
                StringCchCopy(cdFilePath, tcharsNeeded, RunningInstancePath);
                hr = StringCchCat(cdFilePath, MAX_PATH, moduleName);

                if (FAILED(hr)) {
                    ExitProcess(ERROR_BUFFER_OVERFLOW);
                }

                if (GetFileVersion (cdFilePath, &cdFileVersionMS, &cdFileVersionLS)) {
                    if (MAKEULONGLONG(regFileVersionLS, regFileVersionMS) >
                        MAKEULONGLONG(cdFileVersionLS, cdFileVersionMS)) {
                        //This lstrcpy is ok, since the buffers are the same size
                        lstrcpy (winnt32DllPath, Text2);
                    }
                }
            }
        }

        FREE (DynamicUpdatesShare);
        DynamicUpdatesShare = NULL;
    }

    if (d == ERROR_SUCCESS) {

#if defined(_X86_)

        //
        // before attempting to load the main module, make sure msvcrt.dll is present in the system dir
        //
        if (!GetSystemDirectory (Text1, MAX_PATH)) {
            ExitProcess (GetLastError ());
        }

        //This is ok, since Text1 is MAX_PATH + 32 TCHARs long
        ConcatenatePaths (Text1, TEXT("msvcrt.dll"));

        d = GetFileAttributes (Text1);
        if (d == (DWORD)-1) {
            //
            // no local msvcrt.dll; copy the private file from CD
            //
            tcharsNeeded = min(MAX_PATH, (INT)(WackExeName - RunningInstancePath + 2));
            StringCchCopy(cdFilePath, tcharsNeeded, RunningInstancePath);

            //this is ok, becuase cdFilePath is MAX_PATH + 32 TCHARs long
            ConcatenatePaths (cdFilePath, TEXT("win9xupg\\msvcrt.dll"));
            if (!CopyFile (cdFilePath, Text1, TRUE)) {
                ExitProcess (GetLastError ());
            }
        } else if (d & FILE_ATTRIBUTE_DIRECTORY) {
            ExitProcess (ERROR_DIRECTORY);
        }

#endif

        *WackExeName = 0;
        if (!winnt32DllPath[0]) {
            //The next two string operations are safe, since winnt32DllPath is 2*MAX_PATH TCHARs long
            lstrcpy (winnt32DllPath, RunningInstancePath);
            ConcatenatePaths (winnt32DllPath, moduleName);
        }

        b = FALSE;
        WinNT32 = LoadLibrary (winnt32DllPath);
        if(WinNT32) {
            winnt32 = (PWINNT32) GetProcAddress(WinNT32, "winnt32");
            if (winnt32) {
                d = (*winnt32) (LocalWinnt32 ? RunningInstancePath : NULL, Dlg, WinNT32Stub, &restartCmdLine);
                b = TRUE;
            }
            FreeLibrary (WinNT32);
        }
        if (!b) {
            d = GetLastError ();
            if (LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text3, sizeof(Text3)/sizeof(TCHAR))
                && LoadString (GetModuleHandle (NULL), IDS_DLLERROR, Text1, sizeof(Text1)/sizeof(TCHAR)))
            {
                //This is safe, since Text2 is 2*MAX_PATH TCHARs long
                wsprintf (Text2, Text1, winnt32DllPath);
                MessageBox (NULL, Text2, Text3, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);
            }
        }
    }

    //
    // remove downloaded files
    //

#ifdef _X86_
    if (IsWin9x) {
        //
        // check if our local directory exists and if so delete it
        //
        if (LocalWinnt32 && GetFileAttributes (RunningInstancePath) != (DWORD)-1) {
            //
            // copy Winnt32.Exe to temp dir and rerun it from there with /CLEANUP option
            //
            //  This is ok, since both buffers are of size MAX_PATH
            lstrcpy (DefSourcesDir, RunningInstancePath);

            CmdLineLen = GetTempPath (MAX_PATH, DownloadDest);
            if (!CmdLineLen) {
                //
                // an error occured; copy it to %windir% instead
                //
                GetWindowsDirectory (DownloadDest, MAX_PATH);
            }

            //
            // make sure temp path doesn't end in backslash
            //
            p = FindLastWack (DownloadDest);
            if (p && *(p + 1) == 0) {
                *p = 0;
            }

            *WackExeName = TEXT('\\');
            if (CopyNode (DefSourcesDir, DownloadDest, WackExeName, FALSE, TRUE)) {
                if (!pReRun (DownloadDest, WackExeName, TEXT("/CLEANUP"), NULL)) {
                    StringCbCatA (DownloadDest, sizeof(DownloadDest), WackExeName);
                    DeleteNode (DownloadDest);
                }
            }
        }
    }
#endif

    if (d == ERROR_SUCCESS) {
        //
        // check if a restart request was made
        //
        if (restartCmdLine) {
            STARTUPINFOA startupInfo;
            PROCESS_INFORMATION pi;

            ZeroMemory(&startupInfo, sizeof(startupInfo));
            startupInfo.cb = sizeof(startupInfo);
            if (!CreateProcessA (
                    NULL,
                    restartCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    NORMAL_PRIORITY_CLASS,
                    NULL,
                    NULL,
                    &startupInfo,
                    &pi
                    )) {
                d = GetLastError ();
            }

            FREE (restartCmdLine);
        }
    }

    ExitProcess(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\i386\download.c ===
#include <windows.h>
#include "download.h"
#include "setupbat.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

//
// these are the critical files that must be copied locally if the
// upgrade of a Win9x system is performed over a network
//

static PCTSTR g_CriticalFiles[] = {
    TEXT("WINNT32.EXE"),
    TEXT("WINNT32A.DLL"),
    TEXT("WINNTBBA.DLL"),
    TEXT("PIDGEN.DLL"),
    TEXT("WSDU.DLL"),
    TEXT("WSDUENG.DLL"),
    TEXT("HWDB.DLL"),
    TEXT("WIN9XUPG"),
    TEXT("drw")
};

//
// these are the critical files for NEC98 plattform that must be copied
//  locally if the upgrade of a Win9x system is performed over a network
//

static PCTSTR g_NEC98_CriticalFiles[] = {
    TEXT("98PTN16.DLL"),
    TEXT("98PTN32.DLL")
};

//
// these are non-critical files that should be copied locally if the
// upgrade of a Win9x system is performed over a network
//

static PCTSTR g_NonCriticalFiles[] = {
    TEXT("IDWLOG.EXE"),
// #define RUN_SYSPARSE = 1
#ifdef RUN_SYSPARSE
    TEXT("SYSPARSE.EXE"),
#endif
    TEXT("WINNT32.HLP"),
    TEXT("DOSNET.INF"),
};

BOOL
pIsSpecialDir (
    IN      PCTSTR Dir
    )

/*++

Routine Description:

  pIsSpecialDir decides if the given dir is a special directory, like . or ..

Arguments:

  Dir - Specifies the directory name only (no path)

Return Value:

  TRUE if the specified dir name is a special name

--*/

{
    return
        *Dir == TEXT('.') &&
        (*(Dir + 1) == 0 || *(Dir + 1) == TEXT('.') && *(Dir + 2) == 0)
        ;
}


BOOL
CopyNode (
    IN      PCTSTR SrcBaseDir,
    IN      PCTSTR DestBaseDir,
    IN      PCTSTR NodeName,
    IN      BOOL FailIfExist,
    IN      BOOL FailIfSourceDoesntExist
    )

/*++

Routine Description:

  CopyNode copies NodeName (file or subdir) from SrcBaseDir to DestBaseDir.

Arguments:

  SrcBaseDir - Specifies the source base directory name

  DestBaseDir - Specifies the destination base directory name

  NodeName - Specifies the file or subdirectory name to copy

  FailIfExist - Specifies if the operation should fail if there is
                already a node with the same name at destination

  FailIfSourceDoesntExist - Specifies if the operation should fail if NO
                            source node exists

Return Value:

  TRUE if the copy operation was actually done

--*/

{
    DWORD FileAttr;
    TCHAR SrcDir[MAX_PATH];  //note: ConcatenatePaths inserts a wack, wack, *.
    TCHAR DestDir[MAX_PATH];  //note: ConcatenatePaths inserts 1 wack later on.
    HANDLE h;
    WIN32_FIND_DATA fd;
    WIN32_FIND_DATA fdSrc;
    DWORD attribs;
    UINT nameLen;

    nameLen = lstrlen(NodeName);

    if(lstrlen(SrcBaseDir) + nameLen + 3 >= ARRAYSIZE(SrcDir) ||     //3 <== wack, wack, *
        lstrlen(DestBaseDir) + nameLen + 1 >= ARRAYSIZE(DestDir)){   //1 <== wack
        return FALSE;
    }
    
    lstrcpy (SrcDir, SrcBaseDir);
    lstrcpy (DestDir, DestBaseDir);

    //
    // check for "\" at the end of dir name
    //
    ConcatenatePaths (SrcDir, NodeName);

    h = FindFirstFile (SrcDir, &fdSrc);
    if (h == INVALID_HANDLE_VALUE) {

        if (GetLastError () != ERROR_FILE_NOT_FOUND) {
            return FALSE;
        }

        return !FailIfSourceDoesntExist;
    }
    CloseHandle (h);

    if (GetFileAttributes (DestDir) == -1) {
        if (!CreateDirectory (DestDir, NULL)) {
            return FALSE;
        }
    }

    if (fdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        //
        // skip to the end of dir name
        //
        ConcatenatePaths (DestDir, NodeName);

        ConcatenatePaths (SrcDir, TEXT("*"));

        h = FindFirstFile (SrcDir, &fd);

        *FindLastWack (SrcDir) = 0;

        //
        // recursively copy all files in that dir
        //
        if (h != INVALID_HANDLE_VALUE) {
            do {
                //
                // skip over special dirs
                //
                if (pIsSpecialDir (fd.cFileName)) {
                    continue;
                }

                if (!CopyNode (SrcDir, DestDir, fd.cFileName, FailIfExist, FailIfSourceDoesntExist)) {
                    return FALSE;
                }
            } while (FindNextFile (h, &fd));
        }
    } else {
        //
        // copy the file
        //
        ConcatenatePaths (DestDir, NodeName);
        if (!CopyFile (SrcDir, DestDir, FailIfExist)) {
            return FALSE;
        }
        //
        // set file timestamps to match exactly the ones of the original
        // ignore errors in this case
        //
        SetFileAttributes (DestDir, FILE_ATTRIBUTE_NORMAL);
        h = CreateFile (DestDir, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (h != INVALID_HANDLE_VALUE) {
            SetFileTime (h, &fdSrc.ftCreationTime, &fdSrc.ftLastAccessTime, &fdSrc.ftLastWriteTime);
            CloseHandle (h);
        }
    }

    return TRUE;
}


BOOL
DeleteNode (
    IN      PCTSTR NodeName
    )

/*++

Routine Description:

  DeleteNode deletes NodeName directory and all its subdirectories

Arguments:

  NodeName - Specifies the directory name to delete

Return Value:

  TRUE if the delete operation was successful; FALSE if only part
  of the files/subdirs were deleted

--*/

{
    DWORD FileAttr;
    TCHAR DestDir[MAX_PATH]; //note: ConcatenatePaths adds: wack, *
    PTSTR p;
    HANDLE h;
    WIN32_FIND_DATA fd;
	BOOL Success = TRUE;

    if (!NodeName || !*NodeName || (lstrlen(NodeName) + 2 >= ARRAYSIZE(DestDir))) {  // 2 <== wack, *
        return FALSE;
    }

    FileAttr = GetFileAttributes (NodeName);
    if (FileAttr == -1)
        return TRUE;

    if (!SetFileAttributes (NodeName, FILE_ATTRIBUTE_NORMAL)) {
        return FALSE;
    }

    if (FileAttr & FILE_ATTRIBUTE_DIRECTORY) {

        lstrcpy (DestDir, NodeName);

        ConcatenatePaths (DestDir, TEXT("*"));

        h = FindFirstFile (DestDir, &fd);

        p = FindLastWack (DestDir);

        //
        // recursively copy all files in that dir
        //
        if (h != INVALID_HANDLE_VALUE) {
            do {
                //
                // skip over special dirs
                //
                if (pIsSpecialDir (fd.cFileName)) {
                    continue;
                }

                if (SUCCEEDED(StringCchCopy(p + 1, 
                                            DestDir + ARRAYSIZE(DestDir) - (p + 1),
                                            fd.cFileName))) 
                {
                    if (!DeleteNode (DestDir))       
                    {
                        Success = FALSE;
                    }
                }
                else
                {
                    Success = FALSE;
                }
                
            } while (FindNextFile (h, &fd));
        }

        //
        // now delete the base dir
        //
        *p = 0;

        if (!RemoveDirectory (DestDir)) {
            Success = FALSE;
        }
    } else {
        //
        // delete the file
        //
        if (!DeleteFile (NodeName)) {
            Success = FALSE;
        }
    }

    return Success;
}


BOOL
DownloadProgramFiles (
    IN      PCTSTR SourceDir,
    IN      PCTSTR DownloadDest,
    IN      PCTSTR* ExtraFiles      OPTIONAL
    )

/*++

Routine Description:

  DownloadProgramFiles copies from SourceDir to DownloadDest
  all specific program files (specified in g_CriticalFiles,
  g_NEC98_CriticalFiles, and g_NonCriticalFiles arrays).

Arguments:

  SourceDir - Specifies the source directory

  DownloadDest - Specifies the destination directory

  ExtraFiles - Specifies an array of extra files (full paths)
               to be copied to the destination directory;
               the array must be NULL terminated

Return Value:

  TRUE if the download operation was successful and all critical
  files were copied locally; FALSE otherwise

--*/

{
    TCHAR SourcePath[MAX_PATH];
    TCHAR DestPath[MAX_PATH];
    INT i;
    PTSTR FileName;
    TCHAR FullPathName[MAX_PATH];


    //
    // first delete any old stuff to make place
    //
    DeleteNode (DownloadDest);

    if(lstrlen(SourceDir) >= ARRAYSIZE(SourcePath) || 
       lstrlen(DownloadDest) >= ARRAYSIZE(DestPath)){
        return FALSE;
    }
       
    //
    // copy there the new stuff
    //
    lstrcpy (SourcePath, SourceDir);
    lstrcpy (DestPath, DownloadDest);

    for (i = 0; i < sizeof (g_CriticalFiles) / sizeof (g_CriticalFiles[0]); i++) {
        //
        // download this one to the destination directory
        //
        if (!CopyNode (SourcePath, DestPath, g_CriticalFiles[i], FALSE, FALSE)) {
            DeleteNode (DownloadDest);
            return FALSE;
        }
    }

    if (ExtraFiles) {
        while (*ExtraFiles) {
            FileName = FindLastWack ((PTSTR)*ExtraFiles);
            if (FileName) {

                StringCchCopy(FullPathName, ARRAYSIZE(FullPathName), DownloadDest);
                
                if (SUCCEEDED(StringCchCat(FullPathName, ARRAYSIZE(FullPathName), FileName))) {
                    CopyFile (*ExtraFiles, FullPathName, FALSE);
                }
            }
            ExtraFiles++;
        }
    }

    for (i = 0; i < sizeof (g_NEC98_CriticalFiles) / sizeof (g_NEC98_CriticalFiles[0]); i++) {
	//
	// download this one to the destination directory
	//
	// Never check for error. Because winnt32a.dll check plattform and
        // sources with NEC98 specific file(98ptn16.dll).
        // See winnt32\dll\winnt32.c line 2316.
	//
        CopyNode (SourcePath, DestPath, g_NEC98_CriticalFiles[i], FALSE, FALSE);
    }
    for (i = 0; i < sizeof (g_NonCriticalFiles) / sizeof (g_NonCriticalFiles[0]); i++) {
        //
        // download this one to the destination directory
        //
        CopyNode (SourcePath, DestPath, g_NonCriticalFiles[i], FALSE, FALSE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\exe\i386\download.h ===
#pragma once



PTSTR
FindLastWack (
    IN      PTSTR String
    );


PTSTR
DuplicateText (
    IN      PCTSTR Text
    );

VOID
ConcatenatePaths (
    IN      PTSTR LeadingPath,
    IN      PCTSTR TrailingPath
    );

BOOL
DownloadProgramFiles (
    IN      PCTSTR SourceDir,
    IN      PCTSTR DownloadDest,
    IN      PCTSTR* ExtraFiles
    );

BOOL
CopyNode (
    IN      LPCTSTR SrcBaseDir,
    IN      LPCTSTR DestBaseDir,
    IN      LPCTSTR NodeName,
    IN      BOOL FailIfExist,
    IN      BOOL FailIfSourceDoesntExist
    );

BOOL
DeleteNode (
    IN      LPCTSTR NodeName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\fsfilter\fsfilter.h ===
#define REGKEY_SERVICES         L"System\\CurrentControlSet\\Services"
#define REGVAL_GROUP            L"Group"
#define DRIVER_DIRECTORY        L"%SystemRoot%\\system32\\drivers\\"
#define DRIVER_SUFFIX           L".sys"
#define REGVAL_START            L"Start"
#define REGVAL_SETUPCHECKED     L"SetupChecked"

#define SIZE_STRINGBUF          256
#define SIZE_SECTIONBUF         128


//
//
// Data structure used for storing lists of strings.  Note that
// some strings are in ansi and others in unicode (thus the VOID
// pointer to String).  It's up to the user to keep track of whether
// a list is ansi or Unicode
//
//

typedef struct _STRING_LIST_ENTRY
{
    LPVOID String;
    struct _STRING_LIST_ENTRY *Next;
} STRING_LIST_ENTRY, *PSTRING_LIST_ENTRY;



//
//
//  PSTRING_LIST_ENTRY
//  PopEntryList(
//      PSTRING_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSTRING_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//
//  VOID
//  PushEntryList(
//      PSTRING_LIST_ENTRY ListHead,
//      PSTRING_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#define InitializeList(ListHead)\
    (ListHead)->Next = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\faulth\util.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pfrutil.h

Abstract:
    PFR utility stuff

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#ifndef PFRUTIL_H
#define PFRUTIL_H

// make sure both _DEBUG & DEBUG are defined if one is defined.  Otherwise
//  the ASSERT macro never does anything
#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG 1
#endif
#if defined(DEBUG) && !defined(_DEBUG)
#define _DEBUG 1
#endif

#define NOTRACE 1

////////////////////////////////////////////////////////////////////////////
// tracing wrappers

// can't call HRESULT_FROM_WIN32 with a fn as a parameter cuz it is a macro
//  and evaluates the expression 3 times.  This is a particularlly bad thing
//  when u don't look at macros first to see what they do.
_inline HRESULT ChangeErrToHR(DWORD dwErr) { return HRESULT_FROM_WIN32(dwErr); }

#if defined(NOTRACE)
    #define INIT_TRACING

    #define TERM_TRACING

    #define USE_TRACING(sz)

    #define TESTHR(hr, fn)                                                  \
            hr = (fn);

    #define TESTBOOL(hr, fn)                                                \
            hr = ((fn) ? NOERROR : HRESULT_FROM_WIN32(GetLastError()));

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            hr = HRESULT_FROM_WIN32(GetLastError());

    #define VALIDATEPARM(hr, expr)                                          \
            hr = ((expr) ? E_INVALIDARG : NOERROR);

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            hr = ((expr) ? (hrErr) : NOERROR);

#else
    #define INIT_TRACING                                                    \
            InitAsyncTrace();

    #define TERM_TRACING                                                    \
            TermAsyncTrace();

    #define USE_TRACING(sz)                                                 \
            TraceQuietEnter(sz);                                            \
            TraceFunctEntry(sz);                                            \
            DWORD __dwtraceGLE = GetLastError();                            \

    #define TESTHR(hr, fn)                                                  \
            if (FAILED(hr = (fn)))                                          \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, hr);          \
                SetLastError(__dwtraceGLE);                                 \
            }                                                               \

    #define TESTBOOL(hr, fn)                                                \
            hr = NOERROR;                                                   \
            if ((fn) == FALSE)                                              \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                hr = HRESULT_FROM_WIN32(__dwtraceGLE);                      \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, hr);          \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            if (FAILED(hr = HRESULT_FROM_WIN32(GetLastError())))            \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: %d", #fn, hr);              \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define VALIDATEPARM(hr, expr)                                          \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Invalid parameters passed to %s",            \
                           ___pszFunctionName);                             \
                SetLastError(ERROR_INVALID_PARAMETER);                      \
                hr = E_INVALIDARG;                                          \
            }                                                               \
            else hr = NOERROR;

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Expression failure %s", #expr);              \
                hr = (hrErr);                                               \
            }                                                               \
            else hr = NOERROR;

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\fsfilter\fsfilter.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This dll finds file system filters

Author:

    George Jenkins (georgeje) Aug-28-98

Environment:

    User Mode

--*/

#include <windows.h>
#include <wchar.h>
#include <comp.h>
#include <imagehlp.h>
#include "fsfilter.h"

STRING_LIST_ENTRY GoodFilterList;
STRING_LIST_ENTRY ImportPrefixList;

LPWSTR GoodFilterBuffer;
LPWSTR ImportPrefixBuffer;

HINSTANCE MyhInstance;

WCHAR TxtFileName[MAX_PATH];

WCHAR HtmlFileName[MAX_PATH];

VOID
InitializeStringLists(
    VOID
    );

VOID
FreeStringLists(
    VOID
    );

BOOL
IsBadFilter(
    LPWSTR DriverName,
    LPWSTR DriverDirectory
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );


BOOL
WINAPI
FsFilterDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
/*++

Routine Description:

    Initializes the dll.

Arguments:

    hInstance   - dll instance handle
    Reason      - reason code
    Context     - context pointer

Return Value:

    TRUE
--*/
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );        
    }

    return TRUE;
}


BOOL
CheckForFsFilters(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
/*++

Routine Description:

    Looks for installed file system filter drivers that are enabled.  The algorithm is as follows:

    1) If the filter is listed in the [ServicesToDisable] or [ServicesToStopInstallation] sections
       of dosnet.inf, the winnt32 will handle that particular driver.  This dll is to catch drivers
       that aren't listed there.
    
    2) Read fsfilter.inf and build two string lists.  One list contains the name of known good filters.
       The other list contains the prefixes of names to look for in the import table of the driver.

    3) recurse through HKLM\system\currentcontrolset\services and look for drivers that have the Group
       "filter".  If the driver is a known good driver, ignore it.  Otherwise, load the image and grovel
       through the import table looking for imports that have prefixes that are in the import prefix list.
       If there are any hits, it is assumed that the driver is a file system filter and the upgrade will be
       stopped until the user deals with the problem.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    TRUE
--*/
{
    
    HKEY    ServicesKey = INVALID_HANDLE_VALUE;
    HKEY    DriverKey = INVALID_HANDLE_VALUE;
    LONG    Result;
    DWORD   SubKeyCount;
    DWORD   Size;
    DWORD   Index;
    LPWSTR  KeyNameBuffer = NULL;
    BYTE    ValueBuffer[SIZE_STRINGBUF];
    DWORD   Type;
    LPWSTR  DriverDirectory = NULL;
    DWORD   MaxKeyLen;
    COMPATIBILITY_ENTRY CompEntry;

    ZeroMemory((PVOID)&CompEntry, sizeof(COMPATIBILITY_ENTRY));
    
    CompEntry.TextName = TxtFileName;
    CompEntry.HtmlName = HtmlFileName;
    
    InitializeStringLists();
    
    Result = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REGKEY_SERVICES,
            0,
            KEY_READ,
            &ServicesKey
            );

    if (Result != ERROR_SUCCESS) {
        return TRUE;
    }
    
    // enumerate all of the services
    
    Result = RegQueryInfoKey(
        ServicesKey,
        NULL,
        NULL,
        NULL,
        &SubKeyCount,
        &MaxKeyLen,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

    if (Result != ERROR_SUCCESS) {
        goto exit;
    }
    
    KeyNameBuffer = (LPWSTR) LocalAlloc( LPTR, (MaxKeyLen + 1) * sizeof(WCHAR));

    if (KeyNameBuffer == NULL) {
        goto exit;
    }
    
    Size = ExpandEnvironmentStrings( DRIVER_DIRECTORY, NULL, 0 );

    DriverDirectory = LocalAlloc( LPTR, Size * sizeof(WCHAR) );

    if (DriverDirectory != NULL) {
        ExpandEnvironmentStrings( DRIVER_DIRECTORY, DriverDirectory, Size );
    } else {
        goto exit;
    }
    
    for (Index = 0; Index < SubKeyCount; Index++) {
        DWORD StartValue;
        DWORD SetupChecked;

        Size = MaxKeyLen;
        Result = RegEnumKeyEx(
            ServicesKey,
            Index,
            KeyNameBuffer,
            &Size,
            NULL,
            NULL,
            NULL,
            NULL
            );

        if (Result != ERROR_SUCCESS) {
            goto exit;
        }
        
        Result = RegOpenKeyEx(
                ServicesKey,
                KeyNameBuffer,
                0,
                KEY_READ,
                &DriverKey
                );
        if (Result != ERROR_SUCCESS) {
            continue;
        }
        
        Size = SIZE_STRINGBUF;
        
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_GROUP,
                0,
                &Type,
                ValueBuffer,
                &Size
                );
        if (Result != ERROR_SUCCESS || Type != REG_SZ) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        
        //
        // if the driver is disabled, ignore it
        //
        Size = sizeof(StartValue);
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_START,
                0,
                &Type,
                (LPBYTE)&StartValue,
                &Size
                );

        if (Result != ERROR_SUCCESS || Type != REG_DWORD) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        //
        // if winnt32 has checked this driver, skip it
        //
        Size = sizeof(SetupChecked);
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_SETUPCHECKED,
                0,
                &Type,
                (LPBYTE)&SetupChecked,
                &Size
                );

        if (Result == ERROR_SUCCESS && Type == REG_DWORD) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        // 
        // if the group is not "filter" ignore it.
        //
        
        if (_wcsicmp( L"filter", (LPWSTR) ValueBuffer ) == 0 && 
            StartValue != SERVICE_DISABLED &&
            IsBadFilter(KeyNameBuffer, DriverDirectory)) {
                CompEntry.Description = (LPTSTR) KeyNameBuffer;
                if(!CompatibilityCallback(&CompEntry, Context)){
                    DWORD Error;
                    Error = GetLastError();
                }
        }
    
        RegCloseKey( DriverKey );
    }
    
exit:
    RegCloseKey( ServicesKey );
    
    LocalFree( KeyNameBuffer );
    LocalFree( DriverDirectory );
    
    FreeStringLists();

    return TRUE;
   
}

BOOL
IsBadFilter(
    LPWSTR FilterName,
    LPWSTR DriverDirectory
    )
/*++

Routine Description:

    Checks the driver name against the list of good drivers.  If it's not in the list, then scan the import
    table looking for certain imports.

Arguments:

    FilterName      - The services key name (driver name).
    DriverDirectory - Full path name to the driver.

Return Value:

    TRUE if the driver meets the above criteria, FALSE otherwise
--*/
{
    PLOADED_IMAGE Image;
    LPWSTR UnicodeImagePath;
    DWORD Size;
    LPSTR AnsiImagePath;
    BOOL RetVal = FALSE;
    PSTRING_LIST_ENTRY StringList;

    
    //
    // if the driver is in the known good list, ignore it
    //
    
    StringList = GoodFilterList.Next;

    while(StringList){
        if (_wcsicmp( (LPWSTR) StringList->String, FilterName) == 0) {
            return FALSE;
        }
        StringList = StringList->Next;
    }
    
    //
    // build up the path name to the driver
    //
    
    Size = wcslen( DriverDirectory );
    Size += wcslen( FilterName );
    Size += wcslen( DRIVER_SUFFIX );
    Size++;

    UnicodeImagePath = LocalAlloc( LPTR, Size * sizeof(WCHAR));
    
    if (UnicodeImagePath != NULL) {
        wcscpy( UnicodeImagePath, DriverDirectory );
        wcscat( UnicodeImagePath, FilterName );
        wcscat( UnicodeImagePath, DRIVER_SUFFIX );
    } else {
        return FALSE;
    }
    
    //
    // imagehlp wants ansi strings
    //
    AnsiImagePath = UnicodeStringToAnsiString( UnicodeImagePath );

    
    // 
    // The following code was transliterated from the linker.  Note
    // that the strings in the import table are ansi.
    //
    
    if (AnsiImagePath) {
        PIMAGE_IMPORT_DESCRIPTOR Imports;
        PIMAGE_NT_HEADERS NtHeader;
        PIMAGE_SECTION_HEADER FirstImageSectionHeader;
        DWORD ImportSize;

        Image = ImageLoad( AnsiImagePath, NULL );
        
        if (Image == NULL) {
            goto exit;
        }
        
        NtHeader = ImageNtHeader( (PVOID)Image->MappedAddress );
        
        Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                        (PVOID)Image->MappedAddress,
                                        FALSE,
                                        IMAGE_DIRECTORY_ENTRY_IMPORT,
                                        &ImportSize
                                        );
        FirstImageSectionHeader = IMAGE_FIRST_SECTION( NtHeader );

        for (;!RetVal; Imports++) {
            WORD StringSection = 0;
            WORD IATSection;
            WORD i;
            DWORD Rva;
            DWORD RvaMax;
            DWORD IATRva;
            DWORD INTRva;
            DWORDLONG INTVa;
            PIMAGE_SECTION_HEADER ImageSectionHeader;
            LPSTR Name;

            if (Imports->Characteristics == 0 && Imports->Name == 0 && Imports->FirstThunk == 0) {
                break;
            }
            
            for (i = 0; i < NtHeader->FileHeader.NumberOfSections; i++) {
            
                ImageSectionHeader = &FirstImageSectionHeader[i];
                                        
                Rva = ImageSectionHeader->VirtualAddress;
                RvaMax = Rva + ImageSectionHeader->SizeOfRawData;
    
                if (Imports->Name >= Rva && Imports->Name < RvaMax) {
                    StringSection = i;
                }

                if (Imports->FirstThunk >= Rva && Imports->FirstThunk < RvaMax) {
                    IATSection = i;
                }
            }

            ImageSectionHeader = ImageRvaToSection( NtHeader, Image->MappedAddress, Imports->Name );

            IATRva = Imports->FirstThunk -
                FirstImageSectionHeader[IATSection].VirtualAddress + 
                FirstImageSectionHeader[IATSection].PointerToRawData;
            
            if (Imports->Characteristics == 0) {
                INTRva = IATRva;
                IATRva = 0;
                INTVa = 0;
            } else {

                INTRva = Imports->Characteristics -
                    ImageSectionHeader->VirtualAddress + 
                    ImageSectionHeader->PointerToRawData;
                
                if (Imports->TimeDateStamp == 0) {

                    IATRva = 0;
                }
            
                INTVa = (DWORDLONG) ImageRvaToVa( 
                            NtHeader, 
                            Image->MappedAddress,
                            Imports->OriginalFirstThunk, 
                            NULL 
                            );

                Name = (LPSTR) ImageRvaToVa(
                    NtHeader,
                    Image->MappedAddress,
                    Imports->Name - FirstImageSectionHeader->VirtualAddress + FirstImageSectionHeader->PointerToRawData,
                    NULL
                    );
            
                //
                // We only care about imports from ntoskrnl.exe
                //
                
                if (strcmp( Name, "ntoskrnl.exe" ) != 0) {
                    continue;
                }
                
                while(!RetVal){
                    PIMAGE_THUNK_DATA32 Thunk;
                    PIMAGE_THUNK_DATA32 IATThunk;

                    Thunk = (PIMAGE_THUNK_DATA32) INTVa;
                    
                    if (Thunk->u1.AddressOfData == 0) {
                        break;
                    }
                    
                    //
                    // Don't need to handle imports by ordinal
                    //
                    if (IMAGE_SNAP_BY_ORDINAL32(Thunk->u1.Ordinal)) {
                        break;
                    }
                    
                    INTVa += sizeof(IMAGE_THUNK_DATA32);

                    for (i = 0; i < NtHeader->FileHeader.NumberOfSections; i++ ) {
                        ImageSectionHeader = &FirstImageSectionHeader[i];
                                                
                        Rva = ImageSectionHeader->VirtualAddress;
                        RvaMax = Rva + ImageSectionHeader->SizeOfRawData;
        
                        if ((DWORD)Thunk->u1.AddressOfData >= Rva && (DWORD)Thunk->u1.AddressOfData < RvaMax) {
                            break;
                        }
                    }    
                    
                    Name = (LPSTR) ImageRvaToVa(
                        NtHeader,
                        Image->MappedAddress,
                        (DWORD)Thunk->u1.AddressOfData - FirstImageSectionHeader[i].VirtualAddress + FirstImageSectionHeader[i].PointerToRawData,
                        NULL
                        );
                    
                    Name += sizeof(WORD);
                        
                    //
                    // Compare the import name with prefixes in the prefix list.  If there is a substring match,
                    // then this driver will stop setup.
                    //
                    
                    StringList = ImportPrefixList.Next;
                    while (StringList) {
                        if (_strnicmp(Name, StringList->String, strlen(StringList->String)) == 0) {
                            RetVal = TRUE;
                            break;
                        }                    
                        StringList = StringList->Next;    
                    }
                }
                
            }
     
        }
            
    }     
exit:    
    
    if (Image != NULL) {
        ImageUnload( Image );
    }
    LocalFree( AnsiImagePath );    
    LocalFree( UnicodeImagePath );    
    
    return RetVal;
}

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    )
/*++

Routine Description:

    Allocates a buffer and converts a Unicode string into an ansi string and copies
    it into the buffer.

Arguments:

    UnicodeString   - The Unicode string to convert.

Return Value:

    A pointer to the buffer containing the ansi string.  Note that the caller must free this
    buffer.
--*/
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) LocalAlloc( LPTR, Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}

LPWSTR
GetSection(
    LPCWSTR Name,
    LPWSTR FileName
    )
/*++

Routine Description:

    Reads the given section from the inf file.

Arguments:

    Name          - The section name.
    FileName      - Full path name of the inf file.

Return Value:

    A pointer to a buffer containing the entire section.  See docs on GetPrivateProfileSection.
--*/
{
    LPWSTR SectionBuffer;
    DWORD Size = SIZE_SECTIONBUF;
    DWORD ReturnedSize;

    SectionBuffer = LocalAlloc( LPTR, Size * sizeof(WCHAR) );

    if (SectionBuffer == NULL) {
        return NULL;
    }
    
    while(TRUE){
        
        ReturnedSize = GetPrivateProfileSection( Name, SectionBuffer, Size, FileName  );
        
        if (ReturnedSize == Size - 2) {
        
            LocalFree( SectionBuffer );
            
            Size *= 2;

            SectionBuffer = LocalAlloc( LPTR, Size * sizeof(WCHAR) );
        
            if (SectionBuffer == NULL) {
                return NULL;
            }
        } else if (ReturnedSize == 0){
            return NULL;
        } else {
            break;
        }

    }
    
    return SectionBuffer;
}


VOID
ReplaceExtension(
    LPWSTR Path,
    LPWSTR NewExt
    )
/*++

Routine Description:

    Replaces the file extension in Path with the one in NewExt.

Arguments:

    Path      - File name
    NewExt    - the new extension

Return Value:

    
--*/
{
    LPWSTR Temp;

    Temp = wcsrchr( Path, L'.' );

    if (Temp) {
        wcscpy( ++Temp, NewExt );
    } else {
        wcscat( Path, L"." );
        wcscat( Path, NewExt );
    }
}


VOID
InitializeStringLists(
    VOID
    )
/*++

Routine Description:

    Initialize the string lists and the file names.

Arguments:


Return Value:
--*/
{

    WCHAR InfFileName[MAX_PATH];
    DWORD Result;
    LPWSTR UStr;
    LPSTR AStr;
    PSTRING_LIST_ENTRY NewString;

    //
    // The GoodFilterList is Unicode.  Since the buffer returned by GetSection has
    // Unicode strings in it, we can keep it around and just point the string list
    // into that buffer.  Since the ImportPrefixList contains Ansi strings, we allocate
    // a new buffer and convert from Unicode to Ansi.  These strings have to be individually
    // freed.
    //

    InitializeList( &GoodFilterList );
    InitializeList( &ImportPrefixList );
    
    Result = GetModuleFileName( MyhInstance, InfFileName, MAX_PATH );

    if (Result == 0) {
        return;
    }
    
    wcscpy(HtmlFileName, InfFileName);

    wcscpy(TxtFileName, InfFileName);

    ReplaceExtension( HtmlFileName, L"htm" );
    ReplaceExtension( TxtFileName, L"txt" );
    ReplaceExtension( InfFileName, L"inf" );

    GoodFilterBuffer = GetSection( L"filters", InfFileName );
    ImportPrefixBuffer = GetSection( L"imports", InfFileName );
        
    //
    // Build the GoodFilterList (Unicode)
    //
    
    for (UStr = GoodFilterBuffer; UStr && *UStr; UStr++) {
        
        NewString = (PSTRING_LIST_ENTRY) LocalAlloc( LPTR, sizeof(STRING_LIST_ENTRY));
    
        if (NewString == NULL) {
            return;
        }

        NewString->String = (LPVOID)UStr;
        
        PushEntryList( &GoodFilterList, NewString );
        
        while(*++UStr){
            ;
        }
    }

    //
    // Build the ImportPrefixList.  Convert the Unicode strings to Ansi.
    //

    for (UStr = ImportPrefixBuffer; UStr && *UStr; UStr++) {
        
        NewString = (PSTRING_LIST_ENTRY) LocalAlloc( LPTR, sizeof(STRING_LIST_ENTRY));
    
        if (NewString == NULL) {
            return;
        }
    
        NewString->String = (LPVOID)UnicodeStringToAnsiString( UStr );
        
        PushEntryList( &ImportPrefixList, NewString );
        
        while(*++UStr){
            ;
        }
    }   
}

VOID
FreeStringLists(
    VOID
    )
/*++

Routine Description:

    Frees the string lists, ansi strings and buffers holding inf sections.

Arguments:

Return Value:

--*/
{
    PSTRING_LIST_ENTRY Temp;
    
    
    Temp = PopEntryList( &GoodFilterList );
    while(Temp) {
        LocalFree( Temp );
        Temp = PopEntryList( &GoodFilterList );
    }

    Temp = PopEntryList( &ImportPrefixList );
    while (Temp) {
        LocalFree( Temp->String );
        LocalFree( Temp );
        Temp = PopEntryList( &ImportPrefixList );
    }

    LocalFree( GoodFilterBuffer );
    LocalFree( ImportPrefixBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\faulth\faulth.c ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    faulth.c

Abstract:
    Implements fault reporting functions

Revision History:
    Much of this code taken from admin\pchealth\client\faultrep

******************************************************************************/

#include <windows.h>
#include <winver.h>
#include <ntverp.h>
#include <errorrep.h>
#include "util.h"
#include "faulth.h"

//#define TEST_WATSON 1

static LPWSTR
plstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    __try {
        src = (LPWSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
                *dst = '\0';
                }
            else {
                dst--;
                *dst = '\0';
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

#define sizeofSTRW(wsz) sizeof(wsz) / sizeof(wsz[0])
///////////////////////////////////////////////////////////////////////////////
// Global stuff

#ifdef TEST_WATSON
const CHAR  c_szDWDefServerI[]  = "officewatson";
#else
const CHAR  c_szDWDefServerI[]  = "watson.microsoft.com";
#endif
const CHAR  c_szDWBrand[]       = "WINDOWS";
const WCHAR c_wzDWDefAppName[]  = L"Application";
const CHAR  c_wszDWCmdLineU[]   = "%s\\dwwin.exe -x -s %lu";
#define c_DWDefaultLCID           1033

_inline DWORD RolloverSubtract(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : (dwA + ((DWORD)-1 - dwB));
}

DWORD
MyGetModuleFileNameA(
    IN      HMODULE Module,
    OUT     PSTR Buffer,
    IN      DWORD BufferLength
    )
{
    DWORD d = GetModuleFileNameA(Module, Buffer, BufferLength);
    Buffer[BufferLength - 1] = 0;
    return d < BufferLength ? d : 0;
}

#ifdef TEST_WATSON
HANDLE hFaultLog = INVALID_HANDLE_VALUE;
char    *c_wszLogFileName = "faulth.log";

// Need to synchroize this?
static DebugLog(char *pszMessage, ...)
{
    va_list arglist;

    if( !pszMessage)
        return 0;

    va_start(arglist,pszMessage);
    
    if (hFaultLog != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME  st;
        DWORD       cb, cbWritten;
        char        szMsg[512];

        GetSystemTime(&st);
        cb = wsprintf(szMsg, 
                      "%02d-%02d-%04d %02d:%02d:%02d ",
                      st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond
                      );
        WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
        /*cb = FormatMessageA(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                    pszMessage,
                    0,0,
                    szMsg,
                    0,
                    &arglist
                    );*/
        cb = wsprintf(szMsg, pszMessage, &arglist);
        WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
    }
    va_end(arglist);
    return 1;
}
#else

#define DebugLog(x)

#endif

HINSTANCE g_hInstance = NULL;

///////////////////////////////////////////////////////////////////////////////
// DllMain

// **************************************************************************

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            //DisableThreadLibraryCalls(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}


static
EFaultRepRetVal
StartDWException( 
                  IN   PSETUP_FAULT_HANDLER This,
                  IN   LPEXCEPTION_POINTERS pep,
                  IN   DWORD dwOpt,
                  IN   DWORD dwFlags,
                  IN   DWORD dwTimeToWait)
{
    SECURITY_ATTRIBUTES sa;
    PROCESS_INFORMATION pi;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    DWSharedMem15       *pdwsm = NULL;
    STARTUPINFOA        si;
    HRESULT             hr = NOERROR;
    HANDLE              hevDone = NULL, hevAlive = NULL, hmut = NULL;
    HANDLE              hfmShared = NULL, hProc = NULL;
    HANDLE              rghWait[2];
    DWORD               dw, dwStart;
    BOOL                fDWRunning = TRUE;
    char                szCmdLine[MAX_PATH], szDir[MAX_PATH];
    char                szModuleFileName[DW_MAX_PATH];
    char                *pch;


    VALIDATEPARM(hr, (pep == NULL));
    if (FAILED(hr))
        goto done;

    // we need the following things to be inheritable, so create a SD that
    //  says it can be.
    ZeroMemory(&sa, sizeof(sa));
    sa.nLength        = sizeof(sa);
    sa.bInheritHandle = TRUE;

    // create the necessary events & mutexes
    hevDone = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevDone != NULL));
    if (FAILED(hr))
        goto done;

    hevAlive = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevAlive != NULL));
    if (FAILED(hr))
        goto done;

    hmut = CreateMutex(&sa, FALSE, NULL);
    TESTBOOL(hr, (hmut != NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), 
                                 GetCurrentProcess(), &hProc, 
                                 PROCESS_ALL_ACCESS, TRUE, 0));
    if (FAILED(hr))
        goto done;

    // create the shared memory region & map it
    hfmShared = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0,
                                  sizeof(DWSharedMem), NULL);
    TESTBOOL(hr, (hfmShared != NULL));
    if (FAILED(hr))
        goto done;

    pdwsm = (DWSharedMem *)MapViewOfFile(hfmShared, 
                                         FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 
                                         0);
    TESTBOOL(hr, (pdwsm != NULL));
    if (FAILED(hr))
        goto done;


    // populate all the stuff that DW needs
    ZeroMemory(pdwsm, sizeof(DWSharedMem15));

    pdwsm->dwSize            = sizeof(DWSharedMem15);
    pdwsm->pid               = GetCurrentProcessId();
    pdwsm->tid               = GetCurrentThreadId();
    pdwsm->eip               = (DWORD_PTR)pep->ExceptionRecord->ExceptionAddress;
    pdwsm->pep               = pep;
    pdwsm->hEventDone        = hevDone;
    pdwsm->hEventNotifyDone  = NULL;
    pdwsm->hEventAlive       = hevAlive;
    pdwsm->hMutex            = hmut;
    pdwsm->hProc             = hProc;
    pdwsm->bfDWBehaviorFlags = dwFlags;
    pdwsm->msoctdsResult     = msoctdsNull;
    pdwsm->fReportProblem    = FALSE;
    pdwsm->bfmsoctdsOffer    = msoctdsQuit;
    pdwsm->bfmsoctdsNotify   = 0;
    if (dwOpt == 1)
        pdwsm->bfmsoctdsOffer |= msoctdsDebug;
    pdwsm->bfmsoctdsLetRun   = pdwsm->bfmsoctdsOffer;
    pdwsm->iPingCurrent      = 0;
    pdwsm->iPingEnd          = 0;
    pdwsm->lcidUI            = 1033;

    lstrcpynA( pdwsm->szServer, This->szURL, DW_MAX_SERVERNAME);
    lstrcpynA( pdwsm->szBrand, c_szDWBrand, DW_APPNAME_LENGTH);
    MyGetModuleFileNameA( NULL, szModuleFileName, DW_MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szModuleFileName, -1, pdwsm->wzModuleFileName, DW_MAX_PATH);

    plstrcpynW( pdwsm->wzFormalAppName, This->wzAppName, DW_APPNAME_LENGTH);
    plstrcpynW( pdwsm->wzAdditionalFile, This->wzAdditionalFiles, DW_MAX_ADDFILES);
    plstrcpynW( pdwsm->wzErrorText, This->wzErrorText, DW_MAX_ERROR_CWC);

    // create the process

    if (!MyGetModuleFileNameA( g_hInstance, szDir, MAX_PATH) ||
        !(pch = strrchr (szDir, '\\'))) {
        goto done;
    }
    *pch = '\0';
    wsprintf( szCmdLine, c_wszDWCmdLineU, szDir, hfmShared);
    DebugLog( "CommandLine ");
    DebugLog( szCmdLine);
    DebugLog( "CurrentDir ");
    DebugLog( szDir);
        
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb        = sizeof(si);
    si.lpDesktop = "Winsta0\\Default";

    TESTBOOL(hr, CreateProcessA(NULL, szCmdLine, NULL, NULL, TRUE, 
                                CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                                NULL, szDir, &si, &pi));
    if (FAILED(hr))
        goto done;

    // don't need the thread handle & we gotta close it, so close it now
    CloseHandle(pi.hThread);
    
    // assume we succeed from here on...
    frrvRet = frrvOk;

    rghWait[0] = hevAlive;
    rghWait[1] = pi.hProcess;

    dwStart = GetTickCount();
    while(fDWRunning)
    {
        // gotta periodically get the Alive signal from DW.  
        switch(WaitForMultipleObjects(2, rghWait, FALSE, 120000))
        {
            case WAIT_OBJECT_0:
                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                    fDWRunning = FALSE;

                if (dwTimeToWait != (DWORD)-1 && 
                    RolloverSubtract(GetTickCount(), dwStart) > dwTimeToWait)
                {
                    frrvRet = frrvErrTimeout;
                    fDWRunning = FALSE;
                }

                continue;

            case WAIT_OBJECT_0 + 1:
                fDWRunning = FALSE;
                continue;
        }

        switch(WaitForSingleObject(hmut, DW_TIMEOUT_VALUE))
        {
            // yay!  we got the mutex.  Try to detemine if DW finally responded
            //  while we were grabbing the mutex.
            case WAIT_OBJECT_0:
                switch(WaitForMultipleObjects(2, rghWait, FALSE, 0))
                {
                    // If it hasn't responded, tell it to go away & fall thru 
                    //  into the 'it died' case.
                    case WAIT_TIMEOUT:
                        SetEvent(hevDone);

                    // It died.  Clean up.
                    case WAIT_OBJECT_0 + 1:
                        fDWRunning = FALSE;
                        frrvRet = frrvErrNoDW;
                        continue;
                }

                // ok, it responded.  Is it done?
                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                    fDWRunning = FALSE;

                ReleaseMutex(hmut);
                break;

            // if the wait was abandoned, it means DW has gone to the great bit
            //  bucket in the sky without cleaning up.  So release the mutex and
            //  fall into the default case
            case WAIT_ABANDONED:
                ReleaseMutex(hmut);
        
            // if we timed out or otherwise failed, just die.
            default:
                frrvRet    = frrvErrNoDW;
                fDWRunning = FALSE;
                break;
        }
    }
    if (frrvRet != frrvOk)
    {
        CloseHandle(pi.hProcess);
        goto done;
    }

    // if user told us to debug, return that back to the 
    if (pdwsm->msoctdsResult == msoctdsDebug)
        frrvRet = frrvLaunchDebugger;

    // if we're going to launch Dr. Watson, wait for the DW process to die.
    //  Give it 5 minutes.  If the user doesn't hit close by then, just return
    //  anyway...
    if (dwOpt == (DWORD)-1)
    {
        if (WaitForSingleObject(pi.hProcess, 300000) == WAIT_TIMEOUT)
            frrvRet = frrvErrTimeout;
    }

    CloseHandle(pi.hProcess);

done:
    // preserve the error code so that the following calls don't overwrite it
    dw = GetLastError();

    if (pdwsm != NULL)
        UnmapViewOfFile(pdwsm);
    if (hfmShared != NULL)
        CloseHandle(hfmShared);
    if (hevDone != NULL)
        CloseHandle(hevDone);
    if (hevAlive != NULL)
        CloseHandle(hevAlive);
    if (hmut != NULL)
        CloseHandle(hmut);
    if (hProc != NULL)
        CloseHandle(hProc);

    SetLastError(dw);

    return frrvRet;
}

static
EFaultRepRetVal
FaultHandler(
    IN   PSETUP_FAULT_HANDLER This,
    IN   EXCEPTION_POINTERS *pep,
    IN   DWORD dwOpt)
{
    
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    DWORD               dwFlags = 0;
    char                wszFile[MAX_PATH], *pwsz;

    DebugLog("Inside FaultHandler\r\n");
    MyGetModuleFileNameA(NULL, wszFile, sizeof(wszFile)/sizeof(wszFile[0]));

    // Find last backslash
    for(pwsz = wszFile + strlen(wszFile);
        pwsz >= wszFile && *pwsz != '\\';
        pwsz--);

    // Should never happen
    if (pwsz < wszFile)
        goto done;

    if (*pwsz == '\\')
        pwsz++;

    // Don't want to debug dwwin.exe itself.
    if (_stricmp(pwsz, "dwwin.exe") == 0 
        // || _stricmp(pwsz, "dumprep.exe") == 0
        )
        goto done;

    frrvRet = StartDWException(This, pep, dwOpt, dwFlags, -1);

done:
    return frrvRet;
}


static
BOOL
FAULTHIsSupported(
    IN   PSETUP_FAULT_HANDLER This
    )
{
    BOOL useExtendedInfo;
    DWORD dwServicePack;
    DWORD dwVersion,dwTemp,dwInfoSize;
    char *pInfo;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    union {
        OSVERSIONINFO Normal;
        OSVERSIONINFOEX Ex;
    } Ovi;

    DebugLog("Inside FAULTHIsSupported\r\n");
    if ( !This) {
        return(FALSE);
    }

    useExtendedInfo = TRUE;
    Ovi.Ex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Ex) ) {
        //
        // EX size not available; try the normal one
        //

        Ovi.Normal.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Normal) ) {
            DebugLog("Inside FAULTHIsSupported:Could not get os version!\r\n");
            return(FALSE);
        }
        useExtendedInfo = FALSE;
    }
    if (useExtendedInfo) {
        dwServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
    } else {
        dwServicePack = 0;
    }
    dwVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;
    switch (Ovi.Normal.dwPlatformId) {
        case VER_PLATFORM_WIN32s:
            DebugLog("Inside FAULTHIsSupported:Unsupported win32s!\r\n");
            return(FALSE);
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            if( dwVersion < 410) {
                DebugLog("Inside FAULTHIsSupported:Unsupported win9x!\r\n");
                return(FALSE);
            }
            break;
        case VER_PLATFORM_WIN32_NT:
            if( dwVersion < 400) {
                DebugLog("Inside FAULTHIsSupported:Unsupported winNT!\r\n");
                return(FALSE);
            }

            if( dwVersion == 400 && dwServicePack < 500) {
                DebugLog("Inside FAULTHIsSupported:Unsupported ServicePack!\r\n");
                return(FALSE);
            }
            break;
        default:
            return(FALSE);
    }

    // Test for wininet.dll from ie 4.01.
    dwInfoSize =  GetFileVersionInfoSize( FAULTH_WININET_NAME, &dwTemp );
    if( !dwInfoSize) {
        DebugLog("Inside FAULTHIsSupported:Could not find wininet.dll or determine version.");
        return( FALSE);
    }

    pInfo = HeapAlloc( GetProcessHeap(), 0, dwInfoSize);

    if( !pInfo || 
        !GetFileVersionInfo( FAULTH_WININET_NAME, dwTemp, dwInfoSize, pInfo) ||
        !VerQueryValue( pInfo, "\\", &VsInfo, &DataLength))
    {
        DebugLog("Inside FAULTHIsSupported:Could not find wininet.dll or get version.");
        HeapFree( GetProcessHeap(), 0, pInfo);
        return( FALSE);
    }
    if( VsInfo->dwFileVersionMS < FAULTH_WININET_MIN_MS ||
        ((VsInfo->dwFileVersionMS == FAULTH_WININET_MIN_MS) && (VsInfo->dwFileVersionLS < FAULTH_WININET_MIN_LS))) {
        DebugLog("Inside FAULTHIsSupported:Require a more recent wininet.dll.");
        HeapFree( GetProcessHeap(), 0, pInfo);
        return( FALSE);
    }
    HeapFree( GetProcessHeap(), 0, pInfo);
    return(TRUE);
}

static
void
FAULTHSetURLA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszURL
    )
{
    DebugLog("Inside FAULTHSetURLA\r\n");
    if (This && pszURL){
        lstrcpynA( This->szURL, pszURL, DW_MAX_SERVERNAME);
    }
}

static
void
FAULTHSetURLW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzURL
    )
{
    DebugLog("Inside FAULTHSetURLW\r\n");
    if (This && pwzURL){
        WideCharToMultiByte( CP_ACP, 0, pwzURL, -1, This->szURL, DW_MAX_SERVERNAME, NULL, NULL);
    }
}

static
void
FAULTHSetErrorTextA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszErrorText
    )
{
    DebugLog("Inside FAULTHSetErrorTextA\r\n");
    if (This && pszErrorText){
        MultiByteToWideChar( CP_ACP, 0, pszErrorText, -1, This->wzErrorText, DW_MAX_ERROR_CWC);
    }
}

static
void
FAULTHSetErrorTextW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzErrorText
    )
{
    DebugLog("Inside FAULTHSetErrorTextW\r\n");
    if (This && pwzErrorText){
        plstrcpynW( This->wzErrorText, pwzErrorText, DW_MAX_ERROR_CWC);
    }
}


static
void
FAULTHSetAdditionalFilesA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszAdditionalFiles
    )
{
    DebugLog("Inside FAULTHSetAdditionalFilesA\r\n");
    if (This && pszAdditionalFiles){
        MultiByteToWideChar( CP_ACP, 0, pszAdditionalFiles, -1, This->wzAdditionalFiles, DW_MAX_ADDFILES);
    }
}

static
void
FAULTHSetAdditionalFilesW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzAdditionalFiles
    )
{
    DebugLog("Inside FAULTHSetAdditionalFilesW\r\n");
    if (This && pwzAdditionalFiles){
        plstrcpynW( This->wzAdditionalFiles, pwzAdditionalFiles, DW_MAX_ADDFILES);
    }
}

static
void
FAULTHSetAppNameA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszAppName
    )
{
    DebugLog("Inside FAULTHAppNameA\r\n");
    if (This && pszAppName){
        MultiByteToWideChar( CP_ACP, 0, pszAppName, -1, This->wzAppName, DW_APPNAME_LENGTH);
    }
}

static
void
FAULTHSetAppNameW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzAppName
    )
{
    DebugLog("Inside FAULTHAppNameW\r\n");
    if (This && pwzAppName){
        plstrcpynW( This->wzAppName, pwzAppName, DW_APPNAME_LENGTH);
    }
}

static
void
FAULTHSetLCID(
    IN   PSETUP_FAULT_HANDLER This,
    IN   LCID lcid
    )
{
    DebugLog("Inside FAULTHSetLCID\r\n");
    if (This){
        This->lcid = lcid;
    }
}


static
VOID
FAULTHInit(
    IN   PSETUP_FAULT_HANDLER This
    )
{
    DebugLog("Inside FAULTHInit\r\n");
    if( This){
        This->SetURLA = FAULTHSetURLA;
        This->SetURLW = FAULTHSetURLW;
        This->SetAppNameA = FAULTHSetAppNameA;
        This->SetAppNameW = FAULTHSetAppNameW;
        This->SetErrorTextA = FAULTHSetErrorTextA;
        This->SetErrorTextW = FAULTHSetErrorTextW;
        This->SetAdditionalFilesA = FAULTHSetAdditionalFilesA;
        This->SetAdditionalFilesW = FAULTHSetAdditionalFilesW;
        This->SetLCID = FAULTHSetLCID;
        This->IsSupported = FAULTHIsSupported;
        This->Report = FaultHandler;
        This->bDebug = FALSE;
        FAULTHSetURLA(This, c_szDWDefServerI);
        FAULTHSetAppNameW(This, c_wzDWDefAppName);
        FAULTHSetAdditionalFilesW(This, L"");
        FAULTHSetErrorTextW(This,L"");
        FAULTHSetLCID(This,c_DWDefaultLCID);
    }
#ifdef TEST_WATSON
    {
        char szFile[MAX_PATH], *pwsz;

        GetSystemDirectoryA(szFile, sizeof(szFile)/sizeof(szFile[0]));
        szFile[3] = '\0';
        strcat(szFile, c_wszLogFileName);
        hFaultLog = CreateFileA(szFile, GENERIC_WRITE, 
                                        FILE_SHARE_WRITE | FILE_SHARE_READ, 
                                        NULL, OPEN_ALWAYS, 0, NULL);
    
        if (hFaultLog != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  st;
            DWORD       cb, cbWritten;
            char        szMsg[512];
    
            GetSystemTime(&st);
            cb = wsprintf(szMsg, 
                          "%02d-%02d-%04d %02d:%02d:%02d Initalization\r\n", 
                          st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, 
                          st.wSecond);
            SetFilePointer(hFaultLog, 0, NULL, FILE_END);
            WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
        }
    }
    DebugLog("exiting FAULTHInit\r\n");
#endif
}

PSETUP_FAULT_HANDLER APIENTRY
FAULTHCreate( VOID)
{
    PSETUP_FAULT_HANDLER This = NULL;

    DebugLog("Inside FAULTHCreate\r\n");
    This = HeapAlloc( GetProcessHeap(), 0, sizeof(SETUP_FAULT_HANDLER));

    if( This) {
        FAULTHInit( This);
    }

    DebugLog("exiting FAULTCreate\r\n");
    return This;
}

VOID APIENTRY
FAULTHDelete(
    IN PSETUP_FAULT_HANDLER This
    )
{
    DebugLog("Inside FAULTHDelete\r\n");
    if( This) {
        HeapFree( GetProcessHeap(), 0, This);
    }
#ifdef TEST_WATSON
    if (hFaultLog != INVALID_HANDLE_VALUE) {
        CloseHandle(hFaultLog);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\faulth\faulth.h ===
#include "msodw.h"

#define FAULTH_CREATE_NAME  "FAULTHCreate"
#define FAULTH_DELETE_NAME  "FAULTHDelete"
#define FAULTH_WININET_NAME "WININET.DLL"

#define WININET_MIN_VERSION 4.72.2106.5
#define FAULTH_WININET_MIN_MS ((4<<16)+72)
#define FAULTH_WININET_MIN_LS ((2106<<16)+5)

#define DW_MAX_ADDFILES     1024

typedef struct _SETUP_FAULT_HANDLER *PSETUP_FAULT_HANDLER;

// Ascii Version of functions
typedef void (* PFAULTHSetURLMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszURL
                            );

typedef void (* PFAULTHSetAdditionalFilesMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszAdditionalFiles
                            );

typedef void (* PFAULTHSetAppNameMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszAppName
                            );

typedef void (* PFAULTHSetErrorTextA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszErrorText
                            );


// Unicode Version of functions
typedef void (* PFAULTHSetURLMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszURL
                            );

typedef void (* PFAULTHSetAdditionalFilesMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszAdditionalFiles
                            );

typedef void (* PFAULTHSetAppNameMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszAppName
                            );

typedef void (* PFAULTHSetErrorTextW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszErrorText
                            );


typedef void (* PFAULTHSetLCID)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN LCID                 lcid
                            );

typedef BOOL (* PFAULTHIsSupported)(
                            IN PSETUP_FAULT_HANDLER This
                            );

typedef EFaultRepRetVal (*PREPORTFAULTA_FN)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN LPEXCEPTION_POINTERS pep,
                            IN DWORD dwReserved
                            );

typedef struct _SETUP_FAULT_HANDLER {
    //
    // Data members
    //
    CHAR                szURL[DW_MAX_SERVERNAME];
    WCHAR               wzAppName[DW_APPNAME_LENGTH];
    WCHAR               wzAdditionalFiles[DW_MAX_ADDFILES];
    WCHAR               wzErrorText[DW_MAX_ERROR_CWC];
    LCID                lcid;
    BOOL                bDebug;

    //
    // Methods
    //
    PFAULTHSetURLMethodA   SetURLA;
    PFAULTHSetAppNameMethodA   SetAppNameA;
    PFAULTHSetAdditionalFilesMethodA SetAdditionalFilesA;
    PFAULTHSetErrorTextA SetErrorTextA;

    PFAULTHSetURLMethodW   SetURLW;
    PFAULTHSetAppNameMethodW   SetAppNameW;
    PFAULTHSetAdditionalFilesMethodW SetAdditionalFilesW;
    PFAULTHSetErrorTextW SetErrorTextW;
    
    
    PFAULTHSetLCID SetLCID;
    PFAULTHIsSupported IsSupported;
    PREPORTFAULTA_FN      Report;

} SETUP_FAULT_HANDLER,*PSETUP_FAULT_HANDLER;

typedef PSETUP_FAULT_HANDLER (APIENTRY *PFAULTHCreate) (VOID);

typedef VOID (APIENTRY *PFAULTHDelete)(IN PSETUP_FAULT_HANDLER This);

PSETUP_FAULT_HANDLER
FAULTHCreate(
    VOID
    );

VOID
FAULTHDelete(
    IN PSETUP_FAULT_HANDLER This
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\ftcomp\ftcomp.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomp.h

Abstract:

    Header for the compatibility dll 

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Notes:

Revision History:

--*/

#pragma once
#ifndef _FTCOMP_H
#define _FTCOMP_H

//
// Exports
//

BOOL WINAPI
FtCompatibilityCheckError(
    PCOMPAIBILITYCALLBACK   CompatibilityCallback,
    LPVOID                  Context
    );

BOOL WINAPI
FtCompatibilityCheckWarning(
    PCOMPAIBILITYCALLBACK   CompatibilityCallback,
    LPVOID                  Context
    );

//
// Variables
//

extern HINSTANCE g_hinst;
extern TCHAR g_FTCOMP50_ERROR_HTML_FILE[];
extern TCHAR g_FTCOMP50_ERROR_TEXT_FILE[];
extern TCHAR g_FTCOMP40_ERROR_HTML_FILE[];
extern TCHAR g_FTCOMP40_ERROR_TEXT_FILE[];
extern TCHAR g_FTCOMP40_WARNING_HTML_FILE[];
extern TCHAR g_FTCOMP40_WARNING_TEXT_FILE[];

//
//  Helpers
//

BOOL
FtPresent50(
    PBOOL   FtPresent
    );

BOOL
FtPresent40(
    PBOOL   FtPresent
    );

BOOL
FtBootSystemPagefilePresent40(
    PBOOL   FtPresent
    );

NTSTATUS 
OpenDevice(
    PWSTR   DeviceName,
    PHANDLE Handle
    );

BOOL
FtPresentOnDisk40(
    HANDLE          Handle,
    PDISK_REGISTRY  DiskRegistry,
    PBOOL           FtPresent
    );

BOOL
IsFtSet40(
    WCHAR           DriveLetter,
    PDISK_REGISTRY  DiskRegistry
    );

BOOL
GetDeviceDriveLetter(
    PWSTR   DeviceName, 
    PWCHAR  DriveLetter
    );

#endif // _FTCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\ftcomp\ftcomp.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomp.cpp

Abstract:

    This compatibility dll is used by winnt32.exe in order to decide 
    whether the installation process should be aborted because of FT 
    sets present in the system.

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Environment:

    compatibility dll for winnt32.exe

Notes:

Revision History:

--*/

#include <initguid.h>
#include <winnt32.h>
#include <ntddft.h>
#include <ntddft2.h>

#include "ftcomp.h"
#include "ftcomprc.h"


HINSTANCE g_hinst;
WCHAR g_FTCOMP50_ERROR_HTML_FILE[] = L"compdata\\ftcomp1.htm";
WCHAR g_FTCOMP50_ERROR_TEXT_FILE[] = L"compdata\\ftcomp1.txt";
WCHAR g_FTCOMP40_ERROR_HTML_FILE[] = L"compdata\\ftcomp2.htm";
WCHAR g_FTCOMP40_ERROR_TEXT_FILE[] = L"compdata\\ftcomp2.txt";
WCHAR g_FTCOMP40_WARNING_HTML_FILE[] = L"compdata\\ftcomp3.htm";
WCHAR g_FTCOMP40_WARNING_TEXT_FILE[] = L"compdata\\ftcomp3.txt";

extern "C"
BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReasonForCall,
    LPVOID      lpReserved
    )
{
    BOOL    status = TRUE;
    
    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
	    DisableThreadLibraryCalls(hInstance);       
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}

BOOL WINAPI 
FtCompatibilityCheckError(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether 
    the installation process should be aborted because of FT sets present 
    in a Windows 2000 system or later. It also aborts the installation on
    NT 4.0 systems if the boot/system/pagefile volumes are FT sets

Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    FALSE   if the installation can continue
    TRUE    if the installation must be aborted

--*/

{   
    OSVERSIONINFO       osvi;
    BOOL                ftPresent;
    BOOL                result;
    COMPATIBILITY_ENTRY ce;
    WCHAR               description[100];
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        return FALSE;
    }

    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT ||
        osvi.dwMajorVersion < 4) {
        return FALSE;
    }

    if (osvi.dwMajorVersion == 4) {

        //
        // On NT 4.0 look for boot/system/pagefile FT sets
        //

        result = FtBootSystemPagefilePresent40(&ftPresent);

    } else {

        //
        //  On Windows 2000 or later look for any FT sets.
        //

        result = FtPresent50(&ftPresent);
    }
    
    if (result && !ftPresent) {

        // 
        // The setup can continue.
        //
        
        return FALSE;
    }    
    
    //
    // FT sets are present in the system or a fatal error occured. 
    // Queue the incompatibility error
    //
    
    ZeroMemory((PVOID) &ce, sizeof(COMPATIBILITY_ENTRY));
    if (osvi.dwMajorVersion == 4) {
        if (!LoadString(g_hinst, FTCOMP_STR_ERROR40_DESCRIPTION, description, 100)) {
            description[0] = 0;
        }
        ce.HtmlName = g_FTCOMP40_ERROR_HTML_FILE;
        ce.TextName = g_FTCOMP40_ERROR_TEXT_FILE; 
    } else {
        if (!LoadString(g_hinst, FTCOMP_STR_ERROR50_DESCRIPTION, description, 100)) {
            description[0] = 0;
        }
        ce.HtmlName = g_FTCOMP50_ERROR_HTML_FILE;
        ce.TextName = g_FTCOMP50_ERROR_TEXT_FILE; 
    }
    ce.Description = description;
    ce.RegKeyName = NULL;
    ce.RegValName = NULL;
    ce.RegValDataSize = 0;
    ce.RegValData = NULL;
    ce.SaveValue = NULL;
    ce.Flags = 0;
    CompatibilityCallback(&ce, Context);

    return TRUE;
}

BOOL WINAPI 
FtCompatibilityCheckWarning(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether the user
    should be warned about the presence of FT sets in a Windows NT 4.0 system
    
Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    FALSE   if the installation can continue
    TRUE    if the installation must be aborted

--*/

{   
    OSVERSIONINFO       osvi;
    BOOL                ftPresent;
    BOOL                result;
    COMPATIBILITY_ENTRY ce;
    WCHAR               description[100];
    
    //
    //  This function is supposed to work only on Windows NT 4.0
    //
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        return FALSE;
    }

    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT ||
        osvi.dwMajorVersion != 4) {
        return FALSE;
    }
        
    result = FtPresent40(&ftPresent);
    if (result && !ftPresent) {

        // 
        // No FT sets are present in the system. The setup can continue.
        //
        
        return FALSE;
    }

    //
    // FT sets are present in the system or a fatal error occured. 
    // Queue the incompatibility warning
    //
    
    if (!LoadString(g_hinst, FTCOMP_STR_WARNING40_DESCRIPTION, description, 100)) {
        description[0] = 0;
    }

    ZeroMemory((PVOID) &ce, sizeof(COMPATIBILITY_ENTRY));
    ce.Description = description;
    ce.HtmlName = g_FTCOMP40_WARNING_HTML_FILE;
    ce.TextName = g_FTCOMP40_WARNING_TEXT_FILE; 
    ce.RegKeyName = NULL;
    ce.RegValName = NULL;
    ce.RegValDataSize = 0;
    ce.RegValData = NULL;
    ce.SaveValue = NULL;
    ce.Flags = 0;
    CompatibilityCallback(&ce, Context);

    return TRUE;
}

BOOL
FtPresent50(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for FT volumes on a Window 2000 or later
    system.

Arguments:

    FtPresent   - is set to true if FT sets are detected in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HANDLE                              handle;
    FT_ENUMERATE_LOGICAL_DISKS_OUTPUT   output;
    BOOL                                result;
    DWORD                               bytes;
    
    *FtPresent = FALSE;

    handle = CreateFile(L"\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    memset(&output, 0, sizeof(output));
    result = DeviceIoControl(handle, FT_ENUMERATE_LOGICAL_DISKS, NULL, 0, 
                             &output, sizeof(output), &bytes, NULL);
    CloseHandle(handle);

    if (!result && GetLastError() != ERROR_MORE_DATA) {
        return FALSE;
    }
        
    if (output.NumberOfRootLogicalDisks > 0) {
        *FtPresent = TRUE;
    }

    return TRUE;
}

BOOL
FtPresent40(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for NTFT partitions on a Window NT 4.0 system

Arguments:

    FtPresent   - is set to true if FT sets are detected in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HKEY                hkey;
    DWORD               registrySize;
    PDISK_CONFIG_HEADER registry;
    PDISK_REGISTRY      diskRegistry;
    ULONG               i;
    WCHAR               devicePath[50];    
    NTSTATUS            status;
    HANDLE              hdev;    

    *FtPresent = FALSE;

    //
    //  Get the ftdisk database from registry.
    //  Key:    HKLM\System\Disk
    //  Value:  Information
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Disk", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        return TRUE;
    }

    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, NULL, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        return TRUE;
    }
  
    registry = (PDISK_CONFIG_HEADER) LocalAlloc(0, registrySize);
    if (!registry) {
        RegCloseKey(hkey);
        return FALSE;
    }
    
    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, (LPBYTE) registry, &registrySize) != 
        ERROR_SUCCESS) {
        LocalFree(registry);
        RegCloseKey(hkey);
        return TRUE;
    }

    RegCloseKey(hkey);

    //
    //  If no FT volume info is present in the registry database we are done
    //

    if (registry->FtInformationSize == 0) {
        LocalFree(registry);
        return TRUE;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);
  
    
    //
    //  Enumerate all disks present in the system by opening \Device\HarddiskX\Partition0
    //  in sequence starting with disk 0. Stop when getting STATUS_OBJECT_PATH_NOT_FOUND
    //
    //

    for (i = 0;; i++) {
        
        //
        //  Open the device
        //
        
        swprintf(devicePath, L"\\Device\\Harddisk%lu\\Partition0", i);
        status = OpenDevice(devicePath, &hdev);
        
        if (status == STATUS_OBJECT_PATH_NOT_FOUND) {
            break;
        }

        if (!NT_SUCCESS(status) || hdev == NULL ||
            hdev == INVALID_HANDLE_VALUE) {
            // inaccessible device
            continue;
        }

        //
        //  Look for FT partitions on disk
        //
        
        if (!FtPresentOnDisk40(hdev, diskRegistry, FtPresent)) {
            CloseHandle(hdev);
            return FALSE;
        }
                
        CloseHandle(hdev);

        if (*FtPresent) {
            break;
        }
    }

    LocalFree(registry);
    return TRUE;
}

BOOL
FtBootSystemPagefilePresent40(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for FT sets that are boot/system/pagefile volumes
    on a NT 4.0 system

Arguments:

    FtPresent   - is set to true if boot/system/pagefile FT sets are detected 
    in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HKEY                            hkey;
    DWORD                           registrySize;
    PDISK_CONFIG_HEADER             registry;
    PDISK_REGISTRY                  diskRegistry;
    WCHAR                           buffer[MAX_PATH + 1];
    NTSTATUS                        status;
    UCHAR                           genericBuffer[0x10000];
    PSYSTEM_PAGEFILE_INFORMATION    pageFileInfo;
    PWCHAR                          p;
    WCHAR                           bootDL = 0, systemDL = 0;
    WCHAR                           dl;

    *FtPresent = FALSE;

    //
    //  Get the ftdisk database from registry.
    //  Key:    HKLM\System\Disk
    //  Value:  Information
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Disk", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        return TRUE;
    }

    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, NULL, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        return TRUE;
    }
  
    registry = (PDISK_CONFIG_HEADER) LocalAlloc(0, registrySize);
    if (!registry) {
        RegCloseKey(hkey);
        return FALSE;
    }
    
    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, (LPBYTE) registry, &registrySize) != 
        ERROR_SUCCESS) {
        LocalFree(registry);
        RegCloseKey(hkey);
        return TRUE;
    }

    RegCloseKey(hkey);

    //
    //  If no FT volume info is present in the registry database we are done
    //

    if (registry->FtInformationSize == 0) {
        LocalFree(registry);
        return TRUE;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);


    //
    //  Check the boot volume
    //
    
    if (!GetSystemDirectory(buffer, MAX_PATH)) {
        goto system;
    }

    if (buffer[1] != L':') {
        goto system;
    }
    
    bootDL = (WCHAR) tolower(buffer[0]);
    if (IsFtSet40(bootDL, diskRegistry)) {
        *FtPresent = TRUE;
        goto exit;
    }

system:
    
    //
    // Check the system volume
    //
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        goto paging;
    }

    registrySize = MAX_PATH * sizeof(WCHAR);
    if (RegQueryValueEx(hkey, L"SystemPartition", NULL, NULL, (LPBYTE) buffer, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        goto paging;
    }

    RegCloseKey(hkey);
        
    if (!GetDeviceDriveLetter(buffer, &systemDL)) {
        goto paging;
    }

    systemDL = (WCHAR) tolower(systemDL);
    if (systemDL == bootDL) {
        // already checked this drive letter
        goto paging;
    }
    
    if (IsFtSet40(systemDL, diskRegistry)) {
        *FtPresent = TRUE;
        goto exit;
    }    
    
paging:
    
    //
    //  Check the paging volumes
    //

    if (!NT_SUCCESS(NtQuerySystemInformation(
                            SystemPageFileInformation,
                            genericBuffer, sizeof(genericBuffer),
                            NULL))) {
        goto exit;
    }

    pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) genericBuffer;

    while (TRUE) {

        //
        // Since the format of the pagefile name generally
        // looks something like "\DosDevices\x:\pagefile.sys",
        // just use the first character before the column
        // and assume that's the drive letter.
        //
            
        for (p = pageFileInfo->PageFileName.Buffer; 
             p < pageFileInfo->PageFileName.Buffer + pageFileInfo->PageFileName.Length 
             && *p != L':'; p++);
            
        if (p < pageFileInfo->PageFileName.Buffer + pageFileInfo->PageFileName.Length &&
            p > pageFileInfo->PageFileName.Buffer) {

            p--;
            dl = (WCHAR) tolower(*p);
            if (dl >= L'a' && dl <= L'z') {

                //
                //  Found the drive letter of a paging volume
                //

                if (dl != bootDL && dl != systemDL) {
                    if (IsFtSet40(dl, diskRegistry)) {
                        *FtPresent = TRUE;
                        goto exit;
                    }
                }
            }
        }

        if (!pageFileInfo->NextEntryOffset) {
            break;
        }

        pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR) pageFileInfo + 
                                                      pageFileInfo->NextEntryOffset);
    }

exit:
    
    LocalFree(registry);
    return TRUE;
}

NTSTATUS 
OpenDevice(
    PWSTR   DeviceName,
    PHANDLE Handle
    )

/*++

Routine Description:

    This routine opens a device for read

Arguments:

    DeviceName  - supplies the device name

    Handle      - returns a handle to the open device

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    IO_STATUS_BLOCK     statusBlock;
    UNICODE_STRING      unicodeName;
    int                 i;
    
    status = RtlCreateUnicodeString(&unicodeName, DeviceName);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    memset(&statusBlock, 0, sizeof(IO_STATUS_BLOCK));
    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &unicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    //
    // If a sharing violation occurs, retry it for
    // max. 10 seconds
    //

    for (i = 0; i < 5; i++) {
        status = NtOpenFile(Handle, SYNCHRONIZE | GENERIC_READ,
                            &oa, &statusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_ALERT);
        if (status == STATUS_SHARING_VIOLATION) {
            Sleep(2000);
        } else {
            break;
        }
    }

    RtlFreeUnicodeString(&unicodeName);
    return status;
}

PDISK_PARTITION
FindPartitionInRegistry40(
    PDISK_REGISTRY  DiskRegistry,
    ULONG           Signature,
    LONGLONG        Offset
    )

/*++

Routine Description:

    This routine looks for a gicen partition into the NT 4.0 ftdisk registry
    database

Arguments:

    DiskRegistry    - supplies the ftdisk registry database

    Signature       - supplies the signature of the disk where the partition resides

    Offset          - supplies the offset of the partition

Return Value:

    The partition structure in the registry database.
    NULL if the partition is not there.

--*/

{
    PDISK_DESCRIPTION   diskDescription;
    USHORT              i, j;
    PDISK_PARTITION     diskPartition;
    LONGLONG            tmp;

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        if (diskDescription->Signature == Signature) {
            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
                diskPartition = &diskDescription->Partitions[j];
                memcpy(&tmp, &diskPartition->StartingOffset.QuadPart,
                       sizeof(LONGLONG));
                if (tmp == Offset) {
                    return diskPartition;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    return NULL;
}

BOOL
FtPresentOnDisk40(
    HANDLE          Handle,
    PDISK_REGISTRY  DiskRegistry,
    PBOOL           FtPresent
    )

/*++

Routine Description:

    This routine looks for FT partitions on a disk

Arguments:

    Handle          - supplies a handle to the open disk

    DiskRegistry    - supplies the ftdisk registry database

    FtPresent       - is set to true if FT partitions are detected on the disk

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    DWORD                       layoutSize;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             statusBlock;
    ULONG                       i;
    PPARTITION_INFORMATION      partInfo;
    PDISK_PARTITION             diskPartition;
    
    *FtPresent = FALSE;

    //
    // Allocate memory for IOCTL_GET_DRIVE_LAYOUT
    //

    layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry) +
                 32 * sizeof(PARTITION_INFORMATION);
    layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(0, layoutSize);
    if (!layout) {
        return FALSE;
    }
    
    //
    //  Read the drive layout
    //
        
    while (1) {

        status = NtDeviceIoControlFile(Handle, 0, NULL, NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_LAYOUT,
                                       NULL, 0,
                                       layout, layoutSize);
        if (status != STATUS_BUFFER_TOO_SMALL) {
            break;
        }
            
        layoutSize += 32 * sizeof(PARTITION_INFORMATION);
        if (layout) {
            LocalFree(layout);
        }
        layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(0, layoutSize);
        if (!layout) {
            return FALSE;
        }            
    }

    if (!NT_SUCCESS(status)) {            
        // inaccessible device. Act like it has no FT volumes
        LocalFree(layout);
        return TRUE;
    }

    //
    // Look for FT partitions
    //

    for (i = 0; i < layout->PartitionCount; i++) {
        
        //
        //  We're looking after recognized partitions marked
        //  with the 0x80 flag
        //

        partInfo = &(layout->PartitionEntry[i]);
        if (!IsFTPartition(partInfo->PartitionType)) {
            continue;
        }
        
        //
        //  Check whether the partition is marked as a member
        //  of an FT volume in the registry database
        //
        
        diskPartition = FindPartitionInRegistry40(
                            DiskRegistry, layout->Signature,
                            partInfo->StartingOffset.QuadPart);
        if (!diskPartition) {
            continue;
        }
            
        if (diskPartition->FtType != NotAnFtMember) {
            *FtPresent = TRUE;
            break;
        }        
    }

    LocalFree(layout);
    return TRUE;
}

BOOL
IsFtSet40(
    WCHAR           DriveLetter,
    PDISK_REGISTRY  DiskRegistry
    )

/*++

Routine Description:

    This routine cheks whether the given drive letter belongs to
    an FT set

Arguments:

    DriveLetter     - supplies a drive letter

    DiskRegistry    - supplies the ftdisk registry database    

Return Value:

    TRUE    if the function is the drive letter belongs to an FT set    

--*/

{
    HANDLE                  handle;
    NTSTATUS                status;
    WCHAR                   deviceName[20];
    PARTITION_INFORMATION   partInfo;
    BOOL                    b;
    DWORD                   bytes;
    PDISK_DESCRIPTION       diskDescription;
    PDISK_PARTITION         diskPartition;
    USHORT                  i, j;

    //
    //  Open the volume and get its "partition" type
    //  If the NTFT flag is not set the volume is not an FT set
    //
    
    wsprintf(deviceName, L"\\DosDevices\\%c:", DriveLetter);    
    status = OpenDevice(deviceName, &handle);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    b = DeviceIoControl(handle, IOCTL_DISK_GET_PARTITION_INFO,
                        NULL, 0, &partInfo, sizeof(partInfo),
                        &bytes, NULL);
    CloseHandle(handle);

    if (!b) {
        return FALSE;
    }
    
    if (!IsFTPartition(partInfo.PartitionType)) {
        return FALSE;
    }

    //
    //  Look for the drive letter in the FT registry. See if it belongs
    //  to an FT set
    //

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
            diskPartition = &diskDescription->Partitions[j];
            if (diskPartition->AssignDriveLetter &&
                tolower(diskPartition->DriveLetter) == tolower(DriveLetter) &&
                diskPartition->FtType != NotAnFtMember) {
                return TRUE;
            }            
        }
        
        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }
    
    return FALSE;
}

BOOL
GetDeviceDriveLetter(
    PWSTR   DeviceName, 
    PWCHAR  DriveLetter
    )

/*++

Routine Description:

    This routine returns the drive letter (if any) of a device given
    the device name (like \Device\HarddiskVolume1)

Arguments:

    DeviceName      - supplies the device name

    DriveLetter     - returns the drive letter

Return Value:

    TRUE    if the device has a drive letter

--*/

{
    DWORD   cch;
    WCHAR   dosDevices[4096];
    WCHAR   target[4096];
    PWCHAR  dosDevice;

    *DriveLetter = 0;

    if (!QueryDosDevice(NULL, dosDevices, 4096)) {
        return FALSE;
    }
    
    dosDevice = dosDevices;
    while (*dosDevice) {

        if (wcslen(dosDevice) == 2 && dosDevice[1] == L':' &&
            QueryDosDevice(dosDevice, target, 4096)) {

            if (!wcscmp(target, DeviceName)) {
                *DriveLetter = (WCHAR) tolower(dosDevice[0]);
                return TRUE;
            }
        }

        while (*dosDevice++);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\ftcomp\ftcomprc.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomprc.h

Abstract:

    Resource ids definitions for ftcomp.rc

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Notes:

Revision History:

--*/

#define FTCOMP_STR_ERROR50_DESCRIPTION    1000
#define FTCOMP_STR_ERROR40_DESCRIPTION    1001
#define FTCOMP_STR_WARNING40_DESCRIPTION  1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\cfgi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfgi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the Configuration Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _CFGI_H_
#define _CFGI_H_


//
// Client machine handle structure and signature
//

typedef struct PnP_Machine_s {
    PVOID hStringTable;
    PVOID hBindingHandle;
    WORD  wVersion;
    ULONG ulSignature;
    WCHAR szMachineName[MAX_PATH + 3];
} PNP_MACHINE, *PPNP_MACHINE;

#define MACHINE_HANDLE_SIGNATURE 'HMPP'


//
// Client context handle signature
//

#define CLIENT_CONTEXT_SIGNATURE 'HCPP'


//
// Client string table priming string
//

#define PRIMING_STRING           TEXT("PLT")


//
// Client side private utility routines
//

BOOL
INVALID_DEVINST(
    IN  PWSTR       pDeviceID
    );

VOID
CopyFixedUpDeviceId(
    OUT LPWSTR      DestinationString,
    IN  LPCWSTR     SourceString,
    IN  DWORD       SourceStringLen
    );

CONFIGRET
PnPUnicodeToMultiByte(
    IN     PWSTR   UnicodeString,
    IN     ULONG   UnicodeStringLen,
    OUT    PSTR    AnsiString           OPTIONAL,
    IN OUT PULONG  AnsiStringLen
    );

CONFIGRET
PnPMultiByteToUnicode(
    IN     PSTR    AnsiString,
    IN     ULONG   AnsiStringLen,
    OUT    PWSTR   UnicodeString        OPTIONAL,
    IN OUT PULONG  UnicodeStringLen
    );

BOOL
PnPGetGlobalHandles(
    IN  HMACHINE    hMachine,
    PVOID           *phStringTable      OPTIONAL,
    PVOID           *phBindingHandle    OPTIONAL
    );

BOOL
PnPRetrieveMachineName(
    IN  HMACHINE    hMachine,
    OUT LPWSTR      pszMachineName
    );

BOOL
PnPGetVersion(
    IN  HMACHINE    hMachine,
    IN  WORD*       pwVersion
    );

HANDLE
PnPEnablePrivileges(
    IN  PDWORD  Privileges,
    IN  ULONG   PrivilegeCount
    );

VOID
PnPRestorePrivileges(
    IN  HANDLE  hToken
    );

#endif // _CFGI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\cmdat.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cmdat.c

Abstract:

    This module contains global strings.

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop


//
// global strings
//
WCHAR pszRegPathClass[] =              REGSTR_PATH_CLASS_NT;
WCHAR pszRegPathDeviceClass[] =        REGSTR_PATH_DEVICE_CLASSES;
WCHAR pszRegPathIDConfigDB[] =         REGSTR_PATH_IDCONFIGDB;
WCHAR pszRegKeyKnownDockingStates[] =  REGSTR_KEY_KNOWNDOCKINGSTATES;
WCHAR pszRegValueClass[] =             REGSTR_VAL_CLASS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\cmdat.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cmdat.h

Abstract:

    This module contains extern declarations for the global strings
    in cmdat.c

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// global strings
//
extern WCHAR pszRegPathClass[];
extern WCHAR pszRegPathDeviceClass[];
extern WCHAR pszRegPathIDConfigDB[];
extern WCHAR pszRegKeyKnownDockingStates[];
extern WCHAR pszRegValueClass[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\conflist.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    conflist.c

Abstract:

    This module contains the API routines that manage conflict list reporting

               CM_Query_Resource_Conflict_List
               CM_Free_Resource_Conflict_Handle
               CM_Get_Resource_Conflict_Count
               CM_Get_Resource_Conflict_Details

Author:

    Jamie Hunter (jamiehun) 4-14-1998

Environment:

    User mode only.

Revision History:

    April-14-1998     jamiehun

        Addition of NT extended resource-conflict functions

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


typedef struct _CONFLICT_LIST_HEADER {
    HMACHINE Machine;                               // indicates relevent machine
    PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictInfo;   // data obtained via UMPNPMGR
    ULONG    Signature;                             // marks this structure as a handle
} CONFLICT_LIST_HEADER, *PCONFLICT_LIST_HEADER;


//
// Private prototypes
//

BOOL
ValidateConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    );

VOID
FreeConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    );

//
// private prototypes from resdes.c
//

CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    );

BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    );

CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResData64,
    IN  ULONG      ResLen64,
    OUT PVOID    * ResData32,
    OUT ULONG    * ResLen32
    );


//
// private prototypes from logconf.c
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );



//
// API functions
//

CMAPI
CONFIGRET
WINAPI
CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             )
/*++

Routine Description:

    Retrieves conflict list
    returns a handle for list

Arguments:

    pclConflictList - holds returned conflict list handle
    dnDevInst     Device we want to allocate a resource for
    ResourceID    Type of resource, ResType_xxxx
    ResourceData  Resource specific data
    ResourceLen   length of ResourceData

    ulFlags       Width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

    hMachine - optional machine to query

Return Value:

    CM status value

--*/
{

    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConfList1 = NULL;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConfList2 = NULL;
    PCONFLICT_LIST_HEADER pConfListHeader = NULL;
    ULONG       ConfListSize1;
    ULONG       ConfListSize2;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        if (pclConflictList == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ResourceID > ResType_MAX) {     // ClassSpecific not allowed
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on a detect
            goto Clean0;
        }
        //
        // Initialize parameters
        //
        *pclConflictList = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        pConfListHeader = (PCONFLICT_LIST_HEADER)pSetupMalloc(sizeof(CONFLICT_LIST_HEADER));
        if (pConfListHeader == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // estimate size required to hold one conflict
        //
        ConfListSize1 = sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST)+          // header + one entry
                        sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS)+      // strings marker
                        (sizeof(WCHAR)*MAX_DEVICE_ID_LEN);              // enough space for one string

        pConfList1 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupMalloc(ConfListSize1);
        if (pConfList1 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // first try
        //

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryResConfList(
                        hBinding,               // rpc binding handle
                        DeviceID,               // device id string
                        ResourceID,             // resource type
                        (LPBYTE)ResourceData,   // actual res des data
                        ResourceLen,            // size in bytes of ResourceData
                        (LPBYTE)pConfList1,     // buffer
                        ConfListSize1,           // size of buffer
                        ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryResConfList (first pass) caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;       // quit for any error
        }

        if (pConfList1->ConflictsCounted > pConfList1->ConflictsListed) {
            //
            // need more space, multiple conflict
            //
            ConfListSize2 = pConfList1->RequiredBufferSize;
            pConfList2 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupMalloc(ConfListSize2);

            if (pConfList2 != NULL) {
                //
                // Try to use this instead
                //

                //
                // No special privileges are required by the server
                //

                RpcTryExcept {
                    //
                    // call rpc service entry point
                    //
                    Status = PNP_QueryResConfList(
                                  hBinding,               // rpc binding handle
                                  DeviceID,               // device id string
                                  ResourceID,             // resource type
                                  (LPBYTE)ResourceData,   // actual res des data
                                  ResourceLen,            // size in bytes of ResourceData
                                  (LPBYTE)pConfList2,     // buffer
                                  ConfListSize2,           // size of buffer
                                  ulFlags);               // currently zero
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "PNP_QueryResConfList (second pass) caused an exception (%d)\n",
                               RpcExceptionCode()));

                    Status = MapRpcExceptionToCR(RpcExceptionCode());
                }
                RpcEndExcept

                if (Status != CR_SUCCESS) {
                    //
                    // if we got error second time, but first time success
                    // use what we got on first attempt
                    // (I can't see this happening, but Murphey says it can)
                    //
                    pSetupFree(pConfList2);
                    Status = CR_SUCCESS;
                } else {
                    //
                    // use second attempt
                    //
                    pSetupFree(pConfList1);
                    pConfList1 = pConfList2;
                    ConfListSize1 = ConfListSize2;
                }
                //
                // either way, we've deleted a buffer
                //
                pConfList2 = NULL;
            }
        }

        if(ConfListSize1 > pConfList1->RequiredBufferSize) {
            //
            // we can release some of the buffer we requested
            //
            ConfListSize2 = pConfList1->RequiredBufferSize;
            pConfList2 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupRealloc(pConfList1,ConfListSize2);
            if(pConfList2) {
                //
                // success, we managed to save space
                //
                pConfList1 = pConfList2;
                ConfListSize1 = ConfListSize2;
                pConfList2 = NULL;
            }
        }
        //
        // if we get here, we have a successfully valid handle
        //
        pConfListHeader->Signature = CM_PRIVATE_CONFLIST_SIGNATURE;
        pConfListHeader->Machine = hMachine;
        pConfListHeader->ConflictInfo = pConfList1;
        *pclConflictList = (ULONG_PTR)pConfListHeader;
        pConfList1 = NULL;
        pConfListHeader = NULL;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    //
    // cleanup
    //
    if (pConfListHeader != NULL) {
        pSetupFree(pConfListHeader);
    }
    if (pConfList1 != NULL) {
        pSetupFree(pConfList1);
    }
    if (pConfList2 != NULL) {
        pSetupFree(pConfList2);
    }

    if (ResourceData32) {
        pSetupFree(ResourceData32);
    }

    return Status;

} // CM_Query_Resource_Conflict_List



CMAPI
CONFIGRET
WINAPI
CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             )
/*++

Routine Description:

    Free's a conflict-list handle

Arguments:
    clConflictList - handle of conflict list to free

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList = NULL;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        FreeConfListHandle(pConfList);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Resource_Conflict_Handle



CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             )
/*++

Routine Description:

    Retrieves number of conflicts from list

Arguments:
    clConflictList - handle of conflict list
    pulCount - filled with number of conflicts (0 if no conflicts)

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        if (pulCount == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // return count parameter
        // that can be used to iterate conflicts
        //

        *pulCount = pConfList->ConflictInfo->ConflictsListed;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Resource_Conflict_Handle



CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsW(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_W pConflictDetails
             )
/*++

Routine Description:

    Retrieves conflict details for a specific conflict

Arguments:

    clConflictList - handle of conflict list

    ulIndex - index of conflict to query, 0 to count-1
                where count is obtained from CM_Get_Resource_Conflict_Count

    pConflictDetails - structure to be filled with conflict details
            must have CD_ulSize & CD_ulFlags initialized before calling function
            eg: pConflictDetails->CD_ulSize = sizeof(CONFLICT_DETAILS)
                pConflictDetails->CD_ulFlags = CM_CDMASK_ALL

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList;
    PPLUGPLAY_CONTROL_CONFLICT_ENTRY pConfEntry;
    PWCHAR pString;
    ULONG ulFlags;
    PPLUGPLAY_CONTROL_CONFLICT_STRINGS ConfStrings;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    HMACHINE    hMachine = NULL;
    DEVINST dnDevInst;
    ULONG  ulSize;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        if (pConflictDetails == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pConflictDetails->CD_ulSize != sizeof(CONFLICT_DETAILS_W)) {
            //
            // currently only one structure size supported
            //
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        if (INVALID_FLAGS(pConflictDetails->CD_ulMask, CM_CDMASK_VALID)) {
            //
            // CM_CDMASK_VALID describes the bits that are supported
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pConflictDetails->CD_ulMask == 0) {
            //
            // must want something
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if(ulIndex >= pConfList->ConflictInfo->ConflictsListed) {
            //
            // validate index
            //
            Status = CR_INVALID_INDEX;
            goto Clean0;
        }

        hMachine = (HMACHINE)(pConfList->Machine);

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }


        ConfStrings =
            (PPLUGPLAY_CONTROL_CONFLICT_STRINGS)
            &(pConfList->ConflictInfo->ConflictEntry[pConfList->ConflictInfo->ConflictsListed]);

        pConfEntry = pConfList->ConflictInfo->ConflictEntry + ulIndex;

        // the string for this entry
        pString = ConfStrings->DeviceInstanceStrings + pConfEntry->DeviceInstance;

        //
        // init requested parameters
        //
        ulFlags = pConflictDetails->CD_ulMask;
        pConflictDetails->CD_ulMask = 0;
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DEVINST)) {
            pConflictDetails->CD_dnDevInst = 0;
        }
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_RESDES)) {
            pConflictDetails->CD_rdResDes = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_FLAGS)) {
            pConflictDetails->CD_ulFlags = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DESCRIPTION)) {
            pConflictDetails->CD_szDescription[0] = 0;
        }

        //
        // fill in requested parameters
        //
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DEVINST)) {

            if ((pString == NULL) ||
                (pString[0] == L'\0') ||
                (IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER))) {
                //
                // not a valid dev-instance
                //
                dnDevInst = (DEVINST)-1;
            } else {
                //
                // lookup DeviceID
                //
                ASSERT(pString && *pString && IsLegalDeviceId(pString));

                dnDevInst = (DEVINST)pSetupStringTableAddString(hStringTable,
                                                   pString,
                                                   STRTAB_CASE_SENSITIVE);
                if (dnDevInst == (DEVINST)(-1)) {
                    Status = CR_OUT_OF_MEMORY;    // probably out of memory
                    goto Clean0;
                }
            }
            pConflictDetails->CD_dnDevInst = dnDevInst;
            pConflictDetails->CD_ulMask |= CM_CDMASK_DEVINST;
        }
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_RESDES)) {
            //
            // not implemented yet
            //
            pConflictDetails->CD_rdResDes = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_FLAGS)) {
            //
            // convert flags
            //
            pConflictDetails->CD_ulFlags = 0;
            if (IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER)) {
                //
                // description describes a driver, not a device
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_DRIVER;
            }
            if (IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_ROOT_OWNED)) {
                //
                // resource is owned by root device
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_ROOT_OWNED;
            }
            if ((IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_TRANSLATE_FAILED)) ||
                (IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_ROOT_OWNED))) {
                //
                // resource cannot be allocated, but no descriptive text
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_RESERVED;
            }
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DESCRIPTION)) {

            if ((pString == NULL) ||
                (pString[0] == L'\0') ||
                (IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER))) {
                //
                // copy string directly, specifies legacy driver (or nothing for unavailable)
                // we allow truncation while copying, though this shouldn't happen.
                //
                if (FAILED(StringCchCopyEx(
                               pConflictDetails->CD_szDescription,
                               SIZECHARS(pConflictDetails->CD_szDescription),
                               pString,
                               NULL, NULL,
                               STRSAFE_IGNORE_NULLS))) {
                    //
                    // possible error cases are handled by StringCchCopyEx
                    // (i.e. truncation, NULL pString), but we pretend to check
                    // the return here to make PREFAST happy.
                    //
                    NOTHING;
                }

            } else {
                //
                // copy a descriptive name for P&P device
                //
                ASSERT(pString && *pString && IsLegalDeviceId(pString));

                dnDevInst = (DEVINST)pSetupStringTableAddString(hStringTable,
                                                   pString,
                                                   STRTAB_CASE_SENSITIVE);
                if (dnDevInst == (DEVINST)(-1)) {
                    Status = CR_OUT_OF_MEMORY;    // probably out of memory
                    goto Clean0;
                }

                ulSize = sizeof(pConflictDetails->CD_szDescription);
                if (CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                     CM_DRP_FRIENDLYNAME,
                                                     NULL, (LPBYTE)(pConflictDetails->CD_szDescription),
                                                     &ulSize, 0,hMachine) != CR_SUCCESS) {

                    ulSize = sizeof(pConflictDetails->CD_szDescription);
                    if (CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         NULL, (LPBYTE)(pConflictDetails->CD_szDescription),
                                                         &ulSize, 0,hMachine) != CR_SUCCESS) {

                        //
                        // unknown
                        //
                        pConflictDetails->CD_szDescription[0] = 0;
                    }
                }
            }
            pConflictDetails->CD_ulMask |= CM_CDMASK_DESCRIPTION;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Resource_Conflict_DetailsW



BOOL
ValidateConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    )
/*++

Routine Description:

    Validates a conflict-list handle
    pConfList must not be null, and must
    contain a valid signature

Arguments:

    pConfList - handle to conflict list

Return Value:

    TRUE if valid, FALSE if not valid

--*/
{
    //
    // validate parameters
    //
    if (pConfList == NULL) {
        return FALSE;
    }

    //
    // check for the private conflict list signature
    //
    if (pConfList->Signature != CM_PRIVATE_CONFLIST_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateConfListHandle



VOID
FreeConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    )
/*++

Routine Description:

    Releases memory allocated for Conflict List
    Makes sure Signature is invalid

Arguments:

    pConfList  - valid handle to conflict list

Return Value:

    none

--*/
{
    if(pConfList != NULL) {
        pConfList->Signature = 0;
        if(pConfList->ConflictInfo) {
            pSetupFree(pConfList->ConflictInfo);
        }
        pSetupFree(pConfList);
    }

    return;

} // FreeConfListHandle




//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             )
/*++

Routine Description:

    Ansi version of CM_Get_Resource_Conflict_DetailsW

--*/
{
    CONFLICT_DETAILS_W detailsW;
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulAnsiLength;

    try {
        //
        // Validate parameters we need for Ansi part
        // further validation occurs in Wide-char part
        //
        if (pConflictDetails == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pConflictDetails->CD_ulSize != sizeof(CONFLICT_DETAILS_A)) {
            //
            // currently only one structure size supported
            //
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        if (INVALID_FLAGS(pConflictDetails->CD_ulMask, CM_CDMASK_VALID)) {
            //
            // CM_CDMASK_VALID describes the bits that are supported
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pConflictDetails->CD_ulMask == 0) {
            //
            // must want something
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        ZeroMemory(&detailsW,sizeof(detailsW));
        detailsW.CD_ulSize = sizeof(detailsW);
        detailsW.CD_ulMask = pConflictDetails->CD_ulMask;

        Status = CM_Get_Resource_Conflict_DetailsW(clConflictList,ulIndex,&detailsW);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // copy details
        //
        pConflictDetails->CD_ulMask = detailsW.CD_ulMask;

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_DEVINST)) {
            pConflictDetails->CD_dnDevInst = detailsW.CD_dnDevInst;
        }
        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_RESDES)) {
            pConflictDetails->CD_rdResDes = detailsW.CD_rdResDes;
        }

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_FLAGS)) {
            pConflictDetails->CD_ulFlags = detailsW.CD_ulFlags;
        }

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_DESCRIPTION)) {
            pConflictDetails->CD_szDescription[0] = 0;
            //
            // need to convery from UNICODE to ANSI
            //
            ulAnsiLength = MAX_PATH;
            Status = PnPUnicodeToMultiByte(detailsW.CD_szDescription,
                                           MAX_PATH*sizeof(WCHAR),
                                           pConflictDetails->CD_szDescription,
                                           &ulAnsiLength);
            if (Status != CR_SUCCESS) {
                //
                // error occurred
                //
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Resource_Conflict_DetailsA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\event.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    event.c

Abstract:

    This module contains miscellaneous Configuration Manager API routines.

               CMP_RegisterNotification
               CMP_UnregisterNotification

Author:

    Jim Cavalaris (jamesca) 05-05-2001

Environment:

    User mode only.

Revision History:

    05-May-2001     jamesca

        Creation and initial implementation (moved from cfgmgr32\misc.c).

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"

#include <dbt.h>
#include <winsvcp.h>


//
// global data
//
#ifndef _WIN64
extern BOOL     IsWow64;  // set if we're running under WOW64, externed from setupapi\dll.c
#endif // _WIN64


//
// Client-side structure used to store context handles.
//

typedef struct _PNP_CLIENT_CONTEXT {
        ULONG     PNP_CC_Signature;
        ULONG_PTR PNP_CC_ContextHandle;
} PNP_CLIENT_CONTEXT, *PPNP_CLIENT_CONTEXT;


//
// GetModuleFileNameExW, dynamically loaded by CMP_RegisterNotification
//
typedef DWORD (WINAPI *PFN_GETMODULEFILENAMEEXW)(
    IN  HANDLE  hProcess,
    IN  HMODULE hModule,
    OUT LPWSTR  lpFilename,
    IN  DWORD   nSize
    );



CONFIGRET
CMP_RegisterNotification(
    IN  HANDLE   hRecipient,
    IN  LPBYTE   NotificationFilter,
    IN  DWORD    Flags,
    OUT PNP_NOTIFICATION_CONTEXT *Context
    )

/*++

Routine Description:

    This routine registers the specified handle for the type of Plug and Play
    device event notification specified by the NotificationFilter.

Parameters:

    hRecipient - Handle to register as the notification recipient.  May be a
                 window handle or service status handle, and must be specified
                 with the appropriate flags.

    NotificationFilter - Specifies a notification filter that specifies the type
                 of events to register for.  The Notification filter specifies a
                 pointer to a DEV_BROADCAST_HEADER structure, whose
                 dbch_devicetype member indicates the actual type of the
                 NotificationFilter.

                 Currently, may be one of the following:

                 DEV_BROADCAST_HANDLE  (DBT_DEVTYP_HANDLE type)

                 DEV_BROADCAST_DEVICEINTERFACE (DBT_DEVTYP_DEVICEINTERFACE type)

    Flags      - Specifies additional flags for the operation.  The following flags
                 are currently defined:

                 DEVICE_NOTIFY_WINDOW_HANDLE  -
                     hRecipient specifies a window handle.

                 DEVICE_NOTIFY_SERVICE_HANDLE -
                     hRecipient specifies a service status handle.

                 DEVICE_NOTIFY_COMPLETION_HANDLE -
                     Not currently implemented.

                 DEVICE_NOTIFY_ALL_INTERFACE_CLASSES - Specifies that the
                     notification request is for all device interface change
                     events.  Only valid with a DEV_BROADCAST_DEVICEINTERFACE
                     NotificationFilter.  If this flag is specified the
                     dbcc_classguid field is ignored.

    Context    - Receives a notification context.  This context is supplied to the
                 server via PNP_UnregisterNotification to unregister the
                 corresponding notification handle.

Return Value:

    Returns CR_SUCCESS if the component was successfully registered for
    notification. Returns CR_FAILURE otherwise.

Notes:

    This CM API does not allow the client to specify a server name because the
    RPC call is always made to the local server.  This routine will never call
    the corresponding RPC server interface (PNP_RegisterNotification)
    remotely.  Additionally, this routine is private, and should only be called
    via user32!RegisterDeviceNotification.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    ULONG       ulSize;
    PPNP_CLIENT_CONTEXT ClientContext;
    ULONG64     ClientContext64;
    WCHAR       ClientName[MAX_SERVICE_NAME_LEN];


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(Context)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *Context = NULL;

        if ((!ARGUMENT_PRESENT(NotificationFilter)) ||
            (hRecipient == NULL)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // DEVICE_NOTIFY_BITS is a private mask, defined specifically for
        // validation by the client and server.  It contains the bitmask for all
        // handle types (DEVICE_NOTIFY_COMPLETION_HANDLE specifically excluded
        // by the server), and all other flags that are currently defined - both
        // public and reserved.
        //
        if (INVALID_FLAGS(Flags, DEVICE_NOTIFY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure the caller didn't specify any private flags.  Flags in this
        // range are currently reserved for use by CFGMGR32 and UMPNPMGR only!!
        //
        if ((Flags & DEVICE_NOTIFY_RESERVED_MASK) != 0) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate the notification filter.  UlSize is used as an explicit
        // parameter to let RPC know how much data to marshall, though the
        // server validates the size in the structure against it as well.
        //
        ulSize = ((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size;

        if (ulSize < sizeof(DEV_BROADCAST_HDR)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

#ifndef _WIN64
        //
        // Determine if the 32 bit client is running on WOW64, and set the
        // reserved flags appropriately.
        //
        if (IsWow64) {
            Flags |= DEVICE_NOTIFY_WOW64_CLIENT;
        }
#endif // _WIN64

        //
        // setup rpc binding handle (don't need string table handle)
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Allocate client context handle structure from the local process heap
        // rather than setupapi's own heap so that the returned pointer can
        // transcend the dynamic loading and unloading of SETUPAPI.DLL between
        // calls to CMP_RegisterNotification and CMP_UnregisterNotification.
        // (this is done by USER32.DLL for RegisterDeviceNotification and
        // UnregisterDeviceNotification).
        //
        ClientContext = LocalAlloc(0, sizeof(PNP_CLIENT_CONTEXT));

        if (ClientContext == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Put a signature on the client context, to be checked (and
        // invalidated) at unregistration time.
        //
        ClientContext->PNP_CC_Signature = CLIENT_CONTEXT_SIGNATURE;
        ClientContext->PNP_CC_ContextHandle = 0;

        ZeroMemory(ClientName, sizeof(ClientName));

        if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_WINDOW_HANDLE) {

            DWORD  dwLength = 0;

            //
            // first, try to retrieve the window text of the window being
            // registered for device event notification.  we'll pass this into
            // UMPNPMGR for use as an identifier when the window vetoes device
            // event notifications.
            //
            dwLength = GetWindowText(hRecipient,
                                     ClientName,
                                     MAX_SERVICE_NAME_LEN);
            if (dwLength == 0) {
                //
                // GetWindowText did not return any text.  Attempt to retrieve
                // the process module name instead.
                //
                DWORD                    dwProcessId;
                HANDLE                   hProcess;
                HMODULE                  hPsApiDll;
                PFN_GETMODULEFILENAMEEXW pfnGetModuleFileNameExW;

                //
                // get the id of the process that this window handle is
                // associated with.
                //

                if (GetWindowThreadProcessId(hRecipient, &dwProcessId)) {

                    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                           FALSE,
                                           dwProcessId);

                    if (hProcess) {

                        //
                        // load the psapi.dll library and find the the
                        // GetModuleFileNameExW entry point.
                        //

                        hPsApiDll = LoadLibrary(L"psapi.dll");

                        if (hPsApiDll) {

                            pfnGetModuleFileNameExW =
                                (PFN_GETMODULEFILENAMEEXW)GetProcAddress(hPsApiDll,
                                                                         "GetModuleFileNameExW");

                            if (pfnGetModuleFileNameExW) {
                                //
                                // retrieve the module file name for the process
                                // this window handle is associated with.
                                //
                                dwLength = pfnGetModuleFileNameExW(hProcess,
                                                                   NULL,
                                                                   ClientName,
                                                                   MAX_SERVICE_NAME_LEN);
                            } else {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS | DBGF_EVENT,
                                           "CFGMGR32: CMP_RegisterNotification: GetProcAddress returned error = %d\n",
                                           GetLastError()));
                            }

                            FreeLibrary(hPsApiDll);
                        }
                        CloseHandle(hProcess);
                    } else {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_EVENT,
                                   "CFGMGR32: CMP_RegisterNotification: OpenProcess returned error = %d\n",
                                   GetLastError()));
                    }

                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_EVENT,
                               "CFGMGR32: CMP_RegisterNotification: GetWindowThreadProcessId returned error = %d\n",
                               GetLastError()));
                }
            }

            if (dwLength == 0) {
                //
                // could not retrieve any identifier for this window.
                //
                ClientName[0] = UNICODE_NULL;

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_EVENT,
                           "CFGMGR32: CMP_RegisterNotification: Could not retieve any name for window %d!!\n",
                           hRecipient));
            }

        } else if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

            //
            // Get the name of the service corresponding to the service status
            // handle supplied.
            //
            if (NO_ERROR != I_ScPnPGetServiceName(hRecipient, ClientName, MAX_SERVICE_NAME_LEN)) {
                Status = CR_INVALID_DATA;
                LocalFree(ClientContext);
                goto Clean0;
            }

            //
            // Just set this to point to the buffer we use. PNP_RegisterNotification will unpack it.
            //
            hRecipient = ClientName;
        }

        //
        // The client context pointer is now always transmitted to the server as
        // a 64-bit value - which is large enough to hold the pointer in both
        // the 32-bit and 64-bit cases.  This standardizes the RPC interface for
        // all clients, since RPC will always marshall a 64-bit value.  The
        // server will also store the value internally as a 64-bit value, but
        // cast it to an HDEVNOTIFY of appropriate size for the client.
        //
        // Note that we have RPC transmit this parameter simply as a pointer to
        // a ULONG64 (which is actually a pointer itself).  We don't transmit it
        // as a pointer to a PPNP_CLIENT_CONTEXT (which is also a pointer)
        // because RPC would instead allocate the memory to marshall the
        // contents of the structure to the server.  The server would get a
        // pointer to RPC allocated memory, not the actual value of the client
        // pointer - which is all we really want to send in the first place.
        // The server does not actually use this value as a pointer to anything.
        //
        ClientContext64 = (ULONG64)ClientContext;

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterNotification(
                hBinding,
                (ULONG_PTR)hRecipient,
                ClientName,
                NotificationFilter,
                ulSize,
                Flags,
                &((PNP_NOTIFICATION_CONTEXT)(ClientContext->PNP_CC_ContextHandle)),
                GetCurrentProcessId(),
                &((ULONG64)ClientContext64));

        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS | DBGF_EVENT,
                       "PNP_RegisterNotification caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            //
            // Something went wrong. If we built a context handle
            // let it dangle; we can't tell RPC it's gone. (will get rundown)
            // If it's NULL, free the memory.
            // Don't tell the client we succeeded
            //
            if (ClientContext->PNP_CC_ContextHandle == 0) {
                LocalFree (ClientContext);
            }
            *Context = NULL;
        } else {
            *Context = (PNP_NOTIFICATION_CONTEXT)ClientContext;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_RegisterNotification



CONFIGRET
CMP_UnregisterNotification(
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    This routine unregisters the Plug and Play device event notification entry
    represented by the specified notification context.

Parameters:

    Context - Supplies a client notification context.

Return Value:

    Returns CR_SUCCESS if the component was successfully unregistered for
    notification. If the function fails, the return value is one of the
    following:

        CR_FAILURE,
        CR_INVALID_POINTER

Notes:

    This CM API does not allow the client to specify a server name because the
    RPC call is always made to the local server.  This routine will never call
    the corresponding RPC server interface (PNP_UnregisterNotification)
    remotely.  Additionally, this routine is private, and should only be called
    via user32!UnregisterDeviceNotification.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    PPNP_CLIENT_CONTEXT ClientContext = (PPNP_CLIENT_CONTEXT)Context;

    try {
        //
        // validate parameters
        //
        if (Context == 0 || Context == (ULONG_PTR)(-1)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // make sure the client context signature is valid
        //
        if (ClientContext->PNP_CC_Signature != CLIENT_CONTEXT_SIGNATURE) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "CMP_UnregisterNotification: bad signature on client handle\n"));
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UnregisterNotification(
                hBinding,
                (PPNP_NOTIFICATION_CONTEXT)&(ClientContext->PNP_CC_ContextHandle));

        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS | DBGF_EVENT,
                       "PNP_UnregisterNotification caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // invalidate the client context signature and free the client
            // context structure.
            //
            ClientContext->PNP_CC_Signature = 0;
            LocalFree((PVOID)Context);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_UnregisterNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\hwprof.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    hwprof.c

Abstract:

    This module contains the API routines that operate directly on hardware
    profile configurations.

               CM_Is_Dock_Station_Present
               CM_Request_Eject_PC
               CM_Get_HW_Prof_Flags
               CM_Set_HW_Prof_Flags
               CM_Get_Hardware_Profile_Info
               CM_Set_HW_Prof

Author:

    Paula Tomlinson (paulat) 7-18-1995

Environment:

    User mode only.

Revision History:

    18-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"



CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present_Ex(
    OUT PBOOL pbPresent,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine determines whether a docking station is currently present.

Parameters:

   pbPresent         Supplies the address of a boolean variable that is set
                     upon successful return to indicate whether or not a
                     docking station is currently present.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pbPresent)) {
            status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Initialize output parameter
        //
        *pbPresent = FALSE;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            status = PNP_IsDockStationPresent(
                hBinding,
                pbPresent);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_IsDockStationPresent caused an exception (%d)\n",
                       RpcExceptionCode()));

            status = MapRpcExceptionToCR(RpcExceptionCode());
            goto Clean0;
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = CR_FAILURE;
    }

    return status;

} // CM_Is_Dock_Station_Present_Ex



CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC_Ex(
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine requests that the PC be ejected (i.e., undocked).

Parameters:

    none.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // No input Parameters to validate.
        //

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_UNDOCK_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            status = PNP_RequestEjectPC(
                hBinding);  // rpc binding handle
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RequestEjectPC caused an exception (%d)\n",
                       RpcExceptionCode()));

            status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = CR_FAILURE;
    }

    return status;

} // CM_Request_Eject_PC_Ex



CONFIGRET
CM_Get_HW_Prof_Flags_ExW(
    IN  DEVINSTID_W pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the configuration-specific configuration flags
   for a device instance and hardware profile combination.

Parameters:

   pDeviceID         Supplies the address of a NULL-terminated string
                     specifying the name of the device instance to query.

   ulHardwareProfile Supplies the handle of the hardware profile to query.
                     If 0, the API queries the current hardware profile.

   pulValue          Supplies the address of the variable that receives the
                     configuration-specific configuration (CSCONFIGFLAG_)
                     flags.

   ulFlags           Must be zero.

   hMachine          Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    handle_t    hBinding = NULL;
    size_t      DeviceIDLen = 0;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pDeviceID)) ||
            (!ARGUMENT_PRESENT(pulValue))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure the device instance path isn't too long
        //
        if (FAILED(StringCchLength(pDeviceID,
                                   MAX_DEVICE_ID_LEN,
                                   &DeviceIDLen))) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

        //
        // device instance path is not optional
        //
        if (DeviceIDLen == 0) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // check the format of the device id string
        //
        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // fix up the device ID string for consistency (uppercase, etc)
        //
        CopyFixedUpDeviceId(szFixedUpDeviceID,
                            pDeviceID,
                            (DWORD)DeviceIDLen);

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
             Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_HwProfFlags(
                hBinding,               // rpc binding handle
                PNP_GET_HWPROFFLAGS,    // HW Prof Action flag
                szFixedUpDeviceID,      // device id string
                ulHardwareProfile,      // hw config id
                pulValue,               // config flags returned here
                NULL,                   // Buffer that receives VetoType
                NULL,                   // Buffer that receives VetoName
                0,                      // Size of VetoName buffer
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_HwProfFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_HW_Prof_Flags_ExW




CONFIGRET
CM_Set_HW_Prof_Flags_ExW(
    IN DEVINSTID_W pDeviceID,
    IN ULONG     ulConfig,
    IN ULONG     ulValue,
    IN ULONG     ulFlags,
    IN HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine sets the configuration-specific configuration flags for a
   device instance and hardware profile combination.  If the
   CSCONFIGFLAG_DO_NOT_CREATE bit is set for an existing device instance
   in the current hardware profile, it will be removed.  If the
   CSCONFIGFLAG_DO_NOT_CREATE bit is cleared in the current hardware profile,
   the entire hardware tree will be reenumerated, so that the parent of the
   device instance has the chance to create the device instance if necessary.

Parameters:

   pDeviceID      Supplies the address of a null-terminated string that
                  specifies the name of a device instance to modify.

   ulConfig       Supplies the number of the hardware profile to modify.
                  If 0, the API modifies the current hardware profile.

   ulValue        Supplies the configuration flags value.  Can be a
                  combination of these values:

                  CSCONFIGFLAG_DISABLE    Disable the device instance in this
                                          hardware profile.

                  CSCONFIGFLAG_DO_NOT_CREATE    Do not allow this device
                        instance to be created in this hardware profile.

   ulFlags        CM_SET_HW_PROF_FLAGS_UI_NOT_OK
                    If this flag is specified then the OS will not display the
                    reason that the device failed to be disabled or removed.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulTempValue = 0;
    handle_t    hBinding = NULL;
    PNP_VETO_TYPE vetoType, *pVetoType;
    WCHAR       vetoName[MAX_DEVICE_ID_LEN], *pszVetoName;
    ULONG       ulNameLength;
    size_t      DeviceIDLen = 0;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pDeviceID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_SET_HW_PROF_FLAGS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulValue, CSCONFIGFLAG_BITS)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // make sure the device instance path isn't too long
        //
        if (FAILED(StringCchLength(pDeviceID,
                                   MAX_DEVICE_ID_LEN,
                                   &DeviceIDLen))) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

        //
        // device instance path is not optional
        //
        if (DeviceIDLen == 0) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // check the format of the device id string
        //
        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // fix up the device ID string for consistency (uppercase, etc)
        //
        CopyFixedUpDeviceId(szFixedUpDeviceID,
                            pDeviceID,
                            (DWORD)DeviceIDLen);

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (ulFlags & CM_SET_HW_PROF_FLAGS_UI_NOT_OK) {
            vetoType = PNP_VetoTypeUnknown;
            pVetoType = &vetoType;
            vetoName[0] = L'\0';
            pszVetoName = &vetoName[0];
            ulNameLength = MAX_DEVICE_ID_LEN;
        } else {
            pVetoType = NULL;
            pszVetoName = NULL;
            ulNameLength = 0;
        }

        ulTempValue = ulValue;

        //
        // Enable privileges required by the server
        //
        // Note that setting hardware profile flags may require
        // SE_LOAD_DRIVER_PRIVILEGE when the change affects the current state of
        // a device in the current hardware profile.  Otherwise, only the access
        // to change persistent state is required.
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_HwProfFlags(
                hBinding,               // rpc machine name
                PNP_SET_HWPROFFLAGS,    // HW Prof Action flag
                szFixedUpDeviceID,      // device id string
                ulConfig,               // hw config id
                &ulTempValue,           // specifies config flags
                pVetoType,              // Buffer that receives the VetoType
                pszVetoName,            // Buffer that receives the VetoName
                ulNameLength,           // size of the pszVetoName buffer
                ulFlags);               // specifies hwprof set flags
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_HwProfFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_HW_Prof_Flags_ExW



CONFIGRET
CM_Get_Hardware_Profile_Info_ExW(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_W pHWProfileInfo,
    IN  ULONG            ulFlags,
    IN  HMACHINE         hMachine
    )

/*++

Routine Description:

   This routine returns information about a hardware profile.

Parameters:

   ulIndex        Supplies the index of the hardware profile to retrieve
                  information for.  Specifying 0xFFFFFFFF references the
                  currently active hardware profile.

   pHWProfileInfo Supplies the address of a HWPROFILEINFO structure that
                  will receive information about the specified hardware
                  profile.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_DATA,
         CR_NO_SUCH_VALUE,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize = sizeof(HWPROFILEINFO);
    handle_t    hBinding = NULL;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pHWProfileInfo)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetHwProfInfo(
                hBinding,               // rpc machine name
                ulIndex,                // hw profile index
                pHWProfileInfo,         // returns profile info
                ulSize,                 // sizeof of profile info struct
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetHwProfInfo caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Hardware_Profile_Info_ExW



CONFIGRET
CM_Set_HW_Prof_Ex(
    IN ULONG    ulHardwareProfile,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

   Routine Description:

      This routine sets the current hardware profile. This API updates the
      HKEY_CURRENT_CONFIG predefined key in the registry, broadcasts a
      DBT_CONFIGCHANGED message, and reenumerates the root device instance.
      It should only be called by the Configuration Manager and the control
      panel.

   Parameters:

      ulHardwareProfile Supplies the current hardware profile handle.

      ulFlags           Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
        CR_INVALID_FLAG or
        CR_REGISTRY_ERROR.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetHwProf(
                hBinding,               // rpc machine name
                ulHardwareProfile,      // hw config id
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetHwProf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_HW_Prof_Ex



//-------------------------------------------------------------------
// ANSI Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Get_HW_Prof_Flags_ExA(
    IN  DEVINSTID_A szDevInstName,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniDeviceID = NULL;

    //
    // convert devinst string to UNICODE and pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(szDevInstName, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Get_HW_Prof_Flags_ExW(pUniDeviceID,
                                          ulHardwareProfile,
                                          pulValue,
                                          ulFlags,
                                          hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Get_HW_Prof_Flags_ExA



CONFIGRET
CM_Set_HW_Prof_Flags_ExA(
    IN DEVINSTID_A szDevInstName,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniDeviceID = NULL;

    //
    // convert devinst string to UNICODE and pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(szDevInstName, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Set_HW_Prof_Flags_ExW(pUniDeviceID,
                                          ulConfig,
                                          ulValue,
                                          ulFlags,
                                          hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Set_HW_Prof_Flags_ExA



CONFIGRET
CM_Get_Hardware_Profile_Info_ExA(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_A pHWProfileInfo,
    IN  ULONG            ulFlags,
    IN  HMACHINE         hMachine
    )
{
    CONFIGRET           Status = CR_SUCCESS;
    HWPROFILEINFO_W     UniHwProfInfo;
    ULONG               ulLength;
    size_t              FriendlyNameLen = 0;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pHWProfileInfo)) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode struct as a parameter
    //
    Status = CM_Get_Hardware_Profile_Info_ExW(ulIndex,
                                              &UniHwProfInfo,
                                              ulFlags,
                                              hMachine);

    //
    // a HWPROFILEINFO_W structure should always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    //
    // copy the info from the unicode structure to the ansi structure passed in
    // by the caller (converting the embedded strings to ansi in the process)
    //
    if (Status == CR_SUCCESS) {

        pHWProfileInfo->HWPI_ulHWProfile = UniHwProfInfo.HWPI_ulHWProfile;
        pHWProfileInfo->HWPI_dwFlags     = UniHwProfInfo.HWPI_dwFlags;

        //
        // convert the hardware profile friendly name string to ANSI.
        //
        if (FAILED(StringCchLength(
                       (PWSTR)UniHwProfInfo.HWPI_szFriendlyName,
                       MAX_PROFILE_LEN,
                       &FriendlyNameLen))) {
            return CR_FAILURE;
        }

        ulLength = MAX_PROFILE_LEN;
        Status =
            PnPUnicodeToMultiByte(
                (PWSTR)UniHwProfInfo.HWPI_szFriendlyName,
                (ULONG)((FriendlyNameLen+1)*sizeof(WCHAR)),
                pHWProfileInfo->HWPI_szFriendlyName,
                &ulLength);

        //
        // the ANSI representation of a hardware profile friendly name string
        // should not be longer than MAX_PROFILE_LEN bytes, because that's the
        // max size of the buffer in the structure.
        //
        ASSERT(Status != CR_BUFFER_SMALL);
    }

    return Status;

} // CM_Get_Hardware_Profile_Info_ExA




//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC (
    VOID
    )
{
    return CM_Request_Eject_PC_Ex (NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present (
    OUT PBOOL pbPresent
    )
{
    return CM_Is_Dock_Station_Present_Ex (pbPresent, NULL);
}


CONFIGRET
CM_Get_HW_Prof_FlagsW(
    IN  DEVINSTID_W pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_HW_Prof_Flags_ExW(pDeviceID, ulHardwareProfile,
                                    pulValue, ulFlags, NULL);
}


CONFIGRET
CM_Get_HW_Prof_FlagsA(
    IN  DEVINSTID_A pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_HW_Prof_Flags_ExA(pDeviceID, ulHardwareProfile,
                                    pulValue, ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof_FlagsW(
    IN DEVINSTID_W pDeviceID,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags
    )
{
    return CM_Set_HW_Prof_Flags_ExW(pDeviceID, ulConfig, ulValue,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof_FlagsA(
    IN DEVINSTID_A pDeviceID,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags
    )
{
    return CM_Set_HW_Prof_Flags_ExA(pDeviceID, ulConfig, ulValue,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Get_Hardware_Profile_InfoW(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_W pHWProfileInfo,
    IN  ULONG            ulFlags
    )
{
    return CM_Get_Hardware_Profile_Info_ExW(ulIndex, pHWProfileInfo,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Get_Hardware_Profile_InfoA(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_A pHWProfileInfo,
    IN  ULONG            ulFlags
    )
{
    return CM_Get_Hardware_Profile_Info_ExA(ulIndex, pHWProfileInfo,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof(
    IN ULONG ulHardwareProfile,
    IN ULONG ulFlags
    )
{
    return CM_Set_HW_Prof_Ex(ulHardwareProfile, ulFlags, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\devnode.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devnode.c

Abstract:

    This module contains the API routines that operate directly on device
    instances (or DevNodes, in Win95 terminology).

               CM_Create_DevNode
               CM_Setup_DevNode
               CM_Disable_DevNode
               CM_Enable_DevNode
               CM_Get_DevNode_Status
               CM_Set_DevNode_Problem
               CM_Reenumerate_DevNode
               CM_Query_And_Remove_SubTree
               CM_Uninstall_DevNode
               CM_Request_Device_Eject
               CM_Add_ID
               CM_Register_Device_Driver

    This module also contains the following API routines which are
    not implemented.

               CM_Move_DevNode
               CM_Query_Remove_Subtree
               CM_Remove_SubTree

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"

#include <pnpmgr.h>



CONFIGRET
CM_Create_DevNode_ExW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine creates a new device instance in the hardware tree.

Parameters:

   pdnDevNode  Supplies the address of the variable that receives a handle
               to the new device instance.

   pDeviceID   Supplies a pointer to a NULL-terminated string specifying
               the device instance ID for this new device instance.  This
               is the registry path (relative to the Enum branch) where
               this device instance will be located (e.g., Root\*PNP0500\0000).
               In Windows NT, this parameter is not optional.

   dnParent    Supplies the handle of the device instance that is the parent
               of the device instance being created.

   ulFlags     Supplies flags specifying options for the creation of the
               device instance.  May be one of the following values:

               CM_CREATE_DEVNODE_NORMAL
                     Create the device instance now, and perform installation
                     for it at a later time.
               CM_CREATE_DEVNODE_NO_WAIT_INSTALL
                     Create the device instance, and perform installation for
                     it immediately.
               CM_CREATE_DEVNODE_PHANTOM
                     Create a phantom device instance (i.e., a handle to a
                     device instance that is not alive as far as the ConfigMgr
                     APIs are concerned).  This may be used for CM APIs that
                     require a devnode handle, but for which no real devnode
                     currently exists (e.g., registry property APIs).  This
                     flag may not be specified with CR_CREATE_DEVNODE_NORMAL
                     or CR_CREATE_DEVNODE_NO_WAIT_INSTALL.  A phantom devnode
                     created in this manner is not accessible to other callers
                     (i.e., CM_Locate_DevNode won't find it).  However, callers
                     attempting to create a devnode with the same name as this
                     phantom devnode will not be able to do so (they will get
                     CR_ALREADY_SUCH_DEVNODE).
               CM_CREATE_DEVNODE_GENERATE_ID
                     Create a Root-enumerated devnode using a unique device
                     instance ID generated from the supplied device ID in
                     pDeviceID.  If this flag is set, then pDeviceID is assumed
                     to contain simply a device ID (i.e., no enumerator key
                     prefix, and no device instance suffix).  A unique 4-digit,
                     base-10 identifier string will be created under
                     Enum\Root\<pDeviceID>, and the devnode will be created
                     based on that device instance ID.  For instance, to add a
                     new legacy COM port devnode, this API would be called with
                     a pDeviceID of *PNP0500.  Assuming there was already one
                     COM port instance in the registry (instance 0000), the new
                     device instance ID would be: Root\*PNP0500\0001
                     The caller may find out what device instance name was
                     generated by calling CM_Get_Device_ID with the devnode
                     returned from this API.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_ALREADY_SUCH_DEVNODE,
       CR_INVALID_DEVICE_ID,
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_INVALID_POINTER,
       CR_OUT_OF_MEMORY,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       ParentID[MAX_DEVICE_ID_LEN];
    WCHAR       szNewDeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen=MAX_DEVICE_ID_LEN;
    BOOL        Success;
    size_t      DeviceIDLen;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (dnParent == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pDeviceID)) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // the length of the supplied device id string must be shorter than
        // MAX_DEVICE_ID_LEN chars so that there is also room for the NULL term
        // char in a buffer of this size.  (many of the CM_ APIs make different
        // assumptions about the consideration of the NULL term char in
        // MAX_DEVICE_ID_LEN; account for the NULL term char to be safe)
        //
        if (FAILED(StringCchLength(pDeviceID,
                                   MAX_DEVICE_ID_LEN,
                                   &DeviceIDLen))) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

        if (DeviceIDLen == 0) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_CREATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Windows NT 5.0 does not support CM_CREATE_DEVNODE_NO_WAIT_INSTALL
        //
        if (ulFlags & CM_CREATE_DEVNODE_NO_WAIT_INSTALL) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Initialize the caller's devnode.  This will have the side effect of
        // generating an exception before we actually do anything if the caller
        // supplied a bogus address.
        //
        *pdnDevInst = 0;

        //
        // retreive device instance string that corresponds to dnParent
        // (note that this is not optional, even a first level device instance
        // has a parent (the root device instance)
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnParent,ParentID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(ParentID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // make sure the new device instance is properly formatted
        //
        CopyFixedUpDeviceId(szNewDeviceID,
                            pDeviceID,
                            (DWORD)DeviceIDLen);

        //
        // If not requesting instance generation, then it must be a
        // valid device instance path.
        //
        if (!(ulFlags & CM_CREATE_DEVINST_GENERATE_ID)) {
            if ((!*szNewDeviceID) ||
                (!IsLegalDeviceId(szNewDeviceID))) {
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_CreateDevInst(
                hBinding,               // rpc binding handle
                szNewDeviceID,          // device instance to create
                ParentID,               // parent device instance
                MAX_DEVICE_ID_LEN,      // max length of szNewDeviceID
                ulFlags);               // flags
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_CreateDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // assign a unique device instance value to the newly created device
        // instance
        //

        ASSERT(*szNewDeviceID && IsLegalDeviceId(szNewDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable, szNewDeviceID,
                                           STRTAB_CASE_SENSITIVE);

        if (*pdnDevInst == 0) {
            Status = CR_NO_SUCH_DEVNODE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Create_DevNode_ExW



CONFIGRET
CM_Move_DevNode_Ex(
    IN DEVINST  dnFromDevInst,
    IN DEVINST  dnToDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine replaces a root-enumerated device instance by the valid
   non-root-enumerated device instance.  The device installer uses this
   service when it detects that a non-root enumerated device instance is
   really the same as its root enumerated counterpart.  This API migrates
   the old device instance to the new location, and marks the old location
   as having a problem.

   ** THIS ROUTINE IS NOT IMPLEMENTED **

Parameters:

   dnFromDevNode  Supplies the handle of the device instance that has been
                  root enumerated.

   dnToDevNode    Supplies the handle of the device instance that is a
                  reenumeration (duplicate) of the root device instance.

   ulFlags        Must be zero.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

--*/

{
    UNREFERENCED_PARAMETER(dnFromDevInst);
    UNREFERENCED_PARAMETER(dnToDevInst);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Move_DevNode_Ex



CONFIGRET
CM_Setup_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine reenables and configures a specified device instance or
   retrieves information from its enumerator.

Parameters:

   dnDevNode   Supplies the handle of the device instance which may be
               reconfigured.

   ulFlags     Supplies a flag indicating the action to take.  Can be one
               of the following values:

               CM_SETUP_DEVNODE_READY
                     Reenable the device instance that had a problem.

               CM_SETUP_DOWNLOAD
                     Retrieve information about this device instance
                     from its enumerator.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_FLAG,
       CR_INVALID_DEVNODE,
       CR_OUT_OF_MEMORY,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen=MAX_DEVICE_ID_LEN;
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_SETUP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,               // rpc binding handle
                PNP_DEVINST_SETUP,      // requested major action - SETUP
                ulFlags,                // requested minor action
                DeviceID,               // device instance to create
                NULL);                  // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Setup_DevNode_Ex



CONFIGRET
CM_Disable_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine disables a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance to be disabled.

   ulFlags     May be one of CM_DISABLE_BITS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_FLAG,
       CR_NOT_DISABLEABLE,
       CR_INVALID_DEVNODE,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    PNP_VETO_TYPE vetoType, *pVetoType;
    WCHAR       vetoName[MAX_DEVICE_ID_LEN], *pszVetoName;
    ULONG       ulNameLength;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DISABLE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (ulFlags & CM_DISABLE_UI_NOT_OK) {
            vetoType = PNP_VetoTypeUnknown;
            pVetoType = &vetoType;
            vetoName[0] = L'\0';
            pszVetoName = &vetoName[0];
            ulNameLength = MAX_DEVICE_ID_LEN;
        } else {
            pVetoType = NULL;
            pszVetoName = NULL;
            ulNameLength = 0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DisableDevInst(
                hBinding,                // rpc binding handle
                DeviceID,                // device instance to create
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);                // requested minor action (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DisableDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Disable_DevNode_Ex



CONFIGRET
CM_Enable_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine enables a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance to enable.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_FLAG,
       CR_INVALID_DEVNODE,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,               // rpc binding handle
                PNP_DEVINST_ENABLE,     // requested major action - ENABLE
                ulFlags,                // requested minor action (not used)
                DeviceID,               // device instance to enable
                NULL);                  // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enable_DevNode_Ex



CONFIGRET
CM_Get_DevNode_Status_Ex(
    OUT PULONG   pulStatus,
    OUT PULONG   pulProblemNumber,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the status of a device instance.

Parameters:

   pulStatus      Supplies the address of the variable that receives the
                  status flag of the device instance.  Can be a combination
                  of the DN_* values.

   pulProblemNumber  Supplies the address of the variable that receives an
                     identifier indicating the problem.  Can be one of the
                     CM_PROB_* values.


   dnDevNode         Supplies the handle of the device instance for which
                     to retrieve status.

   ulFlags           Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_INVALID_POINTER, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulStatus)) ||
            (!ARGUMENT_PRESENT(pulProblemNumber))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceStatus(
                hBinding,               // rpc binding handle
                DeviceID,               // device instance to get status for
                pulStatus,              // return StatusFlags here
                pulProblemNumber,       // return Problem here
                ulFlags);               // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceStatus caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Status_Ex



CONFIGRET
CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine clears or set the problem of a device instance.

Parameters:

   dnDevNode    Supplies the handle of the device instance for which
                to set the problem.

   ulProblem    Supplies the new problem value.  Can be one of the
                CM_PROB_* values. If zero, the problem is cleared.

   ulFlags      Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_SET_DEVNODE_PROBLEM_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetDeviceProblem(
                hBinding,   // rpc binding handle
                DeviceID,   // device instance
                ulProblem,  // specifies new Problem
                ulFlags);   // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetDeviceProblem caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_DevNode_Problem_Ex



CONFIGRET
CM_Reenumerate_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine causes the specified device instance to be enumerated
   (if it is enumerable).

Parameters:

   dnDevNode   Supplies the handle of the device instance to be enumerated.

   ulFlags     Supplies flags specifying options for the re-enumeration of the
               device instance.  May be one of the following values:

               CM_REENUMERATE_NORMAL
               CM_REENUMERATE_SYNCHRONOUS
               CM_REENUMERATE_RETRY_INSTALLATION
               CM_REENUMERATE_ASYNCHRONOUS

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REENUMERATE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,               // rpc binding handle
                PNP_DEVINST_REENUMERATE,// requested major action - REENUMERATE
                ulFlags,                // requested minor action
                DeviceID,               // device instance subtree to reenumerate
                NULL);                  // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Reenumerate_DevNode_Ex



CONFIGRET
CM_Query_And_Remove_SubTree_ExW(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )

/*++

Routine Description:

   This routine checks whether a device instance and its progeny can be
   removed.  If the query isn't vetoed then a remove is done.  The replaces
   the old CM_Query_Remove_SubTree followed by CM_Remove_SubTree.

Parameters:

   dnAncestor  Supplies the handle of the device instance at the root of
               the subtree to be removed.

   ulFlags     Specifies whether UI should be presented for
               this action.  Can be one of the following values:

               CM_REMOVE_UI_OK       - OK to present UI for query-removal.
               CM_REMOVE_UI_NOT_OK   - Don't present UI for query-removal.
               CM_REMOVE_NO_RESTART  - Don't attempt to restart the devnode.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_REMOVE_VETOED,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (dnAncestor == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REMOVE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        pSetupStringTableStringFromIdEx(hStringTable, dnAncestor,pDeviceID,&ulLen);

        ASSERT(pDeviceID && *pDeviceID && IsLegalDeviceId(pDeviceID));

        if (pDeviceID == NULL || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (ulNameLength == 0) {
            pszVetoName = NULL;
        }

        if (pszVetoName != NULL) {
            *pszVetoName = L'\0';
        }

        if (pVetoType != NULL) {
            *pVetoType = PNP_VetoTypeUnknown;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryRemove(
                hBinding,                   // rpc binding handle
                pDeviceID,                  // device instance subtree to remove
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryRemove caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_And_Remove_SubTree_ExW



CONFIGRET
CM_Query_Remove_SubTree_Ex(
    IN DEVINST  dnAncestor,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine checks whether a device instance and its progeny can be
   removed.  This API must be called before calling CM_Remove_SubTree to
   make sure applications prepare for the removal of the device or to
   give the applications a chance to deny the request to remove the device.
   If the removal happens ?surprise style? (i.e., there?s no advanced
   warning or chance to veto), then this API should not be called before
   calling CM_Remove_SubTree.

Parameters:

   dnAncestor  Supplies the handle of the device instance at the root of
               the subtree to be removed.

   ulFlags     Specifies whether UI should be presented for
               this action.  Can be one of the following values:

               CM_QUERY_REMOVE_UI_OK  - OK to present UI for query-removal.
               CM_QUERY_REMOVE_UI_NOT_OK  -Don't present UI for query-removal.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

--*/

{
    UNREFERENCED_PARAMETER(dnAncestor);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Query_Remove_SubTree_Ex



CONFIGRET
CM_Remove_SubTree_Ex(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine removes a device instance and its children from the
   running system.  This API notifies each device instance in the subtree
   of the dnAncestor parameter of the device's removal.  (On Windows NT,
   this means that each driver/service controlling a device in this
   subtree receives a device removal notification.)

Parameters:

   dnAncestor  Supplies the handle of the device instance that is being removed.

   ulFlags     Must be either CM_REMOVE_UI_OK or CM_REMOVE_UI_NOT_OK.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

--*/

{
    UNREFERENCED_PARAMETER(dnAncestor);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Remove_SubTree_Ex



CONFIGRET
CM_Uninstall_DevNode_Ex(
    IN DEVNODE  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine uninstalls a device instance (i.e., deletes its registry
   key(s) in the Enum branch).  This API can only be called for phantom
   device instances, and the handle supplied is invalid after the call.
   This API does not attempt to delete all possible storage locations
   associated with the device instance.  It will do a recursive delete on
   the devnode key, so that any subkeys will be removed.  It will also
   delete the devnode key (and any subkeys) located in the Enum branch
   of each hardware profile.  It will not delete any software keys or user
   keys  (CM_Delete_DevNode_Key must be called to do that before calling
   this API).

Parameters:

   dnPhantom   Handle of a phantom device instance to uninstall.  This
               handle is typically retrieved by a call to CM_Locate_DevNode
               or CM_Create_DevNode.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_REGISTRY_ERROR,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       szParentKey[MAX_CM_PATH], szChildKey[MAX_CM_PATH],
                DeviceID[MAX_DEVICE_ID_LEN];
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UninstallDevInst(
                hBinding,                  // rpc binding handle
                DeviceID,                  // device instance to uninstall
                ulFlags);                  // (unused)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_UninstallDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //------------------------------------------------------------------
        // after deleting the main hw key and the config specific hw keys,
        // cleanup the user hw key, which can only be done on the client
        // side.
        //------------------------------------------------------------------

        //
        // form the user hardware registry key path
        //
        // note - in some cases, GetDevNodeKeyPath may call PNP_GetClassInstance
        // or PNP_SetDeviceRegProp to set values on the server, in which case
        // special privileges would be required by the server.  the call below,
        // which specifies the flags (CM_REGISTRY_HARDWARE | CM_REGISTRY_USER)
        // is NOT one of those cases, so there is no need to have any privileges
        // enabled during this call.
        //
        Status =
            GetDevNodeKeyPath(
                hBinding,
                DeviceID,
                CM_REGISTRY_HARDWARE | CM_REGISTRY_USER,
                0,
                szParentKey,
                SIZECHARS(szParentKey),
                szChildKey,
                SIZECHARS(szChildKey),
                FALSE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // delete the specified private user key
        //
        Status = DeletePrivateKey(HKEY_CURRENT_USER, szParentKey, szChildKey);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Uninstall_DevNode_Ex



CONFIGRET
CM_Request_Device_Eject_ExW(
    IN DEVNODE          dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )

/*++

Routine Description:


Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_REGISTRY_ERROR,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivileges[2];


    try {
        //
        // validate parameters
        //
        if (ulNameLength == 0) {
            pszVetoName = NULL;
        }

        if (pszVetoName != NULL) {
            *pszVetoName = L'\0';
        }

        if (pVetoType != NULL) {
            *pVetoType = PNP_VetoTypeUnknown;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // no flags are currently valid
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        // Note - for most devices, only the SeLoadDriverPrivilege privilege
        // will be required, however if the device being ejected is a dock
        // device, the SeUndockPrivilege privilege will be required instead.
        // Since we don't know if the device the user is requesting to eject is
        // a dock device or not (that is determined on the server-side), we
        // attempt to enable both privileges.
        //
        // ISSUE-2002/03/04-jamesca: Should client perform dock device check?
        //     We could avoid enabling one of these two privileges unecessarily
        //   if the client checked the capabilities of the device in advance to
        //   see if the device was actually a dock or not.  In the case of a
        //   dock this routine would simply call CM_Request_Eject_PC, which
        //   would enable the SeUndockPrivilege.  This logic already exists on
        //   the server, is it appropriate for the client also/instead?
        //
        ulPrivileges[0] = SE_LOAD_DRIVER_PRIVILEGE;
        ulPrivileges[1] = SE_UNDOCK_PRIVILEGE;
        hToken = PnPEnablePrivileges(ulPrivileges, 2);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RequestDeviceEject(
                hBinding,                   // rpc binding handle
                DeviceID,                   // device instance subtree to remove
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RequestDeviceEject caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Request_Device_Eject_ExW



CONFIGRET
CM_Add_ID_ExW(
    IN DEVINST  dnDevInst,
    IN PWSTR    pszID,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:


   This routine adds a device ID to a device instance's HardwareID or
   CompatibleIDs list.

Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   pszID       Supplies a pointer to a NULL-terminated string specifying
               the ID to be added.

   ulFlags     Supplies flags for the ID.  May be one of the following values:

               ID Type Flags:
               CM_ADD_ID_HARDWARE   The specified ID is a hardware ID.  Add
                                    it to the device instance's HardwareID
                                    list.
               CM_ADD_ID_COMPATIBLE The specified ID is a compatible ID.
                                    Add it to the device instance's
                                    CompatibleIDs list.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_POINTER,
       CR_INVALID_FLAG,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pszID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_ADD_ID_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddID(
                hBinding,                  // rpc binding handle
                DeviceID,                 // device instance
                pszID,                     // id to add
                ulFlags);                  // hardware or compatible
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddID caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Add_ID_ExW



CMAPI
CONFIGRET
CM_Register_Device_Driver_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:


   This routine registers the device driver for the specified device.

Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulFlags     Supplies flags for register the driver.  May be one of the
               following values:

                CM_REGISTER_DEVICE_DRIVER_STATIC
                CM_REGISTER_DEVICE_DRIVER_DISABLEABLE
                CM_REGISTER_DEVICE_DRIVER_REMOVABLE

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_ACCESS_DENIED, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTER_DEVICE_DRIVER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterDriver(
                hBinding,                  // rpc binding handle
                DeviceID,                  // device instance
                ulFlags);                  // hardware or compatible
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RegisterDriver caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Register_Device_Driver_Ex



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Create_DevNodeW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags
    )
{
    return CM_Create_DevNode_ExW(pdnDevInst, pDeviceID, dnParent,
                                 ulFlags, NULL);
}


CONFIGRET
CM_Create_DevNodeA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags
    )
{
    return CM_Create_DevNode_ExA(pdnDevInst, pDeviceID, dnParent,
                                 ulFlags, NULL);
}


CONFIGRET
CM_Move_DevNode(
    IN DEVINST dnFromDevInst,
    IN DEVINST dnToDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Move_DevNode_Ex(dnFromDevInst, dnToDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Setup_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Setup_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Disable_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Disable_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Enable_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Enable_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_DevNode_Status(
    OUT PULONG  pulStatus,
    OUT PULONG  pulProblemNumber,
    IN  DEVINST dnDevInst,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_DevNode_Status_Ex(pulStatus, pulProblemNumber,
                                    dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Problem(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags
    )
{
    return CM_Set_DevNode_Problem_Ex(dnDevInst, ulProblem, ulFlags, NULL);
}


CONFIGRET
CM_Reenumerate_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Reenumerate_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Query_And_Remove_SubTree(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG                   ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Query_And_Remove_SubTree_Ex( dnAncestor,
                                           pVetoType,
                                           pszVetoName,
                                           ulNameLength,
                                           ulFlags,
                                           NULL);
}


CONFIGRET
CM_Query_And_Remove_SubTreeA(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Query_And_Remove_SubTree_ExA( dnAncestor,
                                            pVetoType,
                                            pszVetoName,
                                            ulNameLength,
                                            ulFlags,
                                            NULL);
}


CONFIGRET
CM_Remove_SubTree(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags
    )
{
    return CM_Remove_SubTree_Ex(dnAncestor, ulFlags, NULL);
}


CONFIGRET
CM_Uninstall_DevNode(
    IN DEVNODE dnPhantom,
    IN ULONG   ulFlags
    )
{
    return CM_Uninstall_DevNode_Ex(dnPhantom, ulFlags, NULL);
}


CONFIGRET
CM_Add_IDW(
    IN DEVINST dnDevInst,
    IN PWSTR   pszID,
    IN ULONG   ulFlags
    )
{
    return CM_Add_ID_ExW(dnDevInst, pszID, ulFlags, NULL);
}


CONFIGRET
CM_Add_IDA(
    IN DEVINST dnDevInst,
    IN PSTR    pszID,
    IN ULONG   ulFlags
    )
{
    return CM_Add_ID_ExA(dnDevInst, pszID, ulFlags, NULL);
}


CMAPI
CONFIGRET
CM_Register_Device_Driver(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags
    )
{
    return CM_Register_Device_Driver_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Query_Remove_SubTree(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags
    )
{
    return CM_Query_Remove_SubTree_Ex(dnAncestor, ulFlags, NULL);
}


CONFIGRET
CM_Request_Device_EjectW(
    IN  DEVINST         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Request_Device_Eject_ExW(dnDevInst,
                                       pVetoType,
                                       pszVetoName,
                                       ulNameLength,
                                       ulFlags,
                                       NULL);
}


CONFIGRET
CM_Request_Device_EjectA(
    IN  DEVNODE         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Request_Device_Eject_ExA( dnDevInst,
                                        pVetoType,
                                        pszVetoName,
                                        ulNameLength,
                                        ulFlags,
                                        NULL);
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Add_ID_ExA(
    IN DEVINST  dnDevInst,
    IN PSTR     pszID,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniID = NULL;


    if (pSetupCaptureAndConvertAnsiArg(pszID, &pUniID) == NO_ERROR) {

        Status = CM_Add_ID_ExW(dnDevInst,
                               pUniID,
                               ulFlags,
                               hMachine);
        pSetupFree(pUniID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Add_ID_ExA



CONFIGRET
CM_Create_DevNode_ExA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceID = NULL;


    if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Create_DevNode_ExW(pdnDevInst,
                                       pUniDeviceID,
                                       dnParent,
                                       ulFlags,
                                       hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_DEVICE_ID;
    }

    return Status;

} // CM_Create_DevNode_ExA



CONFIGRET
CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS, tmpStatus;
    PWSTR     pUniVetoName = NULL;
    ULONG     ulAnsiBufferLen;
    size_t    UniBufferLen = 0;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszVetoName)) && (ulNameLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (ulNameLength != 0) {
        //
        // pass a Unicode buffer instead and convert back to caller's
        // ANSI buffer on return
        //
        pUniVetoName = pSetupMalloc(MAX_VETO_NAME_LENGTH*sizeof(WCHAR));
        if (pUniVetoName == NULL) {
            return CR_OUT_OF_MEMORY;
        }
    }

    //
    // call the wide version
    //
    Status = CM_Query_And_Remove_SubTree_ExW(dnAncestor,
                                             pVetoType,
                                             pUniVetoName,
                                             MAX_VETO_NAME_LENGTH,
                                             ulFlags,
                                             hMachine);

    //
    // We should never return a veto name longer than MAX_VETO_NAME_LENGTH.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if ((Status == CR_REMOVE_VETOED) && (ARGUMENT_PRESENT(pszVetoName))) {
        //
        // convert the unicode buffer to an ANSI string and copy to the caller's
        // buffer
        //
        ASSERT(pUniVetoName != NULL);

        if (FAILED(StringCchLength(
                       pUniVetoName,
                       MAX_VETO_NAME_LENGTH,
                       &UniBufferLen))) {
            //
            // the returned veto name is not a valid length (shouldn't happen),
            // but still return that a veto occurred.
            //
            return CR_REMOVE_VETOED;
        }

        ulAnsiBufferLen = ulNameLength;

        tmpStatus =
            PnPUnicodeToMultiByte(
                pUniVetoName,
                (ULONG)((UniBufferLen + 1)*sizeof(WCHAR)),
                pszVetoName,
                &ulAnsiBufferLen);

        //
        // if conversion was unsuccessful, return that status instead
        //
        if (tmpStatus != CR_SUCCESS) {
            Status = tmpStatus;
        }
    }

    if (pUniVetoName != NULL) {
        pSetupFree(pUniVetoName);
    }

    return Status;

} // CM_Query_And_Remove_SubTree_ExA



CONFIGRET
CM_Request_Device_Eject_ExA(
    IN  DEVNODE         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS, tmpStatus;
    PWSTR     pUniVetoName = NULL;
    ULONG     ulAnsiBufferLen;
    size_t    UniBufferLen = 0;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszVetoName)) && (ulNameLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (ulNameLength != 0) {
        //
        // pass a Unicode buffer instead and convert back to caller's
        // ANSI buffer on return
        //
        pUniVetoName = pSetupMalloc(MAX_VETO_NAME_LENGTH*sizeof(WCHAR));
        if (pUniVetoName == NULL) {
            return CR_OUT_OF_MEMORY;
        }
    }

    //
    // call the wide version
    //
    Status = CM_Request_Device_Eject_ExW(dnDevInst,
                                         pVetoType,
                                         pUniVetoName,
                                         MAX_VETO_NAME_LENGTH,
                                         ulFlags,
                                         hMachine);

    //
    // We should never return a veto name longer than MAX_VETO_NAME_LENGTH.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if ((Status == CR_REMOVE_VETOED) && (ARGUMENT_PRESENT(pszVetoName))) {
        //
        // convert the unicode buffer to an ANSI string and copy to the caller's
        // buffer
        //
        ASSERT(pUniVetoName != NULL);

        if (FAILED(StringCchLength(
                       pUniVetoName,
                       MAX_VETO_NAME_LENGTH,
                       &UniBufferLen))) {
            //
            // the returned veto name is not a valid length (shouldn't happen),
            // but still return that a veto occurred.
            //
            return CR_REMOVE_VETOED;
        }

        ulAnsiBufferLen = ulNameLength;

        tmpStatus =
            PnPUnicodeToMultiByte(
                pUniVetoName,
                (ULONG)((UniBufferLen + 1)*sizeof(WCHAR)),
                pszVetoName,
                &ulAnsiBufferLen);

        //
        // if conversion was unsuccessful, return that status instead
        //
        if (tmpStatus != CR_SUCCESS) {
            Status = tmpStatus;
        }
    }

    if (pUniVetoName != NULL) {
        pSetupFree(pUniVetoName);
    }

    return Status;

} // CM_Request_Device_Eject_ExA



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\logconf.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    logconf.c

Abstract:

    This module contains the API routines that operate directly on logical
    configurations.

               CM_Add_Empty_Log_Conf
               CM_Free_Log_Conf
               CM_Get_First_Log_Conf
               CM_Get_Next_Log_Conf
               CM_Free_Log_Conf_Handle
               CM_Get_Log_Conf_Priority_Ex

Author:

    Paula Tomlinson (paulat) 9-26-1995

Environment:

    User mode only.

Revision History:

    26-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


//
// Private prototypes
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );



CONFIGRET
CM_Add_Empty_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  PRIORITY  Priority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine creates an empty logical configuration.  This configuration
   has no resource descriptor.

Parameters:

   plcLogConf  Address of a variable that receives the handle of the logical
               configuration.

   dnDevNode   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   Priority    Specifies the priority of the logical configuration.

   ulFlags     Supplies flags relating to the logical configuration.  Must
               be either BASIC_LOG_CONF or FILTERED_LOG_CONF, combined with
               either PRIORITY_EQUAL_FIRST or PRIORITY_EQUAL_LAST.

               BASIC_LOG_CONF - Specifies the requirements list
               FILTERED_LOG_CONF - Specifies the filtered requirements list
               PRIORITY_EQUAL_FIRST - Same priority, new one is first
               PRIORITY_EQUAL_LAST - Same priority, new one is last

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY,
         CR_INVALID_PRIORITY,
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTag = 0;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (plcLogConf == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (Priority > MAX_LCPRI) {
            Status = CR_INVALID_PRIORITY;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS | PRIORITY_BIT)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *plcLogConf = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddEmptyLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                Priority,         // priority for new log conf
                &ulTag,           // return tag of log conf
                ulFlags);         // type of log conf to add
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddEmptyLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // If successful, allocate a new log conf handle, fill with log conf
        // info
        //

        if (Status == CR_SUCCESS) {
            Status = CreateLogConfHandle(
                plcLogConf, dnDevInst,
                ulFlags & LOG_CONF_BITS,
                ulTag);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Add_Empty_Log_Conf_Ex



CONFIGRET
CM_Free_Log_Conf_Ex(
    IN LOG_CONF lcLogConfToBeFreed,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine frees a logical configuration and all resource descriptors
   associated with it.   This API may invalidate the logical configuration
   handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf
   APIs.  To continue enumerating logical configurations, always use the
   CM_Get_First_Log_Conf API to start again from the beginning.

Parameters:

   lcLogConfToBeFreed   Supplies the handle of the logical configuration to
               free.  This handle must have been previously returned from
               a call to CM_Add_Empty_Log_Conf.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    ULONG       ulTag, ulType,ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // extract the devnode and log conf info from the log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_DevInst;
        ulTag     = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_LogConfTag;
        ulType    = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_LogConfType;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_REGISTRY,
                   "CM_Free_Log_Conf_Ex: Deleting LogConf (pDeviceID = %s, Type = %d\r\n",
                   pDeviceID,
                   ulType));

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_FreeLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // identifies which type of log conf
                ulTag,            // identifies which actual log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_FreeLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_INVALID_LOG_CONF;    // probably a bad log conf got us here
    }

    return Status;

} // CM_Free_Log_Conf_Ex



CONFIGRET
CM_Get_First_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,       OPTIONAL
    IN  DEVINST   dnDevInst,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns a handle to the first logical configuration of the
   specified type in a device instance.  The CM_Add_Empty_Log_Conf and
   CM_Free_Log_Conf APIs may invalidate the handle of the logical
   configuration returned by this API.  To enumerate logical configurations
   after adding or freeing a logical configuration, always call this API
   again to retrieve a valid handle.

Parameters:

   plcLogConf  Supplies the address of the variable that receives the handle
               of the logical configuration.

   dnDevNode   Supplies the handle of the device instance for which to
               retrieve the logical configuration.

   ulFlags     Configuration type.  Can be one of the following values:
               ALLOC_LOG_CONF - Retrieve the allocated configuration.
               BASIC_LOG_CONF - Retrieve the requirements list.
               BOOT_LOG_CONF  - Retrieve the boot configuration.

               The following additional configuration type is also defined
               for Windows 95:
               FILTERED_LOG_CONF - Retrieve the filtered requirements list.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOF_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize paramters (plcLogConf is optional)
        //
        if (plcLogConf != NULL) {
            *plcLogConf = 0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetFirstLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulFlags,          // type of long conf
                &ulTag,           // return tag of specific log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetFirstLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS  && plcLogConf != NULL) {
            //
            // allocate a new log conf handle, fill with log conf info
            //
            Status = CreateLogConfHandle(plcLogConf, dnDevInst,
                                         ulFlags & LOG_CONF_BITS,
                                         ulTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_First_Log_Conf_Ex



CONFIGRET
CM_Get_Next_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,     OPTIONAL
    IN  LOG_CONF  lcLogConf,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns a handle to the next logical configuration following
   the given configuration. This API returns CR_NO_MORE_LOG_CONF if the given
   handle was retrieved using the CM_Get_First_Log_Conf API with either the
   ALLOC_LOG_CONF or BOOT_LOG_CONF flag.  There is never more than one active
   boot logical configuration or currently-allocated logical configuration.
   The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the
   logical configuration handle returned by this API.  To continue enumerating
   logical configuration after addding or freeing a logical configuration,
   always use the CM_Get_First_Log_Conf API to start again from the beginning.

Parameters:

   plcLogConf  Supplies the address of the variable that receives the handle
               of the next logical configuration.

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using either this API or
               the CM_Get_First_Log_Conf API.  Logical configurations are in
               priority order.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulType = 0, ulCurrentTag = 0, ulNextTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize paramters (plcLogConf is optional)
        //
        if (plcLogConf != NULL) {
            *plcLogConf = 0;
        }

        //
        // extract devnode and log conf info from the current log conf handle
        //
        dnDevInst    = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulType       = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulCurrentTag = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetNextLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // specifes which type of log conf
                ulCurrentTag,     // specifies current log conf tag
                &ulNextTag,       // return tag of next log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetNextLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS  &&  plcLogConf != NULL) {
            //
            // allocate a new log conf handle, fill with log conf info
            //
            Status = CreateLogConfHandle(plcLogConf, dnDevInst,
                                         ulType, ulNextTag);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Next_Log_Conf_Ex



CONFIGRET
CM_Free_Log_Conf_Handle(
    IN  LOG_CONF  lcLogConf
    )

/*++

Routine Description:

   This routine frees the handle to the specified log conf and frees and
   memory associated with that log conf handle.

Parameters:

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using CM_Add_Empty_Log_Conf,
               CM_Get_First_Log_Conf or CM_Get_Next_Log_Conf.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;


    try {
        //
        // Validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // It's a valid log conf handle, which is a pointer to memory
        // allocated when the log conf was created or retrieved using
        // the first/next routines. Free the associated memory.
        //
        ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_Signature = 0;
        pSetupFree((PPrivate_Log_Conf_Handle)lcLogConf);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Log_Conf_Handle



CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns the priority value of the specified log conf.
   Only BASIC, FILTERED and OVERRIDE log confs (requirements lists) have
   a priority value associated with them. If a FORCED, BOOT, or ALLOC
   config is passed in, then CR_INVALID_LOG_CONF will be returned.

Parameters:

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using either the
               CM_Add_Emptry_Log_Conf, CM_Get_First_Log_Conf, or
               CM_Get_Next_Log_Conf API.

   pPriority   Supplies the address of the variable that receives the
               priorty (if any) associated with this logical configuration.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulType = 0, ulTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pPriority == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // extract devnode and log conf info from the current log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulType    = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulTag     = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // only "requirements list" style log confs have priorities and
        // are valid in this call.
        //
        if ((ulType != BASIC_LOG_CONF) &&
            (ulType != FILTERED_LOG_CONF) &&
            (ulType != OVERRIDE_LOG_CONF)) {

            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetLogConfPriority(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // specifes which type of log conf
                ulTag,            // specifies current log conf tag
                pPriority,        // return tag of next log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetLogConfPriority caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Log_Conf_Handle



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Add_Empty_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  PRIORITY  Priority,
    IN  ULONG     ulFlags
    )
{
    return CM_Add_Empty_Log_Conf_Ex(plcLogConf, dnDevInst, Priority,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Free_Log_Conf(
    IN LOG_CONF lcLogConfToBeFreed,
    IN ULONG    ulFlags
    )
{
    return CM_Free_Log_Conf_Ex(lcLogConfToBeFreed, ulFlags, NULL);
}


CONFIGRET
CM_Get_First_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_First_Log_Conf_Ex(plcLogConf, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Next_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  LOG_CONF  lcLogConf,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_Next_Log_Conf_Ex(plcLogConf, lcLogConf, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_Log_Conf_Priority_Ex(lcLogConf, pPriority, ulFlags, NULL);
}



//-------------------------------------------------------------------
// Local Utility Routines
//-------------------------------------------------------------------


CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    )
{
    PPrivate_Log_Conf_Handle   pLogConfHandle;

    //
    // allocate memory for the res des handle data
    //
    pLogConfHandle = (PPrivate_Log_Conf_Handle)pSetupMalloc(
                            sizeof(Private_Log_Conf_Handle));

    if (pLogConfHandle == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    //
    // fill in the private res des info and return as handle
    //
    pLogConfHandle->LC_Signature   = CM_PRIVATE_LOGCONF_SIGNATURE;
    pLogConfHandle->LC_DevInst     = dnDevInst;
    pLogConfHandle->LC_LogConfType = ulLogType;
    pLogConfHandle->LC_LogConfTag  = ulLogTag;

    *plcLogConf = (LOG_CONF)pLogConfHandle;

    return CR_SUCCESS;

} // CreateLogConfHandle



BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    )
{
    //
    // validate parameters
    //
    if (pLogConf == NULL  || pLogConf == 0) {
        return FALSE;
    }

    //
    // check for the private log conf signature
    //
    if (pLogConf->LC_Signature != CM_PRIVATE_LOGCONF_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateLogConfHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\main.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    main.c

Abstract:

    This module contains the startup and termination code for the Configuration
    Manager (cfgmgr32).

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    3-Mar-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


//
// global data
//
HANDLE   hInst;
PVOID    hLocalStringTable = NULL;     // handle to local string table
PVOID    hLocalBindingHandle = NULL;   // rpc binding handle to local machine
WORD     LocalServerVersion = 0;       // local machine internal server version
WCHAR    LocalMachineNameNetBIOS[MAX_PATH + 3];
WCHAR    LocalMachineNameDnsFullyQualified[MAX_PATH + 3];
CRITICAL_SECTION  BindingCriticalSection;
CRITICAL_SECTION  StringTableCriticalSection;



BOOL
CfgmgrEntry(
    PVOID hModule,
    ULONG Reason,
    PCONTEXT pContext
    )

/*++

Routine Description:

   This is the standard DLL entrypoint routine, called whenever a process
   or thread attaches or detaches.
   Arguments:

   hModule -   PVOID parameter that specifies the handle of the DLL

   Reason -    ULONG parameter that specifies the reason this entrypoint
               was called (either PROCESS_ATTACH, PROCESS_DETACH,
               THREAD_ATTACH, or THREAD_DETACH).

   pContext -  Not used.
               (when cfgmgr32 is initialized by setupapi - as should almost
               always be the case - this is the 'Reserved' argument supplied to
               setupapi's DllMain entrypoint)

Return value:

   Returns true if initialization completed successfully, false is not.

--*/

{
    UNREFERENCED_PARAMETER(pContext);

    hInst = (HANDLE)hModule;

    switch(Reason) {

        case DLL_PROCESS_ATTACH: {

            WCHAR    szTemp[MAX_PATH + 1];
            ULONG    ulSize;
            size_t   len;

            //
            // InitializeCriticalSection may raise STATUS_NO_MEMORY exception
            //
            try {
                InitializeCriticalSection(&BindingCriticalSection);
                InitializeCriticalSection(&StringTableCriticalSection);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }

            //
            // save the NetBIOS name of the local machine for later use.
            // note that the size of the DNS computer name buffer is MAX_PATH+3,
            // which is actually much larger than MAX_COMPUTERNAME_LENGTH, the
            // max length returned for ComputerNameNetBIOS.
            //
            ulSize = SIZECHARS(szTemp);

            if(!GetComputerNameEx(ComputerNameNetBIOS, szTemp, &ulSize)) {

                //
                // ISSUE-2002/03/05-jamesca: Can we actually run w/o knowing
                // the local machine name???
                //
                *LocalMachineNameNetBIOS = L'\0';

            } else {

                if (FAILED(StringCchLength(
                               szTemp,
                               SIZECHARS(szTemp),
                               &len))) {
                    return FALSE;
                }

                //
                // always save local machine name in "\\name format"
                //
                if((len > 2) &&
                   (szTemp[0] == L'\\') && (szTemp[1] == L'\\')) {
                    //
                    // The name is already in the correct format.
                    //
                    if (FAILED(StringCchCopy(
                                   LocalMachineNameNetBIOS,
                                   SIZECHARS(LocalMachineNameNetBIOS),
                                   szTemp))) {
                        return FALSE;
                    }

                } else {
                    //
                    // Prepend UNC path prefix
                    //
                    if (FAILED(StringCchCopy(
                                   LocalMachineNameNetBIOS,
                                   SIZECHARS(LocalMachineNameNetBIOS),
                                   L"\\\\"))) {
                        return FALSE;
                    }

                    if (FAILED(StringCchCat(
                                   LocalMachineNameNetBIOS,
                                   SIZECHARS(LocalMachineNameNetBIOS),
                                   szTemp))) {
                        return FALSE;
                    }
                }
            }


            //
            // save the DNS name of the local machine for later use.
            // note that the size of the DNS computer name buffer is MAX_PATH+3,
            // which is actually larger than DNS_MAX_NAME_BUFFER_LENGTH, the max
            // length for ComputerNameDnsFullyQualified.
            //
            ulSize = SIZECHARS(szTemp);

            if(!GetComputerNameEx(ComputerNameDnsFullyQualified, szTemp, &ulSize)) {

                //
                // ISSUE-2002/03/05-jamesca: Can we actually run w/o knowing
                // the local machine name???
                //
                *LocalMachineNameDnsFullyQualified = L'\0';

            } else {

                if (FAILED(StringCchLength(
                               szTemp,
                               SIZECHARS(szTemp),
                               &len))) {
                    return FALSE;
                }

                //
                // always save local machine name in "\\name format"
                //
                if((len > 2) &&
                   (szTemp[0] == L'\\') && (szTemp[1] == L'\\')) {
                    //
                    // The name is already in the correct format.
                    //
                    if (FAILED(StringCchCopy(
                                   LocalMachineNameDnsFullyQualified,
                                   SIZECHARS(LocalMachineNameDnsFullyQualified),
                                   szTemp))) {
                        return FALSE;
                    }

                } else {
                    //
                    // Prepend UNC path prefix
                    //
                    if (FAILED(StringCchCopy(
                                   LocalMachineNameDnsFullyQualified,
                                   SIZECHARS(LocalMachineNameDnsFullyQualified),
                                   L"\\\\"))) {
                        return FALSE;
                    }

                    if (FAILED(StringCchCat(
                                   LocalMachineNameDnsFullyQualified,
                                   SIZECHARS(LocalMachineNameDnsFullyQualified),
                                   szTemp))) {
                        return FALSE;
                    }
                }
            }
            break;
        }

        case DLL_PROCESS_DETACH:
            //
            // release the rpc binding for the local machine
            //
            if (hLocalBindingHandle != NULL) {

                PNP_HANDLE_unbind(NULL, (handle_t)hLocalBindingHandle);
                hLocalBindingHandle = NULL;
            }

            //
            // release the string table for the local machine
            //
            if (hLocalStringTable != NULL) {
                pSetupStringTableDestroy(hLocalStringTable);
                hLocalStringTable = NULL;
            }

            DeleteCriticalSection(&BindingCriticalSection);
            DeleteCriticalSection(&StringTableCriticalSection);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;

} // CfgmgrEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\precomp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the Configuration Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpnpapi.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <cfgmgr32.h>
#pragma warning(push, 3)
#include <setupapi.h>   // setupapi.h does not compile cleanly at warning level 4.
#pragma warning(pop)
#include <regstr.h>
#include <strsafe.h>

//
// Win32 Private Header Files
//
#include <spapip.h>     // private setupapi exports

//
// CRT Header Files
//
#include <stdlib.h>
#include <stddef.h>

//
// RPC Header Files
//
#include <ntrpcp.h>     // RpcpBindRpc, RpcpUnbindRpc
#include <rpcasync.h>   // I_RpcExceptionFilter

//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "umpnplib.h"   // private shared header, for routines in shared umpnplib
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\pnp_c_stub.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnp_c_stub.c

Abstract:

    Stub file to allow pnp_c.c to work with precompiled headers.

Author:

    Jim Cavalaris (jamesca) 04-06-2001

Environment:

    User-mode only.

Revision History:

    06-April-2001     jamesca

        Creation and initial implementation.

Notes:

    The included file pnp_c.c contains the client side stubs for the PNP RPC
    interface.  The stubs are platform specific, and are included from
    ..\idl\$(O).  You must first build ..\idl for the current platform prior to
    building cfgmgr32.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop


//
// Disable some level-4 warnings for the MIDL-generated RPC client stubs.
//
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4211) // warning C4211: nonstandard extension used: redefined extern to static
#pragma warning(disable:4310) // warning C4310: cast truncates constant value

//
// Include the RPC client-side stubs
//
#include "pnp_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\range.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    range.c

Abstract:

    This module contains the API routines that operate directly on ranges.

          CM_Add_Range
          CM_Create_Range_List
          CM_Delete_Range
          CM_Dup_Range_List
          CM_Find_Range
          CM_First_Range
          CM_Free_Range_List
          CM_Intersect_Range_List
          CM_Invert_Range_List
          CM_Merge_Range_List
          CM_Next_Range
          CM_Test_Range_Available

Author:

    Paula Tomlinson (paulat) 10-17-1995

Environment:

    User mode only.

Revision History:

    17-Oct-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


//
// Private prototypes
//
BOOL
IsValidRangeList(
    IN RANGE_LIST rlh
    );

CONFIGRET
AddRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue,
    IN ULONG           ulFlags
    );

CONFIGRET
InsertRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    );

CONFIGRET
DeleteRange(
    IN PRange_Element  pParentElement
    );

CONFIGRET
JoinRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    );

CONFIGRET
CopyRanges(
    IN PRange_Element  pFromRange,
    IN PRange_Element  pToRange
    );

CONFIGRET
ClearRanges(
    IN PRange_Element  pRange
    );

CONFIGRET
TestRange(
    IN  PRange_Element   rlh,
    IN  DWORDLONG        ullStartValue,
    IN  DWORDLONG        ullEndValue,
    OUT PRange_Element   *pConflictingRange
    );


//
// global data
//





CONFIGRET
CM_Add_Range(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine adds a memory range to a range list.

Parameters:

   ullStartValue  Low end of the range.

   ullEndValue    High end of the range.

   rlh            Handle of a range list.

   ulFlags        Supplies flags specifying options for ranges that conflict
                  with ranges alread in the list.  May be one of the
                  following values:

                  CM_ADD_RANGE_ADDIFCONFLICT New range is merged with the
                                             ranges it conflicts with.
                  CM_ADD_RANGE_DONOTADDIFCONFLICT Returns CR_FAILURE if there
                                             is a conflict.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.
--*/

{
    CONFIGRET    Status = CR_SUCCESS;
    BOOL         bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_ADD_RANGE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullStartValue > ullEndValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        Status = AddRange((PRange_Element)rlh, ullStartValue,
                          ullEndValue, ulFlags);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Add_Range



CONFIGRET
CM_Create_Range_List(
    OUT PRANGE_LIST prlh,
    IN  ULONG  ulFlags
    )

/*++

Routine Description:

   This routine creates a list of ranges.

Parameters:

   prlh     Supplies the address of the variable that receives a
            handle to the new range list.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET         Status = CR_SUCCESS;
    PRange_List_Hdr   pRangeHdr = NULL;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (prlh == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // allocate a buffer for the range list header struct
        //
        pRangeHdr = pSetupMalloc(sizeof(Range_List_Hdr));

        if (pRangeHdr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // initialize the range list header buffer
        //
        pRangeHdr->RLH_Head = 0;
        pRangeHdr->RLH_Header = (ULONG_PTR)pRangeHdr;
        pRangeHdr->RLH_Signature = Range_List_Signature;

        //
        // initialize the private resource lock
        //
        InitPrivateResource(&(pRangeHdr->RLH_Lock));

        //
        // return a pointer to range list buffer to the caller
        //
        *prlh = (RANGE_LIST)pRangeHdr;


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Create_Range_List



CONFIGRET
CM_Delete_Range(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine deletes a range from a range list. If ullStartValue
   and ullEndValue are set to 0 and DWORD_MAX, this API carries out
   a special case, quickly emptying the lower 4 Gigabytes of the range.
   If ullEndValue is instead DWORDLONG_MAX, the entire range list is
   cleared, without having to process each element.

Parameters:

   ullStartValue  Low end of the range.

   ullEndValue    High end of the range.

   rlh            Handle of a range list.

   ulFlags        Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL, pPrevious = NULL, pCurrent = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullStartValue > ullEndValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pPrevious = (PRange_Element)rlh;


        //-------------------------------------------------------------
        // first check the special case range values
        //-------------------------------------------------------------

        if (ullStartValue == 0) {

            if (ullEndValue == DWORDLONG_MAX) {
                //
                // quick clear of all ranges
                //
                ClearRanges(pPrevious);
            }

            else if (ullEndValue == DWORD_MAX) {
                //
                // quick clear of lower 4 GB ranges
                //
                while (pPrevious->RL_Next != 0) {
                    pCurrent = (PRange_Element)pPrevious->RL_Next;

                    if (pCurrent->RL_Start >= DWORD_MAX) {
                        goto Clean0;   // done
                    }

                    if (pCurrent->RL_End >= DWORD_MAX) {
                        pCurrent->RL_Start = DWORD_MAX;
                        goto Clean0;   // done
                    }

                    DeleteRange(pPrevious);    // pass the parent
                }
                goto Clean0;
            }
        }


        //-------------------------------------------------------------
        // search through each range in this list, if any part of the
        // specified range is contained in this range list, remove the
        // intersections
        //-------------------------------------------------------------

        while (pPrevious->RL_Next != 0) {
            pRange = (PRange_Element)pPrevious->RL_Next;

            //
            // if this range is completely before the current range, then
            // we can stop
            //
            if (ullEndValue < pRange->RL_Start) {
                break;
            }

            //
            // if this range is completely after the current range, then
            // skip to the next range
            //
            if (ullStartValue > pRange->RL_End) {
                goto NextRange;
            }

            //
            // if the range is completely contained, then delete the whole
            // thing
            //
            if (ullStartValue <= pRange->RL_Start  &&
                ullEndValue >= pRange->RL_End) {

                DeleteRange(pPrevious);    // pass the parent range

                //
                // don't goto next range because that would increment the
                // pPrevious counter. Since the current range was just deleted,
                // we need to process the current spot still.
                //
                continue;
            }

            //
            // if the start of the specified range intersects the current range,
            // adjust the current range to exclude it
            //
            if (ullStartValue > pRange->RL_Start  &&
                ullStartValue <= pRange->RL_End) {
                //
                // if the specified range is in the middle of this range, then
                // in addition to shrinking the first part of the range, I'll
                // have to create a range for the second part
                //       |  |<-- delete --->|  |
                //
                if (ullEndValue < pRange->RL_End) {
                    AddRange(pRange, ullEndValue+1, pRange->RL_End,
                             CM_ADD_RANGE_ADDIFCONFLICT);
                }

                pRange->RL_End = ullStartValue-1;

                //
                // reset the delete range for further processing
                //
                if (ullEndValue > pRange->RL_End) {
                    ullStartValue = pRange->RL_End+1;
                }
            }

            //
            // if the end of the specified range intersects the current range,
            // adjust the current range to exclude it
            //
            if (ullEndValue >= pRange->RL_Start  &&
                ullEndValue <= pRange->RL_End) {

                pRange->RL_Start = ullEndValue+1;

                //
                // reset the delete range for further processing
                //
                if (ullEndValue > pRange->RL_End) {
                    ullStartValue = pRange->RL_End+1;
                }
            }


            NextRange:

            pPrevious = (PRange_Element)pPrevious->RL_Next;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Delete_Range



CONFIGRET
CM_Dup_Range_List(
    IN RANGE_LIST rlhOld,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine copies a range list.

Parameters:

   rlhOld   Supplies the handle of the range list to copy.

   rlhNew   Supplies the handle of a valid range list into which rlhOld
            is copied.  Anything contained in the rlhNew range list is
            removed by the copy operation.

   ulFlags  Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRangeNew = NULL, pRangeOld = NULL;
    BOOL           bLockOld = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
        bLockOld = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld = (PRange_Element)rlhOld;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        Status = CR_SUCCESS;    // reset status flag to okay


        //
        // duplicate each of the old ranges
        //
        pRangeOld = (PRange_Element)pRangeOld->RL_Next;
        CopyRanges(pRangeOld, pRangeNew);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLockOld = bLockOld;    // needed to prevent optimizing this flag away
        bLockNew = bLockNew;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLockOld) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Dup_Range_List



CONFIGRET
CM_Find_Range(
    OUT PDWORDLONG pullStart,
    IN  DWORDLONG  ullStart,
    IN  ULONG      ulLength,
    IN  DWORDLONG  ullAlignment,
    IN  DWORDLONG  ullEnd,
    IN  RANGE_LIST rlh,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This routine attempts to find a range in the supplied range list that
  will accommodate the range requirements specified.  [TBD:  Verify
  that this description is correct.]

Parameters:

   pullStart   Supplies the address of a variable that receives the
               starting value of the allocated range.

   ullStart    Supplies the starting address that the range can have.

   ulLength    Supplies the length needed for the allocated range.

   ullAlignment   Supplies the alignment bitmask that specifies where the
               allocated range can start. [TBD:  verify that this is indeed
               a bitmask]

   ullEnd      Supplies the ending address of the area from which the range
               may be allocated.

   rlh         Supplies a handle to a range list in which the specified
               range is to be found.

   ulFlags     TBD


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_FAILURE

--*/

{
    CONFIGRET         Status = CR_SUCCESS;
    PRange_Element    pRange = NULL;
    DWORDLONG         ullNewEnd;
    BOOL              bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (pullStart == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        //
        // Normalize aligment. Alignments are now like 0x00000FFF.
        //
        ullAlignment =~ ullAlignment;

        //
        // Test for impossible alignments (-1, not a power of 2 or start is
        // less than alignment away from wrapping). Also test for invalid
        // length.
        //
        if ((ullAlignment == DWORD_MAX) |
            (ulLength == 0) |
            ((ullAlignment & (ullAlignment + 1)) != 0) |
            (ullStart + ullAlignment < ullStart)) {

            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Align the base.
        //
        ullStart += ullAlignment;
        ullStart &= ~ullAlignment;

        //
        // Compute the new end.
        //
        ullNewEnd = ullStart + ulLength - 1;

        //
        // Make sure we do have space.
        //
        if ((ullNewEnd < ullStart) || (ullNewEnd > ullEnd)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Check if that range fits
        //
        if (TestRange((PRange_Element)rlh, ullStart, ullStart + ulLength - 1,
                      &pRange) == CR_SUCCESS) {
            //
            // We got it then, on the first try.
            //
            *pullStart = ullStart;
            goto Clean0;
        }

        //
        // Search for a spot where this range will fit.
        //
        for ( ; ; ) {
            //
            // Start at the end of the conflicting range.
            //
            ullStart = pRange->RL_End + 1;

            //
            // Check for wrapping.
            //
            if (!ullStart) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Make sure the alignment adjustment won't wrap.
            //
            if (ullStart + ullAlignment < ullStart) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Adjust the alignment.
            //
            ullStart += ullAlignment;
            ullStart &= ~ullAlignment;

            //
            // Compute the new end.
            //
            ullNewEnd = ullStart + ulLength - 1;

            //
            // Make sure the new end does not wrap and is still valid.
            //
            if ((ullNewEnd < ullStart) | (ullStart + ulLength - 1 > ullEnd))  {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Skip any prls which existed only below our new range
            // (because we moved ulStart upward of them).
            //
            while ((pRange = (PRange_Element)pRange->RL_Next) != NULL &&
                   ullStart > pRange->RL_End) {
            }

            //
            // If we don't have a prl or it's begining is after our end
            //
            if (pRange == NULL || ullNewEnd < pRange->RL_Start) {
                *pullStart = ullStart;
                goto Clean0;
            }

            //
            // Otherwise try with the new prl.
            //
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Find_Range



CONFIGRET
CM_First_Range(
    IN  RANGE_LIST     rlh,
    OUT PDWORDLONG     pullStart,
    OUT PDWORDLONG     pullEnd,
    OUT PRANGE_ELEMENT preElement,
    IN  ULONG          ulFlags
    )

/*++

Routine Description:

   This routine retrieves the first range element in a range list.

Parameters:

   rlh         Supplies the handle of a range list.

   pullStart   Supplies the address of a variable that receives the
               starting value of the first range element.

   pullEnd     Supplies the address of a variable that receives the
               ending value of the first range element.

   preElement  Supplies the address of a variable that receives the
               handle of the next range element.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (pullEnd == NULL  ||  pullStart == NULL  ||  preElement == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pRange = (PRange_Element)rlh;

        //
        // is the range list empty?
        //
        if (pRange->RL_Next == 0) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // skip over the header to the first element
        //
        pRange = (PRange_Element)pRange->RL_Next;

        *pullStart = pRange->RL_Start;
        *pullEnd = pRange->RL_End;
        *preElement = (RANGE_ELEMENT)pRange->RL_Next;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_First_Range



CONFIGRET
CM_Free_Range_List(
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine frees the specified range list and the memory allocated
   for it.

Parameters:

   rlh      Supplies the handle of the range list to be freed.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS, Status1 = CR_SUCCESS;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        while (Status1 == CR_SUCCESS) {
            //
            // keep deleting the first range after the header (pass parent
            // of range to delete)
            //
            Status1 = DeleteRange((PRange_Element)rlh);
        }

        //
        // destroy the private resource lock
        //
        DestroyPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);

        //
        // delete the range header
        //
        ((PRange_List_Hdr)rlh)->RLH_Signature = 0;
        pSetupFree((PRange_Element)rlh);
        bLock = FALSE;


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Free_Range_List




CONFIGRET
CM_Intersect_Range_List(
    IN RANGE_LIST rlhOld1,
    IN RANGE_LIST rlhOld2,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list from the intersection of two specified
   range lists. If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle
   of a valid but empty range list.

Parameters:

   rlhOld1  Supplies the handle of a range list to be used as part of the
            intersection.

   rlhOld2  Supplies the handle of a range list to be used as part of the
            intersection.

   rlhNew   Supplies the handle of the range list that receives the
            intersection of rlhOld1 and rlhOld2.  Anything previously contained
            in the rlhNew ragne list is removed by this operation.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    DWORDLONG      ulStart = 0, ulEnd = 0;
    PRange_Element pRangeNew = NULL, pRangeOld1 = NULL, pRangeOld2 = NULL;
    BOOL           bLock1 = FALSE, bLock2 = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld1)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhOld2)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
        bLock1 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
        bLock2 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld1 = (PRange_Element)rlhOld1;
        pRangeOld2 = (PRange_Element)rlhOld2;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // Special case: if either range is empty then there is no
        // intersection by definition
        //
        if (pRangeOld1->RL_Next == 0  || pRangeOld2->RL_Next == 0) {
            goto Clean0;
        }


        pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
        pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;

        for ( ; ; ) {
            //
            // skip over Old2 ranges until intersects with or exceeds
            // current Old1 range (or no more Old2 ranges left)
            //
            while (pRangeOld2->RL_End < pRangeOld1->RL_Start) {

                if (pRangeOld2->RL_Next == 0) {
                    goto Clean0;      // Old2 exhausted, we're done
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }

            //
            // if this Old2 range exceeds Old1 range, then go to the
            // next Old1 range and go through the main loop again
            //
            if (pRangeOld2->RL_Start > pRangeOld1->RL_End) {

                if (pRangeOld1->RL_Next == 0) {
                    goto Clean0;      // Old1 exhausted, we're done
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
                continue;
            }

            //
            // if we got here there must be an intersection so add
            // the intersected range to New
            //
            ulStart = max(pRangeOld1->RL_Start, pRangeOld2->RL_Start);
            ulEnd   = min(pRangeOld1->RL_End, pRangeOld2->RL_End);

            Status = InsertRange(pRangeNew, ulStart, ulEnd);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
            pRangeNew = (PRange_Element)pRangeNew->RL_Next;

            //
            // after handling the intersection, skip to next ranges in
            // Old1 and Old2 as appropriate
            //
            if (pRangeOld1->RL_End <= ulEnd) {
                if (pRangeOld1->RL_Next == 0) {
                    goto Clean0;         // Old1 exhausted, we're done
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            }

            if (pRangeOld2->RL_End <= ulEnd) {
                if (pRangeOld2->RL_Next == 0) {
                    goto Clean0;         // Old1 exhausted, we're done
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock1 = bLock1;     // needed to prevent optimizing this flag away
        bLock2 = bLock2;     // needed to prevent optimizing this flag away
        bLockNew = bLockNew; // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock1) {
         UnlockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
    }
    if (bLock2) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Intersect_Range_List



CONFIGRET
CM_Invert_Range_List(
    IN RANGE_LIST rlhOld,
    IN RANGE_LIST rlhNew,
    IN DWORDLONG  ullMaxValue,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list that is the inverse of a specified
   range list; all claimed ranges in the new list are specified as free
   in the old list, and vice-versa. For example, the inversion of
   {[2,4],[6,8]} when the ulMaxValue parameter is 15 is {[0,1],[5,5],[9,15]}.
   If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle of a valid
   but empty range list.


Parameters:

   rlhOld      Supplies the handle of a range list to be inverted.

   rlhNew      Supplies the handle of the range list that receives the
               inverted copy of rlhOld.  Anything previously contained in
               the rlhNew range list is removed by this operation.

   ullMaxValue Uppermost value of the inverted range list.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST,
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRangeNew = NULL, pRangeOld = NULL;
    DWORDLONG      ullStart = 0, ullEnd = 0;
    BOOL           bLockOld = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
        bLockOld = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld = (PRange_Element)rlhOld;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // special case: if the old range is empty, then the new range
        // is the entire range (up to max)
        //
        if (pRangeOld->RL_Next == 0) {
            Status = InsertRange(pRangeNew, 0, ullMaxValue);
            goto Clean0;
        }


        //
        // invert each of the old ranges
        //
        ullStart = ullEnd = 0;

        while (pRangeOld->RL_Next != 0) {

            pRangeOld = (PRange_Element)pRangeOld->RL_Next;

            //
            // Special start case: if range starts at 0, skip over it
            //
            if (pRangeOld->RL_Start != 0) {

                //
                // Special end case: check if we've hit the max for the new range
                //
                if (pRangeOld->RL_End >= ullMaxValue) {

                    ullEnd = min(ullMaxValue, pRangeOld->RL_Start - 1);
                    Status = InsertRange(pRangeNew, ullStart, ullEnd);
                    goto Clean0;      // we're done
                }

                Status = InsertRange(pRangeNew, ullStart, pRangeOld->RL_Start - 1);
                if (Status != CR_SUCCESS) {
                    goto Clean0;
                }

                pRangeNew = (PRange_Element)pRangeNew->RL_Next;
            }

            ullStart = pRangeOld->RL_End + 1;
        }

        //
        // add the range that incorporates the end of the old range up to
        // the max value specified
        //
        if (ullStart <= ullMaxValue) {
            Status = InsertRange(pRangeNew, ullStart, ullMaxValue);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLockOld = bLockOld;    // needed to prevent optimizing this flag away
        bLockNew = bLockNew;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLockOld) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Invert_Range_List



CONFIGRET
CM_Merge_Range_List(
    IN RANGE_LIST rlhOld1,
    IN RANGE_LIST rlhOld2,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list from the union of two specified range
   lists. If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle of a
   valid but empty range list.

Parameters:

   rlhOld1  Supplies the handle of a range list to be used as part of the
            union.

   rlhOld2  Supplies the handle of a range list to be used as part of the
            union.

   rlhNew   Supplies the handle of the range list that receives the union
            of rlhOld1 and rlhOld2.  Anything previously contained in the
            rlhNew range list is removed by this operation.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    DWORDLONG      ullStart = 0, ullEnd = 0;
    BOOL           bOld1Empty = FALSE, bOld2Empty = FALSE;
    PRange_Element pRangeNew = NULL, pRangeOld1 = NULL, pRangeOld2 = NULL;
    BOOL           bLock1 = FALSE, bLock2 = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld1)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhOld2)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
        bLock1 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
        bLock2 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld1 = (PRange_Element)rlhOld1;
        pRangeOld2 = (PRange_Element)rlhOld2;

        //
        // If the new range list is not empty, then clear it
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // Special case: if both ranges are empty then there is no
        // union by definition
        //
        if (pRangeOld1->RL_Next == 0  &&  pRangeOld2->RL_Next == 0) {
            goto Clean0;
        }

        //
        // Special case: if one range is empty, then the union is just the other
        //
        if (pRangeOld1->RL_Next == 0) {
            pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            CopyRanges(pRangeOld2, pRangeNew);     // from -> to
            goto Clean0;
        }

        if (pRangeOld2->RL_Next == 0) {
            pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            CopyRanges(pRangeOld1, pRangeNew);     // from -> to
            goto Clean0;
        }


        pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
        pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;


        for ( ; ; ) {
            //
            // Pick whichever range comes first between current Old1 range
            // and current Old2 range
            //
            if (pRangeOld1->RL_Start <= pRangeOld2->RL_Start) {

                ullStart = pRangeOld1->RL_Start;
                ullEnd   = pRangeOld1->RL_End;

                if (pRangeOld1->RL_Next == 0) {
                    bOld1Empty = TRUE;
                } else {
                    pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
                }

            } else {

                ullStart = pRangeOld2->RL_Start;
                ullEnd   = pRangeOld2->RL_End;

                if (pRangeOld2->RL_Next == 0) {
                    bOld2Empty = TRUE;
                } else {
                    pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
                }
            }

            //
            // gather any ranges in Old1 that intersect (ullStart,ullEnd)
            //
            while (pRangeOld1->RL_Start <= ullEnd) {

                ullEnd = max(ullEnd, pRangeOld1->RL_End);

                if (pRangeOld1->RL_Next == 0) {
                    bOld1Empty = TRUE;
                    break;
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            }

            //
            // gather any ranges in Old2 that intersect (ullStart,ullEnd)
            //
            while (pRangeOld2->RL_Start <= ullEnd) {

                ullEnd = max(ullEnd, pRangeOld2->RL_End);

                if (pRangeOld2->RL_Next == 0) {
                    bOld2Empty = TRUE;
                    break;
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }

            //
            // add (ullStart,ullEnd) to the new range
            //
            Status = InsertRange(pRangeNew, ullStart, ullEnd);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
            pRangeNew = (PRange_Element)pRangeNew->RL_Next;

            //
            // As an optimization, if either range is exhausted first,
            // then only need to duplicate the other remaining ranges.
            //
            if (bOld1Empty && bOld2Empty) {
                goto Clean0;   // both exhausted during last pass, we're done
            }

            if (bOld1Empty) {    // Old1 exhausted, copy remaining from Old2
                CopyRanges(pRangeOld2, pRangeNew);
                goto Clean0;
            }

            if (bOld2Empty) {    // Old2 exhausted, copy remaining from Old1
                CopyRanges(pRangeOld1, pRangeNew);
                goto Clean0;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock1 = bLock1;     // needed to prevent optimizing this flag away
        bLock2 = bLock2;     // needed to prevent optimizing this flag away
        bLockNew = bLockNew; // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock1) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
    }
    if (bLock2) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Merge_Range_List



CONFIGRET
CM_Next_Range(
    IN OUT PRANGE_ELEMENT preElement,
    OUT PDWORDLONG        pullStart,
    OUT PDWORDLONG        pullEnd,
    IN  ULONG             ulFlags
    )

/*++

Routine Description:

    This routine returns the next range element in a range list. This
    API returns CR_FAILURE if there are no more elements in the range
    list.

Parameters:

   preElement  Supplies the address of the handle for the current range
               element.  Upon return, this variable receives the handle
               of the next range element.

   pullStart   Supplies the address of the variable that receives the
               starting value of the next range.

   pullEnd     Supplies the address of the variable that receives the
               ending value of the next range.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_INVALID_RANGE.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;
    PRange_List_Hdr prlh = NULL;


    try {
        //
        // validate parameters
        //
        if (preElement == NULL  ||  *preElement == 0) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (pullEnd == NULL  ||  pullStart == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        prlh = (PRange_List_Hdr)((PRange_Element)(*preElement))->RL_Header;
        LockPrivateResource(&(prlh->RLH_Lock));
        bLock = TRUE;

        pRange = (PRange_Element)(*preElement);

        *pullStart = pRange->RL_Start;
        *pullEnd = pRange->RL_End;
        *preElement = (RANGE_ELEMENT)pRange->RL_Next;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&(prlh->RLH_Lock));
    }

    return Status;

} // CM_Next_Range



CONFIGRET
CM_Test_Range_Available(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine checks a range against a range list to ensure that no
   conflicts exist.

Parameters:

   ullStartValue  Supplies the low end of the range.

   ullEndValue    Supplies the high end of the range.

   rlh            Supplies the handle to a range list.

   ulFlags        Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE, or
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullEndValue < ullStartValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pRange = (PRange_Element)rlh;

        //
        // check each range for a conflict
        //
        while (pRange->RL_Next != 0) {

            pRange = (PRange_Element)pRange->RL_Next;

            //
            // If I've already passed the test range, then it's available
            //
            if (ullEndValue < pRange->RL_Start) {
                goto Clean0;
            }

            //
            // check if the start of the test range intersects the current range
            //
            if (ullStartValue >= pRange->RL_Start &&
                ullStartValue <= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // check if the end of the test range intersects the current range
            //
            if (ullEndValue >= pRange->RL_Start &&
               ullEndValue <= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // check if it's a complete overlap
            //
            if (ullStartValue <= pRange->RL_Start &&
               ullEndValue >= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //
        // if we got this far, then we made it through the range list
        // without hitting a conflict
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Test_Range_Available




//------------------------------------------------------------------------
// Private Utility Functions
//------------------------------------------------------------------------


BOOL
IsValidRangeList(
    IN RANGE_LIST rlh
    )
{
    BOOL             Status = TRUE;
    PRange_List_Hdr  pRangeHdr = NULL;

    try {

        if ((rlh == 0)  || (rlh == ((DWORD)-1))) {
            Status = FALSE;
            goto Clean0;
        }

        pRangeHdr = (PRange_List_Hdr)rlh;

        if (pRangeHdr->RLH_Signature != Range_List_Signature) {
            Status = FALSE;
            goto Clean0;
        }

      Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // IsValidRangeList




CONFIGRET
AddRange(
    IN PRange_Element   prlh,
    IN DWORDLONG        ullStartValue,
    IN DWORDLONG        ullEndValue,
    IN ULONG            ulFlags
    )
{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pPrevious = NULL, pCurrent = NULL;


    try {

        pPrevious = prlh;

        if (pPrevious->RL_Next == 0) {
            //
            // the range is empty
            //
            Status = InsertRange(pPrevious, ullStartValue, ullEndValue);
            goto Clean0;
        }


        while (pPrevious->RL_Next != 0) {

            pCurrent = (PRange_Element)pPrevious->RL_Next;


            if (ullStartValue < pCurrent->RL_Start) {

                if (ullEndValue < pCurrent->RL_Start) {
                    //
                    // new range completely contained before this one,
                    // add new range between previous and current range
                    //
                    Status = InsertRange(pPrevious, ullStartValue, ullEndValue);
                    goto Clean0;
                }

                if (ullEndValue <= pCurrent->RL_End) {
                    //
                    // new range intersects current range, on the low side,
                    // enlarge this range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_Start = ullStartValue;
                    goto Clean0;
                }

                if ((pCurrent->RL_Next == 0)  ||
                    (ullEndValue < ((PRange_Element)(pCurrent->RL_Next))->RL_Start)) {
                    //
                    // new range intersects current range on high and low
                    // side, extent range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_Start = ullStartValue;
                    pCurrent->RL_End = ullEndValue;
                    goto Clean0;
                }

                //
                // new range intersects more than one range, needs to be
                // merged
                //
                if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                Status = JoinRange(pPrevious, ullStartValue, ullEndValue);
                goto Clean0;
            }


            if (ullStartValue <= pCurrent->RL_End+1) {

                if (ullEndValue <= pCurrent->RL_End) {
                    //
                    // new range is completely contained inside the current
                    // range so nothing to do
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    goto Clean0;
                }

                if ((pCurrent->RL_Next == 0)  ||
                    (ullEndValue < ((PRange_Element)(pCurrent->RL_Next))->RL_Start)) {
                    //
                    // new range intersects current range on high end only,
                    // extend range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_End = ullEndValue;
                    goto Clean0;
                }

                //
                // new range intersects more than one range, needs to be
                // merged
                //
                if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                Status = JoinRange(pPrevious, ullStartValue, ullEndValue);
                goto Clean0;
            }

            //
            // step to the next range
            //
            pPrevious = pCurrent;
            pCurrent = (PRange_Element)pCurrent->RL_Next;
        }

        //
        // if we got here then we need to just insert this range to the end
        // of the range list
        //
        Status = InsertRange(pPrevious, ullStartValue, ullEndValue);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = 0;
    }

    return Status;

} // AddRange



CONFIGRET
InsertRange(
    IN PRange_Element pParentElement,
    IN DWORDLONG      ullStartValue,
    IN DWORDLONG      ullEndValue)
{
    PRange_Element  pNewElement = NULL;


    pNewElement = (PRange_Element)pSetupMalloc(sizeof(Range_Element));

    if (pNewElement == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    pNewElement->RL_Next   = pParentElement->RL_Next;   // rejoin the link
    pNewElement->RL_Start  = ullStartValue;
    pNewElement->RL_End    = ullEndValue;
    pNewElement->RL_Header = pParentElement->RL_Header;
    pParentElement->RL_Next = (ULONG_PTR)pNewElement;

    return CR_SUCCESS;

} // InsertRange



CONFIGRET
DeleteRange(
    IN PRange_Element  pParentElement
    )
{
    PRange_Element pTemp = NULL;

    //
    // must pass a valid parent of the range to delete (in otherwords,
    // can't pass the last range)
    //

    if (pParentElement == 0) {
        return CR_FAILURE;
    }

    pTemp = (PRange_Element)(pParentElement->RL_Next);
    if (pTemp == 0) {
        return CR_FAILURE;
    }

    pParentElement->RL_Next =
                ((PRange_Element)(pParentElement->RL_Next))->RL_Next;

    pSetupFree(pTemp);

    return CR_SUCCESS;

} // DeleteRange



CONFIGRET
JoinRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    )
{
    CONFIGRET       Status = CR_SUCCESS;
    PRange_Element  pCurrent = NULL, pNext = NULL;


    if (pParentElement->RL_Next == 0) {
        return CR_SUCCESS;      // at the end, nothing to join
    }

    //
    // pCurrent is the starting range of intersecting ranges that need
    // to be joined
    //
    pCurrent = (PRange_Element)pParentElement->RL_Next;

    //
    // set start of joined range
    //
    if (ullStartValue < pCurrent->RL_Start) {
        pCurrent->RL_Start = ullStartValue;
    }

    //
    // find the end of the joined range
    //
    while (pCurrent->RL_Next != 0) {
        pNext = (PRange_Element)pCurrent->RL_Next;

        //
        // I know this next range needs to be absorbed in all cases so
        // reset the end point to at least include the next range
        //
        pCurrent->RL_End = pNext->RL_End;

        if (ullEndValue <= pNext->RL_End) {
            DeleteRange(pCurrent);     // delete the range following current
            break;   // we're done
        }

        if ((pNext->RL_Next == 0)  ||
            (ullEndValue < ((PRange_Element)(pNext->RL_Next))->RL_Start)) {
            //
            // adjust the end point of the newly joined range and then we're done
            //
            pCurrent->RL_End = ullEndValue;
            DeleteRange(pCurrent);     // delete the range following current
            break;
        }

        DeleteRange(pCurrent);     // delete the range following current

        // if we got here, there are more ranges to join
    }

    return Status;

} // JoinRange



CONFIGRET
CopyRanges(
    IN PRange_Element  pFromRange,
    IN PRange_Element  pToRange
    )
{
    CONFIGRET       Status = CR_SUCCESS;

    //
    // copy each range in pFromRange to pToRange
    //
    for ( ; ; ) {

        Status = AddRange(pToRange,
                          pFromRange->RL_Start,
                          pFromRange->RL_End,
                          CM_ADD_RANGE_ADDIFCONFLICT);

        if (Status != CR_SUCCESS) {
            break;
        }

        pToRange = (PRange_Element)pToRange->RL_Next;

        if (pFromRange->RL_Next == 0) {
            break;
        }

        pFromRange = (PRange_Element)pFromRange->RL_Next;
    }

    return Status;

} // CopyRanges



CONFIGRET
ClearRanges(
    IN PRange_Element  pRange
    )
{
    CONFIGRET       Status = CR_SUCCESS;

    //
    // If the range list is not empty, then delete ranges
    //
    if (pRange->RL_Next != 0) {

        while (Status == CR_SUCCESS) {
            //
            // keep deleting the first range after the header (pass parent
            // of range to delete)
            //
            Status = DeleteRange(pRange);
        }
    }

    return CR_SUCCESS;  // Status is set to end deleting ranges, don't return it

} // ClearRanges



CONFIGRET
TestRange(
    IN  PRange_Element   rlh,
    IN  DWORDLONG        ullStartValue,
    IN  DWORDLONG        ullEndValue,
    OUT PRange_Element   *pConflictingRange
    )

{
    PRange_Element    pRange = (PRange_Element)rlh;

    //
    // check each range for a conflict
    //
    while (pRange->RL_Next != 0) {

        pRange = (PRange_Element)pRange->RL_Next;

        if (pRange->RL_Start > ullEndValue) {
            //
            // We've gone past the range in question so no conflict
            //
            return CR_SUCCESS;
        }

        if (pRange->RL_End < ullStartValue) {
            //
            // this range is still below the range in question, skip to next range
            //
            continue;
        }

        //
        // otherwise there's a conflict
        //
        *pConflictingRange = pRange;
        return CR_FAILURE;
    }

    return CR_SUCCESS;

} // TestRange
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\misc.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    misc.c

Abstract:

    This module contains miscellaneous Configuration Manager API routines.

               CM_Get_Version
               CM_Is_Version_Available
               CM_Connect_Machine
               CM_Disconnect_Machine
               CM_Get_Global_State
               CM_Run_Detection
               CM_Query_Arbitrator_Free_Data
               CM_Query_Resource_Conflicts
               CM_Query_Arbitrator_Free_Size

               CMP_Report_LogOn
               CMP_Init_Detection
               CMP_WaitServicesAvailable
               CMP_WaitNoPendingInstallEvents
               CMP_GetBlockedDriverInfo

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    20-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"
#include "pnpipc.h"


//
// global data
//
extern PVOID    hLocalStringTable;                  // NOT MODIFIED BY THESE PROCEDURES
extern WCHAR    LocalMachineNameNetBIOS[];          // NOT MODIFIED BY THESE PROCEDURES
extern WCHAR    LocalMachineNameDnsFullyQualified[];// NOT MODIFIED BY THESE PROCEDURES

#define NUM_LOGON_RETRIES   30


//
// Private prototypes
//

CONFIGRET
IsRemoteServiceRunning(
    IN  LPCWSTR   UNCServerName,
    IN  LPCWSTR   ServiceName
    );



WORD
CM_Get_Version_Ex(
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine retrieves the version number of the Configuration Manager APIs.

Arguments:

   hMachine - Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   The function returns the major revision number in the high byte and the
   minor revision number in the low byte.  For example, version 4.0 of
   Configuration Manager returns 0x0400.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WORD        wVersion = (WORD)CFGMGR32_VERSION;
    handle_t    hBinding = NULL;

    //
    // setup rpc binding handle
    //
    if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return wVersion = 0;
    }

    //
    // No special privileges are required by the server
    //

    RpcTryExcept {
        //
        // call rpc service entry point
        //
        Status = PNP_GetVersion(
                hBinding,               // rpc machine name
                &wVersion);             // server side version
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "PNP_GetVersion caused an exception (%d)\n",
                   RpcExceptionCode()));

        SetLastError(RpcExceptionCode());
        wVersion = 0;
    }
    RpcEndExcept

    return wVersion;

} // CM_Get_Version_Ex



BOOL
CM_Is_Version_Available_Ex(
    IN  WORD       wVersion,
    IN  HMACHINE   hMachine
    )
/*++

Routine Description:

   This routine returns whether a specific version of the Configuration Manager
   APIs are available.

Arguments:

   wVersion - Version to query.

   hMachine - Machine to connect to.

Return value:

   The function returns TRUE if the version of the Configuration Manager APIs is
   equal to or greater than the specified version.

--*/
{
    handle_t    hBinding = NULL;
    WORD        wVersionInternal;

    //
    // version 0x0400 is available on all servers, by definition.
    //
    if (wVersion <= (WORD)0x0400) {
        return TRUE;
    }

    //
    // setup rpc binding handle
    //
    if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
        return FALSE;
    }

    //
    // retrieve the internal server version.
    //
    if (!PnPGetVersion(hMachine, &wVersionInternal)) {
        return FALSE;
    }

    //
    // versions up to and including the internal server version are available.
    //
    return (wVersion <= wVersionInternal);

} // CM_Is_Version_Available_Ex



CONFIGRET
CM_Connect_MachineW(
    IN  PCWSTR    UNCServerName,
    OUT PHMACHINE phMachine
    )

/*++

Routine Description:

   This routine connects to the machine specified and returns a handle that
   is then passed to future calls to the Ex versions of the CM routines.
   This allows callers to get device information on remote machines.

Arguments:

   UNCServerName - Specifies the UNC name of the remote machine to connect to.

   phMachine     - Specifies the address of a variable to receive a handle to
                   the connected machine.

Return value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns one
   of the CR_* error codes.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    WORD           wVersion = 0, wVersionInternal;
    PPNP_MACHINE   pMachine = NULL;
    size_t         UNCServerNameLen;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(phMachine)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phMachine = NULL;

        //
        // if machine name specified, check for UNC format
        //
        if ((ARGUMENT_PRESENT(UNCServerName)) &&
            (UNCServerName[0] != L'\0')) {

            //
            // Check that the length in not any longer than the longest possible
            // name we can possibly save, including the NULL terminating
            // character.
            //
            if (FAILED(StringCchLength(
                           UNCServerName,
                           MAX_PATH + 3,
                           &UNCServerNameLen))) {
                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }

            ASSERT(UNCServerNameLen < (MAX_PATH + 3));

            //
            // Check that the machine name is a UNC name.
            //
            if ((UNCServerNameLen < 3) ||
                (UNCServerName[0] != L'\\') ||
                (UNCServerName[1] != L'\\')) {
                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }
        }

        //
        // allocate memory for the machine structure and initialize it
        //
        pMachine = (PPNP_MACHINE)pSetupMalloc(sizeof(PNP_MACHINE));

        if(!pMachine) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }


        if ((!ARGUMENT_PRESENT(UNCServerName))  ||
            (UNCServerName[0] == L'\0') ||
            (!lstrcmpi(UNCServerName, LocalMachineNameNetBIOS)) ||
            (!lstrcmpi(UNCServerName, LocalMachineNameDnsFullyQualified))) {

            //----------------------------------------------------------
            // If no machine name was passed in or the machine name
            // matches the local name, use local machine info rather
            // than creating a new binding.
            //----------------------------------------------------------

            PnPGetGlobalHandles(NULL,
                                &pMachine->hStringTable,
                                &pMachine->hBindingHandle);

            if (!ARGUMENT_PRESENT(UNCServerName)) {

                if (FAILED(StringCchCopy(
                               pMachine->szMachineName,
                               SIZECHARS(pMachine->szMachineName),
                               LocalMachineNameNetBIOS))) {
                    Status = CR_INVALID_MACHINENAME;
                    goto Clean0;
                }

            } else {

                if (FAILED(StringCchCopy(
                               pMachine->szMachineName,
                               SIZECHARS(pMachine->szMachineName),
                               UNCServerName))) {
                    Status = CR_INVALID_MACHINENAME;
                    goto Clean0;
                }
            }

        } else {

            //
            // First, make sure that the RemoteRegistry service is running on
            // the remote machine, since RemoteRegistry is required for several
            // cfgmgr32/setupapi services.
            //
            Status = IsRemoteServiceRunning(UNCServerName,
                                            L"RemoteRegistry");
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            //-------------------------------------------------------------
            // A remote machine name was specified so explicitly force a
            // new binding for this machine.
            //-------------------------------------------------------------

            pMachine->hBindingHandle =
                      (PVOID)PNP_HANDLE_bind((PNP_HANDLE)UNCServerName);

            if (pMachine->hBindingHandle == NULL) {

                if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                    Status = CR_OUT_OF_MEMORY;
                } else if (GetLastError() == ERROR_INVALID_COMPUTERNAME) {
                    Status = CR_INVALID_MACHINENAME;
                } else {
                    Status = CR_FAILURE;
                }
                goto Clean0;
            }

            //
            // initialize a string table for use with this connection to
            // the remote machine
            //
            pMachine->hStringTable = pSetupStringTableInitialize();

            if (pMachine->hStringTable == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Add a priming string (see dll entrypt in main.c for details)
            //
            pSetupStringTableAddString(pMachine->hStringTable,
                                 PRIMING_STRING,
                                 STRTAB_CASE_SENSITIVE);

            //
            // save the machine name
            //
            if (FAILED(StringCchCopy(
                           pMachine->szMachineName,
                           SIZECHARS(pMachine->szMachineName),
                           UNCServerName))) {
                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }
        }

        //
        // test the binding by calling the simplest RPC call (good way
        // for the caller to know whether the service is actually
        // running)
        //

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetVersion(
                pMachine->hBindingHandle,
                &wVersion);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetVersion caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // we got the standard version alright, now try to determine the
            // internal version of the server.  initialize the version supplied
            // to the internal version of the client.
            //
            wVersionInternal = (WORD)CFGMGR32_VERSION_INTERNAL;

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetVersionInternal(
                    pMachine->hBindingHandle,
                    &wVersionInternal);
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                //
                // rpc exception may occur if the interface does not exist on
                // the server, indicating a server version prior to NT 5.1.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "PNP_GetVersionInternal caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if (Status == CR_SUCCESS) {
                //
                // PNP_GetVersionInternal exists on NT 5.1 and later.
                //
                ASSERT(wVersionInternal >= (WORD)0x0501);

                //
                // use the real internal version of the server instead of the
                // static version returned by PNP_GetVersion.
                //
                wVersion = wVersionInternal;
            }

            //
            // no matter what happened while trying to retrieve the internal
            // version of the server, we were successful before this.
            //
            Status = CR_SUCCESS;
        }

        if (Status == CR_SUCCESS) {
            pMachine->ulSignature = (ULONG)MACHINE_HANDLE_SIGNATURE;
            pMachine->wVersion = wVersion;
            *phMachine = (HMACHINE)pMachine;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pMachine = pMachine;
    }

    if ((Status != CR_SUCCESS)  &&  (pMachine != NULL)) {
        pSetupFree(pMachine);
    }

    return Status;

} // CM_Connect_MachineW




CONFIGRET
CM_Disconnect_Machine(
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine disconnects from a machine that was previously connected to
   with the CM_Connect_Machine call.

Arguments:

   hMachine - Specifies a machine handle previously returned by a call to
              CM_Connect_Machine.

Return value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns one
   of the CR_* error codes.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PPNP_MACHINE   pMachine = NULL;

    try {
        //
        // validate parameters
        //
        if (hMachine == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        pMachine = (PPNP_MACHINE)hMachine;

        if (pMachine->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // only free the machine info if it's not the local machine
        //
        if (pMachine->hStringTable != hLocalStringTable) {
            //
            // free the rpc binding for this remote machine
            //
            PNP_HANDLE_unbind((PNP_HANDLE)pMachine->szMachineName,
                              (handle_t)pMachine->hBindingHandle);

            //
            // release the string table
            //
            pSetupStringTableDestroy(pMachine->hStringTable);
        }

        //
        // invalidate the signature so we never try to free it again.
        //
        pMachine->ulSignature = 0;

        //
        // free the memory for the PNP_MACHINE struct
        //
        pSetupFree(pMachine);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Disconnect_Machine



CONFIGRET
CM_Get_Global_State_Ex(
    OUT PULONG   pulState,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the global state of the configuration manager.

Parameters:

   pulState Supplies the address of the variable that receives the
            Configuration Managers state.  May be a combination of the
            following values:

            Configuration Manager Global State Flags:
            CM_GLOBAL_STATE_CAN_DO_UI
                  Can UI be initiated? [TBD:  On NT, this may relate to
                  whether anyone is logged in]
            CM_GLOBAL_STATE_SERVICES_AVAILABLE
                  Are the CM APIs available? (on Windows NT this is always set)
            CM_GLOBAL_STATE_SHUTTING_DOWN
                  The Configuration Manager is shutting down.
                  [TBD:  Does this only happen at shutdown/restart time?]
            CM_GLOBAL_STATE_DETECTION_PENDING
                  The Configuration Manager is about to initiate some
                  sort of detection.

            Windows 95 also defines the following additional flag:
            CM_GLOBAL_STATE_ON_BIG_STACK
                  [TBD: What should this be defaulted to for NT?]

   ulFlags  Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulState)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetGlobalState(
                hBinding,                  // rpc binding handle
                pulState,                  // returns global state
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetGlobalState caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Global_State_Ex



CONFIGRET
CM_Run_Detection_Ex(
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

   Routine Description:

      This routine loads and executes a detection module.

   Parameters:

      ulFlags - Specifies the reason for the detection. Can be one of the
                following values:

                Detection Flags:
                CM_DETECT_NEW_PROFILE  - Run detection for a new hardware
                                         profile.
                CM_DETECT_CRASHED      - Previously attempted detection crashed.

                (Windows 95 defines the following two unused flags as well:
                CM_DETECT_HWPROF_FIRST_BOOT and CM_DETECT_RUN.)

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is CR_INVALID_FLAG.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    HANDLE      hToken;
    ULONG       ulPrivilege;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DETECT_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RunDetection(
                hBinding,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RunDetection caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Run_Detection_Ex



CONFIGRET
CM_Query_Arbitrator_Free_Data_Ex(
    OUT PVOID      pData,
    IN  ULONG      DataLen,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

   Routine Description:

      This routine returns information about available resources of a
      particular type. If the given size is not large enough, this API
      truncates the data and returns CR_BUFFER_SMALL.  To determine the
      buffer size needed to receive all the available resource information,
      use the CM_Query_Arbitrator_Free_Size API.

   Parameters:

      pData       Supplies the address of the buffer that receives information
                  on the available resources for the resource type specified
                  by ResourceID.

      DataLen     Supplies the size, in bytes, of the data buffer.

      dnDevNode   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root device
                  instance or NULL.  On Windows NT, this parameter must
                  specify either the Root device instance or NULL.

      ResourceID  Supplies the type of the resource. Can be one of the ResType
                  values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ulFlags     Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_BUFFER_SMALL,
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pData)) || (DataLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeData(
                hBinding,
                pData,
                DataLen,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Arbitrator_Free_Data_Ex


#if 0

CONFIGRET
WINAPI
CM_Query_Resource_Conflicts_Ex(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN OUT PVOID   pData,
    IN OUT PULONG  pulDataLen,
    IN  ULONG      ulFlags
    )

/*++

   Routine Description:

      This routine returns a list of devnodes that own resources that would
      conflict with the specified resource. If there are no conflicts, the
      returned list is NULL. If the caller supplied buffer is not large enough,
      CR_BUFFER_SMALL is returned and pulDataLen contains the required buffer
      size.

   Parameters:

      dnDevInst   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root device
                  instance or NULL.  On Windows NT, this parameter must
                  specify either the Root device instance or NULL.  ???

      ResourceID  Supplies the type of the resource. Can be one of the ResType
                  values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ResourceData Supplies the adress of an IO_DES, MEM_DES, DMA_DES, IRQ_DES,
                  etc, structure, depending on the given resource type.

      ResourceLen Supplies the size, in bytes, of the structure pointed to
                  by ResourceData.

      pData       Supplies the address of the buffer that receives information
                  on the available resources for the resource type specified
                  by ResourceID.

      pulDataLen  Supplies the size, in bytes, of the data buffer.

      ulFlags     Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_BUFFER_SMALL,
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pData)) ||
            (!ARGUMENT_PRESENT(pulDataLen)) ||
            (*pulDataLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeData(
                hBinding,
                pData,
                DataLen,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Resource_Conflicts_Ex
#endif



CONFIGRET
CM_Query_Arbitrator_Free_Size_Ex(
      OUT PULONG     pulSize,
      IN  DEVINST    dnDevInst,
      IN  RESOURCEID ResourceID,
      IN  ULONG      ulFlags,
      IN  HMACHINE   hMachine
      )
/*++

   Routine Description:


      This routine retrieves the size of the available resource information
      that would be returned in a call to the CM_Query_Arbitrator_Free_Data
      API.

   Parameters:

      pulSize     Supplies the address of the variable that receives the size,
                  in bytes, that is required to hold the available resource
                  information.

      dnDevNode   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root
                  device instance or NULL.  On Windows NT, this parameter
                  must specify either the Root device instance or NULL.

      ResourceID  Supplies the type of the resource.  Can be one of the
                  ResType values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ulFlags     CM_QUERY_ARBITRATOR_BITS.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulSize)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeSize(
                hBinding,
                pulSize,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Arbitrator_Free_Size_Ex



//-------------------------------------------------------------------
// Private CM routines
//-------------------------------------------------------------------


CONFIGRET
CMP_Report_LogOn(
    IN ULONG    ulPrivateID,
    IN DWORD    ProcessID
    )

/*++

Routine Description:

    This is a private routine to notify the PlugPlay service that an interactive
    user has logged in.  It is currently only called by userinit.exe.

Parameters:

    ulPrivateID -

        Specifies the value of the private id.

    ProcessID -

        Specifies the process id of the calling process.  Currently, this
        routine is only called by userinit.exe.

Return Value:

    If the function succeeds, the return value is CR_SUCCESS.
    If the function fails, the return value is one of the following:
        CR_FAILURE,
        CR_INVALID_DATA

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    DWORD       Retries = 0;

    UNREFERENCED_PARAMETER(ProcessID);

    try {

        //
        // validate parameters
        //
        if (ulPrivateID != 0x07020420) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        for (Retries = 0; Retries < NUM_LOGON_RETRIES; Retries++) {

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_ReportLogOn(
                    hBinding,                  // rpc binding handle
                    FALSE,                     // Is Admin? (not used by server)
                    GetCurrentProcessId());    // calling process id
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_ReportLogOn caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if ((Status == CR_NO_CM_SERVICES) ||
                (Status == CR_REMOTE_COMM_FAILURE)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PlugPlay services not available (%d), retrying...\n",
                           Status));

                //
                // This is some error related to the service not being
                // available, wait and try again.
                //
                Sleep(5000);
                continue;

            } else {
                //
                // Some other error, the service may never be available so bail
                // out now.
                //
                break;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_Report_LogOn



CONFIGRET
CMP_Init_Detection(
    IN ULONG    ulPrivateID
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    HANDLE      hToken;
    ULONG       ulPrivilege;

    try {
        //
        // validate parameters
        //
        if (ulPrivateID != 0x07020420) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Enable privileges required by the server
        //
        ulPrivilege = SE_LOAD_DRIVER_PRIVILEGE;
        hToken = PnPEnablePrivileges(&ulPrivilege, 1);

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_InitDetection(
                hBinding);                 // rpc binding handle
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_InitDetection caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //
        // Restore previous privileges
        //
        PnPRestorePrivileges(hToken);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_Init_Detection



CONFIGRET
CMP_WaitServicesAvailable(
    IN  HMACHINE   hMachine
    )

/*++

   Routine Description:

        This routine determines whether the user-mode pnp manager server side
        (umpnpmgr) is up and running yet (providing the PNP_Xxx side of the
        config manager apis).

   Parameters:

       hMachine - private (opaque) cm machine handle. If NULL, the call refers
            to the local machine.

   Return Value:

      If the service is avialable upon return then CR_SUCCESS is returned.
      If some other failure occurs, CR_FAILURE is returned.

--*/
{
    CONFIGRET   Status = CR_NO_CM_SERVICES;
    handle_t    hBinding = NULL;
    WORD        wVersion;

    try {

        //
        // setup rpc binding handle (don't need string table handle)
        //

        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        while ((Status == CR_NO_CM_SERVICES) ||
               (Status == CR_MACHINE_UNAVAILABLE) ||
               (Status == CR_REMOTE_COMM_FAILURE)) {

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetVersion(
                    hBinding,       // rpc machine name
                    &wVersion);     // server size version
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "PNP_GetVersion caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if (Status == CR_SUCCESS) {

                //
                // Service is avilable now, return success.
                //

                goto Clean0;
            }

            if ((Status == CR_NO_CM_SERVICES) ||
                (Status == CR_MACHINE_UNAVAILABLE) ||
                (Status == CR_REMOTE_COMM_FAILURE)) {

                //
                // This is some error related to the service not being
                // available, wait and try again.
                //

                Sleep(5000);

            } else {

                //
                // Some other error, the service may never be avaiable
                // so bail out now.
                //

                Status = CR_FAILURE;
                goto Clean0;
            }

        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_WaitServicesAvailable



DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    )

/*++

   Routine Description:

        This routine waits until there are no pending device install events.
        If a timeout value is specified then it will return either when no
        install events are pending or when the timeout period has expired,
        whichever comes first. This routine is intended to be called after
        user-logon, only.

        NOTE: New install events can occur at anytime, this routine just
        indicates that there are no install events at this moment.

   Parameters:

       dwTimeout - Specifies the time-out interval, in milliseconds. The function
            returns if the interval elapses, even if there are still pending
            install events. If dwTimeout is zero, the function just tests whether
            there are pending install events and returns immediately. If
            dwTimeout is INFINITE, the function's time-out interval never elapses.

   Return Value:

      If the function succeeds, the return value indicates the event that caused
      the function to return. If the function fails, the return value is
      WAIT_FAILED. To get extended error information, call GetLastError.
      The return value on success is one of the following values:

        WAIT_ABANDONED  The specified object is a mutex object that was not
                        released by the thread that owned the mutex object before
                        the owning thread terminated. Ownership of the mutex
                        object is granted to the calling thread, and the mutex is
                        set to nonsignaled.
        WAIT_OBJECT_0   The state of the specified object is signaled.
        WAIT_TIMEOUT    The time-out interval elapsed, and the object's state is
                        nonsignaled.

--*/
{
    DWORD Status = WAIT_FAILED;
    HANDLE hEvent = NULL;

    try {

        hEvent = OpenEvent(SYNCHRONIZE, FALSE, PNP_NO_INSTALL_EVENTS);

        if (hEvent == NULL) {
            Status = WAIT_FAILED;
        } else {
            Status = WaitForSingleObject(hEvent, dwTimeout);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = WAIT_FAILED;
    }

    if (hEvent) {
        CloseHandle(hEvent);
    }

    return Status;

} // CMP_WaitNoPendingInstallEvents



CONFIGRET
CMP_GetBlockedDriverInfo(
    OUT LPBYTE      Buffer,
    IN OUT PULONG   pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine retrieves the list of drivers that have been blocked from
    loading on the system since boot.

Arguments:

    Buffer    - Supplies the address of the buffer that receives the list of
                drivers that have been blocked from loading on the system.  Can
                be NULL when simply retrieving data size.

    pulLength - Supplies the address of the variable that contains the size, in
                bytes, of the buffer.  If the variable is initially zero, the
                API replaces it with the buffer size needed to receive all the
                data.  In this case, the Buffer parameter is ignored.

    ulFlags   - Must be zero.

    hMachine  - Machine handle returned from CM_Connect_Machine or NULL.

Return value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns one of
    the CR_* error codes.

--*/

{
    CONFIGRET   Status;
    ULONG       ulTransferLen;
    BYTE        NullBuffer = 0;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // NOTE: The ulTransferLen variable is just used to control
        // how much data is marshalled via rpc between address spaces.
        // ulTransferLen should be set on entry to the size of the Buffer.
        // The last parameter should also be the size of the Buffer on entry
        // and on exit contains either the amount transferred (if a transfer
        // occured) or the amount required, this value should be passed back
        // in the callers pulLength parameter.
        //
        ulTransferLen = *pulLength;
        if (!ARGUMENT_PRESENT(Buffer)) {
            Buffer = &NullBuffer;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetBlockedDriverInfo(
                hBinding,       // rpc binding handle
                Buffer,         // receives blocked driver info
                &ulTransferLen, // input/output buffer size
                pulLength,      // bytes copied (or bytes required)
                ulFlags);       // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetBlockedDriverInfo caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_GetBlockedDriverInfo



CONFIGRET
CMP_GetServerSideDeviceInstallFlags(
    IN  PULONG      pulSSDIFlags,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine retrieves the server side device install flags.                                

Arguments:

    pulSSDIFlags - Pointer to a ULONG that receives the server side device 
                   install flags.

    ulFlags   - Must be zero.

    hMachine  - Machine handle returned from CM_Connect_Machine or NULL.

Return value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns one of
    the CR_* error codes.

--*/

{
    CONFIGRET   Status;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulSSDIFlags)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetServerSideDeviceInstallFlags(
                hBinding,       // rpc binding handle
                pulSSDIFlags,   // receives server side device install flags
                ulFlags);       // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetServerSideDeviceInstallFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_GetServerSideDeviceInstallFlags



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


WORD
CM_Get_Version(
    VOID
    )
{
    return CM_Get_Version_Ex(NULL);
}


BOOL
CM_Is_Version_Available(
    IN  WORD  wVersion
    )
{
    return CM_Is_Version_Available_Ex(wVersion, NULL);
}


CONFIGRET
CM_Get_Global_State(
    OUT PULONG pulState,
    IN  ULONG  ulFlags
    )
{
    return CM_Get_Global_State_Ex(pulState, ulFlags, NULL);
}


CONFIGRET
CM_Query_Arbitrator_Free_Data(
    OUT PVOID      pData,
    IN  ULONG      DataLen,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    return CM_Query_Arbitrator_Free_Data_Ex(pData, DataLen, dnDevInst,
                                            ResourceID, ulFlags, NULL);
}


CONFIGRET
CM_Query_Arbitrator_Free_Size(
    OUT PULONG     pulSize,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    return CM_Query_Arbitrator_Free_Size_Ex(pulSize, dnDevInst, ResourceID,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Run_Detection(
    IN ULONG ulFlags
    )
{
    return CM_Run_Detection_Ex(ulFlags, NULL);
}



//-------------------------------------------------------------------
// ANSI Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Connect_MachineA(
    IN  PCSTR     UNCServerName,
    OUT PHMACHINE phMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniName = NULL;

    if ((!ARGUMENT_PRESENT(UNCServerName)) ||
        (UNCServerName[0] == '\0')) {
        //
        // no explicit name specified, so assume local machine and
        // nothing to translate
        //
        Status = CM_Connect_MachineW(pUniName,
                                     phMachine);

    } else if (pSetupCaptureAndConvertAnsiArg(UNCServerName, &pUniName) == NO_ERROR) {

        Status = CM_Connect_MachineW(pUniName,
                                     phMachine);
        pSetupFree(pUniName);

    } else {
        Status = CR_INVALID_DATA;
    }

    return Status;

} // CM_Connect_MachineA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\resdes.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    resdes.c

Abstract:

    This module contains the API routines that operate directly on resource
    descriptions.

               CM_Add_Res_Des
               CM_Free_Res_Des
               CM_Get_Next_Res_Des
               CM_Get_Res_Des_Data
               CM_Get_Res_Des_Data_Size
               CM_Modify_Res_Des
               CM_Detect_Resource_Conflict
               CM_Free_Res_Des_Handle

Author:

    Paula Tomlinson (paulat) 9-26-1995

Environment:

    User mode only.

Revision History:

    26-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


//
// Private prototypes
//
CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    );

BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    );

CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResData64,
    IN  ULONG      ResLen64,
    OUT PVOID    * ResData32,
    OUT ULONG    * ResLen32
    );

CONFIGRET
Convert32bitResDesTo64bitResDes(
    IN     RESOURCEID ResourceID,
    IN OUT PVOID      ResData,
    IN     ULONG      ResLen
    );

CONFIGRET
Convert32bitResDesSizeTo64bitResDesSize(
    IN     RESOURCEID ResourceID,
    IN OUT PULONG     ResLen
    );

//
// private prototypes from logconf.c
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );




CONFIGRET
CM_Add_Res_Des_Ex(
    OUT PRES_DES  prdResDes,
    IN LOG_CONF   lcLogConf,
    IN RESOURCEID ResourceID,
    IN PCVOID     ResourceData,
    IN ULONG      ResourceLen,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine adds a resource descriptor to a logical configuration.

Parameters:

   prdResDes   Address of a variable that receives a handle for the new
               resource descriptor.

   lcLogConf   Supplies the handle of the logical configuration to which
               the resource descriptor is added.

   ResourceID  Specifies the type of the resource.  Can be one of the
               ResType values defined in Section 2.1..

   ResourceData Supplies the address of an IO_DES, MEM_DES, DMA_DES, or
               IRQ_DES structure, depending on the given resource type.

   ResourceLen Supplies the size, in bytes, of the structure pointed to
               by ResourceData.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RESOURCE_ID,
         CR_OUT_OF_MEMORY.

--*/


{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulResTag = 0, ulLogTag, ulLogType,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;


    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        #if 0
        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif

        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on an add
        }

        //
        // Initialize parameters
        //
        if (prdResDes != NULL) {   // prdResDes is optional param
            *prdResDes = 0;
        }

        //
        // extract info from the log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulLogType = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulLogTag  = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ResourceID,             // resource type
                &ulResTag,              // resource tag
                (LPBYTE)ResourceData,   // actual res des data
                ResourceLen,            // size in bytes of ResourceData
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if ((Status == CR_SUCCESS) && (prdResDes != NULL)) {

            Status = CreateResDesHandle(prdResDes,
                                        dnDevInst,
                                        ulLogType,
                                        ulLogTag,
                                        ResourceID,
                                        ulResTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if(ResourceData32) {
        pSetupFree(ResourceData32);
    }

    return Status;

} // CM_Add_Res_Des_Ex




CONFIGRET
CM_Free_Res_Des_Ex(
    OUT PRES_DES prdResDes,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine destroys a resource descriptor. This API returns
   CR_NO_MORE_RES_DES if rdResDes specifies the last resource descriptor.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the previous resource descriptor.  If rdResDes
               is the handle of the first resource descriptor, this
               address receives the handle of the logical configuration.

   rdResDes    Supplies the handle of the resource descriptor to be destroyed.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_NO_MORE_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR      pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen=MAX_DEVICE_ID_LEN;
    ULONG       ulPreviousResType = 0, ulPreviousResTag = 0;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize parameters
        //
        if (prdResDes != NULL) {  // optional parameter
            *prdResDes = 0;
        }

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_FreeResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                &ulPreviousResType,     // resource type of previous res des
                &ulPreviousResTag,      // tag of previous res des
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_FreeResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if ((Status != CR_SUCCESS) &&
            (Status != CR_NO_MORE_RES_DES)) {
            goto Clean0;       // quit for any other error
        }

        //
        // if prdResDes supplied, fill in with previous res des or
        // the log conf info
        //
        if (prdResDes != NULL) {
            //
            // if the previous tag value is set to 0xFFFFFFFF, then
            // there are no previous tages so return the log conf
            // info instead
            //
            if (Status == CR_NO_MORE_RES_DES) {

                CONFIGRET Status1;

                Status1 = CreateLogConfHandle(prdResDes, dnDevInst,
                                              ulLogType, ulLogTag);

                if (Status1 != CR_SUCCESS) {
                    Status = Status1;
                }
            }

            else {
                //
                // allocate a res des handle
                //
                Status = CreateResDesHandle(prdResDes, dnDevInst,
                                            ulLogType, ulLogTag,
                                            ulPreviousResType,
                                            ulPreviousResTag);
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Res_Des_Ex



CONFIGRET
CM_Get_Next_Res_Des_Ex(
    OUT PRES_DES    prdResDes,
    IN  RES_DES     rdResDes,
    IN  RESOURCEID  ForResource,
    OUT PRESOURCEID pResourceID,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns the handle of the next resource descriptor in
   a logical configuration.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the next resource descriptor.

   rdResDes    Supplies the handle of the current resource
               descriptor or the handle of a logical configuration.
               (Both are 32-bit numbers--Configuration Manager must can
               distinguish between them.)

   ForResource Specifies the type of the resource to retrieve.  Can be
               one of the ResType values listed in Section 2.1..

   pResourceID Supplies the address of the variable that receives the
               resource type, when ForResource specifies ResType_All.
               (When ForResource is not ResType_All, this parameter can
               be NULL.)

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_NO_MORE_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogTag, ulLogType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    ULONG       ulNextResType = 0, ulNextResTag = 0;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (prdResDes == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ForResource > ResType_MAX  &&
            ForResource != ResType_ClassSpecific) {

            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ForResource == ResType_All  &&  pResourceID == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // this handle could be a res des or a log conf, determine
        // which and extract info handle
        //
        if (ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            //
            // it was a valid res des handle
            //
            dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
            ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
            ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
            ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;
        }

        else if (ValidateLogConfHandle((PPrivate_Log_Conf_Handle)rdResDes)) {
            //
            // it was a valid log conf handle, so assume it's the first
            // res des we want
            //
            dnDevInst = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_DevInst;
            ulLogType = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_LogConfType;
            ulLogTag  = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_LogConfTag;
            ulResTag  = MAX_RESDES_TAG;
        }

        else {
            //
            // it was neither a valid log conf nor a valid res des handle
            //
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetNextResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ForResource,            // resource type
                ulResTag,               // resource tag
                &ulNextResTag,          // next res des of type ForResource
                &ulNextResType,         // type of next res des
                ulFlags);               // 32/64 bit data
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetNextResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        if (ForResource == ResType_All) {
            *pResourceID = ulNextResType;
        }

        Status = CreateResDesHandle(prdResDes,
                                    dnDevInst,
                                    ulLogType,
                                    ulLogTag,
                                    ulNextResType,
                                    ulNextResTag);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Next_Res_Des_Ex



CONFIGRET
CM_Get_Res_Des_Data_Ex(
    IN  RES_DES  rdResDes,
    OUT PVOID    Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine copies the data from a specified resource descriptor
   into a buffer.  Use the CM_Get_Res_Des_Data_Size API to determine
   the buffer size needed to receive the data.  Alternately, set a
   size that is at least as large as the maximum possible size of the
   resource.  If the size given is too small, the data is truncated and
   the API returns CR_BUFFER_SMALL.

Parameters:

   rdResDes    Supplies the handle of the resource descriptor from which
               data is to be copied.

   Buffer      Supplies the address of the buffer that receives the data.

   BufferLen   Supplies the size of the buffer, in bytes.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data expected is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    BOOL        ConvertResDes = FALSE;

    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (Buffer == NULL || BufferLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Client will only give us 32-bit resdes.  Request a 32-bit
                // resdes from the server, and we'll convert it to 64-bit here
                // on the client.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;
                ConvertResDes = TRUE;
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetResDesData(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                Buffer,                 // return res des data
                BufferLen,              // size in bytes of Buffer
                ulFlags);               // 32/64 bit data
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetResDesData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if((Status == CR_SUCCESS) && ConvertResDes) {
            Status = Convert32bitResDesTo64bitResDes(ulResType,Buffer,BufferLen);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Res_Des_Data_Ex



CONFIGRET
CM_Get_Res_Des_Data_Size_Ex(
    OUT PULONG   pulSize,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size of a resource descriptor, not
   including the resource descriptor header.

Parameters:

   pulSize     Supplies the address of the variable that receives the
               size, in bytes, of the resource descriptor data.

   rdResDes    Supplies the handle of the resource descriptor for which
               to retrieve the size.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data expected is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    BOOL        ConvertResDesSize = FALSE;


    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (pulSize == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // Initialize output parameters
        //
        *pulSize = 0;

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server only supports 32-bit resdes.  Request a 32-bit
                // resdes size from the server, and we'll convert it to 64-bit here
                // on the client.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;
                ConvertResDesSize = TRUE;
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetResDesDataSize(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                pulSize,                // returns size of res des data
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetResDesDataSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if(Status == CR_SUCCESS) {
            Status = Convert32bitResDesSizeTo64bitResDesSize(ulResType,pulSize);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Res_Des_Data_Size_Ex



CONFIGRET
CM_Modify_Res_Des_Ex(
    OUT PRES_DES   prdResDes,
    IN  RES_DES    rdResDes,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine modifies a resource descriptor. This API retrieves a
   handle to the new resource descriptor.  This may or may not be the
   handle of the original resource descriptor.  The original resource
   descriptor handle is invalid after calling this API.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the modified resource descriptor.

   rdResDes    Supplies the handle of the resource descriptor to be
               modified.

   ResourceID  Specifies the type of resource to modify.  Can be one
               of the ResType values described in Section 2.1..

   ResourceData  Supplies the address of a resource data structure.

   ResourceLen Supplies the size, in bytes, of the new resource data
               structure.  This size can be different from the size of
               the original resource data.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;


    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (prdResDes == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ResourceData == NULL  ||  ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // initialize output parameters
        //
        *prdResDes = 0;

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_ModifyResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // current resource type
                ResourceID,             // new resource type
                ulResTag,               // resource tag
                (LPBYTE)ResourceData,   // actual res des data
                ResourceLen,            // size in bytes of ResourceData
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_ModifyResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // The resource type may change so a new handle is required and
            // returned to caller.
            //
            Status = CreateResDesHandle(prdResDes,
                                        dnDevInst,
                                        ulLogType,
                                        ulLogTag,
                                        ResourceID,
                                        ulResTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if(ResourceData32) {
        pSetupFree(ResourceData32);
    }
    return Status;

} // CM_Modify_Res_Des_Ex



CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,         OPTIONAL
    IN  PCVOID     ResourceData,       OPTIONAL
    IN  ULONG      ResourceLen,        OPTIONAL
    OUT PBOOL      pbConflictDetected,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
/*++

Routine Description:

   This depreciated routine calls CM_Query_Resource_Conflict_List to see if
   dnDevInst is conflicting with any other devices. It is used for a simple
   "has a conflict" check. CM_Query_Resource_Conflict_List returns more
   details of the conflicts.

Parameters:

   dnDevInst   DEVINST we're doing the test for (ie, that resource belongs to)

   ResourceID,ResourceData,ResourceLen
               See if this resource conflicts with a device other than dnDevInst

   pbConflictDetected
               Set to TRUE on conflict, FALSE if no conflict

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY.

--*/
{
    CONFIGRET     Status = CR_SUCCESS;
    CONFLICT_LIST ConflictList = 0;
    ULONG         ConflictCount = 0;
    WCHAR         pDeviceID [MAX_DEVICE_ID_LEN];  // )
    PVOID         hStringTable = NULL;            // > for validation only
    handle_t      hBinding = NULL;                // )
    ULONG         ulLen = MAX_DEVICE_ID_LEN;      // )

    try {
        //
        // validate parameters - must maintain compatability with original implementation
        // even though some of the error codes don't make sense
        // don't change any of the parameters here, as they are needed for
        // CM_Query_Resource_Conflict_List
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pbConflictDetected == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on a detect
            goto Clean0;
        }
        //
        // setup rpc binding handle and string table handle - for validation only
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        // stupid status code for this check, but someone may rely on it
        //
        if ((pSetupStringTableStringFromIdEx(hStringTable,dnDevInst,pDeviceID,&ulLen) == FALSE)
             || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }
        //
        // now implement via CM_Query_Resource_Conflict_List
        // the only difference here is that this new implementation should return
        // only valid conflicts
        //
        Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                 dnDevInst,
                                                 ResourceID,
                                                 ResourceData,
                                                 ResourceLen,
                                                 ulFlags,
                                                 hMachine);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        *pbConflictDetected = ConflictCount ? TRUE : FALSE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (ConflictList) {
        CM_Free_Resource_Conflict_Handle(ConflictList);
    }

    return Status;

} // CM_Detect_Resource_Conflict



CONFIGRET
CM_Free_Res_Des_Handle(
    IN  RES_DES    rdResDes
    )

/*++

Routine Description:

   This routine frees the handle to the specified res des and frees and
   memory associated with that res des handle.

Parameters:


   rdResDes    Supplies the handle of the resource descriptor.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;


    try {
        //
        // Validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // It's a valid log conf handle, which is a pointer to memory
        // allocated when the log conf was created or retrieved using
        // the first/next routines. Free the associated memory.
        //
        ((PPrivate_Res_Des_Handle)rdResDes)->RD_Signature = 0;
        pSetupFree((PPrivate_Res_Des_Handle)rdResDes);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Res_Des_Handle



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Add_Res_Des(
    OUT PRES_DES  prdResDes,
    IN LOG_CONF   lcLogConf,
    IN RESOURCEID ResourceID,
    IN PCVOID     ResourceData,
    IN ULONG     ResourceLen,
    IN ULONG     ulFlags
    )
{
    return CM_Add_Res_Des_Ex(prdResDes, lcLogConf, ResourceID, ResourceData,
                             ResourceLen, ulFlags, NULL);
}


CONFIGRET
CM_Free_Res_Des(
    OUT PRES_DES prdResDes,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags
    )
{
    return CM_Free_Res_Des_Ex(prdResDes, rdResDes, ulFlags, NULL);
}


CONFIGRET
CM_Get_Next_Res_Des(
    OUT PRES_DES    prdResDes,
    IN  RES_DES     rdResDes,
    IN  RESOURCEID  ForResource,
    OUT PRESOURCEID pResourceID,
    IN  ULONG       ulFlags
    )
{
   return CM_Get_Next_Res_Des_Ex(prdResDes, rdResDes, ForResource,
                                 pResourceID, ulFlags, NULL);
}


CONFIGRET
CM_Get_Res_Des_Data(
    IN  RES_DES rdResDes,
    OUT PVOID   Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Res_Des_Data_Ex(rdResDes, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Get_Res_Des_Data_Size(
    OUT PULONG  pulSize,
    IN  RES_DES rdResDes,
    IN  ULONG  ulFlags
    )
{
    return CM_Get_Res_Des_Data_Size_Ex(pulSize, rdResDes, ulFlags, NULL);
}


CONFIGRET
CM_Modify_Res_Des(
    OUT PRES_DES   prdResDes,
    IN  RES_DES    rdResDes,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN  ULONG      ulFlags
    )
{
   return CM_Modify_Res_Des_Ex(prdResDes, rdResDes, ResourceID, ResourceData,
                               ResourceLen, ulFlags, NULL);
}


CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,         OPTIONAL
    IN  PCVOID     ResourceData,       OPTIONAL
    IN  ULONG      ResourceLen,        OPTIONAL
    OUT PBOOL      pbConflictDetected,
    IN  ULONG      ulFlags
    )
{
    return CM_Detect_Resource_Conflict_Ex(dnDevInst, ResourceID, ResourceData,
                                          ResourceLen, pbConflictDetected,
                                          ulFlags, NULL);
}



//-------------------------------------------------------------------
// Local Utility Routines
//-------------------------------------------------------------------


CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    )
{
    PPrivate_Res_Des_Handle pResDesHandle;

    //
    // allocate memory for the res des handle data
    //
    pResDesHandle = (PPrivate_Res_Des_Handle)pSetupMalloc(
                            sizeof(Private_Res_Des_Handle));

    if (pResDesHandle == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    //
    // fill in the private res des info and return as handle
    //
    pResDesHandle->RD_Signature    = CM_PRIVATE_RESDES_SIGNATURE;
    pResDesHandle->RD_DevInst      = dnDevInst;
    pResDesHandle->RD_LogConfType  = ulLogType;
    pResDesHandle->RD_LogConfTag   = ulLogTag;
    pResDesHandle->RD_ResourceType = ulResType;
    pResDesHandle->RD_ResDesTag    = ulResTag;

    *prdResDes = (RES_DES)pResDesHandle;

    return CR_SUCCESS;

} // CreateResDesHandle



BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    )
{
    //
    // validate parameters
    //
    if (pResDes == NULL  || pResDes == 0) {
        return FALSE;
    }

    //
    // check for the private log conf signature
    //
    if (pResDes->RD_Signature != CM_PRIVATE_RESDES_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateResDesHandle



CONFIGRET
Convert32bitResDesSizeTo64bitResDesSize(
    IN  RESOURCEID ResourceID,
    IN OUT PULONG ResLen
    )
/*++

Routine Description:

   This routine resizes ResLen for ResourceID
   old structure: [DES32][RANGE32][RANGE32]...
   new structure: [DES64 ][RANGE64 ][RANGE 64]...
   #elements = (len-sizeof(DES32))/sizeof(RANGE32)
   new len = sizeof(DES64)+#elements*sizeof(RANGE64)
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResLen     - adjusted resource length

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource size
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        //
        // header only
        // use offsetof to handle non-obvious structure alignment padding
        //
        *ResLen += offsetof(IRQ_RESOURCE_64,IRQ_Data)-offsetof(IRQ_RESOURCE_32,IRQ_Data);
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}



CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID ResData64,
    IN  ULONG ResLen64,
    OUT PVOID * ResData32,
    OUT ULONG * ResLen32
    )
/*++

Routine Description:

   This routine allocates ResData32 and converts ResData64 into ResData32 if needed
   In the cases where no conversion is required, CR_SUCCESS is returned and
   ResData32 is NULL.
   In the cases where conversion is required, ResData32 holds new data

   old structure: [DES64 ][RANGE64 ][RANGE 64]...
   new structure: [DES32][RANGE32][RANGE32]...
   #elements from 64-bit structure
   new len = sizeof(DES32)+#elements*sizeof(RANGE32)
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResData64  - incoming data to convert (constant buffer)
   ResLen64   - incoming length of data
   ResData32  - converted data (if non-NULL)
   ResLen32   - converted length

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    *ResData32 = NULL;
    *ResLen32 = ResLen64;

    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource structure
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        {
            PIRQ_RESOURCE_64 pIrq64 = (PIRQ_RESOURCE_64)ResData64;
            ULONG DataSize = ResLen64-offsetof(IRQ_RESOURCE_64,IRQ_Data);
            ULONG NewResSize = DataSize+offsetof(IRQ_RESOURCE_32,IRQ_Data);
            PVOID NewResData = pSetupMalloc(NewResSize);
            PIRQ_RESOURCE_32 pIrq32 = (PIRQ_RESOURCE_32)NewResData;

            if(NewResData == NULL) {
                return CR_OUT_OF_MEMORY;
            }
            //
            // copy header
            //
            MoveMemory(pIrq32,pIrq64,offsetof(IRQ_RESOURCE_32,IRQ_Data));
            //
            // copy/truncate Affinity (to ensure it's correct)
            //
            pIrq32->IRQ_Header.IRQD_Affinity = (ULONG32)pIrq64->IRQ_Header.IRQD_Affinity;
            //
            // copy data (trivial in this case)
            //
            MoveMemory(pIrq32->IRQ_Data,pIrq64->IRQ_Data,DataSize);

            *ResLen32 = NewResSize;
            *ResData32 = NewResData;
        }
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}



CONFIGRET
Convert32bitResDesTo64bitResDes(
    IN     RESOURCEID ResourceID,
    IN OUT PVOID ResData,
    IN     ULONG ResLen
    )
/*++

Routine Description:

   This routine reuses ResData and ResLen converting the 32-bit data provided
   into 64-bit. Return error if buffer (reslen) isn't big enough

   old structure: [DES32][RANGE32][RANGE32]...
   new structure: [DES64 ][RANGE64 ][RANGE 64]...
   #elements from 32-bit structure
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResData    - in, 32-bit, out, 64-bit
   ResData32  - size of ResData buffer

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource structure
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        {
            PIRQ_RESOURCE_64 pIrq64 = (PIRQ_RESOURCE_64)ResData;
            PIRQ_RESOURCE_32 pIrq32 = (PIRQ_RESOURCE_32)ResData;
            ULONG DataSize = pIrq32->IRQ_Header.IRQD_Count * sizeof(IRQ_RANGE);
            ULONG NewResSize = DataSize+offsetof(IRQ_RESOURCE_64,IRQ_Data);

            if(NewResSize > ResLen) {
                return CR_BUFFER_SMALL;
            }
            //
            // work top to bottom
            // copy data (trivial in this case)
            // MoveMemory handles overlap
            //
            MoveMemory(pIrq64->IRQ_Data,pIrq32->IRQ_Data,DataSize);

            //
            // header is in correct position
            // but we need to deal with affinity... copy only low 32-bits
            //
            pIrq64->IRQ_Header.IRQD_Affinity = pIrq32->IRQ_Header.IRQD_Affinity;
        }
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\rpcbind.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rpcbind.c

Abstract:

    This module contains the RPC bind and un-bind routines for the
    Configuration Manager client-side APIs.

Author:

    Paula Tomlinson (paulat) 6-21-1995

Environment:

    User-mode only.

Revision History:

    21-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"

#include <svcsp.h>



handle_t
PNP_HANDLE_bind(
    PNP_HANDLE   ServerName
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all
    services. This routine is called from the PNP API client stubs
    when it is necessary to bind to a server. The binding is done to
    allow impersonation by the server since that is necessary for the
    API calls.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t  BindingHandle;
    NTSTATUS  Status;


    //
    // Bind to the server on the shared named pipe for services.exe RPC servers.
    // We specify the following network options for security:
    //
    //     L"Security=Impersonation Dynamic True",
    //
    // The "Impersonation" option indicates that in addition to knowing the
    // identity of the client, the server may impersonate the client as well.
    //
    // The "Dynamic" option specifies dynamic identity tracking, such that
    // changes in the client security identity are seen by the server.
    //
    // NOTE: When using the named pipe transport, "Dynamic" identity tracking is
    // only available to local RPC clients.  For remote clients, "Static"
    // identity tracking is used, which means that changes in the client
    // security identity are NOT seen by the server.  The identity of the caller
    // is saved during the first remote procedure call on that binding handle
    //
    // The "True" option (Effective = TRUE) specifies that only token privileges
    // currently enabled for the client are present in the token seen by the
    // server.  This means that the server cannot enable any privileges the
    // client may have possessed, but were not explicitly enabled at the time of
    // the call.  This is desirable, because the PlugPlay RPC server should
    // never need to enable any client privileges itself.  Any privileges
    // required by the server must be enabled by the client prior to the call.
    //

    Status =
        RpcpBindRpc(
            ServerName,    // UNC Server Name
            SVCS_RPC_PIPE, // L"ntsvcs"
            L"Security=Impersonation Dynamic True",
            &BindingHandle);

    //
    // The possible return codes from RpcpBindRpc are STATUS_SUCCESS,
    // STATUS_NO_MEMORY and STATUS_INVALID_COMPUTER_NAME.  Since the format
    // of the bind routine is fixed, set any errors encountered as the last
    // error and return NULL.
    //
    if (Status != STATUS_SUCCESS) {

        BindingHandle = NULL;

        if (Status == STATUS_NO_MEMORY) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        } else if (Status == STATUS_INVALID_COMPUTER_NAME) {
            SetLastError(ERROR_INVALID_COMPUTERNAME);

        } else {
            SetLastError(ERROR_GEN_FAILURE);
        }
    }

    return BindingHandle;

} // PNP_HANDLE_bind



void
PNP_HANDLE_unbind(
    PNP_HANDLE    ServerName,
    handle_t      BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services. It is called from the PlugPlay RPC client stubs
    when it is necessary to unbind from the RPC server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/

{
    NTSTATUS  Status;

    UNREFERENCED_PARAMETER(ServerName);

    Status = RpcpUnbindRpc(BindingHandle);

    return;

} // PNP_HANDLE_unbind
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\regprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    regprop.c

Abstract:

    This module contains the API routines that reg and set registry
    properties and operates on classes.

                  CM_Get_DevNode_Registry_Property
                  CM_Set_DevNode_Registry_Property
                  CM_Get_Class_Registry_Property
                  CM_Set_Class_Registry_Property
                  CM_Open_DevNode_Key
                  CM_Delete_DevNode_Key
                  CM_Open_Class_Key
                  CM_Enumerate_Classes
                  CM_Get_Class_Name
                  CM_Get_Class_Key_Name
                  CM_Delete_Class_Key
                  CM_Get_Device_Interface_Alias
                  CM_Get_Device_Interface_List
                  CM_Get_Device_Interface_List_Size
                  CM_Register_Device_Interface
                  CM_Unregister_Device_Interface
                  CM_Get_DevNode_Custom_Property

Author:

    Paula Tomlinson (paulat) 6-22-1995

Environment:

    User mode only.

Revision History:

    22-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"
#include "cmdat.h"


//
// Private prototypes
//

ULONG
GetPropertyDataType(
    IN ULONG ulProperty
    );

//
// use these from SetupAPI
//
PSECURITY_DESCRIPTOR
pSetupConvertTextToSD(
    IN PCWSTR SDS,
    OUT PULONG SecDescSize
    );

PWSTR
pSetupConvertSDToText(
    IN PSECURITY_DESCRIPTOR SD,
    OUT PULONG pSDSSize
    );


//
// global data
//
extern PVOID    hLocalBindingHandle;   // NOT MODIFIED BY THESE PROCEDURES



CONFIGRET
CM_Get_DevNode_Registry_Property_ExW(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified value from the device instance's
   registry storage key.

Parameters:

   dnDevInst   Supplies the handle of the device instance for which a
               property is to be retrieved.

   ulProperty  Supplies an ordinal specifying the property to be retrieved.
               (CM_DRP_*)

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVINST,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulSizeID = MAX_DEVICE_ID_LEN;
    ULONG       ulTempDataType=0, ulTransferLen=0;
    ULONG       ulGetProperty = ulProperty;
    BYTE        NullBuffer=0;
    handle_t    hBinding = NULL;
    PVOID       hStringTable = NULL;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulProperty < CM_DRP_MIN) || (ulProperty > CM_DRP_MAX)) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        if (ulProperty == CM_DRP_SECURITY_SDS) {
            //
            // translates operation
            //
            LPVOID tmpBuffer = NULL;
            ULONG tmpBufferSize = 0;
            ULONG datatype;
            LPWSTR sds = NULL;
            size_t sdsLen = 0;

            ulTempDataType = REG_SZ;

            try {
                Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                              CM_DRP_SECURITY,
                                                              &datatype,
                                                              NULL,
                                                              &tmpBufferSize,
                                                              ulFlags,
                                                              hMachine);
                if (Status != CR_SUCCESS && Status != CR_BUFFER_SMALL) {
                    leave;
                }
                tmpBuffer = pSetupMalloc(tmpBufferSize);
                if (tmpBuffer == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    leave;
                }
                Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                              CM_DRP_SECURITY,
                                                              &datatype,
                                                              tmpBuffer,
                                                              &tmpBufferSize,
                                                              ulFlags,
                                                              hMachine);
                if (Status != CR_SUCCESS) {
                    leave;
                }

                //
                // now translate
                //
                sds = pSetupConvertSDToText((PSECURITY_DESCRIPTOR)tmpBuffer,NULL);
                if (sds == NULL) {
                    Status = CR_FAILURE;
                    leave;
                }

                //
                // There really isn't a max length defined for security
                // descriptor strings, but it had better be less than
                // STRSAFE_MAX_CCH (INT_MAX).
                //
                if (FAILED(StringCchLength(
                               sds,
                               STRSAFE_MAX_CCH,
                               &sdsLen))) {
                    Status = CR_FAILURE;
                    leave;
                }

                ulTransferLen = (ULONG)((sdsLen + 1)*sizeof(WCHAR));

                if (*pulLength == 0 || Buffer == NULL || *pulLength < ulTransferLen) {
                    //
                    // buffer too small, or buffer size wanted
                    // required buffer size
                    //
                    Status = CR_BUFFER_SMALL;
                    *pulLength = ulTransferLen;
                    ulTransferLen = 0;
                } else {
                    //
                    // copy data
                    //
                    CopyMemory(Buffer, sds, ulTransferLen);
                    *pulLength = ulTransferLen;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = CR_FAILURE;

                //
                // Reference the following variables so the compiler will respect
                // statement ordering w.r.t. their assignment.
                //
                tmpBuffer = tmpBuffer;
                sds = sds;
            }
            if (tmpBuffer != NULL) {
                pSetupFree(tmpBuffer);
            }
            if (sds != NULL) {
                //
                // must use LocalFree
                //
                LocalFree(sds);
            }
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        } else {
            //
            // setup rpc binding handle and string table handle
            //
            if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // retrieve the string form of the device id string
            //
            Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSizeID);
            if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }

            //
            // NOTE - When calling a PNP RPC server stub routine that marshalls
            // data between client and server buffers, be very careful to check
            // the corresponding server stub definition in the IDL file for the
            // [in] and/or [out] attributes of the parameters, and which
            // parameters are used to describe the [size_is] and/or [length_is]
            // attributes of a buffer.  Each of the PNP RPC server stub routines
            // behave in differently, so make sure you know what you are doing!!
            //

            //
            // PNP_GetDeviceRegProp -
            //
            //   Note that the [in,out] ulTransferLen parameter is used for
            //   *both* the [size_is] *and* [length_is] attributes of the [out]
            //   Buffer.  This means that upon entry [in] ulTransferLen is used
            //   to specify the amount of memory the stubs must allocate for the
            //   Buffer parameter, while on exit [out], its value indicates the
            //   amount of data the stubs should marshall back to the client (or
            //   0 if no data is to be marshalled).  Note that no data is
            //   marshalled by the stubs to the server since Buffer is [out]
            //   only.
            //
            //   The [in,out] pulLength parameter should also be set on entry
            //   [in] to the size of the Buffer.  On exit [out], this value
            //   contains either the amount of data marshalled back to the
            //   client by the server (if a transfer occurred) or the size that
            //   is required for a successful transfer.  This value should be
            //   passed back in the callers pulLength parameter.
            //

            //
            // Even though we may specify 0 bytes as the value of the [size_is]
            // attribute for the [out] Buffer, the Buffer itself must not be
            // NULL.  If the caller supplied a NULL Buffer, supply a local
            // pointer to the stubs instead.
            //
            ulTransferLen = *pulLength;
            if (Buffer == NULL) {
                Buffer = &NullBuffer;
            }

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetDeviceRegProp(
                    hBinding,               // rpc binding handle
                    pDeviceID,              // string representation of device instance
                    ulGetProperty,          // id for the property
                    &ulTempDataType,        // receives registry data type
                    Buffer,                 // receives registry data
                    &ulTransferLen,         // input/output buffer size
                    pulLength,              // bytes copied (or bytes required)
                    ulFlags);               // not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetDeviceRegProp caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        if (pulRegDataType != NULL) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Registry_Property_ExW



CONFIGRET
CM_Set_DevNode_Registry_Property_ExW(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine sets the specified value in the device instance's registry
   storage key.

Parameters:

   dnDevInst      Supplies the handle of the device instance for which a
                  property is to be retrieved.

   ulProperty     Supplies an ordinal specifying the property to be set.
                  (CM_DRP_*)

   Buffer         Supplies the address of the buffer that contains the
                  registry data.  This data must be of the proper type
                  for that property.

   ulLength       Supplies the number of bytes of registry data to write.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_OUT_OF_MEMORY,
      CR_INVALID_DATA, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulRegDataType = 0, ulLen = MAX_DEVICE_ID_LEN;
    BYTE        NullBuffer = 0x0;
    handle_t    hBinding = NULL;
    PVOID       hStringTable = NULL;
    BOOL        Success;
    PVOID       Buffer2 = NULL;
    PVOID       Buffer3 = NULL;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulProperty < CM_DRP_MIN) || (ulProperty > CM_DRP_MAX)) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // we need to specify what registry data to use for storing this data
        //
        ulRegDataType = GetPropertyDataType(ulProperty);

        //
        // if data type is REG_DWORD, make sure size is right
        //
        if((ulRegDataType == REG_DWORD) && ulLength && (ulLength != sizeof(DWORD))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // if the register is CM_DRP_SECURITY_SDS, convert it
        //
        if (ulProperty == CM_DRP_SECURITY_SDS) {
            if (ulLength) {
                //
                // this form of CM_DRP_SECURITY provides a string that needs to be converted to binary
                //
                PCWSTR UnicodeSecDesc = (PCWSTR)Buffer;

                Buffer2 = pSetupConvertTextToSD(UnicodeSecDesc,&ulLength);
                if (Buffer2 == NULL) {
                    //
                    // If last error is ERROR_SCE_DISABLED, then the failure is
                    // due to SCE APIs being "turned off" on Embedded.  Treat
                    // this as a (successful) no-op...
                    //
                    if(GetLastError() == ERROR_SCE_DISABLED) {
                        Status = CR_SUCCESS;
                    } else {
                        Status = CR_INVALID_DATA;
                    }
                    goto Clean0;
                }
                Buffer = Buffer2;
            }
            ulProperty = CM_DRP_SECURITY;
            ulRegDataType = REG_BINARY;
        }

        //
        // if data type is REG_SZ, make sure it is NULL terminated
        //
        if ((ulRegDataType == REG_SZ) && (ulLength != 0)) {

            HRESULT hr;
            size_t  BufferLen = 0;

            //
            // Check the length of the string specified, up to the number of
            // bytes specified.
            //
            hr = StringCbLength(Buffer, ulLength, &BufferLen);

            if (SUCCEEDED(hr)) {
                //
                // The specified buffer was NULL terminated before ulLength
                // bytes.  Use the specified buffer, specifying the length of
                // the string we just calculated.  The registry APIs will store
                // the size of the REG_SZ value data exactly as specified
                // (regardless of the actual string length), so we need to make
                // sure this is correct.
                //
                ASSERT(BufferLen < ulLength);
                ulLength = (ULONG)(BufferLen + sizeof(WCHAR));

            } else {
                //
                // The specified buffer was not NULL terminated before ulLength
                // bytes.  Allocate a new buffer that can hold a NULL terminated
                // version of the string data supplied.
                //
                BufferLen = ulLength + sizeof(WCHAR);

                Buffer3 = pSetupMalloc((DWORD)BufferLen);

                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // Copy the source data to the destination buffer, up to the
                // length of the destination, including terminating NULL.
                //
                // Ignore the return error because the source buffer may not be
                // NULL terminated, immediately beyond the number of bytes
                // specified as its length (ulLength), in which case truncation
                // will occur (at the ulLength originally specified for the
                // source), and an error is returned.  This is ok, since we are
                // guaranteed that the destination buffer is NULL terminated.
                //
                StringCbCopy(Buffer3, BufferLen, Buffer);

                Buffer = Buffer3;
                ulLength = (ULONG)BufferLen;
            }
        }

        //
        // if data type is REG_MULTI_SZ, make sure it is double-NULL terminated
        //
        if ((ulRegDataType == REG_MULTI_SZ) && (ulLength != 0)) {

            ULONG ulNewLength;
            PWSTR tmpBuffer, bufferEnd;

            ulLength &= ~(ULONG)1;
            tmpBuffer = (PWSTR)Buffer;
            bufferEnd = (PWSTR)((PUCHAR)tmpBuffer + ulLength);
            ulNewLength = ulLength;
            while ((tmpBuffer < bufferEnd) && (*tmpBuffer != L'\0')) {

                while ((tmpBuffer < bufferEnd) && (*tmpBuffer != L'\0')) {

                    tmpBuffer++;
                }
                if (tmpBuffer >= bufferEnd) {

                    ulNewLength += sizeof(WCHAR);
                } else {

                    tmpBuffer++;
                }
            }
            if (tmpBuffer >= bufferEnd) {

                ulNewLength += sizeof(WCHAR);
            } else {

                ulNewLength = ((ULONG)(tmpBuffer - (PWSTR)Buffer) + 1) * sizeof(WCHAR);
            }
            if (ulNewLength > ulLength) {

                Buffer3 = pSetupMalloc(ulNewLength);
                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                CopyMemory(Buffer3, Buffer, ulLength);
                ZeroMemory((PUCHAR)Buffer3 + ulLength, ulNewLength - ulLength);
                Buffer = Buffer3;
            }
            ulLength = ulNewLength;
        }


        //
        // NOTE - When calling a PNP RPC server stub routine that marshalls
        // data between client and server buffers, be very careful to check
        // the corresponding server stub definition in the IDL file for the
        // [in] and/or [out] attributes of the parameters, and which
        // parameters are used to describe the [size_is] and/or [length_is]
        // attributes of a buffer.  Each of the PNP RPC server stub routines
        // behave in differently, so make sure you know what you are doing!!
        //

        //
        // PNP_SetDeviceRegProp -
        //
        //   Note that the [in] ulLength parameter is used for the [size_is]
        //   attributes of the [in] Buffer.  This indicates both the amount of
        //   memory the stubs must allocate, as well as the amount of data that
        //   must be marshalled.  Note that no data is marshalled by the stubs
        //   to the client since Buffer is [in] only.
        //

        //
        // Even though we may specify 0 bytes as the value of the [size_is]
        // attribute for the [in] Buffer, the Buffer itself must not be
        // NULL.  If the caller supplied a NULL Buffer, supply a local
        // pointer to the stubs instead.
        //
        if (Buffer == NULL) {
            Buffer = &NullBuffer;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetDeviceRegProp(
                hBinding,               // rpc binding handle
                pDeviceID,              // string representation of devinst
                ulProperty,             // string name for property
                ulRegDataType,          // specifies registry data type
                (LPBYTE)Buffer,         // specifies registry data
                ulLength,               // specifies amount of data in Buffer
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetDeviceRegProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        Buffer2 = Buffer2;
        Buffer3 = Buffer3;
    }

    if (Buffer3) {
        pSetupFree(Buffer3);
    }

    if (Buffer2) {
        //
        // SceSvc requires LocalFree
        //
        LocalFree(Buffer2);
    }

    return Status;

} // CM_Set_DevNode_Registry_Property_ExW



CONFIGRET
CM_Get_Class_Registry_PropertyW(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified value from the classes's
   registry storage key.

Parameters:

   ClassGUID   Supplies the Class GUID.

   ulProperty  Supplies an ordinal specifying the property to be retrieved.
               (CM_DRP_*)

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVINST,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulTempDataType=0, ulTransferLen=0;
    BYTE        NullBuffer=0;
    handle_t    hBinding = NULL;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    ULONG       ulGetProperty = ulProperty;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(ClassGUID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(
                ClassGUID,
                szStringGuid,
                MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if ((ulProperty < CM_CRP_MIN) || (ulProperty > CM_CRP_MAX)) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        if (ulProperty == CM_CRP_SECURITY_SDS) {
            //
            // translates operation
            //
            LPVOID tmpBuffer = NULL;
            ULONG tmpBufferSize = 0;
            ULONG datatype;
            LPWSTR sds = NULL;
            size_t sdsLen = 0;

            ulTempDataType = REG_SZ;

            try {
                Status =
                    CM_Get_Class_Registry_PropertyW(
                        ClassGUID,
                        CM_CRP_SECURITY,
                        &datatype,
                        NULL,
                        &tmpBufferSize,
                        ulFlags,
                        hMachine);

                if ((Status != CR_SUCCESS) &&
                    (Status != CR_BUFFER_SMALL)) {
                    leave;
                }

                tmpBuffer = pSetupMalloc(tmpBufferSize);
                if (tmpBuffer == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    leave;
                }

                Status =
                    CM_Get_Class_Registry_PropertyW(
                        ClassGUID,
                        CM_CRP_SECURITY,
                        &datatype,
                        tmpBuffer,
                        &tmpBufferSize,
                        ulFlags,
                        hMachine);
                if (Status != CR_SUCCESS) {
                    leave;
                }

                //
                // now translate
                //
                sds = pSetupConvertSDToText((PSECURITY_DESCRIPTOR)tmpBuffer,NULL);
                if (sds == NULL) {
                    Status = CR_FAILURE;
                    leave;
                }

                //
                // There really isn't a max length defined for security
                // descriptor strings, but it had better be less than
                // STRSAFE_MAX_CCH (INT_MAX).
                //
                if (FAILED(StringCchLength(
                               sds,
                               STRSAFE_MAX_CCH,
                               &sdsLen))) {
                    Status = CR_FAILURE;
                    leave;
                }

                ulTransferLen = (ULONG)((sdsLen + 1)*sizeof(WCHAR));

                if (*pulLength == 0 || Buffer == NULL || *pulLength < ulTransferLen) {
                    //
                    // buffer too small, or buffer size wanted
                    // required buffer size
                    //
                    Status = CR_BUFFER_SMALL;
                    *pulLength = ulTransferLen;
                    ulTransferLen = 0;
                } else {
                    //
                    // copy data
                    //
                    CopyMemory(Buffer, sds, ulTransferLen);
                    *pulLength = ulTransferLen;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = CR_FAILURE;
            }
            if (tmpBuffer != NULL) {
                pSetupFree(tmpBuffer);
            }
            if (sds != NULL) {
                //
                // must use LocalFree
                //
                LocalFree(sds);
            }
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        } else {

            //
            // setup rpc binding handle and string table handle
            //
            if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // NOTE - When calling a PNP RPC server stub routine that marshalls
            // data between client and server buffers, be very careful to check
            // the corresponding server stub definition in the IDL file for the
            // [in] and/or [out] attributes of the parameters, and which
            // parameters are used to describe the [size_is] and/or [length_is]
            // attributes of a buffer.  Each of the PNP RPC server stub routines
            // behave in differently, so make sure you know what you are doing!!
            //

            //
            // PNP_GetClassRegProp -
            //
            //   Note that the [in,out] ulTransferLen parameter is used for
            //   *both* the [size_is] *and* [length_is] attributes of the [out]
            //   Buffer.  This means that upon entry [in] ulTransferLen is used
            //   to specify the amount of memory the stubs must allocate for the
            //   Buffer parameter, while on exit [out], its value indicates the
            //   amount of data the stubs should marshall back to the client (or
            //   0 if no data is to be marshalled).  Note that no data is
            //   marshalled by the stubs to the server since Buffer is [out]
            //   only.
            //
            //   The [in,out] pulLength parameter should also be set on entry
            //   [in] to the size of the Buffer.  On exit [out], this value
            //   contains either the amount of data marshalled back to the
            //   client by the server (if a transfer occurred) or the size that
            //   is required for a successful transfer.  This value should be
            //   passed back in the callers pulLength parameter.
            //

            //
            // Even though we may specify 0 bytes as the value of the [size_is]
            // attribute for the [out] Buffer, the Buffer itself must not be
            // NULL.  If the caller supplied a NULL Buffer, supply a local
            // pointer to the stubs instead.
            //
            ulTransferLen = *pulLength;
            if (Buffer == NULL) {
                Buffer = &NullBuffer;
            }

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetClassRegProp(
                    hBinding,               // rpc binding handle
                    szStringGuid,           // string representation of class
                    ulGetProperty,          // id for the property
                    &ulTempDataType,        // receives registry data type
                    Buffer,                 // receives registry data
                    &ulTransferLen,         // input/output buffer size
                    pulLength,              // bytes copied (or bytes required)
                    ulFlags);               // not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetClassRegProp caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

        }

        if (pulRegDataType != NULL) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Registry_PropertyW



CONFIGRET
CM_Set_Class_Registry_PropertyW(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine sets the specified value in the device instance's registry
   storage key.

Parameters:

   ClassGUID      Supplies the Class GUID.

   ulProperty     Supplies an ordinal specifying the property to be set.
                  (CM_DRP_*)

   Buffer         Supplies the address of the buffer that contains the
                  registry data.  This data must be of the proper type
                  for that property.

   ulLength       Supplies the number of bytes of registry data to write.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_OUT_OF_MEMORY,
      CR_INVALID_DATA, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulRegDataType = 0;
    BYTE        NullBuffer = 0x0;
    handle_t    hBinding = NULL;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    PVOID       Buffer2 = NULL;
    PVOID       Buffer3 = NULL;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(ClassGUID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(
                ClassGUID,
                szStringGuid,
                MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if ((ulProperty < CM_CRP_MIN) || (ulProperty > CM_CRP_MAX)) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // we need to specify what registry data to use for storing this data
        //
        ulRegDataType = GetPropertyDataType(ulProperty);

        //
        // if data type is REG_DWORD, make sure size is right
        //
        if((ulRegDataType == REG_DWORD) && ulLength && (ulLength != sizeof(DWORD))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // if the register is CM_CRP_SECURITY_SDS, convert it
        //
        if (ulProperty == CM_CRP_SECURITY_SDS) {
            if (ulLength) {
                //
                // this form of CM_CRP_SECURITY provides a string that needs to be converted to binary
                //
                PCWSTR UnicodeSecDesc = (PCWSTR)Buffer;

                Buffer2 = pSetupConvertTextToSD(UnicodeSecDesc,&ulLength);
                if (Buffer2 == NULL) {
                    //
                    // If last error is ERROR_SCE_DISABLED, then the failure is
                    // due to SCE APIs being "turned off" on Embedded.  Treat
                    // this as a (successful) no-op...
                    //
                    if(GetLastError() == ERROR_SCE_DISABLED) {
                        Status = CR_SUCCESS;
                    } else {
                        Status = CR_INVALID_DATA;
                    }
                    goto Clean0;
                }
                Buffer = Buffer2;
            }
            ulProperty = CM_CRP_SECURITY;
            ulRegDataType = REG_BINARY;
        }

        //
        // if data type is REG_SZ, make sure it is NULL terminated
        //
        if ((ulRegDataType == REG_SZ) && (ulLength != 0)) {

            HRESULT hr;
            size_t  BufferLen = 0;

            //
            // Check the length of the string specified, up to the number of
            // bytes specified.
            //
            hr = StringCbLength(Buffer, ulLength, &BufferLen);

            if (SUCCEEDED(hr)) {
                //
                // The specified buffer was NULL terminated before ulLength
                // bytes.  Use the specified buffer, specifying the length of
                // the string we just calculated.  The registry APIs will store
                // the size of the REG_SZ value data exactly as specified
                // (regardless of the actual string length), so we need to make
                // sure this is correct.
                //
                ASSERT(BufferLen < ulLength);
                ulLength = (ULONG)(BufferLen + sizeof(WCHAR));

            } else {
                //
                // The specified buffer was not NULL terminated before ulLength
                // bytes.  Allocate a new buffer that can hold a NULL terminated
                // version of the string data supplied.
                //
                BufferLen = ulLength + sizeof(WCHAR);

                Buffer3 = pSetupMalloc((DWORD)BufferLen);

                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // Copy the source data to the destination buffer, up to the
                // length of the destination, including terminating NULL.
                //
                // Ignore the return error because the source buffer may not be
                // NULL terminated, immediately beyond the number of bytes
                // specified as its length (ulLength), in which case truncation
                // will occur (at the ulLength originally specified for the
                // source), and an error is returned.  This is ok, since we are
                // guaranteed that the destination buffer is NULL terminated.
                //
                StringCbCopy(Buffer3, BufferLen, Buffer);

                Buffer = Buffer3;
                ulLength = (ULONG)BufferLen;
            }
        }

        //
        // if data type is REG_MULTI_SZ, make sure it is double-NULL terminated
        //
        if ((ulRegDataType == REG_MULTI_SZ) && (ulLength != 0)) {

            ULONG ulNewLength;
            PWSTR tmpBuffer, bufferEnd;

            ulLength &= ~(ULONG)1;
            tmpBuffer = (PWSTR)Buffer;
            bufferEnd = (PWSTR)((PUCHAR)tmpBuffer + ulLength);
            ulNewLength = ulLength;

            while ((tmpBuffer < bufferEnd) && (*tmpBuffer != L'\0')) {

                while ((tmpBuffer < bufferEnd) && (*tmpBuffer != L'\0')) {

                    tmpBuffer++;
                }
                if (tmpBuffer >= bufferEnd) {

                    ulNewLength += sizeof(WCHAR);
                } else {

                    tmpBuffer++;
                }
            }
            if (tmpBuffer >= bufferEnd) {

                ulNewLength += sizeof(WCHAR);
            } else {

                ulNewLength = ((ULONG)(tmpBuffer - (PWSTR)Buffer) + 1) * sizeof(WCHAR);
            }
            if (ulNewLength > ulLength) {

                Buffer3 = pSetupMalloc(ulNewLength);
                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                CopyMemory(Buffer3, Buffer, ulLength);
                ZeroMemory((PUCHAR)Buffer3 + ulLength, ulNewLength - ulLength);
                Buffer = Buffer3;
            }
            ulLength = ulNewLength;
        }

        //
        // NOTE - When calling a PNP RPC server stub routine that marshalls
        // data between client and server buffers, be very careful to check
        // the corresponding server stub definition in the IDL file for the
        // [in] and/or [out] attributes of the parameters, and which
        // parameters are used to describe the [size_is] and/or [length_is]
        // attributes of a buffer.  Each of the PNP RPC server stub routines
        // behave in differently, so make sure you know what you are doing!!
        //

        //
        // PNP_SetClassRegProp -
        //
        //   Note that the [in] ulLength parameter is used for the [size_is]
        //   attributes of the [in] Buffer.  This indicates both the amount of
        //   memory the stubs must allocate, as well as the amount of data that
        //   must be marshalled.  Note that no data is marshalled by the stubs
        //   to the client since Buffer is [in] only.
        //

        //
        // Even though we may specify 0 bytes as the value of the [size_is]
        // attribute for the [in] Buffer, the Buffer itself must not be
        // NULL.  If the caller supplied a NULL Buffer, supply a local
        // pointer to the stubs instead.
        //
        if (Buffer == NULL) {
            Buffer = &NullBuffer;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetClassRegProp(
                hBinding,               // rpc binding handle
                szStringGuid,           // string representation of class
                ulProperty,             // string name for property
                ulRegDataType,          // specifies registry data type
                (LPBYTE)Buffer,         // specifies registry data
                ulLength,               // specifies amount of data in Buffer
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetClassRegProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        Buffer2 = Buffer2;
        Buffer3 = Buffer3;
    }

    if (Buffer2) {
        //
        // SceSvc requires LocalFree
        //
        LocalFree(Buffer2);
    }

    if (Buffer3) {
        pSetupFree(Buffer3);
    }

    return Status;

} // CM_Set_Class_Registry_Property_ExW



CONFIGRET
CM_Open_DevNode_Key_Ex(
    IN  DEVINST        dnDevNode,
    IN  REGSAM         samDesired,
    IN  ULONG          ulHardwareProfile,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkDevice,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )

/*++

Routine Description:

   This routine opens the software storage registry key associated with a
   device instance.

   Parameters:

   dnDevNode         Handle of a device instance.  This handle is typically
                     retrieved by a call to CM_Locate_DevNode or
                     CM_Create_DevNode.

   samDesired        Specifies an access mask that describes the desired
                     security access for the key.  This parameter can be
                     a combination of the values used in calls to RegOpenKeyEx.

   ulHardwareProfile Supplies the handle of the hardware profile to open the
                     storage key under.  This parameter is only used if the
                     CM_REGISTRY_CONFIG flag is specified in ulFlags.  If
                     this parameter is 0, the API uses the current hardware
                     profile.

   Disposition       Specifies how the registry key is to be opened.  May be
                     one of the following values:

                     RegDisposition_OpenAlways - Open the key if it exists,
                         otherwise, create the key.
                     RegDisposition_OpenExisting - Open the key only if it
                         exists, otherwise fail with CR_NO_SUCH_REGISTRY_VALUE.

   phkDevice         Supplies the address of the variable that receives an
                     opened handle to the specified key.  When access to this
                     key is completed, it must be closed via RegCloseKey.

   ulFlags           Specifies what type of storage key should be opened.
                     Can be a combination of these values:

                     CM_REGISTRY_HARDWARE (0x00000000)
                        Open a key for storing driver-independent information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Enum\<enumerator>\
                            <DeviceID>\<InstanceID>\Device Parameters

                     CM_REGISTRY_SOFTWARE (0x00000001)
                        Open a key for storing driver-specific information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Control\Class\
                            <DevNodeClass>\<ClassInstanceOrdinal>

                     CM_REGISTRY_USER (0x00000100)
                        Open a key under HKEY_CURRENT_USER instead of
                        HKEY_LOCAL_MACHINE.  This flag may not be used with
                        CM_REGISTRY_CONFIG.  There is no analagous kernel-mode
                        API on NT to get a per-user device configuration
                        storage, since this concept does not apply to device
                        drivers (no user may be logged on, etc).  However,
                        this flag is provided for consistency with Win95, and
                        because it is foreseeable that it could be useful to
                        Win32 services that interact with Plug-and-Play model.

                     CM_REGISTRY_CONFIG (0x00000200)
                        Open the key under a hardware profile branch instead
                        of HKEY_LOCAL_MACHINE.  If this flag is specified,
                        then ulHardwareProfile supplies the handle of the
                        hardware profile to be used.  This flag may not be
                        used with CM_REGISTRY_USER.

   hMachine          Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVICE_ID,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    PWSTR       pszMachineName = NULL;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    HKEY        hKey=NULL, hRemoteKey=NULL, hBranchKey=NULL;
    PWSTR       pszKey = NULL, pszPrivateKey = NULL;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(phkDevice)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phkDevice = NULL;

        if (dnDevNode == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTRY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (INVALID_FLAGS(Disposition, RegDisposition_Bits)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if ((ulFlags & CM_REGISTRY_CONFIG)  &&
            (ulHardwareProfile > MAX_CONFIG_VALUE)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // current user key can't be remoted
        //
        if ((hBinding != hLocalBindingHandle) && (ulFlags & CM_REGISTRY_USER)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // retrieve the device id string and validate it
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevNode,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // determine the branch key to use; either HKLM or HKCU
        //-------------------------------------------------------------

        if (hBinding == hLocalBindingHandle) {

            if (ulFlags & CM_REGISTRY_USER) {
                //
                // current user key specified
                //
                hBranchKey = HKEY_CURRENT_USER;

            } else {
                //
                // all other cases go to HKLM
                //
                hBranchKey = HKEY_LOCAL_MACHINE;
            }
        }
        else {
            //
            // retrieve machine name
            //
            pszMachineName = pSetupMalloc((MAX_PATH + 3)*sizeof(WCHAR));
            if (pszMachineName == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            if (!PnPRetrieveMachineName(hMachine, pszMachineName)) {
                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }

            //
            // use remote HKLM branch (we only support connect to
            // HKEY_LOCAL_MACHINE on the remote machine, not HKEY_CURRENT_USER)
            //
            RegStatus = RegConnectRegistry(pszMachineName,
                                           HKEY_LOCAL_MACHINE,
                                           &hRemoteKey);

            pSetupFree(pszMachineName);
            pszMachineName = NULL;

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // hBranchKey is either a predefined key or assigned to by
            // another key, I never attempt to close it. If hRemoteKey is
            // non-NULL I will attempt to close it during cleanup since
            // it is explicitly opened.
            //
            hBranchKey = hRemoteKey;
        }

        //
        // allocate some buffer space to work with
        //
        pszKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszPrivateKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszPrivateKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // form the registry path based on the device id and the flags.
        //
        // note that in some cases, GetDevNodeKeyPath may call
        // PNP_GetClassInstance or PNP_SetDeviceRegProp to set values or create
        // keys on the server, in which case special write access would be
        // required by the server, but no special privilges are required.
        //
        Status =
            GetDevNodeKeyPath(
                hBinding,
                pDeviceID,
                ulFlags,
                ulHardwareProfile,
                pszKey,
                MAX_CM_PATH,
                pszPrivateKey,
                MAX_CM_PATH,
                (Disposition == RegDisposition_OpenAlways));

        //
        // Failed to get devnode key path components
        //
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Build the full key path
        //
        ASSERT(pszKey[0] != L'\0');
        ASSERT(pszPrivateKey[0] != L'\0');

        if (FAILED(StringCchCat(
                       pszKey,
                       MAX_CM_PATH,
                       L"\\"))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (FAILED(StringCchCat(
                       pszKey,
                       MAX_CM_PATH,
                       pszPrivateKey))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        pSetupFree(pszPrivateKey);
        pszPrivateKey = NULL;

        //
        // open the registry key (method of open is based on flags)
        //
        if (Disposition == RegDisposition_OpenAlways) {

            //-----------------------------------------------------
            // open the registry key always
            //-----------------------------------------------------

            //
            // Only the main Enum subtree under HKLM has strict security
            // that requires me to first create the key on the server
            // side and then open it here on the client side. This
            // condition currently only occurs if the flags have
            // CM_REGISTRY_HARDWARE set but no other flags set.
            //
            if (ulFlags == CM_REGISTRY_HARDWARE) {
                //
                // first try to open it (in case it already exists).  If it
                // doesn't exist, then I'll have to have the protected server
                // side create the key.  I still need to open it from here, the
                // client-side, so that the registry handle will be in the
                // caller's address space.
                //
                RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         pszKey,
                                         0,
                                         samDesired,
                                         phkDevice);

                if (RegStatus != ERROR_SUCCESS) {

                    //
                    // call server side to create the key
                    //

                    //
                    // Special privileges are no longer required by the server.
                    //
                    // Note that with previous versions of the PlugPlay RPC
                    // server, SE_LOAD_DRIVER_PRIVILEGE was required for this
                    // operation.  We do not need to enable the privilege for
                    // local callers, since this version of CFGMGR32 should
                    // match a local version of UMPNPMGR that does not require
                    // the privilege.  For remote calls, it's not always
                    // possible for us to enable the privilege anyways, since
                    // the client may not have the privilege on the local
                    // machine, but may as authenticated on the server.  The
                    // server typically sees all privileges that a remote caller
                    // has as "enabled by default", so we are not required to
                    // enable the privilege here either.
                    //

                    RpcTryExcept {
                        //
                        // call rpc service entry point
                        //
                        Status = PNP_CreateKey(
                            hBinding,
                            pDeviceID,
                            samDesired,
                            0);
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "PNP_CreateKey caused an exception (%d)\n",
                                   RpcExceptionCode()));

                        Status = MapRpcExceptionToCR(RpcExceptionCode());
                    }
                    RpcEndExcept

                    if (Status != CR_SUCCESS) {
                        *phkDevice = NULL;
                        goto Clean0;
                    }

                    //
                    // the key was created successfully, so open it now
                    //
                    RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                             pszKey,
                                             0,
                                             samDesired,
                                             phkDevice);

                    if (RegStatus == ERROR_ACCESS_DENIED) {
                        *phkDevice = NULL;
                        Status = CR_ACCESS_DENIED;
                        goto Clean0;
                    }
                    else if (RegStatus != ERROR_SUCCESS) {
                        //
                        // if we still can't open the key, I give up
                        //
                        *phkDevice = NULL;
                        Status = CR_REGISTRY_ERROR;
                        goto Clean0;
                    }
                }
            }

            else {
                //
                // these keys have admin-full privilege so try to open
                // from the client-side and just let the security of the
                // key judge whether the caller can access it.
                //
                RegStatus = RegCreateKeyEx(hBranchKey,
                                           pszKey,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           samDesired,
                                           NULL,
                                           phkDevice,
                                           NULL);

                if (RegStatus == ERROR_ACCESS_DENIED) {
                    *phkDevice = NULL;
                    Status = CR_ACCESS_DENIED;
                    goto Clean0;
                }
                else if (RegStatus != ERROR_SUCCESS) {
                    *phkDevice = NULL;
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }
            }
        }
        else {

            //-----------------------------------------------------
            // open only if it already exists
            //-----------------------------------------------------

            //
            // the actual open always occurs on the client side so I can
            // pass back a handle that's valid for the calling process.
            // Only creates need to happen on the server side
            //
            RegStatus = RegOpenKeyEx(hBranchKey,
                                     pszKey,
                                     0,
                                     samDesired,
                                     phkDevice);

            if (RegStatus == ERROR_ACCESS_DENIED) {
                *phkDevice = NULL;
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }
            else if (RegStatus != ERROR_SUCCESS) {
                *phkDevice = NULL;
                Status = CR_NO_SUCH_REGISTRY_KEY;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pszMachineName = pszMachineName;
        pszPrivateKey = pszPrivateKey;
        pszKey = pszKey;
        hKey = hKey;
        hRemoteKey = hRemoteKey;
    }

    if (pszMachineName) {
        pSetupFree(pszMachineName);
    }

    if (pszPrivateKey) {
        pSetupFree(pszPrivateKey);
    }

    if (pszKey) {
        pSetupFree(pszKey);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (hRemoteKey != NULL) {
        RegCloseKey(hRemoteKey);
    }

    return Status;

} // CM_Open_DevNode_Key_ExW



CONFIGRET
CM_Delete_DevNode_Key_Ex(
    IN DEVNODE dnDevNode,
    IN ULONG   ulHardwareProfile,
    IN ULONG   ulFlags,
    IN HANDLE  hMachine
    )

/*++

Routine Description:

   This routine deletes a registry storage key associated with a device
   instance.

   dnDevNode   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulHardwareProfile Supplies the handle of the hardware profile to delete
               the storage key under.  This parameter is only used if the
               CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this
               parameter is 0, the API uses the current hardware profile.
               If this parameter is 0xFFFFFFFF, then the specified storage
               key(s) for all hardware profiles is (are) deleted.

   ulFlags     Specifies what type(s) of storage key(s) should be deleted.
               Can be a combination of these values:

               CM_REGISTRY_HARDWARE - Delete the key for storing driver-
                  independent information relating to the device instance.
                  This may be combined with CM_REGISTRY_SOFTWARE to delete
                  both device and driver keys simultaneously.
               CM_REGISTRY_SOFTWARE - Delete the key for storing driver-
                  specific information relating to the device instance.
                  This may be combined with CM_REGISTRY_HARDWARE to
                  delete both driver and device keys simultaneously.
               CM_REGISTRY_USER - Delete the specified key(s) under
                  HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.
                  This flag may not be used with CM_REGISTRY_CONFIG.
               CM_REGISTRY_CONFIG - Delete the specified keys(s) under a
                  hardware profile branch instead of HKEY_LOCAL_MACHINE.
                  If this flag is specified, then ulHardwareProfile
                  supplies the handle to the hardware profile to be used.
                  This flag may not be used with CM_REGISTRY_USER.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    HKEY        hKey = NULL;
    PWSTR       pszParentKey = NULL, pszChildKey = NULL, pszRegStr = NULL;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevNode == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTRY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // can't specify both user-specific and config-specific flags
        //
        if ((ulFlags & CM_REGISTRY_USER) && (ulFlags & CM_REGISTRY_CONFIG)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device id string and validate it
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevNode,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // allocate some buffer space to work with
        //
        pszParentKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszParentKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszChildKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszChildKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegStr = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // form the registry path based on the device id and the flags.
        //
        Status =
            GetDevNodeKeyPath(
                hBinding,
                pDeviceID,
                ulFlags,
                ulHardwareProfile,
                pszParentKey,
                MAX_CM_PATH,
                pszChildKey,
                MAX_CM_PATH,
                FALSE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //------------------------------------------------------------------
        // For both hardware and software USER keys, the client must be
        // granted access to delete (the keys are in the user's own hive).
        // The server side does not access any HKEY_CURRENT_USER keys.
        //------------------------------------------------------------------

        if (ulFlags & CM_REGISTRY_USER) {

            //
            // Not config-specific, just delete the specified key on the client.
            //
            ASSERT(!(ulFlags & CM_REGISTRY_CONFIG));

            Status = DeletePrivateKey(HKEY_CURRENT_USER,
                                      pszParentKey,
                                      pszChildKey);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        }

        //------------------------------------------------------------------
        // For the remaining cases (no user keys), do the work on the
        // server side, since that side has the code to make the key
        // volatile if necessary instead of deleting. Also, access to
        // these registry keys is granted to SYSTEM only.
        //------------------------------------------------------------------

        else {
            //
            // If not config-specific, just set the flags to 0; it will not be
            // used by the server.
            //
            if (!(ulFlags & CM_REGISTRY_CONFIG)) {
                ulHardwareProfile = 0;
            }

            //
            // NOTICE-2002/03/11-jamesca: Logic for profile-specific behavior.
            //   If the config-specific flag was specified, and a specific
            // hardware profile was targeted, GetDevNodeKeyPath formed the exact
            // config-specific parent/child key paths for the specified hardware
            // profile above, and the server will ignore the profile specified.
            //   If the config-specific flag was specified, but the hardware
            // profile targeted was 0 (current profile) or 0xFFFFFFFF (all
            // profiles), the parent/child paths formed contain printf-style
            // replacement characters, and ulHardwareProfile is relevant to the
            // server to determine which of the two cases it is handling.
            //

            //
            // Special privileges are no longer required by the server.
            //
            // Note that with previous versions of the PlugPlay RPC server,
            // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do
            // not need to enable the privilege for local callers, since this
            // version of CFGMGR32 should match a local version of UMPNPMGR that
            // does not require the privilege.  For remote calls, it's not
            // always possible for us to enable the privilege anyways, since the
            // client may not have the privilege on the local machine, but may
            // as authenticated on the server.  The server typically sees all
            // privileges that a remote caller has as "enabled by default", so
            // we are not required to enable the privilege here either.
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_DeleteRegistryKey(
                    hBinding,               // rpc binding handle
                    pDeviceID,              // device id
                    pszParentKey,           // parent of key to delete
                    pszChildKey,            // key to delete
                    ulHardwareProfile);     // flags, not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_DeleteRegistryKey caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        hKey = hKey;
        pszRegStr = pszRegStr;
        pszChildKey = pszChildKey;
        pszParentKey = pszParentKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pszRegStr) {
        pSetupFree(pszRegStr);
    }

    if (pszChildKey) {
        pSetupFree(pszChildKey);
    }

    if (pszParentKey) {
        pSetupFree(pszParentKey);
    }

    return Status;

} // CM_Delete_DevNode_Key_Ex



CONFIGRET
CM_Open_Class_Key_ExW(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCWSTR        pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )

/*++

Routine Description:

   This routine opens the class registry key, and optionally, a specific
   class's subkey.

Parameters:

   ClassGuid   Optionally, supplies the address of a class GUID representing
               the class subkey to be opened.

   pszClassName Specifies the string form of the class name for the class
                represented by ClassGuid.  This parameter is only valid if
                the CM_OPEN_CLASS_KEY_INSTALLER flag is set in the ulFlags
                parameter.  If specified, this string will replace any existing
                class name associated with this setup class GUID.

                This parameter must be set to NULL if the
                CM_OPEN_CLASS_KEY_INTERFACE bit is set in the ulFlags parameter.

   samDesired  Specifies an access mask that describes the desired security
               access for the new key. This parameter can be a combination
               of the values used in calls to RegOpenKeyEx.

   Disposition Specifies how the registry key is to be opened. May be one
               of the following values:
               RegDisposition_OpenAlways - Open the key if it exists,
                  otherwise, create the key.
               RegDisposition_OpenExisting - Open the key f it exists,
                  otherwise, fail with CR_NO_SUCH_REGISTRY_KEY.

   phkClass    Supplies the address of the variable that receives an opened
               handle to the specified key.  When access to this key is
               completed, it must be closed via RegCloseKey.

   ulFlags     May be one of the following values:

               CM_OPEN_CLASS_KEY_INSTALLER - open/create a setup class key for
                   the specified GUID under
                   HKLM\System\CurrentControlSet\Control\Class.

               CM_OPEN_CLASS_KEY_INTERFACE - open/create a device interface
                   class key for the specified GUID under
                   HKLM\System\CurrentControlSet\Control\DeviceClasses.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hRootKey = NULL, hRemoteKey = NULL;
    PWSTR       pszMachineName = NULL, pszRegStr = NULL;
    PVOID       hStringTable = NULL;
    size_t      ClassNameLen = 0;

    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(phkClass)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phkClass = NULL;

        if (INVALID_FLAGS(Disposition, RegDisposition_Bits)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_OPEN_CLASS_KEY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // If ulFlags == CM_OPEN_CLASS_KEY_INTERFACE then pszClassName had
        // better be NULL.
        //
        if ((ulFlags == CM_OPEN_CLASS_KEY_INTERFACE) &&
            (ARGUMENT_PRESENT(pszClassName))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // if a class name was specified, make sure it's valid.
        //
        if (ARGUMENT_PRESENT(pszClassName)) {

            if (FAILED(StringCchLength(
                           pszClassName,
                           MAX_CLASS_NAME_LEN,
                           &ClassNameLen))) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            ASSERT(ClassNameLen < MAX_CLASS_NAME_LEN);

            if (ClassNameLen == 0) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }
        }

        //
        // get reg key for HKEY_LOCAL_MACHINE
        //
        if (hMachine == NULL) {
            //
            // local call
            //
            hRootKey = HKEY_LOCAL_MACHINE;
        }
        else {
            //
            // setup string table handle
            //
            if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // retrieve machine name
            //
            pszMachineName = pSetupMalloc((MAX_PATH + 3)*sizeof(WCHAR));
            if (pszMachineName == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            if (!PnPRetrieveMachineName(hMachine, pszMachineName)) {
                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }

            //
            // connect to HKEY_LOCAL_MACHINE on remote machine
            //
            RegStatus = RegConnectRegistry(pszMachineName,
                                           HKEY_LOCAL_MACHINE,
                                           &hRemoteKey);

            pSetupFree(pszMachineName);
            pszMachineName = NULL;

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            hRootKey = hRemoteKey;
        }

        //
        // allocate some buffer space to work with
        //
        pszRegStr = pSetupMalloc(MAX_PATH*sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Form the registry path
        //
        if (ulFlags == CM_OPEN_CLASS_KEY_INTERFACE) {
            //
            // Form the path for the "DeviceClasses" key
            //
            if (FAILED(StringCchCopy(
                           pszRegStr,
                           MAX_PATH,
                           pszRegPathDeviceClass))) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        } else {
            //
            // Form the path for the "Class" key
            //
            if (FAILED(StringCchCopy(
                           pszRegStr,
                           MAX_PATH,
                           pszRegPathClass))) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        if (ARGUMENT_PRESENT(ClassGuid)) {
            //
            // Optional class guid was specified
            //
            WCHAR szStringGuid[MAX_GUID_STRING_LEN];

            if (pSetupStringFromGuid(
                    ClassGuid,
                    szStringGuid,
                    MAX_GUID_STRING_LEN) != NO_ERROR) {
                ASSERT(0);
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Append "\{ClassGUID}" to the existing path
            //
            if (FAILED(StringCchCat(
                           pszRegStr,
                           MAX_PATH,
                           L"\\"))) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (FAILED(StringCchCat(
                           pszRegStr,
                           MAX_PATH,
                           szStringGuid))) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //
        // attempt to open/create that key
        //
        if (Disposition == RegDisposition_OpenAlways) {

            ULONG ulDisposition;

            RegStatus = RegCreateKeyEx(hRootKey, pszRegStr, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, samDesired,
                                       NULL, phkClass, &ulDisposition);

        } else {
            RegStatus = RegOpenKeyEx(hRootKey, pszRegStr, 0, samDesired,
                                     phkClass);
        }

        if ((ARGUMENT_PRESENT(pszClassName)) && (RegStatus == ERROR_SUCCESS)) {
            RegSetValueEx(*phkClass,
                          pszRegValueClass,
                          0,
                          REG_SZ,
                          (LPBYTE)pszClassName,
                          (DWORD)((ClassNameLen+1)*sizeof(WCHAR)));
        }

        if (RegStatus != ERROR_SUCCESS) {
            *phkClass = NULL;
            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pszMachineName = pszMachineName;
        pszRegStr = pszRegStr;
        hRemoteKey = hRemoteKey;
    }

    if (pszMachineName != NULL) {
        pSetupFree(pszMachineName);
    }

    if (pszRegStr != NULL) {
        pSetupFree(pszRegStr);
    }

    if (hRemoteKey != NULL) {
        RegCloseKey(hRemoteKey);
    }

    return Status;

} // CM_Open_Class_Key_ExW



CONFIGRET
CM_Enumerate_Classes_Ex(
    IN  ULONG      ulClassIndex,
    OUT LPGUID     ClassGuid,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine enumerates the installed classes in the system.  It
   retrieves the GUID string for a single class each time it is called.
   To enumerate installed classes, an application should initially call the
   CM_Enumerate_Classes function with the ulClassIndex parameter set to
   zero. The application should then increment the ulClassIndex parameter
   and call CM_Enumerate_Classes until there are no more classes (until the
   function returns CR_NO_SUCH_VALUE).

   It is possible to receive a CR_INVALID_DATA error while enumerating
   installed classes.  This may happen if the registry key represented by
   the specified index is determined to be an invalid class key.  Such keys
   should be ignored during enumeration.

Parameters:

   ulClassIndex   Supplies the index of the class to retrieve the class
                  GUID string for.

   ClassGuid      Supplies the address of a variable that receives the GUID
                  for the class whose index is specified by ulClassIndex.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];
    ULONG       ulLength = MAX_GUID_STRING_LEN;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(ClassGuid)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize guid struct
        //
        ZeroMemory(ClassGuid, sizeof(GUID));

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_EnumerateSubKeys(
                hBinding,            // rpc binding handle
                PNP_CLASS_SUBKEYS,   // subkeys of class branch
                ulClassIndex,        // index of class key to enumerate
                szClassGuid,         // will contain class name
                ulLength,            // length of Buffer in chars,
                &ulLength,           // size copied (or size required)
                ulFlags);            // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_EnumerateSubKeys caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            if (pSetupGuidFromString(szClassGuid, ClassGuid) != NO_ERROR) {
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enumerate_Classes_Ex



CONFIGRET
CM_Get_Class_Name_ExW(
    IN  LPGUID     ClassGuid,
    OUT PWCHAR     Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )


/*++

Routine Description:

   This routine retrieves the class name associated with the specified
   class GUID string.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID whose name
                  is to be retrieved.

   Buffer         Supplies the address of the character buffer that receives
                  the class name corresponding to the specified GUID.

   pulLength      Supplies the address of the variable that contains the
                  length, in characters, of the Buffer.  Upon return, this
                  variable will contain the number of characters (including
                  terminating NULL) written to Buffer (if the supplied buffer
                  isn't large enough, then the routine will fail with
                  CR_BUFFER_SMALL, and this value will indicate how large the
                  buffer needs to be in order to succeed).

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(ClassGuid)) ||
            (!ARGUMENT_PRESENT(Buffer))    ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(
                ClassGuid,
                szStringGuid,
                MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetClassName(
                hBinding,            // rpc binding handle
                szStringGuid,
                Buffer,
                pulLength,           // returns count of keys under Class
                ulFlags);            // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetClassName caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Name_ExW



CONFIGRET
CM_Get_Class_Key_Name_ExW(
    IN  LPGUID     ClassGuid,
    OUT LPWSTR     pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine retrieves the class name associated with the specified
   class GUID string.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID whose name
                  is to be retrieved.

   pszKeyName     Returns the name of the class key in the registry that
                  corresponds to the specified ClassGuid. The returned key
                  name is relative to
                  HKLM\System\CurrentControlSet\Control\Class.

   pulLength      Supplies the address of the variable that contains the
                  length, in characters, of the Buffer.  Upon return, this
                  variable will contain the number of characters (including
                  terminating NULL) written to Buffer (if the supplied buffer
                  isn't large enough, then the routine will fail with
                  CR_BUFFER_SMALL, and this value will indicate how large the
                  buffer needs to be in order to succeed).

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    //
    // NOTE: the supplied machine handle is never referenced by this routine,
    // since it is known/assumed that the key name of the class key requested is
    // always just the string representation of the supplied class GUID.
    // there is no corresponding UMPNPMGR server-side routine.
    //
    UNREFERENCED_PARAMETER(hMachine);

    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(ClassGuid)) ||
            (!ARGUMENT_PRESENT(pszKeyName))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (*pulLength < MAX_GUID_STRING_LEN) {
            *pulLength = MAX_GUID_STRING_LEN;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(
                ClassGuid,
                pszKeyName,
                MAX_GUID_STRING_LEN) == NO_ERROR) {
            *pulLength = MAX_GUID_STRING_LEN;
        } else {
            Status = CR_INVALID_DATA;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Key_Name_ExW



CONFIGRET
CM_Delete_Class_Key_Ex(
    IN  LPGUID     ClassGuid,
    IN  ULONG      ulFlags,
    IN  HANDLE     hMachine
    )

/*++

Routine Description:

   This routine deletes the specified class key from the registry.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID to delete.

   ulFlags        Must be one of the following values:
                  CM_DELETE_CLASS_ONLY - only deletes the class key if it
                                         doesn't have any subkeys.
                  CM_DELETE_CLASS_SUBKEYS - deletes the class key and any
                                            subkeys of the class key.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(ClassGuid)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_DELETE_CLASS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(
                ClassGuid,
                szStringGuid,
                MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeleteClassKey(
                hBinding,            // rpc binding handle
                szStringGuid,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeleteClassKey caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Delete_Class_Key_Ex



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    IN     LPCWSTR  pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPWSTR   pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    ULONG       ulTransferLen = 0;

    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pszDeviceInterface)) ||
            (!ARGUMENT_PRESENT(AliasInterfaceGuid)) ||
            (!ARGUMENT_PRESENT(pszAliasDeviceInterface)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pszAliasDeviceInterface = L'\0';
        ulTransferLen = *pulLength;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceAlias(
                hBinding,
                pszDeviceInterface,
                AliasInterfaceGuid,
                pszAliasDeviceInterface,
                pulLength,
                &ulTransferLen,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceAlias caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_Alias_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    OUT PWCHAR      Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns a list of interface devices of the specified interface
   class. You can optionally filter the list of returned interface devices
   based on only those created by a particular devinst. Typically the
   CM_Get_Interface_Device_List routine is called first to determine how big
   a buffer must be allocated to hold the interface device list.

Parameters:

   InterfaceClassGuid    This GUID specifies which interface devices to return (only
                         those interface devices that belong to this interface class).

   pDeviceID        Optional devinst to filter the list of returned interface
                    devices (if non-zero, only the interfaces devices associated
                    with this devinst will be returned).

   Buffer           Supplies the buffer that will contain the returned multi_sz
                    list of interface devices.

   BufferLen        Specifies how big the Buffer parameter is in characters.

   ulFlags          Must be one of the following values:

                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT -
                                only currently 'live' devices
                    CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES 0x00000001 -
                                all registered devices, live or not

   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceList(
                hBinding,            // RPC Binding Handle
                InterfaceClassGuid,  // Device interface GUID
                pDeviceID,           // filter string, optional
                Buffer,              // will contain device list
                &BufferLen,          // in/out size of Buffer
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceList caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_List_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns the size (in characters) of buffer required to hold a
   multi_sz list of interface devices of the specified interface class. You
   can optionally filter the list of returned interface devices based on only
   those created by a particular devinst. This routine is typically called before
   a call to the CM_Get_Interface_Device_List routine.

Parameters:

   pulLen           On a successful return from this routine, this parameter
                    will contain the size (in characters) required to hold the
                    multi_sz list of returned interface devices.

   InterfaceClassGuid    This GUID specifies which interface devices to include (only
                         those interface devices that belong to this interface class).

   pDeviceID        Optional devinst to filter the list of returned interface
                    devices (if non-zero, only the interfaces devices associated
                    with this devinst will be returned).

   ulFlags          Must be one of the following values:

                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT -
                                only currently 'live' devices
                    CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES -
                                all registered devices, live or not

   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pulLen = 0;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceListSize(
                hBinding,            // RPC Binding Handle
                pulLen,              // Size of buffer required (in chars)
                InterfaceClassGuid,  // Device interface GUID
                pDeviceID,           // filter string, optional
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceListSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_List_Size_Ex



CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCWSTR   pszReference          OPTIONAL,
    OUT LPWSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

Parameters:


   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pszDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTransferLen,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pszDeviceInterface)) ||
            (!ARGUMENT_PRESENT(InterfaceClassGuid))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnParent
        // (note that this is not optional, even a first level device instance
        // has a parent (the root device instance)
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pszDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // ulTransferLen is just used to control how many bytes in the
        // pszInterfaceDevice buffer must be marshalled. We need two
        // length params, since pulLength may contained the required bytes
        // (if the passed in buffer was too small) which may differ from
        // how many types are actually available to marshall (in the buffer
        // too small case, we'll marshall zero so ulTransferLen will be zero
        // but pulLength will describe how many bytes are required to hold
        // the Interface Device string.
        //
        ulTransferLen = *pulLength;

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterDeviceClassAssociation(
                hBinding,            // RPC Binding Handle
                pszDeviceID,         // device instance
                InterfaceClassGuid,  // Device interface GUID
                pszReference,        // reference string, optional
                pszDeviceInterface,  // returns interface device name
                pulLength,           // pszInterfaceDevice buffer required in chars
                &ulTransferLen,      // how many chars to marshall back
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RegisterDeviceClassAssociation caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Register_Device_Interface



CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
    IN LPCWSTR  pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

Parameters:


   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pszDeviceInterface)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Special privileges are no longer required by the server.
        //
        // Note that with previous versions of the PlugPlay RPC server,
        // SE_LOAD_DRIVER_PRIVILEGE was required for this operation.  We do not
        // need to enable the privilege for local callers, since this version of
        // CFGMGR32 should match a local version of UMPNPMGR that does not
        // require the privilege.  For remote calls, it's not always possible
        // for us to enable the privilege anyways, since the client may not have
        // the privilege on the local machine, but may as authenticated on the
        // server.  The server typically sees all privileges that a remote
        // caller has as "enabled by default", so we are not required to enable
        // the privilege here either.
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UnregisterDeviceClassAssociation(
                hBinding,            // RPC Binding Handle
                pszDeviceInterface,  // interface device
                ulFlags);            // unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_UnregisterDeviceClassAssociation caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Unregister_Device_Interface_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExW(
    IN  DEVINST     dnDevInst,
    IN  PCWSTR      pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified property, either from the devnode's
   device (aka, hardware) key, or from the most-specific per-hardware-id
   storage key for that devnode.

Parameters:

   dnDevInst   Supplies the handle of the device instance for which a
               custom property is to be retrieved.

   pszCustomPropertyName  Supplies a string identifying the name of the
                          property (registry value entry name) to be retrieved.

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     May be a combination of the following values:

               CM_CUSTOMDEVPROP_MERGE_MULTISZ : merge the devnode-specific
                   REG_SZ or REG_MULTI_SZ property (if present) with the
                   per-hardware-id REG_SZ or REG_MULTI_SZ property (if
                   present).  The result will always be a REG_MULTI_SZ.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

    If the function succeeds, the return value is CR_SUCCESS.

    If the function fails, the return value indicates the cause of failure, and
    is typically one of the following:
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_INVALID_POINTER,
       CR_REGISTRY_ERROR,
       CR_BUFFER_SMALL,
       CR_NO_SUCH_VALUE, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulSizeID, ulTempDataType = 0, ulTransferLen = 0;
    BYTE        NullBuffer = 0;
    handle_t    hBinding;
    PVOID       hStringTable;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if(dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if(!ARGUMENT_PRESENT(pszCustomPropertyName)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(INVALID_FLAGS(ulFlags, CM_CUSTOMDEVPROP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if(!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        ulSizeID = SIZECHARS(pDeviceID);
        Success = pSetupStringTableStringFromIdEx(hStringTable,
                                                  dnDevInst,
                                                  pDeviceID,
                                                  &ulSizeID
                                                 );

        if(!Success || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // NOTE - When calling a PNP RPC server stub routine that marshalls
        // data between client and server buffers, be very careful to check
        // the corresponding server stub definition in the IDL file for the
        // [in] and/or [out] attributes of the parameters, and which
        // parameters are used to describe the [size_is] and/or [length_is]
        // attributes of a buffer.  Each of the PNP RPC server stub routines
        // behave in differently, so make sure you know what you are doing!!
        //

        //
        // PNP_GetCustomDevProp -
        //
        //   Note that ulTransferLen is specified as an [out] parameter
        //   only.  Since Buffer also has the [out] attribute only,
        //   ulTransferLen is NOT used or needed on entry to indicate how
        //   much data to marshall to the server.  The value of
        //   ulTransferLen is set by the server, and is only used upon
        //   return to indicate how much data to marshall back to the client
        //   Buffer.
        //

        //
        // Even though we may specify 0 bytes as the value of the [size_is]
        // attribute for the [out] Buffer, the Buffer itself must not be
        // NULL.  If the caller supplied a NULL Buffer, supply a local
        // pointer to the stubs instead.
        //
        if(Buffer == NULL) {
            Buffer = &NullBuffer;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetCustomDevProp(
                hBinding,               // rpc binding handle
                pDeviceID,              // string representation of device instance
                pszCustomPropertyName,  // name of the property
                &ulTempDataType,        // receives registry data type
                Buffer,                 // receives registry data
                &ulTransferLen,         // input/output buffer size
                pulLength,              // bytes copied (or bytes required)
                ulFlags);               // flags (e.g., merge-multi-sz?)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetCustomDevProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if(pulRegDataType) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Custom_Property_ExW



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Get_DevNode_Registry_PropertyW(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Registry_Property_ExW(dnDevInst, ulProperty,
                                                pulRegDataType, Buffer,
                                                pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_DevNode_Registry_PropertyA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Registry_Property_ExA(dnDevInst, ulProperty,
                                                pulRegDataType, Buffer,
                                                pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Registry_PropertyW(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags
    )
{
    return CM_Set_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, Buffer,
                                                ulLength, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Registry_PropertyA(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags
    )
{
    return CM_Set_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, Buffer,
                                                ulLength, ulFlags, NULL);
}


CONFIGRET
CM_Open_DevNode_Key(
    IN  DEVINST        dnDevNode,
    IN  REGSAM         samDesired,
    IN  ULONG          ulHardwareProfile,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkDevice,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_DevNode_Key_Ex(dnDevNode, samDesired, ulHardwareProfile,
                                  Disposition, phkDevice, ulFlags, NULL);
}


CONFIGRET
CM_Delete_DevNode_Key(
    IN DEVNODE dnDevNode,
    IN ULONG   ulHardwareProfile,
    IN ULONG   ulFlags
    )

{
    return CM_Delete_DevNode_Key_Ex(dnDevNode, ulHardwareProfile,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Open_Class_KeyW(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCWSTR        pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_Class_Key_ExW(ClassGuid, pszClassName, samDesired,
                                 Disposition, phkClass, ulFlags, NULL);
}


CONFIGRET
CM_Open_Class_KeyA(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCSTR         pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_Class_Key_ExA(ClassGuid, pszClassName, samDesired,
                                 Disposition, phkClass, ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_Classes(
    IN ULONG      ulClassIndex,
    OUT LPGUID    ClassGuid,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Classes_Ex(ulClassIndex, ClassGuid, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_NameW(
    IN  LPGUID     ClassGuid,
    OUT PWCHAR     Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Name_ExW(ClassGuid, Buffer, pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_NameA(
    IN  LPGUID     ClassGuid,
    OUT PCHAR      Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Name_ExA(ClassGuid, Buffer, pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_Key_NameA(
    IN  LPGUID     ClassGuid,
    OUT LPSTR      pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Key_Name_ExA(ClassGuid, pszKeyName, pulLength,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_Key_NameW(
    IN  LPGUID     ClassGuid,
    OUT LPWSTR     pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Key_Name_ExW(ClassGuid, pszKeyName, pulLength,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Delete_Class_Key(
    IN  LPGUID     ClassGuid,
    IN  ULONG      ulFlags
    )
{
    return CM_Delete_Class_Key_Ex(ClassGuid, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    IN     LPCSTR  pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPSTR   pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    )
{
    return CM_Get_Device_Interface_Alias_ExA(pszDeviceInterface, AliasInterfaceGuid,
                                             pszAliasDeviceInterface, pulLength,
                                             ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    IN     LPCWSTR pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPWSTR  pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    )
{
    return CM_Get_Device_Interface_Alias_ExW(pszDeviceInterface, AliasInterfaceGuid,
                                             pszAliasDeviceInterface, pulLength,
                                             ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_ExA(InterfaceClassGuid, pDeviceID, Buffer,
                                            BufferLen, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    OUT PWCHAR      Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_ExW(InterfaceClassGuid, pDeviceID, Buffer,
                                            BufferLen, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_Size_ExA(pulLen, InterfaceClassGuid,
                                                 pDeviceID, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_Size_ExW(pulLen, InterfaceClassGuid,
                                                 pDeviceID, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
    IN  DEVINST  dnDevInst,
    IN  LPGUID   InterfaceClassGuid,
    IN  LPCSTR   pszReference           OPTIONAL,
    OUT LPSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG    ulFlags
    )
{
    return CM_Register_Device_Interface_ExA(dnDevInst, InterfaceClassGuid,
                                            pszReference, pszDeviceInterface,
                                            pulLength, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCWSTR   pszReference          OPTIONAL,
    OUT LPWSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags
    )
{
    return CM_Register_Device_Interface_ExW(dnDevInst, InterfaceClassGuid,
                                            pszReference, pszDeviceInterface,
                                            pulLength, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
    IN LPCSTR  pszDeviceInterface,
    IN ULONG   ulFlags
    )
{
    return CM_Unregister_Device_Interface_ExA(pszDeviceInterface, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
    IN LPCWSTR pszDeviceInterface,
    IN ULONG   ulFlags
    )
{
    return CM_Unregister_Device_Interface_ExW(pszDeviceInterface, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
    IN  DEVINST     dnDevInst,
    IN  PCWSTR      pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Custom_Property_ExW(dnDevInst,
                                              pszCustomPropertyName,
                                              pulRegDataType,
                                              Buffer,
                                              pulLength,
                                              ulFlags,
                                              NULL
                                             );
}

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyA(
    IN  DEVINST     dnDevInst,
    IN  PCSTR       pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Custom_Property_ExA(dnDevInst,
                                              pszCustomPropertyName,
                                              pulRegDataType,
                                              Buffer,
                                              pulLength,
                                              ulFlags,
                                              NULL
                                             );
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Get_DevNode_Registry_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType, UniLen;
    PWSTR       pUniBuffer;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLength)) {
        return CR_INVALID_POINTER;
    }

    if ((ulProperty < CM_DRP_MIN) || (ulProperty > CM_DRP_MAX)) {
        return CR_INVALID_PROPERTY;
    }

    //
    // examine datatype to see if need to convert return data
    //
    ulDataType = GetPropertyDataType(ulProperty);

    //
    // for all string type registry properties, we pass a Unicode buffer and
    // convert back to caller's ANSI buffer on return.  since the Unicode ->
    // ANSI conversion may involve DBCS chars, we can't make any assumptions
    // about the size of the required ANSI buffer relative to the size of the
    // require Unicode buffer, so we must always get the Unicode string buffer
    // and convert it whether a buffer was actually supplied by the caller or
    // not.
    //
    if ((ulDataType == REG_SZ) ||
        (ulDataType == REG_MULTI_SZ) ||
        (ulDataType == REG_EXPAND_SZ)) {

        //
        // first, call the Wide version with a zero-length buffer to retrieve
        // the size required for the Unicode property.
        //
        UniLen = 0;
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      NULL,
                                                      &UniLen,
                                                      ulFlags,
                                                      hMachine);
        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // allocate the required buffer.
        //
        pUniBuffer = pSetupMalloc(UniLen);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        //
        // call the Wide version to retrieve the Unicode property.
        //
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      pUniBuffer,
                                                      &UniLen,
                                                      ulFlags,
                                                      hMachine);

        //
        // We specifically allocated the buffer of the required size, so it
        // should always be large enough.
        //
        ASSERT(Status != CR_BUFFER_SMALL);

        if (Status == CR_SUCCESS) {
            //
            // do the ANSI conversion or retrieve the ANSI buffer size required.
            // this may be a single-sz or multi-sz string, so we pass in the
            // length, and let PnPUnicodeToMultiByte convert the entire buffer.
            //
            Status =
                PnPUnicodeToMultiByte(
                    pUniBuffer,
                    UniLen,
                    Buffer,
                    pulLength);
        }

        pSetupFree(pUniBuffer);

    } else {
        //
        // for the non-string registry data types, just pass call on through to
        // the Wide version
        //
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      Buffer,
                                                      pulLength,
                                                      ulFlags,
                                                      hMachine);
    }

    return Status;

} // CM_Get_DevNode_Registry_Property_ExA



CONFIGRET
CM_Set_DevNode_Registry_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    IN  PCVOID      Buffer              OPTIONAL,
    IN  ULONG       ulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType = 0, UniBufferSize = 0;
    PWSTR       pUniBuffer = NULL;
    PSTR        pAnsiString = NULL;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if ((ulProperty < CM_DRP_MIN) || (ulProperty > CM_DRP_MAX)) {
        return CR_INVALID_PROPERTY;
    }

    if (!ARGUMENT_PRESENT(Buffer)) {
        //
        // No need to convert the parameter
        //
        return CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                    ulProperty,
                                                    Buffer,
                                                    ulLength,
                                                    ulFlags,
                                                    hMachine);
    }

    //
    // examine datatype to see if need to convert input buffer
    //
    ulDataType = GetPropertyDataType(ulProperty);

    if ((ulDataType == REG_SZ) ||
        (ulDataType == REG_EXPAND_SZ) ||
        (ulDataType == REG_MULTI_SZ)) {

        pAnsiString = (PSTR)Buffer;

        //
        // determine the size of the Unicode buffer required to convert buffer
        // string data to unicode
        //
        UniBufferSize = 0;
        Status = PnPMultiByteToUnicode((PSTR)pAnsiString,
                                       ulLength,
                                       NULL,
                                       &UniBufferSize);

        ASSERT(Status == CR_BUFFER_SMALL);

        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // convert the buffer string data to unicode and pass to wide version
        //
        pUniBuffer = pSetupMalloc(UniBufferSize);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        Status = PnPMultiByteToUnicode((PSTR)pAnsiString,
                                       ulLength,
                                       pUniBuffer,
                                       &UniBufferSize);

        ASSERT(Status != CR_BUFFER_SMALL);

        Status = CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pUniBuffer,
                                                      UniBufferSize,
                                                      ulFlags,
                                                      hMachine);
        pSetupFree(pUniBuffer);

    } else {
        //
        // no need to convert
        //

        Status = CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      Buffer,
                                                      ulLength,
                                                      ulFlags,
                                                      hMachine);
    }

    return Status;

} // CM_Set_DevNode_Registry_Property_ExA



CONFIGRET
CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      pClassGuid,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType, UniLen;
    PWSTR       pUniBuffer;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLength)) {
        return CR_INVALID_POINTER;
    }

    if ((ulProperty < CM_CRP_MIN) || (ulProperty > CM_CRP_MAX)) {
        return CR_INVALID_PROPERTY;
    }

    //
    // examine datatype to see if need to convert return data
    //
    ulDataType = GetPropertyDataType(ulProperty);

    //
    // for all string type registry properties, we pass a Unicode buffer and
    // convert back to caller's ANSI buffer on return.  since the Unicode ->
    // ANSI conversion may involve DBCS chars, we can't make any assumptions
    // about the size of the required ANSI buffer relative to the size of the
    // require Unicode buffer, so we must always get the Unicode string buffer
    // and convert it whether a buffer was actually supplied by the caller or
    // not.
    //
    if ((ulDataType == REG_SZ) ||
        (ulDataType == REG_MULTI_SZ) ||
        (ulDataType == REG_EXPAND_SZ)) {

        //
        // first, call the Wide version with a zero-length buffer to retrieve
        // the size required for the Unicode property.
        //
        UniLen = 0;
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 NULL,
                                                 &UniLen,
                                                 ulFlags,
                                                 hMachine);
        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // allocate the required buffer.
        //
        pUniBuffer = pSetupMalloc(UniLen);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        //
        // call the Wide version to retrieve the Unicode property.
        //
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 pUniBuffer,
                                                 &UniLen,
                                                 ulFlags,
                                                 hMachine);

        //
        // We specifically allocated the buffer of the required size, so it
        // should always be large enough.
        //
        ASSERT(Status != CR_BUFFER_SMALL);

        if (Status == CR_SUCCESS) {
            //
            // do the ANSI conversion or retrieve the ANSI buffer size required.
            // this may be a single-sz or multi-sz string, so we pass in the
            // length, and let PnPUnicodeToMultiByte convert the entire buffer.
            //
            Status =
                PnPUnicodeToMultiByte(
                    pUniBuffer,
                    UniLen,
                    Buffer,
                    pulLength);
        }

        pSetupFree(pUniBuffer);

    } else {
        //
        // for the non-string registry data types, just pass call
        // on through to the Wide version
        //
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 Buffer,
                                                 pulLength,
                                                 ulFlags,
                                                 hMachine);
    }

    return Status;

} // CM_Get_Class_Registry_PropertyA



CONFIGRET
CM_Set_Class_Registry_PropertyA(
    IN  LPGUID      pClassGuid,
    IN  ULONG       ulProperty,
    IN  PCVOID      Buffer              OPTIONAL,
    IN  ULONG       ulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType = 0, UniBufferSize = 0;
    PWSTR       pUniBuffer = NULL;
    PSTR        pAnsiString = NULL;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if ((ulProperty < CM_CRP_MIN) || (ulProperty > CM_CRP_MAX)) {
        return CR_INVALID_PROPERTY;
    }

    if (!ARGUMENT_PRESENT(Buffer)) {
        //
        // No need to convert the parameter
        //
        return CM_Set_Class_Registry_PropertyW(pClassGuid,
                                               ulProperty,
                                               Buffer,
                                               ulLength,
                                               ulFlags,
                                               hMachine);
    }

    //
    // examine datatype to see if need to convert input buffer
    //
    ulDataType = GetPropertyDataType(ulProperty);

    if ((ulDataType == REG_SZ) ||
        (ulDataType == REG_EXPAND_SZ) ||
        (ulDataType == REG_MULTI_SZ)) {

        pAnsiString = (PSTR)Buffer;

        //
        // determine the size of the Unicode buffer required to convert buffer
        // string data to unicode
        //
        UniBufferSize = 0;
        Status = PnPMultiByteToUnicode((PSTR)pAnsiString,
                                       ulLength,
                                       NULL,
                                       &UniBufferSize);

        ASSERT(Status == CR_BUFFER_SMALL);

        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // convert the buffer string data to unicode and pass to wide version
        //
        pUniBuffer = pSetupMalloc(UniBufferSize);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        Status = PnPMultiByteToUnicode((PSTR)pAnsiString,
                                       ulLength,
                                       pUniBuffer,
                                       &UniBufferSize);

        ASSERT(Status != CR_BUFFER_SMALL);

        Status = CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pUniBuffer,
                                                 UniBufferSize,
                                                 ulFlags,
                                                 hMachine);

        pSetupFree(pUniBuffer);

    } else {

        Status = CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 Buffer,
                                                 ulLength,
                                                 ulFlags,
                                                 hMachine);
    }

    return Status;

} // CM_Set_Class_Registry_Property_ExA



CONFIGRET
CM_Open_Class_Key_ExA(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCSTR         pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniClassName = NULL;

    if (ARGUMENT_PRESENT(pszClassName)) {
        if (pSetupCaptureAndConvertAnsiArg(pszClassName, &pUniClassName) != NO_ERROR) {
            return CR_INVALID_DATA;
        }
    }

    Status = CM_Open_Class_Key_ExW(ClassGuid,
                                   pUniClassName,
                                   samDesired,
                                   Disposition,
                                   phkClass,
                                   ulFlags,
                                   hMachine);

    if (pUniClassName) {
        pSetupFree(pUniClassName);
    }

    return Status;

} // CM_Open_Class_Key_ExA



CONFIGRET
CM_Get_Class_Name_ExA(
    IN  LPGUID     ClassGuid,
    OUT PCHAR      Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_CLASS_NAME_LEN];
    ULONG     UniLen = MAX_CLASS_NAME_LEN;


    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer))    ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Class_Name_ExW(ClassGuid,
                                   UniBuffer,
                                   &UniLen,
                                   ulFlags,
                                   hMachine);

    //
    // We should never return a class name longer than MAX_CLASS_NAME_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // do the ANSI conversion or retrieve the ANSI buffer size required.
        //
        Status =
            PnPUnicodeToMultiByte(
                UniBuffer,
                UniLen*sizeof(WCHAR),
                Buffer,
                pulLength);
    }

    return Status;

} // CM_Get_Class_Name_ExA



CONFIGRET
CM_Get_Class_Key_Name_ExA(
    IN  LPGUID     ClassGuid,
    OUT LPSTR      pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_GUID_STRING_LEN];
    ULONG     UniLen = MAX_GUID_STRING_LEN;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszKeyName)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Class_Key_Name_ExW(ClassGuid,
                                       UniBuffer,
                                       &UniLen,
                                       ulFlags,
                                       hMachine);

    //
    // We should never return a class key name longer than MAX_GUID_STRING_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // do the ANSI conversion or retrieve the ANSI buffer size required.
        //
        Status =
            PnPUnicodeToMultiByte(
                UniBuffer,
                UniLen*sizeof(WCHAR),
                pszKeyName,
                pulLength);
    }

    return Status;

} // CM_Get_Class_Key_Name_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceInterface, pUniAliasDeviceInterface;
    ULONG     UniLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszDeviceInterface)) ||
        (!ARGUMENT_PRESENT(pszAliasDeviceInterface)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // convert buffer string data to unicode to pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(pszDeviceInterface, &pUniDeviceInterface) != NO_ERROR) {
        return CR_INVALID_DATA;
    }

    //
    // first, call the Wide version with a zero-length buffer to retrieve
    // the size required for the Unicode property.
    //
    UniLen = 0;
    Status = CM_Get_Device_Interface_Alias_ExW(pUniDeviceInterface,
                                               AliasInterfaceGuid,
                                               NULL,
                                               &UniLen,
                                               ulFlags,
                                               hMachine);
    if (Status != CR_BUFFER_SMALL) {
        return Status;
        goto Clean0;
    }

    //
    // allocate the required buffer.
    //
    pUniAliasDeviceInterface = pSetupMalloc(UniLen);
    if (pUniAliasDeviceInterface == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    //
    // call the Wide version to retrieve the Unicode property.
    //
    Status = CM_Get_Device_Interface_Alias_ExW(pUniDeviceInterface,
                                               AliasInterfaceGuid,
                                               pUniAliasDeviceInterface,
                                               &UniLen,
                                               ulFlags,
                                               hMachine);

    //
    // We specifically allocated the buffer of the required size, so it should
    // always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // do the ANSI conversion or retrieve the ANSI buffer size required.
        //
        Status =
            PnPUnicodeToMultiByte(
                pUniAliasDeviceInterface,
                UniLen*sizeof(WCHAR),
                pszAliasDeviceInterface,
                pulLength);
    }

    pSetupFree(pUniAliasDeviceInterface);

 Clean0:

    pSetupFree(pUniDeviceInterface);

    return Status;

} // CM_Get_Device_Interface_Alias_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniBuffer, pUniDeviceID = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pDeviceID)) {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) != NO_ERROR) {
            return CR_INVALID_DEVICE_ID;
        }
        ASSERT(pUniDeviceID != NULL);
    } else {
        ASSERT(pUniDeviceID == NULL);
    }

    //
    // prepare a larger buffer to hold the unicode formatted
    // multi_sz data returned by CM_Get_Device_Interface_List_ExW.
    //
    pUniBuffer = pSetupMalloc(BufferLen * sizeof(WCHAR));
    if (pUniBuffer == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    *pUniBuffer = L'\0';

    //
    // call the wide version
    //
    Status = CM_Get_Device_Interface_List_ExW(InterfaceClassGuid,
                                              pUniDeviceID,
                                              pUniBuffer,
                                              BufferLen,    // size in chars
                                              ulFlags,
                                              hMachine);

    if (Status == CR_SUCCESS) {
        //
        // do the ANSI conversion or retrieve the ANSI buffer size required.
        //
        ulAnsiBufferLen = BufferLen;
        Status =
            PnPUnicodeToMultiByte(
                pUniBuffer,
                BufferLen*sizeof(WCHAR),
                Buffer,
                &ulAnsiBufferLen);
    }

    pSetupFree(pUniBuffer);

 Clean0:

    if (pUniDeviceID) {
        pSetupFree(pUniDeviceID);
    }

    return Status;

} // CM_Get_Device_Interface_List_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS, tmpStatus;
    PWSTR     pUniDeviceID = NULL, pUniDeviceInterfaceList;
    ULONG     UniLen;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLen)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pDeviceID)) {
        //
        // if a device ID string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) != NO_ERROR) {
            return CR_INVALID_DEVICE_ID;
        }
        ASSERT(pUniDeviceID != NULL);
    } else {
        ASSERT(pUniDeviceID == NULL);
    }

    //
    // first, call the Wide version to retrieve the size required for the
    // Unicode device interface list.
    //
    UniLen = 0;
    Status = CM_Get_Device_Interface_List_Size_ExW(&UniLen,
                                                   InterfaceClassGuid,
                                                   pUniDeviceID,
                                                   ulFlags,
                                                   hMachine);
    if (Status != CR_SUCCESS) {
        goto Clean0;
    }

    //
    // allocate the required buffer.
    //
    pUniDeviceInterfaceList = pSetupMalloc(UniLen*sizeof(WCHAR));
    if (pUniDeviceInterfaceList == NULL) {
        Status =  CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    //
    // call the Wide version to retrieve the Unicode device interface list.
    //
    Status = CM_Get_Device_Interface_List_ExW(InterfaceClassGuid,
                                              pUniDeviceID,
                                              pUniDeviceInterfaceList,
                                              UniLen,
                                              ulFlags,
                                              hMachine);

    //
    // We specifically allocated the buffer of the required size, so it should
    // always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // retrieve the size, in bytes, of the ANSI buffer size required to
        // convert this list.  since this is a multi-sz string, we pass in the
        // length and let PnPUnicodeToMultiByte convert the entire buffer.
        //
        *pulLen = 0;
        tmpStatus =
            PnPUnicodeToMultiByte(
                pUniDeviceInterfaceList,
                UniLen*sizeof(WCHAR),
                NULL,
                pulLen);

        ASSERT(tmpStatus == CR_BUFFER_SMALL);
    }

    pSetupFree(pUniDeviceInterfaceList);

 Clean0:

    if (pUniDeviceID) {
        pSetupFree(pUniDeviceID);
    }

    return Status;

} // CM_Get_Device_Interface_List_Size_ExA



CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCSTR    pszReference          OPTIONAL,
    OUT LPSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniReference = NULL, pUniDeviceInterface = NULL;
    ULONG     UniLen;

    try {
        //
        // validate essential parameters only
        //
        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pszDeviceInterface))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // if a device reference string was passed in, convert to Unicode before
        // passing on to the wide version
        //
        if (ARGUMENT_PRESENT(pszReference)) {
            if (pSetupCaptureAndConvertAnsiArg(
                    pszReference, &pUniReference) != NO_ERROR) {
                pUniReference = NULL;
                Status = CR_INVALID_DATA;
                goto Clean0;
            }
        }

        //
        // pass a Unicode buffer instead and convert back to caller's ANSI buffer on
        // return
        //
        UniLen = *pulLength;
        pUniDeviceInterface = pSetupMalloc(UniLen*sizeof(WCHAR));
        if (pUniDeviceInterface == NULL) {
            Status =  CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        Status = CM_Register_Device_Interface_ExW(dnDevInst,
                                                  InterfaceClassGuid,
                                                  pUniReference,
                                                  pUniDeviceInterface,
                                                  &UniLen,
                                                  ulFlags,
                                                  hMachine);

        if (Status == CR_SUCCESS) {
            //
            // if the call succeeded, convert the Unicode string to ANSI
            //
            Status =
                PnPUnicodeToMultiByte(
                    pUniDeviceInterface,
                    UniLen*sizeof(WCHAR),
                    pszDeviceInterface,
                    pulLength);

        } else if (Status == CR_BUFFER_SMALL) {
            //
            // returned size is in chars
            //
            *pulLength = UniLen;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pUniDeviceInterface = pUniDeviceInterface;
        pUniReference = pUniReference;
    }

    if (pUniDeviceInterface) {
        pSetupFree(pUniDeviceInterface);
    }

    if (pUniReference) {
        pSetupFree(pUniReference);
    }

    return Status;

} // CM_Register_Device_Interface_ExA



CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
    IN LPCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceInterface = NULL;

    try {
        //
        // validate essential parameters only
        //
        if (!ARGUMENT_PRESENT(pszDeviceInterface)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // convert buffer string data to unicode and pass to wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pszDeviceInterface, &pUniDeviceInterface) == NO_ERROR) {

            Status = CM_Unregister_Device_Interface_ExW(pUniDeviceInterface,
                                                        ulFlags,
                                                        hMachine);
        } else {
            Status = CR_INVALID_DATA;
        }

      Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pUniDeviceInterface = pUniDeviceInterface;
    }

    if (pUniDeviceInterface) {
        pSetupFree(pUniDeviceInterface);
    }

    return Status;

} // CM_Unregister_Device_Interface_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  PCSTR       pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    DWORD       Win32Status;
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       UnicodeCustomPropName = NULL;
    DWORD       UniLen;
    PBYTE       pUniBuffer = NULL;
    PSTR        pAnsiBuffer = NULL;
    ULONG       ulDataType;
    ULONG       ulAnsiBufferLen;

    try {
        //
        // Validate parameters not validated by upcoming call to Unicode API
        // (CM_Get_DevNode_Registry_Property_ExW).
        //
        if(!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pszCustomPropertyName) {
            //
            // Convert property name to Unicode.
            //
            Win32Status = pSetupCaptureAndConvertAnsiArg(pszCustomPropertyName,
                                                         &UnicodeCustomPropName
                                                        );

            if(Win32Status != NO_ERROR) {
                //
                // This routine guarantees that the returned unicode string
                // pointer will be null upon failure, so we don't have to reset
                // it here--just bail.
                //
                if(Win32Status == ERROR_NOT_ENOUGH_MEMORY) {
                    Status = CR_OUT_OF_MEMORY;
                } else {
                    Status = CR_INVALID_POINTER;
                }
                goto Clean0;
            }

        } else {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Unfortunately, we have no clue as to whether or not the requested
        // property is a string (thus requiring conversion from Unicode to
        // ANSI).  Therefore, we'll retrieve the data (if any) in its entirety,
        // then convert to ANSI if necessary.  Only then can we determine the
        // data size (and whether it can be returned to the caller).
        //
        // Start out with a reasonable guess as to buffer size in an attempt to
        // avoid calling the Unicode get-property API twice...
        //
        UniLen = 1024;
        do {
            pUniBuffer = pSetupMalloc(UniLen);
            if(!pUniBuffer) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            Status = CM_Get_DevNode_Custom_Property_ExW(dnDevInst,
                                                        UnicodeCustomPropName,
                                                        &ulDataType,
                                                        pUniBuffer,
                                                        &UniLen,
                                                        ulFlags,
                                                        hMachine
                                                       );
            if(Status != CR_SUCCESS) {
                pSetupFree(pUniBuffer);
                pUniBuffer = NULL;
            }

        } while(Status == CR_BUFFER_SMALL);

        if(Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // If we get to here, we successfully retrieved the property.
        //
        if(pulRegDataType) {
            *pulRegDataType = ulDataType;
        }

        if(UniLen == 0) {
            //
            // We retrieved an empty buffer--no need to worry about
            // transferring any data into caller's buffer.
            //
            *pulLength = 0;
            goto Clean0;
        }

        switch(ulDataType) {

            case REG_MULTI_SZ :
            case REG_SZ :
            case REG_EXPAND_SZ :
                //
                // Worst case, an ANSI buffer large enough to hold the results
                // would be the same size as the Unicode results.
                //
                pAnsiBuffer = pSetupMalloc(UniLen);
                if(!pAnsiBuffer) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // do the ANSI conversion or retrieve the ANSI buffer size required.
                // this may be a single-sz or multi-sz string, so we pass in the
                // length, and let PnPUnicodeToMultiByte convert the entire buffer.
                //
                ulAnsiBufferLen = *pulLength;
                Status =
                    PnPUnicodeToMultiByte(
                        (PWSTR)pUniBuffer,
                        UniLen,
                        pAnsiBuffer,
                        &ulAnsiBufferLen);

                if(ulAnsiBufferLen > *pulLength) {
                    ASSERT(Status == CR_BUFFER_SMALL);
                    Status = CR_BUFFER_SMALL;
                } else {
                    //
                    // Copy ANSI string(s) into caller's buffer.
                    //
                    CopyMemory(Buffer, pAnsiBuffer, ulAnsiBufferLen);
                }

                *pulLength = ulAnsiBufferLen;

                break;

            default :
                //
                // buffer doesn't contain text, no conversion necessary.
                //
                if(UniLen > *pulLength) {
                    Status = CR_BUFFER_SMALL;
                } else {
                    CopyMemory(Buffer, pUniBuffer, UniLen);
                }

                *pulLength = UniLen;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        UnicodeCustomPropName = UnicodeCustomPropName;
        pUniBuffer = pUniBuffer;
        pAnsiBuffer = pAnsiBuffer;
    }

    if(UnicodeCustomPropName) {
        pSetupFree(UnicodeCustomPropName);
    }

    if(pUniBuffer) {
        pSetupFree(pUniBuffer);
    }

    if(pAnsiBuffer) {
        pSetupFree(pAnsiBuffer);
    }

    return Status;

} // CM_Get_DevNode_Custom_Property_ExA



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------


ULONG
GetPropertyDataType(
    IN ULONG ulProperty)

/*++

Routine Description:

   This routine takes a property ID and returns the registry data type that
   is used to store this property data (i.e., REG_SZ, etc).
Parameters:

   ulProperty     Property ID (one of the CM_DRP_* defines)

Return Value:

   Returns one of the predefined registry data types, REG_BINARY is the default.

--*/

{
    switch(ulProperty) {

        case CM_DRP_DEVICEDESC:
        case CM_DRP_SERVICE:
        case CM_DRP_CLASS:
        case CM_DRP_CLASSGUID:
        case CM_DRP_DRIVER:
        case CM_DRP_MFG:
        case CM_DRP_FRIENDLYNAME:
        case CM_DRP_LOCATION_INFORMATION:
        case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:
        case CM_DRP_ENUMERATOR_NAME:
        case CM_DRP_SECURITY_SDS: // and CM_CRP_SECURITY_SDS
        case CM_DRP_UI_NUMBER_DESC_FORMAT:
            return REG_SZ;

        case CM_DRP_HARDWAREID:
        case CM_DRP_COMPATIBLEIDS:
        case CM_DRP_UPPERFILTERS:
        case CM_DRP_LOWERFILTERS:
            return REG_MULTI_SZ;

        case CM_DRP_CONFIGFLAGS:
        case CM_DRP_CAPABILITIES:
        case CM_DRP_UI_NUMBER:
        case CM_DRP_LEGACYBUSTYPE:
        case CM_DRP_BUSNUMBER:
        case CM_DRP_CHARACTERISTICS: // and CM_CRP_CHARACTERISTICS
        case CM_DRP_EXCLUSIVE: // and CM_CRP_EXCLUSIVE
        case CM_DRP_DEVTYPE: // and CM_CRP_DEVTYPE
        case CM_DRP_ADDRESS:
        case CM_DRP_REMOVAL_POLICY:
        case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        case CM_DRP_INSTALL_STATE:
            return REG_DWORD;

        case CM_DRP_BUSTYPEGUID:
        case CM_DRP_SECURITY: // and CM_CRP_SECURITY

            return REG_BINARY;

        case CM_DRP_DEVICE_POWER_DATA:
            return REG_BINARY;

        default:
            //
            // We should never get here!
            //
            ASSERT(0);
            return REG_BINARY;
    }

} // GetPropertyDataType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\traverse.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    traverse.c

Abstract:

    This module contains the API routines that perform hardware tree
    traversal.
               CM_Locate_DevNode
               CM_Get_Parent
               CM_Get_Child
               CM_Get_Sibling
               CM_Get_Device_ID_Size
               CM_Get_Device_ID
               CM_Enumerate_Enumerators
               CM_Get_Device_ID_List
               CM_Get_Device_ID_List_Size
               CM_Get_Depth

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"



CONFIGRET
CM_Locate_DevNode_ExW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the handle of the device instance that
   corresponds to a specified device identifier.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives the
                  handle of a device instance.

   pDeviceID      Supplies the address of a null-terminated string specifying
                  a device identifier.  If this parameter is NULL, the API
                  retrieves a handle to the device instance at the root of
                  the hardware tree.

   ulFlags        Supplies flags specifying options for locating the device
                  instance.  May be a combination of the following values:

                  CM_LOCATE_DEVNODE_NORMAL  - Locate only device instances
                     that are currently alive from the ConfigMgr's point of
                     view.
                  CM_LOCATE_DEVNODE_PHANTOM - Allows a device instance handle
                     to be returned for a device instance that is not
                     currently alive, but that does exist in the registry.
                     This may be used with other CM APIs that require a
                     devnode handle, but for which there currently is none
                     for a particular device (e.g., you want to set a device
                     registry property for a device not currently present).
                     This flag does not allow you to locate phantom devnodes
                     created by using CM_Create_DevNode with the
                     CM_CREATE_DEVNODE_PHANTOM flag (such device instances
                     are only accessible by the caller who holds the devnode
                     handle returned from that API).

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVICE_ID,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    PVOID     hStringTable = NULL;
    handle_t  hBinding = NULL;
    size_t    DeviceIDLen = 0;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_LOCATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // CM_LOCATE_DEVNODE_NOVALIDATION is not supported on NT
        //
        if (IS_FLAG_SET(ulFlags, CM_LOCATE_DEVNODE_NOVALIDATION)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // if a device instance was specified, make sure it's not too long
        //
        if (ARGUMENT_PRESENT(pDeviceID)) {

            if (FAILED(StringCchLength(
                           pDeviceID,
                           MAX_DEVICE_ID_LEN,
                           &DeviceIDLen))) {
                Status = CR_INVALID_DEVICE_ID;
                goto Clean0;
            }

            ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);
        }

        //------------------------------------------------------------------
        // if the device instance is NULL or it's a zero-length string, then
        // retreive the root device instance
        //------------------------------------------------------------------

        if ((!ARGUMENT_PRESENT(pDeviceID)) || (DeviceIDLen == 0)) {

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetRootDeviceInstance(
                    hBinding,              // rpc binding handle
                    szFixedUpDeviceID,     // return device instance string
                    MAX_DEVICE_ID_LEN);    // length of DeviceInstanceID
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetRootDeviceInstance caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        //------------------------------------------------------------------
        // if the device instance was specified, validate the string
        //------------------------------------------------------------------

        else {
            //
            // first see if the format of the device id string is valid, this
            // can be done on the client side
            //
            if (!IsLegalDeviceId(pDeviceID)) {
                Status = CR_INVALID_DEVICE_ID;
                goto Clean0;
            }

            //
            // Next, fix up the device ID string for consistency (uppercase, etc)
            //
            CopyFixedUpDeviceId(szFixedUpDeviceID,
                                pDeviceID,
                                (DWORD)DeviceIDLen);

            //
            // finally, validate the presense of the device ID string, this must
            // be done by the server
            //

            //
            // No special privileges are required by the server
            //

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_ValidateDeviceInstance(
                    hBinding,               // rpc binding handle
                    szFixedUpDeviceID,      // device id
                    ulFlags);               // locate flag
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_ValidateDeviceInstance caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }


        //------------------------------------------------------------------
        // In either case, if we're successful then we have a valid device
        // ID. Use the string table to assign a unique DevNode to this
        // device id (if it's already in the string table, it just retrieves
        // the existing unique value)
        //------------------------------------------------------------------

        ASSERT(*szFixedUpDeviceID && IsLegalDeviceId(szFixedUpDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szFixedUpDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == (DEVINST)(-1)) {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Locate_DevNode_ExW



CONFIGRET
CM_Get_Parent_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the handle of the parent of a device instance.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives a
                  handle to the parent device instance.

   dnDevInst      Supplies the handle of the child device instance string.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_PARENT_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // returns parent device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == (DEVINST)(-1)) {
            Status = CR_FAILURE;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Parent_Ex



CONFIGRET
CM_Get_Child_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the first child of a given device instance.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives the
                  handle of the device instance.

   dnDevInst      Supplies the handle of the parent device instance.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_CHILD_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // child device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == (DEVINST)(-1)) {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Child_Ex



CONFIGRET
CM_Get_Sibling_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the sibling of a device instance.

   This API can be called in a loop to retrieve all the siblings of a
   device instance.  When the API returns CR_NO_SUCH_DEVNODE, there are no
   more siblings to enumerate.  In order to enumerate all children of a
   device instance, this loop must start with the device instance retrieved
   by calling CM_Get_Child to get the first sibling.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives a
                  handle to the sibling device  instance.

   dnDevInst      Supplies the handle of a device instance.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_SIBLING_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // sibling device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == (DEVINST)(-1)) {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Sibling_Ex



CONFIGRET
CM_Get_Device_ID_Size_Ex(
    OUT PULONG   pulLen,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size of a device identifier from a
   device instance.

Parameters:

   pulLen      Supplies the address of the variable that receives the size
               in characters, not including the terminating NULL, of the
               device identifier.  The API sets the variable to 0 if no
               identifier exists.  The size is always less than or equal to
               MAX_DEVICE_ID_LEN.

   dnDevInst   Supplies the handle of the device instance.

   ulFlags     Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    BOOL        Success;
    DWORD       ulLen;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        // use private ulLen, since we know this is valid
        //
        ulLen = MAX_DEVICE_ID_LEN;
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            *pulLen = 0;
            Status = CR_INVALID_DEVINST;
        }
        //
        // discount the terminating NULL char,
        // included in the size reported by pSetupStringTableStringFromIdEx
        //
        *pulLen = ulLen - 1;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_Size_Ex



CONFIGRET
CM_Get_Device_ID_ExW(
    IN  DEVINST  dnDevInst,
    OUT PWCHAR   Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the device identifier for a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance for which to
               retrieve the device identifier.

   Buffer      Supplies the address of the buffer that receives the device
               identifier.  If this buffer is larger than the device
               identifier, the API appends a null-terminating character to
               the data.  If it is smaller than the device identifier, the API
               fills it with as much of the device identifier as will fit
               and returns CR_BUFFER_SMALL.

   BufferLen   Supplies the size, in characters, of the buffer for the device
               identifier.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_BUFFER_SMALL,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLength = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    BOOL        Success;
    size_t      DeviceIDLen = 0;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLength);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        if (FAILED(StringCchLength(
                       pDeviceID,
                       MAX_DEVICE_ID_LEN,
                       &DeviceIDLen))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // copy as much of the the device id string as possible to the user
        // buffer.  include the NULL term char, if there is room.
        //
        CopyMemory(Buffer, pDeviceID,
                   min((DeviceIDLen+1)*sizeof(WCHAR),BufferLen*sizeof(WCHAR)));

        //
        // if the length of device id string (without NULL termination) is
        // longer than the supplied buffer, report CR_BUFFER_SMALL.
        // if the Buffer is large enough to hold the string, without
        // NULL-termination, we'll report success, per specification.
        //
        if (DeviceIDLen > BufferLen) {
            Status = CR_BUFFER_SMALL;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_ExW



CONFIGRET
CM_Enumerate_Enumerators_ExW(
    IN ULONG      ulEnumIndex,
    OUT PWCHAR    Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine enumerates the enumerator subkeys under the Enum branch
   (e.g., Root, PCI, etc.).  These names should not be used to access the
   registry directly, but may be used as input to the CM_Get_Device_ID_List
   routine.  To enumerate enumerator subkey names, an application should
   initially call the CM_Enumerate_Enumerators function with the ulEnumIndex
   parameter set to zero. The application should then increment the
   ulEnumIndex parameter and call CM_Enumerate_Enumerators until there are
   no more subkeys (until the function returns CR_NO_SUCH_VALUE).

Parameters:

   ulEnumIndex Supplies the index of the enumerator subkey name to retrieve.

   Buffer      Supplies the address of the character buffer that receives
               the enumerator subkey name whose index is specified by
               ulEnumIndex.

   pulLength   Supplies the address of the variable that contains the length,
               in characters, of the Buffer.  Upon return, this variable
               will contain the number of characters (including terminating
               NULL) written to Buffer (if the supplied buffer is't large
               enough, then the routine will fail with CR_BUFFER_SMALL, and
               this value will indicate how large the buffer needs to be in
               order to succeed).

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_EnumerateSubKeys(
                hBinding,               // rpc binding handle
                PNP_ENUMERATOR_SUBKEYS, // subkeys of enum branch
                ulEnumIndex,            // index of enumerator to enumerate
                Buffer,                 // will contain enumerator name
                *pulLength,             // max length of Buffer in chars
                pulLength,              // chars copied (or chars required)
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_EnumerateSubKeys caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enumerate_Enumerators_ExW



CONFIGRET
CM_Get_Device_ID_List_ExW(
    IN PCWSTR   pszFilter,    OPTIONAL
    OUT PWCHAR  Buffer,
    IN ULONG    BufferLen,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:
   This routine retrieve a list of all device IDs (device instance names)
   stored in the system.

Parameters:

   pszFilter      This string filters the list of device IDs returned.  Its
                  interpretation is dependent on the ulFlags specified.   If
                  CM_GETDEVID_FILTER_ENUMERATORS is specified, then this
                  value can be either the name of an enumerator or the name
                  of an enumerator plus the device id.  If
                  CM_GETDEVID_FILTER_SERVICE is specified, then this value
                  is a service name.

   Buffer         Supplies the address of the character buffer that receives
                  the device ID list.  Each device ID is null-terminated, with
                  an extra NULL at the end.

   BufferLen      Supplies the size, in characters, of the Buffer.  This size
                  may be ascertained by calling CM_Get_Device_ID_List_Size.

   ulFlags        Must be either CM_GETDEVID_FILTER_ENUMERATOR or
                  CM_GETDEVID_FILTER_SERVICE.  The flags value controls how
                  the pszFilter string is used.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceList(
                hBinding,            // RPC Binding Handle
                pszFilter,           // filter string, optional
                Buffer,              // will contain device list
                &BufferLen,          // in/out size of Buffer
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceList caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_List_ExW



CONFIGRET
CM_Get_Device_ID_List_Size_ExW(
    OUT PULONG  pulLen,
    IN PCWSTR   pszFilter,   OPTIONAL
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size, in characters, of a list of device
   identifiers.  It may be used to supply the buffer size necessary for a
   call to CM_Get_Device_ID_List.

Parameters:

   pulLen         Supplies the address of the variable that receives the
                  size, in characters, required to store a list of all device
                  identifiers (possibly limited to those existing under the
                  pszEnumerator subkey described below).  The size reflects
                  a list of null-terminated device identifiers, with an extra
                  null at the end.  For efficiency, this number represents an
                  upper bound on the size required, and the actual list size
                  may be slightly smaller.

   pszFilter      This string filters the list of device IDs returned.  Its
                  interpretation is dependent on the ulFlags specified.   If
                  CM_GETDEVID_FILTER_ENUMERATORS is specified, then this
                  value can be either the name of an enumerator or the name
                  of an enumerator plus the device id.  If
                  CM_GETDEVID_FILTER_SERVICE is specified, then this value
                  is a service name.

   ulFlags        Must be either CM_GETDEVID_FILTER_ENUMERATOR or
                  CM_GETDEVID_FILTER_SERVICE.  The flags value controls how
                  the pszFilter string is used.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pulLen = 0;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceListSize(
                hBinding,       // rpc binding handle
                pszFilter,      // Enumerator subkey, optional
                pulLen,         // length of device list in chars
                ulFlags);       // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceListSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_List_SizeW



CONFIGRET
CM_Get_Depth_Ex(
    OUT PULONG   pulDepth,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the depth of a device instance in the
   hardware tree.

Parameters:

   pulDepth    Supplies the address of the variable that receives the
               depth of the device instance.  This value is 0 to designate
               the root of the tree, 1 to designate a child of the root,
               and so on.

   dnDevNode   Supplies the handle of a device instance.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG, or
      CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulDepth)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // No special privileges are required by the server
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDepth(
                hBinding,     // rpc binding handle
                pDeviceID,    // device instance
                pulDepth,     // returns the depth
                ulFlags);     // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDepth caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Depth



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Locate_DevNodeW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags
    )
{
    return CM_Locate_DevNode_ExW(pdnDevInst, pDeviceID, ulFlags, NULL);
}


CONFIGRET
CM_Locate_DevNodeA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags
    )
{
    return CM_Locate_DevNode_ExA(pdnDevInst, pDeviceID, ulFlags, NULL);
}


CONFIGRET
CM_Get_Parent(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Parent_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Child(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Child_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Sibling(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Sibling_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_Size(
    OUT PULONG  pulLen,
    IN  DEVINST dnDevInst,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_Size_Ex(pulLen, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_IDW(
    IN  DEVINST dnDevInst,
    OUT PWCHAR  Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_ExW(dnDevInst, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_IDA(
    IN  DEVINST dnDevInst,
    OUT PCHAR   Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_ExA(dnDevInst, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_EnumeratorsW(
    IN ULONG      ulEnumIndex,
    OUT PWCHAR    Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Enumerators_ExW(ulEnumIndex, Buffer, pulLength,
                                        ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_EnumeratorsA(
    IN ULONG      ulEnumIndex,
    OUT PCHAR     Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Enumerators_ExA(ulEnumIndex, Buffer, pulLength,
                                        ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_ListW(
    IN PCWSTR  pszFilter,    OPTIONAL
    OUT PWCHAR Buffer,
    IN ULONG   BufferLen,
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_ExW(pszFilter, Buffer, BufferLen,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_ListA(
    IN PCSTR   pszFilter,    OPTIONAL
    OUT PCHAR  Buffer,
    IN ULONG   BufferLen,
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_ExA(pszFilter, Buffer, BufferLen,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_List_SizeW(
    OUT PULONG pulLen,
    IN PCWSTR  pszFilter,   OPTIONAL
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_Size_ExW(pulLen, pszFilter, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_List_SizeA(
    OUT PULONG pulLen,
    IN PCSTR   pszFilter,   OPTIONAL
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_Size_ExA(pulLen, pszFilter, ulFlags, NULL);
}


CONFIGRET
CM_Get_Depth(
    OUT PULONG   pulDepth,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Depth_Ex(pulDepth, dnDevInst, ulFlags, NULL);
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Locate_DevNode_ExA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,    OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;


    if (!ARGUMENT_PRESENT(pDeviceID)) {
        //
        // If the DEVINSTID parameter is NULL, then no conversion is necessary,
        // just call the wide version
        //
        Status = CM_Locate_DevNode_ExW(pdnDevInst,
                                       NULL,
                                       ulFlags,
                                       hMachine);
    } else {
        //
        // if a device id string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        PWSTR pUniDeviceID = NULL;

        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) == NO_ERROR) {

            Status = CM_Locate_DevNode_ExW(pdnDevInst,
                                           pUniDeviceID,
                                           ulFlags,
                                           hMachine);

            pSetupFree(pUniDeviceID);

        } else {
            Status = CR_INVALID_DEVICE_ID;
        }
    }

    return Status;

} // CM_Locate_DevNode_ExA



CONFIGRET
CM_Get_Device_ID_ExA(
    IN  DEVINST  dnDevInst,
    OUT PCHAR    Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_DEVICE_ID_LEN];
    ULONG     ulAnsiBufferLen;
    size_t    UniBufferLen = 0;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Device_ID_ExW(dnDevInst,
                                  UniBuffer,
                                  MAX_DEVICE_ID_LEN,
                                  ulFlags,
                                  hMachine);

    //
    // We should never return a DeviceId longer than MAX_DEVICE_ID_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {

        //
        // if the call succeeded, convert the device id to ansi before returning
        //

        if (FAILED(StringCchLength(
                       UniBuffer,
                       MAX_DEVICE_ID_LEN,
                       &UniBufferLen))) {
            return CR_FAILURE;
        }

        ASSERT(UniBufferLen < MAX_DEVICE_ID_LEN);

        ulAnsiBufferLen = BufferLen;

        Status =
            PnPUnicodeToMultiByte(
                UniBuffer,
                (DWORD)((UniBufferLen + 1)*sizeof(WCHAR)),
                Buffer,
                &ulAnsiBufferLen);
    }

    return Status;

} // CM_Get_Device_ID_ExA




CONFIGRET
CM_Enumerate_Enumerators_ExA(
    IN ULONG      ulEnumIndex,
    OUT PCHAR     Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_DEVICE_ID_LEN];
    ULONG     UniLen = MAX_DEVICE_ID_LEN;

    //
    // validate parameters
    //
    if ((!ARGUMENT_PRESENT(Buffer)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Enumerate_Enumerators_ExW(ulEnumIndex,
                                          UniBuffer,
                                          &UniLen,
                                          ulFlags,
                                          hMachine);

    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // convert the unicode buffer to an ansi string and copy to the caller's
        // buffer
        //
        Status =
            PnPUnicodeToMultiByte(
                UniBuffer,
                UniLen*sizeof(WCHAR),
                Buffer,
                pulLength);
    }

    return Status;

} // CM_Enumerate_Enumerators_ExA



CONFIGRET
CM_Get_Device_ID_List_ExA(
      IN PCSTR    pszFilter,    OPTIONAL
      OUT PCHAR   Buffer,
      IN ULONG    BufferLen,
      IN ULONG    ulFlags,
      IN HMACHINE hMachine
      )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniBuffer, pUniFilter = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate input parameters
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pszFilter)) {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pszFilter, &pUniFilter) != NO_ERROR) {
            return CR_INVALID_DATA;
        }
        ASSERT(pUniFilter != NULL);
    }

    //
    // prepare a larger buffer to hold the unicode formatted
    // multi_sz data returned by CM_Get_Device_ID_List.
    //
    pUniBuffer = pSetupMalloc(BufferLen*sizeof(WCHAR));
    if (pUniBuffer == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    *pUniBuffer = L'\0';

    //
    // call the wide version
    //
    Status = CM_Get_Device_ID_List_ExW(pUniFilter,
                                       pUniBuffer,
                                       BufferLen,   // size in chars
                                       ulFlags,
                                       hMachine);
    if (Status == CR_SUCCESS) {

        //
        // if the call succeeded, must convert the multi_sz list to ansi before
        // returning
        //

        ulAnsiBufferLen = BufferLen;

        Status =
            PnPUnicodeToMultiByte(
                pUniBuffer,
                BufferLen*sizeof(WCHAR),
                Buffer,
                &ulAnsiBufferLen);
    }

    pSetupFree(pUniBuffer);

 Clean0:

    if (pUniFilter) {
        pSetupFree(pUniFilter);
    }

    return Status;

} // CM_Get_Device_ID_List_ExA



CONFIGRET
CM_Get_Device_ID_List_Size_ExA(
    OUT PULONG  pulLen,
    IN PCSTR    pszFilter,   OPTIONAL
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;


    if (!ARGUMENT_PRESENT(pszFilter)) {
        //
        // If the filter parameter is NULL, then no conversion is necessary,
        // just call the wide version
        //
        Status = CM_Get_Device_ID_List_Size_ExW(pulLen,
                                                NULL,
                                                ulFlags,
                                                hMachine);
    } else {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        PWSTR pUniFilter = NULL;

        if (pSetupCaptureAndConvertAnsiArg(pszFilter, &pUniFilter) == NO_ERROR) {

            Status = CM_Get_Device_ID_List_Size_ExW(pulLen,
                                                    pUniFilter,
                                                    ulFlags,
                                                    hMachine);
            pSetupFree(pUniFilter);

        } else {
            Status = CR_INVALID_DATA;
        }
    }

    return Status;

} // CM_Get_Device_ID_List_Size_ExA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\cfgmgr32\util.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    util.c

Abstract:

    This module contains general utility routines used by cfgmgr32 code.

               INVALID_DEVINST
               CopyFixedUpDeviceId
               PnPUnicodeToMultiByte
               PnPMultiByteToUnicode
               PnPRetrieveMachineName
               PnPGetVersion
               PnPGetGlobalHandles
               PnPEnablePrivileges
               PnPRestorePrivileges
               IsRemoteServiceRunning

Author:

    Paula Tomlinson (paulat) 6-22-1995

Environment:

    User mode only.

Revision History:

    22-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "cfgi.h"


//
// Private prototypes
//
BOOL
EnablePnPPrivileges(
    VOID
    );


//
// global data
//
extern PVOID    hLocalStringTable;                  // MODIFIED by PnPGetGlobalHandles
extern PVOID    hLocalBindingHandle;                // MODIFIED by PnPGetGlobalHandles
extern WORD     LocalServerVersion;                 // MODIFIED by PnPGetVersion
extern WCHAR    LocalMachineNameNetBIOS[];          // NOT MODIFIED BY THIS FILE
extern CRITICAL_SECTION BindingCriticalSection;     // NOT MODIFIED IN THIS FILE
extern CRITICAL_SECTION StringTableCriticalSection; // NOT MODIFIED IN THIS FILE



BOOL
INVALID_DEVINST(
   PWSTR    pDeviceID
   )

/*++

Routine Description:

    This routine attempts a simple check whether the pDeviceID string
    returned from StringTableStringFromID is valid or not.  It does
    this simply by dereferencing the pointer and comparing the first
    character in the string against the range of characters for a valid
    device id.  If the string is valid but it's not an existing device id
    then this error will be caught later.

Arguments:

    pDeviceID  Supplies a pointer to the string to be validated.

Return Value:

    If it's invalid it returns TRUE, otherwise it returns FALSE.

--*/
{
    BOOL  Status = FALSE;

    try {

        if ((!ARGUMENT_PRESENT(pDeviceID)) ||
            (*pDeviceID <= L' ')      ||
            (*pDeviceID > (WCHAR)0x7F)     ||
            (*pDeviceID == L',')) {
            Status = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = TRUE;
    }

    return Status;

} // INVALID_DEVINST



VOID
CopyFixedUpDeviceId(
      OUT LPWSTR  DestinationString,
      IN  LPCWSTR SourceString,
      IN  DWORD   SourceStringLen
      )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

    DestinationString - Supplies a pointer to the destination string buffer
        where the fixed-up device id is to be copied.  This buffer must
        be large enough to hold a copy of the source string (including
        terminating NULL).

    SourceString - Supplies a pointer to the (null-terminated) source
        string to be fixed up.

    SourceStringLen - Supplies the length, in characters, of the source
        string (not including terminating NULL).

Return Value:

    None.

--*/
{
    PWCHAR p;

    try {

        CopyMemory(DestinationString,
                   SourceString,
                   ((SourceStringLen + 1) * sizeof(WCHAR)));

        CharUpperBuff(DestinationString, SourceStringLen);

        for(p = DestinationString; *p; p++) {

            if((*p <= L' ')  ||
               (*p > (WCHAR)0x7F) ||
               (*p == L',')) {
                *p = L'_';
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

} // CopyFixedUpDeviceId



CONFIGRET
PnPUnicodeToMultiByte(
    IN     PWSTR   UnicodeString,
    IN     ULONG   UnicodeStringLen,
    OUT    PSTR    AnsiString           OPTIONAL,
    IN OUT PULONG  AnsiStringLen
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString    - Supplies string to be converted.

    UnicodeStringLen - Specifies the size, in bytes, of the string to be
                       converted.

    AnsiString       - Optionally, supplies a buffer to receive the ANSI
                       string.

    AnsiStringLen    - Supplies the address of a variable that contains the
                       size, in bytes, of the buffer pointed to by AnsiString.
                       This API replaces the initial size with the number of
                       bytes of data copied to the buffer.  If the variable is
                       initially zero, the API replaces it with the buffer size
                       needed to receive all the registry data.  In this case,
                       the AnsiString parameter is ignored.

Return Value:

    Returns a CONFIGRET code.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    NTSTATUS  ntStatus;
    ULONG     ulAnsiStringLen = 0;

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(AnsiStringLen)) ||
            (!ARGUMENT_PRESENT(AnsiString)) && (*AnsiStringLen != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Determine the size required for the ANSI string representation.
        //
        ntStatus = RtlUnicodeToMultiByteSize(&ulAnsiStringLen,
                                             UnicodeString,
                                             UnicodeStringLen);
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(AnsiString)) ||
            (*AnsiStringLen < ulAnsiStringLen)) {
            *AnsiStringLen = ulAnsiStringLen;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // Perform the conversion.
        //
        ntStatus = RtlUnicodeToMultiByteN(AnsiString,
                                          *AnsiStringLen,
                                          &ulAnsiStringLen,
                                          UnicodeString,
                                          UnicodeStringLen);

        ASSERT(NT_SUCCESS(ntStatus));
        ASSERT(ulAnsiStringLen <= *AnsiStringLen);

        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
        }

        *AnsiStringLen = ulAnsiStringLen;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PnPUnicodeToMultiByte



CONFIGRET
PnPMultiByteToUnicode(
    IN     PSTR    AnsiString,
    IN     ULONG   AnsiStringLen,
    OUT    PWSTR   UnicodeString           OPTIONAL,
    IN OUT PULONG  UnicodeStringLen
    )

/*++

Routine Description:

    Convert a string from ansi to unicode.

Arguments:

    AnsiString       - Supplies string to be converted.

    AnsiStringLen    - Specifies the size, in bytes, of the string to be
                       converted.

    UnicodeString    - Optionally, supplies a buffer to receive the Unicode
                       string.

    UnicodeStringLen - Supplies the address of a variable that contains the
                       size, in bytes, of the buffer pointed to by UnicodeString.
                       This API replaces the initial size with the number of
                       bytes of data copied to the buffer.  If the variable is
                       initially zero, the API replaces it with the buffer size
                       needed to receive all the registry data.  In this case,
                       the UnicodeString parameter is ignored.

Return Value:

    Returns a CONFIGRET code.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    NTSTATUS  ntStatus;
    ULONG     ulUnicodeStringLen = 0;

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(UnicodeStringLen)) ||
            (!ARGUMENT_PRESENT(UnicodeString)) && (*UnicodeStringLen != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Determine the size required for the ANSI string representation.
        //
        ntStatus = RtlMultiByteToUnicodeSize(&ulUnicodeStringLen,
                                             AnsiString,
                                             AnsiStringLen);
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(UnicodeString)) ||
            (*UnicodeStringLen < ulUnicodeStringLen)) {
            *UnicodeStringLen = ulUnicodeStringLen;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // Perform the conversion.
        //
        ntStatus = RtlMultiByteToUnicodeN(UnicodeString,
                                          *UnicodeStringLen,
                                          &ulUnicodeStringLen,
                                          AnsiString,
                                          AnsiStringLen);

        ASSERT(NT_SUCCESS(ntStatus));
        ASSERT(ulUnicodeStringLen <= *UnicodeStringLen);

        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
        }

        *UnicodeStringLen = ulUnicodeStringLen;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PnPMultiByteToUnicode



BOOL
PnPRetrieveMachineName(
    IN  HMACHINE   hMachine,
    OUT LPWSTR     pszMachineName
    )

/*++

Routine Description:

    Optimized version of PnPConnect, only returns the machine name
    associated with this connection.

Arguments:

    hMachine       - Information about this connection

    pszMachineName - Returns machine name specified when CM_Connect_Machine
                     was called.

        ** THIS BUFFER MUST BE AT LEAST (MAX_PATH + 3) CHARACTERS LONG. **

Return Value:

    Return TRUE if the function succeeds and FALSE if it fails.

--*/

{
    BOOL Status = TRUE;

    try {

        if (hMachine == NULL) {
            //
            // local machine scenario
            //
            // use the global local machine name string that was filled
            // when the DLL initialized.
            //
            if (FAILED(StringCchCopy(
                           pszMachineName,
                           MAX_PATH + 3,
                           LocalMachineNameNetBIOS))) {
                Status = FALSE;
                goto Clean0;
            }

        } else {
            //
            // remote machine scenario
            //
            // validate the machine handle.
            //
            if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                Status = FALSE;
                goto Clean0;
            }

            //
            // use information within the hMachine handle to fill in the
            // machine name.  The hMachine info was set on a previous call
            // to CM_Connect_Machine.
            //
            if (FAILED(StringCchCopy(
                           pszMachineName,
                           MAX_PATH + 3,
                           ((PPNP_MACHINE)hMachine)->szMachineName))) {
                Status = FALSE;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // PnPRetrieveMachineName



BOOL
PnPGetVersion(
    IN  HMACHINE   hMachine,
    IN  WORD *     pwVersion
    )

/*++

Routine Description:

    This routine returns the internal server version for the specified machine
    connection, as returned by the RPC server interface routine
    PNP_GetVersionInternal.  If the PNP_GetVersionInternal interface does not
    exist on the specified machine, this routine returns the version as reported
    by PNP_GetVersion.

Arguments:

    hMachine  - Information about this connection

    pwVersion - Receives the internal server version.

Return Value:

    Return TRUE if the function succeeds and FALSE if it fails.

Notes:

    The version reported by PNP_GetVersion is defined to be constant, at 0x0400.
    The version returned by PNP_GetVersionInternal may change with each release
    of the product, starting with 0x0501 for Windows NT 5.1.

--*/

{
    BOOL Status = TRUE;
    handle_t hBinding = NULL;
    CONFIGRET crStatus;
    WORD wVersionInternal;

    try {

        if (pwVersion == NULL) {
            Status = FALSE;
            goto Clean0;
        }

        if (hMachine == NULL) {
            //
            // local machine scenario
            //
            if (LocalServerVersion != 0) {
                //
                // local server version has already been retrieved.
                //
                *pwVersion = LocalServerVersion;

            } else {
                //
                // retrieve binding handle for the local machine.
                //
                if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
                    Status = FALSE;
                    goto Clean0;
                }

                ASSERT(hBinding);

                //
                // initialize the version supplied to the internal client
                // version, in case the server wants to adjust the response
                // based on the client version.
                //
                wVersionInternal = (WORD)CFGMGR32_VERSION_INTERNAL;

                //
                // No special privileges are required by the server
                //

                RpcTryExcept {
                    //
                    // call rpc service entry point
                    //
                    crStatus = PNP_GetVersionInternal(
                        hBinding,           // rpc binding
                        &wVersionInternal); // internal server version
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "PNP_GetVersionInternal caused an exception (%d)\n",
                               RpcExceptionCode()));

                    crStatus = MapRpcExceptionToCR(RpcExceptionCode());
                }
                RpcEndExcept

                if (crStatus == CR_SUCCESS) {
                    //
                    // PNP_GetVersionInternal exists on NT 5.1 and later.
                    //
                    ASSERT(wVersionInternal >= (WORD)0x0501);

                    //
                    // initialize the global local server version.
                    //
                    LocalServerVersion = *pwVersion = wVersionInternal;

                } else {
                    //
                    // we successfully retrieved a local binding handle, but
                    // PNP_GetVersionInternal failed for some reason other than
                    // the server not being available.
                    //
                    ASSERT(0);

                    //
                    // although we know this version of the client should match
                    // a version of the server where PNP_GetVersionInternal is
                    // available, it's technically possible (though unsupported)
                    // that this client is communicating with a downlevel server
                    // on the local machine, so we'll have to resort to calling
                    // PNP_GetVersion.
                    //

                    //
                    // No special privileges are required by the server
                    //

                    RpcTryExcept {
                        //
                        // call rpc service entry point
                        //
                        crStatus = PNP_GetVersion(
                            hBinding,           // rpc binding
                            &wVersionInternal); // server version
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_WARNINGS,
                                   "PNP_GetVersion caused an exception (%d)\n",
                                   RpcExceptionCode()));

                        crStatus = MapRpcExceptionToCR(RpcExceptionCode());
                    }
                    RpcEndExcept

                    if (crStatus == CR_SUCCESS) {
                        //
                        // PNP_GetVersion should always return 0x0400 on all servers.
                        //
                        ASSERT(wVersionInternal == (WORD)0x0400);

                        //
                        // initialize the global local server version.
                        //
                        LocalServerVersion = *pwVersion = wVersionInternal;

                    } else {
                        //
                        // nothing more we can do here but fail.
                        //
                        ASSERT(0);
                        Status = FALSE;
                    }
                }
            }

        } else {
            //
            // remote machine scenario
            //
            // validate the machine handle.
            //
            if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                Status = FALSE;
                goto Clean0;
            }

            //
            // use information within the hMachine handle to fill in the
            // version.  The hMachine info was set on a previous call to
            // CM_Connect_Machine.
            //
            *pwVersion = ((PPNP_MACHINE)hMachine)->wVersion;
        }

      Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // PnPGetVersion



BOOL
PnPGetGlobalHandles(
    IN  HMACHINE   hMachine,
    OUT PVOID     *phStringTable,      OPTIONAL
    OUT PVOID     *phBindingHandle     OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves a handle to the string table and/or the rpc binding
    handle for the specified server machine connection.

Arguments:

    hMachine        - Specifies a server machine connection handle, as returned
                      by CM_Connect_Machine.

    phStringTable   - Optionally, specifies an address to receive a handle to
                      the string table for the specified server machine
                      connection.

    phBindingHandle - Optionally, specifies an address to receive the RPC
                      binding handle for the specifies server machine
                      connection.

Return value:

    Returns TRUE if successful, FALSE otherwise.

--*/

{
    BOOL    bStatus = TRUE;


    try {

        if (ARGUMENT_PRESENT(phStringTable)) {

            if (hMachine == NULL) {

                //------------------------------------------------------
                // Retrieve String Table Handle for the local machine
                //-------------------------------------------------------

                EnterCriticalSection(&StringTableCriticalSection);

                if (hLocalStringTable != NULL) {
                    //
                    // local string table has already been created
                    //
                    *phStringTable = hLocalStringTable;

                } else {
                    //
                    // first time, initialize the local string table
                    //

                    hLocalStringTable = pSetupStringTableInitialize();

                    if (hLocalStringTable != NULL) {
                        //
                        // No matter how the string table is implemented, I never
                        // want to have a string id of zero - this would generate
                        // an invalid devinst. So, add a small priming string just
                        // to be safe.
                        //
                        pSetupStringTableAddString(hLocalStringTable,
                                                   PRIMING_STRING,
                                                   STRTAB_CASE_SENSITIVE);

                        *phStringTable = hLocalStringTable;

                    } else {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "CFGMGR32: failed to initialize local string table\n"));
                        *phStringTable = NULL;
                    }
                }

                LeaveCriticalSection(&StringTableCriticalSection);

                if (*phStringTable == NULL) {
                    bStatus = FALSE;
                    goto Clean0;
                }

            } else {

                //-------------------------------------------------------
                // Retrieve String Table Handle for the remote machine
                //-------------------------------------------------------

                //
                // validate the machine handle.
                //
                if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                    bStatus = FALSE;
                    goto Clean0;
                }

                //
                // use information within the hMachine handle to set the string
                // table handle.  The hMachine info was set on a previous call
                // to CM_Connect_Machine.
                //
                *phStringTable = ((PPNP_MACHINE)hMachine)->hStringTable;
            }
        }



        if (ARGUMENT_PRESENT(phBindingHandle)) {

            if (hMachine == NULL) {

                //-------------------------------------------------------
                // Retrieve Binding Handle for the local machine
                //-------------------------------------------------------

                EnterCriticalSection(&BindingCriticalSection);

                if (hLocalBindingHandle != NULL) {
                    //
                    // local binding handle has already been set
                    //
                    *phBindingHandle = hLocalBindingHandle;

                } else {
                    //
                    // first time, explicitly force binding to local machine
                    //
                    pnp_handle = PNP_HANDLE_bind(NULL);    // set rpc global

                    if (pnp_handle != NULL) {

                        *phBindingHandle = hLocalBindingHandle = (PVOID)pnp_handle;

                    } else {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "CFGMGR32: failed to initialize local binding handle\n"));
                        *phBindingHandle = NULL;
                    }
                }

                LeaveCriticalSection(&BindingCriticalSection);

                if (*phBindingHandle == NULL) {
                    bStatus = FALSE;
                    goto Clean0;
                }

            } else {

                //-------------------------------------------------------
                // Retrieve Binding Handle for the remote machine
                //-------------------------------------------------------

                //
                // validate the machine handle.
                //
                if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                    bStatus = FALSE;
                    goto Clean0;
                }

                //
                // use information within the hMachine handle to set the
                // binding handle.  The hMachine info was set on a previous call
                // to CM_Connect_Machine.
                //
                *phBindingHandle = ((PPNP_MACHINE)hMachine)->hBindingHandle;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // PnpGetGlobalHandles



HANDLE
PnPEnablePrivileges(
    IN  PULONG  Privileges,
    IN  ULONG   PrivilegeCount
    )

/*++

Routine Description:

    This routine enables the specified privileges in the thread token for the
    calling thread.  If no thread exists (not impersonating), the process token
    is used.

Arguments:

    Privileges - Specifies a list of privileges to enable.

    PrivilegeCount - Specifies the number of privileges in the list.

Return value:

    If successful, returns a handle to the previous thread token (if it exists)
    or NULL, to indicate that the thread did not previously have a token.  If
    successful, ReleasePrivileges should be called to ensure that the previous
    thread token (if exists) is replaced on the calling thread and that the
    handle is closed.

    If unsuccessful, INVALID_HANDLE_VALUE is returned.

Notes:

    This routine is intended to operate on well-known privileges only; no lookup
    of privilege names is done by this routine; it assumes that the privilege
    LUID value for well-known privileges can be constructed from it's
    corresponding ULONG privilege value, via RtlConvertUlongToLuid.

    This is true for SE_LOAD_DRIVER_PRIVILEGE and SE_UNDOCK_PRIVILEGE, which are
    the only privilege values CFGMGR32 uses this routine to enable.  If
    additional pricileges are used where that is not the case, this routine may
    be changed to receive an array of privilege names - with the corresponding
    privilege LUID value lookup performed for each.

--*/

{
    BOOL                 bResult;
    HANDLE               hToken, hNewToken;
    HANDLE               hOriginalThreadToken;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    SECURITY_ATTRIBUTES  sa;
    PTOKEN_PRIVILEGES    pTokenPrivileges;
    ULONG                nBufferSize, i;


    //
    // Validate parameters
    //

    if ((!ARGUMENT_PRESENT(Privileges)) || (PrivilegeCount == 0)) {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    //

    nBufferSize =
        sizeof(TOKEN_PRIVILEGES) +
        ((PrivilegeCount - 1) * sizeof(LUID_AND_ATTRIBUTES));

    pTokenPrivileges = (PTOKEN_PRIVILEGES)
        pSetupMalloc(nBufferSize);

    if (pTokenPrivileges == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Initialize the Privileges Structure
    //

    pTokenPrivileges->PrivilegeCount = PrivilegeCount;
    for (i = 0; i < PrivilegeCount; i++) {
        pTokenPrivileges->Privileges[i].Luid = RtlConvertUlongToLuid(Privileges[i]);
        pTokenPrivileges->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Open the thread token for TOKEN_DUPLICATE access.  We also required
    // READ_CONTROL access to read the security descriptor information.
    //

    hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;

    bResult =
        OpenThreadToken(
            GetCurrentThread(),
            TOKEN_DUPLICATE | READ_CONTROL,
            FALSE,
            &hToken);

    if (bResult) {

        //
        // Remember the previous thread token
        //

        hOriginalThreadToken = hToken;

    } else if (GetLastError() == ERROR_NO_TOKEN) {

        //
        // No thread token - open the process token.
        //

        //
        // Note that if we failed to open the thread token for any other reason,
        // we don't want to open the process token instead.  The caller is
        // impersonating, and opening the process token would defeat that.
        // We'll simply not enable any privileges, and the caller will have to
        // pass any required privilege checks on the merit of their existing
        // thread token.
        //

        bResult =
            OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_DUPLICATE | READ_CONTROL,
                &hToken);
    }

    if (bResult) {

        ASSERT((hToken != NULL) && (hToken != INVALID_HANDLE_VALUE));

        //
        // Copy the security descriptor from whichever token we were able to
        // retrieve so that we can apply it to the duplicated token.
        //
        // Note that if we cannot retrieve the security descriptor for the
        // token, we will not continue on below to duplicate it with the default
        // security descriptor, since it may be more restrictive than that of
        // the original token, and may prevent the client from removing the
        // impersonation token from the thread when restoring privileges.
        //

        bResult =
            GetKernelObjectSecurity(
                hToken,
                DACL_SECURITY_INFORMATION,
                NULL,
                0,
                &nBufferSize);

        if ((!bResult) &&
            (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

            ASSERT(nBufferSize > 0);

            pSecurityDescriptor = (PSECURITY_DESCRIPTOR)
                pSetupMalloc(nBufferSize);

            if (pSecurityDescriptor != NULL) {

                bResult =
                    GetKernelObjectSecurity(
                        hToken,
                        DACL_SECURITY_INFORMATION,
                        pSecurityDescriptor,
                        nBufferSize,
                        &nBufferSize);
            }

        } else {
            bResult = FALSE;
        }
    }

    if (bResult) {

        ASSERT(pSecurityDescriptor != NULL);

        //
        // Duplicate whichever token we were able to retrieve, using the
        // token's security descriptor.
        //

        ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSecurityDescriptor;
        sa.bInheritHandle = FALSE;

        bResult =
            DuplicateTokenEx(
                hToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &sa,                    // PSECURITY_ATTRIBUTES
                SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                TokenImpersonation,     // TokenType
                &hNewToken);            // Duplicate token

        if (bResult) {

            ASSERT((hNewToken != NULL) && (hNewToken != INVALID_HANDLE_VALUE));

            //
            // Adjust the privileges of the duplicated token.  We don't care
            // about its previous state because we still have the original
            // token.
            //

            bResult =
                AdjustTokenPrivileges(
                    hNewToken,        // TokenHandle
                    FALSE,            // DisableAllPrivileges
                    pTokenPrivileges, // NewState
                    0,                // BufferLength
                    NULL,             // PreviousState
                    NULL);            // ReturnLength

            if (bResult) {
                //
                // Begin impersonating with the new token
                //
                bResult =
                    SetThreadToken(
                        NULL,
                        hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    //
    // If something failed, don't return a token
    //

    if (!bResult) {
        hOriginalThreadToken = INVALID_HANDLE_VALUE;
    }

    //
    // Close the original token if we aren't returning it
    //

    if ((hOriginalThreadToken == INVALID_HANDLE_VALUE) &&
        (hToken != INVALID_HANDLE_VALUE)) {
        CloseHandle(hToken);
    }

    //
    // If we succeeded, but there was no original thread token, return NULL.
    // PnPRestorePrivileges will simply remove the current thread token.
    //

    if (bResult && (hOriginalThreadToken == INVALID_HANDLE_VALUE)) {
        hOriginalThreadToken = NULL;
    }

    if (pSecurityDescriptor != NULL) {
        pSetupFree(pSecurityDescriptor);
    }

    pSetupFree(pTokenPrivileges);

    return hOriginalThreadToken;

} // PnPEnablePrivileges



VOID
PnPRestorePrivileges(
    IN  HANDLE  hToken
    )

/*++

Routine Description:

    This routine restores the privileges of the calling thread to their state
    prior to a corresponding call to PnPEnablePrivileges.

Arguments:

    hToken - Return value from corresponding call to PnPEnablePrivileges.

Return value:

    None.

Notes:

    If the corresponding call to PnPEnablePrivileges returned a handle to the
    previous thread token, this routine will restore it, and close the handle.

    If PnPEnablePrivileges returned NULL, no thread token previously existed.
    This routine will remove any existing token from the thread.

    If PnPEnablePrivileges returned INVALID_HANDLE_VALUE, the attempt to enable
    the specified privileges failed, but the previous state of the thread was
    not modified.  This routine does nothing.

--*/

{
    BOOL                bResult;


    //
    // First, check if we actually need to do anything for this thread.
    //

    if (hToken != INVALID_HANDLE_VALUE) {

        //
        // Call SetThreadToken for the current thread with the specified hToken.
        // If the handle value is NULL, SetThreadToken will remove the current
        // thread token from the thread.  Ignore the return, there's nothing we
        // can do about it.
        //

        bResult = SetThreadToken(NULL, hToken);

        if (hToken != NULL) {
            //
            // Close the handle to the token.
            //
            CloseHandle(hToken);
        }
    }

    return;

} // PnPRestorePrivileges



CONFIGRET
IsRemoteServiceRunning(
    IN  LPCWSTR   UNCServerName,
    IN  LPCWSTR   ServiceName
    )

/*++

Routine Description:

   This routine connects to the active service database of the Service Control
   Manager (SCM) on the machine specified and returns whether or not the
   specified service is running.

Arguments:

   UNCServerName - Specifies the name of the remote machine.

   ServiceName   - Specifies the name of the service whose status is to be
                   queried.

Return value:

   Returns TRUE if the specified service is installed on the remote machine and
   is currently in the SERVICE_RUNNING state, FALSE otherwise.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    DWORD          Err;
    SC_HANDLE      hSCManager = NULL, hService = NULL;
    SERVICE_STATUS ServiceStatus;


    //
    // Open the Service Control Manager
    //
    hSCManager = OpenSCManager(
        UNCServerName,            // computer name
        SERVICES_ACTIVE_DATABASE, // SCM database name
        SC_MANAGER_CONNECT        // access type
        );

    if (hSCManager == NULL) {
        Err = GetLastError();
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: OpenSCManager failed, error = %d\n",
                   Err));
        if (Err == ERROR_ACCESS_DENIED) {
            Status = CR_ACCESS_DENIED;
        } else {
            Status = CR_MACHINE_UNAVAILABLE;
        }
        goto Clean0;
    }

    //
    // Open the service
    //
    hService = OpenService(
        hSCManager,               // handle to SCM database
        ServiceName,              // service name
        SERVICE_QUERY_STATUS      // access type
        );

    if (hService == NULL) {
        Err = GetLastError();
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: OpenService failed, error = %d\n",
                   Err));
        if (Err == ERROR_ACCESS_DENIED) {
            Status = CR_ACCESS_DENIED;
        } else {
            Status = CR_NO_CM_SERVICES;
        }
        goto Clean0;
    }

    //
    // Query the service status
    //
    if (!QueryServiceStatus(hService,
                            &ServiceStatus)) {
        Err = GetLastError();
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: QueryServiceStatus failed, error = %d\n",
                   Err));
        if (Err == ERROR_ACCESS_DENIED) {
            Status = CR_ACCESS_DENIED;
        } else {
            Status = CR_NO_CM_SERVICES;
        }
        goto Clean0;
    }

    //
    // Check if the service is running.
    //
    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
        Status = CR_NO_CM_SERVICES;
        goto Clean0;
    }

 Clean0:

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return Status;

} // IsRemoteServiceRunning
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\detect.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       detect.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


typedef
UINT
(*PINSTALLSELECTEDDEVICE)(
    HWND hwndParent,
    HDEVINFO hDeviceInfo,
    PDWORD pReboot
    );

PINSTALLSELECTEDDEVICE pInstallSelectedDevice = NULL;


/*
 * BuildMissingAndNew
 *
 * worker routine for BuildDeviceDetection.
 *
 * On entry:
 * Missing contains known devices prior to class installer detection.
 * Detected contains devices detected by class installer.
 * NewDevices is an empty list.
 *
 * If a device is in Missing and not in Detected, then it is missing.
 * If a device is in Detected and not in Missing, then it is newly detected.
 *
 * On Exit:
 * Missing contains only missing devices,
 * Detected gone.
 * NewDevices contains those that were newly detectd
 *
 */
BOOL
BuildMissingAndNew(
    PCLASSDEVINFO ClassDevInfo
    )
{
    HDEVINFO Missing, Detected;
    int iMissing, iDetect;
    ULONG DevNodeStatus, Problem;
    SP_DEVINFO_DATA DevInfoDataDetect;
    SP_DEVINFO_DATA DevInfoDataMissing;
    BOOL Removed;

    Detected   = ClassDevInfo->Detected;
    Missing    = ClassDevInfo->Missing;

    DevInfoDataMissing.cbSize = sizeof(DevInfoDataMissing);
    DevInfoDataDetect.cbSize = sizeof(DevInfoDataDetect);



    //
    // For each member of the detected list, fetch its Device ID
    // and see if it exists in the missing list.
    //

BMNBuildDetectedList:
    Removed = FALSE;
    iMissing = 0;
    
    while (SetupDiEnumDeviceInfo(Missing, iMissing++, &DevInfoDataMissing)) {

        iDetect = 0;
        while (SetupDiEnumDeviceInfo(Detected, iDetect++, &DevInfoDataDetect)) {

            //
            // If Found in both lists, its not a new device and exists(not missing).
            // remove it from both lists.
            //

            if (DevInfoDataDetect.DevInst == DevInfoDataMissing.DevInst) {

                SetupDiDeleteDeviceInfo(Missing, &DevInfoDataMissing);
                SetupDiDeleteDeviceInfo(Detected, &DevInfoDataDetect);
                Removed = TRUE;
                break;
            }
        }
    }

    //
    // If a device info was removed, the enumeration index changes
    // and we will miss some in the list. Rescan until none are deleted.
    //

    if (Removed && SetupDiEnumDeviceInfo(Detected, 0, &DevInfoDataDetect)) {

        goto BMNBuildDetectedList;
    }


    //
    // Remove devices which are up and running from the misssing list,
    // since they are obviously present. Class installers may not report
    // all devices which are present, if they are already installed and
    // running. e.g. Bios enumerated devices. We also check that it is
    // a Root Enumerated Device (not a PnP BIOS device) and that it was
    // not a manually installed device.
    //

BMNRemoveLiveFromMissing:
    Removed = FALSE;
    iMissing = 0;

    while (SetupDiEnumDeviceInfo(Missing, iMissing++, &DevInfoDataMissing)) {

        if ((CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  DevInfoDataMissing.DevInst,
                                  0) == CR_SUCCESS) &&
            ((DevNodeStatus & DN_STARTED) &&
             !(DevNodeStatus & DN_HAS_PROBLEM)) ||
             !(DevNodeStatus & DN_ROOT_ENUMERATED) ||
            (DevNodeStatus & DN_MANUAL)) {
            
            SetupDiDeleteDeviceInfo(Missing, &DevInfoDataMissing);
            Removed = TRUE;
        }
    }


    if (Removed) {

        goto BMNRemoveLiveFromMissing;
    }


    //
    // Register the newly detected devices
    //

BMNRegisterDetected:
    Removed = FALSE;
    iDetect = 0;

    while (SetupDiEnumDeviceInfo(Detected, iDetect++, &DevInfoDataDetect)) {

        if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                       Detected,
                                       &DevInfoDataDetect
                                       )) {
                                       
            SetupDiDeleteDeviceInfo(Detected, &DevInfoDataDetect);
            Removed = TRUE;
        }
    }

    if (Removed) {
    
        goto BMNRegisterDetected;
    }


    //
    // if the missing devices list is empty, don't need it anymore either
    //
    if (!SetupDiEnumDeviceInfo(Missing, 0, &DevInfoDataMissing)) {
    
        SetupDiDestroyDeviceInfoList(Missing);
        ClassDevInfo->Missing = NULL;
    }

    return SetupDiEnumDeviceInfo(Detected, 0, &DevInfoDataDetect) || ClassDevInfo->Missing;
}

BOOL
DevInstIsSelected(
   HWND hwndListView,
   DEVINST DevInst
   )
{
    LVITEM lvItem;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = -1;

    while ((lvItem.iItem = ListView_GetNextItem(hwndListView, lvItem.iItem, LVNI_ALL)) != -1) {
    
        ListView_GetItem(hwndListView, &lvItem);

        if (lvItem.lParam == (LPARAM)DevInst) {
        
            // Image list is 0 based, and one means checked.
            return (ListView_GetCheckState(hwndListView, lvItem.iItem) == 1);
        }
    }

    return FALSE;
}

void
RemoveDeviceInfo(
   HDEVINFO DeviceInfo,
   HWND hwndListView
   )
{
    int Index;
    SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;
    SP_DEVINFO_DATA DevInfoData;

    Index = 0;
    DevInfoData.cbSize = sizeof(DevInfoData);

    while (SetupDiEnumDeviceInfo(DeviceInfo, Index++, &DevInfoData)) {
    
        if (!hwndListView || DevInstIsSelected(hwndListView, DevInfoData.DevInst)) {
       
            RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
            RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
            RemoveDeviceParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(DeviceInfo,
                                            &DevInfoData,
                                            (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                            sizeof(RemoveDeviceParams)
                                            )) {
                                            
                SetupDiCallClassInstaller(DIF_REMOVE, DeviceInfo, &DevInfoData);
            }

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(DeviceInfo,
                                         &DevInfoData,
                                         NULL,
                                         0
                                         );
        }
    }

    SetupDiDestroyDeviceInfoList(DeviceInfo);
}

void
DestroyClassDevinfo(
    PCLASSDEVINFO ClassDevInfo
    )
{
    if (ClassDevInfo->Missing) {
    
        SetupDiDestroyDeviceInfoList(ClassDevInfo->Missing);
        ClassDevInfo->Missing = NULL;
    }

    if (ClassDevInfo->Detected) {
    
        SetupDiDestroyDeviceInfoList(ClassDevInfo->Detected);
        ClassDevInfo->Detected = NULL;
    }
}

void
DestroyDeviceDetection(
    PHARDWAREWIZ HardwareWiz,
    BOOL DetectionCancelled
    )
{
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;

    if (!HardwareWiz->DeviceDetection) {
        
        return;
    }

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
        if (DetectionCancelled) {

            //
            // If there is a detected list,
            // then invoke the class installer DIF_DETECTCANCEL for its cleanup.
            //

            if (ClassDevInfo->Detected) {
           
                SetupDiCallClassInstaller(DIF_DETECTCANCEL, ClassDevInfo->Detected, NULL);

                //
                // Remove all newly detected devices.
                //

                if (ClassDevInfo->Detected) {
               
                    RemoveDeviceInfo(ClassDevInfo->Detected, NULL);
                    ClassDevInfo->Detected = NULL;
                }
            }
        }

        DestroyClassDevinfo(ClassDevInfo);
        ClassDevInfo++;
        ClassGuid++;
    }

    if (DetectionCancelled) {
    
        HardwareWiz->Reboot = FALSE;
    }

    LocalFree(HardwareWiz->DeviceDetection);
    HardwareWiz->DeviceDetection = NULL;
}

BOOL
DetectProgressNotify(
    PVOID pvProgressNotifyParam,
    DWORD DetectComplete
    )
{
    PHARDWAREWIZ HardwareWiz = pvProgressNotifyParam;
    BOOL ExitDetect;

    try  {
    
        ExitDetect = HardwareWiz->ExitDetect;

        HardwareWiz->DeviceDetection->ClassProgress += DetectComplete;

        SendDlgItemMessage(HardwareWiz->DeviceDetection->hDlg,
                           IDC_HDW_DETWARN_PROGRESSBAR,
                           PBM_SETPOS,
                           DetectComplete,
                           0
                           );

        SendDlgItemMessage(HardwareWiz->DeviceDetection->hDlg,
                           IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                           PBM_SETPOS,
                           (HardwareWiz->DeviceDetection->TotalProgress + DetectComplete/100),
                           0
                           );
    }

    except(EXCEPTION_EXECUTE_HANDLER)  {
    
        ExitDetect = TRUE;
    }

    return ExitDetect;
}

VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount
    )
/*++

Routine Description:

        This routine sorts the supplied list of GUID based on a (partial) ordering
        specified in the [DetectionOrder] section of syssetup.inf.  This allows us
        to maintain a detection ordering similar to previous versions of NT.

Arguments:

        GuidList - address of the array of GUIDs to be sorted.

        GuidCount - the number of GUIDs in the array.

Return Value:

        none.

--*/
{
    HINF SyssetupInf;
    LONG LineCount, LineIndex, GuidIndex, NextTopmost;
    PCWSTR CurGuidString;
    INFCONTEXT InfContext;
    GUID CurGuid;

    if ((SyssetupInf = SetupOpenInfFile(L"syssetup.inf",
                                        NULL,
                                        INF_STYLE_WIN4,
                                        NULL
                                        )
         ) == INVALID_HANDLE_VALUE) {

        return;
    }

    LineCount = SetupGetLineCount(SyssetupInf, L"DetectionOrder");
    NextTopmost = 0;

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"DetectionOrder", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString((PWCHAR)CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move the GUID from
        // it's current position to the next topmost position.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {

                if(NextTopmost != GuidIndex) {
                    //
                    // We should never be moving the GUID _down_ the list.
                    //
                    MoveMemory(&(GuidList[NextTopmost + 1]),
                               &(GuidList[NextTopmost]),
                               (GuidIndex - NextTopmost) * sizeof(GUID)
                              );

                    CopyMemory(&(GuidList[NextTopmost]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                NextTopmost++;
                break;
            }
        }
    }

    SetupCloseInfFile(SyssetupInf);
}

void
BuildDeviceDetection(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO hDeviceInfo;
    int ClassGuidNum;
    LPGUID ClassGuid;
    PCLASSDEVINFO ClassDevInfo;
    SP_DETECTDEVICE_PARAMS DetectDeviceParams;
    TCHAR ClassName[MAX_PATH];
    TCHAR Buffer[MAX_PATH + 64];
    TCHAR Format[64];

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    SortClassGuidListForDetection(ClassGuid, ClassGuidNum);

    DetectDeviceParams.ClassInstallHeader.cbSize = sizeof(DetectDeviceParams.ClassInstallHeader);
    DetectDeviceParams.ClassInstallHeader.InstallFunction = DIF_DETECT;
    DetectDeviceParams.DetectProgressNotify = DetectProgressNotify;
    DetectDeviceParams.ProgressNotifyParam  = HardwareWiz;

    HardwareWiz->DeviceDetection->TotalProgress = 0;
    HardwareWiz->DeviceDetection->hDlg = hwndParent;
    SetDlgText(hwndParent, IDC_HDW_DETWARN_PROGRESSTEXT, IDS_DETECTPROGRESS, IDS_DETECTPROGRESS);

    while (!HardwareWiz->ExitDetect && ClassGuidNum--) 
    {
        hDeviceInfo = SetupDiGetClassDevs(ClassGuid,
                                          REGSTR_KEY_ROOTENUM,
                                          hwndParent,
                                          DIGCF_PROFILE
                                          );

        if (hDeviceInfo != INVALID_HANDLE_VALUE) 
        {
            ClassDevInfo->Missing = hDeviceInfo;
        }


        hDeviceInfo =  SetupDiCreateDeviceInfoList(ClassGuid, hwndParent);
        if (hDeviceInfo != INVALID_HANDLE_VALUE) 
        {
            ClassDevInfo->Detected = hDeviceInfo;
        }

        HardwareWiz->DeviceDetection->ClassGuid = ClassGuid;
        HardwareWiz->DeviceDetection->ClassProgress = 0;

        // set progress bar to zero.
        SendDlgItemMessage(hwndParent,
                           IDC_HDW_DETWARN_PROGRESSBAR,
                           PBM_SETPOS,
                           0,
                           0
                           );

        if (!SetupDiGetClassDescription(HardwareWiz->DeviceDetection->ClassGuid,
                                        ClassName,
                                        SIZECHARS(ClassName),
                                        NULL
                                        )
            &&
            !SetupDiClassNameFromGuid(HardwareWiz->DeviceDetection->ClassGuid,
                                      ClassName,
                                      SIZECHARS(ClassName),
                                      NULL
                                      ))
        {
            *ClassName = TEXT('\0');
        }

        LoadString(hHdwWiz, IDS_DETECTCLASS, Format, SIZECHARS(Format));
        StringCchPrintf(Buffer, SIZECHARS(Buffer), Format, ClassName);

        SetDlgItemText(hwndParent,
                       IDC_HDW_DETWARN_PROGRESSTEXT,
                       Buffer
                       );

        if (!IsEqualGUID(ClassGuid, &GUID_NULL) &&
            !IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN) &&
            ClassDevInfo->Missing &&
            ClassDevInfo->Detected &&
            SetupDiSetClassInstallParams(ClassDevInfo->Detected,
                                         NULL,
                                         &DetectDeviceParams.ClassInstallHeader,
                                         sizeof(DetectDeviceParams)
                                         )
            &&
            SetupDiCallClassInstaller(DIF_DETECT, ClassDevInfo->Detected, NULL))
        {
            SP_DEVINSTALL_PARAMS DeviceInstallParams;
            SendDlgItemMessage(hwndParent,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETPOS,
                               HardwareWiz->DeviceDetection->TotalProgress,
                               0
                               );

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(ClassDevInfo->Detected,
                                         NULL,
                                         NULL,
                                         0
                                         );

            //
            // Get the device install parameters for the reboot flags.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(ClassDevInfo->Detected,
                                              NULL,
                                              &DeviceInstallParams
                                              ))
            {
                HardwareWiz->DeviceDetection->Reboot |= DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT);
            }


            if (BuildMissingAndNew(ClassDevInfo)) 
            {
                HardwareWiz->DeviceDetection->MissingOrNew = TRUE;
            }
        }
        
        else 
        {
            DestroyClassDevinfo(ClassDevInfo);
        }

        HardwareWiz->DeviceDetection->TotalProgress += 10;
        SendDlgItemMessage(hwndParent, IDC_HDW_DETWARN_PROGRESSBAR, PBM_SETPOS, 100, 0);
        SendDlgItemMessage(hwndParent, IDC_HDW_DETWARN_TOTALPROGRESSBAR, PBM_STEPIT, 0, 0);
        ClassDevInfo++;
        ClassGuid++;
    }
}

INT_PTR CALLBACK
HdwDetectionDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        break;
        }

    case WM_DESTROY:
        CancelSearchRequest(HardwareWiz);
        DestroyDeviceDetection(HardwareWiz, FALSE);
        break;

    break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
           int Len, PrevPage;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTION;

                // Coming back, after doing a previous detection
            if (PrevPage == IDD_ADDDEVICE_DETECTINSTALL) {
                DestroyDeviceDetection(HardwareWiz, TRUE);
                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);
                break;
                }


            //
            // Only back,cancel button, when detection completes ok, we will
            // jump directly to the next page.
            //

            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK );

            // refresh the class guid list
            HdwBuildClassInfoList(HardwareWiz, 
                                  DIBCI_NOINSTALLCLASS
                                  );

            // allocate memory for DeviceDetection data
            Len = sizeof(DEVICEDETECTION) + (HardwareWiz->ClassGuidNum * sizeof(CLASSDEVINFO));
            HardwareWiz->DeviceDetection = LocalAlloc(LPTR, Len);
            if (!HardwareWiz->DeviceDetection) {
                
                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);
                break;
            }

            memset(HardwareWiz->DeviceDetection, 0, Len);
            HardwareWiz->ExitDetect = FALSE;

            // set progress bar to zero.
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETPOS,
                               0,
                               0
                               );

            // set the range to 10 * number of classes
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETRANGE,
                               0,
                               MAKELPARAM(0, 10 * HardwareWiz->ClassGuidNum)
                               );

            // set the step to 10.
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETSTEP,
                               10,
                               0
                               );


            HardwareWiz->CurrCursor = HardwareWiz->IdcAppStarting;
            SetCursor(HardwareWiz->CurrCursor);

            SearchThreadRequest(HardwareWiz->SearchThread,
                                hDlg,
                                SEARCH_DETECT,
                                0
                                );

            }
            break;


        case PSN_QUERYCANCEL:

            if (HardwareWiz->ExitDetect) {
                SetDlgMsgResult(hDlg, wMsg, TRUE);
                }

            HardwareWiz->ExitDetect = TRUE;
            HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
            SetCursor(HardwareWiz->CurrCursor);
            CancelSearchRequest(HardwareWiz);
            HardwareWiz->CurrCursor = NULL;

            SetDlgMsgResult(hDlg, wMsg, FALSE);
            break;

        case PSN_RESET:
            DestroyDeviceDetection(HardwareWiz, TRUE);
            break;


            //
            // we receive back if
            //   coming back from a previous search result
            //   when user wants to stop current search.
            //

        case PSN_WIZBACK:
            if (HardwareWiz->DeviceDetection) {
                if (HardwareWiz->ExitDetect) {
                    SetDlgMsgResult(hDlg, wMsg, -1);
                    break;
                    }

                HardwareWiz->ExitDetect = TRUE;
                HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                SetCursor(HardwareWiz->CurrCursor);
                CancelSearchRequest(HardwareWiz);
                HardwareWiz->CurrCursor = NULL;

                DestroyDeviceDetection(HardwareWiz, TRUE);
                }

            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ASKDETECT);
            break;


             //
             // next button is off, we only receive this after doing detection.
             //

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTINSTALL);
            break;

        }
        break;


    case WUM_DETECT:
        HardwareWiz->CurrCursor = NULL;
        SetCursor(HardwareWiz->IdcArrow);

        if (HardwareWiz->ExitDetect == TRUE) {
            break;
            }

        //
        // finish building the missing\detected stuff
        //

        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

        break;

    case WM_SETCURSOR:
        if (HardwareWiz->CurrCursor) {
            SetCursor(HardwareWiz->CurrCursor);
            break;
            }

         // fall thru to return(FALSE);


    default:
        return(FALSE);
    }

    return(TRUE);
}







DWORD
InstallNewDevices(
    HWND     hwndParent,
    HDEVINFO NewDevices,
    HWND     hwndListView
    )
{
    DWORD Reboot, dwRet = 0;
    int iNewDevices;
    SP_DEVINFO_DATA DevInfoData;

    DevInfoData.cbSize = sizeof(DevInfoData);
    iNewDevices = 0;
    Reboot = 0;

    while (SetupDiEnumDeviceInfo(NewDevices, iNewDevices++, &DevInfoData)) {
   
        if (DevInstIsSelected(hwndListView, DevInfoData.DevInst)) {
          
            SetupDiSetSelectedDevice(NewDevices, &DevInfoData);

            if (hNewDev) {

                if (!pInstallSelectedDevice) {

                    pInstallSelectedDevice = (PINSTALLSELECTEDDEVICE)GetProcAddress(hNewDev, "InstallSelectedDevice");
                }
            }

            if (pInstallSelectedDevice) {

                pInstallSelectedDevice(hwndParent,
                                       NewDevices,
                                       &dwRet
                                       );
            }

        } else {
          
            SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;

            RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
            RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
            RemoveDeviceParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(NewDevices,
                                             &DevInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                             sizeof(RemoveDeviceParams)
                                             )) {
                                             
                SetupDiCallClassInstaller(DIF_REMOVE, NewDevices, &DevInfoData);
            }


            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(NewDevices,
                                         &DevInfoData,
                                         NULL,
                                         0
                                         );
        }

        Reboot |= dwRet;
    }

    SetupDiDestroyDeviceInfoList(NewDevices);

    return Reboot;
}



/*
 * InstallMissingAndNewDevices
 *
 * Missing devices are removed.
 * NewDevices are installed by invoking InstallDevic
 *
 */
void
InstallDetectedDevices(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    )
{
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;
    HWND hwndDetectList;

    if (!HardwareWiz->DeviceDetection) {
    
        return;
    }

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;
    hwndDetectList = GetDlgItem(hwndParent,IDC_HDW_INSTALLDET_LIST);;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Missing) {
       
           RemoveDeviceInfo(ClassDevInfo->Missing, hwndDetectList);
           ClassDevInfo->Missing = NULL;
       }

       if (ClassDevInfo->Detected) {
       
           HardwareWiz->Reboot |= InstallNewDevices(hwndParent, ClassDevInfo->Detected, hwndDetectList);
           ClassDevInfo->Detected = NULL;
       }

       ClassDevInfo++;
       ClassGuid++;
   }

   HardwareWiz->DeviceDetection->MissingOrNew = FALSE;
}

void
AddDeviceDescription(
    PHARDWAREWIZ HardwareWiz,
    HWND hListView,
    HDEVINFO Devices,
    BOOL Install
    )
{
    PTCHAR FriendlyName;
    LV_ITEM lviItem;
    int iItem;
    int iDevices;
    GUID ClassGuid;
    SP_DEVINFO_DATA DevInfoData;
    SP_DRVINFO_DATA DriverInfoData;
    TCHAR Format[LINE_LEN];
    TCHAR DeviceDesc[MAX_PATH*2];
    TCHAR String[LINE_LEN];

    if (Install) {

        LoadString(hHdwWiz, IDS_INSTALL_LEGACY_DEVICE, Format, SIZECHARS(Format));

    } else {

        LoadString(hHdwWiz, IDS_UNINSTALL_LEGACY_DEVICE, Format, SIZECHARS(Format));
    }


    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;
    lviItem.state = 0;
    lviItem.stateMask = LVIS_SELECTED;

    if (HardwareWiz->ClassImageList.cbSize &&
        SetupDiGetDeviceInfoListClass(Devices, &ClassGuid) &&
        SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &ClassGuid,
                                  &lviItem.iImage
                                  ))
    {
        lviItem.mask |= LVIF_IMAGE;
    }


    DevInfoData.cbSize = sizeof(DevInfoData);
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    iDevices = 0;
    while (SetupDiEnumDeviceInfo(Devices, iDevices++, &DevInfoData)) {

        lviItem.lParam = DevInfoData.DevInst;

        //
        // Add the device description to the list view control.
        // NOTE: We don't error out if the DeviceDesc buffer is too small,
        // since this will just cause the device description to get
        // cut off a little bit.
        //
        if (SetupDiGetSelectedDriver(Devices,
                                     &DevInfoData,
                                     &DriverInfoData
                                     )
            &&
            *DriverInfoData.Description)
        {
            StringCchCopy(DeviceDesc, SIZECHARS(DeviceDesc), DriverInfoData.Description);
        }

        else 
        {
            FriendlyName = BuildFriendlyName(DevInfoData.DevInst);
            
            if (FriendlyName) {
            
                StringCchCopy(DeviceDesc, SIZECHARS(DeviceDesc), FriendlyName);
                LocalFree(FriendlyName);
            }
            else {
                StringCchCopy(DeviceDesc, SIZECHARS(DeviceDesc), szUnknown);
            }
        }

        StringCchPrintf(String, SIZECHARS(String), Format, DeviceDesc);

        lviItem.pszText = String;

        //
        // Send it to the listview
        //
        iItem = ListView_InsertItem(hListView, &lviItem);

        if (iItem != -1) {
        
            // set the checkbox, control uses one based index, while imageindex is zero based
            ListView_SetItemState(hListView, iItem, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
        }
    }
}

void
ShowDetectedDevices(
    HWND       hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;
    HWND    hwndDetectList;

    hwndDetectList = GetDlgItem(hDlg,IDC_HDW_INSTALLDET_LIST);
    SendMessage(hwndDetectList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndDetectList);

    if (HardwareWiz->ClassImageList.cbSize) {
    
        ListView_SetImageList(hwndDetectList,
                              HardwareWiz->ClassImageList.ImageList,
                              LVSIL_SMALL
                              );
    }

    //
    // Display the new devices
    //

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Detected) {
       
           AddDeviceDescription(HardwareWiz, hwndDetectList, ClassDevInfo->Detected, TRUE);
       }
       
       ClassDevInfo++;
       ClassGuid++;
   }



    //
    // Display the missing devices
    //

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Missing) {
       
           AddDeviceDescription(HardwareWiz, hwndDetectList, ClassDevInfo->Missing, FALSE);
       }

       ClassDevInfo++;
       ClassGuid++;
   }


    //
    // scroll the first item into view.
    //

    ListView_EnsureVisible(hwndDetectList, 0, FALSE);
    ListView_SetColumnWidth(hwndDetectList, 0, LVSCW_AUTOSIZE_USEHEADER);
    SendMessage(hwndDetectList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
HdwDetectInstallDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);
    TCHAR PropSheetHeaderTitle[MAX_PATH];

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg)  {
    case WM_INITDIALOG: {
        HWND hwndDetectList;
        LV_COLUMN lvcCol;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);


        hwndDetectList = GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST);

        // Insert a column for the class list
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndDetectList, 0, &lvcCol);

        ListView_SetExtendedListViewStyleEx(hwndDetectList, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTINSTALL;

            if (HardwareWiz->DeviceDetection->MissingOrNew) {
                
                ShowDetectedDevices(hDlg, HardwareWiz);
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_INSTALLDET1, IDS_HDW_INSTALLDET1);
                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);

                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LISTTITLE), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST), SW_SHOW);
            }
            
            else if (HardwareWiz->DeviceDetection->Reboot) {
                
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTREBOOT);
                break;
            }
            
            else {

                //
                // hide the list box
                //
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LISTTITLE), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST), SW_HIDE);

                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_NONEDET1, IDS_HDW_NONEDET1);
                if (LoadString(hHdwWiz, 
                               IDS_ADDDEVICE_DETECTINSTALL_NONE,
                               PropSheetHeaderTitle,
                               SIZECHARS(PropSheetHeaderTitle)
                               )) {
                    PropSheet_SetHeaderTitle(GetParent(hDlg),
                                             PropSheet_IdToIndex(GetParent(hDlg), IDD_ADDDEVICE_DETECTINSTALL),
                                             PropSheetHeaderTitle
                                             );
                }
                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
            }

            break;


        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTION);
            break;


        case PSN_WIZNEXT:
            if (HardwareWiz->DeviceDetection->MissingOrNew) {
                
                InstallDetectedDevices(hDlg, HardwareWiz);
                HardwareWiz->Reboot |= HardwareWiz->DeviceDetection->Reboot;

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTREBOOT);

            }
            
            else {
                
                DestroyDeviceDetection(HardwareWiz, FALSE);
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
            }

            break;

        case PSN_RESET:
            DestroyDeviceDetection(HardwareWiz, TRUE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
HdwDetectRebootDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTREBOOT;
            if (HardwareWiz->Reboot && HardwareWiz->PromptForReboot) {
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_REBOOTDET, IDS_HDW_REBOOTDET);
            }
            
            else {
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_NOREBOOTDET, IDS_HDW_NOREBOOTDET);
            }


            //
            // no back, no next! This page is just to confirm that the
            // user will continue detection after rebooting.
            //
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_FINISH);
            EnableWindow(GetDlgItem(hwndParentDlg, IDCANCEL), FALSE);
            break;


        case PSN_WIZFINISH:
            DestroyDeviceDetection(HardwareWiz, FALSE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\analyze.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       analyze.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <infstr.h>

BOOL
DeviceHasForcedConfig(
   DEVINST DeviceInst
   )
/*++

    This function checks to see if a given DevInst has a forced config or
    not.
    
--*/
{
    CONFIGRET ConfigRet;

    ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, FORCED_LOG_CONF, NULL);
    if (ConfigRet == CR_SUCCESS) 
    {
        return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK
InstallNewDeviceDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
        
    case WM_INITDIALOG: {
            
        HICON hIcon;
        HWND hwndParentDlg;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        hIcon = LoadIcon(hHdwWiz,MAKEINTRESOURCE(IDI_HDWWIZICON));
            
        if (hIcon) {

            hwndParentDlg = GetParent(hDlg);
            SendMessage(hwndParentDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
            SendMessage(hwndParentDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        }
        break;

    }

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
            
        switch (((NMHDR FAR *)lParam)->code) {
                
        case PSN_SETACTIVE: {

            int PrevPage;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_INSTALLNEWDEVICE;

            //
            // If we are coming back then this is effectively a Cancel
            // of the install.
            //

            if (PrevPage == IDD_ADDDEVICE_SELECTDEVICE ||
                PrevPage == IDD_ADDDEVICE_SELECTCLASS )
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                break;
            }


            //
            // If we have a class then jump into SelectDevice.
            // otherwise goto search pages.
            //

            if (HardwareWiz->ClassGuidSelected) {

                HardwareWiz->EnterInto = IDD_ADDDEVICE_SELECTDEVICE;
                HardwareWiz->EnterFrom = IDD_INSTALLNEWDEVICE;
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);

            } else {

                HardwareWiz->EnterInto = IDD_ADDDEVICE_SELECTCLASS;
                HardwareWiz->EnterFrom = IDD_INSTALLNEWDEVICE;
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
            }
        }
        break;
                                
        case PSN_WIZNEXT:
            break;

        case PSN_RESET:
            HardwareWiz->Cancelled = TRUE;
            break;
        }
        break;
            
    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
CompareInfIdToHardwareIds(
    LPTSTR     HardwareId,
    LPTSTR     InfDeviceId
    )
/*++

    This function takes a pointer to the Hardware/Compatible Id list for a device and
    a DeviceId that we got from the INF.  It enumerates through all of the device's
    Hardware and Compatible Ids comparing them against the Device Id we got from the INF.
    If one of the device's Hardware or Compatible Ids match the API returns TRUE, otherwise
    it returns FALSE.
    
--*/
{
    while (*HardwareId) {
    
        if (_wcsicmp(HardwareId, InfDeviceId) == 0) {
        
            return TRUE;
        }

        HardwareId = HardwareId + lstrlen(HardwareId) + 1;
    }

    return(FALSE);
}

/*
 * RegisterDeviceNode
 *
 * Determines if device is a legacy or pnp style device,
 * Registers the device (phantomn devnode to real devnode).
 *
 */
DWORD
RegisterDeviceNode(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{

    DWORD FieldCount, Index, Len;
    HINF hInf = INVALID_HANDLE_VALUE;
    LPTSTR HardwareId;
    SP_DRVINFO_DATA  DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData = NULL;
    INFCONTEXT InfContext;
    TCHAR InfDeviceID[MAX_DEVICE_ID_LEN];
    TCHAR SectionName[LINE_LEN*2];
    LONG LastError;
    HardwareWiz->CopyFilesOnly= FALSE;

    //
    // Fetch the DriverInfoDetail, with enough space for lots of hardwareIDs.
    //
    Len = sizeof(SP_DRVINFO_DETAIL_DATA) + MAX_PATH*sizeof(TCHAR);
    DriverInfoDetailData = LocalAlloc(LPTR, Len);
    
    if (!DriverInfoDetailData) {

        goto AnalyzeExit;
    }
    
    DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        goto AnalyzeExit;
    }


    if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                    &HardwareWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    DriverInfoDetailData,
                                    Len,
                                    &Len
                                    ))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        
            LocalFree(DriverInfoDetailData);
            DriverInfoDetailData = LocalAlloc(LPTR, Len);

            if (!DriverInfoDetailData) {
            
                goto AnalyzeExit;
            }

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                            &HardwareWiz->DeviceInfoData,
                                            &DriverInfoData,
                                            DriverInfoDetailData,
                                            Len,
                                            NULL
                                            ))
            {
                goto AnalyzeExit;
            }

        } else {
        
            goto AnalyzeExit;
        }
    }


    //
    // Get a handle to the inf file.
    //
    hInf = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // If this is an old style inf file, then we can't write out
        // the logconfigs for classes which allow old style infs this is Ok,
        // If its an invalid or missing inf, it will fail further
        // down the chain of execution
        //

        goto AnalyzeExit;
    }



    //
    // Check InfFile for ControlFlags section for INFSTR_KEY_COPYFILESONLY
    //
    if (SetupFindFirstLine(hInf,
                           INFSTR_CONTROLFLAGS_SECTION,
                           INFSTR_KEY_COPYFILESONLY,
                           &InfContext
                           ))
    {
        HardwareId = DriverInfoDetailData->HardwareID;

        do {

            FieldCount = SetupGetFieldCount(&InfContext);
            Index = 0;

            while (Index++ < FieldCount) {

                if (SetupGetStringField(&InfContext,
                                        Index,
                                        InfDeviceID,
                                        SIZECHARS(InfDeviceID),
                                        NULL
                                        ))
                {
                   if (CompareInfIdToHardwareIds(HardwareId, InfDeviceID)) {
                   
                       HardwareWiz->CopyFilesOnly = TRUE;
                       goto AnalyzeExit;
                   }
               }
            }

        } while (SetupFindNextMatchLine(&InfContext,
                                        INFSTR_KEY_COPYFILESONLY,
                                        &InfContext)
                                        );
    }


    //
    // If there are factdef logconfigs install them as a forced config.
    // These are the factory default jumper settings for the hw.
    //
    if (SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData->SectionName,
                                         SectionName,
                                         SIZECHARS(SectionName),
                                         NULL,
                                         NULL
                                         ) &&
        SUCCEEDED(StringCchCat(SectionName, 
                               SIZECHARS(SectionName), 
                               TEXT(".") INFSTR_SUBKEY_FACTDEF)) &&
        (SetupFindFirstLine(hInf, SectionName, NULL, &InfContext))) {
        
        SetupInstallFromInfSection(hDlg,
                                   hInf,
                                   SectionName,
                                   SPINST_LOGCONFIG | SPINST_SINGLESECTION | SPINST_LOGCONFIG_IS_FORCED,
                                   NULL,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData
                                   );
    }



AnalyzeExit:

    if (DriverInfoDetailData) {
    
        LocalFree(DriverInfoDetailData);
    }


    if (hInf != INVALID_HANDLE_VALUE) {
    
        SetupCloseInfFile(hInf);
    }


    //
    // Register the phantom device in preparation for install.
    // Once this is registered we MUST remove it from the registry
    // if the device install is not completed.
    //
    if (SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                  HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData
                                  ))
    {
        LastError = ERROR_SUCCESS;

    } else {
    
        LastError = GetLastError();
    }


    HardwareWiz->Registered = LastError == ERROR_SUCCESS;

    return LastError;
}

DWORD
ProcessLogConfig(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{

    DWORD Len;
    HINF hInf = INVALID_HANDLE_VALUE;
    SP_DRVINFO_DATA  DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData = NULL;
    TCHAR SectionName[LINE_LEN*2];
    LONG LastError = ERROR_SUCCESS;

    //
    // Fetch the DriverInfoDetail, with enough space for lots of hardwareIDs.
    //

    Len = sizeof(SP_DRVINFO_DETAIL_DATA) + MAX_PATH*sizeof(TCHAR);
    DriverInfoDetailData = LocalAlloc(LPTR, Len);
    
    if (!DriverInfoDetailData) {

        goto AnalyzeExit;
    }
    
    DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        goto AnalyzeExit;
    }


    if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                    &HardwareWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    DriverInfoDetailData,
                                    Len,
                                    &Len
                                    ))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        
            LocalFree(DriverInfoDetailData);
            DriverInfoDetailData = LocalAlloc(LPTR, Len);

            if (!DriverInfoDetailData) {
            
                goto AnalyzeExit;
            }

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                            &HardwareWiz->DeviceInfoData,
                                            &DriverInfoData,
                                            DriverInfoDetailData,
                                            Len,
                                            NULL
                                            ))
            {
                goto AnalyzeExit;
            }

        } else {
        
            goto AnalyzeExit;
        }
    }


    //
    // Get a handle to the inf file.
    //


    hInf = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // If this is an old style inf file, then we can't write out
        // the logconfigs for classes which allow old style infs this is Ok,
        // If its an invalid or missing inf, it will fail further
        // down the chain of execution
        //

        goto AnalyzeExit;
    }

    //
    // Install any LogConfig entries in the install section.
    //
    if (SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData->SectionName,
                                         SectionName,
                                         SIZECHARS(SectionName),
                                         NULL,
                                         NULL
                                         ))
    {
        SetupInstallFromInfSection(hDlg,
                                   hInf,
                                   SectionName,
                                   SPINST_LOGCONFIG,
                                   NULL,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData
                                   );
    }



AnalyzeExit:

    if (DriverInfoDetailData) {
    
        LocalFree(DriverInfoDetailData);
    }


    if (hInf != INVALID_HANDLE_VALUE) {
    
        SetupCloseInfFile(hInf);
    }

    return LastError;
}

INT_PTR CALLBACK
HdwAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HICON hicon;
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    UNREFERENCED_PARAMETER(wParam);

    if (wMsg == WM_INITDIALOG) {
    
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        HardwareWiz->AnalyzeResult = 0;
        return TRUE;
    }



    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    InstallWizard = &HardwareWiz->InstallDynaWiz;

    switch (wMsg) {

    case WM_DESTROY:

        hicon = (HICON)SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0);
        if (hicon) {
            
            DestroyIcon(hicon);
        }
        break;

    case WUM_RESOURCEPICKER:
    {
        TCHAR Title[MAX_PATH], Message[MAX_PATH];

        LoadString(hHdwWiz, IDS_HDWWIZNAME, Title, SIZECHARS(Title));
        LoadString(hHdwWiz, IDS_NEED_FORCED_CONFIG, Message, SIZECHARS(Message));

        MessageBox(hDlg, Message, Title, MB_OK | MB_ICONEXCLAMATION);

        DisplayResource(HardwareWiz, GetParent(hDlg), TRUE);
    }
        break;
    
    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {

            int PrevPage;
            DWORD RegisterError = ERROR_SUCCESS;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_ADDDEVICE_ANALYZEDEV;

            if (PrevPage == IDD_WIZARDEXT_POSTANALYZE) {

                break;
            }

            //
            // Get info on currently selected device, since this could change
            // as the user move back and forth between wizard pages
            // we do this on each activate.
            //
            if (!SetupDiGetSelectedDevice(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData
                                          )) {

                RegisterError = GetLastError();

            } else {
                //
                // If wizard type is addnew, then we have a phantom devnode
                // and it needs to registered. All other wizard types, the
                // devnode is already registered.
                //
                RegisterError = RegisterDeviceNode(hDlg, HardwareWiz);
            }

            //
            // Set the class Icon
            //
            if (SetupDiLoadClassIcon(&HardwareWiz->DeviceInfoData.ClassGuid, &hicon, NULL)) {

                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {

                    DestroyIcon(hicon);
                }
            }

            SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);

            //
            // need to determine conflict warning.
            //
            if (RegisterError != ERROR_SUCCESS) {
            
                //
                // Show the bullet text items.
                //
                ShowWindow(GetDlgItem(hDlg, IDC_BULLET_1), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_INSTALL_TEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_BULLET_2), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_EXIT_TEXT), SW_SHOW);
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_ANALYZEERR1, IDS_HDW_ANALYZEERR1);

                //
                // Turn the 'i' character into a bullet.
                //
                SetWindowText(GetDlgItem(hDlg, IDC_BULLET_1), TEXT("i"));
                SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_1), HardwareWiz->hfontTextMarlett, TRUE);
                SetWindowText(GetDlgItem(hDlg, IDC_BULLET_2), TEXT("i"));
                SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_2), HardwareWiz->hfontTextMarlett, TRUE);

                if (RegisterError == ERROR_DUPLICATE_FOUND) {

                    SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_DUPLICATE1, IDS_HDW_DUPLICATE1);
                }

                //
                // Bold the error text.
                //
                SetWindowFont(GetDlgItem(hDlg, IDC_HDW_TEXT), HardwareWiz->hfontTextBold, TRUE);

            } else {

               SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_STDCFG, IDS_HDW_STDCFG);

               //
               // Hide the bullet text items.
               //
               ShowWindow(GetDlgItem(hDlg, IDC_BULLET_1), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_INSTALL_TEXT), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_BULLET_2), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_EXIT_TEXT), SW_HIDE);
            }

            if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

                if (RegisterError == ERROR_SUCCESS ||
                   !(InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT)) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_NEXTPAGE);
                }
            }

            //
            // If a device has recources and it does not have a forced config
            // and it is a manually installed device then pop up the resource
            // picker.  We need to do this because a legacy device must have 
            // a forced or boot config or else it won't get started.
            //
            if ((ERROR_SUCCESS == RegisterError) && 
                !HardwareWiz->CopyFilesOnly &&
                DeviceHasResources(HardwareWiz->DeviceInfoData.DevInst) &&
                !DeviceHasForcedConfig(HardwareWiz->DeviceInfoData.DevInst)) {

                //
                // Post ourselves a message to show the resource picker
                //
                PostMessage(hDlg, WUM_RESOURCEPICKER, 0, 0);
            }

            break;
        }


        case PSN_WIZBACK:
            //
            // Undo the registration
            //
            if (HardwareWiz->Registered) {

                HardwareWiz->Registered = FALSE;
            }

            if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {

                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     HardwareWiz->WizExtPostAnalyze.hPropSheet
                                     );

                HardwareWiz->WizExtPostAnalyze.hPropSheet = NULL;
            }

            SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PREANALYZE);
            break;

        case PSN_WIZNEXT:


            if (!HardwareWiz->Registered &&
                !SetupDiRegisterDeviceInfo(HardwareWiz->hDeviceInfo,
                                           &HardwareWiz->DeviceInfoData,
                                           0,
                                           NULL,
                                           NULL,
                                           NULL
                                           ))
            {
                InstallFailedWarning(hDlg, HardwareWiz);
                if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPostAnalyze.hPropSheet
                                         );
                    HardwareWiz->WizExtPostAnalyze.hPropSheet = NULL;
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PREANALYZE);
            }
            else  {

                //
                // Add the PostAnalyze Page and jump to it
                //

                HardwareWiz->WizExtPostAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE,
                                                                           WizExtPostAnalyzeDlgProc,
                                                                           HardwareWiz
                                                                           );

                if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPostAnalyze.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_POSTANALYZE);
            }

            break;
       }
       break;


       default:
           return(FALSE);
    
    }
    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE;

            if (PrevPageId == IDD_WIZARDEXT_SELECT) {
                //
                // Moving forward on first page
                //


                //
                // if we are not doing the old fashioned DYNAWIZ
                // Add ClassWizard Extension pages for preanalyze
                //

                if (!(HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
                {
                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPreAnalyze.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_PREANALYZE
                                        );
                }


                //
                // Add the end page, which is PreAnalyze end
                //

                HardwareWiz->WizExtPreAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE_END,
                                                                             WizExtPreAnalyzeEndDlgProc,
                                                                             HardwareWiz
                                                                             );

                if (HardwareWiz->WizExtPreAnalyze.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreAnalyze.hPropSheetEnd);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }
            else {
                //
                // Moving backwards from PreAnalyze end on PreAanalyze
                //

                //
                // Clean up proppages added.
                //

                if (HardwareWiz->WizExtPreAnalyze.hPropSheetEnd) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPreAnalyze.hPropSheetEnd
                                         );
                    HardwareWiz->WizExtPreAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &HardwareWiz->WizExtPreAnalyze.DeviceWizardData
                                       );




                //
                // Jump back
                // Note: The target pages don't set PrevPage, so set it for them
                //
                HardwareWiz->PrevPage = IDD_WIZARDEXT_SELECT;
                if (HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_PREVPAGE);
                }
                else {
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_SELECTDEV_PAGE);
                }
             }

            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE_END;

            if (PrevPageId == IDD_ADDDEVICE_ANALYZEDEV) {
                //
                // Moving backwards from analyzepage
                //

                //
                // Jump back
                //


                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);

            }
            else {
                //
                // Moving forward on end page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ANALYZEDEV);
            }


            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE;

            if (PrevPageId == IDD_ADDDEVICE_ANALYZEDEV) {
                //
                // Moving forward on first page
                //

                //
                // if we are not doing the old fashioned DYNAWIZ
                // Add ClassWizard Extension pages for postanalyze
                //

                if (!(HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
                {
                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPostAnalyze.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_POSTANALYZE
                                        );
                }


                //
                // Add the end page, which is PostAnalyze end
                //

                HardwareWiz->WizExtPostAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE_END,
                                                                             WizExtPostAnalyzeEndDlgProc,
                                                                              HardwareWiz
                                                                              );

                if (HardwareWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPostAnalyze.hPropSheetEnd);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }
            else  {
                //
                // Moving backwards from PostAnalyze end on PostAnalyze
                //

                //
                // Clean up proppages added.
                //

                if (HardwareWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPostAnalyze.hPropSheetEnd
                                         );
                    HardwareWiz->WizExtPostAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &HardwareWiz->WizExtPostAnalyze.DeviceWizardData
                                       );
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE_END;

            if (PrevPageId == IDD_ADDDEVICE_INSTALLDEV) {

                 //
                 // Moving backwards from finishpage
                 //

                 //
                 // Jump back
                 //

                 PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);

            }
            else  {
                //
                // Moving forward on End page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_INSTALLDEV);
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\devcfg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       devcfg.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <initguid.h>
#include <devguid.h>


//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

TCHAR szUnknownDevice[64];
TCHAR szUnknown[64];

PTCHAR
BuildFriendlyName(
    DEVINST DevInst
    )
{
    PTCHAR FriendlyName;
    ULONG ulSize;
    CONFIGRET ConfigRet;
    TCHAR szBuffer[MAX_PATH];

    //
    // Try the registry for FRIENDLYNAME
    //
    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_FRIENDLYNAME,
                                                 NULL,
                                                 szBuffer,
                                                 &ulSize,
                                                 0
                                                 );
    if (ConfigRet != CR_SUCCESS || !*szBuffer) {
        //
        // Try the registry for DEVICEDESC
        //
        ulSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                     CM_DRP_DEVICEDESC,
                                                     NULL,
                                                     szBuffer,
                                                     &ulSize,
                                                     0
                                                     );
        if (ConfigRet != CR_SUCCESS || !*szBuffer) {
            
            GUID ClassGuid;

            //
            // Initialize ClassGuid to GUID_NULL
            //
            CopyMemory(&ClassGuid,
                       &GUID_NULL,
                       sizeof(GUID)
                       );
            
            //
            // Try the registry for CLASSNAME
            //
            ulSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                         CM_DRP_CLASSGUID,
                                                         NULL,
                                                         szBuffer,
                                                         &ulSize,
                                                         0
                                                         );


            if (ConfigRet == CR_SUCCESS) {
                pSetupGuidFromString(szBuffer, &ClassGuid);
            }


            if (!IsEqualGUID(&ClassGuid, &GUID_NULL) &&
                !IsEqualGUID(&ClassGuid, &GUID_DEVCLASS_UNKNOWN))
            {
                ulSize = sizeof(szBuffer);
                ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                             CM_DRP_CLASS,
                                                             NULL,
                                                             szBuffer,
                                                             &ulSize,
                                                             0
                                                             );
            }
            else {
                ConfigRet = CR_FAILURE;
            }
        }
    }


    if (ConfigRet == CR_SUCCESS && *szBuffer) {
        FriendlyName = LocalAlloc(LPTR, ulSize);
        if (FriendlyName) {
            StringCchCopy(FriendlyName, ulSize/sizeof(TCHAR), szBuffer);
        }
    }
    else {
        FriendlyName = NULL;
    }


    return FriendlyName;
}

void
AddItemToListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    DEVINST DevInst,
    DWORD Problem,
    BOOL HiddenDevice,
    DEVINST SelectedDevInst
    )
{
    INT Index;
    LV_ITEM lviItem;
    PTCHAR FriendlyName;
    GUID ClassGuid;
    ULONG ulSize;
    CONFIGRET ConfigRet;
    TCHAR szBuffer[MAX_PATH];


    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iSubItem = 0;
    lviItem.lParam = DevInst;

    //
    // Devices with problems need to go at the top of the list
    //
    if (Problem) {
    
        lviItem.iItem = 0;

    } else {

        lviItem.iItem = ListView_GetItemCount(hwndListView);
    }
    
    //
    // fetch a name for this device
    //
    FriendlyName = BuildFriendlyName(DevInst);
    if (FriendlyName) {
    
        lviItem.pszText = FriendlyName;

    } else {
    
        lviItem.pszText = szUnknown;
    }

    //
    // Fetch the class icon for this device.
    //
    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_CLASSGUID,
                                                 NULL,
                                                 szBuffer,
                                                 &ulSize,
                                                 0
                                                 );


    if (ConfigRet == CR_SUCCESS) {
    
        pSetupGuidFromString(szBuffer, &ClassGuid);

    } else {
    
        ClassGuid = GUID_DEVCLASS_UNKNOWN;
    }

    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &ClassGuid,
                                  &lviItem.iImage
                                  ))
    {
        lviItem.mask |= (LVIF_IMAGE | LVIF_STATE);

        if (Problem) {
        
            lviItem.state = (Problem == CM_PROB_DISABLED) ?
                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :
                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else {

            lviItem.state = INDEXTOOVERLAYMASK(0);
        }

        lviItem.stateMask = LVIS_OVERLAYMASK;

        if (HiddenDevice) {

            lviItem.state |= LVIS_CUT;
            lviItem.stateMask |= LVIS_CUT;
        }
    }

    Index = ListView_InsertItem(hwndListView, &lviItem);

    if ((Index != -1) && (SelectedDevInst == DevInst)) {

        ListView_SetItemState(hwndListView,
                              Index,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }

    if (FriendlyName) {
    
        LocalFree(FriendlyName);
    }

    return;
}


BOOL
BuildDeviceListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    BOOL ShowHiddenDevices,
    DEVINST SelectedDevInst,
    DWORD *DevicesDetected,
    ADDDEVNODETOLIST_CALLBACK AddDevNodeToListCallBack
    )
{
    HDEVINFO hDeviceInfo;
    DWORD Index;
    ULONG DevNodeStatus, DevNodeProblem;
    SP_DEVINFO_DATA DevInfoData;
    BOOL HiddenDevice;

    *DevicesDetected = 0;

    hDeviceInfo = SetupDiGetClassDevsEx(NULL,   
                                        NULL,   
                                        NULL,   
                                        ShowHiddenDevices ? DIGCF_ALLCLASSES : DIGCF_ALLCLASSES | DIGCF_PRESENT,
                                        NULL,   
                                        NULL,
                                        0
                                        );
                                        
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {
    
        return FALSE;
    }

    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    Index = 0;
    while (SetupDiEnumDeviceInfo(hDeviceInfo, Index++, &DevInfoData)) {

        if (CM_Get_DevNode_Status(&DevNodeStatus,
                                  &DevNodeProblem,
                                  DevInfoData.DevInst,
                                  0
                                  ) != CR_SUCCESS) {
        
            DevNodeProblem = 0;
        }

        HiddenDevice = IsDeviceHidden(&DevInfoData);

        //
        // Only call AddItemToListView if the device is not a hidden device.
        //
        if (ShowHiddenDevices || !HiddenDevice) {
        
            //
            // Check the callback to see if we should add this devnode to the list.
            //
            if (!AddDevNodeToListCallBack || AddDevNodeToListCallBack(HardwareWiz, &DevInfoData)) {
                
                *DevicesDetected += 1;

                //
                // Add the item to the ListView
                //
                AddItemToListView(HardwareWiz,
                                  hwndListView,
                                  DevInfoData.DevInst,
                                  DevNodeProblem,
                                  HiddenDevice,
                                  SelectedDevInst);
            }
        }

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }
    
    SetupDiDestroyDeviceInfoList(hDeviceInfo);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\finish.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       finish.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <help.h>

typedef
BOOL
(*SRSETRESTOREPOINT)(
    PRESTOREPOINTINFO pRestorePtSpec,
    PSTATEMGRSTATUS pSMgrStatus
    );

BOOL
DeviceHasResources(
                  DEVINST DeviceInst
                  )
{
    CONFIGRET ConfigRet;
    ULONG lcType = NUM_LOG_CONF;

    while (lcType--) {
        
        ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, lcType, NULL);
        
        if (ConfigRet == CR_SUCCESS) {
            
            return TRUE;
        }
    }

    return FALSE;
}

DWORD
HdwRemoveDevice(
               PHARDWAREWIZ HardwareWiz
               )
{
    SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;
    LONG Error = ERROR_SUCCESS;

    RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    RemoveDeviceParams.HwProfile = 0;

    if (!SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                      sizeof(RemoveDeviceParams)
                                     )
        ||
        !SetupDiCallClassInstaller(DIF_REMOVE,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData
                                  )) {
        Error = GetLastError();
    }


    //
    // Clear the class install parameters.
    //
    SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 NULL,
                                 0
                                );

    return Error;
}

BOOL
GetClassGuidForInf(
    PTSTR InfFileName,
    LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if (!SetupDiGetINFClass(InfFileName,
                            ClassGuid,
                            ClassName,
                            SIZECHARS(ClassName),
                            NULL)) {
        return FALSE;
    }

    if (IsEqualGUID(ClassGuid, &GUID_NULL)) {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // of if it matches with multiple GUIDs, then we abort.
        //
        if (!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) ||
            !NumGuids) {
            
            return FALSE;
        }
    }

    return TRUE;
}

LONG
ClassInstallerInstalls(
                      HWND hwndParent,
                      PHARDWAREWIZ HardwareWiz,
                      HDEVINFO hDeviceInfo,
                      PSP_DEVINFO_DATA DeviceInfoData,
                      BOOL InstallFilesOnly
                      )
{
    DWORD Err = ERROR_SUCCESS;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    PVOID MessageHandlerContext = NULL;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD ScanResult = 0;
    RESTOREPOINTINFO RestorePointInfo;
    STATEMGRSTATUS SMgrStatus;
    int FileQueueNeedsReboot = 0;

    //
    // verify with class installer, and class-specific coinstallers
    // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
    // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
    //
    if (!SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   ) &&
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {

        Err = GetLastError();
        goto clean0;
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                       &HardwareWiz->DeviceInfoData,
                                       &DeviceInstallParams
                                       )) {

        Err = GetLastError();
        goto clean0;
    }

    FileQueue = SetupOpenFileQueue();

    if (FileQueue == INVALID_HANDLE_VALUE) {
       Err = ERROR_NOT_ENOUGH_MEMORY;
       goto clean0;
    }

    DeviceInstallParams.Flags |= DI_NOVCP;
    DeviceInstallParams.FileQueue = FileQueue;

    SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DeviceInstallParams
                                  );

    //
    // Set the SPQ_FLAG_ABORT_IF_UNSIGNED value on the file queue. With this
    // flag set setupapi will bail out of the copy if it encounters an unsigned
    // file. At that point we will set a system restore point and then 
    // do the copy. This way the user can back out of an unsigned driver
    // install using system restore.
    //
    // Note that system restore is currently not supported on 64-bit so don't 
    // bother setting the SPQ_FLAG_ABORT_IF_UNSIGNED.
    //
#ifndef _WIN64
    SetupSetFileQueueFlags(FileQueue,
                           SPQ_FLAG_ABORT_IF_UNSIGNED,
                           SPQ_FLAG_ABORT_IF_UNSIGNED
                           );
#endif

    //
    // Install the files first in one shot.
    // This allows new coinstallers to run during the install.
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // Since we created our own FileQueue then we need to
    // scan and possibly commit the queue and prune copies as needed.
    //
    if (!SetupScanFileQueue(FileQueue,
                            SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                            hwndParent,
                            NULL,
                            NULL,
                            &ScanResult
                            )) {

        //
        // If the API failed then set the ScanResult to 0 (failure).
        //
        ScanResult = 0;
    }

    //
    // If the ScanResult is 1 then that means that all of the files are present
    // and that there are no rename or delete operations are left in the copy
    // queue. This means we can skip the file queue commit.
    //
    // If the ScanResult is 0 then there are file copy operations that are needed.
    // If the ScanResult is 2 then there are delete, rename or backup operations
    // that are needed. 
    //
    if (ScanResult != 1) {
        MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                    hwndParent,
                                    (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                        ? INVALID_HANDLE_VALUE : NULL,
                                    0,
                                    0,
                                    NULL
                                    );

        if (MessageHandlerContext) {
            //
            // Commit the file queue.
            //
            if (!SetupCommitFileQueue(hwndParent,
                                      FileQueue,
                                      SetupDefaultQueueCallback,
                                      MessageHandlerContext
                                      )) {

                Err = GetLastError();

                if (Err == ERROR_SET_SYSTEM_RESTORE_POINT) {
                    SetupTermDefaultQueueCallback(MessageHandlerContext);

                    MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                hwndParent,
                                                (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                                    ? INVALID_HANDLE_VALUE : NULL,
                                                0,
                                                0,
                                                NULL
                                                );

                    if (MessageHandlerContext) {
                        HMODULE hSrClientDll = NULL;
                        SRSETRESTOREPOINT pfnSrSetRestorePoint = NULL;

                        if ((hSrClientDll = LoadLibrary(TEXT("srclient.dll"))) != NULL) {
                            
                            if ((pfnSrSetRestorePoint = (SRSETRESTOREPOINT)GetProcAddress(hSrClientDll,
                                                                                          "SRSetRestorePointW"
                                                                                          )) != NULL) {
                                //
                                // Set the system restore point.
                                //
                                RestorePointInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
                                RestorePointInfo.dwRestorePtType = DEVICE_DRIVER_INSTALL;
                                RestorePointInfo.llSequenceNumber = 0;
        
                                if (!LoadString(hHdwWiz,
                                                IDS_NEW_SETRESTOREPOINT,
                                                (LPWSTR)RestorePointInfo.szDescription,
                                                SIZECHARS(RestorePointInfo.szDescription)
                                                )) {
                                    RestorePointInfo.szDescription[0] = TEXT('\0');
                                }
        
                                pfnSrSetRestorePoint(&RestorePointInfo, &SMgrStatus);
                            }

                            FreeLibrary(hSrClientDll);
                        }

                        //
                        // Clear the SPQ_FLAG_ABORT_IF_UNSIGNED flag so the file
                        // queue will be commited the next time.
                        //
                        SetupSetFileQueueFlags(FileQueue,
                                               SPQ_FLAG_ABORT_IF_UNSIGNED,
                                               0
                                               );

                        //
                        // Now that we have set the restore point and cleared the
                        // SPQ_FLAG_ABORT_IF_UNSIGNED flag from the file queue we
                        // can commit the queue again.
                        //
                        if (!SetupCommitFileQueue(hwndParent,
                                                  FileQueue,
                                                  SetupDefaultQueueCallback,
                                                  MessageHandlerContext
                                                  )) {
                            Err = GetLastError();
                            goto clean0;
                        } else {
                            //
                            // We were successful in commiting the file queue, so check
                            // to see whether a reboot is required as a result of committing
                            // the queue (i.e. because files were in use, or the INF requested
                            // a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
                        }
                    }
                } else {
                    goto clean0;
                }
            } else {
                //
                // We were successful in commiting the file queue, so check
                // to see whether a reboot is required as a result of committing
                // the queue (i.e. because files were in use, or the INF requested
                // a reboot).
                //
                FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
            }
        }
    }

    //
    // If we were only copiny files then we are done!
    //
    if (InstallFilesOnly) {
        Err = ERROR_SUCCESS;
        goto clean0;
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(hDeviceInfo,
                                      DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {
        DWORD FileQueueFlags;
        
        //
        // If we didn't copy any files when commiting the file queue then the
        // SPQ_FLAG_FILES_MODIFIED flag will NOT be set.  In this case set
        // the DI_FLAGSEX_RESTART_DEVICE_ONLY flag so that we only stop/start
        // this single device.  By default setupapi will stop/start this device
        // as well as any other device that was using the same driver/filter 
        // that this device is using.
        //
        if (SetupGetFileQueueFlags(FileQueue, &FileQueueFlags) &&
            !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
            
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
        }

        //
        // Set the DI_NOFILECOPY flag since we already copied the files during
        // the DIF_INSTALLDEVICEFILES, so we don't need to copy them again during
        // the DIF_INSTALLDEVICE.
        //
        DeviceInstallParams.Flags |= DI_NOFILECOPY;
        SetupDiSetDeviceInstallParams(hDeviceInfo,
                                      DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }


    //
    // Register any device-specific co-installers for this device,
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // install any INF/class installer-specified interfaces.
    // and then finally the real "InstallDevice"!
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                  hDeviceInfo,
                                  DeviceInfoData
                                  )
        ||
        !SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    Err = ERROR_SUCCESS;

clean0:

    if (MessageHandlerContext) {
        SetupTermDefaultQueueCallback(MessageHandlerContext);
    }

    //
    // If the file queue said that a reboot was needed then set the 
    // DI_NEEDRESTART flag.
    //
    if (FileQueueNeedsReboot) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags |= DI_NEEDRESTART;

            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we have a valid file queue handle and there was an error during
        // the device install then we want to delete any new INFs that were
        // copied into the INF directory.  We do this under the assumption that
        // since there was an error during the install these INFs must be bad.
        //
        if (Err != ERROR_SUCCESS) {
            SetupUninstallNewlyCopiedInfs(FileQueue,
                                          0,
                                          NULL
                                          );
        }

        //
        // Clear out our file queue from the device install params. We need
        // to do this or else SetupCloseFileQueue will fail because it will
        // still have a ref count.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        SetupCloseFileQueue(FileQueue);
    }

    return Err;
}

//
// invokable only from finish page!
//
DWORD
InstallDev(
          HWND       hwndParent,
          PHARDWAREWIZ HardwareWiz
          )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];
    GUID ClassGuidInf;
    LPGUID ClassGuid;
    int   ClassGuidNum;
    DWORD Error = ERROR_SUCCESS;
    BOOL IgnoreRebootFlags = FALSE;
    TCHAR Buffer[MAX_PATH];
    ULONG DevNodeStatus = 0, Problem = 0;


    if (!HardwareWiz->ClassGuidSelected) {
        HardwareWiz->ClassGuidSelected = (LPGUID)&GUID_NULL;
    }


    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 &DriverInfoData
                                )) {
        //
        // Get details on this driver node, so that we can examine the INF that this
        // node came from.
        //
        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                        &HardwareWiz->DeviceInfoData,
                                        &DriverInfoData,
                                        &DriverInfoDetailData,
                                        sizeof(DriverInfoDetailData),
                                        NULL
                                       )) {
            Error = GetLastError();
            if (Error != ERROR_INSUFFICIENT_BUFFER) {
                goto clean0;
            }
        }


        //
        // Verif that the class is installed, if its not then
        // attempt to install it.
        //
        HdwBuildClassInfoList(HardwareWiz, 
                              0
                             );


        //
        // fetch classguid from inf, (It may be different than what we already
        // have in class guid selected).
        //
        if (!GetClassGuidForInf(DriverInfoDetailData.InfFileName, &ClassGuidInf)) {
            
            ClassGuidInf = *HardwareWiz->ClassGuidSelected;
        }

        if (IsEqualGUID(&ClassGuidInf, &GUID_NULL)) {

            ClassGuidInf = GUID_DEVCLASS_UNKNOWN;
        }

        //
        // if the ClassGuidInf wasn't found then this class hasn't been installed yet.
        // -install the class installer now.
        //
        ClassGuid = HardwareWiz->ClassGuidList;
        ClassGuidNum = HardwareWiz->ClassGuidNum;
        while (ClassGuidNum--) {
            if (IsEqualGUID(ClassGuid, &ClassGuidInf)) {
                break;
            }

            ClassGuid++;
        }

        if (ClassGuidNum < 0 &&
            !SetupDiInstallClass(hwndParent,
                                 DriverInfoDetailData.InfFileName,
                                 0,
                                 NULL
                                )) {
            Error = GetLastError();
            goto clean0;
        }


        //
        // Now make sure that the class of this device is the same as the class
        // of the selected driver node.
        //
        if (!IsEqualGUID(&ClassGuidInf, HardwareWiz->ClassGuidSelected)) {
            pSetupStringFromGuid(&ClassGuidInf,
                                 ClassGuidString,
                                 SIZECHARS(ClassGuidString)
                                );

            SetupDiSetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                            );
        }
    }

    //
    // No selected driver, and no associated class--use "Unknown" class.
    //
    else {

        //
        // If the devnode is currently running 'raw', then remember this
        // fact so that we don't require a reboot later (NULL driver installation
        // isn't going to change anything).
        //
        if (CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  HardwareWiz->DeviceInfoData.DevInst,
                                  0) == CR_SUCCESS) {
            if (!SetupDiGetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                                  &HardwareWiz->DeviceInfoData,
                                                  SPDRP_SERVICE,
                                                  NULL,     // regdatatype
                                                  (PVOID)Buffer,
                                                  sizeof(Buffer),
                                                  NULL
                                                 )) {
                *Buffer = TEXT('\0');
            }

            if ((DevNodeStatus & DN_STARTED) && (*Buffer == TEXT('\0'))) {
                IgnoreRebootFlags = TRUE;
            }
        }

        if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_NULL)) {

            pSetupStringFromGuid(&GUID_DEVCLASS_UNKNOWN,
                                 ClassGuidString,
                                 SIZECHARS(ClassGuidString)
                                );


            SetupDiSetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                            );
        }
    }


    //
    // since this is a legacy install, set the manually installed bit if the
    // driver that was selected was not a CopyFilesOnly (PnP) driver.
    //
    if (!HardwareWiz->CopyFilesOnly) {
        ULONG Len;
        CONFIGRET ConfigRet;
        ULONG ConfigFlag;

        Len = sizeof(ConfigFlag);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(HardwareWiz->DeviceInfoData.DevInst,
                                                        CM_DRP_CONFIGFLAGS,
                                                        NULL,
                                                        (PVOID)&ConfigFlag,
                                                        &Len,
                                                        0,
                                                        NULL
                                                       );
        if (ConfigRet != CR_SUCCESS) {
            ConfigFlag = 0;
        }

        ConfigFlag |= CONFIGFLAG_MANUAL_INSTALL;
        CM_Set_DevNode_Registry_Property_Ex(HardwareWiz->DeviceInfoData.DevInst,
                                            CM_DRP_CONFIGFLAGS,
                                            (PVOID)&ConfigFlag,
                                            sizeof(ConfigFlag),
                                            0,
                                            NULL
                                           );
    }

    Error = ClassInstallerInstalls(hwndParent,
                                   HardwareWiz,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData,
                                   HardwareWiz->CopyFilesOnly
                                  );

    if (Error != ERROR_SUCCESS) {
        //
        // we Have an install error, including a user cancel.
        // Install the null driver.
        //
        if (SetupDiSetSelectedDriver(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     NULL
                                    )) {

            if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                             )) {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
                SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                             );
            }

            SetupDiInstallDevice(HardwareWiz->hDeviceInfo, &HardwareWiz->DeviceInfoData);
        }

        goto clean0;
    }


    //
    // Fetch the latest DeviceInstallParams for the restart bits.
    //
    if (!IgnoreRebootFlags) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                         )) {
            if (DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
                HardwareWiz->Reboot |= DI_NEEDREBOOT;
            }
        }
    }


clean0:

    return Error;
}

BOOL
CALLBACK
AddPropSheetPageProc(
                    IN HPROPSHEETPAGE hpage,
                    IN LPARAM lParam
                    )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}

void
DisplayResource(
               PHARDWAREWIZ HardwareWiz,
               HWND hWndParent,
               BOOL NeedsForcedConfig 
               )
{
    HINSTANCE hLib;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsPages[1];
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES ExtensionPropSheetPage = NULL;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Now get the resource selection page from setupapi.dll
    //
    hLib = GetModuleHandle(TEXT("setupapi.dll"));
    if (hLib) {
        ExtensionPropSheetPage = (LPFNADDPROPSHEETPAGES)GetProcAddress(hLib, "ExtensionPropSheetPageProc");
    }

    if (!ExtensionPropSheetPage) {
        return;
    }

    PropPageRequest.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropPageRequest.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropPageRequest.DeviceInfoSet  = HardwareWiz->hDeviceInfo;
    PropPageRequest.DeviceInfoData = &HardwareWiz->DeviceInfoData;

    if (!ExtensionPropSheetPage(&PropPageRequest,
                                AddPropSheetPageProc,
                                (LONG_PTR)hpsPages
                               )) {
        // warning ?
        return;
    }

    //
    // create the property sheet
    //
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    psh.hwndParent  = hWndParent;
    psh.hInstance   = hHdwWiz;
    psh.pszIcon     = NULL;

    psh.pszCaption  = (LPTSTR)IDS_ADDNEWDEVICE;

    psh.nPages      = 1;
    psh.phpage      = hpsPages;
    psh.nStartPage  = 0;
    psh.pfnCallback = NULL;


    //
    // Clear the Propchange pending bit in the DeviceInstall params.
    //
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        DevInstallParams.FlagsEx &= ~DI_FLAGSEX_PROPCHANGE_PENDING;
        SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     );
    }

    //
    // Set the CONFIGFLAG_NEEDS_FORCED_CONFIG if this device needs a forced config.
    //
    if (NeedsForcedConfig) {

        DWORD ConfigFlags = 0;
        ULONG ulSize = sizeof(ConfigFlags);

        if (CM_Get_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL,
                                             (LPBYTE)&ConfigFlags,
                                             &ulSize,
                                             0) != CR_SUCCESS) {
            ConfigFlags = 0;
        }

        ConfigFlags |= CONFIGFLAG_NEEDS_FORCED_CONFIG;

        CM_Set_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         (LPBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         0
                                        );
    }

    if (PropertySheet(&psh) == -1) {
        DestroyPropertySheetPage(hpsPages[0]);
    }

    //
    // If a PropChange occurred invoke the DIF_PROPERTYCHANGE
    //
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        if (DevInstallParams.FlagsEx & DI_FLAGSEX_PROPCHANGE_PENDING) {
            SP_PROPCHANGE_PARAMS PropChangeParams;

            PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            PropChangeParams.Scope = DICS_FLAG_GLOBAL;
            PropChangeParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                             sizeof(PropChangeParams)
                                            )) {
                SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                          HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData
                                         );
            }

            //
            // Clear the class install parameters.
            //
            SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                         &HardwareWiz->DeviceInfoData,
                                         NULL,
                                         0
                                        );
        }
    }

    //
    // See if we need to reboot
    //
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        if (DevInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            HardwareWiz->Reboot |= DI_NEEDREBOOT;
        }
    }


    //
    // Clear the CONFIGFLAG_NEEDS_FORCED_CONFIG if this device needs a forced config.
    //
    if (NeedsForcedConfig) {

        DWORD ConfigFlags = 0;
        ULONG ulSize = sizeof(ConfigFlags);

        if (CM_Get_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL,
                                             (LPBYTE)&ConfigFlags,
                                             &ulSize,
                                             0) == CR_SUCCESS) {

            ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;

            CM_Set_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             (LPBYTE)&ConfigFlags,
                                             sizeof(ConfigFlags),
                                             0
                                            );
        }
    }

    return;
}

INT_PTR CALLBACK
HdwInstallDevDlgProc(
                    HWND hDlg,
                    UINT wMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            break;
        }

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0);
        if (hicon) {
            DestroyIcon(hicon);
        }
        break;

    case WUM_DOINSTALL:

        // do the Install
        HardwareWiz->LastError = InstallDev(hDlg, HardwareWiz);
        HardwareWiz->InstallPending = FALSE;
        HardwareWiz->CurrCursor = NULL;
        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
                HardwareWiz->PrevPage = IDD_ADDDEVICE_INSTALLDEV;

                //
                // This is an intermediary status page, no buttons needed.
                // Set the device description
                // Set the class Icon
                //
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);

                SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);

                if (SetupDiLoadClassIcon(HardwareWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                SetCursor(HardwareWiz->CurrCursor);

                //
                // Post ourselves a msg, to do the actual install, this allows this
                // page to show itself while the install is actually occuring.
                //
                HardwareWiz->InstallPending = TRUE;

                PostMessage(hDlg, WUM_DOINSTALL, 0, 0);

                break;
            }


        case PSN_WIZNEXT:

            //
            // Add the FinishInstall Page and jump to it if the installation succeded.
            //
            if (HardwareWiz->LastError == ERROR_SUCCESS) {

                HardwareWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                               WizExtFinishInstallDlgProc,
                                                                               HardwareWiz
                                                                              );

                if (HardwareWiz->WizExtFinishInstall.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtFinishInstall.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

                //
                // There was an error during the installation so just jump to our finish page.
                //
            } else {

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_FINISH);
            }
            break;
        }
        break;


    case WM_SETCURSOR:
        if (HardwareWiz->CurrCursor) {
            SetCursor(HardwareWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}



void
ShowInstallSummary(
                  HWND hDlg,
                  PHARDWAREWIZ HardwareWiz
                  )
{
    LONG Error;
    ULONG Problem, DevNodeStatus;
    BOOL HasResources;
    HWND hwndParentDlg = GetParent(hDlg);
    PTCHAR ErrorMsg, ProblemText;
    TCHAR TextBuffer[MAX_PATH*4];


    Problem = 0;
    *TextBuffer = TEXT('\0');

    Error = HardwareWiz->LastError;

    //
    // Installation was canceled
    //
    if (Error == ERROR_CANCELLED) {
        PropSheet_PressButton(hwndParentDlg, PSBTN_CANCEL);
        return;
    }

    //
    // Installation failed
    //
    if (Error != ERROR_SUCCESS) {
        
        HardwareWiz->Installed = FALSE;
        
        LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_HDW_ERRORFIN1, IDS_HDW_ERRORFIN1);

        //
        // Add on a description of the error to the end of the text buffer.
        // NOTE: if the description of the error does not fit in our huge text
        // buffer then it also won't fit in the dialog, however we should display
        // as much as we can to the user. The full error will be logged in 
        // setupapi.log so PSS can still figure out what happened.
        //
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          HRESULT_FROM_SETUPAPI(Error),
                          0,
                          (LPTSTR)&ErrorMsg,
                          0,
                          NULL)) {

            StringCchCat(TextBuffer, SIZECHARS(TextBuffer), TEXT("\n\n"));
            StringCchCat(TextBuffer, SIZECHARS(TextBuffer), ErrorMsg);
            LocalFree(ErrorMsg);
        }

        SetDlgItemText(hDlg, IDC_HDW_TEXT, TextBuffer);
    }

    //
    // No errors installing the drivers for this device
    //
    else {
        //
        // Check to see if the device itself has any problems
        //
        Error = CM_Get_DevNode_Status(&DevNodeStatus,
                                      &Problem,
                                      HardwareWiz->DeviceInfoData.DevInst,
                                      0
                                     );
        if (Error != CR_SUCCESS) {

            //
            // For some reason, we couldn't retrieve the devnode's status.
            // Default status and problem values to zero.
            //
            DevNodeStatus = Problem = 0;
        }

        //
        // make sure the reboot flags\Problem are set correctly
        //
        if (HardwareWiz->CopyFilesOnly || HardwareWiz->Reboot || Problem == CM_PROB_NEED_RESTART) {
            
            if (Problem != CM_PROB_PARTIAL_LOG_CONF) {
                Problem = CM_PROB_NEED_RESTART;
            }

            HardwareWiz->Reboot |= DI_NEEDREBOOT;
        }


        HardwareWiz->Installed = TRUE;
        HasResources = DeviceHasResources(HardwareWiz->DeviceInfoData.DevInst);

        //
        // The device has a problem
        //
        if ((Error != CR_SUCCESS) || Problem) {
            if (Problem == CM_PROB_NEED_RESTART) {
                if (HasResources &&
                    !HardwareWiz->CopyFilesOnly) {
                    LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_HDW_NORMAL_LEGACY_FINISH1, IDS_HDW_NORMAL_LEGACY_FINISH1);
                } else {
                    LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_HDW_NORMALFINISH1, IDS_HDW_NORMALFINISH1);
                }

                LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_NEEDREBOOT, IDS_NEEDREBOOT);
            }

            else {
                LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_INSTALL_PROBLEM, IDS_INSTALL_PROBLEM);

                //
                // If the device has a problem then get the problem text from
                // device manager. It the TextBuffer is too small then the
                // user will just see a truncated error message, so it is
                // OK if StringCchCat fails. 
                //
                if (Problem) {
                    ProblemText = DeviceProblemText(HardwareWiz->DeviceInfoData.DevInst,
                                                    0,
                                                    Problem
                                                   );

                    if (ProblemText) {
                        StringCchCat(TextBuffer, SIZECHARS(TextBuffer), TEXT("\n\n"));
                        StringCchCat(TextBuffer, SIZECHARS(TextBuffer), ProblemText);
                        LocalFree(ProblemText);
                    }
                }
            }

            //
            // Show the resource button if the device has resources and it has a problem
            //
            if (HasResources ||
                (Problem && !(HardwareWiz->Reboot && (DevNodeStatus & DN_STARTED))) ||
                (Problem == CM_PROB_PARTIAL_LOG_CONF)) {
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_DISPLAYRESOURCE), SW_SHOW);
            }
        }

        //
        // Installation was sucessful and the device does not have any problems
        //
        else {
            LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_HDW_NORMALFINISH1, IDS_HDW_NORMALFINISH1);
        }

        SetDlgItemText(hDlg, IDC_HDW_TEXT, TextBuffer);
    }
}

INT_PTR CALLBACK
HdwAddDeviceFinishDlgProc(
                         HWND hDlg,
                         UINT wMsg,
                         WPARAM wParam,
                         LPARAM lParam
                         )
{
    HICON hicon;
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: 
        {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);

            break;
        }

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0);
        if (hicon) {
            
            DestroyIcon(hicon);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            //
            // No back button since install is already done.
            // set the device description
            // Hide Resources button until we know if resources exist or not.
            // Set the class Icon
            //
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);

            ShowWindow(GetDlgItem(hDlg, IDC_HDW_DISPLAYRESOURCE), SW_HIDE);

            //
            // Set the class Icon
            //
            if (SetupDiLoadClassIcon(&HardwareWiz->DeviceInfoData.ClassGuid, &hicon, NULL)) {

                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {

                    DestroyIcon(hicon);
                }
            }

            ShowInstallSummary(hDlg, HardwareWiz);
            break;

        case PSN_RESET:
            //
            // Cancel the install
            //
            if (HardwareWiz->Registered) {
                HardwareWiz->Installed = FALSE;
            }
            break;

        case PSN_WIZFINISH:
            //
            // Pnp Device install only consists of copying files
            // when the system does the real install, it will create
            // the proper devnode, so remove our temporary devnode.
            //
            if (HardwareWiz->CopyFilesOnly && HardwareWiz->Registered) {
                HardwareWiz->Installed = FALSE;
                break;
            }
            break;

        case NM_RETURN:
        case NM_CLICK:
            DisplayResource(HardwareWiz, GetParent(hDlg), FALSE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
                          HWND hDlg, 
                          UINT wMsg, 
                          WPARAM wParam, 
                          LPARAM lParam
                          )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);


    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL;

            if (PrevPageId == IDD_ADDDEVICE_INSTALLDEV) {
                
                //
                // Moving forward on first page
                //

                //
                // Add ClassWizard Extension pages for FinishInstall
                //
                AddClassWizExtPages(hwndParentDlg,
                                    HardwareWiz,
                                    &HardwareWiz->WizExtFinishInstall.DeviceWizardData,
                                    DIF_NEWDEVICEWIZARD_FINISHINSTALL
                                   );

                //
                // Add the end page, which is FinishInstall end
                //
                HardwareWiz->WizExtFinishInstall.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL_END,
                                                                                  WizExtFinishInstallEndDlgProc,
                                                                                  HardwareWiz
                                                                                 );

                if (HardwareWiz->WizExtFinishInstall.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtFinishInstall.hPropSheetEnd);
                }
            }


            //
            // We can't go backwards, so always go forward
            //
            SetDlgMsgResult(hDlg, wMsg, -1);
            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
                             HWND hDlg, 
                             UINT wMsg, 
                             WPARAM wParam, 
                             LPARAM lParam
                             )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL_END;

            //
            // We can't go backwards, so always go forward
            //
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_FINISH);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\hdwwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       hdwwiz.h
//
//--------------------------------------------------------------------------

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cpl.h>
#include <prsht.h>
#include <commctrl.h>
#include <dlgs.h>  
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <spapip.h>
#include <regstr.h>
#include <srrestoreptapi.h>
#include <mountmgr.h>
#include <devguid.h>
#include <powrprof.h>
#include <shfusion.h>
#include <strsafe.h>
#include "resource.h"

#pragma warning( default : 4201 )

extern HMODULE hHdwWiz;
extern HMODULE hDevMgr;
extern HMODULE hNewDev;
extern int g_BlankIconIndex;

#define SIZECHARS(x) (sizeof((x))/sizeof(TCHAR))

//
// devmgr.dll exports
//
typedef
UINT
(*PDEVICEPROBLEMTEXT)(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    );

typedef
int
(*PDEVICEPROPERTIESEX)(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

typedef
int
(*PDEVICEPROBLEMWIZARD)(
    HWND hwndParent,
    PTCHAR MachineName,
    PTCHAR DeviceID
    );



//
// Search thread Functions
//
#define SEARCH_NULL     0
#define SEARCH_EXIT     1
#define SEARCH_DRIVERS  2
#define SEARCH_DELAY    3
#define SEARCH_DETECT   4
#define SEARCH_PNPENUM  5

#define WUM_DELAYTIMER      (WM_USER+280)
#define WUM_DOINSTALL       (WM_USER+281)
#define WUM_DETECT          (WM_USER+282)
#define WUM_PNPENUMERATE    (WM_USER+283)
#define WUM_RESOURCEPICKER  (WM_USER+284)


#define MAX_MESSAGE_STRING    512
#define MAX_MESSAGE_TITLE      50


typedef struct _SearchThreadData {
   HWND    hDlg;
   HANDLE  hThread;
   HANDLE  RequestEvent;
   HANDLE  ReadyEvent;
   HANDLE  CancelEvent;
   ULONG   Param;
   UCHAR   Function;
   BOOLEAN CancelRequest;
   LPTSTR  Path;
} SEARCHTHREAD, *PSEARCHTHREAD;

typedef struct _ClassDeviceInfo {
   HDEVINFO Missing;
   HDEVINFO Detected;
} CLASSDEVINFO, *PCLASSDEVINFO;

typedef struct _DeviceDetectionData {
   HWND    hDlg;
   LPGUID  ClassGuid;
   DWORD   ClassProgress;
   UCHAR   TotalProgress;
   BOOLEAN Reboot;
   BOOLEAN MissingOrNew;
   CLASSDEVINFO ClassDevInfo[1];
} DEVICEDETECTION, *PDEVICEDETECTION;

typedef struct _NewDeviceWizardExtension {
   HPROPSHEETPAGE hPropSheet;
   HPROPSHEETPAGE hPropSheetEnd;         // optional
   SP_NEWDEVICEWIZARD_DATA DeviceWizardData;
} WIZARDEXTENSION, *PWIZARDEXTENSION;

typedef struct _HardwareWizard {
    HDEVINFO                hDeviceInfo;
    HDEVINFO                PNPEnumDeviceInfo;

    INT                     PrevPage;
    INT                     EnterFrom;
    INT                     EnterInto;

    DWORD                   ClassGuidNum;
    DWORD                   ClassGuidSize;
    LPGUID                  ClassGuidList;
    LPGUID                  ClassGuidSelected;
    GUID                    lvClassGuidSelected;
    GUID                    SavedClassGuid;

    HCURSOR                 IdcWait;
    HCURSOR                 IdcAppStarting;
    HCURSOR                 IdcArrow;
    HCURSOR                 CurrCursor;

    HFONT                   hfontTextMarlett;
    HFONT                   hfontTextBold;
    HFONT                   hfontTextBigBold;

    INT                     cyText;

    PSEARCHTHREAD           SearchThread;
    PDEVICEDETECTION        DeviceDetection;           // used by detect code
    SP_DEVINFO_DATA         DeviceInfoData;
    DWORD                   AnalyzeResult;
    HWND                    hwndProbList;
    DEVINST                 DevInst;
    DEVINST                 ProblemDevInst;
    SP_INSTALLWIZARD_DATA   InstallDynaWiz;
    HPROPSHEETPAGE          SelectDevicePage;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

    BOOL                    Registered;
    BOOL                    Installed;
    BOOL                    InstallPending;
    BOOL                    Cancelled;
    BOOL                    CopyFilesOnly;
    BOOL                    FoundPnPDevices;
    BOOL                    ExitDetect;
    BOOL                    PromptForReboot;
    BOOL                    RunTroubleShooter;
    BOOL                    Shutdown;

    DWORD                   Reboot;
    DWORD                   LastError;

    WIZARDEXTENSION         WizExtPreSelect;
    WIZARDEXTENSION         WizExtSelect;
    WIZARDEXTENSION         WizExtUnplug;
    WIZARDEXTENSION         WizExtPreAnalyze;
    WIZARDEXTENSION         WizExtPostAnalyze;
    WIZARDEXTENSION         WizExtFinishInstall;

    TCHAR                   ClassName[MAX_CLASS_NAME_LEN];
    TCHAR                   ClassDescription[LINE_LEN];
    TCHAR                   DriverDescription[LINE_LEN];

} HARDWAREWIZ, *PHARDWAREWIZ;

#define NUMPROPPAGES 22

typedef struct _HardwareWizPropertySheet {
   PROPSHEETHEADER   PropSheetHeader;
   HPROPSHEETPAGE    PropSheetPages[NUMPROPPAGES];
} HDWPROPERTYSHEET, *PHDWPROPERTYSHEET;

#define TNULL ((TCHAR)0)

typedef BOOL
(CALLBACK* ADDDEVNODETOLIST_CALLBACK)(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    );


INT_PTR CALLBACK
HdwIntroDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwConnectedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwConnectedFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwProbListDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwProbListFinishDlgProc(
   HWND   hDlg,
   UINT   wMsg,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwClassListDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwDevicePropDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwPnpEnumDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwPnpFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAskDetectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectionDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectRebootDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwPickClassDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwSelectDeviceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwInstallDevDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAddDeviceFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
InstallNewDeviceDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
WizExtPreSelectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPreAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPreAnalyzeEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPostAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPostAnalyzeEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

PHDWPROPERTYSHEET
HdwWizard(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   int StartPageId
   );


//
// miscutil.c
//
VOID
HdwWizPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LONG
HdwBuildClassInfoList(
    PHARDWAREWIZ HardwareWiz,
    DWORD ClassListFlags
    );

int
HdwMessageBox(
    HWND hWnd,
    LPTSTR szIdText,
    LPTSTR szIdCaption,
    UINT Type
    );

LONG
HdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

BOOL
NoPrivilegeWarning(
   HWND hWnd
   );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
LoadText(
    PTCHAR szText,
    int SizeText,
    int nStartString,
    int nEndString
    );

void
InstallFailedWarning(
    HWND    hDlg,
    PHARDWAREWIZ HardwareWiz
    );

void
SetDlgText(
   HWND hDlg,
   int iControl,
   int nStartString,
   int nEndString
   );

void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PHARDWAREWIZ HardwareWiz
    );

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PHARDWAREWIZ HardwareWiz
   );

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PHARDWAREWIZ HardwareWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction
   );

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   );

BOOL
IsDeviceHidden(
    PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
ShutdownMachine(
    HWND hWnd
    );

int
DeviceProperties(
    HWND hWnd,
    DEVNODE DevNode,
    ULONG Flags
    );

//
// devcfg.c
//
typedef void
(*PFNDETECTPROBCALLBACK)(
   PHARDWAREWIZ HardwareWiz,
   DEVINST DevInst,
   ULONG Problem
   );

BOOL
BuildDeviceListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    BOOL ShowHiddenDevices,
    DEVINST SelectedDevInst,
    DWORD *DevicesDetected,
    ADDDEVNODETOLIST_CALLBACK AddDevNodeToListCallBack
    );

PTCHAR
BuildFriendlyName(
   DEVINST DevInst
   );


extern TCHAR szUnknown[64];
extern TCHAR szUnknownDevice[64];


//
// sthread.c
//
LONG
CreateSearchThread(
   PHARDWAREWIZ HardwareWiz
   );

void
DestroySearchThread(
   PSEARCHTHREAD SearchThread
   );

BOOL
SearchThreadRequest(
   PSEARCHTHREAD SearchThread,
   HWND    hDlg,
   UCHAR   Function,
   ULONG   Param
   );

void
CancelSearchRequest(
    PHARDWAREWIZ HardwareWiz
    );


//
// install.c
//
void
InstallSilentChildSiblings(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   DEVINST DeviceInstance,
   BOOL ReinstallAll
   );


//
// pnpenum.c
//
DWORD
PNPEnumerate(
    PHARDWAREWIZ HardwareWiz
    );


//
// detect.c
//
void
BuildDeviceDetection(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    );


//
// finish.c
//
DWORD
HdwRemoveDevice(
   PHARDWAREWIZ HardwareWiz
   );

BOOL
DeviceHasResources(
   DEVINST DeviceInst
   );

void
DisplayResource(
    PHARDWAREWIZ HardwareWiz,
    HWND hWndParent,
    BOOL NeedsForcedConfig
    );


//
// getdev.c
//
PTCHAR
DeviceProblemText(
   DEVNODE DevNode,
   ULONG Status,
   ULONG ProblemNumber
   );

BOOL
ProblemDeviceListFilter(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    );



//
// config mgr privates
//
DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );


#ifdef DBG

void
Trace(
    LPCTSTR format,
    ...
    );

#define TRACE( args )          Trace args

#else

#define TRACE( args )

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\hdwwiz.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       hdwwiz.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <htmlhelp.h>


BOOL
InitHdwIntroDlgProc(
   HWND hDlg,
   PHARDWAREWIZ HardwareWiz
   )
{
   HWND hwnd;
   HDC hDC;
   HFONT hfont;
   HICON hIcon;
   LOGFONT LogFont, LogFontOriginal;
   int FontSize, PtsPixels;

   //
   // Set the windows icons, so that we have the correct icon
   // in the alt-tab menu.
   //
   hwnd = GetParent(hDlg);
   hIcon = LoadIcon(hHdwWiz,MAKEINTRESOURCE(IDI_HDWWIZICON));
   
   if (hIcon) {
       SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
       SendMessage(hwnd, WM_SETICON, ICON_BIG,   (LPARAM)hIcon);
   }

   hIcon = LoadImage(hHdwWiz,
                     MAKEINTRESOURCE(IDI_WARN),
                     IMAGE_ICON,
                     GetSystemMetrics(SM_CXSMICON),
                     GetSystemMetrics(SM_CYSMICON),
                     0
                     );

   if (hIcon) {
       hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_SETICON, (WPARAM)hIcon, 0L);
   }

   if (hIcon) {
       DestroyIcon(hIcon);
   }

   hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_HDWNAME), WM_GETFONT, 0, 0);
   GetObject(hfont, sizeof(LogFont), &LogFont);
   LogFontOriginal = LogFont;

   HardwareWiz->cyText = LogFont.lfHeight;

   if (HardwareWiz->cyText < 0) {
       HardwareWiz->cyText = -HardwareWiz->cyText;
   }

   LogFont = LogFontOriginal;
   LogFont.lfWeight = FW_BOLD;
   HardwareWiz->hfontTextBold = CreateFontIndirect(&LogFont);

   LogFont = LogFontOriginal;
   LogFont.lfWeight = FW_BOLD;

   hDC = GetDC(hDlg);

   if (hDC) {
       //
       // Bump up font height.
       //
       PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
       FontSize = 12;
       LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
       HardwareWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
   }

   //
   // Create the Marlett font.  In the Marlett font the "i" is a bullet.
   //
   hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_BULLET_1), WM_GETFONT, 0, 0);
   GetObject(hfont, sizeof(LogFont), &LogFont);
   LogFont.lfCharSet = SYMBOL_CHARSET;
   LogFont.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
   StringCchCopy(LogFont.lfFaceName, SIZECHARS(LogFont.lfFaceName), TEXT("Marlett"));
   HardwareWiz->hfontTextMarlett = CreateFontIndirect(&LogFont);

   if (!HardwareWiz->hfontTextMarlett   ||
       !HardwareWiz->hfontTextBold   ||
       !HardwareWiz->hfontTextBigBold )
   {
       return FALSE;
   }

   SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
   SetWindowFont(GetDlgItem(hDlg, IDC_CD_TEXT), HardwareWiz->hfontTextBold, TRUE);

   //
   // An "i" in the marlett font is a small bullet.
   //
   SetWindowText(GetDlgItem(hDlg, IDC_BULLET_1), TEXT("i"));
   SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_1), HardwareWiz->hfontTextMarlett, TRUE);
   SetWindowText(GetDlgItem(hDlg, IDC_BULLET_2), TEXT("i"));
   SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_2), HardwareWiz->hfontTextMarlett, TRUE);

   return TRUE;
}

//
// Wizard intro dialog proc.
//
INT_PTR CALLBACK
HdwIntroDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )
/*++

Routine Description:


Arguments:

   standard stuff.



Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz;
    HICON hIcon;

    if (message == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ) lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        if (!InitHdwIntroDlgProc(hDlg, HardwareWiz)) {
            return FALSE;
        }

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {

    case WM_DESTROY:
        if (HardwareWiz->hfontTextMarlett) {
            DeleteObject(HardwareWiz->hfontTextMarlett);
            HardwareWiz->hfontTextMarlett = NULL;
        }

        if (HardwareWiz->hfontTextBold) {
            DeleteObject(HardwareWiz->hfontTextBold);
            HardwareWiz->hfontTextBold = NULL;
        }

        if (HardwareWiz->hfontTextBigBold) {
            DeleteObject(HardwareWiz->hfontTextBigBold);
            HardwareWiz->hfontTextBigBold = NULL;
        }

        hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_GETICON, 0, 0);
        if (hIcon) {
            DestroyIcon(hIcon);
        }
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {
        NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

        switch (pnmhdr->code) {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            HardwareWiz->PrevPage = IDD_ADDDEVICE_WELCOME;
            break;

        case PSN_WIZNEXT:
            HardwareWiz->EnterFrom = IDD_ADDDEVICE_WELCOME;
            break;
        }
    }
    break;

    case WM_SYSCOLORCHANGE:
        HdwWizPropagateMessage(hDlg, message, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

HMODULE hHdwWiz;
int g_BlankIconIndex;

INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{
    UNREFERENCED_PARAMETER(hwndDlg);

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){
        
            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}

PHDWPROPERTYSHEET
HdwWizard(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz,
    int StartPageId
    )
{
    PHDWPROPERTYSHEET HdwPropertySheet;
    LPPROPSHEETHEADER PropSheetHeader;
    PROPSHEETPAGE psp;
    int Index;

    //
    // Allocate memory for the header and the page array.
    //
    HdwPropertySheet = LocalAlloc(LPTR, sizeof(HDWPROPERTYSHEET));
    if (!HdwPropertySheet) {
    
        return NULL;
    }

    memset(HdwPropertySheet, 0, sizeof(*HdwPropertySheet));

    if (ERROR_SUCCESS != HdwBuildClassInfoList(HardwareWiz, 
                                               DIBCI_NOINSTALLCLASS
                                               )) {

        return NULL;
    }

    //
    // Initialize the PropertySheet Header
    //
    PropSheetHeader = &HdwPropertySheet->PropSheetHeader;
    PropSheetHeader->dwSize = sizeof(HdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;

    PropSheetHeader->hwndParent = hwndParent;
    PropSheetHeader->hInstance = hHdwWiz;
    PropSheetHeader->pszCaption = MAKEINTRESOURCE(IDS_HDWWIZNAME);
    PropSheetHeader->phpage = HdwPropertySheet->PropSheetPages;
    PropSheetHeader->pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
    PropSheetHeader->pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
    PropSheetHeader->pfnCallback = iHdwWizardDlgCallback;

    PropSheetHeader->nStartPage = 0;
    PropSheetHeader->nPages = 0;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.hInstance = hHdwWiz;
    psp.lParam = (LPARAM)HardwareWiz;
    psp.pszTitle = MAKEINTRESOURCE(IDS_HDWWIZNAME);


    //
    // If the StartPageId is IDD_INSTALLNEWDEVICE then we don't need to create the detection
    // and removal pages.
    //
    if (IDD_INSTALLNEWDEVICE == StartPageId) {
        
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_INSTALLNEWDEVICE);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_INSTALLNEWDEVICE);
        psp.pfnDlgProc = InstallNewDeviceDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    else {
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_WELCOME);
        psp.pfnDlgProc = HdwIntroDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        //
        // Add Hardware wizard pages
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_PNPENUM);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PNPENUM);
        psp.pfnDlgProc = HdwPnpEnumDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PNPFINISH);
        psp.pfnDlgProc = HdwPnpFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_CONNECTED);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_CONNECTED);
        psp.pfnDlgProc = HdwConnectedDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_CONNECTED_FINISH);
        psp.pfnDlgProc = HdwConnectedFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_PROBLIST);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PROBLIST);
        psp.pfnDlgProc = HdwProbListDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PROBLIST_FINISH);
        psp.pfnDlgProc = HdwProbListFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_ASKDETECT);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_ASKDETECT);
        psp.pfnDlgProc = HdwAskDetectDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_DETECTION);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTION);
        psp.pfnDlgProc = HdwDetectionDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_DETECTINSTALL);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTINSTALL);
        psp.pfnDlgProc = HdwDetectInstallDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTREBOOT);
        psp.pfnDlgProc = HdwDetectRebootDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    //
    // These pages are always shown
    //
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_SELECTCLASS);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_SELECTCLASS);
    psp.pfnDlgProc = HdwPickClassDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.d