///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// MMC Detection Code
//
//Sets the MMCDETECTED property to True if MMC is found to be running on the machine
extern "C" ADMINPAK_API int __stdcall  fnDetectMMC(MSIHANDLE hInstall)
{
	HWND lpWindowReturned = NULL;
	lpWindowReturned = FindWindowEx(NULL, NULL, "MMCMainFrame",NULL);
	if (lpWindowReturned != NULL)
		MsiSetProperty(hInstall, TEXT("MMCDETECTED"), "Yes"); //set property in MSI
	else
		MsiSetProperty(hInstall, TEXT("MMCDETECTED"), "No"); //set property in MSI
	
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Admin Tools start menu folder Code
//

//Sets the AdminTools start menu folder to On
extern "C" ADMINPAK_API int __stdcall  fnAdminToolsFolderOn(MSIHANDLE hInstall)
{
    DWORD dwError = NO_ERROR;
	HKEY hKey;
	LPCTSTR key = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced";
	LPCTSTR value = "Not set";
	DWORD data = 0;
		
	UNREFERENCED_PARAMETER( hInstall );

	//Open key to write to in the registry
	dwError = RegOpenKeyEx(HKEY_CURRENT_USER,key, 0, KEY_WRITE, &hKey );
	if ( dwError != ERROR_SUCCESS ) 
			return ERROR_INVALID_HANDLE;
	
	//Turn on the admin tools folder via their reg keys
	data = 2;
	value = "Start_AdminToolsRoot";
	dwError = RegSetValueEx(hKey, value, 0, REG_DWORD, (CONST BYTE *)&data, sizeof(data));
	if ( dwError != ERROR_SUCCESS ) 
    {
    	RegCloseKey(hKey);
		return ERROR_INVALID_HANDLE;
    }

	data = 1;
	value = "StartMenuAdminTools";
	dwError = RegSetValueEx(hKey, value, 0, REG_DWORD, (CONST BYTE *)&data, sizeof(data));
	if ( dwError != ERROR_SUCCESS ) 
    {
    	RegCloseKey(hKey);
		return ERROR_INVALID_HANDLE;
	}

	//Close key and exit
	RegCloseKey(hKey);
	return ERROR_SUCCESS;
}

//Sets the AdminTools start menu folder to Off
extern "C" ADMINPAK_API int __stdcall  fnAdminToolsFolderOff(MSIHANDLE hInstall)
{
    DWORD dwError = NO_ERROR;
	HKEY hKey;
	const TCHAR key[] = TEXT( "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced" );
	const TCHAR valueRoot[] = TEXT( "Start_AdminToolsRoot" );
	const TCHAR valueMenu[] = TEXT( "StartMenuAdminTools" );
	TCHAR lparam[] = TEXT( "Policy" );
	DWORD data = 0;
	DWORD_PTR dwResult = 0; //unused
		
	UNREFERENCED_PARAMETER( hInstall );

	//Open key to write to in the registry
	dwError = RegOpenKeyEx(HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey );
	if ( dwError != ERROR_SUCCESS ) 
			return ERROR_INVALID_HANDLE;

	//Turn off the admin tools folder via their reg keys
	// value = "Start_AdminToolsRoot";
	data = 0;
	dwError = RegSetValueEx(hKey, valueRoot, 0, REG_DWORD, (CONST BYTE *)&data, sizeof(data));
	if ( dwError != ERROR_SUCCESS ) 
    {
    	RegCloseKey(hKey);
		return ERROR_INVALID_HANDLE;
    }

	// value = "StartMenuAdminTools";
	data = 0;
	dwError = RegSetValueEx(hKey, valueMenu, 0, REG_DWORD, (CONST BYTE *)&data, sizeof(data));
	if ( dwError != ERROR_SUCCESS ) 
    {
    	RegCloseKey(hKey);
		return ERROR_INVALID_HANDLE;
    }

	//Close key and exit
	RegCloseKey(hKey);

	//Undocumented API call to force a redraw of the start menu to remove the admin tools folder without logging off or having the user have to manually "apply" the changes to the start menu
	SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM) lparam , SMTO_ABORTIFHUNG, 1000, &dwResult  );
	
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
//AdminpakBackup table handling Code
//
//Backup files from the AdminpakBackup table
extern "C" ADMINPAK_API int __stdcall  fnBackupAdminpakBackupTable(MSIHANDLE hInstall)
{
	DWORD dwLength = MAX_PATH;			//Length of string to return from MSI
	DWORD dwError = NO_ERROR;			//Error variable
	
	TCHAR szDir[MAX_PATH];				//Directory read from the MSI
	TCHAR szDirFromMSI[MAX_PATH];		//Directory read from Adminbackup table
	TCHAR szFileToBackup[MAX_PATH];		//File name to backup
	TCHAR szBackupFileName[MAX_PATH];	//Backed up file name
	TCHAR szFileToBackupFromMSI[MAX_PATH];	//File name to backup from MSI
	TCHAR szBackupFileNameFromMSI[MAX_PATH];	//Backed up file name
	
	HRESULT res;

	PMSIHANDLE hView;					//MSI view handle
	PMSIHANDLE hRecord;					//MSI record handle
	PMSIHANDLE hDatabase;				//MSI database handle
	
	TCHAR szSQL[MAX_PATH];					//SQL to return table from MSI
	res = StringCchCopy(szSQL, dwLength,TEXT("SELECT * FROM `AdminpackBackup`"));
		
	// Get a handle on the MSI database 
	hDatabase = MsiGetActiveDatabase(hInstall); 
	if( hDatabase == 0 ) 
		return ERROR_INVALID_HANDLE; 

	//Get a view of our table in the MSI
	dwError = MsiDatabaseOpenView(hDatabase, szSQL, &hView ); 
	if( dwError == ERROR_SUCCESS ) 
		dwError = MsiViewExecute(hView, NULL ); 

	// If no errors, get our records
	if( dwError != ERROR_SUCCESS )
	{ 
		return ERROR_INVALID_HANDLE; 
	}
	else
	{
		//Loop through records in the AdminpakBackup table
		while(MsiViewFetch(hView, &hRecord ) == ERROR_SUCCESS )
		{
			dwError = MsiRecordGetString(hRecord, BACKUPFILENAME, szBackupFileNameFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiRecordGetString(hRecord, ORIGINALFILENAME, szFileToBackupFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiRecordGetString(hRecord, BACKUPDIRECTORY, szDirFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
					return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiGetProperty( hInstall, TEXT(szDirFromMSI), szDir, &dwLength );
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			
			//Build up the paths for the file to backup
			res = StringCchCopy(szFileToBackup, dwLength ,szDir);
			res = StringCchCat(szFileToBackup, dwLength, szFileToBackupFromMSI);
			res = StringCchCopy(szBackupFileName, dwLength, szDir);
			res = StringCchCat(szBackupFileName, dwLength, szBackupFileNameFromMSI);

			//Perform backup
			//We know MoveFileEx is inseucure due to ACL's, but we are moving to same directory and planing on moving file back on uninstall, so we should be OK as far as ACL's are concearned
			if (res == S_OK)
			{
				dwError = MoveFileEx(szFileToBackup,szBackupFileName, MOVEFILE_WRITE_THROUGH);
			}
			
			if( dwError == 0 )
			{
				if ( GetLastError() == ERROR_FILE_NOT_FOUND )
				{
					// ignore this error
				}
				else
				{
					// even in this case, we will ignore this error
					// this is because, anyhow, the failure of this action 
					// will not stop from MSI installing the package -- 
					// so, practically, there is no meaning in stoping this action in middle
					//
					// return ERROR_INVALID_HANDLE; 
					//
				}
			}

			dwError = MsiCloseHandle(hRecord);	//Close record
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
		}
	}

	dwError = MsiViewClose( hView );		//Close view
	if( dwError != ERROR_SUCCESS )
		return ERROR_INVALID_HANDLE; 

	dwError = MsiCloseHandle( hDatabase );	//Close Database
	if( dwError != ERROR_SUCCESS )
		return ERROR_INVALID_HANDLE; 
	
	
	return ERROR_SUCCESS;
}


//Restores files specified in the AdminpakBackup table, called during uninstall...
extern "C" ADMINPAK_API int __stdcall  fnRestoreAdminpakBackupTable(MSIHANDLE hInstall)
{
	DWORD dwLength = MAX_PATH;			//Length of string to return from MSI
	DWORD dwError = ERROR_SUCCESS;		//Error variable
	HRESULT res;
	TCHAR szDir[MAX_PATH];				//Directory read from the MSI
	TCHAR szDirFromMSI[MAX_PATH];		//Directory read from Adminbackup table
	TCHAR szFileToRestore[MAX_PATH];	//File name to restore
	TCHAR szBackupFileName[MAX_PATH];	//Backed up file name
	TCHAR szFileToRestoreFromMSI[MAX_PATH];	//File name to restore
	TCHAR szBackupFileNameFromMSI[MAX_PATH];	//Backed up file name
	
	TCHAR szSQL[MAX_PATH];					//SQL to return table from MSI
	res = StringCchCopy(szSQL, dwLength, TEXT("SELECT * FROM `AdminpackBackup`"));
	
	PMSIHANDLE hView;					//MSI view handle
	PMSIHANDLE hRecord;					//MSI record handle
	PMSIHANDLE hDatabase;				//MSI database handle
	
		
	// Get a handle on the MSI database 
	hDatabase = MsiGetActiveDatabase(hInstall); 
	if( hDatabase == 0 ) 
		return ERROR_INVALID_HANDLE; 

	//Get a view of our table in the MSI
	dwError = MsiDatabaseOpenView(hDatabase, szSQL, &hView ); 
	if( dwError == ERROR_SUCCESS ) 
		dwError = MsiViewExecute(hView, NULL ); 

	// If no errors, get our records
	if( dwError != ERROR_SUCCESS )
	{ 
		return ERROR_INVALID_HANDLE; 
	}
	else
	{
		//Loop through records in the AdminpakBackup table
		while(MsiViewFetch(hView, &hRecord ) == ERROR_SUCCESS )
		{
			dwError = MsiRecordGetString(hRecord, ORIGINALFILENAME, szBackupFileNameFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiRecordGetString(hRecord, BACKUPFILENAME, szFileToRestoreFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiRecordGetString(hRecord, BACKUPDIRECTORY, szDirFromMSI , &dwLength);
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			dwError = MsiGetProperty( hInstall, TEXT(szDirFromMSI), szDir, &dwLength );
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
			dwLength = MAX_PATH;
			
			//Build up the paths for the file to restore
			res = StringCchCopy(szFileToRestore, dwLength, szDir);
			res = StringCchCat(szFileToRestore, dwLength, szBackupFileNameFromMSI);
			res = StringCchCopy(szBackupFileName, dwLength, szDir);
			res = StringCchCat(szBackupFileName, dwLength, szFileToRestoreFromMSI);
			//Perform restore
			dwError = MoveFileEx(szBackupFileName, szFileToRestore, MOVEFILE_REPLACE_EXISTING);	//Restore the file
			if( dwError == 0 )
			{
				if ( GetLastError() == ERROR_FILE_NOT_FOUND )
				{
					// ignore this error
				}
				else
				{
					// even in this case, we will ignore this error
					// this is because, anyhow, the failure of this action 
					// will not stop from MSI installing the package -- 
					// so, practically, there is no meaning in stoping this action in middle
					//
					// return ERROR_INVALID_HANDLE; 
					//
				}
			}

			dwError = MsiCloseHandle(hRecord);	//Close Record
			if( dwError != ERROR_SUCCESS )
				return ERROR_INVALID_HANDLE; 
		}
	}

	dwError = MsiViewClose(hView);			//Close View
	if( dwError != ERROR_SUCCESS )
		return ERROR_INVALID_HANDLE; 
	dwError = MsiCloseHandle(hDatabase);	//Close Database
	if( dwError != ERROR_SUCCESS )
		return ERROR_INVALID_HANDLE; 
	
	return ERROR_SUCCESS;
}

// check whether the OEM code page and SYSTEM code are same or not
extern "C" ADMINPAK_API int __stdcall  fnNativeOSLanguage( MSIHANDLE hInstall )
{
	// local variables
	HRESULT hr = S_OK;
	LANGID langOEM = 0;
	WCHAR wszLanguageCode[ 10 ] = L"\0";

	// get the OEM code page
	langOEM = GetSystemDefaultUILanguage();

	// convert the numeric value into string format
	hr = StringCchPrintfW( wszLanguageCode, 10, L"%d", langOEM );
	if ( FAILED( hr ) )
	{
		return ERROR_INVALID_HANDLE;
	}

	// save the native OS language information
	MsiSetPropertyW( hInstall, L"NativeOSLanguage", wszLanguageCode );

	// return success
	return ERROR_SUCCESS;
}


void fnDeleteShortcut(MSIHANDLE, TCHAR[_MAX_PATH]);

//Cleans up after a Win2k adminpak upgrade as Win2k adminpak leaves behind several shortcuts that we need to clean up after
extern "C" ADMINPAK_API int __stdcall  fnCleanW2KUpgrade( MSIHANDLE hInstall )
{

	//Call fnDeleteShortcut with the name of the shortcut you want to delete
	fnDeleteShortcut(hInstall, "Internet Services Manager");
	fnDeleteShortcut(hInstall, "Routing and Remote Access");
	fnDeleteShortcut(hInstall, "Distributed File System");
	fnDeleteShortcut(hInstall, "Local Security Policy");

	// return success
	return ERROR_SUCCESS;
}

//Actually does the shortcut deletion
void fnDeleteShortcut(MSIHANDLE hInstall,  TCHAR LinkName[])
{
    HRESULT hr = S_OK;
	TCHAR	buf[_MAX_PATH];				//shortcut path/name buffer
	DWORD dwLength = _MAX_PATH;			//Length of string to return from MSI	
	LPITEMIDLIST	pidl;				//used to get admin tools shortcut path

	UNREFERENCED_PARAMETER( hInstall );
	
   //get admin tools shortcut folder
	hr = SHGetSpecialFolderLocation( NULL, CSIDL_COMMON_ADMINTOOLS, &pidl );
	SHGetPathFromIDList(pidl, buf);
	
	//append shortcut name and extention
	hr = StringCchCat( buf, dwLength, "\\" );
	hr = StringCchCat( buf, dwLength, LinkName );
    hr = StringCchCat( buf, dwLength, ".lnk");
   
   //delete the shortcut and return
	DeleteFile( buf );
}

BOOL TranslateVersionString( LPCWSTR pwszVersion, PTVERSION pVersion )
{
    // local variables
    DWORD dwLoop = 0;
    LONG lPosition = 0;
    CHString strTemp;
    CHString strVersion;
    CHString strVersionField;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszNumber = NULL;
    DWORD dwNumbers[ 4 ];

    // check the input parameters
    if ( pVersion == NULL || pwszVersion == NULL )
    {
        return FALSE;
    }

    // init the version struct to zero's
    ZeroMemory( pVersion, sizeof( TVERSION ) );
    ZeroMemory( dwNumbers, 4 * sizeof( DWORD ) );

    try
    {
        // get the version info into the class variable
        strVersion = pwszVersion;

        // trim the string
        strVersion.TrimLeft();
        strVersion.TrimRight();

        // cut the string till the first space we encountered in it
        lPosition = strVersion.Find( L' ' );
        if ( lPosition != -1 )
        {
            strTemp = strVersion.Mid( 0, lPosition );
            strVersion = strTemp;
        }

        // we need to get 4 parts from the version string
        for ( dwLoop = 0; dwLoop < 4; dwLoop++ )
        {
            lPosition = strVersion.Find( L'.' );
            if ( lPosition == -1 )
            {
                // this might be the last number
                if ( strVersion.GetLength() == 0 )
                {
                    break;
                }
                else
                {
                    strVersionField = strVersion;
                    strVersion.Empty();
                }
            }
            else
            {
                strVersionField = strVersion.Mid( 0, lPosition );
                strTemp = strVersion.Mid( lPosition + 1 );
                strVersion = strTemp;
            }

            // get the version field internal buffer
            // NOTE: assuming no. of digits in a version string is never going to larger than 10 digits
            pwszNumber = strVersionField.GetBuffer( 10 );
            if ( pwszNumber == NULL )
            {
                return FALSE;
            }

            // convert the number
            dwNumbers[ dwLoop ] = wcstoul( pwszNumber, &pwszTemp, 10 );

            //
            // check the validity of the number
            // 
            if ( errno == ERANGE || (pwszTemp != NULL && lstrlenW( pwszTemp ) != 0 ))
            {
                strVersionField.ReleaseBuffer( -1 );
                return FALSE;
            }

            // release the buffer
            strVersionField.ReleaseBuffer( -1 );
        }

        // check the no. of loops that are done -- it the loops are not equal to 3, error
        // we dont care whether we got the sub-revision or not -- so, we are not checking for 4 here
        if ( dwLoop < 3 || strVersion.GetLength() != 0 )
        {
            return FALSE;
        }

        // everything went well
        pVersion->dwMajor = dwNumbers[ 0 ];
        pVersion->dwMinor = dwNumbers[ 1 ];
        pVersion->dwRevision = dwNumbers[ 2 ];
        pVersion->dwSubRevision = dwNumbers[ 3 ];

        // return
        return TRUE;
    }
    catch( ... )
    {
        return FALSE;
    }
}


LONG CheckFileVersion( LPCWSTR pwszFileName, 
					   LPCWSTR pwszRequiredInternalName,
					   LPCWSTR pwszRequiredFileVersion )
{
    // local variables
    DWORD dw = 0;
    UINT dwSize = 0;
    UINT dwTranslateSize = 0;
    LPVOID pVersionInfo = NULL;
    PTTRANSLATE pTranslate = NULL;
	LPCWSTR pwszFileVersion = NULL;
	LPCWSTR pwszInternalName = NULL;
    TVERSION verFileVersion;
    TVERSION verRequiredFileVersion;

	// check the input
	// NOTE: we dont care whether "pwszRequiredInternalName" is passed or not
	if ( pwszFileName == NULL || pwszRequiredFileVersion == NULL )
	{
		return translateError;
	}

    // translate the required file version string into TVERSION struct
    if ( TranslateVersionString( pwszRequiredFileVersion, &verRequiredFileVersion ) == FALSE )
    {
        // version string passed is invalid
        return translateError;
    }

    // init
    dw = 0;
    dwSize = _MAX_PATH;

	// get the version information size
    dwSize = GetFileVersionInfoSizeW( pwszFileName, 0 );
    if ( dwSize == 0 )
    {
        // tool might have encountered error (or)
        // tool doesn't have version information
        // but version information is mandatory for us
        // so, just exit
        if ( GetLastError() == NO_ERROR )
        {
			SetLastError( ERROR_INVALID_PARAMETER );
            return translateError;
        }

        // ...
        return translateError;
    }

    // allocate memory for the version resource
    // take some 10 bytes extra -- for safety purposes
    dwSize += 10;
    pVersionInfo = new BYTE[ dwSize ];
    if ( pVersionInfo == NULL )
    {
        return translateError;
    }

    // now get the version information
    if ( GetFileVersionInfoW( pwszFileName, 0, dwSize, pVersionInfo ) == FALSE )
    {
        delete [] pVersionInfo;
        return translateError;
    }

    // get the translation info
    if ( VerQueryValueW( pVersionInfo, 
                        L"\\VarFileInfo\\Translation",
                        (LPVOID*) &pTranslate, &dwTranslateSize ) == FALSE )
    {
        delete [] pVersionInfo;
        return translateError;
    }

    // try to get the internal name of the tool for each language and code page.
	pwszFileVersion = NULL;
    pwszInternalName = NULL;
    for( dw = 0; dw < ( dwTranslateSize / sizeof( TTRANSLATE ) ); dw++ )
    {
		try
		{
			//
			// prepare the format string to get the localized the version info
			//
			CHString strBuffer;
			LPWSTR pwszBuffer = NULL;

			//
			// file version
			strBuffer.Format( 
				L"\\StringFileInfo\\%04x%04x\\FileVersion",
				pTranslate[ dw ].wLanguage, pTranslate[ dw ].wCodePage );

			// retrieve file description for language and code page "i". 
			pwszBuffer = strBuffer.LockBuffer();
	        if ( VerQueryValueW( pVersionInfo, pwszBuffer,
		                        (LPVOID*) &pwszFileVersion, &dwSize ) == FALSE )
	        {
		        // we cannot decide the failure based on the result of this
				// function failure -- we will decide about this
				// after terminating from the 'for' loop
				// for now, make the pwszFileVersion to NULL -- this will
				// enable us to decide the result
				pwszFileVersion = NULL;
			}

			// release the earlier access buffer
			strBuffer.UnlockBuffer();

			//
			// internal name
			strBuffer.Format( 
				L"\\StringFileInfo\\%04x%04x\\InternalName",
				pTranslate[ dw ].wLanguage, pTranslate[ dw ].wCodePage );

			// retrieve file description for language and code page "i". 
			pwszBuffer = strBuffer.LockBuffer();
	        if ( VerQueryValueW( pVersionInfo, pwszBuffer,
		                        (LPVOID*) &pwszInternalName, &dwSize ) == FALSE )
	        {
		        // we cannot decide the failure based on the result of this
				// function failure -- we will decide about this
				// after terminating from the 'for' loop
				// for now, make the pwszInternalName to NULL -- this will
				// enable us to decide the result
				pwszInternalName = NULL;
			}

			// release the earlier access buffer
			strBuffer.UnlockBuffer();

			// check whether we got the information that we are looking for or not
			if ( pwszInternalName != NULL && pwszFileVersion != NULL )
			{
				// we got the information
				break;
			}
		}
		catch( ... )
		{
			// do not return -- we might miss the cleanup
			// so just break from the loop and rest will be taken care
			// outside the loop
			pwszFileVersion = NULL;
			pwszInternalName = NULL;
			break;
		}
    }

    // check whether we got the information or we need or not
    if ( pwszInternalName == NULL || pwszFileVersion == NULL )
    {
        delete [] pVersionInfo;
        return translateError;
    }

	// check the internal name -- this is important to make sure that
	// user is not trying to cheat the installation
	if ( pwszRequiredInternalName != NULL )
	{
		if ( CompareStringW( LOCALE_INVARIANT, NORM_IGNORECASE, 
							 pwszInternalName, -1, pwszRequiredInternalName, -1 ) != CSTR_EQUAL )
		{
			// installation is being cheated
			delete [] pVersionInfo;
			return translateWrongFile;
		}
	}

	// 
	// translate the version string
	if ( TranslateVersionString( pwszFileVersion, &verFileVersion ) == FALSE )
    {
        delete [] pVersionInfo;
        return translateError;
    }

    // we are dont with pVersionInfo -- release the memory
    delete [] pVersionInfo;

    //
	// now compare the file version with the required file version

    // major version
    if ( verFileVersion.dwMajor == verRequiredFileVersion.dwMajor )
    {
        // need to proceed with checking minor version
    }
    else if ( verFileVersion.dwMajor < verRequiredFileVersion.dwMajor )
    {
        return translateLesser;
    }
    else if ( verFileVersion.dwMajor > verRequiredFileVersion.dwMajor )
    {
        return translateGreater;
    }

    // minor version
    if ( verFileVersion.dwMinor == verRequiredFileVersion.dwMinor )
    {
        // need to proceed with checking revision (build number)
    }
    else if ( verFileVersion.dwMinor < verRequiredFileVersion.dwMinor )
    {
        return translateLesser;
    }
    else if ( verFileVersion.dwMinor > verRequiredFileVersion.dwMinor )
    {
        return translateGreater;
    }

    // revision (build number)
    if ( verFileVersion.dwRevision == verRequiredFileVersion.dwRevision )
    {
        // need to proceed with checking sub-revision (QFE / SP)
    }
    else if ( verFileVersion.dwRevision < verRequiredFileVersion.dwRevision )
    {
        return translateLesser;
    }
    else if ( verFileVersion.dwRevision > verRequiredFileVersion.dwRevision )
    {
        return translateGreater;
    }

    // sub-revision (QFE / SP)
    if ( verFileVersion.dwSubRevision == verRequiredFileVersion.dwSubRevision )
    {
        // done -- version's matched
        return translateEqual;
    }
    else if ( verFileVersion.dwSubRevision < verRequiredFileVersion.dwSubRevision )
    {
        return translateLesser;
    }
    else if ( verFileVersion.dwSubRevision > verRequiredFileVersion.dwSubRevision )
    {
        return translateGreater;
    }

	// return -- we should not come to this point -- if reached -- error
	return translateError;
}

// verify the existence of the QFE
extern "C" ADMINPAK_API int __stdcall fnCheckForQFE( MSIHANDLE hInstall )
{
	// local variables
	CHString strFile;
	CHString strSystemDirectory;

	// get the path reference to the "system32" directory
	// NOTE: we cannot proceed if we cant get the path to the "system32" directory
	if ( PropertyGet_String( hInstall, L"SystemFolder", strSystemDirectory ) == FALSE )
	{
		return ERROR_INVALID_HANDLE;
	}

	// form the path
	strFile.Format( L"%s%s", strSystemDirectory, L"dsprop.dll" );

	// now check ...
	switch( CheckFileVersion( strFile, L"ShADprop", L"5.1.2600.101" ) )
	{
    case translateEqual:
    case translateGreater:
        {
    		// set the native OS language information
	    	MsiSetPropertyW( hInstall, L"QFE_DSPROP", L"Yes" );
            break;
        }

    default:
        // do nothing
        break;

	}
	
	// return
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\adminpak.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the ADMINPAK_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// ADMINPAK_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef ADMINPAK_EXPORTS
#define ADMINPAK_API __declspec(dllexport)
#else
#define ADMINPAK_API __declspec(dllimport)
#endif


// This class is exported from the adminpak.dll
class ADMINPAK_API CAdminpakDLL {
public:
	CAdminpakDLL(void) {}
};

extern "C" ADMINPAK_API int __stdcall  fnMigrateProfilesToNewCmak( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnDeleteOldCmakVersion( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnTSIntegration( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnDeleteIISLink( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnDetectMMC( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnAdminToolsFolderOn( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnAdminToolsFolderOff( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnBackupAdminpakBackupTable( MSIHANDLE hInstall );
extern "C" ADMINPAK_API int __stdcall  fnRestoreAdminpakBackupTable( MSIHANDLE hInstall );

//AdminpakBackup table column headers
static int BACKUPID = 1;
static int ORIGINALFILENAME = 2;
static int BACKUPFILENAME = 3;
static int BACKUPDIRECTORY = 4;

// includes
#include <comdef.h>
#include <chstring.h>

// prototypes for the the generic functions
BOOL TransformDirectory( MSIHANDLE hInstall, CHString& strDirectory );
BOOL PropertyGet_String( MSIHANDLE hInstall, LPCWSTR pwszProperty, CHString& strValue );
BOOL GetFieldValueFromRecord_String( MSIHANDLE hRecord, DWORD dwColumn, CHString& strValue );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\msidatabase.cpp ===
// MsiDatabase.cpp: implementation of the CMsiDatabase class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <stdlib.h>
#include "MsiDatabase.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/*
CMsiDatabase::CMsiDatabase()
{


//  MSIHANDLE hInstall    // installer handle


}
*/
CMsiDatabase::CMsiDatabase(MSIHANDLE hInstall)
{
	UNREFERENCED_PARAMETER( hInstall );
//	m_hInstall = hInstall;
//	m_hDatabase = MsiGetActiveDatabase(hInstall);
//	*m_pszBuf = new TCHAR(sizeof(BUFFERSIZE));
}
CMsiDatabase::~CMsiDatabase()
{
	delete *m_pszBuf;
}

int CMsiDatabase::GetProperty(TCHAR* name, TCHAR** pszBuf)
{

	DWORD cbSize = BUFFERSIZE;

	ZeroMemory( *m_pszBuf, BUFFERSIZE );
	*pszBuf = *m_pszBuf;
	
	int rt = MsiGetProperty( m_hInstall, name, *pszBuf, &cbSize );
	
	if(rt == ERROR_SUCCESS)
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CMsiDatabase::SetProperty(TCHAR* ptName, TCHAR* ptValue)
{

	int rt = MsiSetProperty( m_hInstall, ptName, ptValue );

	if(rt == ERROR_SUCCESS)
	{
		return TRUE;
	}

	return FALSE;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B96E58A0_CAAD_11D2_9C11_00A0C9F14522__INCLUDED_)
#define AFX_STDAFX_H__B96E58A0_CAAD_11D2_9C11_00A0C9F14522__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <errno.h>

#include <msi.h>
#include <msiquery.h>

#endif // !defined(AFX_STDAFX_H__B96E58A0_CAAD_11D2_9C11_00A0C9F14522__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\shortcuts.cpp ===
#include <stdafx.h>
#include <adminpak.h>
#include <objidl.h>
#include "shlobj.h"

// shortcut icons table ConditionType definition
#define SHI_TYPE_NONE				0
#define SHI_TYPE_SEARCH				1				// searches for existence of component's key file
#define SHI_TYPE_INSTALLCOMPONENT	2				// checked for the component mentioned in the
													// Condition column at HKLM\SOFTWARE\Microsoft\CurrentVersion\Setup\OC Manager\Subcomponents
#define SHI_TYPE_CONDITION			3				// evaluate the condition specified

#define SAFE_EXECUTE_CS( statement )	\
	hr = statement;			\
	if ( FAILED( hr ) )		\
	{						\
		bResult = FALSE;	\
		goto cleanup;		\
	}						\
	1

#define SAFE_RELEASE( pointer )	\
	if ( (pointer) != NULL )				\
	{										\
		(pointer)->Release();				\
		(pointer) = NULL;					\
	}										\
	1

//
// prototypes
//
BOOL IsComponentInstalled( LPCWSTR pwszComponent );
BOOL LocateFile( LPCWSTR pwszFile, LPCWSTR pwszDirectory, PBOOL pbShortForm = NULL );
BOOL CheckForComponents( HKEY hKey, LPCWSTR pwszComponents );
BOOL CreateShortcut( LPCWSTR pwszShortcut, 
					 LPCWSTR pwszDescription, LPCWSTR pwszDirectory,
					 LPCWSTR pwszFileName, LPCWSTR pwszArguments, LPCWSTR pwszWorkingDir, 
					 WORD wHotKey, INT nShowCmd, LPCWSTR pwszIconFile, DWORD dwIconIndex );

//
// implementation
//

BOOL PropertyGet_String( MSIHANDLE hInstall, LPCWSTR pwszProperty, CHString& strValue )
{
	// local variables
	DWORD dwLength = 0;
	DWORD dwResult = 0;
	LPWSTR pwszValue = NULL;
	BOOL bSecondChance = FALSE;

	// check the input arguments
	if ( hInstall == NULL || pwszProperty == NULL )
	{
		return FALSE;
	}

	try
	{
		// mark this as first chance
		dwLength = 255;
		bSecondChance = FALSE;

		//
		// re-start point
		//
		retry_get:

		// get the pointer to the internal buffer
		pwszValue = strValue.GetBufferSetLength( dwLength + 1 );

		// get the value from the MSI record and check the result
		dwResult = MsiGetPropertyW( hInstall, pwszProperty, pwszValue, &dwLength );
		if ( dwResult == ERROR_MORE_DATA && bSecondChance == FALSE )
		{
			// now go back and try to the read the value again
			bSecondChance = TRUE;
			goto retry_get;
		}
		else if ( dwResult != ERROR_SUCCESS )
		{
			SetLastError( dwResult );
			strValue.ReleaseBuffer( 1 );	// simply pass some number
			return FALSE;
		}

		// release the buffer
		strValue.ReleaseBuffer( dwLength );

		// return the result
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL GetFieldValueFromRecord_String( MSIHANDLE hRecord, DWORD dwColumn, CHString& strValue )
{
	// local variables
	DWORD dwLength = 0;
	DWORD dwResult = 0;
	LPWSTR pwszValue = NULL;
	BOOL bSecondChance = FALSE;

	// check the input
	if ( hRecord == NULL )
	{
		return FALSE;
	}

	try
	{

		// mark this as first chance
		dwLength = 255;
		bSecondChance = FALSE;

		//
		// re-start point
		// 
		retry_get:

		// get the pointer to the internal buffer
		pwszValue = strValue.GetBufferSetLength( dwLength + 1 );

		// get the value from the MSI record and check the result
		dwResult = MsiRecordGetStringW( hRecord, dwColumn, pwszValue, &dwLength );
		if ( dwResult == ERROR_MORE_DATA && bSecondChance == FALSE )
		{
			// now go back and try to the read the value again
			bSecondChance = TRUE;
			goto retry_get;
		}
		else if ( dwResult != ERROR_SUCCESS )
		{
			SetLastError( dwResult );
			return FALSE;
		}

		// release the buffer
		strValue.ReleaseBuffer( dwLength );

		// we successfully got the value from the record
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

BOOL CreateShortcut( LPCWSTR pwszShortcut, 
					 LPCWSTR pwszDescription, LPCWSTR pwszDirectory,
					 LPCWSTR pwszFileName, LPCWSTR pwszArguments, LPCWSTR pwszWorkingDir, 
					 WORD wHotKey, INT nShowCmd, LPCWSTR pwszIconFile, DWORD dwIconIndex )
{
	// local variables
	CHString str;
	HRESULT hr = S_OK;
	HANDLE hFile = NULL;
	BOOL bResult = FALSE;
	IShellLinkW* pShellLink = NULL;
	IPersistFile* pPersistFile = NULL;

	// check the input parameters
	// we dont care about the input for pwszArguments parameter
	if ( pwszShortcut == NULL ||
		 pwszDescription == NULL || pwszDirectory == NULL ||
		 pwszFileName == NULL || pwszWorkingDir == NULL || pwszIconFile == NULL )
	{
		return FALSE;
	}
	

	try
	{
		//
		// check if shortcut is already existing at this location or not
		//

		// prepare the link name and save it
		str.Format( L"%s%s", pwszDirectory, pwszShortcut );
        if ( str.Mid( str.GetLength() - 4 ).CompareNoCase( L".lnk" ) != 0 )
        {
            str += ".lnk";
        }

		// try to open the file
		hFile = CreateFileW( str, GENERIC_READ, 
			FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
		if ( hFile != INVALID_HANDLE_VALUE )
		{
			// close the handle to the file
			CloseHandle( hFile );

			// shortcut is alreadt existing -- so, dont create it again
			bResult = TRUE;
			goto cleanup;
		}
		
		//
		// shortcut is not existing -- so we need to create it now
		//

		// get the pointer to the IShellLink interface
		SAFE_EXECUTE_CS( CoCreateInstance( CLSID_ShellLink, NULL, 
			CLSCTX_INPROC_SERVER, IID_IShellLinkW, (LPVOID*) &pShellLink ) );

		// get the pointer to the IPersistFile interface	
		SAFE_EXECUTE_CS( pShellLink->QueryInterface( IID_IPersistFile, (LPVOID*) &pPersistFile ) );

		// set the working directory for the shortcut.
		SAFE_EXECUTE_CS( pShellLink->SetWorkingDirectory( pwszWorkingDir ) );

		// prepare the shortcut name -- path (working dir) + file name -- finally set the path
		// NOTE: we assume path containded in pwszWorkingDir ends with "\"
		str.Format( L"%s%s", pwszWorkingDir, pwszFileName );
		SAFE_EXECUTE_CS( pShellLink->SetPath( str ) );

		// check if arguments needs to set
		if ( pwszArguments == NULL || lstrlenW( pwszArguments ) > 0 )
		{
			SAFE_EXECUTE_CS( pShellLink->SetArguments( pwszArguments ) );
		}

		// set the description
		SAFE_EXECUTE_CS( pShellLink->SetDescription( pwszDescription ) );

		// set icon location
		SAFE_EXECUTE_CS( pShellLink->SetIconLocation( 
			pwszIconFile, ((dwIconIndex == MSI_NULL_INTEGER) ? 0 : dwIconIndex) ) );

		// set hotkey
		if ( wHotKey != MSI_NULL_INTEGER )
		{
			SAFE_EXECUTE_CS( pShellLink->SetHotkey( wHotKey ) );
		}

		// set showcmd
		if ( nShowCmd != MSI_NULL_INTEGER )
		{
			SAFE_EXECUTE_CS( pShellLink->SetShowCmd( nShowCmd ) );
		}

		// prepare the link name and save it
		str.Format( L"%s%s", pwszDirectory, pwszShortcut );
        if ( str.Mid( str.GetLength() - 4 ).CompareNoCase( L".lnk" ) != 0 )
        {
            str += ".lnk";
        }

        // ...
		SAFE_EXECUTE_CS( pPersistFile->Save( str, TRUE ) );

		// mark the result as success
		bResult = TRUE;
	}
	catch( ... )
	{
		bResult = FALSE;
	}

// default clean up
cleanup:

	// release the interfaces
	SAFE_RELEASE( pShellLink );
	SAFE_RELEASE( pPersistFile );

	// return
	return bResult;
}

extern "C" ADMINPAK_API int _stdcall fnReCreateShortcuts( MSIHANDLE hInstall )
{
	// local variables
	CHString str;
	HRESULT hr = S_OK;
	BOOL bFileFound = FALSE;
	BOOL bCreateShortcut = FALSE;
	DWORD dwResult = ERROR_SUCCESS;

	// MSI handles
	PMSIHANDLE hView = NULL;
	PMSIHANDLE hRecord = NULL;
	PMSIHANDLE hDatabase = NULL;

	// query field variables
	WORD wHotKey = 0;
	INT nShowCmd = 0;
	CHString strShortcut;
	CHString strFileName;
	CHString strIconFile;
	CHString strDirectory;
	CHString strArguments;
	CHString strCondition;
	DWORD dwIconIndex = 0;
	CHString strWorkingDir;
	CHString strDescription;
	CHString strIconDirectory;
	DWORD dwConditionType = 0;

	// sql for retrieving the information from MSI table
	const WCHAR cwszSQL[] = 
		L" SELECT DISTINCT"
		L" `Shortcut`.`Name`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `File`.`FileName`, "
		L" `Shortcut`.`Arguments`, `Component`.`Directory_`, `Shortcut`.`Hotkey`, `Shortcut`.`ShowCmd`, "
		L" `ShortcutIcons`.`IconDirectory_`, `ShortcutIcons`.`IconFile`, `ShortcutIcons`.`IconIndex`, "
		L" `ShortcutIcons`.`ConditionType`, `ShortcutIcons`.`Condition` "
		L" FROM `Shortcut`, `Component`, `File`, `ShortcutIcons` "
		L" WHERE `Shortcut`.`Component_` = `Component`.`Component` "
		L" AND   `Component`.`KeyPath` = `File`.`File` "
		L" AND   `ShortcutIcons`.`Shortcut_` = `Shortcut`.`Shortcut`";

	// column indices into the record
	enum {
		Shortcut = 1,
		Description, Directory, FileName, Arguments,
		WorkingDir, HotKey, ShowCmd, IconDirectory, IconFile, IconIndex, ConditionType, Condition
	};

	// initialize the COM library
	hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
	if ( FAILED( hr ) )
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	// get a handle on the MSI database 
	hDatabase = MsiGetActiveDatabase( hInstall );
	if ( hDatabase == NULL ) 
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}
	
	// get a view of our table in the MSI
	dwResult = MsiDatabaseOpenViewW( hDatabase, cwszSQL, &hView ); 
	if ( dwResult != ERROR_SUCCESS ) 
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}
	
	// if no errors, get our records
	dwResult = MsiViewExecute( hView, NULL ); 
	if( dwResult != ERROR_SUCCESS )
	{ 
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	// loop through the result records obtain via SQL
	hRecord = NULL;
	while( MsiViewFetch( hView, &hRecord ) == ERROR_SUCCESS )
	{
		// get the values from the record
		wHotKey = (WORD) MsiRecordGetInteger( hRecord, HotKey );
		nShowCmd = MsiRecordGetInteger( hRecord, ShowCmd );
		dwIconIndex = MsiRecordGetInteger( hRecord, IconIndex );
		dwConditionType = MsiRecordGetInteger( hRecord, ConditionType );
		GetFieldValueFromRecord_String( hRecord, Shortcut, strShortcut );
		GetFieldValueFromRecord_String( hRecord, FileName, strFileName );
		GetFieldValueFromRecord_String( hRecord, IconFile, strIconFile );
		GetFieldValueFromRecord_String( hRecord, Directory, strDirectory );
		GetFieldValueFromRecord_String( hRecord, Arguments, strArguments );
		GetFieldValueFromRecord_String( hRecord, Condition, strCondition );
		GetFieldValueFromRecord_String( hRecord, WorkingDir, strWorkingDir );
		GetFieldValueFromRecord_String( hRecord, Description, strDescription );
		GetFieldValueFromRecord_String( hRecord, IconDirectory, strIconDirectory );

		// shortcut name might contain '|' as seperator for 8.3 and long name formats -- suppress this
		if( strShortcut.Find( L'|' ) != -1 )
		{
			str = strShortcut.Mid( strShortcut.Find( L'|' ) + 1 );
			strShortcut = str;			// store the result back
		}

		// transform the directory property references
		TransformDirectory( hInstall, strDirectory );
		TransformDirectory( hInstall, strWorkingDir );
		TransformDirectory( hInstall, strIconDirectory );

		// prepare the icon locatio
		str.Format( L"%s%s", strIconDirectory, strIconFile );
		strIconFile = str;		// store the result back

		//
		// determine whether shortcut need to be created or not
		//

		// if the condition type is not specified, assume it "SEARCH"
		if ( dwConditionType == MSI_NULL_INTEGER )
		{
			dwConditionType = SHI_TYPE_SEARCH;
		}

		// no matter what the "ConditionType" -- since creation of the shortcut very much depends
		// on the existence of the file, we will try to locate for the file first -- this is necessary condition
		// so, do a simple file search for the component key file
		bFileFound = LocateFile( strFileName, strWorkingDir, NULL );

		// proceed with rest of the conditions only if necessary condition is satisfied
		if ( bFileFound == TRUE )
		{
			//
			// now do additional sufficient conditon(s) if needed
			//
			bCreateShortcut = FALSE;
			if ( dwConditionType == SHI_TYPE_SEARCH )
			{
				// search is already successful
				bCreateShortcut = TRUE;
			}
			else if ( dwConditionType == SHI_TYPE_INSTALLCOMPONENT )
			{
				// check whether the component specified in 'Condition' field is installed or not
				bCreateShortcut = IsComponentInstalled( strCondition );
			}
			else if ( dwConditionType == SHI_TYPE_CONDITION )
			{
				// evaluate the condition specified by the user
				if ( MsiEvaluateConditionW( hInstall, strCondition ) == MSICONDITION_TRUE )
				{
					bCreateShortcut = TRUE;
				}
			}

			// check the shortcut if needed
			if ( bCreateShortcut == TRUE )
			{
				CreateShortcut( strShortcut, 
					strDescription, strDirectory, strFileName, strArguments, 
					strWorkingDir, wHotKey, nShowCmd, strIconFile, dwIconIndex );
			}
		}

		// close the MSI handle to the current record object -- ignore the error
		MsiCloseHandle( hRecord );
		hRecord = NULL;
	}

	// mark the flag as success
	dwResult = ERROR_SUCCESS;

//
// cleanup
//
cleanup:

	// un-initialize the COM library
	CoUninitialize();

	// close the handle to the record
	if ( hRecord != NULL )
	{
		MsiCloseHandle( hRecord );
		hRecord = NULL;
	}
	
	// close View -- ignore the errors
	if ( hView != NULL )
	{
		MsiViewClose( hView );
		hView = NULL;
	}

	// close the database handle
	if ( hDatabase != NULL )
	{
		MsiCloseHandle( hDatabase );
		hDatabase = NULL;
	}

	// return
	return dwResult;
}


BOOL LocateFile( LPCWSTR pwszFile, LPCWSTR pwszDirectory, PBOOL pbShortForm )
{
	// local variables
	INT nPosition = 0;
	HANDLE hFind = NULL;
	BOOL bFound = FALSE;
	CHString strPath;
	CHString strFileName;
	WIN32_FIND_DATAW findData;

    // check the optional parameter
    if ( pbShortForm != NULL )
    {
        *pbShortForm = FALSE;
    }

	// check the input
	if ( pwszFile == NULL || pwszDirectory == NULL )
	{
		return FALSE;
	}

	try
	{
		// init the variable with file name passed
		strFileName = pwszFile;

		// check whether user specified two formats for this file (8.3 and long format)
		nPosition = strFileName.Find( L'|' );
		if ( nPosition != -1 )
		{
			// extract the long file name first
			CHString strTemp;
			strTemp = strFileName.Mid( nPosition + 1 );
			strFileName = strTemp;
			
			// check the length of the file name
			if ( strFileName.GetLength() == 0 )
			{
				// invalid file name format
				return FALSE;
			}
		}

		// prepare the path
		strPath.Format( L"%s%s", pwszDirectory, strFileName );

		// search for this file
		bFound = FALSE;
		hFind = FindFirstFileW( strPath, &findData );
		if ( hFind == INVALID_HANDLE_VALUE )
		{
			// find failed -- may be file is not found -- confirm this
            bFound = FALSE;
			if ( GetLastError() == ERROR_FILE_NOT_FOUND )
			{
				// yes -- file is not found
			}
		}
		else
		{
			// file is located
			// take the actions needed

			// close the handle to the file search first
			FindClose( hFind );
			hFind = NULL;

			// set the flag
			bFound = TRUE;
            if ( pbShortForm != NULL )
            {
                *pbShortForm = FALSE;
            }
		}

		//
		// file is not found in long format
		// may be, it is existed in 8.3 format
		// so, check whether user supplied 8.3 file name for this file
		if ( nPosition != -1 && bFound == FALSE )
		{
			// extract the 8.3 format of the file name
			CHString strTemp;
			strTemp = pwszFile;
			strFileName = strTemp.Mid( 0, nPosition );

			// prepare the path
			strPath.Format( L"%s%s", pwszDirectory, strFileName );

			// search for this file
			bFound = FALSE;
			hFind = FindFirstFileW( strPath, &findData );
			if ( hFind == INVALID_HANDLE_VALUE )
			{
				// find failed -- may be file is not found -- confirm this
				if ( GetLastError() == ERROR_FILE_NOT_FOUND )
				{
					// yes -- file is not found
				}
			}
			else
			{
				// file is located
				// take the actions needed

				// close the handle to the file search first
				FindClose( hFind );
				hFind = NULL;

				// set the flag
				bFound = TRUE;
                if ( pbShortForm != NULL )
                {
                    *pbShortForm = TRUE;
                }
			}
		}
	}
	catch( ... )
	{
		return FALSE;
	}

	// return the result of search
	return bFound;
}

BOOL IsComponentInstalled( LPCWSTR pwszComponent )
{
	// local variables
	HKEY hKey = NULL;
	LONG lResult = 0;
	LONG lPosition = 0;
	CHString strTemp;
	CHString strComponent;
	CHString strComponents;
	BOOL bComponentInstalled = FALSE;
	const WCHAR cwszSubKey[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";

	// open the registry path
	lResult = RegOpenKeyExW( HKEY_LOCAL_MACHINE, cwszSubKey, 0, KEY_READ, &hKey );
	if ( lResult != ERROR_SUCCESS )
	{
		SetLastError( lResult );
		return FALSE;
	}

	//
	// since components may be multiple -- we need to check for each and every component
	//
	try
	{
		// get the component -- ready for processing
		strComponents = pwszComponent;

		// loop until there are no more components
		bComponentInstalled = FALSE;
		while ( strComponents.GetLength() != 0 )
		{
			// extract the first component
			lPosition = strComponents.Find( L';' );
			if ( lPosition != -1 )
			{
				strComponent = strComponents.Mid( 0, lPosition );
				strTemp = strComponents.Mid( lPosition + 1 );
				strComponents = strTemp;
			}
			else
			{
				// there is only one component
				strComponent = strComponents;
				strComponents = L"";
			}

			// check for the components existence
			if ( CheckForComponents( hKey, strComponent ) == TRUE )
			{
				// since this is an OR condition checking -- if atleast one component in installed
				// then we will return from here itself as there wont be any meaning in checking for the
				// existence of other components -- the condition is satisfied
				bComponentInstalled = TRUE;
				break;
			}
		}

	}
	catch( ... )
	{
		// ignore the exception
	}

	// we are done with the opened registry key -- we can close it
	RegCloseKey( hKey );
	hKey = NULL;

	// return the result
	return bComponentInstalled;
}

BOOL CheckForComponents( HKEY hKey, LPCWSTR pwszComponents )
{
	// local variables
	LONG lResult = 0;
	DWORD dwType = 0;
	DWORD dwSize = 0;
	DWORD dwValue = 0;
	CHString strTemp;
	CHString strComponent;
	CHString strComponents;
	LONG lPosition = 0;

	// check the input
	if ( hKey == NULL || pwszComponents == NULL )
	{
		return FALSE;
	}

	try
	{
		// ...
		strComponents = pwszComponents;
		if ( strComponents.GetLength() == 0 )
		{
			return FALSE;
		}

		// loop until all the components are checked
		while ( strComponents.GetLength() != 0 )
		{
			// extract the first component
			lPosition = strComponent.Find( L',' );
			if ( lPosition != -1 )
			{
				strComponent = strComponents.Mid( 0, lPosition );
				strTemp = strComponents.Mid( lPosition + 1 );
				strComponents = strTemp;
			}
			else
			{
				// there is only one component
				strComponent = strComponents;
				strComponents = L"";
			}

			// now check for this component in registry
			dwSize = sizeof( DWORD );
			lResult = RegQueryValueExW( hKey, strComponent, NULL, &dwType, (LPBYTE) &dwValue, &dwSize );

			// *) check result of the registry query operation
			// *) confirm the type of the value -- it should be REG_DWORD
			// *) also check the state of the component and return the accordingly
			//     1		Installed
			//     0		Not Installed
			strTemp.Format( L"%d", dwValue );
			if ( lResult != ERROR_SUCCESS || dwType != REG_DWORD || dwValue == 0 )
			{
				// no matter what is the reason -- we will treat this as
				// component is not installed at all
				//
				// and since this is an AND condition checking -- if atleast one component in not installed
				// then we will return from here itself as there wont be any meaning in checking for the
				// existence of other components
				return FALSE;
			}
		}
	}
	catch( ... )
	{
		return FALSE;
	}

	// if the control came to this point -- it is obvious that required components are installed
	return TRUE;
}


BOOL TransformDirectory( MSIHANDLE hInstall, CHString& strDirectory )
{
	// local variables
	CHString strActualDirectory;

	// check the input parameters
	if ( hInstall == NULL )
	{
		return FALSE;
	}

	try
	{
		// get the property value
		PropertyGet_String( hInstall, strDirectory, strActualDirectory );

		// assign the property value to the input argument
		strDirectory = strActualDirectory;

		// return
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}

// remove the shortcuts that are created by W2K version of adminpak.msi (W2K -> .NET upgrade scenario)
extern "C" ADMINPAK_API int _stdcall fnDeleteW2KShortcuts( MSIHANDLE hInstall )
{
	// local variables
	CHString str;
	HRESULT hr = S_OK;
	BOOL bFileFound = FALSE;
    BOOL bShortForm = FALSE;
	BOOL bCreateShortcut = FALSE;
    DWORD nPosition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	// MSI handles
	PMSIHANDLE hView = NULL;
	PMSIHANDLE hRecord = NULL;
	PMSIHANDLE hDatabase = NULL;

	// query field variables
	CHString strShortcut;
	CHString strNewShortcut;
	CHString strShortcutDirectory;
	CHString strRecreate;
	CHString strFileDirectory;
	CHString strFileName;
	CHString strArguments;
	CHString strDescription;
	CHString strIconDirectory;
	CHString strIconFile;
	DWORD dwIconIndex = 0;
	DWORD dwConditionType = 0;
	CHString strCondition;

	// sql for retrieving the information from MSI table
	const WCHAR cwszSQL[] = L"SELECT * FROM `W2KShortcutCleanup`";

	// column indices into the record
	enum {
		Shortcut = 2,
		ShortcutDirectory, Recreate, NewShortcut,
		FileDirectory, FileName, Arguments, Description, 
		IconDirectory, IconFile, IconIndex, ConditionType, Condition
	};

	// initialize the COM library
	hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
	if ( FAILED( hr ) )
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

    // get a handle on the MSI database 
	hDatabase = MsiGetActiveDatabase( hInstall );
	if ( hDatabase == NULL ) 
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

    // get a view of our table in the MSI
	dwResult = MsiDatabaseOpenViewW( hDatabase, cwszSQL, &hView ); 
	if ( dwResult != ERROR_SUCCESS ) 
	{
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

    // if no errors, get our records
	dwResult = MsiViewExecute( hView, NULL ); 
	if( dwResult != ERROR_SUCCESS )
	{ 
		dwResult = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

    try
    {
        // loop through the result records obtain via SQL
	    hRecord = NULL;
	    while( MsiViewFetch( hView, &hRecord ) == ERROR_SUCCESS )
	    {
            // get the values from the record
		    dwIconIndex = MsiRecordGetInteger( hRecord, IconIndex );
		    dwConditionType = MsiRecordGetInteger( hRecord, ConditionType );
		    GetFieldValueFromRecord_String( hRecord, Shortcut, strShortcut );
		    GetFieldValueFromRecord_String( hRecord, NewShortcut, strNewShortcut );
		    GetFieldValueFromRecord_String( hRecord, Recreate, strRecreate );
		    GetFieldValueFromRecord_String( hRecord, FileName, strFileName );
		    GetFieldValueFromRecord_String( hRecord, IconFile, strIconFile );
		    GetFieldValueFromRecord_String( hRecord, Arguments, strArguments );
		    GetFieldValueFromRecord_String( hRecord, Condition, strCondition );
		    GetFieldValueFromRecord_String( hRecord, Description, strDescription );
		    GetFieldValueFromRecord_String( hRecord, FileDirectory, strFileDirectory );
		    GetFieldValueFromRecord_String( hRecord, IconDirectory, strIconDirectory );
		    GetFieldValueFromRecord_String( hRecord, ShortcutDirectory, strShortcutDirectory );

		    // transform the directory property references
		    TransformDirectory( hInstall, strFileDirectory );
		    TransformDirectory( hInstall, strIconDirectory );
		    TransformDirectory( hInstall, strShortcutDirectory );
    
            // search for the existence of the shortcut
		    if ( LocateFile( strShortcut, strShortcutDirectory ) == FALSE )
		    {
			    // file is not found
			    goto loop_cleanup;
		    }

		    //
		    // shortcut is found
		    //

		    // delete the shortcut
            //
            // file might be in short name or long name -- so attempt to delete the appropriate file only
            nPosition = strShortcut.Find( L'|' );
            if ( nPosition != -1 )
            {
                if ( bShortForm == TRUE )
                {
                    str = strShortcut.Mid( 0, nPosition );
                }
                else
                {
                    str = strShortcut.Mid( nPosition + 1 );
                }

                // ...
                strShortcut = str;
            }


		    str.Format( L"%s%s", strShortcutDirectory, strShortcut );
		    if ( DeleteFileW( str ) == FALSE )
		    {
			    // failed to delete the file
			    goto loop_cleanup;
		    }

			// check if the directory is empty or not --
			// if the directory is empty, delete the directory also
			if ( LocateFile( L"*.lnk", strShortcutDirectory ) == FALSE )
			{
				// directory is empty -- delete it
				// NOTE: we dont care about the suceess of the function call
				RemoveDirectoryW( strShortcutDirectory );
			}

		    // check whether we need to recreate the shortcut or not
		    if ( strRecreate == L"N" )
		    {
			    // no need to create the shortcut
			    goto loop_cleanup;
		    }

		    //
		    // we need to recreate the shortcut
		    //

		    // prepare the icon location
		    str.Format( L"%s%s", strIconDirectory, strIconFile );
		    strIconFile = str;		// store the result back

		    //
		    // determine whether shortcut need to be created or not
		    //

		    // if the condition type is not specified, assume it "SEARCH"
		    if ( dwConditionType == MSI_NULL_INTEGER )
		    {
			    dwConditionType = SHI_TYPE_SEARCH;
		    }

		    // no matter what the "ConditionType" -- since creation of the shortcut very much depends
		    // on the existence of the file, we will try to locate for the file first -- this is necessary condition
		    // so, do a simple file search for the component key file
		    bFileFound = LocateFile( strFileName, strFileDirectory );

		    // proceed with rest of the conditions only if necessary condition is satisfied
		    if ( bFileFound == TRUE )
		    {
			    //
			    // now do additional sufficient conditon(s) if needed
			    //
			    bCreateShortcut = FALSE;
			    if ( dwConditionType == SHI_TYPE_SEARCH )
			    {
				    // search is already successful
				    bCreateShortcut = TRUE;
			    }
			    else if ( dwConditionType == SHI_TYPE_INSTALLCOMPONENT )
			    {
				    // check whether the component specified in 'Condition' field is installed or not
				    bCreateShortcut = IsComponentInstalled( strCondition );
			    }
			    else if ( dwConditionType == SHI_TYPE_CONDITION )
			    {
				    // evaluate the condition specified by the user
				    if ( MsiEvaluateConditionW( hInstall, strCondition ) == MSICONDITION_TRUE )
				    {
					    bCreateShortcut = TRUE;
				    }
			    }

			    // check the shortcut if needed
			    if ( bCreateShortcut == TRUE )
			    {
				    CreateShortcut( 
					    ((strNewShortcut.GetLength() == 0) ? strShortcut : strNewShortcut), strDescription, 
					    strShortcutDirectory, strFileName, strArguments, strFileDirectory, 0, 0, strIconFile, dwIconIndex );
			    }
		    }

		    loop_cleanup:

		    // close the MSI handle to the current record object -- ignore the error
		    MsiCloseHandle( hRecord );
		    hRecord = NULL;
	    }

	    // mark the flag as success
	    dwResult = ERROR_SUCCESS;
    }
    catch( ... )
    {
        // error
		dwResult = ERROR_INVALID_HANDLE;
    }

//
// cleanup
//
cleanup:

	// un-initialize the COM library
	CoUninitialize();

	// close the handle to the record
	if ( hRecord != NULL )
	{
		MsiCloseHandle( hRecord );
		hRecord = NULL;
	}
	
	// close View -- ignore the errors
	if ( hView != NULL )
	{
		MsiViewClose( hView );
		hView = NULL;
	}

	// close the database handle
	if ( hDatabase != NULL )
	{
		MsiCloseHandle( hDatabase );
		hDatabase = NULL;
	}

	// return
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\adsprop.cpp ===
/*---------------------------------------------------------------------------
  File: McsADsClassProp.cpp

  Comments: Implementation of DLL Exports.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsADsClassPropps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ADsProp.h"

#include "ADsProp_i.c"
#include "ObjProp.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ObjPropBuilder, CObjPropBuilder)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsADsClassProp.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSADSCLASSPROPLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsADsClassProp.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ADsProp.rc
//
#define IDS_PROJNAME                    100
#define IDR_OBJPROPBUILDER              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\objprop.cpp ===
/*---------------------------------------------------------------------------
  File: ObjPropBuilder.cpp

  Comments: Implementation of CObjPropBuilder COM object. This COM object
            is used to access/set properties for Win2K active directory
            objects. This COM object supports following operations
            
            1. GetClassPropeEnum : This method allows users to get all the
                                   the properties for a class in a domain.

            2. GetObjectProperty : This method gathers values for properties
                                   on a given AD object. 

            3. MapProperties : Constructs a set of properties that are common
                               to two classes in the AD.

            4. SetPropFromVarset : Sets properties for a AD object from a varset.

            5. CopyProperties : Copies common properties from source AD object
                                to target AD object.


  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "EaLen.hpp"
#include "ResStr.h"
#include "ADsProp.h"
#include "ObjProp.h"
#include "iads.h"
#include <lm.h>
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "StrHelp.h"
#include "pwgen.hpp"
#include "AdsiHelpers.h"
#include "GetDcName.h"
#include "TxtSid.h"
#include <Sddl.h>
#include <set>

StringLoader gString;

//#import "\bin\NetEnum.tlb" no_namespace 
//#import "\bin\DBManager.tlb" no_namespace
#import "NetEnum.tlb" no_namespace 
#import "DBMgr.tlb" no_namespace

#ifndef ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT
#define ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT 0x10
#endif
#ifndef ADS_SYSTEMFLAG_ATTR_IS_OPERATIONAL
#define ADS_SYSTEMFLAG_ATTR_IS_OPERATIONAL 0x8
#endif
#ifndef ADS_SYSTEMFLAG_ATTR_REQ_PARTIAL_SET_MEMBER
#define ADS_SYSTEMFLAG_ATTR_REQ_PARTIAL_SET_MEMBER 0x2
#endif

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif

TErrorDct                    err;
TError                     & errCommon = err;

/////////////////////////////////////////////////////////////////////////////
// CObjPropBuilder

BOOL CObjPropBuilder::GetProgramDirectory(
      WCHAR                * filename      // out - buffer that will contain path to program directory
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   if ( ! bFound )
   {
      UStrCpy(filename,L"C:\\");    // if all else fails, default to the C: drive
   }
   return bFound;
}

//---------------------------------------------------------------------------
// GetClassPropEnum: This function fills the varset with all the properties 
//                   for a given class in a given domain. The Varset has 
//                   values stored by the OID and then by their name with
//                   MandatoryProperties/OptionalProperties as parent nodes
//                   as applicable.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::GetClassPropEnum(
                                                BSTR sClassName,        //in -Class name to get the properties for
                                                BSTR sDomainName,       //in -Domain name
                                                long lVer,              //in -The domain version
                                                IUnknown **ppVarset     //out-Varset filled with the properties
                                              )
{
   // This function goes through the list of properties for the specified class in specified domain
   // Builds the given varset with the properties and their values.
   WCHAR                     sAdsPath[LEN_Path];
   DWORD                     dwArraySizeOfsAdsPath = sizeof(sAdsPath)/sizeof(sAdsPath[0]);
   HRESULT                   hr = E_INVALIDARG;
   _variant_t                dnsName;

   if (sDomainName == NULL || sClassName == NULL)
      return hr;
   
   if ( lVer > 4 ) 
   {
      // For this Domain get the default naming context
      wsprintfW(sAdsPath, L"LDAP://%s/rootDSE", sDomainName);
      IADs                    * pAds = NULL;

      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
   
      if ( SUCCEEDED(hr) )
      {
         hr = pAds->Get(L"defaultNamingContext", &dnsName);
      }
      if ( SUCCEEDED(hr) )
      {
         wcscpy(m_sNamingConvention, dnsName.bstrVal);

         // Build LDAP path to the schema
         if (wcslen(L"LDAP://") + wcslen(sDomainName)
             + wcslen(L"/") + wcslen(sClassName)
             + wcslen(L", schema") >= dwArraySizeOfsAdsPath)
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
         else
         {
             wcscpy(sAdsPath, L"LDAP://"); 
             wcscat(sAdsPath, sDomainName);
             wcscat(sAdsPath, L"/");
             wcscat(sAdsPath, sClassName);
             wcscat(sAdsPath, L", schema");
             hr = S_OK;
         }
      }

      if ( pAds )
         pAds->Release();
   }
   else
   {
      wsprintf(sAdsPath, L"WinNT://%s/Schema/%s", sDomainName, sClassName);
      hr = S_OK;
   }

   if ( SUCCEEDED(hr) )
   {
      wcscpy(m_sDomainName, sDomainName);
      m_lVer = lVer;
      // Get the class object.
      IADsClass               * pIClass=NULL;
            
      hr = ADsGetObject(sAdsPath, IID_IADsClass, (void **)&pIClass);
      // Without the object we can not go any further so we will stop here.
      if ( SUCCEEDED(hr) )
      {
         // Let the Auxilliary function take care of Getting properties and filling up the Varset.
         hr = GetClassProperties( pIClass, *ppVarset );
         pIClass->Release();
      }   
   }
	return hr;
}

//---------------------------------------------------------------------------
// GetClassProperties: This function fills the varset with properties of the class.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::GetClassProperties( 
                                            
                                             IADsClass * pClass,     //in -IADsClass * to the class
                                             IUnknown *& pVarSet     //out-Varset to fill the properties
                                           )
{
   HRESULT                   hr;
   _variant_t                variant;

   // mandatory properties
   hr = pClass->get_MandatoryProperties(&variant);
   if ( SUCCEEDED(hr) )
   {
      hr = FillupVarsetFromVariant(pClass, &variant, L"MandatoryProperties", pVarSet);
   }
   variant.Clear();
   
   // optional properties
   hr = pClass->get_OptionalProperties(&variant);
   if ( SUCCEEDED(hr) )
   {
      hr = FillupVarsetFromVariant(pClass, &variant, L"OptionalProperties", pVarSet);
   }
   variant.Clear();

   return hr;
}

//---------------------------------------------------------------------------
// FillupVarsetFromVariant: This function fills in the Varset property info
//                          with the info in a variant.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetFromVariant(
                                                   IADsClass * pClass,  //in -IADsClass * to the class
                                                   VARIANT * pVar,      //in -Variant to lookup info.
                                                   BSTR sPropType,      //in -Type of the property
                                                   IUnknown *& pVarSet  //out-Varset with the info,
                                                )
{
   HRESULT                      hr;
   BSTR                         sPropName;
   USHORT                       type;
   type = pVar->vt;
   
   if ( type & VT_ARRAY )
   {
      if ( type == (VT_ARRAY|VT_VARIANT) )
      {
         hr = FillupVarsetFromVariantArray(pClass, pVar->parray, sPropType, pVarSet);
         if ( FAILED ( hr ) )
            return hr;
      }
      else
         return S_FALSE;
   }
   else
   {
      if ( type == VT_BSTR )
      {
         // Only other thing that the VARIANT could be is a BSTR.
         sPropName = pVar->bstrVal;
         hr = FillupVarsetWithProperty(sPropName, sPropType, pVarSet);
         if ( FAILED ( hr ) )
            return hr;
      }
      else
         return S_FALSE;
   }
   return S_OK;
}

//---------------------------------------------------------------------------
// FillupVarsetWithProperty: Given the class prop name and the prop type this
//                           function fills info into the varset.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetWithProperty(
                                                   BSTR sPropName,      //in -Property name
                                                   BSTR sPropType,      //in -Property type
                                                   IUnknown *& pVarSet  //out-Varset to fill in the information
                                                 )
{
   if ( wcslen(sPropName) == 0 )
      return S_OK;
   // This function fills up the Varset for a given property
   HRESULT                         hr;
   _variant_t                      var;
   _variant_t                      varSO;
   _variant_t                      varID;
   IVarSetPtr                      pVar;
   WCHAR                           sAdsPath[LEN_Path];
   DWORD                           dwArraySizeOfsAdsPath = sizeof(sAdsPath)/sizeof(sAdsPath[0]);
   IADsProperty                  * pProp = NULL;
   BSTR                            objID = NULL;
   BSTR                            sPath = NULL;
   BSTR                            sClass = NULL;
   WCHAR                           sPropPut[LEN_Path];

   if (sPropName == NULL || sPropType == NULL)
      return E_INVALIDARG;

   // Get the OID  for the property
   // First we need a IADsProperty pointer to the property schema
   if ( m_lVer > 4 )
   {
      if (wcslen(L"LDAP://") + wcslen(m_sDomainName)
          + wcslen(L"/") + wcslen(sPropName) + wcslen(L", schema") >= dwArraySizeOfsAdsPath)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, m_sDomainName);
      wcscat(sAdsPath, L"/");
      wcscat(sAdsPath, sPropName);
      wcscat(sAdsPath, L", schema");
   }
   else
   {
      wsprintf(sAdsPath, L"WinNT://%s/Schema/%s", m_sDomainName, sPropName);
   }

   hr = ADsGetObject(sAdsPath, IID_IADsProperty, (void **)&pProp);

   if (SUCCEEDED(hr))
   {
       // Get the objectID for the property
       hr = pProp->get_OID(&objID);

       if (SUCCEEDED(hr))
       {
           hr = pProp->get_ADsPath(&sPath);

           if (SUCCEEDED(hr))
           {
               hr = pProp->get_Class(&sClass);

               if (SUCCEEDED(hr))
               {               
                   // Get the varset from the parameter
                   pVar = pVarSet;

                   // Set up the variant to put into the varset
                   var = objID;
                 
                   // Put the value into the varset
                   wcscpy(sPropPut, sPropType);
                   wcscat(sPropPut, L".");
                   wcscat(sPropPut, sPropName);
                   hr = pVar->put(sPropPut, var);

                   if (SUCCEEDED(hr))
                   {
                       // Set up the variant to put into the varset
                       var = sPropName;

                       // Put the value with the ObjectID as the key.
                       hr = pVar->put(objID, var);
                   }
               }
           }
       }
   }
   
   SysFreeString(objID);
   SysFreeString(sPath);
   SysFreeString(sClass);
   if (pProp)
   {
      pProp->Release();
   }
   
   return hr;
}

//---------------------------------------------------------------------------
// FillupVarsetFromVariantArray: Given the class, SafeArray of props and the 
//                               prop type this function fills info into the 
//                               varset.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetFromVariantArray(
                                                         IADsClass * pClass,  //in -IADsClass* to the class in question
                                                         SAFEARRAY * pArray,  //in -SafeArray pointer with the prop names
                                                         BSTR sPropType,      //in -Property type
                                                         IUnknown *& pVarSet  //out-Varset with the information filled in
                                                     )
{
   HRESULT                   hr = S_FALSE;
   DWORD                     nDim;         // number of dimensions, must be one
   LONG                      nLBound;      // lower bound of array
   LONG                      nUBound;      // upper bound of array
   LONG                      indices[1];   // array indices to access elements
   DWORD                     rc;           // SafeArray return code
   VARIANT                   variant;      // one element in array
   
   nDim = SafeArrayGetDim(pArray);
   VariantInit(&variant);

   if ( nDim == 1 )
   {
      SafeArrayGetLBound(pArray, 1, &nLBound);
      SafeArrayGetUBound(pArray, 1, &nUBound);
      for ( indices[0] = nLBound, rc = 0;
            indices[0] <= nUBound && !rc;
            indices[0] += 1 )
      {
         
         rc = SafeArrayGetElement(pArray,indices,&variant);
         if ( !rc )
            hr = FillupVarsetFromVariant(pClass, &variant, sPropType, pVarSet);
         VariantClear(&variant);
      }
   }


   return hr;
}

//---------------------------------------------------------------------------
// GetProperties: This function gets the values for the properties specified
//                in the varset in the ADS_ATTR_INFO array for the object
//                specified in a given domain.
//---------------------------------------------------------------------------
DWORD CObjPropBuilder::GetProperties(
                                       BSTR sObjPath,             //in -Path to the object for which we are getting the props
//                                       BSTR sDomainName,          //in -Domain name where the object resides
                                       IVarSet * pVar,           //in -Varset listing all the property names that we need to get.
                                       ADS_ATTR_INFO*& pAttrInfo  //out-Attribute values for the property
                                    )
{
   // Construct the LDAP path.
   WCHAR                   sPath[LEN_Path];
   VARIANT                 var;

   // Get the path to the source object
   safecopy(sPath, sObjPath);

   // Get the Varset pointer and enumerate the properties asked for and build an array to send to IADsDirectory
   long                      lRet=0;
   SAFEARRAY               * keys = NULL;
   SAFEARRAY               * vals = NULL;
   IDirectoryObject        * pDir;
   DWORD                     dwRet = 0;

   LPWSTR                  * pAttrNames = new LPWSTR[pVar->GetCount()];
   HRESULT                   hr = pVar->raw_getItems(NULL, NULL, 1, 10000, &keys, &vals, &lRet);

   VariantInit(&var);

   if (!pAttrNames)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   if ( SUCCEEDED( hr ) ) 
   {

      // Build the Attribute array from the varset.
      for ( long x = 0; x < lRet; x++ )
      {
         ::SafeArrayGetElement(keys, &x, &var);
         int len = wcslen(var.bstrVal);
         pAttrNames[x] = new WCHAR[len + 2];
		 if (!(pAttrNames[x]))
		 {
			for (int j=0; j<x; j++)
			   delete [] pAttrNames[j];
			delete [] pAttrNames;
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		 }
         wcscpy(pAttrNames[x], var.bstrVal);
         VariantClear(&var);
      }

      // Now get the IDirectoryObject Ptr for the given object.
      hr = ADsGetObject(sPath, IID_IDirectoryObject, (void **)&pDir);
      if ( FAILED( hr ) ) 
      {
         dwRet = 0;
      }
      else
      {
         // Get the Property values for the object.
         hr = pDir->GetObjectAttributes(pAttrNames, lRet, &pAttrInfo, &dwRet);
         pDir->Release();
      }
      for ( long y = 0 ; y < lRet; y++ )
      {
         delete [] pAttrNames[y];
      }
      SafeArrayDestroy(keys);
      SafeArrayDestroy(vals);
   }
   delete [] pAttrNames;

   return dwRet;
}

//---------------------------------------------------------------------------
// GetObjectProperty: This function takes in a varset with property names. 
//                    Then it fills up the varset with values by getting them 
//                    from the Object.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::GetObjectProperty(
                                                   BSTR sobjSubPath,       //in- LDAP Sub path to the object
//                                                   BSTR sDomainName,       //in- Domain name where the object resides
                                                   IUnknown **ppVarset     //out-Varset filled with the information
                                               )
{
   IVarSetPtr                pVar;
   ADS_ATTR_INFO           * pAttrInfo=NULL;
   pVar = *ppVarset;

   // Get the properties from the directory
   DWORD dwRet = GetProperties(sobjSubPath, /*sDomainName,*/ pVar, pAttrInfo);

   // The GetProperties return value is overloaded: either a failure HRESULT
   // (e.g., a negetive value), or a count if successful
   if ( FAILED(dwRet) )
      return dwRet;

   _ASSERT(dwRet >= 0);

   // Go through the property values and put them into the varset.
   for ( DWORD dwIdx = 0; dwIdx < dwRet; dwIdx++ )
   {
      SetValuesInVarset(pAttrInfo[dwIdx], pVar);
   }
   if ( pAttrInfo )
      FreeADsMem( pAttrInfo );
   return S_OK;
}

//---------------------------------------------------------------------------
// SetValuesInVarset: This function sets the values for the properties into
//                    a varset.
//---------------------------------------------------------------------------
void CObjPropBuilder::SetValuesInVarset(
                                          ADS_ATTR_INFO attrInfo,    //in -The property value in ADS_ATTR_INFO struct.
                                          IVarSetPtr pVar            //in,out -The VarSet where we need to put the values
                                       )
{
   // This function extraces values from ADS_ATTR_INFO struct and puts it into the Varset.
   LPWSTR            sKeyName = attrInfo.pszAttrName;
   _variant_t        var;
   // Got through each value ( in case of multivalued entries ) and depending on the type put it into the varset
   // the way we put in single value entries is to put the propertyName as key and put its value as value. Although
   // in case of a multivalued entry we put PropertyName.### and each of the values in it.
   for ( DWORD dw = 0; dw < attrInfo.dwNumValues; dw++)
   {
      var = L"";
      if ( attrInfo.dwNumValues > 1 )
         // Multivalued property name
         wsprintfW(sKeyName, L"%s.%d", attrInfo.pszAttrName, dw);
      else
         // Single value keyname.
         wcscpy(sKeyName,attrInfo.pszAttrName);

      // Fill in the values as per the varset.
      switch (attrInfo.dwADsType)
      {
         case ADSTYPE_DN_STRING           :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].DNString);
                                             break;
         case ADSTYPE_CASE_EXACT_STRING   :  var.vt = VT_BSTR;
                                             var.bstrVal = attrInfo.pADsValues[dw].CaseExactString;
                                             break;
         case ADSTYPE_CASE_IGNORE_STRING  :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].CaseIgnoreString);
                                             break;
         case ADSTYPE_PRINTABLE_STRING    :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].PrintableString);
                                             break;
         case ADSTYPE_NUMERIC_STRING      :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].NumericString);
                                             break;
         case ADSTYPE_INTEGER             :  var.vt = VT_I4;
                                             var.lVal = attrInfo.pADsValues[dw].Integer;
                                             break; 
         case ADSTYPE_OCTET_STRING        :  {
                                                var.vt = VT_ARRAY | VT_UI1;
                                                long           * pData;
                                                DWORD            dwLength = attrInfo.pADsValues[dw].OctetString.dwLength;
                                                SAFEARRAY      * sA;
                                                SAFEARRAYBOUND   rgBound = {dwLength, 0}; 
                                                sA = ::SafeArrayCreate(VT_UI1, 1, &rgBound);
                                                ::SafeArrayAccessData( sA, (void**)&pData);
                                                for ( DWORD i = 0; i < dwLength; i++ )
                                                   pData[i] = attrInfo.pADsValues[dw].OctetString.lpValue[i];
                                                ::SafeArrayUnaccessData(sA);
                                                var.parray = sA;
                                             }
                                             break;
/*         case ADSTYPE_UTC_TIME            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Date not supported.");
                                             break;
         case ADSTYPE_LARGE_INTEGER       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Large Integer not supported.");
                                             break;
         case ADSTYPE_PROV_SPECIFIC       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Provider specific strings not supported.");
                                             break;
         case ADSTYPE_OBJECT_CLASS        :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].ClassName);
                                             break;
         case ADSTYPE_CASEIGNORE_LIST     :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Case ignore lists are not supported.";
                                             break;
         case ADSTYPE_OCTET_LIST          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Octet lists are not supported.";
                                             break;
         case ADSTYPE_PATH                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Path type not supported.";
                                             break;
         case ADSTYPE_POSTALADDRESS       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Postal addresses are not supported.";
                                             break;
         case ADSTYPE_TIMESTAMP           :  var.vt = VT_UI4;
                                             var.lVal = attrInfo.pADsValues[dw].UTCTime;
                                             break;
         case ADSTYPE_BACKLINK            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Backlink is not supported.";
                                             break;
         case ADSTYPE_TYPEDNAME           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Typed name not supported.";
                                             break;
         case ADSTYPE_HOLD                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Hold not supported.";
                                             break;
         case ADSTYPE_NETADDRESS          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"NetAddress not supported.";
                                             break;
         case ADSTYPE_REPLICAPOINTER      :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Replica pointer not supported.";
                                             break;
         case ADSTYPE_FAXNUMBER           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Faxnumber not supported.";
                                             break;
         case ADSTYPE_EMAIL               :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Email not supported.";
                                             break;
         case ADSTYPE_NT_SECURITY_DESCRIPTOR : wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Security Descriptor not supported.";
                                             break;
*/
         default                          :  wcscat(sKeyName,GET_STRING(DCTVS_SUB_ERROR));
                                             var.vt = VT_BSTR;
                                             var.bstrVal = GET_BSTR(IDS_UNKNOWN_TYPE);
                                             break;
      }
      pVar->put(sKeyName, var);
      if ( attrInfo.dwADsType == ADSTYPE_OCTET_STRING) 
         var.vt = VT_EMPTY;
   }
}

//---------------------------------------------------------------------------
// CopyProperties: This function copies properties, specified in the varset,
//                 by getting the values 
//                 from the source account and the setting the values in
//                 the target account.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::CopyProperties(
                                                BSTR sSourcePath,       //in -Source path to the object
                                                BSTR sSourceDomain,     //in -Source domain name
                                                BSTR sTargetPath,       //in -Target object LDAP path
                                                BSTR sTargetDomain,     //in -Target domain name
                                                IUnknown *pPropSet,     //in -Varset listing all the props to copy
                                                IUnknown *pDBManager,   //in -DB Manager that has a open connection to the DB.
                                                IUnknown* pVarSetDnMap  //in -VarSet containing a mapping of source to target DNs
                                            )
{
   IIManageDBPtr                pDb = pDBManager;
   IVarSetPtr                   spDnMap = pVarSetDnMap;

   ADS_ATTR_INFO              * pAttrInfo = NULL;
   IVarSetPtr                   pVarset = pPropSet;
   HRESULT                      hr = S_OK;
   bool                       * pAllocArray = NULL;
   
  
   // Get properties from the source
   DWORD dwRet = GetProperties(sSourcePath, /*sSourceDomain,*/ pVarset, pAttrInfo);
   
   if ( dwRet > 0 )
   {

      pAllocArray = new bool[dwRet];
      if (!pAllocArray)
      {
          hr = E_OUTOFMEMORY;
      }
      else
      {
          ZeroMemory(pAllocArray, sizeof(bool)*dwRet);
       
          if (!TranslateDNs(pAttrInfo, dwRet, sSourceDomain, sTargetDomain, pDBManager, spDnMap, pAllocArray))
          {
              hr = E_FAIL;
          }
          else
          {
       
              for ( DWORD dwIdx = 0; dwIdx < dwRet; dwIdx++)
              {
                 pAttrInfo[dwIdx].dwControlCode = ADS_ATTR_UPDATE;
        	        //we do not want to copy over the account enable\disable bit since we want this target
        	        //account to remain disabled at this time, so make sure that bit is cleared
        		 if (!_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"userAccountControl"))
        		 {
        			 if (pAttrInfo[dwIdx].dwADsType == ADSTYPE_INTEGER)
        			    pAttrInfo[dwIdx].pADsValues->Integer |= UF_ACCOUNTDISABLE;
        		 }
              }

              // Set the source properties in the target.
              hr = SetProperties(sTargetPath, /*sTargetDomain,*/ pAttrInfo, dwRet);
          }
      }
   }
   else
   {
      hr = dwRet;
   }

   // Need to free those strings allocated by TranslateDNs
   if (pAllocArray)
   {
       if (pAttrInfo)
       {
           for (DWORD i=0; i < dwRet; i++)
           {
              if (pAllocArray[i] == true)
              {
                FreeADsStr(pAttrInfo[i].pADsValues->DNString);
              }
           }
       }
       
       delete [] pAllocArray;   
   }

   
   if ( pAttrInfo )
      FreeADsMem( pAttrInfo );

   
  return hr;
}

//---------------------------------------------------------------------------
// SetProperties: This function sets the properties for a given object from 
//                the attr info array.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::SetProperties(
                                          BSTR sTargetPath,             //in -Target object path.
//                                          BSTR sTargetDomain,           //in - Target domain name
                                          ADS_ATTR_INFO * pAttrInfo,    //in - ADSATTRINFO array with values for props
                                          DWORD dwItems                 //in - number of properties in the array
                                      )
{
   IDirectoryObject           * pDir;
   DWORD                        dwRet=0;
   IVarSetPtr                   pSucc(__uuidof(VarSet));
   IVarSetPtr                   pFail(__uuidof(VarSet));

   // Get the IDirectory Object interface to the Object.
   HRESULT hr = ADsGetObject(sTargetPath, IID_IDirectoryObject, (void**) &pDir);
   if ( FAILED(hr) )
      return hr;

   // Set the Object Attributes.
   hr = pDir->SetObjectAttributes(pAttrInfo, dwItems, &dwRet);
   if ( FAILED(hr) )
   {
      // we are going to try it one at a time and see what causes problems
      for (DWORD dw = 0; dw < dwItems; dw++)
      {
         hr = pDir->SetObjectAttributes(&pAttrInfo[dw], 1, &dwRet);
         _bstr_t x = pAttrInfo[dw].pszAttrName;
         _variant_t var;
         if ( FAILED(hr))
         {
           DWORD dwLastError;
           WCHAR szErrorBuf[LEN_Path];
           WCHAR szNameBuf[LEN_Path];
           //Get extended error value.
           HRESULT hr_return =S_OK;
           hr_return = ADsGetLastError( &dwLastError,
                                          szErrorBuf,
                                          LEN_Path-1,
                                           szNameBuf,
                                          LEN_Path-1);
           //var = szErrorBuf;
           var = hr;
            pFail->put(x, var);
            hr = S_OK;
         }
         else
         {
            pSucc->put(x, var);         
         }
      }
   }
   pDir->Release();
   return hr;
}

//---------------------------------------------------------------------------
// SetPropertiesFromVarset: This function sets values for properties from
//                          the varset. The varset should contain the 
//                          propname (containing the val) and the 
//                          propname.Type ( containing the type of Val) 
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::SetPropertiesFromVarset(
                                                         BSTR sTargetPath,       //in -LDAP path to the target object
//                                                         BSTR sTragetDomain,     //in - Domain name for the Target domain
                                                         IUnknown *pUnk,         //in - Varset to fetch the values from
                                                         DWORD dwControl         //in - Cotnrol code to use for Updating/Deleting etc..
                                                     )
{
   // This function loads up properties and their values from the Varset and sets them for a given user
   IVarSetPtr                   pVar;
   SAFEARRAY                  * keys;
   SAFEARRAY                  * vals;
   long                         lRet;
   VARIANT                      var;
   _variant_t                   varX;
   pVar = pUnk;

   VariantInit(&var);

   ADS_ATTR_INFO  FAR		  * pAttrInfo = new ADS_ATTR_INFO[pVar->GetCount()];
   if (!pAttrInfo)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   HRESULT  hr = pVar->getItems(L"", L"", 0, 10000, &keys, &vals, &lRet);
   if ( FAILED (hr) ) 
   {
      delete [] pAttrInfo;
      return hr;
   }
	
   // Build the Property Name/Value array from the varset.
   for ( long x = 0; x < lRet; x++ )
   {
      // Get the property name
      ::SafeArrayGetElement(keys, &x, &var);
      _bstr_t                keyName = var.bstrVal;
      int                    len = wcslen(keyName);

      pAttrInfo[x].pszAttrName = new WCHAR[len + 2];
	  if (!(pAttrInfo[x].pszAttrName))
	  {
		 for (int z=0; z<x; z++)
			 delete [] pAttrInfo[z].pszAttrName;
         delete [] pAttrInfo;
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }
      wcscpy(pAttrInfo[x].pszAttrName, keyName);
      VariantClear(&var);
      // Get the property value
      ::SafeArrayGetElement(vals, &x, &var);
      keyName = keyName + _bstr_t(L".Type");
      varX = pVar->get(keyName);
      
      if(GetAttrInfo(varX, var, pAttrInfo[x]))
	  {
         pAttrInfo[x].dwControlCode = dwControl;
         pAttrInfo[x].dwNumValues = 1;
	  }
      VariantClear(&var);
   }
   SafeArrayDestroy(keys);
   SafeArrayDestroy(vals);
   // Once we build the array of name and property values then we call the sister function to do the rest
   if ( lRet > 0 ) SetProperties(sTargetPath, /*sTragetDomain,*/ pAttrInfo, lRet);

   // Always cleanup after yourself...

   for ( x = 0; x < lRet; x++ )
   {
      if (pAttrInfo[x].pADsValues)
      {
          switch (pAttrInfo[x].dwADsType)
          {
              case ADSTYPE_DN_STRING:
                if (pAttrInfo[x].pADsValues->DNString)
                    FreeADsStr(pAttrInfo[x].pADsValues->DNString);
                break;
                
              case ADSTYPE_CASE_EXACT_STRING:
                if (pAttrInfo[x].pADsValues->CaseExactString)
                    FreeADsStr(pAttrInfo[x].pADsValues->CaseExactString);
                break;
                
              case ADSTYPE_CASE_IGNORE_STRING:
                if (pAttrInfo[x].pADsValues->CaseIgnoreString)
                    FreeADsStr(pAttrInfo[x].pADsValues->CaseIgnoreString);
                break;
                
              case ADSTYPE_PRINTABLE_STRING:
                if (pAttrInfo[x].pADsValues->PrintableString)
                    FreeADsStr(pAttrInfo[x].pADsValues->PrintableString);
                break;
                
              case ADSTYPE_NUMERIC_STRING:
                if (pAttrInfo[x].pADsValues->NumericString)
                    FreeADsStr(pAttrInfo[x].pADsValues->NumericString);
                break;

              default:
                break;
          }
      }
      
      delete pAttrInfo[x].pADsValues;
	  delete [] pAttrInfo[x].pszAttrName;
   }
   delete [] pAttrInfo;

   return S_OK;
}


//------------------------------------------------------------------------------
// GetAttrInfo: Given a variant this function fills in the ADS_ATTR_INFO struct
//------------------------------------------------------------------------------
bool CObjPropBuilder::GetAttrInfo(
                                    _variant_t varX,           //in - Variant containing the Type of prop
                                    const _variant_t & var,    //in - Variant containing the Prop value
                                    ADS_ATTR_INFO& attrInfo    //out - The filled up attr info structure
                                 )
{
   switch (varX.lVal)
   {
      case ADSTYPE_DN_STRING           :  {
                                             attrInfo.dwADsType = ADSTYPE_DN_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_DN_STRING;
                                             pAd->DNString = AllocADsStr(var.bstrVal);
                                             if (!pAd->DNString && var.bstrVal)
                                             {
                                                delete pAd;
                                                return false;
                                             }
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_CASE_EXACT_STRING   :  {
                                             attrInfo.dwADsType = ADSTYPE_CASE_EXACT_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_CASE_EXACT_STRING;
                                             pAd->CaseExactString  = AllocADsStr(var.bstrVal);
                                             if (!pAd->CaseExactString && var.bstrVal)
                                             {
                                                delete pAd;
                                                return false;
                                             }                                             
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_CASE_IGNORE_STRING  :  {
                                             attrInfo.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_CASE_IGNORE_STRING;
                                             pAd->CaseIgnoreString = AllocADsStr(var.bstrVal);
                                             if (!pAd->CaseIgnoreString && var.bstrVal)
                                             {
                                                delete pAd;
                                                return false;
                                             }                                             
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_PRINTABLE_STRING    :  {
                                             attrInfo.dwADsType = ADSTYPE_PRINTABLE_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_PRINTABLE_STRING;
                                             pAd->PrintableString = AllocADsStr(var.bstrVal);
                                             if (!pAd->PrintableString && var.bstrVal)
                                             {
                                                delete pAd;
                                                return false;
                                             }                                             
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_NUMERIC_STRING      :  {
                                             attrInfo.dwADsType = ADSTYPE_NUMERIC_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_NUMERIC_STRING;
                                             pAd->NumericString = AllocADsStr(var.bstrVal);
                                             if (!pAd->NumericString && var.bstrVal)
                                             {
                                                delete pAd;
                                                return false;
                                             }                                             
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_INTEGER            :   {
                                             attrInfo.dwADsType = ADSTYPE_INTEGER;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_INTEGER;
                                             pAd->Integer = var.lVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      default                          :  {
                                             // Don't support this type then get it out of the way.
                                             return false;
                                             break;
                                          }
   }
   return true;
}

//------------------------------------------------------------------------------
// MapProperties: Using the OID of the properties this function creates a set
//                of properties that are common to both source and target domain.
//------------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::MapProperties(
                                             BSTR sSourceClass,      //in- Source Class name 
                                             BSTR sSourceDomain,     //in- Source domain name
                                             long lSourceVer,        //in- Source domain version
                                             BSTR sTargetClass,      //in - Target class name
                                             BSTR sTargetDomain,     //in - Target domain name
                                             long lTargetVer,        //in - Target Domain version
                                             BOOL bIncNames,         //in - flag telling if varset should include propname
                                             IUnknown **ppUnk        //out - Varset with the mapped properties
                                           )
{
    ATLTRACE(_T("E CObjPropBuilder::MapProperties(sSourceClass='%s', sSourceDomain='%s', lSourceVer=%ld, sTargetClass='%s', sTargetDomain='%s', lTargetVer=%ld, bIncNames=%s, ppUnk=...)\n"), sSourceClass, sSourceDomain, lSourceVer, sTargetClass, sTargetDomain, lTargetVer, bIncNames ? _T("TRUE") : _T("FALSE"));

    IVarSetPtr                pSource(__uuidof(VarSet));
    IVarSetPtr                pTarget(__uuidof(VarSet));
    IVarSetPtr                pMerged = *ppUnk;
    IVarSetPtr                pFailed(__uuidof(VarSet));
    IUnknown                * pUnk;
    SAFEARRAY               * keys;
    SAFEARRAY               * vals;
    long                      lRet;
    VARIANT                   var;
    _variant_t                varTarget;
    _variant_t                varEmpty;
    bool                      bSystemFlag;
    WCHAR                     sPath[LEN_Path];
    WCHAR                     sProgDir[LEN_Path];
    bool                      bUnMapped = false;

    VariantInit(&var);
    GetProgramDirectory(sProgDir);
    wsprintf(sPath, L"%s%s", sProgDir, L"Logs\\PropMap.log");

    err.LogOpen(sPath,0,0);
    // Get the list of props for source and target first
    HRESULT hr = pSource->QueryInterface(IID_IUnknown, (void **)&pUnk);
    GetClassPropEnum(sSourceClass, sSourceDomain, lSourceVer, &pUnk);
    pUnk->Release();
    hr = pTarget->QueryInterface(IID_IUnknown, (void **)&pUnk);
    GetClassPropEnum(sTargetClass, sTargetDomain, lTargetVer, &pUnk);
    pUnk->Release();

    // For every item in source try to find same OID in target. If it exists in both source and target then put it into merged Varset
    hr = pSource->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
    if ( FAILED (hr) ) 
        return hr;
        
    // Build the Property Name/Value array from the varset.
    _bstr_t        val;
    _bstr_t        keyName;
    for ( long x = 0; x < lRet; x++ )
    {
        // Get the property name
        ::SafeArrayGetElement(keys, &x, &var);
        keyName = var.bstrVal;
        VariantClear(&var);

        if ( lSourceVer > 4 )
        {
            // Windows 2000 domain so we map by OID    
            if ((wcsncmp(keyName, L"Man", 3) != 0) && (wcsncmp(keyName, L"Opt", 3) != 0) )
            {
                //
                // Only leaf VarSet nodes which represent a complete OID should be processed.
                //
                // Each component of a key string delimited by the period character becomes
                // a subkey of the previous component.
                //
                // For example given the OID 1.2.840.113556.1.2.102 for the memberOf attribute
                // the VarSet stores each component in a node where only the leaf node contains
                // a value.
                //
                // Key                      Value
                // 1                        VT_EMPTY
                // 1.2                      VT_EMPTY
                // 1.2.840                  VT_EMPTY
                // 1.2.840.113556           VT_EMPTY
                // 1.2.840.113556.1         VT_EMPTY
                // 1.2.840.113556.1.2       VT_EMPTY
                // 1.2.840.113556.1.2.102   "memberOf"
                //
                // The empty nodes in the VarSet do not correspond to valid attributes and
                // therefore must be ignored.
                //

                _variant_t vntValue = pSource->get(keyName);

                if (V_VT(&vntValue) == VT_BSTR)
                {
                    // Only go through the OID keys to get the name of the properties.
                    varTarget = pTarget->get(keyName);
                    if ( varTarget.vt == VT_BSTR )
                    {
                        val = varTarget.bstrVal;

                        //
                        // The member, sAMAccountName and userPrincipalName attributes are set by other
                        // components which depend upon the attribute not being copied by this component.
                        //
                        // The legacyExchangeDN attribute is managed by Exchange and should never be copied.
                        //
                        // TODO: The objectSid attribute is a system only attribute therefore this is redundant.
                        //
                        // The isCriticalSystemObject, pwdLastSet, rid and userPassword attributes probably
                        // cannot be set as the system won't allow it so it is okay not to try and copy them.
                        //
                        // TODO: The c, l, st and userAccountControl attributes were previously considered
                        // 'system' attributes as they are required to be members of the partial set. Therefore
                        // explicitly including them is no longer necessary.
                        //

                        if ((!IsPropSystemOnly(val, sTargetDomain, bSystemFlag) && (wcscmp(val, L"objectSid") != 0) 
                            && (wcscmp(val, L"sAMAccountName") != 0) && (_wcsicmp(val, L"Rid") != 0) 
                            && (wcscmp(val, L"pwdLastSet") != 0) && (wcscmp(val, L"userPassword") != 0) 
                            && (wcscmp(val, L"member") != 0) && (wcscmp(val, L"userPrincipalName") != 0) 
                            && (wcscmp(val, L"isCriticalSystemObject") != 0) && (wcscmp(val, L"legacyExchangeDN") != 0)) 
                            || ( !_wcsicmp(val, L"c") || !_wcsicmp(val, L"l") || !_wcsicmp(val, L"st") 
                            || !_wcsicmp(val, L"userAccountControl") ) )     // These properties are exceptions.
                        {
                            if (bIncNames)
                                pMerged->put(keyName, val);
                            else
                                pMerged->put(val, varEmpty);
                        }
                        else
                            pFailed->put(val, varEmpty);
                    }
                    else if (!bIncNames)
                    {
                        err.MsgWrite(ErrE, DCT_MSG_FAILED_TO_MAP_PROP_SSSSS, (WCHAR*)_bstr_t(vntValue), (WCHAR*) sSourceClass, 
                                                        (WCHAR*) sSourceDomain, (WCHAR*) sTargetClass, (WCHAR*) sTargetDomain);
                        bUnMapped = true;
                    }
                }
            }
        }
        else
        {
            // NT4 code is the one that we map by Names.
            if ( keyName.length() > 0 )
            {
                WCHAR          propName[LEN_Path];
                if (wcsncmp(keyName, L"Man", 3) == 0)
                wcscpy(propName, (WCHAR*) keyName+20);
                else
                wcscpy(propName, (WCHAR*) keyName+19);
          
                varTarget = pSource->get(keyName);
                if ( varTarget.vt == VT_BSTR )
                pMerged->put(propName, varEmpty);
            }
        }
    }
    SafeArrayDestroy(keys);
    SafeArrayDestroy(vals);
    err.LogClose();

    ATLTRACE(_T("L CObjPropBuilder::MapProperties()\n"));

    if (bUnMapped)
        return DCT_MSG_PROPERTIES_NOT_MAPPED;
    else
        return S_OK;
}

//------------------------------------------------------------------------------
// IsPropSystemOnly: This function determines if a specific property is 
//                   System Only or not
//------------------------------------------------------------------------------
bool CObjPropBuilder::IsPropSystemOnly(
                                          const WCHAR * sName,       //in- Name of the property
                                          const WCHAR * sDomain,     //in- Domain name where we need to check  
                                          bool& bSystemFlag,         //out- Tells us if it failed due to system flag.
                                          bool* pbBaseObject         //out- whether attribute is part of the base schema
                                      )
{
    // we will lookup the property name in target domain schema and see if it is system only or not.
    // First build an LDAP path to the Schema container.
    HRESULT                   hr = S_OK;
    WCHAR                     sQuery[LEN_Path];
    LPWSTR                    sCols[] = { L"systemOnly", L"systemFlags" };                   
    ADS_SEARCH_HANDLE         hSearch;
    ADS_SEARCH_COLUMN         col;

    bool                      bSystemOnly = true;

    if (pbBaseObject)
    {
        *pbBaseObject = false;
    }

    if (m_strSchemaDomain != _bstr_t(sDomain))
    {
        m_strSchemaDomain = sDomain;
        m_spSchemaSearch.Release();

        //
        // Retrieve schema naming context and bind to IDirectorySearch
        // interface of schema container in domain. Note that three
        // attempts are made to bind to RootDSE and the schema container.
        //

        IADsPtr spRootDse;
        _bstr_t strSchemaNamingContext;

        int nTry = 0;

        do
        {
            if (FAILED(hr))
            {
                Sleep(5000);
            }

            hr = ADsGetObject(L"LDAP://" + m_strSchemaDomain + L"/rootDSE", IID_IADs, (void**)&spRootDse);

            if (SUCCEEDED(hr))
            {
                VARIANT var;
                VariantInit(&var);

                hr = spRootDse->Get(L"schemaNamingContext", &var);

                if (SUCCEEDED(hr))
                {
                    strSchemaNamingContext = _variant_t(var, false);
                }
            }
        }
        while (FAILED(hr) && (++nTry < 3));

        if (SUCCEEDED(hr))
        {
            nTry = 0;

            do
            {
                if (FAILED(hr))
                {
                    Sleep(5000);
                }

                hr = ADsGetObject(
                    L"LDAP://" + m_strSchemaDomain + L"/" + strSchemaNamingContext,
                    IID_IDirectorySearch,
                    (void**)&m_spSchemaSearch
                );
            }
            while (FAILED(hr) && (++nTry < 3));
        }

        if (FAILED(hr))
        {
            err.SysMsgWrite(ErrW, hr, DCT_MSG_IS_SYSTEM_PROPERTY_CANNOT_BIND_TO_SCHEMA_S, sDomain);
        }
    }

    if (SUCCEEDED(hr) && m_spSchemaSearch)
    {
        // Build the query string
        wsprintf(sQuery, L"(lDAPDisplayName=%s)", sName);
        // Now search for this property
        hr = m_spSchemaSearch->ExecuteSearch(sQuery, sCols, 2, &hSearch);

        if ( SUCCEEDED(hr) )
        {// Get the systemOnly flag and return its value.
            hr = m_spSchemaSearch->GetFirstRow(hSearch);
            if (hr == S_OK)
            {
                hr = m_spSchemaSearch->GetColumn( hSearch, sCols[0], &col );
                if ( SUCCEEDED(hr) )
                {
                    bSystemOnly = ( col.pADsValues->Boolean == TRUE);
                    m_spSchemaSearch->FreeColumn( &col );
                }
                else if (hr == E_ADS_COLUMN_NOT_SET)
                {
                    //
                    // If systemOnly attribute is not defined for this attribute
                    // then the attribute cannot be a 'system only' attribute.
                    //

                    bSystemOnly = false;

                    hr = S_OK;
                }
                // Check the system flags 
                hr = m_spSchemaSearch->GetColumn( hSearch, sCols[1], &col );
                if ( SUCCEEDED(hr) )
                {
                    //
                    // If the attribute is a base schema object then check the system flags. If
                    // the attribute is not a base schema object it cannot be a system attribute
                    // and therefore may be copied.
                    //

                    if (col.pADsValues->Integer & ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT)
                    {
                        //
                        // If the attribute is an operational attribute, is a constructed attribute
                        // or the attribute is not replicated then the attribute should not be copied.
                        //
                        // The nTSecurityDescriptor attribute is an example of an operational attribute
                        // that should not be copied. The canonicalName attribute is an example of a
                        // constructed attribute that cannot be copied. The distinguishedName attribute
                        // is an example of a not replicated attribute that cannot be copied.
                        //

                        const ADS_INTEGER SYSTEM_FLAGS =
                            ADS_SYSTEMFLAG_ATTR_IS_OPERATIONAL|ADS_SYSTEMFLAG_ATTR_IS_CONSTRUCTED|ADS_SYSTEMFLAG_ATTR_REQ_PARTIAL_SET_MEMBER|ADS_SYSTEMFLAG_ATTR_NOT_REPLICATED;

                        bSystemFlag = (col.pADsValues->Integer & SYSTEM_FLAGS) != 0;
                        bSystemOnly = bSystemOnly || bSystemFlag;

                        if (pbBaseObject)
                        {
                            *pbBaseObject = true;
                        }
                    }

                    m_spSchemaSearch->FreeColumn(&col);
                }
                else if (hr == E_ADS_COLUMN_NOT_SET)
                {
                    //
                    // If systemFlags attribute is not defined for this attribute
                    // then return fact that systemFlags attribute cannot be reason
                    // attribute was marked as 'system only' if it is.
                    //

                    bSystemFlag = false;

                    hr = S_OK;
                }
            }
            else if (hr == S_ADS_NOMORE_ROWS)
            {
                //
                // If neither the systemOnly or systemFlags attribute is defined for
                // this attribute then the attribute cannot be a 'system only' attribute.
                //

                bSystemOnly = false;

                hr = S_OK;
            }
            m_spSchemaSearch->CloseSearchHandle(hSearch);
        }

        if (FAILED(hr))
        {
            err.SysMsgWrite(ErrW, hr, DCT_MSG_IS_SYSTEM_PROPERTY_CANNOT_VERIFY_SYSTEM_ONLY_SS, sName, sDomain);
        }
    }

    return bSystemOnly;
}


//------------------------------------------------------------------------------
// TranslateDNs: This function Translates object properties that are
//               distinguished names to point to same object in target domain
//               as the object in the source domain.
//------------------------------------------------------------------------------
BOOL CObjPropBuilder::TranslateDNs(
                                    ADS_ATTR_INFO *pAttrInfo,        //in -Array
                                    DWORD dwRet, BSTR sSource,
                                    BSTR sTarget,
                                    IUnknown *pCheckList,          //in -Object that will check the list if an account Exists
                                    IVarSet* pDnMap,
                                    bool *pAllocArray
                                  )
{
    HRESULT hr;

    IIManageDBPtr spDatabase = pCheckList;

    //
    // Initialize source pathname object. If able to retrieve name of global catalog
    // server in the source forest then initialize pathname to global catalog otherwise
    // initialize pathname to source domain.
    //

    _bstr_t strSourceGC;
    _bstr_t strTargetGC;

    GetGlobalCatalogServer5(sSource, strSourceGC);
    GetGlobalCatalogServer5(sTarget, strTargetGC);

    CADsPathName pnSourcePath;

    if ((PCWSTR)strSourceGC)
    {
        pnSourcePath.Set(L"GC", ADS_SETTYPE_PROVIDER);
        pnSourcePath.Set(strSourceGC, ADS_SETTYPE_SERVER);
    }
    else
    {
        pnSourcePath.Set(L"LDAP", ADS_SETTYPE_PROVIDER);
        pnSourcePath.Set(sSource, ADS_SETTYPE_SERVER);
    }

    //
    // For each ADSTYPE_DN_STRING attribute...
    //

    for (DWORD iAttribute = 0; iAttribute < dwRet; iAttribute++)
    {
        if (pAttrInfo[iAttribute].dwADsType != ADSTYPE_DN_STRING)
        {
            continue;
        }

        //
        // For each value in attribute...
        //

        DWORD cValue = pAttrInfo[iAttribute].dwNumValues;

        for (DWORD iValue = 0; iValue < cValue; iValue++)
        {
            ADSVALUE& value = pAttrInfo[iAttribute].pADsValues[iValue];

            //
            // If the object is currently being migrated then the source
            // and target distinguished names will be in the distinguished
            // name map. As this will be the most current information and
            // the least expensive to query the map is queried first before
            // querying the database.
            //

            _bstr_t strTargetDn = pDnMap->get(_bstr_t(value.DNString));

            if (strTargetDn.length() > 0)
            {
                LPWSTR pszName = AllocADsStr(strTargetDn);

                if (pszName)
                {
                    value.DNString = pszName;
                    pAllocArray[iAttribute] = true;
                }

                continue;
            }

            //
            // If the object has previously been migrated then a record that maps the source object
            // to the target object will exist in the migrated objects table. The SID of the source
            // object is used to query for the source object in the table as this uniquely identifies
            // the object.
            //

            IDirectoryObjectPtr spSourceObject;
            _variant_t vntSid;

            pnSourcePath.Set(value.DNString, ADS_SETTYPE_DN);

            hr = ADsGetObject(pnSourcePath.Retrieve(ADS_FORMAT_X500), IID_IDirectoryObject, (VOID**)&spSourceObject);      

            if (SUCCEEDED(hr))
            {
                LPWSTR pszNames[] = { L"objectSid" };
                PADS_ATTR_INFO pAttrInfo = NULL;
                DWORD cAttrInfo = 0;

                hr = spSourceObject->GetObjectAttributes(pszNames, 1, &pAttrInfo, &cAttrInfo);

                if (SUCCEEDED(hr))
                {
                    if (pAttrInfo && (_wcsicmp(pAttrInfo->pszAttrName, pszNames[0]) == 0))
                    {
                        if (pAttrInfo->dwADsType == ADSTYPE_OCTET_STRING)
                        {
                            ADS_OCTET_STRING& os = pAttrInfo->pADsValues->OctetString;

                            SAFEARRAY* psa = SafeArrayCreateVector(VT_UI1, 0, os.dwLength);

                            if (psa)
                            {
                                memcpy(psa->pvData, os.lpValue, os.dwLength);

                                V_VT(&vntSid) = VT_ARRAY|VT_UI1;
                                V_ARRAY(&vntSid) = psa;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }

                    FreeADsMem(pAttrInfo);
                }
            }

            if (FAILED(hr))
            {
                continue;
            }

            _bstr_t strSid;
            _bstr_t strRid;

            if (!GetSidAndRidFromVariant(vntSid, strSid, strRid))
            {
                continue;
            }

            IVarSetPtr spVarSet(__uuidof(VarSet));
            IUnknownPtr spUnknown(spVarSet);
            IUnknown* punk = spUnknown;

            hr = spDatabase->raw_GetAMigratedObjectBySidAndRid(strSid, strRid, &punk);

            //
            // If the object was found in the database
            // the result will be S_OK otherwise S_FALSE.
            //

            if (hr != S_OK)
            {
                continue;
            }

            //
            // Bind to the target object using the GUID property.
            //

            _bstr_t strGuid = spVarSet->get(_bstr_t(L"MigratedObjects.GUID"));

            if ((PCWSTR)strGuid)
            {
                tstring strGuidPath;

                if ((PCWSTR)strTargetGC)
                {
                    strGuidPath = _T("GC://");
                    strGuidPath += strTargetGC;
                }
                else
                {
                    strGuidPath = _T("LDAP://");
                    strGuidPath += sTarget;
                }

                strGuidPath += _T("/<GUID=");
                strGuidPath += strGuid;
                strGuidPath += _T(">");

                IADsPtr spTargetObject;

                hr = ADsGetObject(strGuidPath.c_str(), IID_IADs, (VOID**)&spTargetObject);

                if (SUCCEEDED(hr))
                {
                    //
                    // Retrieve distinguished name and update DN
                    // attribute value.
                    //

                    VARIANT varName;
                    VariantInit(&varName);

                    hr = spTargetObject->Get(_bstr_t(L"distinguishedName"), &varName);

                    if (SUCCEEDED(hr))
                    {
                        LPWSTR pszName = AllocADsStr(V_BSTR(&varName));

                        if (pszName)
                        {
                            value.DNString = pszName;
                            pAllocArray[iAttribute] = true;
                        }

                        VariantClear(&varName);
                    }
                }
            }
        }
    }

    return TRUE;
}


STDMETHODIMP CObjPropBuilder::ChangeGroupType(BSTR sGroupPath, long lGroupType)
{
   HRESULT                   hr;
   IADsGroup               * pGroup;
   _variant_t                var;
   long                      lType;
   
   // Get the group type info from the object.
   hr = ADsGetObject( sGroupPath, IID_IADsGroup, (void**) &pGroup);
   if (FAILED(hr)) return hr;

   hr = pGroup->Get(L"groupType", &var);
   if (FAILED(hr)) return hr;

   // Check if Security group or Distribution group and then set the type accordingly.
   lType = var.lVal;

   if (lType & 0x80000000 )
      lType = lGroupType | 0x80000000;
   else
      lType = lGroupType;

   // Set the value into the Group Information
   var = lType;
   hr = pGroup->Put(L"groupType", var);   
   if (FAILED(hr)) return hr;

   hr = pGroup->SetInfo();
   if (FAILED(hr)) return hr;

   pGroup->Release();
   return S_OK;
}


//------------------------------------------------------------------------------------------------------------------------------
// CopyNT4Props : Uses Net APIs to get info from the source account and then set it to the target account.
//------------------------------------------------------------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::CopyNT4Props(BSTR sSourceSam, BSTR sTargetSam, BSTR sSourceServer, BSTR sTargetServer, BSTR sType, long lGrpType, BSTR sExclude)
{
	DWORD dwError = ERROR_SUCCESS;

	#define ISEXCLUDE(a) IsStringInDelimitedString(sExclude, L#a, L',')

	if (_wcsicmp(sType, L"user") == 0)
	{
		//
		// user
		//

		USER_INFO_3 ui;

		PUSER_INFO_3 puiSource = NULL;
		PUSER_INFO_3 puiTarget = NULL;

		dwError = NetUserGetInfo(sSourceServer, sSourceSam, 3, (LPBYTE*)&puiSource);

		if (dwError == ERROR_SUCCESS)
		{
			dwError = NetUserGetInfo(sTargetServer, sTargetSam, 3, (LPBYTE*)&puiTarget);

			if (dwError == ERROR_SUCCESS)
			{
				// note that attributes with the comment ignored are ignored by NetUserSetInfo
				// setting to target value just so that they have a valid value

				ui.usri3_name = puiTarget->usri3_name; // ignored
				ui.usri3_password = NULL; // must not set during copy properties
				ui.usri3_password_age = puiTarget->usri3_password_age; // ignored
				ui.usri3_priv = puiTarget->usri3_priv; // ignored
				ui.usri3_home_dir = ISEXCLUDE(homeDirectory) ? puiTarget->usri3_home_dir : puiSource->usri3_home_dir;
				ui.usri3_comment = ISEXCLUDE(description) ? puiTarget->usri3_comment : puiSource->usri3_comment;

				ui.usri3_flags = puiSource->usri3_flags;
				// translate a local account to a domain account
				ui.usri3_flags &= ~UF_TEMP_DUPLICATE_ACCOUNT;
				// disable the account in case no password has been set
				ui.usri3_flags |= UF_ACCOUNTDISABLE;

				ui.usri3_script_path = ISEXCLUDE(scriptPath) ? puiTarget->usri3_script_path : puiSource->usri3_script_path;
				ui.usri3_auth_flags = puiTarget->usri3_auth_flags; // ignored
				ui.usri3_full_name = ISEXCLUDE(displayName) ? puiTarget->usri3_full_name : puiSource->usri3_full_name;
				ui.usri3_usr_comment = ISEXCLUDE(comment) ? puiTarget->usri3_usr_comment : puiSource->usri3_usr_comment;
				ui.usri3_parms = ISEXCLUDE(userParameters) ? puiTarget->usri3_parms : puiSource->usri3_parms;
				ui.usri3_workstations = ISEXCLUDE(userWorkstations) ? puiTarget->usri3_workstations : puiSource->usri3_workstations;
				ui.usri3_last_logon = puiTarget->usri3_last_logon; // ignored
				ui.usri3_last_logoff = ISEXCLUDE(lastLogoff) ? puiTarget->usri3_last_logoff : puiSource->usri3_last_logoff;
				ui.usri3_acct_expires = ISEXCLUDE(accountExpires) ? puiTarget->usri3_acct_expires : puiSource->usri3_acct_expires;
				ui.usri3_max_storage = ISEXCLUDE(maxStorage) ? puiTarget->usri3_max_storage : puiSource->usri3_max_storage;
				ui.usri3_units_per_week = puiTarget->usri3_units_per_week; // ignored
				ui.usri3_logon_hours = ISEXCLUDE(logonHours) ? puiTarget->usri3_logon_hours : puiSource->usri3_logon_hours;
				ui.usri3_bad_pw_count = puiTarget->usri3_bad_pw_count; // ignored
				ui.usri3_num_logons = puiTarget->usri3_num_logons; // ignored
				ui.usri3_logon_server = puiTarget->usri3_logon_server; // ignored
				ui.usri3_country_code = ISEXCLUDE(countryCode) ? puiTarget->usri3_country_code : puiSource->usri3_country_code;
				ui.usri3_code_page = ISEXCLUDE(codePage) ? puiTarget->usri3_code_page : puiSource->usri3_code_page;
				ui.usri3_user_id = puiTarget->usri3_user_id; // ignored
				// if not excluded set the primary group to the Domain Users group
				ui.usri3_primary_group_id = ISEXCLUDE(primaryGroupID) ? puiTarget->usri3_primary_group_id : DOMAIN_GROUP_RID_USERS;
				ui.usri3_profile = ISEXCLUDE(profilePath) ? puiTarget->usri3_profile : puiSource->usri3_profile;
				ui.usri3_home_dir_drive = ISEXCLUDE(homeDrive) ? puiTarget->usri3_home_dir_drive : puiSource->usri3_home_dir_drive;
				ui.usri3_password_expired = puiTarget->usri3_password_expired;

				dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);

				if (dwError == NERR_UserNotInGroup)
				{
					// if the setInfo failed because of the primary group property, try again, using the primary group 
					// that is already defined for the target account
					ui.usri3_primary_group_id = puiTarget->usri3_primary_group_id;

					dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);
				}
			}

			if (puiTarget)
			{
				NetApiBufferFree(puiTarget);
			}

			if (puiSource)
			{
				NetApiBufferFree(puiSource);
			}
		}
	}
	else if (_wcsicmp(sType, L"group") == 0)
	{
		// if description attribute is not excluded then copy comment attribute
		// note that the only downlevel group attribute that will be copied is the description (comment) attribute

		if (ISEXCLUDE(description) == FALSE)
		{
			if (lGrpType & 4)
			{
				//
				// local group
				//

				PLOCALGROUP_INFO_1 plgi = NULL;

				dwError = NetLocalGroupGetInfo(sSourceServer, sSourceSam, 1, (LPBYTE*)&plgi);

				if (dwError == ERROR_SUCCESS)
				{
					dwError = NetLocalGroupSetInfo(sTargetServer, sTargetSam, 1, (LPBYTE)plgi, NULL);

					NetApiBufferFree(plgi);
				}
			}
			else
			{
				//
				// global group
				//

				PGROUP_INFO_1 pgi = NULL;

				dwError = NetGroupGetInfo(sSourceServer, sSourceSam, 1, (LPBYTE*)&pgi);

				if (dwError == ERROR_SUCCESS)
				{
					dwError = NetGroupSetInfo(sTargetServer, sTargetSam, 1, (LPBYTE)pgi, NULL);

					NetApiBufferFree(pgi);
				}
			}
		}
	}
	else if (_wcsicmp(sType, L"computer") == 0)
	{
		//
		// computer
		//

		USER_INFO_3 ui;

		PUSER_INFO_3 puiSource = NULL;
		PUSER_INFO_3 puiTarget = NULL;

		dwError = NetUserGetInfo(sSourceServer, sSourceSam, 3, (LPBYTE*)&puiSource);

		if (dwError == ERROR_SUCCESS)
		{
			dwError = NetUserGetInfo(sTargetServer, sTargetSam, 3, (LPBYTE*)&puiTarget);

			if (dwError == ERROR_SUCCESS)
			{
				// note that attributes with the comment ignored are ignored by NetUserSetInfo
				// setting to target value just so that they have a valid value

				ui.usri3_name = puiTarget->usri3_name; // ignored
				ui.usri3_password = NULL; // must not set during copy properties
				ui.usri3_password_age = puiTarget->usri3_password_age; // ignored
				ui.usri3_priv = puiTarget->usri3_priv; // ignored
				ui.usri3_home_dir = puiTarget->usri3_home_dir;
				ui.usri3_comment = ISEXCLUDE(description) ? puiTarget->usri3_comment : puiSource->usri3_comment;

				ui.usri3_flags = puiSource->usri3_flags;
				// translate a local account to a domain account
				ui.usri3_flags &= ~UF_TEMP_DUPLICATE_ACCOUNT;
				// disable the account in case no password has been set
				//ui.usri3_flags |= UF_ACCOUNTDISABLE;

				ui.usri3_script_path = puiTarget->usri3_script_path;
				ui.usri3_auth_flags = puiTarget->usri3_auth_flags; // ignored
				ui.usri3_full_name = ISEXCLUDE(displayName) ? puiTarget->usri3_full_name : puiSource->usri3_full_name;
				ui.usri3_usr_comment = ISEXCLUDE(comment) ? puiTarget->usri3_usr_comment : puiSource->usri3_usr_comment;
				ui.usri3_parms = puiTarget->usri3_parms;
				ui.usri3_workstations = puiTarget->usri3_workstations;
				ui.usri3_last_logon = puiTarget->usri3_last_logon; // ignored
				ui.usri3_last_logoff = puiTarget->usri3_last_logoff;
				ui.usri3_acct_expires = puiTarget->usri3_acct_expires;
				ui.usri3_max_storage = puiTarget->usri3_max_storage;
				ui.usri3_units_per_week = puiTarget->usri3_units_per_week; // ignored
				ui.usri3_logon_hours = puiTarget->usri3_logon_hours;
				ui.usri3_bad_pw_count = puiTarget->usri3_bad_pw_count; // ignored
				ui.usri3_num_logons = puiTarget->usri3_num_logons; // ignored
				ui.usri3_logon_server = puiTarget->usri3_logon_server; // ignored
				ui.usri3_country_code = puiTarget->usri3_country_code;
				ui.usri3_code_page = puiTarget->usri3_code_page;
				ui.usri3_user_id = puiTarget->usri3_user_id; // ignored
				ui.usri3_primary_group_id = puiTarget->usri3_primary_group_id;
				ui.usri3_profile = puiTarget->usri3_profile;
				ui.usri3_home_dir_drive = puiTarget->usri3_home_dir_drive;
				ui.usri3_password_expired = puiTarget->usri3_password_expired;

				dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);
			}

			if (puiTarget)
			{
				NetApiBufferFree(puiTarget);
			}

			if (puiSource)
			{
				NetApiBufferFree(puiSource);
			}
		}
	}
	else
	{
		_ASSERT(FALSE);
	}

	return HRESULT_FROM_WIN32(dwError);
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for copying all properties, from *
 * an incoming varset of properties, into a new varset but excluding *
 * those properties listed in a given exclusion list.  The exclusion *
 * list is a comma-seperated string of property names.               *
 *                                                                   *
 *********************************************************************/

//BEGIN ExcludeProperties
STDMETHODIMP CObjPropBuilder::ExcludeProperties(
                                             BSTR sExclusionList,    //in- list of props to exclude 
                                             IUnknown *pPropSet,     //in -Varset listing all the props to copy
                                             IUnknown **ppUnk        //out - Varset with all the props except those excluded
                                           )
{
/* local variables */
   IVarSetPtr                pVarsetNew = *ppUnk;
   IVarSetPtr                pVarset = pPropSet;
   SAFEARRAY               * keys;
   SAFEARRAY               * vals;
   long                      lRet;
   VARIANT                   var;
   _variant_t                varEmpty;
   BOOL						 bFound = FALSE;
   HRESULT					 hr;

/* function body */
   VariantInit(&var);

      //retrieve all item in the incoming varset
   hr = pVarset->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
   if ( FAILED (hr) ) 
      return hr;
	
      //get each property name and if it is not in the exclusion list
      //place it in the new varset
   _bstr_t        keyName;

   for ( long x = 0; x < lRet; x++ )
   {
         //get the property name
      ::SafeArrayGetElement(keys, &x, &var);
      keyName = var.bstrVal;
      VariantClear(&var);

	     //see if this name is in the exclusion list
      bFound = IsStringInDelimitedString((WCHAR*)sExclusionList, 
										 (WCHAR*)keyName,
										 L',');

	     //if the property was not found in the exclusion list, place it
		 //in the new varset
	  if (!bFound)
         pVarsetNew->put(keyName, varEmpty);
  }//end for each property

   SafeArrayDestroy(keys);
   SafeArrayDestroy(vals);
   return S_OK;
}
//END ExcludeProperties


//-----------------------------------------------------------------------------
// GetNonBaseProperties
//
// Synopsis
// Retrieves list of properties for object classes that ADMT migrates and that
// are not marked as being part of the base schema.
//
// Arguments
// IN  bstrDomainName    - the name of the domain to query
// OUT pbstrPropertyList - a comma separated list of attributes that are not
//                         base schema attributes
//
// Return Value
// Standard HRESULT return codes.
//-----------------------------------------------------------------------------

STDMETHODIMP CObjPropBuilder::GetNonBaseProperties(BSTR bstrDomainName, BSTR* pbstrPropertyList)
{
    typedef std::set<tstring> StringSet;

    static PCTSTR s_pszClasses[] = { _T("user"), _T("inetOrgPerson"), _T("group"), _T("computer") };

    HRESULT hr = S_OK;

    try
    {
        //
        // Retrieve all mandatory and optional properties for all object classes that ADMT migrates.
        //

        StringSet setProperties;

        for (size_t iClass = 0; iClass < countof(s_pszClasses); iClass++)
        {
            IVarSetPtr spVarSet(__uuidof(VarSet));
            IUnknownPtr spunk(spVarSet);
            IUnknown* punk = spunk;

            HRESULT hrEnum = GetClassPropEnum(_bstr_t(s_pszClasses[iClass]), bstrDomainName, 5L, &punk);

            if (SUCCEEDED(hrEnum))
            {
                IEnumVARIANTPtr spEnum = spVarSet->_NewEnum;

                if (spEnum)
                {
                    VARIANT varKey;
                    VariantInit(&varKey);

                    while (spEnum->Next(1UL, &varKey, NULL) == S_OK)
                    {
                        //
                        // The returned VarSet contains two sets of attribute mapping. The first set of values maps
                        // OIDs to lDAPDisplayNames. The second set of values maps lDAPDisplayNames prefixed with
                        // either MandatoryProperties or OptionalProperties to OIDs. Therefore don't include
                        // the second set of values.
                        //

                        if (V_BSTR(&varKey) && (wcsncmp(V_BSTR(&varKey), L"Man", 3) != 0) && (wcsncmp(V_BSTR(&varKey), L"Opt", 3) != 0))
                        {
                            //
                            // If lDAPDisplayName value defined then add to set of properties.
                            //
                            // The VarSet generates a series of hierarchical values based on the period character
                            // as follows. Therefore only the leaf entries actually contain lDAPDisplayName
                            // values.
                            //
                            // 2002-10-21 18:05:52  [0] <Empty>
                            // 2002-10-21 18:05:52  [0.9] <Empty>
                            // 2002-10-21 18:05:52  [0.9.2342] <Empty>
                            // 2002-10-21 18:05:52  [0.9.2342.19200300] <Empty>
                            // 2002-10-21 18:05:52  [0.9.2342.19200300.100] <Empty>
                            // 2002-10-21 18:05:52  [0.9.2342.19200300.100.1] <Empty>
                            // 2002-10-21 18:05:52  [0.9.2342.19200300.100.1.1] uid
                            //

                            _variant_t vntValue = spVarSet->get(V_BSTR(&varKey));

                            if (V_VT(&vntValue) == VT_BSTR)
                            {
                                setProperties.insert(tstring(V_BSTR(&vntValue)));
                            }
                        }

                        VariantClear(&varKey);
                    }
                }
            }
        }

        //
        // Generate a comma separated list of lDAPDisplayNames of
        // attributes that are not base schema attributes.
        //

        tstring strAttributes;

        for (StringSet::const_iterator it = setProperties.begin(); it != setProperties.end(); ++it)
        {
            const tstring& strProperty = *it;

            if (strProperty.empty() == false)
            {
                bool bSystemFlag;
                bool bBaseObject = false;

                IsPropSystemOnly(strProperty.c_str(), bstrDomainName, bSystemFlag, &bBaseObject);

                if (bBaseObject == false)
                {
                    if (!strAttributes.empty())
                    {
                        strAttributes += _T(",");
                    }

                    strAttributes += strProperty;
                }
            }
        }

        *pbstrPropertyList = _bstr_t(strAttributes.c_str()).copy();
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }

    return hr;
}


//------------------------------------------------------------------------------
// GetSidAndRidFromVariant Function
//
// Synopsis
// Retrieves the domain SID and object RID as strings.
//
// Arguments
// IN  varSid - SID as an array of bytes (this is the form received from ADSI)
// OUT strSid - domain SID as a string
// OUT strRid - object RID as a string
//
// Return
// True if successful otherwise false.
//------------------------------------------------------------------------------

bool __stdcall CObjPropBuilder::GetSidAndRidFromVariant(const VARIANT& varSid, _bstr_t& strSid, _bstr_t& strRid)
{
    bool bGet = false;

    if ((V_VT(&varSid) == (VT_ARRAY|VT_UI1)) && varSid.parray)
    {
        PSID pSid = SafeCopySid((PSID)varSid.parray->pvData);

        if (pSid)
        {
            PUCHAR puchCount = GetSidSubAuthorityCount(pSid);

            DWORD dwCount = static_cast<DWORD>(*puchCount);
            PDWORD pdwRid = GetSidSubAuthority(pSid, dwCount - 1);
            DWORD dwRid = *pdwRid;

            --(*puchCount);

            LPTSTR pszSid = NULL;

            if (ConvertSidToStringSid(pSid, &pszSid))
            {
                strSid = pszSid;
                strRid = _variant_t(long(dwRid));

                LocalFree(pszSid);

                if ((PCWSTR)strSid && (PCWSTR)strRid)
                {
                    bGet = true;
                }
            }

            FreeSid(pSid);
        }
    }

    return bGet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\objprop.h ===
/*---------------------------------------------------------------------------
  File: ObjPropBuilder.h

  Comments: Declaration of CObjPropBuilder

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#ifndef __OBJPROPBUILDER_H_
#define __OBJPROPBUILDER_H_

#include "resource.h"       // main symbols
//#import "\bin\mcsvarsetmin.tlb" no_namespace 
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

/////////////////////////////////////////////////////////////////////////////
// CObjPropBuilder
class ATL_NO_VTABLE CObjPropBuilder : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CObjPropBuilder, &CLSID_ObjPropBuilder>,
	public IObjPropBuilder
{
public:
	CObjPropBuilder()
	{
      m_lVer = -1;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_OBJPROPBUILDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CObjPropBuilder)
	COM_INTERFACE_ENTRY(IObjPropBuilder)
END_COM_MAP()

// IObjPropBuilder
public:
    STDMETHOD(CopyNT4Props)(/*[in]*/ BSTR sSourceSam, /*[in]*/ BSTR sTargetSam, /*[in]*/ BSTR sSourceServer, /*[in]*/ BSTR sTargetServer, /*[in]*/ BSTR sType, long lGrpType, BSTR sExclude);
    STDMETHOD(ChangeGroupType)(/*[in]*/ BSTR sGroupPath, /*[in]*/ long lGroupType);
    STDMETHOD(MapProperties)(/*[in]*/ BSTR sSourceClass, /*[in]*/ BSTR sSourceDomain, long lSourceVer, /*[in]*/ BSTR sTargetClass, /*[in]*/ BSTR sTargetDomain, long lTargetVer, /*[in]*/ BOOL bIncName, /*[out]*/ IUnknown ** pUnk);
    STDMETHOD(SetPropertiesFromVarset)(/*[in]*/ BSTR sTargetPath, /*BSTR sTragetDomain,*/ IUnknown * pUnk, DWORD dwControl = ADS_ATTR_UPDATE);
    DWORD GetProperties(BSTR sObjPath, /*BSTR sDomainName, */IVarSet * pVar, ADS_ATTR_INFO*& pAttrInfo);
    STDMETHOD(CopyProperties)(/*[in]*/ BSTR sSourcePath, /*[in]*/ BSTR sSourceDomain, /*[in]*/ BSTR sTargetPath, /*[in]*/ BSTR sTargetDomain, /*[in]*/ IUnknown *pPropSet, /*[in]*/ IUnknown *pDBManager, IUnknown* pVarSetDnMap);
    STDMETHOD(GetObjectProperty)(/*[in]*/ BSTR sobjSubPath, /*[in]*/ /*BSTR sDomainName,*/ /*[in, out]*/ IUnknown ** ppVarset);
    STDMETHOD(GetClassPropEnum)(/*[in]*/ BSTR sClassName, /*[in]*/ BSTR sDomainName, long lVer, /*[out, retval]*/ IUnknown ** ppVarset);
    HRESULT SetProperties(BSTR sTargetPath, /*BSTR sTargetDomain,*/ ADS_ATTR_INFO* pAttrInfo, DWORD dwItems);
    STDMETHOD(ExcludeProperties)(/*[in]*/ BSTR sExclusionList, /*[in]*/ IUnknown *pPropSet, /*[out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetNonBaseProperties)(/*[in]*/ BSTR bstrDomainName, /*[out, retval]*/ BSTR* pbstrPropertyList);
private:
    BOOL TranslateDNs(ADS_ATTR_INFO* pAttrInfo, DWORD dwRet, BSTR sSource, BSTR sTarget, IUnknown *pCheckList, IVarSet* pDnMap, bool *pAllocArray);
    HRESULT CObjPropBuilder::GetClassProperties( IADsClass * pClass, IUnknown *& pVarSet );
    HRESULT FillupVarsetFromVariant(IADsClass * pClass, VARIANT * pVar, BSTR sPropType, IUnknown *& pVarSet);
    HRESULT FillupVarsetWithProperty(BSTR sPropName, BSTR sPropType, IUnknown *& pVarSet);
    HRESULT FillupVarsetFromVariantArray(IADsClass * pClass, SAFEARRAY * pArray, BSTR sPropType, IUnknown *& pVarSet);
    void SetValuesInVarset(ADS_ATTR_INFO attrInfo, IVarSetPtr pVar);
    bool GetAttrInfo(_variant_t varX, const _variant_t & var, ADS_ATTR_INFO& attrInfo);
    bool IsPropSystemOnly(const WCHAR * sName, const WCHAR * sDomain, bool& bSystemFlag, bool* pbBaseObject = NULL);
    BOOL GetProgramDirectory(WCHAR * filename);
    static bool __stdcall GetSidAndRidFromVariant(const VARIANT& varSid, _bstr_t& strSid, _bstr_t& strRid);

    WCHAR m_sDomainName[255];
    WCHAR m_sNamingConvention[255];
    // cached schema search interface for IsPropSystemOnly()
    _bstr_t m_strSchemaDomain;
    CComPtr<IDirectorySearch> m_spSchemaSearch;
    //
    long m_lVer;
};

#endif //__OBJPROPBUILDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\agtsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DCTAgSvc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\agtsvc\agentrpc.cpp ===
/*---------------------------------------------------------------------------
  File: AgentRpc.cpp

  Comments:  RPC interface for DCT Agent service   

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 11:39:58

 ---------------------------------------------------------------------------
*/


#include <windows.h>
#include <objbase.h>

#include "AgSvc.h"

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "TEvent.hpp"
#include "EaLen.hpp"
#include "Cipher.hpp"
#include "IsAdmin.hpp"
#include "ResStr.h"
#include "TSync.hpp"

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\MCSEADCTAgent.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "Engine.tlb" no_namespace, named_guids

#include "TNode.hpp"

#ifdef OFA
#include "atlbase.h"
#endif

extern LPSTREAM              pStream;
extern TCriticalSection      gStreamCS;
extern TErrorEventLog        err;
extern BOOL                  gSuicide;
extern BOOL                  gDebug;
extern BOOL                  gLocallyInstalled;
extern BOOL                  gbFinished;
extern BOOL                  gbIsNt351;
extern StringLoader          gString;

DWORD RemoveService();
DWORD UnregisterFiles();
DWORD RemoveFiles(); 
DWORD RegisterDLL(const WCHAR * filename);
DWORD RegisterExe(const WCHAR * filename);
BOOL IsLocallyInstalled();

DWORD __stdcall 
   ShutdownService(
      /* [in] */ DWORD    bFlags
   );



TNodeList                    gJobList;

class TJobNode : public TNode
{
   WCHAR                   guid[LEN_Guid];
public:
   TJobNode(WCHAR const * id) { safecopy(guid,id); }
   WCHAR const * JobID() { return guid; }
};

// thread entry point, waits for the specified job to end,
// then shuts down the DCTAgentService
DWORD __stdcall
   MonitorJob( 
      void                 * arg           // in - BSTR job ID
   )
{
    HRESULT                   hr = CoInitialize(NULL);
    _bstr_t                   jobID = (BSTR)arg;
    IDCTAgent               * pLocalAgent = NULL;
    BOOL                      bDone = FALSE;

    try {
        
        // Get a pointer to the local agent
        if ( SUCCEEDED(hr) )
        {
            gStreamCS.Enter();  // this critical section is used to ensure that 
                                  // only one process is unmarshalling pStream at a time
            hr = CoUnmarshalInterface( pStream, IID_IDCTAgent,(void**)&pLocalAgent);
            HRESULT hr2;
            if ( SUCCEEDED(hr) )
            {
                // Reset the stream to the beginning
                LARGE_INTEGER           offset =  { 0,0 };
                ULARGE_INTEGER          result =  { 0,0 };
                hr2 = pStream->Seek(offset,STREAM_SEEK_SET,&result);
            }
            gStreamCS.Leave();

            if (FAILED(hr2))
               err.SysMsgWrite(ErrE, hr2, DCT_MSG_SEEK_FAILED_D, hr2);

            // Get the status of the job
            IUnknown             * pUnk = NULL;

            if ( SUCCEEDED(hr) )
            {
                do { 
                    hr = pLocalAgent->raw_QueryJobStatus(jobID,&pUnk);
                    if ( SUCCEEDED(hr) )
                    {
                        IVarSetPtr          pVarSet = pUnk;
                        _bstr_t             status = pVarSet->get(GET_BSTR(DCTVS_JobStatus));
                        _bstr_t shutdownStatus = pVarSet->get(GET_BSTR(DCTVS_ShutdownStatus));

                        if ( gDebug )
                        {
                            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONJOBSTAT),(WCHAR*)jobID, (WCHAR*)status);
                        }
                        // only when the agent finishes and is ready to shut down, do we shut down
                        if (( ! UStrICmp(status,GET_STRING(IDS_DCT_Status_Completed)) 
                            || ! UStrICmp(status,GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
                            && ! UStrICmp(shutdownStatus,GET_STRING(IDS_DCT_Status_Shutdown)))
                        {
                            bDone = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        // if we are unable to query the agent, it indicates something serious happened
                        // we should shut down the service
                        bDone = TRUE;
                        if (gDebug)
                            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_CANNOT_MONITOR_JOB),(WCHAR*)jobID, hr);
                    }
                    pUnk->Release();
                    pUnk = NULL;
                    Sleep(60*1000);   // one minute
                }
                while ( SUCCEEDED(hr) );
                pLocalAgent->Release();
            }
            else
            {
                // cannot unmarshal the agent, shut down the service
                bDone = TRUE;
            }

            CoUninitialize();
        }
        else
        {
            bDone = TRUE;
        }
    }
    catch ( ... )
    {
        bDone = TRUE;
        if (gDebug)
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONERROR));
        try { 
            pLocalAgent->Release();
        }
        catch ( ... )
        {
        }
    }

    if (bDone)
        hr = ShutdownService(0);
    
    if ( gDebug )
        err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONEXIT),hr);
    return hr;
}

DWORD 
   AuthenticateClient(
      handle_t               hBinding        // in - binding for client call
   )
{
   DWORD                     rc;
   
   rc = RpcImpersonateClient(hBinding);
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_IMPERSONATE_D,rc);
   }
   else 
   {
      rc = IsAdminLocal();
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_CLIENT_NOT_ADMIN_D, rc);
      }

      RpcRevertToSelf();
   }
   return rc;
}
DWORD 
   RegisterPlugInFiles(
      IVarSet              * pVarSet
   )
{
   DWORD                     rc = 0;
   WCHAR                     key[MAX_PATH + 50];
   int                       nFiles = 0;
   _bstr_t                   filename;

   do 
   {
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Starting plug-in file registration.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_STARTPLUGREG));
      
      swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_RegisterFiles_D),nFiles);
      filename = pVarSet->get(key);

      if ( filename.length() != 0 )
      {
         if ( gDebug )
//*            err.DbgMsgWrite(0,L"File %ld = %ls",nFiles,(WCHAR*)filename);
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_FILEREG),nFiles,(WCHAR*)filename);

         if ( !UStrICmp((WCHAR *)filename + filename.length() - 4,L".DLL") )
         {
            RegisterDLL(filename);   
         }
         else
         {
            RegisterExe(filename);
         }
         nFiles++;
      }

   } while (filename.length() != 0);
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Done Registering plug-in files.");
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_PLUGREGDONE));
   return rc;
}

DWORD __stdcall 
   EaxsSubmitJob( 
      /* [in] */ handle_t hBinding,
      /* [string][in] */ const WCHAR __RPC_FAR *filename,
      /* [string][in] */ const WCHAR __RPC_FAR *extra,
      /* [size_is][string][out] */ WCHAR __RPC_FAR *jobGUID
   )
{
   
   HRESULT                   hr = 0;
   WCHAR                     filenameW[MAX_PATH];
   WCHAR                     pathW[MAX_PATH];
   int                       pathLen = 0;
   IDCTAgent               * pLocalAgent = NULL;
//   BOOL                      bFileCopied = FALSE;
   BOOL                      gbDeleteOnCompletion = FALSE;

   // Make sure the client is an admin on the local machine, otherwise, forget it
   hr = AuthenticateClient(hBinding);
   if ( hr )
   {
      return hr; 
   }
   safecopy(filenameW,filename);

   // get the path for our install directory
   if ( ! GetModuleFileName(NULL,pathW,DIM(pathW)) )
   {
      hr = GetLastError();
      pathW[0] = L'\0'; // to keep PREfast happy
      safecopy(pathW,filenameW);
      err.SysMsgWrite(ErrW,hr,DCT_MSG_GET_MODULE_PATH_FAILED_D,hr);
   }
   else
   {
      pathW[DIM(pathW) - 1] = L'\0';
      pathLen = UStrLen(pathW) - UStrLen(GET_STRING(IDS_SERVICE_EXE));
      UStrCpy(pathW + pathLen,filenameW, DIM(pathW));
   }

   gStreamCS.Enter();  // this critical section is used to ensure that only one
                         // process is unmarshalling pStream at a time
   hr = CoUnmarshalInterface( pStream, IID_IDCTAgent,(void**)&pLocalAgent);
                   // interface pointer requested in riid);
   if ( SUCCEEDED(hr) )
   {
      // Reset the stream to the beginning
      LARGE_INTEGER           offset = { 0,0 };
      ULARGE_INTEGER          result = { 0,0 };
      
      HRESULT hr2 = pStream->Seek(offset,STREAM_SEEK_SET,&result);
        
      gStreamCS.Leave();

      if (FAILED(hr2))
         err.SysMsgWrite(ErrE, hr2, DCT_MSG_SEEK_FAILED_D, hr2);

      BSTR                   jobID = NULL;

      // Read the varset data from the file

      IVarSetPtr             pVarSet;
      IStoragePtr            store = NULL;

      // Try to create the COM objects
      hr = pVarSet.CreateInstance(CLSID_VarSet);
      if ( SUCCEEDED(hr) )
      {
         
         // Read the VarSet from the data file
         hr = StgOpenStorage(pathW,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
         if ( SUCCEEDED(hr) )
         {                  
            // Load the data into a new varset
            hr = OleLoad(store,IID_IUnknown,NULL,(void **)&pVarSet);
            if ( SUCCEEDED(hr) )
            {
               _bstr_t       text = pVarSet->get(GET_BSTR(DCTVS_Options_DeleteFileAfterLoad));

               if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
               {
                  // Free the storage pointer to the file
                  store = NULL;
                  if ( DeleteFile(pathW) )
                  {
                     if ( gDebug )
//*                        err.DbgMsgWrite(0,L"Deleted job file %ls",pathW);
                        err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_JOBDEL),pathW);
                  }
                  else
                  {
                     err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_JOB_FILE_NOT_DELETED_SD,pathW,GetLastError());
                  }
               }
               text = pVarSet->get(GET_BSTR(DCTVS_Options_RemoveAgentOnCompletion));
               if ( !UStrICmp(text,GET_STRING(IDS_YES)))
               {
                  gbDeleteOnCompletion = TRUE;   
               }
               text = pVarSet->get(GET_BSTR(DCTVS_AgentService_DebugMode));
               if ( !UStrICmp(text,GET_STRING(IDS_YES)))
               {
                  gDebug = TRUE;
               }
               WCHAR password[LEN_Password];
               safecopy(password,extra);
               

               RegisterPlugInFiles(pVarSet);

               // reset the absolute result file name based on the module file path
               _bstr_t relativeResultFileName = pVarSet->get(GET_BSTR(DCTVS_Options_RelativeResultFileName));
               UStrCpy(pathW + pathLen,
                        (!relativeResultFileName) ? L"" : (WCHAR*)relativeResultFileName,
                        DIM(pathW));
               pVarSet->put(GET_BSTR(DCTVS_Options_ResultFile), _bstr_t(pathW));

               // reset the absolute .secrefs file name based on the module file path
               text = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));
               if (text.length())
               {
                   relativeResultFileName = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferencesRelativeFileName));
                   UStrCpy(pathW + pathLen,
                            (!relativeResultFileName) ? L"" : (WCHAR*)relativeResultFileName,
                            DIM(pathW));
                   pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences), _bstr_t(pathW));
               }
               
               hr = pLocalAgent->raw_SubmitJob(pVarSet,&jobID);
               if ( SUCCEEDED(hr)) 
               {
                  TJobNode * pnode = new TJobNode(jobID);
                  gJobList.InsertBottom(pnode);
                  err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,jobID,L"",L"");
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_SUBMIT_JOB_FAILED_D,hr);
               }

               if ( gbDeleteOnCompletion )
               {
                  if ( ! gLocallyInstalled )
                  {
                     gSuicide = TRUE;
      
                  }
                  if ( SUCCEEDED(hr) )
                  {
                     // Start up a thread to monitor this job and initiate a shutdown when it is completed
                     DWORD                 threadID = 0;
                     HANDLE                gThread = CreateThread(NULL,0,&MonitorJob,(void*)jobID,0,&threadID);
                  
                     CloseHandle(gThread);
                  }
                  
               }
               UStrCpy(jobGUID,jobID);
            }
            else
            {
               err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_VARSET_LOAD_FAILED_SD,filenameW, hr);
            }
         }
         else
         {
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_JOBFILE_OPEN_FAILED_SD,filenameW,hr);
         }
         
      }
//      int x = pLocalAgent->Release();
      pLocalAgent->Release();
   }
   else
   {
      gStreamCS.Leave();
      err.SysMsgWrite(ErrE,hr,DCT_MSG_UMARSHAL_AGENT_FAILED_D,hr);
   }

   return hr;
}

DWORD __stdcall
   EaxsQueryInterface(
      /* [in] */ handle_t hBinding,
      /* [out] */ LPUNKNOWN __RPC_FAR *lpAgentUnknown
   )
{

   DWORD                     rc = 0;
   HRESULT                   hr;
   IDCTAgent               * pLocalAgent = NULL;

   (*lpAgentUnknown) = NULL;
   // make sure the client is an admin on the local machine
   rc = AuthenticateClient(hBinding);
   if ( rc )
   {
      return rc; 
   }
   
   if ( ! gbIsNt351 )
   {
      gStreamCS.Enter();  // this critical section is used to ensure that
                            // only one process is unmarshalling pStream at a time
      hr = CoUnmarshalInterface( pStream, IID_IUnknown,(void**)&pLocalAgent);
                   // interface pointer requested in riid);
   
      if ( SUCCEEDED(hr) )
      {
         // Reset the stream to the beginning
         LARGE_INTEGER           offset = { 0,0 };
         ULARGE_INTEGER          result = { 0,0 };
      
         HRESULT hr2 = pStream->Seek(offset,STREAM_SEEK_SET,&result);
         gStreamCS.Leave();
         
         if (FAILED(hr2))
            err.SysMsgWrite(ErrE, hr2, DCT_MSG_SEEK_FAILED_D, hr2);

         (*lpAgentUnknown) = pLocalAgent;
      }
      else 
      {
         gStreamCS.Leave();
         err.SysMsgWrite(ErrE,hr,DCT_MSG_UMARSHAL_AGENT_FAILED_D,hr);
         (*lpAgentUnknown) = NULL;
      }
   }
   else
   {
      // NT 3.51 doesn't support DCOM, so there's no point in even trying this
      (*lpAgentUnknown) = NULL;
      hr = E_NOTIMPL;
   }

   return hr;
}
 

#define DCTAgent_Remove             1

DWORD __stdcall 
   ShutdownService(
      /* [in] */ DWORD    bFlags
   )
{
    DWORD                     rc = 0;
    HRESULT                   hr;
    //   LPUNKNOWN                 pLocalAgent = NULL;

    if ( bFlags )
    {
        if ( gDebug )
        //*         err.DbgMsgWrite(0,L"Set suicide flag.");
        err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_SETFLAG));
        gSuicide = TRUE;
    }
    else
    {
        if ( gDebug )
        //*         err.DbgMsgWrite(0,L"Did not set suicide flag");
        err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_NOSETFLAG));
    }

    if ( gSuicide && ! gLocallyInstalled )
    {
        if ( gDebug )
            //*         err.DbgMsgWrite(ErrW,L"Removing agent");
            err.DbgMsgWrite(ErrW,GET_STRING(IDS_EVENTVW_MSG_REMOVEAGENT));
        // Uninstall the service
        if ( gDebug )
            //*         err.DbgMsgWrite(0,L"Unregistering files");
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_UNREGFILES));
        UnregisterFiles();
        // delete all files
        if ( gDebug )
            //*         err.DbgMsgWrite(0,L"Deleting files");
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_FILEDEL));
        RemoveFiles();
        if ( gDebug )
            //*         err.DbgMsgWrite(0,L"Removing service");
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REMOVESVC));
        RemoveService();

    }
    else
    {
        if ( gDebug )
        //*         err.DbgMsgWrite(ErrW,L"Not Removing agent");
        err.DbgMsgWrite(ErrW,GET_STRING(IDS_EVENTVW_MSG_NOREMOVEAGENT));
    }

    RPC_STATUS status = RPC_S_OK;

    if ( ! gbIsNt351 )
    {
        status = RpcMgmtStopServerListening(NULL);
    }
    else
    {
        gbFinished = TRUE;
    }

    if (gDebug)
    {
        if (status == RPC_S_OK)
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_STOPLISTEN),bFlags);
        else
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_CANNOT_STOP_LISTENING),(long)status);
    }

    status = RpcServerUnregisterIf( NULL, NULL, FALSE );
    if (gDebug)
    {
        if (status == RPC_S_OK)
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_UNREGISTER_INTERFACE));
        else
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_CANNOT_UNREGISTER_INTERFACE),(long)status);
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\agtsvc\dctagsvc.cpp ===
/*---------------------------------------------------------------------------
  File: DCTAgentService.cpp

  Comments:  entry point and service control functions for DCTAgent service

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 11:39:58

 ---------------------------------------------------------------------------
*/
//

#include <windows.h>  
#include <lm.h>
#include <lmwksta.h>
#include <locale.h>
#include "AgSvc.h"
#include "AgSvc_s.c"

#include "Common.hpp"
#include "Err.hpp"
#include "TService.hpp"  
#include "TSync.hpp"
#include "TEvent.hpp"       
#include "TReg.hpp"
#include "TNode.hpp"
#include "ResStr.h"
#include "folders.h"

using namespace nsFolders;

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsEADCTAgent.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "Engine.tlb" no_namespace, named_guids

// These global variables can be changed if required
WCHAR                const * gsEaDctProtoSeq = TEXT("ncacn_np");
WCHAR                const * gsEaDctEndPoint = TEXT("\\pipe\\EaDctRpc");

class TServerNode : public TNode
{
   WCHAR                     filename[MAX_PATH];
   BOOL                      bExe;
public:
   TServerNode(WCHAR const * fname,BOOL isExe) { safecopy(filename,fname);bExe=isExe; }
   BOOL                      IsExe() { return bExe; }
   WCHAR             const * Name() { return filename; }
};

BOOL                         gForceCli = FALSE;
BOOL                         gDebug = TRUE;
BOOL                         gHelp = FALSE;
DWORD                        gEaDctRpcMinThreads = 1;
DWORD                        gEaDctRpcMaxThreads = 20;
BOOL                         gSuicide = FALSE;
BOOL                         gLocallyInstalled = FALSE;
BOOL                         gbIsNt351 = FALSE;
BOOL                         gbFinished = FALSE;
TNodeList                    gRegisteredFiles;

IDCTAgent                  * m_pAgent = NULL;
         
StringLoader                 gString;

LPSTREAM pStream = NULL;
TCriticalSection gStreamCS;


#define  EADCTAGENT_SEMNAME  L"EaDCTAgent.990000.Sem"



TErrorEventLog               err( L"", GET_STRING(IDS_EVENT_SOURCE), 0, 0 );
TError                     & errCommon = err;

// Provided by TService user
BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      char           const * arg           // in -command line argument
   )
{
		//adding bogus use of arg parameter to satisfy the compiler
   if (!arg)
	   return TRUE;

   return TRUE;
}

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      WCHAR          const * arg           // in -command line argument
   )
{
   if ( !UStrICmp(arg,(WCHAR*)GET_STRING(IDS_DEBUG_SWITCH)) )
   {
      gDebug = TRUE;
   }
   return TRUE;
}

BOOL                                       // ret-TRUE if force CLI
   UScmForceCli()
{
   // TODO:  what should this do?
   return FALSE;
}

BOOL 
   IsLocallyInstalled()
{
   BOOL                      bFound;
   TRegKey                   key;
   DWORD                     rc;


   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key));
#ifdef OFA
   if(!rc)
   {
      BSTR buf = ::SysAllocStringLen(0, 2000);
      DWORD nMax = 2000;
      DWORD res = key.ValueGetStr(_bstr_t(L"Directory"), buf, nMax);
      ::SysFreeString(buf);
      rc = (res == ERROR_SUCCESS)?0:1;
   }
#endif

   if ( ! rc )
   {
      bFound = TRUE;
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Agent service has been locally installed.  The Domain Administrator components will not be unregistered or removed.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGENTSVCINSTALLED));
   }
   else
   {
      bFound = FALSE;
      if  ( gDebug )
//*         err.DbgMsgWrite(0,L"Agent service has not been locally installed, rc=%ld, ",rc);
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED),rc);
   }
   return bFound;
}


void 
   CheckOSVersion()
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * info = NULL;

   // TODO:  change this to use GetVersionEx
   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&info);
   if (! rc )
   {
      if ( info->wki100_ver_major == 3 )
      {
         if ( gDebug )
//*            err.DbgMsgWrite(0,L"This computer is running Windows NT, version %ld.%ld",info->wki100_ver_major,info->wki100_ver_minor);
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_OSVERSION),info->wki100_ver_major,info->wki100_ver_minor);
         gbIsNt351 = TRUE;
      }
      NetApiBufferFree(info);
   }
}

DWORD                                      // ret- HRESULT or WIN32 error
   RegisterDLL(
      WCHAR          const * filename      // in - DLL name to register (regsvr32)
   )
{
   DWORD                     rc = 0;
   HMODULE                   hDLL;
   HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
   HRESULT                   hr = S_OK;   
   hDLL = LoadLibrary(filename);
   if ( hDLL )
   {
      
      (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllRegisterServer");
      if (lpDllEntryPoint != NULL) 
      {
         hr = (*lpDllEntryPoint)();
         if ( FAILED(hr) )
         {
            // registration failed
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_FAILED_TO_REGISTER_FILE_SD,filename,hr);
            rc = hr;                       
         }
         else
         {
            if ( gDebug )
//*               err.DbgMsgWrite(0,L"Registered %ls",filename);
               err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGISTERED),filename);

            TServerNode * pNode = new TServerNode(filename,FALSE);
            gRegisteredFiles.InsertBottom(pNode);
         }
      }
      else
      {
         //unable to locate entry point
         err.MsgWrite(ErrE,DCT_MSG_DLL_NOT_REGISTERABLE_S,filename);
      }
   }
   else
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_LOAD_LIBRARY_FAILED_SD,filename,rc);
   }
   
   return rc;
}

DWORD                                      // ret- HRESULT or WIN32 error
   UnregisterDLL(
      WCHAR          const * filename      // in - name of dll to unregister
   )
{
   DWORD                     rc = 0;
   HMODULE                   hDLL;
   HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
   HRESULT                   hr = S_OK;   
   
   hDLL = LoadLibrary(filename);
   if ( hDLL )
   {
      
      (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllUnregisterServer");
      if (lpDllEntryPoint != NULL) 
      {
         hr = (*lpDllEntryPoint)();
         if ( FAILED(hr) )
         {
            // registration failed
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_FAILED_TO_UNREGISTER_FILE_SD,filename,hr);
            rc = hr;                       
         }
         else
         {
            if ( gDebug )
//*               err.DbgMsgWrite(0,L"Unregistered %ls",filename);
               err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_UNREGISTERED),filename);
         }
      }
      else
      {
         //unable to locate entry point
         err.MsgWrite(ErrE,DCT_MSG_DLL_NOT_UNREGISTERABLE_S,filename);
      }
   }
   else
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_LOAD_LIBRARY_FAILED_SD,filename,rc);
   }
   return rc;   
}

DWORD                                      // ret- OS return code
   RegisterExe(
      WCHAR          const * filename      // in - name of EXE to register
   )
{
   DWORD                     rc = 0;
   WCHAR                     cmdline[1000];
   STARTUPINFO               sInfo;
   PROCESS_INFORMATION       pInfo;
   WCHAR                     pathW[MAX_PATH] = L"";
   WCHAR                     drive[MAX_PATH] = L"";
   WCHAR                     dir[MAX_PATH] = L"";
   DWORD                     dwLength = 0;   
   
   memset(&sInfo,0,(sizeof sInfo));
   memset(&pInfo,0,(sizeof pInfo));

   sInfo.cb = (sizeof sInfo);

   // get the path for our install directory   
   dwLength = GetModuleFileName(NULL,pathW,MAX_PATH - 1);
   if ( !dwLength)
   {
      rc = GetLastError();      
      err.SysMsgWrite(ErrW,rc,DCT_MSG_GET_MODULE_PATH_FAILED_D,rc);
      return rc;
   }    
   
   pathW[dwLength] = L'\0';
   _wsplitpath(pathW, drive, dir, NULL, NULL);
   _wmakepath(cmdline, drive, dir, filename, NULL);
   wcscat(cmdline, L" /REGSERVER");
   
   if ( ! CreateProcess(NULL,cmdline,NULL,NULL,FALSE,0,NULL,NULL,&sInfo,&pInfo) )
   {
      rc = GetLastError();
   }
   else 
   {
      // TODO:  wait for the registration to complete
      DWORD             exitCode = 0;
      int               count = 0;         
      do 
      {
         Sleep(100);
         if (! GetExitCodeProcess(pInfo.hProcess,&exitCode) )
            break;
         count++;
      } while ( exitCode == STILL_ACTIVE && ( count < 500 ) );
      CloseHandle(pInfo.hProcess);
   }
   
   if ( rc == ERROR_SUCCESS)
   {
      rc = 0; // success
      TServerNode * pNode = new TServerNode(filename,TRUE);
      gRegisteredFiles.InsertBottom(pNode);
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Registered %ls",filename);
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGISTERED),filename);

   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_REGISTER_FILE_SD,filename,rc);
   }
   return rc;
}

DWORD                                     //ret- OS return code
   UnregisterExe(
      WCHAR          const * filename     // in - name of EXE to unregister
   )
{
   DWORD                     rc = 0;
   char                      cmdline[1000];

   sprintf(cmdline,"%ls /UNREGSERVER",filename);
   rc = WinExec(cmdline,FALSE);
   
   if ( rc > 31 )
   {
      rc = 0; // success
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_UNREGISTER_FILE_SD,filename,rc);
   }
   return rc;
}


DWORD    
   UnregisterFiles()
{
//   DWORD                     rc = 0;
   TNodeListEnum             e;
   TServerNode             * pNode;
   TServerNode             * pNext;

   for ( pNode = (TServerNode *)e.OpenFirst(&gRegisteredFiles) ;  pNode ; pNode = pNext )
   {
      pNext = (TServerNode*)e.Next();
      
      if ( pNode->IsExe() )
      {
         UnregisterExe(pNode->Name());
      }
      else
      {
         UnregisterDLL(pNode->Name());
      }
      gRegisteredFiles.Remove(pNode);
      delete pNode;
   }
  
   return 0;
}

DWORD    
   RemoveFiles()
{
   DWORD                     rc = 0;
   WCHAR                     pathWC[MAX_PATH];
   WCHAR                     pathW[MAX_PATH] = L"";
   WCHAR                     fullpath[MAX_PATH];
   HANDLE                    h;
   WIN32_FIND_DATA           fDat;


   // get the path for our install directory
   if ( ! GetModuleFileName(NULL,pathW,DIM(pathW)) )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_MODULE_PATH_FAILED_D,rc);
   }
   else
   {
      WCHAR *pszAgentSvcPath;
#ifdef OFA
      pszAgentSvcPath = L"OnePointFileAdminAgent\\OFAAgentService.exe";
#else
      pszAgentSvcPath = L"OnePointDomainAgent\\DCTAgentService.exe";
#endif
      if ( !UStrICmp(pathW + UStrLen(pathW) - UStrLen(GET_STRING(IDS_AGENT_DIRECTORY)) - UStrLen(GET_STRING(IDS_SERVICE_EXE))-1,pszAgentSvcPath) )
      {
         // this is our install directory.  Delete all the files from it, then remove the directory
         UStrCpy(pathWC,pathW,UStrLen(pathW)-UStrLen(GET_STRING(IDS_SERVICE_EXE)));
         UStrCpy(pathWC+UStrLen(pathWC),"\\*");
         
         h = FindFirstFile(pathWC,&fDat);
         if ( h != INVALID_HANDLE_VALUE )
         {
            do 
            {
               if ( fDat.cFileName[0] != L'.' )
               {
                  UStrCpy(fullpath,pathWC);
                  UStrCpy(fullpath + UStrLen(fullpath)-1, fDat.cFileName);

                  if (!DeleteFile(fullpath) && ! MoveFileEx(fullpath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT) )
                  {
                     err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_DELETE_FILE_FAILED_SD,fDat.cFileName,GetLastError());
                  }
               
               }
               if ( ! FindNextFile(h,&fDat) )
               {
                  rc = GetLastError();
               }
            } while ( ! rc );
            FindClose(h);
         }
         // now delete the directory
         UStrCpy(fullpath,pathWC);
         fullpath[UStrLen(fullpath)-2] = 0;
         if(!DeleteFile(fullpath))
            MoveFileEx(fullpath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
      }
   }

   return 0;
}


DWORD    
   RemoveService()
{
   SC_HANDLE                 hScm = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
   DWORD                     rc = 0;

   if ( hScm && hScm != INVALID_HANDLE_VALUE )
   {
      SC_HANDLE              hService = OpenService(hScm,GET_STRING(IDS_SERVICE_NAME),DELETE);

      if ( hService && hService != INVALID_HANDLE_VALUE )
      {
         if ( ! DeleteService(hService) )
         {
            rc = GetLastError();
         }
      }
      else
      {
         rc = GetLastError();
      }
   }
   else
   {
      rc = GetLastError();
   }
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_REMOVE_SERVICE_FAILED_D,rc);
   }
   return rc;
}

void
   UScmEp(
//      BOOL                   bService      // in -FALSE=Cli,TRUE=Service
   )
{
   DWORD                     rc = 0;
   _bstr_t                   jobID;
   _bstr_t                   filename = GET_STRING(IDS_DATA_FILE);
      
   // Register all the DCT DLLs
   
//   do { // once
   int i = 0;
   while (i == 0) 
   { // once
	  i++;
      HRESULT                   hr;
      
      hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
      if ( FAILED(hr) )
         break;
        
      _wsetlocale( LC_ALL, L".ACP" );
      // Check to see if this is NT 3.51 or not
      CheckOSVersion();

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Initializing OLE subsystem.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_INITOLE));

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Registering Components");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGCOMPNT));
      rc = RegisterDLL(GET_STRING(IDS_VARSET_DLL));
      if ( rc ) break;
      rc = RegisterDLL(GET_STRING(IDS_WORKER_DLL));
      if ( rc ) break;
      rc = RegisterExe(GET_STRING(IDS_AGENT_EXE));
      if ( rc ) break;
      
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Creating Instance of agent.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_CREATEAGT));
      {
         hr = CoCreateInstance(CLSID_DCTAgent,NULL,CLSCTX_ALL,IID_IDCTAgent,(void**)&m_pAgent);
         
         if ( FAILED(hr) )
         {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE))
            {
               // we just registered this file -- wait a few seconds and try it again
               Sleep(5000);
               hr = CoCreateInstance(CLSID_DCTAgent,NULL,CLSCTX_ALL,IID_IDCTAgent,(void**)&m_pAgent);
            }
         }
         if ( FAILED(hr) )
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_CREATE_FAILED_D,hr);
            rc = hr;
            break;
         }
         hr =CoMarshalInterThreadInterfaceInStream(IID_IDCTAgent,m_pAgent,&pStream);
         if ( FAILED(hr) )
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_MARSHAL_FAILED_D,hr);
            rc = hr;
            break;
         }
         
      }
      
      gLocallyInstalled = IsLocallyInstalled();
      
      
      // specify protocol sequence and endpoint
      // for receiving remote procedure calls

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Initializing RPC connection.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_INITRPC));
      rc = RpcServerUseProtseqEp(
            const_cast<UTCHAR *>(gsEaDctProtoSeq),
            gEaDctRpcMaxThreads,
            const_cast<UTCHAR *>(gsEaDctEndPoint),
            NULL );
      if ( rc )
      {
         err.SysMsgWrite(
               ErrE,
               rc,
               DCT_MSG_RpcServerUseProtseqEp_FAILED_SDSD,
               gsEaDctProtoSeq,
               gEaDctRpcMaxThreads,
               gsEaDctEndPoint,
               rc );
         break;
      }
      // register an interface with the RPC run-time library
      rc = RpcServerRegisterIf( EaxsEaDctRpc_ServerIfHandle, NULL, NULL );
      if ( rc )
      {
         err.SysMsgWrite(
               ErrE,
               rc,
               DCT_MSG_RpcServerRegisterIf_FAILED_SDSD,
               gsEaDctProtoSeq,
               gEaDctRpcMaxThreads,
               gsEaDctEndPoint,
               rc );
         break;
      }

      rc = RpcServerRegisterAuthInfo(
               0,
               RPC_C_AUTHN_WINNT,
               0,
               0 );

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Listening...");   
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_LISTENQ));   
      // listen for remote procedure calls
// per Q141264       

      if (! gbIsNt351 )
      {
         // on NT 4 or higher, put ourselves into a listening state
         rc = RpcServerListen(
               gEaDctRpcMinThreads,
               gEaDctRpcMaxThreads,
               FALSE );

         if ( rc == RPC_S_ALREADY_LISTENING )
         {
            // assume this is NT 3.51
            gbIsNt351 = TRUE;
         }

      }
      if ( gbIsNt351 )
      {
         // for NT 3.51, RpcServerListen will return an error
         // we need to sit and wait for shutdown
         do 
         {
            Sleep(5000);
         } while ( ! gbFinished );
      }
   }// while ( false );
   CoUninitialize();
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent entry-point exiting.");
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_EXITENTRYP));
}

//----------------------------------------------------------------------------
// Function:   RegisterEvent
//
// Synopsis:   Register the ADMTAgent under HKLM\System\CurrentControlSet\Services\EventLog\Application
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------

void RegisterEvent()
{
    // construct message dll path
    TRegKey currentVersionKey;
    //DWORD myrc;
    TCHAR sProgramFilesDir[MAX_PATH];
    _bstr_t messageDllPath;

    DWORD myrc = currentVersionKey.Open(REGKEY_CURRENT_VERSION);
    if ( !myrc )
    {
        myrc = currentVersionKey.ValueGetStr(REGVAL_PROGRAM_FILES_DIRECTORY, sProgramFilesDir, MAX_PATH * (sizeof TCHAR));
        if (!myrc)
            messageDllPath = _bstr_t(sProgramFilesDir) + _bstr_t(_T("\\OnePointDomainAgent\\McsDmMsg.dll"));
    }

    // register the event source
    TRegKey eventLog, eventSource;

    if ( ! myrc )
    {
        myrc = eventLog.Open(REGKEY_APPLICATION_LOG);
    }

    if (!myrc)
    {
        myrc = eventSource.Create(REGKEY_ADMTAGENT_EVENT_SOURCE, &eventLog);
        if (!myrc)
        {
            DWORD categoryCount = 5;
            myrc = eventSource.ValueSetDWORD(REGVAL_EVENT_CATEGORYCOUNT, categoryCount);
        }
        if (!myrc)
        {
            DWORD typesSupported = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
            myrc = eventSource.ValueSetDWORD(REGVAL_EVENT_TYPESSUPPORTED, typesSupported);
        }
        if (!myrc)
        {
            myrc = eventSource.ValueSetStr(REGVAL_EVENT_CATEGORYMESSAGEFILE, messageDllPath, REG_EXPAND_SZ);
        }
        if (!myrc)
        {
            myrc = eventSource.ValueSetStr(REGVAL_EVENT_EVENTMESSAGEFILE, messageDllPath, REG_EXPAND_SZ);
        }
    }
}

int __cdecl                                // ret-zero
   main(
      int                    argc         ,// in -argument count
      char          const ** argv          // in -argument array
   )
{
   TScmEpRc                  rcScmEp;      // TScmEp return code
   TSemaphoreNamed           cSem;         // named semaphore
   BOOL                      bExisted=FALSE; // TRUE if semaphore existed
   DWORD                     rcOs = 0;
   HRESULT                   hr = 0;

    // register event and initialize err
    RegisterEvent();
    err.LogOpen(GET_STRING(IDS_EVENT_SOURCE));

   // initialize the main thread to multithreaded apartment
   hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   if (FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COINITIALIZE_FAILED_D,hr);
      return hr;
   }
         // Only allow one instance of EaDctAgent per machine
   rcOs = cSem.Create( EADCTAGENT_SEMNAME, 0, 1, &bExisted );
   if ( rcOs || bExisted )
   {
      err.MsgWrite(ErrE,DCT_MSG_AGENT_ALREADY_RUNNING);
      return 1;
   }

   rcScmEp = TScmEp(
         argc,
         argv,
         GET_STRING(IDS_EVENTSOURCE));

   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent main exiting...",m_pAgent);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGTEXITQ),m_pAgent);

   if ( m_pAgent )
   {
      if ( pStream )
      {
         CoReleaseMarshalData(pStream);
         pStream->Release();
      }
      pStream = NULL;
      m_pAgent->Release();
      m_pAgent = NULL;
   }  
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent main exiting!.",m_pAgent);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGTEXITS),m_pAgent);
   CoUninitialize();
   return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// Midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\addtogrp.cpp ===
// AddToGroup.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AddToGroupps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AddToGrp.h"

#include "AddToGrp_i.c"
#include "GrpUpdt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_GroupUpdate, CGroupUpdate)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
         ATLTRACE(_T("{AddToGroup.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
       _Module.Init(ObjectMap, hInstance, &LIBID_ADDTOGROUPLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        ATLTRACE(_T("{AddToGroup.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AddToGrp.rc
//
#define IDS_PROJNAME                    100
#define IDR_GROUPUPDATE                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\grpupdt.cpp ===
//---------------------------------------------------------------------------
// GrpUpdt.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The Process method adds the migrated account to the specified
//          group on source and target domain. The Undo function removes these
//          from the specified group.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <lm.h>
#include "AddToGrp.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "GrpUpdt.h"
#include "ResStr.h"
#include "ErrDCT.hpp"
#include "EALen.hpp"
//#import "\bin\mcsvarsetmin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")


StringLoader      gString;
/////////////////////////////////////////////////////////////////////////////
// CGroupUpdate

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// PreProcessObject : This method doesn't do anything at this point
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method adds the copied account to the specified
//                 groups on source and target domains.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sGrpName, sServer, sAcct;
   HRESULT                   hr = S_OK;
   long                      rc = 0;
   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];

   // Get the Error log filename from the Varset
   var = pVs->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   
   // Open the error log
   err.LogOpen(fileName, 1);

   // Process adding users to the source domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupAddUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ADDTO_FAILED_SSD, sAcct, sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_ADDED_TO_GROUP_SS,sAcct,sGrpName);
         }
      }
   }

   // Now process the group on the target domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupAddUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ADDTO_FAILED_SSD, sAcct, sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_ADDED_TO_GROUP_SS,sAcct,sGrpName);
         }
      }
   }
   err.LogClose();
   return hr;
}

//---------------------------------------------------------------------------
// ProcessUndo :  This method removes the account from the specified group.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::ProcessUndo(                                             
                                          IUnknown *pSource,         //in- Pointer to the source AD object
                                          IUnknown *pTarget,         //in- Pointer to the target AD object
                                          IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                          IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                     //         once all extension objects are executed.
                                          EAMAccountStats* pStats
                                       )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sGrpName, sServer, sAcct;
   HRESULT                   hr = S_OK;
   long                      rc = 0;
   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];

   // Get the Error log filename from the Varset
   var = pVs->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   VariantInit(&var);
   // Open the error log
   err.LogOpen(fileName, 1);

   // Process adding users to the source domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupDelUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_REMOVE_FROM_FAILED_SSD, (WCHAR *)sAcct, (WCHAR*)sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS,(WCHAR *)sAcct,(WCHAR *)sGrpName);
         }
      }
   }

   // Now process the group on the target domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupDelUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_REMOVE_FROM_FAILED_SSD, (WCHAR *)sAcct, (WCHAR *)sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS,(WCHAR *)sAcct,(WCHAR *)sGrpName);
         }
      }
   }
   err.LogClose();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\grpupdt.h ===
//---------------------------------------------------------------------------
// GrpUpdt.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The Process method adds the migrated account to the specified
//          group on source and target domain. The Undo function removes these
//          from the specified group.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef __GROUPUPDATE_H_
#define __GROUPUPDATE_H_

#include "resource.h"       // main symbols
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// CGroupUpdate
class ATL_NO_VTABLE CGroupUpdate : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGroupUpdate, &CLSID_GroupUpdate>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_ADDTOGROUPLib>
{
public:
	CGroupUpdate()
	{
      m_sName = L"";
      m_sDesc = L"";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_GROUPUPDATE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGroupUpdate)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;

};

#endif //__GROUPUPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AcctDis.rc
//
#define IDS_PROJNAME                    100
#define IDR_DISABLETARGET               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\disacct.h ===
//---------------------------------------------------------------------------
// DisableTarget.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. In
//          the process method this object disables the Source and the Target
//          accounts depending on the settings in the VarSet.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __DISABLETARGET_H_
#define __DISABLETARGET_H_

#include "resource.h"       // main symbols
#include <comdef.h>
#include "ResStr.h"
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// CDisableTarget
class ATL_NO_VTABLE CDisableTarget : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDisableTarget, &CLSID_DisableTarget>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_DISABLETARGETACCOUNTLib>
{
public:
	CDisableTarget()
	{
      m_sName = L"Disable Accounts";
      m_sDesc = L"Extensions to Disable accounts.";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DISABLETARGET)
static HRESULT WINAPI UpdateRegistry( BOOL bUpdateRegistry )
{
   _ATL_REGMAP_ENTRY         regMap[] =
   {
      { OLESTR("DISPIDVER"), GET_BSTR(IDS_COM_DisPidVer) },
      { OLESTR("DISACCT"), GET_BSTR(IDS_COM_DisTarget) },
      { OLESTR("DISPID"), GET_BSTR(IDS_COM_DisPid) },
      { 0, 0 }
   };

   return _Module.UpdateRegistryFromResourceD( IDR_DISABLETARGET, bUpdateRegistry, regMap );
}

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDisableTarget)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet,  /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet,  /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif //__DISABLETARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\disacct.cpp ===
//---------------------------------------------------------------------------
// DisableTarget.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. In
//          the process method this object disables the Source and the Target
//          accounts depending on the settings in the VarSet.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "ResStr.h"
#include <lm.h>
#include <activeds.h>
#include "AcctDis.h"
#include "DisAcct.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "ErrDCT.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace

const int  LEN_Path = 255;
StringLoader                 gString;

#define AR_Status_PasswordError     (0x00000400)

/////////////////////////////////////////////////////////////////////////////
// CDisableTarget

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CDisableTarget::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CDisableTarget::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CDisableTarget::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}


//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
   // Check if the object is of user type. if not then there is no point in disabling that account.
   IVarSetPtr                   pVs = pMainSettings;
   _bstr_t sType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if (!sType.length())
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   if (UStrICmp((WCHAR*)sType,L"user") && UStrICmp((WCHAR*)sType,L"inetOrgPerson"))
      return S_OK;

   if ( pSource )
   {
//      HRESULT                      hr = S_OK;
      _variant_t                   vtExp;
      _variant_t                   vtFlag;
      _bstr_t                      sSourceType;
      IIManageDBPtr                pDb = pVs->get(GET_BSTR(DCTVS_DBManager));

      sSourceType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));

      if ( !_wcsicmp((WCHAR*) sSourceType, L"user") || !_wcsicmp((WCHAR*) sSourceType, L"inetOrgPerson") )
      {
         // Get the expiration date and put it into the AR Node.
         _bstr_t sSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         _bstr_t sComp = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         USER_INFO_3  * pInfo = NULL;
         DWORD rc = NetUserGetInfo((WCHAR*) sComp, (WCHAR*)sSam, 3, (LPBYTE*)&pInfo);

         if ( !rc )
         {
            vtExp = (long)pInfo->usri3_acct_expires;
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_ExpDate), vtExp);

            // Get the ControlFlag and store it into the AR Node.
            vtFlag = (long)pInfo->usri3_flags;
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags), vtFlag);
            if ( pInfo ) NetApiBufferFree(pInfo);
         }
      }
      pDb->raw_SaveUserProps(pMainSettings);
   }
   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method checks in varset if it needs to disable any
//                 accounts. If it does then it disables those accounts.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
    IVarSetPtr                pVarSet = pMainSettings;
    _variant_t                var;
    DWORD                     paramErr;
    USER_INFO_3             * info = NULL;
    long                      rc;
    WCHAR                     strDomain[LEN_Path];
    WCHAR                     strAcct[LEN_Path];
    HRESULT                   hr = S_OK;
    TErrorDct                 err;
    WCHAR                     fileName[LEN_Path];
    BOOL                      bDisableSource = FALSE;
    BOOL                      bExpireSource = FALSE;
    _bstr_t                   temp;
    time_t                    expireTime = 0;
    _bstr_t                   bstrSameForest;
    BOOL                      bSameAsSource = FALSE;
    BOOL                      bDisableTarget = FALSE;
    BOOL                      bGotSrcState = FALSE;
    BOOL                      bSrcDisabled = FALSE;

    bstrSameForest = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));

    if (! UStrICmp((WCHAR*)bstrSameForest,GET_STRING(IDS_YES)) )
    {
        // in the intra-forest case, we are moving the user accounts, not 
        // copying them, so these disabling/expiring options don't make any sense
        return S_OK;
    }
    // Get the Error log filename from the Varset
    var = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
    wcscpy(fileName, (WCHAR*)V_BSTR(&var));
    VariantInit(&var);
    // Open the error log
    err.LogOpen(fileName, 1);

    // Check if the object is of user type. if not then there is no point in disabling that account.
    var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Type));
    if ( UStrICmp(var.bstrVal,L"user") && UStrICmp(var.bstrVal,L"inetOrgPerson") )
    {
        return S_OK;
    }

    //set flags based on user selections
    temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
    if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) )
    {
        bDisableSource = TRUE;
    }
    //
    // If disable target account option is true or unable to
    // set password for this account then disable account.
    //
    temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
    long lStatus = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Status));
    if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) || (lStatus & AR_Status_PasswordError) )
    {
        bDisableTarget = TRUE;
    }
    temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
    if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) )
    {
        bSameAsSource = TRUE;
    }

    /* process the source account */
    //if expire source accounts was set, retrieve the expire time, now given to us in
    //number of days from now
    temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
    if ( temp.length() )
    {
        long oneDay = 24 * 60 * 60; // number of seconds in 1 day

        //get days until expire
        long lExpireDays = _wtol(temp);
        //get the current time
        time_t currentTime = time(NULL);
        //convert current time to local time
        struct tm  * convtm;
        convtm = localtime(&currentTime);
        //rollback to this morning
        convtm->tm_hour = 0;
        convtm->tm_min = 0;
        convtm->tm_sec = 0;

        //convert this time back to GMT
        expireTime = mktime(convtm);
        //move forward to tonight at midnight
        expireTime += oneDay;

        //now add the desired number of days
        expireTime += lExpireDays * oneDay;

        bExpireSource = TRUE;
    }

    //get source account state
    var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
    wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
    var = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
    wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
    // we will use the net APIs to disable the source account
    rc = NetUserGetInfo(strDomain, strAcct, 3, (LPBYTE *)&info);
    if (rc != 0) 
    {
        hr = S_FALSE;

        if (bDisableSource || bExpireSource || bSameAsSource)
        {
            if (pStats != NULL)
            {
                pStats->errors.users++;
            }

            err.SysMsgWrite(ErrE, rc, DCT_MSG_UNABLE_RETRIEVE_SOURCE_DISABLE_STATE_S, strAcct);

            if (bDisableSource || bExpireSource)
            {
                err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_DISABLE_OR_EXPIRE_FAILED_S, strAcct);
            }

            if (bSameAsSource)
            {
                err.MsgWrite(ErrE, DCT_MSG_CANNOT_ENABLEDISABLE_TARGET_SAMEASSOURCE_S, strAcct);
            }
        }
    }
    else
    {
        bGotSrcState = TRUE;

        //set current source account state
        if (info->usri3_flags & UF_ACCOUNTDISABLE)
            bSrcDisabled = TRUE;
        //also save the flags in the varset to be used in setpass ARExt
        _variant_t vtFlag = (long)info->usri3_flags;
        pVarSet->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags), vtFlag);

        //disable the source account if requested
        if (bDisableSource)
        {
            // Set the disable flag
            info->usri3_flags |= UF_ACCOUNTDISABLE;
        }

        //expire the account in given timeframe, if requested
        if ( bExpireSource )
        {
            if (((time_t)info->usri3_acct_expires == TIMEQ_FOREVER) 
                || ((time_t)info->usri3_acct_expires > expireTime))
            {
                info->usri3_acct_expires = (DWORD)expireTime;
            }
        }

        //if changed, set the source information into the Domain.
        if (bDisableSource || bExpireSource)
        {
            rc = NetUserSetInfo(strDomain,strAcct, 3, (LPBYTE)info, &paramErr);

            if (rc == NERR_Success)
            {
                if (bDisableSource)
                {
                    err.MsgWrite(0, DCT_MSG_SOURCE_DISABLED_S, strAcct);
                }

                if ( bExpireSource )
                {
                    if (((time_t)info->usri3_acct_expires == TIMEQ_FOREVER) ||
                        ((time_t)info->usri3_acct_expires > expireTime))
                    {
                        err.MsgWrite(0, DCT_MSG_SOURCE_EXPIRED_S, strAcct);
                    }
                    else
                    {
                        err.MsgWrite(0, DCT_MSG_SOURCE_EXPIRATION_EARLY_S, strAcct);
                    }
                }
            }
            else
            {
                if (pStats != NULL)
                    pStats->errors.users++;
                err.SysMsgWrite(ErrE, rc, DCT_MSG_ACCOUNT_DISABLE_OR_EXPIRE_FAILED_S, strAcct);
            }
        }
        NetApiBufferFree((LPVOID) info);
    }//if got current src account state


    /* process the target account */
    //get the target state
    var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
    wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
    var = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
    wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
    // we will use the net APIs to disable the target account
    rc = NetUserGetInfo(strDomain, strAcct, 3, (LPBYTE *)&info);

    if (rc != NERR_Success) 
    {
        hr = S_FALSE;
        if (pStats != NULL)
            pStats->errors.users++;
        err.SysMsgWrite(ErrE, rc, DCT_MSG_DISABLE_TARGET_FAILED_S, strAcct);
    }
    else
    {
        //disable the target if requested
        if (bDisableTarget)
        {
            // Set the disable flag
            info->usri3_flags |= UF_ACCOUNTDISABLE;
            // Set the information into the Domain.
            rc = NetUserSetInfo(strDomain, strAcct, 3, (LPBYTE)info, &paramErr);

            if (rc == NERR_Success)
            {
                err.MsgWrite(0, DCT_MSG_TARGET_DISABLED_S, strAcct);
            }
            else
            {
                if (pStats != NULL)
                    pStats->errors.users++;
                err.SysMsgWrite(ErrE, rc, DCT_MSG_DISABLE_TARGET_FAILED_S, strAcct);
            }
        }
        //else make target same state as source was
        else if (bSameAsSource) 
        {
            //if the source was disabled or unable to retrieve source state, disable the target
            if (bSrcDisabled || !bGotSrcState)
            {
                //disable the target
                info->usri3_flags |= UF_ACCOUNTDISABLE;
                // Set the information into the Domain.
                rc = NetUserSetInfo( strDomain, strAcct, 3, (LPBYTE)info, &paramErr);

                if (rc == NERR_Success)
                {
                    err.MsgWrite(0, DCT_MSG_TARGET_DISABLED_S, strAcct);
                }
                else
                {
                    if (pStats != NULL)
                        pStats->errors.users++;
                    err.SysMsgWrite(ErrE, rc, DCT_MSG_DISABLE_TARGET_FAILED_S, strAcct);
                }
            }
            else //else make sure target is enabled and not set to expire
            {
                info->usri3_flags &= ~UF_ACCOUNTDISABLE;
                rc = NetUserSetInfo(strDomain,strAcct,3,(LPBYTE)info,&paramErr);

                if (rc != NERR_Success)
                {
                    if (pStats != NULL)
                        pStats->warnings.users++;
                    err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_TARGET_FAILED_S, strAcct);
                }
            }
        }
        else //else make sure target is enabled and not set to expire
        {
            info->usri3_flags &= ~UF_ACCOUNTDISABLE;
            rc = NetUserSetInfo(strDomain,strAcct,3,(LPBYTE)info,&paramErr);

            if (rc != NERR_Success)
            {
                if (pStats != NULL)
                    pStats->warnings.users++;
                err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_TARGET_FAILED_S, strAcct);
            }
        }
        NetApiBufferFree((LPVOID) info);
    }

    return hr;
}


//---------------------------------------------------------------------------
// ProcessUndo : This function Enables the accounts that were previously 
//               disabled..
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::ProcessUndo(                                             
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
    IVarSetPtr                pVarSet = pMainSettings;
    IIManageDBPtr             pDb = pVarSet->get(GET_BSTR(DCTVS_DBManager));
    _variant_t                var;
    DWORD                     paramErr;
    USER_INFO_3             * info;
    long                      rc;
    WCHAR                     strDomain[LEN_Path];
    WCHAR                     strAcct[LEN_Path];
    HRESULT                   hr = S_OK;
    TErrorDct                 err;
    IUnknown                * pUnk = NULL;
    _bstr_t                   sSourceName, sSourceDomain, sTgtDomain;
    WCHAR                     fileName[LEN_Path];
    IVarSetPtr                pVs(__uuidof(VarSet));
    _variant_t                vtExp, vtFlag;
    _bstr_t                   sDomainName = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));

    pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);

    sSourceName = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
    sSourceDomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
    sTgtDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

    hr = pDb->raw_GetUserProps(sSourceDomain, sSourceName, &pUnk);
    if ( pUnk ) pUnk->Release();

    if ( hr == S_OK )
    {
        vtExp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_ExpDate));      
        vtFlag = pVs->get(GET_BSTR(DCTVS_CopiedAccount_UserFlags));      
    }

    // Get the Error log filename from the Varset
    var = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
    wcscpy(fileName, (WCHAR*)V_BSTR(&var));
    VariantInit(&var);
    // Open the error log
    err.LogOpen(fileName, 1);

    // Check if the object is of user type. if not then there is no point in disabling that account.
    var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Type));
    if ( _wcsicmp((WCHAR*)V_BSTR(&var),L"user") != 0 && _wcsicmp((WCHAR*)V_BSTR(&var),L"inetOrgPerson") != 0 )
        return S_OK;

    _bstr_t sDis = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
    _bstr_t sExp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));


    if ( !wcscmp((WCHAR*)sDis,GET_STRING(IDS_YES)) || sExp.length() )
    {
        // Reset the flag and the expiration date for the source account.
        var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
        wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
        var = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
        wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
        // we will use the net APIs to disable the source account
        rc = NetUserGetInfo( strDomain, strAcct, 3, (LPBYTE *)&info);
        if (rc != NERR_Success) 
        {
            hr = S_FALSE;
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_SOURCE_FAILED_S, strAcct);
        }
        else
        {
            // Set the disable flag
            info->usri3_flags = vtFlag.lVal;
            info->usri3_acct_expires = vtExp.lVal;
            // Set the information into the Domain.
            rc = NetUserSetInfo(strDomain,strAcct, 3, (LPBYTE)info, &paramErr);
            NetApiBufferFree((LPVOID) info);

            if (rc == NERR_Success)
            {
                err.MsgWrite(0, DCT_MSG_SOURCE_ENABLED_S, strAcct);
            }
            else
            {
                if (pStats != NULL)
                    pStats->warnings.users++;
                err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_SOURCE_FAILED_S, strAcct);
            }
        }
    }

    // Process the target account if the Varset is set
    var = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
    if ( (var.vt == VT_BSTR) && (_wcsicmp((WCHAR*)V_BSTR(&var),GET_STRING(IDS_YES)) == 0) )
    {
        var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
        wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
        var = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
        wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
        // we will use the net APIs to disable the target account
        rc = NetUserGetInfo( strDomain, strAcct, 3, (LPBYTE *)&info);
        if (rc != NERR_Success)
        {
            hr = S_FALSE;
            if (pStats != NULL)
                pStats->warnings.users++;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_TARGET_FAILED_S, strAcct);
        }
        else
        {
            // clear the disable flag
            info->usri3_flags &= ~(UF_ACCOUNTDISABLE);
            // Set the information into the Domain.
            rc = NetUserSetInfo( strDomain, strAcct, 3, (LPBYTE)info, &paramErr);
            NetApiBufferFree((LPVOID) info);

            if (rc == NERR_Success)
            {
                err.MsgWrite(0, DCT_MSG_TARGET_ENABLED_S, strAcct);
            }
            else
            {
                if (pStats != NULL)
                    pStats->warnings.users++;
                err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_TARGET_FAILED_S, strAcct);
            }
        }
    }
    WCHAR                     sFilter[5000];
    wsprintf(sFilter, L"SourceDomain='%s' and SourceSam='%s'", (WCHAR*)sDomainName, strAcct);
    _variant_t Filter = sFilter;
    pDb->raw_ClearTable(L"UserProps", Filter);

    err.LogClose();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\acctdis.cpp ===
// DisableTargetAccount.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DisableTargetAccountps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AcctDis.h"

#include "AcctDis_i.c"
#include "DisAcct.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DisableTarget, CDisableTarget)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ATLTRACE(_T("{DisableTargetAccount.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_DISABLETARGETACCOUNTLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ATLTRACE(_T("{DisableTargetAccount.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\addtogrp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_)
#define AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "GetRids_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\disacct\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GetRids.rc
//
#define IDS_PROJNAME                    100
#define IDS_RIDSAVE_DESC                101
#define IDR_RidSave                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\ridsave.h ===
// RidSave.h: Definition of the RidSave class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_)
#define AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// RidSave

class RidSave : 
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_GETRIDSLib>, 
	public ISupportErrorInfoImpl<&IID_IExtendAccountMigration>,
	public CComObjectRoot,
	public CComCoClass<RidSave,&CLSID_RidSave>
{
public:
	RidSave() 
   {
      m_sName = L"Get Rids";
      m_sDesc = L"Extension that gathers the RID for the source and target accounts.";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
   }
BEGIN_COM_MAP(RidSave)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(RidSave) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_RidSave)

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif // !defined(AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\getrids.cpp ===
// GetRids.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for GetRids.idl by adding the following 
//      files to the Outputs.
//          GetRids_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f GetRidsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "GetRids.h"
#include "dlldatax.h"

#include "GetRids_i.c"
#include "RidSave.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RidSave, RidSave)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{GetRids.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_GETRIDSLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{GetRids.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\ridsave.cpp ===
// RidSave.cpp : Implementation of CGetRidsApp and DLL registration.

#include "stdafx.h"
#include "GetRids.h"
#include "RidSave.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include <iads.h>
#include <AdsHlp.h>
#include "resstr.h"
#include "TxtSid.h"

#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif


/////////////////////////////////////////////////////////////////////////////
// RidSave
StringLoader   gString;

DWORD __stdcall GetRidFromVariantSid(const _variant_t& vntSid);

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
    return S_OK;
}

STDMETHODIMP RidSave::put_sName(BSTR newVal)
{
   m_sName = newVal;
    return S_OK;
}

STDMETHODIMP RidSave::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
    return S_OK;
}

STDMETHODIMP RidSave::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
    return S_OK;
}


//---------------------------------------------------------------------------
// PreProcessObject
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::PreProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
    IVarSetPtr                pVs = pMainSettings;
    VARIANT                   var;
    _bstr_t                   sTemp;
    IADsPtr                   pAds;
    HRESULT                   hr = S_OK;
    DWORD                     rid = 0; // default to 0, if RID not found   
    // We need to process users and groups only
    sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
    if (!sTemp.length())
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    if ( _wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"inetOrgPerson") && _wcsicmp((WCHAR*)sTemp,L"group") ) 
        return S_OK;

    //Get the IADs pointer to manipulate properties
    pAds = pSource;

    if ( pAds )
    {
        VariantInit(&var);
        hr = pAds->Get(_bstr_t(L"objectSID"),&var);

        if ( SUCCEEDED(hr) )
        {
            // retrieve the RID
            rid = GetRidFromVariantSid(_variant_t(var, false));
        }
    }

    // save the RID
    pVs->put(GET_BSTR(DCTVS_CopiedAccount_SourceRID),(long)rid);
    return hr;
}

//---------------------------------------------------------------------------
// ProcessObject
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::ProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
    IVarSetPtr                pVs = pMainSettings;
    VARIANT                   var;
    _bstr_t                   sTemp;
    IADsPtr                   pAds;
    HRESULT                   hr = S_OK;
    DWORD                     rid = 0; // default to 0, if RID not found   
    // We need to process users and groups only
    sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
    if ( _wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"inetOrgPerson") && _wcsicmp((WCHAR*)sTemp,L"group") ) 
    {
        return S_OK;
    }

    //Get the IADs pointer to manipulate properties
    pAds = pTarget;

    if (pAds)
    {
        VariantInit(&var);
        hr = pAds->Get(_bstr_t(L"objectSID"),&var);

        if ( SUCCEEDED(hr) )
        {
            // retrieve the RID
            rid = GetRidFromVariantSid(_variant_t(var, false));
        }
    }

    // save the RID
    pVs->put(GET_BSTR(DCTVS_CopiedAccount_TargetRID),(long)rid);
    return hr;
}


//---------------------------------------------------------------------------
// ProcessUndo
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
    HRESULT hr = S_OK;

    IVarSetPtr spSettings(pMainSettings);

    if (spSettings)
    {
        //
        // Update RID for undo of intra-forest moves only as the
        // target object will receive a new RID in this case.
        //

        _bstr_t strIntraForest = spSettings->get(GET_BSTR(DCTVS_Options_IsIntraforest));

        if (strIntraForest == GET_BSTR(IDS_YES))
        {
            //
            // Update RID if target object exists.
            //

            IADsPtr spTarget(pTarget);

            if (spTarget)
            {
                //
                // Update RID only for user and group objects.
                //

                _bstr_t strType = spSettings->get(GET_BSTR(DCTVS_CopiedAccount_Type));
                PCWSTR pszType = strType;

                bool bTypeValid =
                    pszType &&
                    ((_wcsicmp(pszType, L"user") == 0) ||
                    (_wcsicmp(pszType, L"inetOrgPerson") == 0) ||
                    (_wcsicmp(pszType, L"group") == 0));

                if (bTypeValid) 
                {
                    //
                    // Retrieve RID of object.
                    //

                    VARIANT var;
                    VariantInit(&var);
                    hr = spTarget->Get(_bstr_t(L"objectSID"), &var);

                    if (SUCCEEDED(hr))
                    {
                        DWORD dwRid = GetRidFromVariantSid(_variant_t(var, false));
                        spSettings->put(GET_BSTR(DCTVS_CopiedAccount_TargetRID), static_cast<long>(dwRid));
                    }
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//------------------------------------------------------------------------------
// GetRidFromVariantSid Function
//
// Synopsis
// Retrieves the final RID from a SID in variant form.
//
// Arguments
// IN vntSid - SID as an array of bytes (this is the form received from ADSI)
//
// Return
// The RID value if successful or zero if not.
//------------------------------------------------------------------------------

DWORD __stdcall GetRidFromVariantSid(const _variant_t& vntSid)
{
    DWORD dwRid = 0;

    if ((V_VT(&vntSid) == (VT_ARRAY|VT_UI1)) && vntSid.parray)
    {
        PSID pSid = (PSID)vntSid.parray->pvData;

        if (IsValidSid(pSid))
        {
            PUCHAR puch = GetSidSubAuthorityCount(pSid);
            DWORD dwCount = static_cast<DWORD>(*puch);
            DWORD dwIndex = dwCount - 1;
            PDWORD pdw = GetSidSubAuthority(pSid, dwIndex);
            dwRid = *pdw;
        }
    }

    return dwRid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\getrids\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED_)
#define AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "ScmMigr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\crypt.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    crypt.hxx

Abstract:

    CSecureString: Encrypted string for holding passwords

History:

    12-April-2002    MattRim     Created
    6-June-2002      MattRim     Adapted for ADMT use

--*/


#include "stdafx.h"
#include <wincrypt.h>
#include <comutil.h>
#include "crypt.hxx"

#define BAIL() goto exit;

CSecureString::CSecureString() :
    m_fEncrypted(false),
    m_fEmpty(true),
    m_pszUnencryptedString(NULL)
{
    m_EncryptedData.pbData = NULL;
    m_EncryptedData.cbData = 0;

    return;
}


CSecureString::~CSecureString()
{
    Reset();

    return;
}


void
CSecureString::Reset()
{
    if (m_pszUnencryptedString) {

        SecureZeroMemory(m_pszUnencryptedString, wcslen(m_pszUnencryptedString) * sizeof(WCHAR));
        delete [] m_pszUnencryptedString;
        m_pszUnencryptedString = NULL;
    }

    if (m_EncryptedData.pbData) {

        SecureZeroMemory(m_EncryptedData.pbData, m_EncryptedData.cbData);
        LocalFree(m_EncryptedData.pbData);

        m_EncryptedData.pbData = NULL;
        m_EncryptedData.cbData = 0;
    }

    m_fEmpty = true;

    return;
}

CSecureString& 
CSecureString::operator=(const CSecureString& rhs)
{
    bool fSucceeded = false;

    //
    // Free up our existing contents and reset to an empty state
    //
    Reset();
    

    //
    // Copy the object
    //
    m_fEncrypted = rhs.m_fEncrypted;
    m_fEmpty = rhs.m_fEmpty;

    if (rhs.m_pszUnencryptedString) {

        m_pszUnencryptedString = new WCHAR[wcslen(rhs.m_pszUnencryptedString)+1];
        if (!m_pszUnencryptedString) {
            
            BAIL();
        }

        wcscpy(m_pszUnencryptedString, rhs.m_pszUnencryptedString);
    }


    if (rhs.m_EncryptedData.pbData) {

        m_EncryptedData.pbData = new BYTE[rhs.m_EncryptedData.cbData];
        if (!m_EncryptedData.pbData) {

            BAIL();
        }

        m_EncryptedData.cbData = rhs.m_EncryptedData.cbData;
        memcpy(m_EncryptedData.pbData, rhs.m_EncryptedData.pbData, rhs.m_EncryptedData.cbData);
    }

    fSucceeded = true;

exit:

    if (!fSucceeded) {

        Reset();
        _com_issue_error(E_OUTOFMEMORY);
    }

    return *this;
}


CSecureString& 
CSecureString::operator=(const PWCHAR& rhs)
{
    bool fSucceeded = false;

    //
    // Free up our existing contents and reset to an empty state
    //
    Reset();

    //
    // If we're being set to an empty string, nothing much
    // to do.
    //

    if (rhs == NULL || rhs[0] == L'\0') {

        // we're done, empty string
        return *this;
    }

    //
    // Non-empty string, do the encryption
    //
    if (GenerateEncryptedData(rhs)) {

        fSucceeded = true;
    }


    if (!fSucceeded) {

        Reset();
        _com_issue_error(E_OUTOFMEMORY);
    }

    m_fEncrypted = true;
    m_fEmpty = false;
    
    return *this;
}


bool 
CSecureString::Decrypt()
{

    DATA_BLOB DecryptedData = {0, NULL};
    DWORD dwStringLength = 0;

    bool fSuccess = false;

    //
    // Validate
    //

    // if already decrypted, or nothing to decrypt, nothing to do
    if (!m_fEncrypted || m_EncryptedData.pbData == NULL) {

        m_fEncrypted = false;
        fSuccess = true;
        BAIL();
    }


    //
    // Try to decrypt the data
    //
    if (!CryptUnprotectData(&m_EncryptedData,            // encrypted data
                            NULL,                        // description
                            NULL,                        // entropy
                            NULL,                        // reserved
                            NULL,                        // prompt structure
                            CRYPTPROTECT_UI_FORBIDDEN,   // no UI
                            &DecryptedData)) {

        BAIL()
    }


    //
    // Copy the decrypted string into m_pszUnencryptedString
    //
    dwStringLength = DecryptedData.cbData / sizeof(WCHAR);
    m_pszUnencryptedString = new WCHAR[dwStringLength];
    if (!m_pszUnencryptedString) {

        BAIL();
    }

    memcpy(m_pszUnencryptedString, DecryptedData.pbData, DecryptedData.cbData);

    m_fEncrypted = false;
    fSuccess = true;

exit:

    if (DecryptedData.pbData) {
    
        SecureZeroMemory (DecryptedData.pbData, DecryptedData.cbData);
        LocalFree(DecryptedData.pbData);
    }

    return fSuccess;
}


void 
CSecureString::ReleaseString()
{

    //
    // We always store an encrypted copy of the data, so this is basically a no-op.
    // We just need to destroy the unencrypted buffer.
    //

    if (m_pszUnencryptedString) {

        SecureZeroMemory(m_pszUnencryptedString, wcslen(m_pszUnencryptedString) * sizeof(WCHAR));
        delete [] m_pszUnencryptedString;
        m_pszUnencryptedString = NULL;
    }

    m_fEncrypted = true;

    return;
}


bool
CSecureString::GetString(PWCHAR *ppszString)
{

    *ppszString = NULL;

    if (m_fEncrypted) {

        if (!Decrypt()) {

            return false;
        }
    }

    *ppszString = m_pszUnencryptedString;

    return true;
}


bool 
CSecureString::GenerateEncryptedData(const PWCHAR pszSource)
{
    DATA_BLOB RawData = {0, NULL};
    bool fSuccess = false;

    _ASSERT(pszSource != NULL);

    RawData.pbData = reinterpret_cast<PBYTE>(const_cast<PWCHAR>(pszSource));
    RawData.cbData = (wcslen(pszSource)+1) * sizeof(WCHAR);

    if (!CryptProtectData(&RawData,                      // unencrypted data
                            L"",                        // description -- note: this cannot be NULL before XP
                            NULL,                        // entropy
                            NULL,                        // reserved
                            NULL,                        // prompt structure
                            CRYPTPROTECT_UI_FORBIDDEN | CRYPTPROTECT_LOCAL_MACHINE,   // flags
                            &m_EncryptedData)) {

        BAIL()
    }

    _ASSERT(m_EncryptedData.pbData != NULL);
    _ASSERT(m_EncryptedData.cbData != 0);

    fSuccess = true;

exit:

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
#define AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScmMigr.rc
//
#define IDS_PROJNAME                    100
#define IDR_SERVMIGR                    101
#define IDS_SVCMGR_DESC                 102
#define IDR_SvcMgr                      103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\scmmigr.cpp ===
// ScmMigr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ScmMigr.idl by adding the following 
//      files to the Outputs.
//          ScmMigr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ScmMigrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ScmMigr.h"
#include "dlldatax.h"

#include "ScmMigr_i.c"
#include "ServMigr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ServMigr, CServMigr)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCMMIGRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\servmigr.cpp ===
// ServMigr.cpp : Implementation of CServMigr
#include "stdafx.h"
#include "ScmMigr.h"
#include "ServMigr.h"
#include "ErrDct.hpp"
#include "ResStr.h"
#include "Common.hpp"
#include "PWGen.hpp"
#include "EaLen.hpp"
#include "TReg.hpp"
#include "TxtSid.h"
#include "ARExt_i.c"
#include "LsaUtils.h"
#include "crypt.hxx"
#include "GetDcName.h"

#include <lm.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <Sddl.h>

#include "folders.h"
using namespace nsFolders;

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
//#import "DBMgr.tlb" no_namespace, named_guids //already #imported in ServMigr.h
#import "WorkObj.tlb" no_namespace, named_guids

TErrorDct         err;
StringLoader      gString;

#define BLOCK_SIZE 160
#define BUFFER_SIZE 400

#define SvcAcctStatus_NotMigratedYet			0
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_Updated				      2
#define SvcAcctStatus_UpdateFailed			   4
#define SvcAcctStatus_NeverAllowUpdate       8

// these defines are for GetWellKnownSid
#define ADMINISTRATORS     1
#define SYSTEM             7

/////////////////////////////////////////////////////////////////////////////
// CServMigr

STDMETHODIMP CServMigr::ProcessUndo(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats)
{
   return E_NOTIMPL;
}

STDMETHODIMP CServMigr::PreProcessObject(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats)
{
   return S_OK;
}

STDMETHODIMP 
   CServMigr::ProcessObject(
      /*[in]*/ IUnknown     * pSource, 
      /*[in]*/ IUnknown     * pTarget, 
      /*[in]*/ IUnknown     * pMainSettings, 
      /*[in,out]*/IUnknown ** ppPropsToSet,
      /*[in,out]*/ EAMAccountStats* pStats
   )
{
    HRESULT                    hr = S_OK;
    WCHAR                      domAccount[500];
    WCHAR                      domTgtAccount[500];
    IVarSetPtr                 pVarSet(pMainSettings);
    IIManageDBPtr              pDB;
    _bstr_t                    logfile;
    _bstr_t                    srcComputer;
    _bstr_t                    tgtComputer;
    IVarSetPtr                 pData(CLSID_VarSet);
    IUnknown                 * pUnk = NULL;
    DWORD                      rc = 0;
    _bstr_t                    sIntraForest;
    BOOL                       bIntraForest = FALSE;
    USER_INFO_2              * uInfo = NULL;

    try { 
        logfile = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));

        if ( logfile.length() )
        {
            err.LogOpen(logfile,1);
        }

        pDB = pVarSet->get(GET_BSTR(DCTVS_DBManager));

        if ( pDB != NULL )
        {
            // Check to see if this account is referenced in the service accounts table
            m_strSourceDomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
            m_strSourceDomainFlat = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainFlat));
            m_strTargetDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
            m_strTargetDomainFlat = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainFlat));
            m_strSourceSam = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
            m_strTargetSam = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
            srcComputer = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
            tgtComputer = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
            sIntraForest = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));

            if ( ! UStrICmp((WCHAR*)sIntraForest,GET_STRING(IDS_YES)) )
            {
                // for intra-forest migration we are moving, not copying, so we don't need to update the password
                // Actually, it turns out that ChangeServiceConfig will not let us update just the service account
                // and not the passord, so we'll have to go ahead and change the password for the service ac
                //bIntraForest = TRUE;
            }
            //if the SAM account name has a " character in it, it cannot be a service
            //account, and therefore we leave
            if (wcschr((WCHAR*)m_strSourceSam, L'\"')) {
                return S_OK;
            }

            swprintf(domAccount,L"%s\\%s",(WCHAR*)m_strSourceDomainFlat,(WCHAR*)m_strSourceSam);
            swprintf(domTgtAccount,L"%s\\%s",(WCHAR*)m_strTargetDomainFlat,(WCHAR*)m_strTargetSam);
        }
    }
    catch (_com_error& ce) {
        hr = ce.Error();
        return hr;
    }
    catch (... )
    {
        return E_FAIL;
    }

    try { 
        hr = pData->QueryInterface(IID_IUnknown,(void**)&pUnk);

        if ( SUCCEEDED(hr) )
        {
            hr = pDB->raw_GetServiceAccount(_bstr_t(domAccount),&pUnk);
        }
    }
    catch (_com_error& ce) {

        if (pUnk)
            pUnk->Release();

        hr = ce.Error();
        return hr;
    }    
    catch ( ... )
    {
        if (pUnk)
            pUnk->Release();

        return E_FAIL;
    }

    try {
        if ( SUCCEEDED(hr) )
        {
            pData = pUnk;
            pUnk->Release();
            pUnk=NULL;
            // remove the password must change flag, if set
            DWORD                   parmErr = 0;
            WCHAR                   password[LEN_Password];
            long                    entries = pData->get("ServiceAccountEntries");

            if ( (entries != 0) && !bIntraForest ) // if we're moving the account, don't mess with its properties
            {
                //
                // Open password log file if it has not been already opened.
                //

                if (!m_bTriedToOpenFile)
                {
                    m_bTriedToOpenFile = true;

                    _bstr_t strPasswordFile = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));

                    if (m_passwordLog.LogOpen(strPasswordFile) == FALSE)
                    {
                        err.MsgWrite(ErrI, DCT_MSG_SERVICES_WILL_NOT_BE_UPDATED);

                        if (pStats != NULL)
                        {
                            pStats->errors.users++;
                        }
                    }
                }

                rc = NetUserGetInfo(tgtComputer,m_strTargetSam,2,(LPBYTE*)&uInfo);

                if ( ! rc )
                {
                    // generate a new, strong, 14 character password for this account, 
                    // and set the password to not expire
                    rc = EaPasswordGenerate(3,3,3,3,6,14,password,DIM(password));

                    if (!rc)
                    {
                        //
                        // Only set password to not expire if able
                        // to write password to password file.
                        //

                        if (m_passwordLog.IsOpen())
                        {
                            uInfo->usri2_flags |= (UF_DONT_EXPIRE_PASSWD);
                        }

                        uInfo->usri2_password = password;
                        rc = NetUserSetInfo(tgtComputer,m_strTargetSam,2,(LPBYTE)uInfo,&parmErr);

                        if ( ! rc )
                        {
                            if (m_passwordLog.IsOpen())
                            {
                                err.MsgWrite(0,DCT_MSG_REMOVED_PWDCHANGE_FLAG_S,(WCHAR*)m_strTargetSam);
                            }
                            err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)m_strTargetSam);
                            // write the password to the password log file and mark this account, so that the 
                            // SetPassword extension will not reset the password again.
                            pVarSet->put(GET_BSTR(DCTVS_CopiedAccount_DoNotUpdatePassword),m_strSourceSam);

                            //
                            // If password log is open then write password to file
                            // otherwise set error code so that services are not updated.
                            //

                            if (m_passwordLog.IsOpen())
                            {
                                m_passwordLog.MsgWrite(L"%ls,%ls",(WCHAR*)m_strTargetSam,password);
                            }
                            else
                            {
                                rc = ERROR_OPEN_FAILED;
                            }
                        }
                        else
                        {
                            if (pStats != NULL)
                                pStats->errors.users++;
                            err.SysMsgWrite(ErrE,rc,DCT_MSG_REMOVED_PWDCHANGE_FLAG_FAILED_SD,(WCHAR*)m_strTargetSam,rc);
                        }

                        uInfo->usri2_password = NULL;
                    }

                    NetApiBufferFree(uInfo);
                    uInfo = NULL;
                }
            }
            if (entries != 0 )
            {
                try { 
                    if ( ! rc )
                    {
                        WCHAR             strSID[200] = L"";
                        BYTE              sid[200];
                        WCHAR             sdomain[LEN_Domain];
                        SID_NAME_USE      snu;
                        DWORD             lenSid = DIM(sid);
                        DWORD             lenDomain = DIM(sdomain);
                        DWORD             lenStrSid = DIM(strSID);

                        if ( LookupAccountName(tgtComputer,m_strTargetSam,sid,&lenSid,sdomain,&lenDomain,&snu) )
                        {
                            if ( GetTextualSid(sid,strSID,&lenStrSid) )
                            {
                                // for each reference to the service account, update the SCM
                                // for intra-forest migration, don't update the password
                                if ( bIntraForest )
                                    UpdateSCMs(pData,domTgtAccount,NULL,strSID,pDB, pStats); 
                                else
                                    UpdateSCMs(pData,domTgtAccount,password,strSID,pDB, pStats);
                            }
                            else
                            {
                                if (pStats != NULL)
                                    pStats->errors.users++;
                                err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_CANNOT_FIND_ACCOUNT_SSD,m_strTargetSam,tgtComputer,GetLastError());
                            }
                        }
                        else
                        {
                            if (pStats != NULL)
                                pStats->errors.users++;
                            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_CANNOT_FIND_ACCOUNT_SSD,m_strTargetSam,tgtComputer,GetLastError());
                        }
                    }
                }
                catch (_com_error& ce) {

                    hr = ce.Error();
                    return hr;
                }  
                catch(...)
                {
                    return E_FAIL;
                }
            }
        }
        else
        {
            if (pStats != NULL)
                pStats->errors.users++;
            err.SysMsgWrite(ErrE,E_FAIL,DCT_MSG_DB_OBJECT_CREATE_FAILED_D,E_FAIL);
        }

        err.LogClose();
    }
    catch (_com_error& ce) {

        if (pUnk)
            pUnk->Release();

        if (uInfo)
            NetApiBufferFree(uInfo);

        hr = ce.Error();
        return hr;
    }  
    catch (... )
    {
        if (pUnk)
            pUnk->Release();

        if (uInfo)
            NetApiBufferFree(uInfo);

        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CServMigr::get_sDesc(/*[out, retval]*/ BSTR *pVal)
{
   (*pVal) = SysAllocString(L"Updates SCM entries for services using migrated accounts.");
   return S_OK;
}

STDMETHODIMP CServMigr::put_sDesc(/*[in]*/ BSTR newVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP CServMigr::get_sName(/*[out, retval]*/ BSTR *pVal)
{
   (*pVal) = SysAllocString(L"Generic Service Account Migration");
   return S_OK;
}

STDMETHODIMP CServMigr::put_sName(/*[in]*/ BSTR newVal)
{
   return E_NOTIMPL;
}

DWORD 
   CServMigr::DoUpdate(
      WCHAR const          * account,
      WCHAR const          * password,
      WCHAR const          * strSid,
      WCHAR const          * computer,
      WCHAR const          * service,
      BOOL                   bNeedToGrantLOS,
	  EAMAccountStats        *pStats
   )
{
    DWORD                     rc = 0;
    WCHAR   const           * ppassword = password;


    // if password is empty, set it to NULL
    if ( ppassword && ppassword[0] == 0 )  
    {
        ppassword = NULL;
    }
    else if ( !UStrCmp(password,L"NULL") )
    {
        ppassword = NULL;
    }
    // only try to update entries that we need to be updating
    // try to connect to the SCM on this machine

    SC_HANDLE          pScm = OpenSCManager(computer, NULL, SC_MANAGER_ALL_ACCESS );
    if ( pScm )
    {
        // grant the logon as a service right to the target account

        if ( bNeedToGrantLOS )
        {
            LSA_HANDLE hPolicy;
            NTSTATUS ntsStatus = OpenPolicy(
                const_cast<LPWSTR>(computer),
                POLICY_CREATE_ACCOUNT|POLICY_LOOKUP_NAMES,
                &hPolicy
            );
            rc = LsaNtStatusToWinError(ntsStatus);

            if (rc == ERROR_SUCCESS)
            {
                LSA_UNICODE_STRING lsausUserRights;
                InitLsaString(&lsausUserRights, _T("SeServiceLogonRight"));
                PSID pSid = SidFromString(strSid);

                if (pSid)
                {
                    ntsStatus = LsaAddAccountRights(hPolicy, pSid, &lsausUserRights, 1L);
                    rc = LsaNtStatusToWinError(ntsStatus);
                    FreeSid(pSid);
                }
                else
                {
                    rc = ERROR_OUTOFMEMORY;
                }

                LsaClose(hPolicy);
            }

            if ( rc )
            {
                if (pStats != NULL)
                    pStats->errors.users++;
                err.SysMsgWrite(ErrE,rc,DCT_MSG_LOS_GRANT_FAILED_SSD,
                    account,(WCHAR*)computer,rc);
            }
            else
            {
                err.MsgWrite(0,DCT_MSG_LOS_GRANTED_SS,
                    account,(WCHAR*)computer);
            }
        }

        SC_HANDLE         pService = OpenService(pScm,service,SERVICE_ALL_ACCESS);

        if ( pService )
        {
            int nCnt = 0;

            /* make sure the same user still starts this service */
            //get the source account names
            BOOL bSameAccount = TRUE;
            _bstr_t sSrcDom, sSrcSAM, sSrcUPN; 
            _bstr_t sSrcAccount = L"";
            _bstr_t sSrcAccountUPN = L"";

            //if not given src names (not migrating right now), get them
            if ((!m_strSourceDomainFlat) && (!m_strSourceSam))
            {
                //if got names, get UPN name also
                if (RetrieveOriginalAccount(sSrcDom, sSrcSAM))
                {
                    sSrcUPN = GetUPNName(sSrcSAM);
                    sSrcAccount = sSrcDom + _bstr_t(L"\\") + sSrcSAM;
                }
            }
            else //els if given src names (migrate this object now), use those names
            {
                sSrcDom = m_strSourceDomainFlat;
                sSrcSAM = m_strSourceSam;
                sSrcUPN = GetUPNName(sSrcSAM);
                sSrcAccount = sSrcDom + _bstr_t(L"\\") + sSrcSAM;
            }

            //if got names to check, check them
            if ((sSrcAccount.length()) || (sSrcUPN.length()))
            {
                BYTE                    buf[3000];
                QUERY_SERVICE_CONFIG  * pConfig = (QUERY_SERVICE_CONFIG *)buf; 
                DWORD                   lenNeeded = 0;
                // get the information about this service
                if (QueryServiceConfig(pService, pConfig, sizeof buf, &lenNeeded))
                {
                    //if not the same account, check UPN name or set to FALSE
                    if ((sSrcAccount.length()) && (UStrICmp(pConfig->lpServiceStartName,sSrcAccount)))
                    {
                        //if UPN name, try it
                        if (sSrcUPN.length())
                        {
                            //if not match either, set flag to FALSE;
                            if (UStrICmp(pConfig->lpServiceStartName,sSrcUPN))
                                bSameAccount = FALSE;
                        }
                        else  //else, not a match
                            bSameAccount = FALSE;
                    }
                }
            }//if got names

            //if same account, update the SCM
            if (bSameAccount)
            {
                // update the account and password for the service
                while ( !ChangeServiceConfig(pService,
                    SERVICE_NO_CHANGE, // dwServiceType
                    SERVICE_NO_CHANGE, // dwStartType
                    SERVICE_NO_CHANGE, // dwErrorControl
                    NULL,              // lpBinaryPathName
                    NULL,              // lpLoadOrderGroup
                    NULL,              // lpdwTagId
                    NULL,              // lpDependencies
                    account, // lpServiceStartName
                    ppassword,   // lpPassword
                    NULL) && nCnt < 5)       // lpDisplayName
                {
                    nCnt++;
                    Sleep(500);
                }
                if ( nCnt < 5 )
                {
                    err.MsgWrite(0,DCT_MSG_UPDATED_SCM_ENTRY_SS,(WCHAR*)computer,(WCHAR*)service);
                }
                else
                {
                    rc = GetLastError();
                }
            }//end if still same account
            else //else if not same user, put message in log and return error
            {
                err.MsgWrite(0,DCT_MSG_UPDATE_SCM_ENTRY_UNMATCHED_SSD,(WCHAR*)computer,(WCHAR*)service,(WCHAR*)sSrcAccount);
                rc = DCT_MSG_UPDATE_SCM_ENTRY_UNMATCHED_SSD;
            }

            CloseServiceHandle(pService);
        }
        CloseServiceHandle(pScm);
    }
    else
    {
        rc = GetLastError();
    }
    return rc;
}

BOOL 
   CServMigr::UpdateSCMs(
      IUnknown             * pVS,
      WCHAR const          * account, 
      WCHAR const          * password, 
      WCHAR const          * strSid,
      IIManageDB           * pDB,
	  EAMAccountStats      * pStats
   )
{
   BOOL                      bGotThemAll = TRUE;
   IVarSetPtr                pVarSet = pVS;
   LONG                      nCount = 0;
   WCHAR                     key[LEN_Path];            
   _bstr_t                   computer;
   _bstr_t                   service;
   long                      status;
   DWORD                     rc = 0;
   BOOL                      bFirst = TRUE;
   WCHAR                     prevComputer[LEN_Path] = L"";
   try  {
      nCount = pVarSet->get("ServiceAccountEntries");
      
      for ( long i = 0 ; i < nCount ; i++ )
      {
         
         swprintf(key,L"Computer.%ld",i);
         computer = pVarSet->get(key);
         swprintf(key,L"Service.%ld",i);
         service = pVarSet->get(key);
         swprintf(key,L"ServiceAccountStatus.%ld",i);
         status = pVarSet->get(key);
         
         if ( status == SvcAcctStatus_NotMigratedYet || status == SvcAcctStatus_UpdateFailed )
         {
            if ( UStrICmp(prevComputer,(WCHAR*)computer) )
            {
               bFirst = TRUE; // reset the 'first' flag when the computer changes
            }
            try {
               rc = DoUpdate(account,password,strSid,computer,service,bFirst/*only grant SeServiceLogonRight once per account*/,
				             pStats);
               bFirst = FALSE;
               safecopy(prevComputer,(WCHAR*)computer);
            }
            catch (...)
            {
                // Do we need to trigger the counter increment here?
                // if (pStats != NULL)
                //    pStats->errors.users++;
               err.DbgMsgWrite(ErrE,L"Exception!");
               err.DbgMsgWrite(0,L"Updating %ls on %ls",(WCHAR*)service,(WCHAR*)computer);
               err.DbgMsgWrite(0,L"Account=%ls, SID=%ls",(WCHAR*)account,(WCHAR*)strSid);
               rc = E_FAIL;
            }
            if (! rc )
            {
               // the update was successful
               pDB->raw_SetServiceAcctEntryStatus(computer,service,_bstr_t(account),SvcAcctStatus_Updated); 
            }
            else
            {
               // couldn't connect to this one -- we will need to save this account's password
               // in our encrypted storage
               pDB->raw_SetServiceAcctEntryStatus(computer,service,NULL,SvcAcctStatus_UpdateFailed);
               bGotThemAll = FALSE;
               SaveEncryptedPassword(computer,service,account,password);
               //if the current service account didn't match, we need not log an error 
               if (rc != DCT_MSG_UPDATE_SCM_ENTRY_UNMATCHED_SSD)
                {
                    err.SysMsgWrite(ErrE,rc,DCT_MSG_UPDATE_SCM_ENTRY_FAILED_SSD,(WCHAR*)computer,(WCHAR*)service,rc);
                    pStats->errors.users++;
                }
            }
         }
		    //else if skipping, still log in file so we can update later
	     else if (status == SvcAcctStatus_DoNotUpdate)
            SaveEncryptedPassword(computer,service,account,password);
      }
   }
   catch ( ... )
   {
    // Do we need to trigger the counter increment here?
    // if (pStats != NULL)
    //    pStats->errors.users++;
      err.DbgMsgWrite(ErrE,L"Exception!");
   }
   return bGotThemAll;
}

HRESULT 
   CServMigr::SaveEncryptedPassword(
      WCHAR          const * server,
      WCHAR          const * service,
      WCHAR          const * account,
      WCHAR          const * password
   )
{
	HRESULT hr = S_OK;
	TNodeListEnum e;
	TEntryNode* pNode;

	// if entry exists...

	for (pNode = (TEntryNode*)e.OpenFirst(&m_List); pNode; pNode = (TEntryNode*)e.Next())
	{
		if (_wcsicmp(pNode->GetComputer(), server) == 0)
		{
			if (_wcsicmp(pNode->GetService(), service) == 0)
			{
				if (_wcsicmp(pNode->GetAccount(), account) == 0)
				{
					// update password
					try {
						pNode->SetPassword(password);
					}
					catch (_com_error& ce) {
						hr = ce.Error();
						return hr;
					}
					break;
				}
			}
		}
	}

	// else...

	if (pNode == NULL)
	{
		// insert new entry

		try {
			pNode = new TEntryNode(server, service, account, password);
		}
		catch (_com_error& ce) {

			hr = ce.Error();
			return hr;
		}

		if (pNode)
		{
			m_List.InsertBottom(pNode);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
///
/// TEntryList implementation of secure storage for service account passwords 
///
///
//////////////////////////////////////////////////////////////////////////////////////

DWORD 
   TEntryList::LoadFromFile(WCHAR const * filename)
{
    DWORD                     rc = 0;

    FILE                    * hSource = NULL;

    HCRYPTPROV                hProv = 0;
    HCRYPTKEY                 hKey = 0;

    BYTE                      pbBuffer[BLOCK_SIZE];
    WCHAR                     strData[BLOCK_SIZE * 5] = { 0 };
    DWORD                     dwCount;
    int                       eof = 0;
    WCHAR                     fullpath[LEN_Path];

    BYTE *pbKeyBlob = NULL;
    DWORD dwBlobLen;

    // Get our install directory from the registry, and then append the filename
    HKEY           hRegKey;
    DWORD          type;
    DWORD          lenValue = (sizeof fullpath);

    rc = RegOpenKey(HKEY_LOCAL_MACHINE,REGKEY_ADMT,&hRegKey);
    if ( ! rc )
    {

        rc = RegQueryValueEx(hRegKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
        if (! rc )
        {
            UStrCpy(fullpath+UStrLen(fullpath),filename);
        }
        RegCloseKey(hRegKey);
    }

    if (rc != ERROR_SUCCESS)
    {
        goto done;
    }


    // Open the source file.
    if((hSource = _wfopen(fullpath,L"rb"))==NULL) 
    {
        rc = GetLastError();
        goto done;
    }

    // acquire handle to key container which must exist
    if ((hProv = AcquireContext(true)) == 0)
    {
        rc = GetLastError();
        goto done;
    }

    // Read the key blob length from the source file and allocate it to memory.
    fread(&dwBlobLen, sizeof(DWORD), 1, hSource);
    if(ferror(hSource) || feof(hSource)) 
    {
        rc = GetLastError();
        goto done;
    }

    if((pbKeyBlob = (BYTE*)malloc(dwBlobLen)) == NULL) 
    {
        rc = GetLastError();
        goto done;
    }

    // Read the key blob from the source file.
    fread(pbKeyBlob, 1, dwBlobLen, hSource);
    if(ferror(hSource) || feof(hSource)) 
    {
        rc = GetLastError();
        goto done;
    }

    // Import the key blob into the CSP.
    if(!CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &hKey)) 
    {
        rc = GetLastError();
        goto done;
    }

    // Decrypt the source file and load the list
    do {
        // Read up to BLOCK_SIZE bytes from source file.
        dwCount = fread(pbBuffer, 1, BLOCK_SIZE, hSource);
        if(ferror(hSource)) 
        {
            rc = GetLastError();
            goto done;
        }
        eof=feof(hSource);

        // Decrypt the data.
        if(!CryptDecrypt(hKey, 0, eof, 0, pbBuffer, &dwCount)) 
        {
            rc = GetLastError();
            goto done;
        }
        // Read any complete entries from the buffer
        // first, add the buffer contents to any leftover information we had read from before
        WCHAR               * curr = strData;
        long                  len = UStrLen(strData);
        WCHAR               * nl = NULL;
        WCHAR                 computer[LEN_Computer];
        WCHAR                 service[LEN_Service];
        WCHAR                 account[LEN_Account];
        WCHAR                 password[LEN_Password];

        wcsncpy(strData + len,(WCHAR*)pbBuffer, dwCount / sizeof(WCHAR));
        strData[len + (dwCount / sizeof(WCHAR))] = 0;
        do {

            nl = wcschr(curr,L'\n');
            if ( nl )
            {
                *nl = 0;
                if ( swscanf(curr,L" %[^\t]\t%[^\t]\t%[^\t]\t%[^\t]\n",computer,service,account,password) )
                {
                    TEntryNode * pNode = NULL;
                    try {
                        pNode = new TEntryNode(computer,service,account,password);
                    }
                    catch (_com_error& ce) {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
                        goto done;
                    }

                    InsertBottom(pNode);
                }
                else 
                {
                    rc = E_FAIL;
                    break;
                }
                // go on to the next entry
                curr = nl + 1;
            }

        } while ( nl );
        // there may be a partial record left in the buffer
        // if so, save it for the next read
        if ( (*curr) != 0 )
        {
            memmove(strData,curr,( 1 + UStrLen(curr) ) * (sizeof WCHAR));
        }
        else
        {
            strData[0] = L'\0';
        }


    } while(!feof(hSource));


done:

    // Clean up
    if(pbKeyBlob) 
        free(pbKeyBlob);


    if(hKey != 0) 
        CryptDestroyKey(hKey);


    if(hProv != 0) 
        CryptReleaseContext(hProv, 0);


    if(hSource != NULL) 
        fclose(hSource);

    return rc;
}

DWORD 
   TEntryList::SaveToFile(WCHAR const * filename)
{
    DWORD                     rc = 0;
    BYTE                      pbBuffer[BUFFER_SIZE];
    DWORD                     dwCount;
    HANDLE                    hDest = INVALID_HANDLE_VALUE;
    BYTE                    * pbKeyBlob = NULL;
    DWORD                     dwBlobLen;
    HCRYPTPROV                hProv = 0;
    HCRYPTKEY                 hKey = 0;
    HCRYPTKEY                 hXchgKey = 0;
    TEntryNode              * pNode;
    TNodeListEnum             e;
    WCHAR                     fullpath[LEN_Path];
    DWORD                     dwBlockSize;
    DWORD                     cbBlockSize = sizeof(dwBlockSize);
    DWORD                     dwPaddedCount;
    DWORD                     cbWritten;

    // Open the destination file.
    HKEY           hRegKey;
    DWORD          type;
    DWORD          lenValue = (sizeof fullpath);

    rc = RegOpenKey(HKEY_LOCAL_MACHINE,REGKEY_ADMT,&hRegKey);
    if ( ! rc )
    {

        rc = RegQueryValueEx(hRegKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
        if (! rc )
        {
            UStrCpy(fullpath+UStrLen(fullpath),filename);
        }
        RegCloseKey(hRegKey);
    }

    if (rc != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Delete previous data file if it exists. This obviates the need to change the
    // security descriptor on the file as CreateFile does not apply the security
    // descriptor if the file is opened but only when created.
    //

    if (!DeleteFile(fullpath))
    {
        rc = GetLastError();

        if (rc == ERROR_FILE_NOT_FOUND)
        {
            rc = ERROR_SUCCESS;
        }
        else
        {
            goto done;
        }
    }

    //
    // Create security descriptor with administrators as owner and permissions on file
    // so that only administrators and system have full access to the file.
    //

    PSECURITY_DESCRIPTOR psd = NULL;

    BOOL bConvert = ConvertStringSecurityDescriptorToSecurityDescriptor(
        _T("O:BAD:P(A;NP;FA;;;BA)(A;NP;FA;;;SY)"),
        SDDL_REVISION_1,
        &psd,
        NULL
    );

    if (!bConvert)
    {
        rc = GetLastError();
        goto done;
    }

    //
    // Create file.
    //

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = psd;
    sa.bInheritHandle = FALSE;

    hDest = CreateFile(
        fullpath,
        GENERIC_WRITE,
        0,
        &sa,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    rc = GetLastError();

    if (psd)
    {
        LocalFree(psd);
    }

    if (hDest == INVALID_HANDLE_VALUE)
    {
        goto done;
    }

    // acquire handle to key container
    if ((hProv = AcquireContext(false)) == 0)
    {
        rc = GetLastError();
        goto done;
    }

    // Attempt to get handle to exchange key.
    if(!CryptGetUserKey(hProv,AT_KEYEXCHANGE,&hKey)) 
    {
        if(GetLastError()==NTE_NO_KEY) 
        {
            // Create key exchange key pair.
            if(!CryptGenKey(hProv,AT_KEYEXCHANGE,0,&hKey)) 
            {
                rc = GetLastError();
                goto done;
            } 
        } 
        else 
        {
            rc = GetLastError();
            goto done;
        }
    }
    CryptDestroyKey(hKey);
    CryptReleaseContext(hProv,0);

    // acquire handle to key container
    if ((hProv = AcquireContext(false)) == 0)
    {
        rc = GetLastError();
        goto done;
    }

    // Get a handle to key exchange key.
    if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hXchgKey)) 
    {
        rc = GetLastError();
        goto done;
    }

    // Create a random block cipher session key.
    if(!CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey)) 
    {
        rc = GetLastError();
        goto done;
    }

    // Determine the size of the key blob and allocate memory.
    if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &dwBlobLen)) 
    {
        rc = GetLastError();
        goto done;
    }

    if((pbKeyBlob = (BYTE*)malloc(dwBlobLen)) == NULL) 
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    // Export the key into a simple key blob.
    if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, 
        &dwBlobLen)) 
    {
        rc = GetLastError();
        free(pbKeyBlob);
        goto done;
    }

    // Write the size of the key blob to the destination file.

    if (!WriteFile(hDest, &dwBlobLen, sizeof(DWORD), &cbWritten, NULL))
    {
        rc = GetLastError();
        free(pbKeyBlob);
        goto done;
    }

    // Write the key blob to the destination file.

    if(!WriteFile(hDest, pbKeyBlob, dwBlobLen, &cbWritten, NULL)) 
    {
        rc = GetLastError();
        free(pbKeyBlob);
        goto done;
    }

    // Free memory.
    free(pbKeyBlob);

    // get key cipher's block length in bytes

    if (CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwBlockSize, &cbBlockSize, 0))
    {
        dwBlockSize /= 8;
    }
    else
    {
        rc = GetLastError();
        goto done;
    }

    // Encrypt the item list and write it to the destination file.

    for ( pNode = (TEntryNode*)e.OpenFirst(this); pNode ; pNode = (TEntryNode *)e.Next()  )
    {
        // copy an item into the buffer in the following format:
        // Computer\tService\tAccount\tPassword

        int cchWritten;
        const size_t BUFFER_SIZE_IN_WCHARS = sizeof(pbBuffer) / sizeof(wchar_t);
        wchar_t* pchLast = &(((wchar_t*)pbBuffer)[BUFFER_SIZE_IN_WCHARS - 1]);
        *pchLast = L'\0';

        const WCHAR * pszPwd = NULL;
        try {
            pszPwd = pNode->GetPassword();
        }
        catch (_com_error& ce) {
            rc = ERROR_DECRYPTION_FAILED;
            goto done;
        }
        
        
        if ( pszPwd && *pszPwd )

        {
            cchWritten = _snwprintf(
                (wchar_t*)pbBuffer,
                BUFFER_SIZE_IN_WCHARS,
                L"%s\t%s\t%s\t%s\n",
                pNode->GetComputer(),
                pNode->GetService(),
                pNode->GetAccount(),
                pszPwd
            );
        }
        else
        {
            cchWritten = _snwprintf(
                (wchar_t*)pbBuffer,
                BUFFER_SIZE_IN_WCHARS,
                L"%s\t%s\t%s\t%s\n",
                pNode->GetComputer(),
                pNode->GetService(),
                pNode->GetAccount(),
                L"NULL"
            );
        }

        pNode->ReleasePassword();
        pszPwd = NULL;


        if ((cchWritten < 0) || (*pchLast != L'\0'))
        {
            rc = ERROR_INSUFFICIENT_BUFFER;
            goto done;
        }

        dwCount = UStrLen((WCHAR*)pbBuffer) * (sizeof WCHAR) ;

        // the buffer must be a multiple of the key cipher's block length
        // NOTE: this algorithm assumes block length is multiple of sizeof(WCHAR)

        if (dwBlockSize > 0)
        {
            // calculate next multiple greater than count
            dwPaddedCount = ((dwCount + dwBlockSize - 1) / dwBlockSize) * dwBlockSize;

            // pad buffer with space characters

            WCHAR* pch = (WCHAR*)(pbBuffer + dwCount);

            for (; dwCount < dwPaddedCount; dwCount += sizeof(WCHAR))
            {
                *pch++ = L' ';
            }
        }

        // Encrypt the data.
        if(!CryptEncrypt(hKey, 0, (pNode->Next() == NULL) , 0, pbBuffer, &dwCount,
            BUFFER_SIZE))
        {
            rc = GetLastError();
            goto done;
        }

        // Write the data to the destination file.

        if(!WriteFile(hDest, pbBuffer, dwCount, &cbWritten, NULL)) 
        {
            rc = GetLastError();
            goto done;
        }
    }

done:

    // Destroy the session key.
    if(hKey != 0) CryptDestroyKey(hKey);

    // Destroy the key exchange key.
    if(hXchgKey != 0) CryptDestroyKey(hXchgKey);

    // Release the provider handle.
    if(hProv != 0) CryptReleaseContext(hProv, 0);

    // Close destination file.
    if(hDest != INVALID_HANDLE_VALUE) CloseHandle(hDest);

    return rc;
}


// AcquireContext Method
//
// acquire handle to key container within cryptographic service provider (CSP)
//

HCRYPTPROV TEntryList::AcquireContext(bool bContainerMustExist)
{
	HCRYPTPROV hProv = 0;

	#define KEY_CONTAINER_NAME _T("A69904BC349C4CFEAAEAB038BAB8C3B1")

	if (bContainerMustExist)
	{
		// first try Microsoft Enhanced Cryptographic Provider

		if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
		{
			if (GetLastError() == NTE_KEYSET_NOT_DEF)
			{
				// then try Microsoft Base Cryptographic Provider

				CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET);
			}
		}
	}
	else
	{
		// first try Microsoft Enhanced Cryptographic Provider

		if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
		{
			DWORD dwError = GetLastError();

			if ((dwError == NTE_BAD_KEYSET) || (dwError == NTE_KEYSET_NOT_DEF))
			{
				// then try creating key container in enhanced provider

				if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET))
				{
					dwError = GetLastError();

					if (dwError == NTE_KEYSET_NOT_DEF)
					{
						// then try Microsoft Base Cryptographic Provider

						if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
						{
							dwError = GetLastError();

							if ((dwError == NTE_BAD_KEYSET) || (dwError == NTE_KEYSET_NOT_DEF))
							{
								// finally try creating key container in base provider

								CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET);
							}
						}
					}
				}
			}
		}
	}

	return hProv;
}


STDMETHODIMP CServMigr::TryUpdateSam(BSTR computer,BSTR service,BSTR account)
{
   HRESULT                   hr = S_OK;
   
   // Find the entry in the list, and perform the update
   TNodeListEnum             e;
   TEntryNode              * pNode;
   BOOL                      bFound = FALSE;

   for ( pNode = (TEntryNode*)e.OpenFirst(&m_List) ; pNode ; pNode = (TEntryNode*)e.Next() )
   {
      if (  !UStrICmp(computer,pNode->GetComputer())
         && !UStrICmp(service,pNode->GetService()) 
         && !UStrICmp(account,pNode->GetAccount())
         )
      {
         // found it!
         bFound = TRUE;
         const WCHAR * pszPwd = NULL;
         try {
              pszPwd = pNode->GetPassword();
         }
         catch (_com_error& ce) {
            hr = ce.Error();
            break;
         }
         
         BSTR bstrPwd = SysAllocString(pszPwd);
         if ((bstrPwd == NULL) && pszPwd && pszPwd[0])
         {
            hr = E_OUTOFMEMORY;
            pNode->ReleasePassword();
            break;
         }
         
         hr = TryUpdateSamWithPassword(computer,service,account,bstrPwd );

         pNode->ReleasePassword();

         SecureZeroMemory(bstrPwd, wcslen(bstrPwd)*sizeof(WCHAR));
         SysFreeString(bstrPwd);

         break;
      }
   }
   
   if ( ! bFound )
   {
      hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
   }
   return hr;
}

STDMETHODIMP CServMigr::TryUpdateSamWithPassword(BSTR computer,BSTR service,BSTR domAccount,BSTR password)
{
   DWORD                     rc = 0;
   WCHAR                     domain[LEN_Domain];
   _bstr_t                   dc;
   WCHAR                     account[LEN_Account];
   WCHAR                     domStr[LEN_Domain];
   BYTE                      sid[100];
   WCHAR                     strSid[200];
   WCHAR                   * pSlash = wcschr(domAccount,L'\\');
   SID_NAME_USE              snu;
   DWORD                     lenSid = DIM(sid);
   DWORD                     lenDomStr = DIM(domStr);
   DWORD                     lenStrSid = DIM(strSid);

   // split out the domain and account names
   if ( pSlash )
   {
//      UStrCpy(domain,domAccount,pSlash - domAccount + 1);
      UStrCpy(domain,domAccount,(int)(pSlash - domAccount + 1));
      UStrCpy(account,pSlash+1);
      
      GetAnyDcName5(domain, dc);

      // get the SID for the target account
      if ( LookupAccountName(dc,account,sid,&lenSid,domStr,&lenDomStr,&snu) )
      {
         GetTextualSid(sid,strSid,&lenStrSid);

         rc = DoUpdate(domAccount,password,strSid,computer,service,TRUE, NULL);
      }
      else 
      {
         rc = GetLastError();
      }
   }
   else
   {
      rc = ERROR_NOT_FOUND;
   }

   return HRESULT_FROM_WIN32(rc);
}


BOOL                                       // ret - TRUE if directory found
   CServMigr::GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

	   rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

	   if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   key.Close();

   return bFound;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAY 2001                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the original      *
 * service account of the given migrated service account.  We use the*
 * target service account name and domain to lookup its source       *
 * account name and domain from the Migrated Objects table.          *
 *     This function returns TRUE or FALSE and if TRUE, fills in the *
 * given BSTRs for soure domain and source SAM name.                 *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveOriginalAccount
BOOL CServMigr::RetrieveOriginalAccount(_bstr_t &sSrcDom, _bstr_t &sSrcSAM)
{
    /* local constants */
    const long ONLY_ONE_MATCHED = 1;

    /* local variables */
    WCHAR			sTemp[MAX_PATH];
    BOOL				bSuccess = FALSE;
    IUnknown		  * pUnk = NULL;


    /* function body */

    try 
    { 
        IVarSetPtr		pVSMig(__uuidof(VarSet));
        IIManageDBPtr	pDb(__uuidof(IManageDB));
        //see if any target account fitting this SAM name and domain have been migrated
        pVSMig->QueryInterface(IID_IUnknown, (void**) &pUnk);
        HRESULT hrFind = pDb->raw_GetMigratedObjectsByTarget(m_strTargetDomain, m_strTargetSam, &pUnk);
        pUnk->Release();
        pUnk = NULL;
        //if migrated only one account to this name, then fill the return strings
        if (hrFind == S_OK)
        {
            //get objects number matching this description
            long nMatched = pVSMig->get(L"MigratedObjects");
            //if only one found, fill output strings
            if (nMatched == ONLY_ONE_MATCHED)
            {
                swprintf(sTemp,L"MigratedObjects.0.%s",GET_STRING(DB_SourceDomain));
                sSrcDom = pVSMig->get(sTemp);
                swprintf(sTemp,L"MigratedObjects.0.%s",GET_STRING(DB_SourceSamName));
                sSrcSAM = pVSMig->get(sTemp);
                bSuccess = TRUE;  //set success flag
            }//end if found only one
        }//end if found at least one
    }
    catch ( ... )
    {
        if (pUnk)
            pUnk->Release();

        bSuccess = false;
    }

    return bSuccess;
}
//END RetrieveOriginalAccount


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAY 2001                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the UPN name of   *
 * the given account.  The given account should be in NT4 format     *
 * (Domain\Username).  The return will be the UPN or empty if not    *
 * retrieved.                                                        *
 *                                                                   *
 *********************************************************************/

//BEGIN GetUPNName
_bstr_t CServMigr::GetUPNName(_bstr_t sSrcSAM)
{
    /* local variables */
    HRESULT         hr;
    _bstr_t			sUPN = L"";
    HANDLE          hDs = NULL;

    /* function body */

    //bind to the source domain
    DWORD dwError = DsBind(NULL,m_strSourceDomain,&hDs);

    //now try to call DSCrackNames to get the UPN name
    if ((dwError == ERROR_SUCCESS) && hDs)
    {
        PDS_NAME_RESULT         pNamesOut = NULL;
        WCHAR                 * pNamesIn[1];

        _bstr_t sSrcAccount = m_strSourceDomainFlat + _bstr_t(L"\\") + m_strSourceSam;
        pNamesIn[0] = (WCHAR*)sSrcAccount;
        hr = DsCrackNames(hDs,DS_NAME_NO_FLAGS,DS_NT4_ACCOUNT_NAME,DS_USER_PRINCIPAL_NAME,1,pNamesIn,&pNamesOut);
        DsUnBind(&hDs);
        hDs = NULL;
        //if got UPN name, store it
        if ( !hr )
        {
            if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
                sUPN = pNamesOut->rItems[0].pName;
            DsFreeNameResult(pNamesOut); //free the results
        }//end if cracked name
    }//end if bound

    return sUPN;
}
//END GetUPNName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\servmigr.h ===
// ServMigr.h : Declaration of the CServMigr

#ifndef __SERVMIGR_H_
#define __SERVMIGR_H_

#include "resource.h"       // main symbols
#include "TNode.hpp"
#include "EaLen.hpp"
#include "UString.hpp"
#include "ExtSeq.h"
#include <wincrypt.h>
#include "crypt.hxx"

#define LEN_Service     200
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids

#include "CommaLog.hpp"

class TEntryNode : public TNode
{
   WCHAR                     computer[LEN_Computer];
   WCHAR                     service[LEN_Service];
   WCHAR                     account[LEN_Account];
   CSecureString             cryptpassword;
public:
   TEntryNode(WCHAR const * c,WCHAR const * s,WCHAR const * a,WCHAR const* p)
   {
      safecopy(computer,c);
      safecopy(service,s);
      safecopy(account,a);
      cryptpassword = (p ? p: L""); // can throw exception
   }
   WCHAR const * GetComputer() { return computer; }
   WCHAR const * GetService() { return service; }
   WCHAR const * GetAccount() { return account; }
   WCHAR const * GetPassword()      // can throw exception
   {
      WCHAR* p;
      if (!cryptpassword.GetString(&p))
      {
          _com_issue_error(SEC_E_DECRYPT_FAILURE);
      }
      
      return p;
   }
   void const ReleasePassword() { cryptpassword.ReleaseString(); }
   void SetPassword(WCHAR const* p) { cryptpassword = (p ? p: L""); }   // can throw exception
};

class TEntryList : public TNodeList
{
   WCHAR                     file[LEN_Path];
public:
   TEntryList(WCHAR const * filename) { safecopy(file,filename); LoadFromFile(file);  }
   DWORD LoadFromFile(WCHAR const * filename);
   DWORD SaveToFile(WCHAR const * filename);
   ~TEntryList() { SaveToFile(file); DeleteAllListItems(TEntryNode); }
private:
   HCRYPTPROV AcquireContext(bool bContainerMustExist);
};


/////////////////////////////////////////////////////////////////////////////
// CServMigr
class ATL_NO_VTABLE CServMigr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CServMigr, &CLSID_ServMigr>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_SCMMIGRLib>,
   public ISvcMgr
{
      TEntryList        m_List;
      IIManageDBPtr     m_pDB;
      BOOL              m_bFatal;
      CPasswordLog      m_passwordLog;       //Password file
      bool              m_bTriedToOpenFile; 
      long              m_Sequence;

    _bstr_t m_strSourceDomain;
    _bstr_t m_strSourceDomainFlat;
    _bstr_t m_strTargetDomain;
    _bstr_t m_strTargetDomainFlat;
    _bstr_t m_strSourceSam;
    _bstr_t m_strTargetSam;

public:
   CServMigr() : m_List(L"SCMData.txt")
	{
      HRESULT           hr = m_pDB.CreateInstance(CLSID_IManageDB);
      
      if ( FAILED(hr) )
      {
         m_bFatal = TRUE;
      }
      else
      {
         m_bFatal = FALSE;
      }
      m_bTriedToOpenFile = FALSE;
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SvcMgr)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CServMigr)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
   COM_INTERFACE_ENTRY(ISvcMgr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
   STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
   STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
   STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
protected:
   // Helper functions
   BOOL UpdateSCMs(IUnknown * pVarSet,WCHAR const * account, WCHAR const * password,WCHAR const * strSid,IIManageDB * pDB, EAMAccountStats* pStats);
   HRESULT SaveEncryptedPassword(WCHAR const * server,WCHAR const * service,WCHAR const * account,WCHAR const * password);
   DWORD DoUpdate(WCHAR const * acount,WCHAR const * password,WCHAR const * strSid,WCHAR const * computer,WCHAR const * service,BOOL bNeedToGrantLOS, EAMAccountStats* pStats);
   BOOL GetDirectory(WCHAR* filename);
   BOOL RetrieveOriginalAccount(_bstr_t &sSrcDom, _bstr_t &sSrcSAM);
   _bstr_t GetUPNName(_bstr_t sSrcSAM);

   // ISvcMgr
public:
   STDMETHOD(TryUpdateSam)(BSTR computer,BSTR service,BSTR account);
   STDMETHOD(TryUpdateSamWithPassword)(BSTR computer,BSTR service,BSTR account,BSTR password);
};

#endif //__SERVMIGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\scmmigr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
#define AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetPwd.rc
//
#define IDS_PROJNAME                    100
#define IDR_SETPASSWORD                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\setpass.cpp ===
//---------------------------------------------------------------------------
// SetPass.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method of this object sets the password for the 
//          target account according to the users specification.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ResStr.h"
#include <lm.h>
#include "rpc.h"
#include "EaLen.hpp"
#include <activeds.h>
#include "ARExt.h"
#include "ARExt_i.c"
#include "ErrDCT.hpp"
#include "PWGen.hpp"
#include "TReg.hpp"

#import "DBMgr.tlb" no_namespace

StringLoader                 gString;
TErrorDct   err;

#include "SetPwd.h"
#include "SetPass.h"
#include "pwdfuncs.h"
#include "PwRpcUtl.h"
#include "PwdSvc.h"

#define AR_Status_Created           (0x00000001)
#define AR_Status_PasswordCopied    (0x00000200)
#define AR_Status_PasswordError     (0x00000400)

#define SECONDS_PER_DAY 86400.0

/////////////////////////////////////////////////////////////////////////////
// CSetPassword

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
    return S_OK;
}

STDMETHODIMP CSetPassword::put_sName(BSTR newVal)
{
   m_sName = newVal;
    return S_OK;
}

STDMETHODIMP CSetPassword::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
    return S_OK;
}

STDMETHODIMP CSetPassword::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
    return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method currently records the setting of the "User
//                 cannot change password" flag for intra-forest user migrations
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
/* local variables */
   IVarSetPtr  pVS = pMainSettings;
   CString     sSAMName = L"";

/* function body */
   _bstr_t sIntraforest = pVS->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   _bstr_t sType = pVS->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   _bstr_t sSrc = pVS->get(GET_BSTR(DCTVS_Options_SourceServer));
   _bstr_t sAccount = pVS->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   if ((!sIntraforest.length()) || (!sType.length()) || 
       (!sSrc.length()) || (!sAccount.length()))
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   sSAMName = (WCHAR*)sAccount;
   if (!UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)))
   {
      if (!UStrICmp((WCHAR*)sType,L"user") || !UStrICmp((WCHAR*)sType,L"inetOrgPerson"))
      {
            //record the password flags set on the source account
         RecordPwdFlags(sSrc, sAccount);
            //we only want to record the "User cannot change password" flag, so
            //clear the others
         m_bUMCPNLFlagSet = false;
         m_bPNEFlagSet = false;

            //store the flag setting in a map as a string
         if (m_bUCCPFlagSet)
            mUCCPMap.SetAt(sSAMName, L"TRUE");
         else
            mUCCPMap.SetAt(sSAMName, L"FALSE");
      }
   }
      //if previously migrated, store that time in a map
   _bstr_t sSrcDom = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t sTgtDom = pVS->get(GET_BSTR(DCTVS_Options_TargetDomain));
   IVarSetPtr       pVSMig(__uuidof(VarSet));
   IUnknown       * pUnk;
   IIManageDBPtr    pDb(__uuidof(IManageDB));
   _variant_t       varDate;
   
   pVSMig->QueryInterface(IID_IUnknown, (void**) &pUnk);
   HRESULT hrFind = pDb->raw_GetAMigratedObject(sAccount, sSrcDom, sTgtDom, &pUnk);
   pUnk->Release();
      //if migrated previously, store that time and date in a class map in string
      //format
   if (hrFind == S_OK)
   {
      //
      // if object's password was previously copied
      //

      long lStatusOld = pVSMig->get(L"MigratedObjects.status");

      if (lStatusOld & AR_Status_PasswordCopied)
      {
          //
          // set password copied flag in account status
          // as the account replicator does not preserve
          // status for objects being replaced
          //

          _bstr_t strStatus = GET_BSTR(DCTVS_CopiedAccount_Status);
          long lStatusNew = pVS->get(strStatus);
          lStatusNew |= AR_Status_PasswordCopied;
          pVS->put(strStatus, lStatusNew);

          //
          // retrieve time when object was migrated and save
          //

          varDate = pVSMig->get(L"MigratedObjects.Time");
          if (varDate.vt & VT_DATE)
          {
             COleDateTime aDate = varDate.date;
                //save the date and time in a string
             CString sDate = aDate.Format(L"%B %d, %Y %H:%M:%S");
                //store the date\time string in a map
             mMigTimeMap.SetAt(sSAMName, sDate);
          }
      }
   }

   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method sets the password of the target object
//                 by looking at the settings in the varset.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                          )
{
    _bstr_t                   sType;
    IVarSetPtr                pVS = pMainSettings;
    WCHAR                     password[LEN_Path];
    bool                      bGenerate = false;
    bool                      bGenerated = false;
    DWORD                     dwMinUC = 0, dwMinLC = 0, dwMinDigits = 1, dwMinSpecial = 0, dwMaxAlpha = 10, dwMinLen = 4;
    _variant_t                var;
    WCHAR                     fileName[LEN_Path];
    bool                      bCopiedPwd = false;
    HRESULT                   hrPwd = ERROR_SUCCESS;

    sType = pVS->get(GET_BSTR(DCTVS_CopiedAccount_Type));

    //
    // Group objects don't have a password so do not attempt to process.
    //

    if (UStrICmp((WCHAR*)sType, L"group") == 0)
    {
        return S_OK;
    }

    // Get the Error log filename from the Varset
    var = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
    wcscpy(fileName, (WCHAR*)V_BSTR(&var));
    VariantInit(&var);
    // Open the error log
    err.LogOpen(fileName, 1);

    _bstr_t sSrc = pVS->get(GET_BSTR(DCTVS_Options_SourceServer));
    _bstr_t sSrcDom = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
    _bstr_t sMach = pVS->get(GET_BSTR(DCTVS_Options_TargetServer));
    _bstr_t sTgtName = pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
    _bstr_t sAccount = pVS->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
    _bstr_t sSkip = pVS->get(GET_BSTR(DCTVS_CopiedAccount_DoNotUpdatePassword));
    _bstr_t sTgtCN = pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetName));
    _bstr_t sIntraforest = pVS->get(GET_BSTR(DCTVS_Options_IsIntraforest));
    _bstr_t sCopyPwd = pVS->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
    _bstr_t sPwdDC = pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordDC));

    if ( !UStrICmp((WCHAR*)sSkip,(WCHAR*)sAccount) )
    {
        return S_OK;
    }

    //
    // Retrieve the operating system version of the password server. If it is
    // NT 4 or earlier then the flat or NetBIOS name of the target domain
    // controller must be specified.
    //

    if (m_nPasswordServerVersion == 0)
    {
        PWKSTA_INFO_100 pwiInfo;

        NET_API_STATUS nasStatus = NetWkstaGetInfo(sPwdDC, 100, (LPBYTE*)&pwiInfo);

        if (nasStatus == NERR_Success)
        {
            m_nPasswordServerVersion = pwiInfo->wki100_ver_major;

            NetApiBufferFree(pwiInfo);
        }
        else
        {
            err.SysMsgWrite(ErrW, nasStatus, DCT_MSG_PW_CANT_GET_PES_OS_VERSION_S, (WCHAR*)sPwdDC);
        }
    }

    if ((m_nPasswordServerVersion > 0) && (m_nPasswordServerVersion < 5))
    {
        sMach = pVS->get(GET_BSTR(DCTVS_Options_TargetServerFlat));
    }

    if ( sTgtCN.length() == 0 ) 
        sTgtCN = sTgtName;
    // strip off the CN= from the beginning of the name, if necessary
    if ( !UStrICmp(sTgtCN,"CN=",3) )
    {
        sTgtCN = _bstr_t(((WCHAR*)sTgtCN)+3);
    }

    dwMaxAlpha = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha));
    dwMinDigits = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinDigit));
    dwMinLC = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLower));
    dwMinUC = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinUpper));
    dwMinSpecial = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinSpecial));
    dwMinLen = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLength));

    // if the values are all 0 s then we make up something
    if ( (dwMaxAlpha + dwMinDigits + dwMinLC + dwMinUC + dwMinSpecial) == 0 ) 
    {
        dwMinDigits = 3;
        dwMinSpecial = 3;
        dwMinUC = 3;
        dwMinLC = 3;
    }

    //for intra-forest migration of a user, reset the user's
    //original "User cannot change password" flag, whose value is
    //stored in the map as a string
    if ( ! UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)) )
    {
        if ( !UStrICmp((WCHAR*)sType,L"user") || !UStrICmp((WCHAR*)sType,L"inetOrgPerson") )
        {
            //get the UCCP string from the map
            CString sFlag;
            if (mUCCPMap.Lookup((WCHAR*)sAccount, sFlag))
            {
                if (sFlag == L"TRUE")
                    m_bUCCPFlagSet = true;
                else
                    m_bUCCPFlagSet = false;
            }//end if found in map
            else
                m_bUCCPFlagSet = false;
            m_bUMCPNLFlagSet = false;
            m_bPNEFlagSet = false;

            ResetPwdFlags(pTarget, sMach, sTgtName);
            return S_OK;
        }
    }
    // Set the password for this account.
    if ( (_wcsicmp((WCHAR*)sType,L"user") == 0) || (_wcsicmp((WCHAR*)sType,L"inetOrgPerson") == 0) || (_wcsicmp((WCHAR*)sType, L"computer") == 0)  )
    {
        if  ( !_wcsicmp((WCHAR*)sType,L"user") || !_wcsicmp((WCHAR*)sType,L"inetOrgPerson") )
        {
            //we will not migrate passwords if replacing and password reuse policy on the target is 2 or greater
            UINT uMsgId = 0;
            if (!CanCopyPassword(pVS, sSrc, sAccount, uMsgId))
            {
                switch (uMsgId)
                {
                    // The source account password has not changed since the last migration.
                case 0:
                    err.MsgWrite(0, DCT_MSG_PW_COPY_NOT_TRIED_S, (WCHAR*)sTgtCN);
                    break;
                    // The 'User Must Change Password at Next Logon' is selected for this user.
                case DCT_MSG_PW_COPY_NOT_TRIED_USER_MUST_CHANGE_S:
                    err.MsgWrite(0, DCT_MSG_PW_COPY_NOT_TRIED_USER_MUST_CHANGE_S, (WCHAR*)sTgtCN);
                    break;
                    // Unable to determine the password age as the password last
                    // changed time is later than the current time on this machine.
                case DCT_MSG_PW_COPY_NOT_TRIED_TIMEDIFF_SS:
                    err.MsgWrite(0, DCT_MSG_PW_COPY_NOT_TRIED_TIMEDIFF_SS, (WCHAR*)sTgtCN, (WCHAR*)sMach);
                    break;
                    // This case should not occur but generate default message in case.
                default:
                    _ASSERT(FALSE);
                    err.MsgWrite(0, DCT_MSG_PW_COPY_NOT_TRIED_S, (WCHAR*)sTgtCN);
                    break;
                }

                return S_OK;
            }

            _bstr_t bstrGenerate = pVS->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));

            if (bstrGenerate == GET_BSTR(IDS_YES))
            {
                bGenerate = true;
            }

            if (bGenerate)
            {
                // generate a strong password
                DWORD dwError = EaPasswordGenerate(dwMinUC, dwMinLC, dwMinDigits, dwMinSpecial, dwMaxAlpha, dwMinLen, password, LEN_Path);
                bGenerated = ( dwError == ERROR_SUCCESS );

                if ( !bGenerated )
                {
                    //
                    // If unable to generate password then mark account to be disabled.
                    //
                    MarkAccountError(pVS);
                    if (pStats != NULL)
                        pStats->errors.users++;
                    err.SysMsgWrite(ErrE, dwError, DCT_MSG_PW_STRONG_GENERATE_FAILED_S, (WCHAR*)sTgtCN);
                    err.LogClose();
                    return S_OK;
                }

                // ensure that the password is NULL terminated
                password[14] = 0;

            }
            else
            {
                // set the password to the first 14 characters of the username
                wcsncpy(password,(WCHAR*)(sTgtName),15);
                // Convert the password to lower case.

                // ensure that the password is NULL terminated
                password[14] = 0;
            }
        }
        else
        {
            // computer, set the password to the first 14 characters of the computer name, in lower case,
            // without the trailing $
            UStrCpy(password, (WCHAR*)sTgtName, DIM(password));
            if ( password[UStrLen(password) - 1] == L'$' )
                password[UStrLen(password) - 1] = L'\0';  // remove trailing $ from machine name
            password[14] = L'\0';                     // truncate to max password length of 14

            // Convert the password to lower case.
            for ( DWORD i = 0; i < wcslen(password); i++ )
                password[i] = towlower(password[i]);

        }

        // We are going to use the Net API to set the password.
        USER_INFO_1003                  pInfo;
        DWORD                           pDw;
        WCHAR                           server[MAX_PATH];
        bool                            bFailedCopyPwd = false;

        //place the new password in the info structure
        pInfo.usri1003_password = password;

        long rc = NetUserSetInfo((WCHAR*)sMach, 
            (WCHAR*)sTgtName, 1003, (LPBYTE) &pInfo, &pDw);

        if ( rc != 0 ) 
        {
            if ( bGenerated )
            {
                //
                // If unable to set password then mark account to be disabled.
                //
                MarkAccountError(pVS);
                if (pStats != NULL)
                    pStats->errors.users++;
                err.SysMsgWrite(ErrE,rc,DCT_MSG_PW_GENERATE_FAILED_S,(WCHAR*)sTgtCN);
                err.LogClose();
                return S_OK;
            }
            else
            {
                if (pStats != NULL)
                    pStats->warnings.users++;
                err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_SET_PASSWORD_TO_USERNAME_SD,(WCHAR*)sTgtCN,rc);
                if ( rc == NERR_PasswordTooShort )
                {
                    // try to generate a password
                    DWORD dwError = EaPasswordGenerate(dwMinUC, dwMinLC, dwMinDigits, dwMinSpecial, dwMaxAlpha, dwMinLen, password, LEN_Path);

                    if (dwError != ERROR_SUCCESS)
                    {
                        //
                        // If unable to generate password then mark account to be disabled.
                        //
                        MarkAccountError(pVS);
                        if (pStats != NULL)
                            pStats->errors.users++;
                        err.SysMsgWrite(ErrE, dwError, DCT_MSG_PW_STRONG_GENERATE_FAILED_S, (WCHAR*)sTgtCN);
                        err.LogClose();
                        return S_OK;
                    }

                    rc = NetUserSetInfo((WCHAR*)sMach,(WCHAR*)sTgtName,1003,(LPBYTE)&pInfo,&pDw);
                    if ( rc )
                    {
                        //
                        // If unable to set password then mark account to be disabled.
                        //
                        MarkAccountError(pVS);
                        if (pStats != NULL)
                            pStats->errors.users++;
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_PW_GENERATE_FAILED_S,(WCHAR*)sTgtCN);
                        err.LogClose();
                        return S_OK;
                    }
                    else //else complex password generated, if requested to copy password
                    {    //we now try to do that and only log that complex pwd generated if copy fails
                        //if we are migrating the user's password, then set it here
                        if ( !UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)) )
                        {
                            //record the password flags set on the source account
                            RecordPwdFlags(sSrc, sAccount);
                            //clear the "User cannot change password" flag if it is set
                            ClearUserCanChangePwdFlag(sMach, sTgtName);
                            //set the change password flag to get past the minimum pwd age policy
                            SetUserMustChangePwdFlag(pTarget);
                            //prepare the server name
                            server[0] = L'\\';
                            server[1] = L'\\';
                            UStrCpy(server+2,(WCHAR*)sPwdDC);
                            //call the member function to copy the password.  If success, set flag, else
                            //failed, log the generated password message
                            if ((hrPwd = CopyPassword(_bstr_t(server), sMach, sAccount, sTgtName, _bstr_t(password), pStats)) == ERROR_SUCCESS)
                            {
                                err.MsgWrite(0,DCT_MSG_PWCOPIED_S,(WCHAR*)sTgtCN);
                                bCopiedPwd = true;
                                //reset the password flags as were on the source account 
                                ResetPwdFlags(pTarget, sMach, sTgtName);
                            }
                            else
                            {
                                bFailedCopyPwd = true;
                            }
                        }//end if migrate password
                        else //else not copy password, so post the complex password generated message
                            err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)sTgtCN);
                    }
                }
            }
        }
        else //else success
        {
            //if complex password generated, if requested to copy password
            //we now try to do that and only log that complex pwd generated if copy fails
            if ( bGenerated )
            {
                //if we are migrating the user's password, then set it here
                if ( !UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)) )
                {
                    //record the password flags set on the source account
                    RecordPwdFlags(sSrc, sAccount);
                    //clear the "User cannot change password" flag if it is set
                    ClearUserCanChangePwdFlag(sMach, sTgtName);
                    //set the change password flag to get past the minimum pwd age policy
                    SetUserMustChangePwdFlag(pTarget);
                    //prepare the server name
                    server[0] = L'\\';
                    server[1] = L'\\';
                    UStrCpy(server+2,(WCHAR*)sPwdDC);
                    //call the member function to copy the password.  If success, set flag, else
                    //failed, log the generated password message
                    if ((hrPwd = CopyPassword(_bstr_t(server), sMach, sAccount, sTgtName, _bstr_t(password), pStats)) == ERROR_SUCCESS)
                    {
                        err.MsgWrite(0,DCT_MSG_PWCOPIED_S,(WCHAR*)sTgtCN);
                        bCopiedPwd = true;
                        //reset the password flags as were on the source account 
                        ResetPwdFlags(pTarget, sMach, sTgtName);
                    }
                    else
                    {
                        bFailedCopyPwd = true;
                    }
                }//end if migrate password
                else //else not copy password, so post the complex password generated message
                    err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)sTgtCN);
            }
            else
            {
                err.MsgWrite(0,DCT_MSG_SET_PASSWORD_TO_USERNAME_S,(WCHAR*)sTgtCN);
            }
        }
        //if user being migrated and that user's password was not copied, write
        //password to the password file
        if (((_wcsicmp((WCHAR*)sType,L"user") == 0) || (_wcsicmp((WCHAR*)sType,L"inetOrgPerson") == 0)) && (bCopiedPwd == false))
        {
            //
            // Open password log file if it has not been already opened.
            //

            if (!m_bTriedToOpenFile)
            {
                m_bTriedToOpenFile = true;

                _bstr_t strPasswordFile = pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));

                if (m_passwordLog.LogOpen(strPasswordFile) == FALSE)
                {
                    if (pStats != NULL)
                    {
                        pStats->errors.users++;
                    }
                }
            }

            // Log the new password in the password log.
            if ( m_passwordLog.IsOpen() )
            {
                m_passwordLog.MsgWrite(L"%ls,%ls",(WCHAR*)(pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam)).bstrVal),password);
            }
        }//end if migrating user
    }//end if migrating user or computer

    //change password flags on the account if we did not copy the password
    if (( pTarget ) && (!bCopiedPwd))
    {
        // We want to clear "user cannot change password" and "password never expire flag"
        USER_INFO_1008               usr1008;
        USER_INFO_20               * usr20;
        DWORD                        errParam = 0;
        DWORD rc = NetUserGetInfo((WCHAR*) sSrc, (WCHAR*)sAccount, 20, (LPBYTE *)&usr20);
        _bstr_t                      strDisable = pVS->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
        _bstr_t                      strSame = pVS->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
        long                         val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_UserFlags));
        BOOL                         bDisable = FALSE;
        BOOL                         bSame = FALSE;

        if ( ! UStrICmp(strDisable,GET_STRING(IDS_YES)) )
            bDisable = TRUE;
        if ( ! UStrICmp(strSame,GET_STRING(IDS_YES)) )
            bSame = TRUE;
        if ( !rc ) 
        {
            usr1008.usri1008_flags = usr20->usri20_flags & ~UF_DONT_EXPIRE_PASSWD;
            // we won't turn off the user cannot change password, we will just expire the password below.
            // This will lock out any account with user cannot change password set, and the admin will
            // have to manually unlock the account.

            //usr1008.usri1008_flags &= ~UF_PASSWD_CANT_CHANGE;

            // for the computer account we need to set the UF_PASSWD_NOTREQD
            if ( !_wcsicmp((WCHAR*)sType,L"computer") )
            {
                usr1008.usri1008_flags |= UF_PASSWD_NOTREQD;
                // make sure the disable state for the computer account is the same as for the source computer
                if ( usr20->usri20_flags & UF_ACCOUNTDISABLE )
                {
                    usr1008.usri1008_flags |= UF_ACCOUNTDISABLE;
                }
                else
                {
                    usr1008.usri1008_flags &= ~UF_ACCOUNTDISABLE;
                }
            }
            else
            {
                // for user accounts, the disable flag is set based on the disable option
                // make sure that the disable flag is set properly!
                if ((bDisable) || (bSame && (val & UF_ACCOUNTDISABLE)))
                {
                    usr1008.usri1008_flags |= UF_ACCOUNTDISABLE;
                }
                else 
                {
                    usr1008.usri1008_flags &= ~UF_ACCOUNTDISABLE;
                }
            }         

            NetUserSetInfo((WCHAR*) sMach, (WCHAR*) sTgtName, 1008, (LPBYTE)&usr1008, &errParam);
            NetApiBufferFree(usr20);
        }
        else
        {
            MarkAccountError(pVS);
            if (pStats != NULL)
                pStats->errors.users++;
            err.SysMsgWrite(ErrE, rc, DCT_MSG_PW_UNABLE_RETRIEVE_FLAGS_SS, (WCHAR*)sTgtName, (WCHAR*)sAccount);
        }
        // Require the users to change the password at next logon since we created new passwords for them
        SetUserMustChangePwdFlag(pTarget);
    }

    //
    // set or clear password copied flag in the persisted object status
    // this flag is used to determine whether the password was previously copied
    //

    _bstr_t strStatus = GET_BSTR(DCTVS_CopiedAccount_Status);

    long lStatus = pVS->get(strStatus);

    if (bCopiedPwd)
    {
        lStatus |= AR_Status_PasswordCopied;
    }
    else
    {
        lStatus &= ~AR_Status_PasswordCopied;
    }

    pVS->put(strStatus, lStatus);

    err.LogClose();

    SecureZeroMemory(password, sizeof(password));
    return S_OK;
}

//---------------------------------------------------------------------------
// ProcessUndo : Since we cant undo the password setting we will ignore this.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::ProcessUndo(                                             
                                          IUnknown *pSource,         //in- Pointer to the source AD object
                                          IUnknown *pTarget,         //in- Pointer to the target AD object
                                          IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                          IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                     //         once all extension objects are executed.
                                          EAMAccountStats* pStats
                                       )
{
   _bstr_t                   sType;
   _bstr_t                   sSam;
   _bstr_t                   sServer;
   _bstr_t                   sIntraforest;
   WCHAR                     password[LEN_Path];
   DWORD                     rc = 0;
   DWORD                     pDw = 0;
   IVarSetPtr                pVs = pMainSettings;

   sIntraforest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   sSam  = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   sType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   sServer = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
   if ((!sIntraforest.length()) || (!sType.length()) || 
       (!sSam.length()) || (!sServer.length()))
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //if this is user intra-forest, call preprocess the first time in and
      //precess the second
   if (!UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)))
   {
      if (!UStrICmp((WCHAR*)sType,L"user") || !UStrICmp((WCHAR*)sType,L"inetOrgPerson"))
      {
            //see if this SAM is in the undone list (every entry in the list has a ","
            //on each side of it
         _bstr_t sTemp = _bstr_t(L",") + sSam + _bstr_t(L",");
            //if found, that means it is post migration, so call process
         if (wcsstr((PCWSTR)m_sUndoneUsers, sTemp))
         {
            ProcessObject(pSource, pTarget, pMainSettings, ppPropsToSet, pStats);
         }
         else //else pre-migration, so add to the list and call preprocess
         {
               //add to the list with an ending ","
            m_sUndoneUsers += sSam;
            m_sUndoneUsers += L",";
            PreProcessObject(pSource, pTarget, pMainSettings, ppPropsToSet, pStats);
         }
      }
   }
   
   if (!_wcsicmp((WCHAR*) sType, L"computer"))
   {
      USER_INFO_1003                      buf;
      rc = 0;
      if ( !rc ) 
      {
         // Create a lower case password from the sam account name. Do not include the trailing $.
         // Password to be maximum of 14 characters.
         UStrCpy(password, (WCHAR*)sSam, DIM(password));
         if ( password[UStrLen(password) - 1] == L'$' )
            password[UStrLen(password) - 1] = L'\0';  // remove trailing $ from machine name
         password[14] = L'\0';                        // truncate to max password length of 14
         for ( DWORD i = 0; i < wcslen(password); i++ )
            password[i] = towlower(password[i]);
         buf.usri1003_password = password;
         rc = NetUserSetInfo((WCHAR*) sServer, (WCHAR*) sSam, 1003, (LPBYTE) &buf, &pDw);
         if ( rc == 2221 )
         {
            WCHAR             sam[300];
            UStrCpy(sam,(WCHAR*)sSam);

            // remove the $ from the sam account name
            sam[UStrLen(sam)-1] = 0;
            rc = NetUserSetInfo((WCHAR*) sServer, sam, 1003, (LPBYTE) &buf, &pDw);
         }
      }
   }
   return HRESULT_FROM_WIN32(rc);
}

BOOL                                       // ret - TRUE if directory found
   CSetPassword::GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

       rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

       if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   key.Close();


   return bFound;
}


//---------------------------------------------------------------------------
// IsValidPassword Method
//
// This method validates a password by converting the Unicode password string
// to an ANSI string.
//
// If any Unicode characters cannot be directly translated to an ANSI
// character and a default character must be used then the password is
// invalid.
//
// If any Unicode characters translate to multi-byte characters then the
// password is invalid.
//---------------------------------------------------------------------------


#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS 0x00000400
#endif


bool CSetPassword::IsValidPassword(LPCWSTR pwszPassword)
{
    bool bValid = false;

    BOOL bUsedDefaultChar;
    CHAR szPassword[PWLEN + 1];

    // convert Unicode string to ANSI string

    int cch = WideCharToMultiByte(
        CP_ACP,                     // use system ANSI code page
        WC_NO_BEST_FIT_CHARS,       // do not use best fit characters
        pwszPassword,
        -1,                         // assume password string is zero terminated
        szPassword,
        sizeof (szPassword),
        NULL,
        &bUsedDefaultChar           // will be true if default character used
    );

    // if no error occurred

    if (cch > 0)
    {
        // if default character was not used

        if (bUsedDefaultChar == FALSE)
        {
            CPINFOEX cpie;
            GetCPInfoEx(CP_ACP, 0, &cpie);

            // if code page defines a SBCS then password is valid
            // otherwise code page defines a DBCS and the password
            // must be searched for a multi-byte character

            if ((cpie.LeadByte[0] == 0) && (cpie.LeadByte[1] == 0))
            {
                bValid = true;
            }
            else
            {
                // search for multi-byte character

                bool bLeadByteFound = false;

                for (int ich = 0; ich < cch; ich++)
                {
                    if (IsDBCSLeadByteEx(CP_ACP, szPassword[ich]))
                    {
                        bLeadByteFound = true;
                        break;
                    }
                }

                // if no multi-byte character found
                // then password is valid

                if (!bLeadByteFound)
                {
                    bValid = true;
                }
            }
        }
    }

    SecureZeroMemory(szPassword, sizeof(szPassword));
    return bValid;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for copying the user's password  *
 * in the source domain to its new account in the target domain.     *
 *     We use the Password Migration COM Wrapper to first check the  *
 * configuration and establish a session with the given Password     *
 * Export server.  Then we copy the password.  The configuration     *
 * check, which establishes a session for this series of operations, *
 * is only done once per set of accounts.                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CopyPassword
HRESULT CSetPassword::CopyPassword(_bstr_t srcServer, _bstr_t tgtServer, _bstr_t srcName, 
                                   _bstr_t tgtName, _bstr_t password, EAMAccountStats* pStats)
{
/* local variables */
    HRESULT     hr = S_OK;

/* function body */

    if (m_pPwdMig == NULL)
    {
        hr = m_pPwdMig.CreateInstance(__uuidof(PasswordMigration));

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // If session has not been established or needs to be re-established
    // then establish a session with the password export server. Note that
    // EstablishSession will un-establish an existing session first before
    // re-establishing a new session.
    //

    if (m_bEstablishedSession == false)
    {
        hr = m_pPwdMig->raw_EstablishSession(srcServer, tgtServer);

        if (SUCCEEDED(hr))
        {
            m_bEstablishedSession = true;
        }
    }

    //
    // Copy the password.
    // If unsuccessful then force session to be re-established.
    //

    if (SUCCEEDED(hr))
    {
        hr = m_pPwdMig->raw_CopyPassword(srcName, tgtName, password);

        if (FAILED(hr))
        {
            m_bEstablishedSession = false;
        }
    }

    //
    // The only time copy password can fail with ERROR_PASSWORD_RESTRICTION is when password history
    // has been enabled on the target domain and ADMT is attempting to recopy a password that has
    // been previously copied to the target. This scenario can happen if the adminstrator migrates
    // users with the copy password option, then migrates users with the generate complex password
    // option and then finally migrates users with the copy password option again.
    //
    // The only way out of this situation is to simply use the brute force technique of setting
    // the user's password to a series of complex passwords in order to push any known passwords
    // out of the password history before finally attempting to copy the source password again.
    //

    if (hr == HRESULT_FROM_WIN32(ERROR_PASSWORD_RESTRICTION))
    {
        //
        // This solution uses the set password API to push the new passwords into the
        // password history list. The set password API is preferred because the new
        // password is not subject to any password policies in effect. Note that the
        // set password API only works if the caller has adminstrator privileges.
        //

        WCHAR szPasswordOld[LEN_Path];
        WCHAR szPasswordNew[LEN_Path];

        USER_INFO_1003 uiInfo = { szPasswordNew };

        wcscpy(szPasswordOld, password);

        for (long lCount = m_lPwdHistoryLength; lCount > 0; lCount--)
        {
            if (EaPasswordGenerate(5, 5, 2, 2, 10, 14, szPasswordNew, LEN_Path) == ERROR_SUCCESS)
            {
                NET_API_STATUS nasStatus = NetUserSetInfo(tgtServer, tgtName, 1003, (LPBYTE)&uiInfo, NULL);

                if (nasStatus == ERROR_SUCCESS)
                {
                    wcscpy(szPasswordOld, szPasswordNew);
                }
                else
                {
                    break;
                }
            }
        }

        //
        // Must expire password so that the password export server may change password otherwise
        // the minimum password age policy may prevent the password change.
        //
        // Attempt to retrieve user information at level 4 which is only supported on .NET and later
        // but note that level 3 may not be supported on a .NET server when the SAM SID compatibility
        // mode is SAM_SID_COMPATIBILITY_STRICT. If failed to retrieve level 4 then retrieve level 3.
        //
        // Note that an error attempting to expire password is ignored as the copy password call will
        // fail if the minimum password age policy is in effect but will succeed otherwise.
        //

        PUSER_INFO_4 pui4 = NULL;

        NET_API_STATUS nasStatus = NetUserGetInfo(tgtServer, tgtName, 4, (LPBYTE*)&pui4);

        if (nasStatus == ERROR_SUCCESS)
        {
            pui4->usri4_password_expired = TRUE;

            NetUserSetInfo(tgtServer, tgtName, 4, (LPBYTE)pui4, NULL);

            NetApiBufferFree(pui4);
        }
        else
        {
            if (nasStatus == ERROR_INVALID_LEVEL)
            {
                PUSER_INFO_3 pui3 = NULL;

                nasStatus = NetUserGetInfo(tgtServer, tgtName, 3, (LPBYTE*)&pui3);

                if (nasStatus == ERROR_SUCCESS)
                {
                    pui3->usri3_password_expired = TRUE;

                    NetUserSetInfo(tgtServer, tgtName, 3, (LPBYTE)pui3, NULL);

                    NetApiBufferFree(pui3);
                }
            }
        }

        //
        // Attempt to copy password.
        //

        hr = m_pPwdMig->raw_CopyPassword(srcName, tgtName, szPasswordOld);
        
        SecureZeroMemory(szPasswordOld, sizeof(szPasswordOld));
        SecureZeroMemory(szPasswordNew, sizeof(szPasswordNew));
    }

       //if either failed, print warning in the migration.log
    if (FAILED(hr))
    {
        IErrorInfoPtr       pErrorInfo = NULL;
        BSTR                bstrDescription;
        _bstr_t             sText = GET_BSTR(IDS_Unspecified_Failure);

            //get the rich error information on the failure
        if (SUCCEEDED(GetErrorInfo(0, &pErrorInfo)))
        {
            HRESULT hrTmp = pErrorInfo->GetDescription(&bstrDescription);
            if (SUCCEEDED(hrTmp)) //if got rich error info, use it
                sText = _bstr_t(bstrDescription, false);
        }
            //print message in the log
        if (pStats != NULL)
            pStats->warnings.users++;
        err.MsgWrite(ErrW,DCT_MSG_PW_COPY_FAILED_S,(WCHAR*)tgtName, (WCHAR*)sText);
    }

    return hr;
}
//END CopyPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 5 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for setting the "User must change*
 * password at next logon" flag for a given user.  We use this prior *
 * to copying a user's password and after we have just set it to a   *
 * new complex password so that we get around the minimum password   *
 * age policy for the target domain.                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN SetUserMustChangePwdFlag
void CSetPassword::SetUserMustChangePwdFlag(IUnknown *pTarget)
{
/* local variables */
   IADs  * pAds = NULL;

/* function body */
      //set the new pwdLastSet value
   HRESULT hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);
   if ( SUCCEEDED(hr) )
   {
         // Require the users to change the password at next logon since we created new passwords for them
      VARIANT var;
      VariantInit(&var);
      V_I4(&var)=0;
      V_VT(&var)=VT_I4;
      hr = pAds->Put(L"pwdLastSet",var);
      hr = pAds->SetInfo();
      VariantClear(&var);
      if ( pAds ) pAds->Release();
   }
}
//END SetUserMustChangePwdFlag


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for setting and clearing the     *
 * "User cannot change password" flag for a given user, if it was    *
 * originally set.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN ClearUserCanChangePwdFlag
void CSetPassword::ClearUserCanChangePwdFlag(LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo;
   DWORD                           pDw;
   long                            rc;

/* function body */
      //get the current flag info for this user
   rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
   if (rc == 0)
   {
         //clear the "User cannot change password" flag if it is set
      if (pInfo->usri3_flags & UF_PASSWD_CANT_CHANGE)
      {
         pInfo->usri3_flags &= !(UF_PASSWD_CANT_CHANGE);
         NetUserSetInfo(pwszMach, pwszUser, 3, (LPBYTE)pInfo, &pDw);
      }

      NetApiBufferFree((LPVOID) pInfo);
   }
}
//END ClearUserCanChangePwdFlag


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for recording the password flags *
 * from a given user's source domain account.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN RecordPwdFlags
void CSetPassword::RecordPwdFlags(LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo;
   long                            rc;

/* function body */
      //get the user password flags
   rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
   if (rc == 0)
   {
         //record whether the "User cannot change password" flag is set
      if (pInfo->usri3_flags & UF_PASSWD_CANT_CHANGE)
         m_bUCCPFlagSet = true;//store whether the flag was set
      else
         m_bUCCPFlagSet = false;

         //record whether the "Password never expires" flag is set
      if (pInfo->usri3_flags & UF_DONT_EXPIRE_PASSWD)
         m_bPNEFlagSet = true;//store whether the flag was set
      else
         m_bPNEFlagSet = false;

         //record whether the "User must change password at next logon" flag is set
      if (pInfo->usri3_password_expired)
         m_bUMCPNLFlagSet = true;//store whether the flag was set
      else
         m_bUMCPNLFlagSet = false;

      NetApiBufferFree((LPVOID) pInfo);
   }
}
//END RecordPwdFlags


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for recording the password flags *
 * from a given user's source domain account.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN ResetPwdFlags
void CSetPassword::ResetPwdFlags(IUnknown *pTarget, LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo = NULL;
   DWORD                           pDw;
   long                            rc;

/* function body */
      //if the "User cannot change password" or "Password never expires" 
      //flag was original set, reset it
   if ((m_bUCCPFlagSet) || (m_bPNEFlagSet))
   {
         //get the current flag info for this user
      rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
      if (rc == 0)
      {
         if (m_bUCCPFlagSet)
            pInfo->usri3_flags |= UF_PASSWD_CANT_CHANGE;
         if (m_bPNEFlagSet)
            pInfo->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
         NetUserSetInfo(pwszMach, pwszUser, 3, (LPBYTE)pInfo, &pDw);

         NetApiBufferFree((LPVOID) pInfo);
      }
   }

      //if the "User must change password at next logon" flag was original set, reset it
   if (m_bUMCPNLFlagSet)
      SetUserMustChangePwdFlag(pTarget);

}
//END ResetPwdFlags


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 MAY 2001                                                  *
 *                                                                   *
 *     This function is responsible for determining if we will indeed*
 * set the password.  If the user is being re-migrated, copy password*
 * was selected, the password reuse policy on the target domain is   *
 * greater than 1, and the password on the source object has not been*
 * changed since the last migration of that user, then we will not   *
 * touch the password on the existing object on the target domain.   *
 *                                                                   *
 *********************************************************************/

//BEGIN CanCopyPassword
BOOL CSetPassword::CanCopyPassword(IVarSet * pVarSet, LPCWSTR pwszMach, LPCWSTR pwszUser, UINT& uMsgId)
{
/* local constants */
    const long      MAX_REUSE_NUM_ALLOWED = 1;

/* local variables */
    BOOL            bCanCopy = TRUE;
    _variant_t      varDate;
    long            rc;

/* function body */
        //init the message id to 0
    uMsgId = 0;

        //if not copying passwords, return TRUE
    _bstr_t sCopyPwd = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
    if (UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)))
        return bCanCopy;

    //
    // Always retrieve the target domain's password history length as
    // the copy password code may need the value even if the account
    // was previously migrated without the copy password option.
    //

    /* if not already done, check password reuse policy on the target domain */
    if (m_lPwdHistoryLength == -1)
    {
        IADsDomain              * pDomain;
        _bstr_t                   sDom( L"WinNT://" );
   
        _bstr_t sTgtDom = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
        sDom += sTgtDom;

        HRESULT hr = ADsGetObject(sDom, IID_IADsDomain, (void **) &pDomain);
        if (SUCCEEDED(hr))
        {
            //Get the password reuse policy
            long lReuse;
            hr = pDomain->get_PasswordHistoryLength(&lReuse);
            pDomain->Release();
                //if successful, store it in a class member variable
            if (SUCCEEDED(hr))
                m_lPwdHistoryLength = lReuse;
        }
    }

        //if not previously migrated, return TRUE
    _bstr_t sAccount = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
        //get the previous migration time from the class map
    CString sDate;
        //if previously migrated, get the date this user was last migrated
    if (mMigTimeMap.Lookup((WCHAR*)sAccount, sDate))
    {
          //convert the date string to a variant (VT_DATE)
        COleDateTime aDate;
        if (aDate.ParseDateTime((LPCTSTR)sDate))
        {
            varDate.vt = VT_DATE;
            varDate.date = DATE(aDate);
        }
        else
            return bCanCopy;
    }
    else //else return TRUE
        return bCanCopy;

    if ((m_lPwdHistoryLength != -1) && (m_lPwdHistoryLength <= MAX_REUSE_NUM_ALLOWED))
        return bCanCopy;

    /* if target account was created, we still want to copy password if object was created (Stystus == 1) */
        //get the migration status for this user
    long lStatus = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Status));
        //if the status field has the first bit set, then this user was
        //created and we should return TRUE to copy the password
    if (lStatus & AR_Status_Created)
        return bCanCopy;

    //
    // Check whether source account password has been
    // changed since the object has been migrated.
    //

    DWORD dwPasswordAge = 0;
    DWORD dwPasswordExpired = 0;

    //
    // Attempt to retrieve user information at level 4 which is only supported on .NET and later
    // but note that level 3 may not be supported on a .NET server when the SAM SID compatibility
    // mode is SAM_SID_COMPATIBILITY_STRICT. If failed to retrieve level 4 then retrieve level 3.
    //

    PUSER_INFO_4 pui4 = NULL;

    rc = NetUserGetInfo(pwszMach, pwszUser, 4, (LPBYTE*)&pui4);

    if (rc == ERROR_SUCCESS)
    {
        dwPasswordAge = pui4->usri4_password_age;
        dwPasswordExpired = pui4->usri4_password_expired;

        NetApiBufferFree(pui4);
    }
    else
    {
        if (rc == ERROR_INVALID_LEVEL)
        {
            PUSER_INFO_3 pui3 = NULL;

            rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE*)&pui3);

            if (rc == ERROR_SUCCESS)
            {
                dwPasswordAge = pui3->usri3_password_age;
                dwPasswordExpired = pui3->usri3_password_expired;

                NetApiBufferFree(pui3);
            }
       }
    }

    if (rc == ERROR_SUCCESS)
    {
        //
        // Retrieve password age in seconds.
        //

        if (dwPasswordAge > 0)
        {
            //
            // Retrieve current system time and then subtract password age
            // from the current system time to arrive at the time that the
            // password was last set. Note that for the DATE type that whole
            // numbers represent days and the fractional part represents a
            // fraction of one day.
            //

            DATE dateCurrent;
            SYSTEMTIME stCurrent;
            GetLocalTime(&stCurrent);
            SystemTimeToVariantTime(&stCurrent, &dateCurrent);

            DATE datePassword = dateCurrent - (double(dwPasswordAge) / SECONDS_PER_DAY);

            //
            // If the time the object was last migrated is later than or equal
            // to the time the password was last set then don't copy password.
            //

            if (varDate.date >= datePassword)
            {
                bCanCopy = FALSE;
            }
        }
        else
        {
            //
            // The password age cannot be determined. There are two possible
            // reasons that the password age cannot be determined. The 'User
            // Must Change Password at Next Logon' might be checked on the
            // source account or the system time on this computer is less
            // than the time the password was last changed.
            //

            //
            // If the password expired value is not zero than we will assume that
            // the 'User Must Change Password at Next Logon' must be checked and
            // there is not a time difference issue.
            //

            if (dwPasswordExpired)
            {
                uMsgId = DCT_MSG_PW_COPY_NOT_TRIED_USER_MUST_CHANGE_S;
            }
            else
            {
                uMsgId = DCT_MSG_PW_COPY_NOT_TRIED_TIMEDIFF_SS;
            }

            bCanCopy = FALSE;
        }
    }

    return bCanCopy;
}
//END CanCopyPassword


//-----------------------------------------------------------------------------
// MarkAccountError
//
// Synopsis
// Sets the error status bit in the account status. This is used by the
// disable account component as an indication that the account should remain
// disabled.
//
// Paramters
// pVarSet - varset containing account information
//-----------------------------------------------------------------------------

void CSetPassword::MarkAccountError(IVarSet* pVarSet)
{
    //
    // set or clear password copied flag in the persisted object status
    // this flag is used to determine whether the password was previously copied
    //

    _bstr_t strStatus = GET_BSTR(DCTVS_CopiedAccount_Status);

    long lStatus = pVarSet->get(strStatus);

    lStatus |= AR_Status_PasswordError;

    pVarSet->put(strStatus, lStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\setpass.h ===
//---------------------------------------------------------------------------
// SetPass.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method of this object sets the password for the 
//          target account according to the users specification.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __SETPASSWORD_H_
#define __SETPASSWORD_H_

#include "resource.h"       // main symbols
#include "CommaLog.hpp"
#include "ExtSeq.h"
#include "ADMTCrypt.h"

#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "MsPwdMig.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
// CSetPassword
class ATL_NO_VTABLE CSetPassword : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSetPassword, &CLSID_SetPassword>,
    public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_SETTARGETPASSWORDLib>
{
public:
   CSetPassword() : m_bTriedToOpenFile(false)
    {
      m_sName = L"Set Target Password";
      m_sDesc = L"Sets the target password and other related options.";
      m_Sequence = AREXT_LATER_SEQUENCE_NUMBER;
      m_bEstablishedSession = false;
      m_bUCCPFlagSet = false;
      m_bUMCPNLFlagSet = false;
      m_bPNEFlagSet = false;
      m_pTgtCrypt = NULL;
      m_sUndoneUsers = L",";
      m_lPwdHistoryLength = -1;
      m_nPasswordServerVersion = 0;
    }

   ~CSetPassword()
    {
      mUCCPMap.RemoveAll();
      mMigTimeMap.RemoveAll();
      m_passwordLog.LogClose();
      delete m_pTgtCrypt;
    }


DECLARE_REGISTRY_RESOURCEID(IDR_SETPASSWORD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetPassword)
    COM_INTERFACE_ENTRY(IExtendAccountMigration)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
    STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
    STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
    STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
    _bstr_t m_sDesc;
    _bstr_t m_sName;
   CPasswordLog              m_passwordLog;       //Password file
   bool                      m_bTriedToOpenFile; 
   long                      m_Sequence;
   bool                      m_bEstablishedSession;
   CTargetCrypt            * m_pTgtCrypt;
   bool                      m_bUCCPFlagSet;
   bool                      m_bUMCPNLFlagSet;
   bool                      m_bPNEFlagSet;
   long                      m_lPwdHistoryLength;
   int                       m_nPasswordServerVersion;

   CMapStringToString mUCCPMap;
   CMapStringToString mMigTimeMap;
   _bstr_t m_sUndoneUsers;
   IPasswordMigrationPtr     m_pPwdMig;

   BOOL GetDirectory(WCHAR* filename);
   bool IsValidPassword(LPCWSTR pwszPassword);
   HRESULT CopyPassword(_bstr_t srcServer, _bstr_t tgtServer, _bstr_t srcName, _bstr_t tgtName, _bstr_t password, EAMAccountStats* pStats);
   void SetUserMustChangePwdFlag(IUnknown *pTarget);
   void RecordPwdFlags(LPCWSTR pwszMach, LPCWSTR pwszUser);
   void ResetPwdFlags(IUnknown *pTarget, LPCWSTR pwszMach, LPCWSTR pwszUser);
   void ClearUserCanChangePwdFlag(LPCWSTR pwszMach, LPCWSTR pwszUser);
   BOOL CanCopyPassword(IVarSet * pVarSet, LPCWSTR pwszMach, LPCWSTR pwszUser, UINT& uMsgId);
   void MarkAccountError(IVarSet* pVarSet);
};

#endif //__SETPASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\setpwd.cpp ===
// SetTargetPassword.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SetTargetPasswordps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SetPwd.h"

#include "SetPwd_i.c"
#include "SetPass.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SetPassword, CSetPassword)
END_OBJECT_MAP()

class CSetPwdApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSetPwdApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSetPwdApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSetPwdApp, CWinApp)
	//{{AFX_MSG_MAP(CSetPwdApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSetPwdApp theApp;

BOOL CSetPwdApp::InitInstance()
{
	ATLTRACE(_T("{SetTargetPassword.dll}CSetPwdApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_SETTARGETPASSWORDLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CSetPwdApp::ExitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CSetPwdApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\setpwd\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

//#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UpdateDB.rc
//
#define IDS_PROJNAME                    100
#define IDR_STOREINFO                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\storeinfo.cpp ===
// StoreInfo.cpp : Implementation of CStoreInfo
#include "stdafx.h"
#include "UpdateDB.h"
#include "ResStr.h"
#include "StoreInfo.h"
#include "Err.hpp"
#include "ARExt_i.c"

//#import "\bin\mcsvarsetmin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace
/////////////////////////////////////////////////////////////////////////////
// CStoreInfo
StringLoader  gString;
#define LEN_Path   255
//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CStoreInfo::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CStoreInfo::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CStoreInfo::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                       )
{
   return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method adds the copied account info to the DB
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                             EAMAccountStats* pStats
                                       )
{
   IIManageDBPtr             pDBMgr;//(__uuidof(IManageDB));
   IVarSetPtr                pVs(__uuidof(VarSet));
   IVarSetPtr                pMain = pMainSettings;
   IUnknown                * pUnk;
   HRESULT                   hr;
   long                      lActionID = 0;
   _variant_t                var;
   TError                    logFile;


   var = pMain->get(GET_BSTR(DCTVS_DBManager));
   if ( var.vt == VT_DISPATCH )
   {
      pDBMgr = var.pdispVal;
      // Fill up the Varset from the info in the main settings varset.
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourcePath));
      pVs->put(GET_BSTR(DB_SourceAdsPath),var);
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetPath));
      pVs->put(GET_BSTR(DB_TargetAdsPath),var);
      var = pMain->get(GET_BSTR(DCTVS_Options_SourceDomain));
      pVs->put(GET_BSTR(DB_SourceDomain), var);

      var = pMain->get(GET_BSTR(DCTVS_Options_TargetDomain));
      pVs->put(GET_BSTR(DB_TargetDomain), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
      pVs->put(GET_BSTR(DB_SourceSamName), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
      pVs->put(GET_BSTR(DB_TargetSamName), var);
   
      _bstr_t sType = pMain->get(GET_BSTR(DCTVS_CopiedAccount_Type));
         //we now want to save any group accounts by their types ("ugroup", "lgroup", 
         //or "ggroup") instead of just "group"
      if (sType.length() && (!UStrICmp((WCHAR*)sType, L"group")))
	  {
		 _bstr_t sGroup;
         long nGroup = pMain->get(GET_BSTR(DCTVS_CopiedAccount_GroupType));
	     if (nGroup & 2)
	        sGroup = L"ggroup";
	     else if (nGroup & 4)
	        sGroup = L"lgroup";
	     else if (nGroup & 8)
	        sGroup = L"ugroup";
	     else
	        sGroup = L"group";
         pVs->put(GET_BSTR(DB_Type), sGroup);
	  }
      else
         pVs->put(GET_BSTR(DB_Type), sType);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_GUID));
      pVs->put(GET_BSTR(DB_GUID), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_Status));
      pVs->put(GET_BSTR(DB_status), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceRID));
      pVs->put(GET_BSTR(DB_SourceRid),var);

      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetRID));
      pVs->put(GET_BSTR(DB_TargetRid),var);

      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceDomainSid));
      pVs->put(GET_BSTR(DB_SourceDomainSid), var);

      hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
      if ( FAILED(hr)) return hr;

      hr = pDBMgr->raw_GetCurrentActionID(&lActionID);
      if ( FAILED(hr)) return hr;

      hr = pDBMgr->raw_SaveMigratedObject(lActionID, pUnk);
      if ( FAILED(hr)) return hr;
      pUnk->Release();
   }

   return S_OK;
}

//---------------------------------------------------------------------------
// ProcessUndo :  This method adds an entry into the DB for undoing migration
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
    // We need to delete this entry from the database.
    WCHAR         sQuery[LEN_Path];
    IVarSetPtr    pVs = pMainSettings;
    IIManageDBPtr pDBMgr;
    HRESULT       hr = E_INVALIDARG;
    _variant_t    var;
    _bstr_t       sSourceSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
    _bstr_t       sTargetSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
    _bstr_t       sSourceDom = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
    _bstr_t       sTargetDom = pVs->get(GET_BSTR(DCTVS_Options_TargetDomain));

    //
    // If undoing a computer migration do not delete records from the migrated objects table as
    // the migration driver component requires the computer object migration records when trimming
    // the server list.
    //

    _bstr_t strWizard = pVs->get(GET_BSTR(DCTVS_Options_Wizard));

    if (UStrICmp(strWizard, L"computer") == 0)
    {
        hr = S_OK;
    }
    else
    {
        var = pVs->get(GET_BSTR(DCTVS_DBManager));
        if ( var.vt == VT_DISPATCH )
        {
            pDBMgr = var.pdispVal;
            _bstr_t bstrSameForest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));

            if (! UStrICmp((WCHAR*)bstrSameForest,GET_STRING(IDS_YES)) )
            {
                swprintf(sQuery, L"SourceSamName = \"%s\" and TargetSamName = \"%s\" and SourceDomain = \"%s\" and TargetDomain = \"%s\"",
                    (WCHAR*)sTargetSam, (WCHAR*)sSourceSam, (WCHAR*)sTargetDom, (WCHAR*)sSourceDom);
            }
            else
            {
                swprintf(sQuery, L"SourceSamName = \"%s\" and TargetSamName = \"%s\" and SourceDomain = \"%s\" and TargetDomain = \"%s\"",
                    (WCHAR*)sSourceSam, (WCHAR*)sTargetSam, (WCHAR*)sSourceDom, (WCHAR*)sTargetDom);
            }
            _bstr_t  sFilter = sQuery;
            _variant_t Filter = sFilter;
            hr = pDBMgr->raw_ClearTable(L"MigratedObjects", Filter);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\storeinfo.h ===
// StoreInfo.h : Declaration of the CStoreInfo

#ifndef __STOREINFO_H_
#define __STOREINFO_H_

#include "resource.h"       // main symbols
#include "extseq.h"

/////////////////////////////////////////////////////////////////////////////
// CStoreInfo
class ATL_NO_VTABLE CStoreInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStoreInfo, &CLSID_StoreInfo>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_UPDATEDBLib>
{
public:
	CStoreInfo()
	{
      m_sName = L"Update Database";
      m_sDesc = L"Extension that updates the migration information in the DB";
      m_Sequence = AREXT_EVEN_LATER_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STOREINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStoreInfo)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif //__STOREINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UPNUpdt.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPDTUPN                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\updatedb\updatedb.cpp ===
// UpdateDB.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UpdateDBps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UpdateDB.h"

#include "UpdateDB_i.c"
#include "StoreInfo.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_StoreInfo, CStoreInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_UPDATEDBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\updtupn.h ===
//---------------------------------------------------------------------------
// UPDTUPN.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method on this object updates the userPrincipalName
//          property on the user object.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __UPDTUPN_H_
#define __UPDTUPN_H_

#include "resource.h"       // main symbols
#include "ExtSeq.h"
#include <string>
#include <map>

typedef std::basic_string<WCHAR> tstring;

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CUpdtUPN
class ATL_NO_VTABLE CUpdtUPN : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUpdtUPN, &CLSID_UpdtUPN>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_UPNUPDTLib>
{
public:
	CUpdtUPN()
	{
      m_sName = L"UpnUpdate";
      m_sDesc = L"";
      m_sUPNSuffix = L"";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

    ~CUpdtUPN()
	{
      mUPNMap.clear();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPDTUPN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdtUPN)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet, /*[in,out]*/ EAMAccountStats* pStats);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	   //define a structure to hold the UPN name and whether it conflicted in the map below
	struct SUPNStruc {
	   SUPNStruc() :
		   bConflicted(false)
	   {
	   }
	   SUPNStruc(const SUPNStruc& UPNData)
	   {
		   bConflicted = UPNData.bConflicted;
		   sName = UPNData.sName;
		   sOldName = UPNData.sOldName;
	   }
	   SUPNStruc& operator =(const SUPNStruc& UPNData)
	   {
		   bConflicted = UPNData.bConflicted;
		   sName = UPNData.sName;
		   sOldName = UPNData.sOldName;
		   return *this;
	   }

	   bool bConflicted;
	   tstring sName;
	   tstring sOldName;
	};

	typedef std::map<tstring,SUPNStruc> CUPNMap;
	CUPNMap mUPNMap;

    bool RenamedWithPrefixSuffix(_bstr_t sSourceSam, _bstr_t sTargetSam, _bstr_t sPrefix, _bstr_t sSuffix);
	void GetUniqueUPN(_bstr_t& sUPN, IVarSetPtr pVs, bool bUsingSamName, _bstr_t sAdsPath);
    bool GetDefaultUPNSuffix(_bstr_t sDomainDNS, _bstr_t sTargetOU);
	_bstr_t GetUPNSuffix(_bstr_t sUPNName);
	_bstr_t ChangeUPNSuffix(_bstr_t sUPNName, _bstr_t sNewSuffix);
	_bstr_t m_sDesc;
	_bstr_t m_sName;
	_bstr_t	m_sUPNSuffix;
    long    m_Sequence;
};

#endif //__UPDTUPN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\updtupn.cpp ===
//---------------------------------------------------------------------------
// UPDTUPN.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method on this object updates the userPrincipalName
//          property on the user object.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "UPNUpdt.h"
#include "ErrDCT.hpp"
#include "Names.hpp"
#include "resstr.h"
#include <GetDcName.h>
#include <Array.h>
#include "AdsiHelpers.h"

//#import "\bin\NetEnum.tlb" no_namespace
#import "NetEnum.tlb" no_namespace
#include "UpdtUPN.h"

TErrorDct                      err;

/////////////////////////////////////////////////////////////////////////////
// CUpdtUPN
StringLoader   gString;

#define SEQUENCE_UPPER_BOUND 999


//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
    return S_OK;
}

STDMETHODIMP CUpdtUPN::put_sName(BSTR newVal)
{
   m_sName = newVal;
    return S_OK;
}

STDMETHODIMP CUpdtUPN::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
    return S_OK;
}

STDMETHODIMP CUpdtUPN::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
    return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::PreProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sTemp;
   _bstr_t                   sUPN;
   _bstr_t                   sPref;
   _bstr_t                   sSuff;
   IADs                    * pAds = NULL;
   IADs                    * pAdsSource = NULL;
   HRESULT                   hr;
   c_array<WCHAR>            sTempUPN(7000);
   long                      ub, lb;
   _bstr_t                   sFull;
   _variant_t HUGEP        * pDt;
   _bstr_t                   sAdsPath;
   _variant_t                varDN;
   _bstr_t                   sIntraforest;
   _bstr_t                   sDomainDNS;
   _bstr_t                   sTargetOU;
   WCHAR                     fileName[MAX_PATH];
   bool                      bReplace = false;
   tstring                   sSAMName;
   tstring                   sUPNName;
   _bstr_t                   sOldUPN;
   bool                      bConflicted = false;
   SUPNStruc                 UPNStruc;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if (!sTemp.length())
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   if (_wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"inetOrgPerson")) 
       return S_OK;

      //store the name of this user in the UPN list
   sSAMName = _bstr_t(pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam)));

      //get the target domain DNS name
   sDomainDNS = pVs->get(GET_BSTR(DCTVS_Options_TargetDomainDns));

      //get the target OU path
   sTargetOU = pVs->get(GET_BSTR(DCTVS_Options_OuPath));

      //if not retrieved yet, get the default UPN suffix for this domain
   if (m_sUPNSuffix.length() == 0)
   {
          //if failed, use the domain's DNS name
       if (!GetDefaultUPNSuffix(sDomainDNS, sTargetOU))
          m_sUPNSuffix = sDomainDNS;
   }

   // Get the Error log filename from the Varset
   wcscpy(fileName, (WCHAR*)(pVs->get(GET_BSTR(DCTVS_Options_Logfile)).bstrVal));
   // Open the error log
   err.LogOpen(fileName, 1);

   sPref = pVs->get(GET_BSTR(DCTVS_Options_Prefix));
   sSuff = pVs->get(GET_BSTR(DCTVS_Options_Suffix));
   sIntraforest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   sTemp = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if (!UStrICmp(sTemp,GET_STRING(IDS_YES)))
       bReplace = true;

   sAdsPath = L"";
   if ( pSource )
   {
       // Get the UPN from the source domain
       hr = pSource->QueryInterface(IID_IADs, (void**) &pAdsSource);
   }
            
   if ( pAdsSource )
   {
      if ( SUCCEEDED(hr) )
      {
          hr = pAdsSource->GetEx(L"userPrincipalName", &var);
          if (SUCCEEDED(hr) )
          {
             SAFEARRAY * pArray = V_ARRAY(&var);
             hr = SafeArrayGetLBound(pArray, 1, &lb);
             hr = SafeArrayGetUBound(pArray, 1, &ub);

             hr = SafeArrayAccessData(pArray, (void HUGEP **) &pDt);
                  
             if ( SUCCEEDED(hr) )
             {
                // translate all the UPNs to the target domain.
                for ( long x = lb; x <= ub; x++)
                {
                   wcsncpy(sTempUPN, (WCHAR*) pDt[x].bstrVal, 5000);
                   sTempUPN[4999] = 0;

                   //Get the stuff before the LAST @ sign.
                   WCHAR             * ndx = NULL;
                   WCHAR             * tempNdx = sTempUPN;
                   do
                   {
                      tempNdx = wcschr(tempNdx + 1, L'@');
                      if ( tempNdx ) 
                         ndx = tempNdx;
                   } while (tempNdx);

                   if (ndx) *ndx = L'\0';

                   if ( sPref.length() )
                      sFull = sPref + _bstr_t(sTempUPN);
                   else if ( sSuff.length() ) 
                      sFull = _bstr_t(sTempUPN) + sSuff;
                   else
                      sFull = sTempUPN;

                   sTemp = sFull;
                   sUPN = sTemp + _bstr_t(L"@");
                   sUPN = sUPN + m_sUPNSuffix;
                    //store UPN name as it enters
                   sOldUPN = sUPN;
                   sUPNName = sUPN;

                   //
                   // If able to verify that UPN is unique or a unique UPN
                   // was generated then sUPN will contain the unique UPN
                   // otherwise sUPN will be an empty string.
                   //

                   GetUniqueUPN(sUPN, pVs, false, sAdsPath);

                   if (sUPN.length() > 0)
                   {
                       //see if the two UPN's differ.  If they do, then we had a conflict
                       if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
                       {
                          sUPNName = sUPN;
                          hr = ERROR_OBJECT_ALREADY_EXISTS;
                          bConflicted = true;
                       }
                   }
                   else
                   {
                       //
                       // Unable to verify if UPN was unique therefore set UPN to be an
                       // empty string which will cause the UPN attribute not to be set
                       // in the process object method. Also must increment the error count.
                       //

                       sUPNName = sUPN;

                       if (pStats != NULL)
                       {
                            pStats->errors.users++;
                       }
                   }

                   pDt[x] = _variant_t(sUPN);
                }
                SafeArrayUnaccessData(pArray);
             }
          }
          else
          {
             sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
             sUPN = sTemp + _bstr_t(L"@");
             sUPN = sUPN + m_sUPNSuffix;
                //store UPN name as it enters
             sOldUPN = sUPN;
             sUPNName = sUPN;

             //
             // If able to verify that UPN is unique or a unique UPN
             // was generated then sUPN will contain the unique UPN
             // otherwise sUPN will be an empty string.
             //

             GetUniqueUPN(sUPN, pVs, false, sAdsPath);

             if (sUPN.length() > 0)
             {
                 //see if the two UPN's differ.  If they do, then we had a conflict
                 if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
                 {
                    sUPNName = sUPN;
                    hr = ERROR_OBJECT_ALREADY_EXISTS;
                    bConflicted = true;
                 }
             }
             else
             {
                 //
                 // Unable to verify if UPN was unique therefore set UPN to be an
                 // empty string which will cause the UPN attribute not to be set
                 // in the process object method. Also must increment the error count.
                 //

                 sUPNName = sUPN;

                 if (pStats != NULL)
                 {
                      pStats->errors.users++;
                 }
             }
          }
      }
   }
   else
   {
      sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
      sUPN = sTemp + _bstr_t(L"@");
      sUPN = sUPN + m_sUPNSuffix;
        //store UPN name as it enters
      sOldUPN = sUPN;
      sUPNName = sUPN;

      //
      // If able to verify that UPN is unique or a unique UPN
      // was generated then sUPN will contain the unique UPN
      // otherwise sUPN will be an empty string.
      //

      GetUniqueUPN(sUPN, pVs, false, sAdsPath);

      if (sUPN.length() > 0)
      {
          //see if the two UPN's differ.  If they do, then we had a conflict
          if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
          {
             sUPNName = sUPN;
             hr = ERROR_OBJECT_ALREADY_EXISTS;
             bConflicted = true;
          }
      }
      else
      {
          //
          // Unable to verify if UPN was unique therefore set UPN to be an
          // empty string which will cause the UPN attribute not to be set
          // in the process object method. Also must increment the error count.
          //

          sUPNName = sUPN;

          if (pStats != NULL)
          {
               pStats->errors.users++;
          }
      }
   }

   if ( pAds ) pAds->Release();
   if (pAdsSource) pAdsSource->Release();

   UPNStruc.sName = sUPNName;
   UPNStruc.sOldName = sOldUPN;
   UPNStruc.bConflicted = bConflicted;
     //insert UPN into Map
   mUPNMap.insert(CUPNMap::value_type(sSAMName, UPNStruc));

   return hr;
}

//---------------------------------------------------------------------------
// ProcessObject : This method updates the UPN property of the object. It 
//                 first sees if a E-Mail is specified then it will set UPN
//                 to that otherwise it builds it from SAMAccountName and the
//                 Domain name
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::ProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _bstr_t                   sTemp;
   IADs                    * pAds = NULL;
   _variant_t                var;
   HRESULT                   hr;
   WCHAR                     fileName[MAX_PATH];
   CUPNMap::iterator         itUPNMap;
   tstring                   sSam;
   SUPNStruc                 UPNStruc;
   bool                      bReplace = false;
   _bstr_t                   sOldUPNSuffix;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"inetOrgPerson") ) return S_OK;

   sTemp = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if (!UStrICmp(sTemp,GET_STRING(IDS_YES)))
       bReplace = true;

      //get the target SAM name
   sSam = _bstr_t(pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam)));

   // Get the Error log filename from the Varset
   wcscpy(fileName, (WCHAR*)(pVs->get(GET_BSTR(DCTVS_Options_Logfile)).bstrVal));
   // Open the error log
   err.LogOpen(fileName, 1);

   // And only need to process the accounts copied to Win2k domain.
   if ( pTarget )
   {
      //Get the IADs pointer to manipulate properties
      hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);

      if (SUCCEEDED(hr))
      {
            //get the UPN name for this user from the list
         itUPNMap = mUPNMap.find(sSam);
         if (itUPNMap != mUPNMap.end())
            UPNStruc = itUPNMap->second;

         if (!UPNStruc.sName.empty())
         {
            bool bSame = false;
               //if replace mode, don't set UPN if same object we are replacing and
               //if not the same object, get it's current UPN Suffix
            if (bReplace)
            {
               hr = pAds->Get(L"userPrincipalName", &var);
               if (SUCCEEDED(hr))
               {
                     //if replacing the object whose UPN conflicted, don't change it
                  if (!UPNStruc.sOldName.compare(var.bstrVal))
                     bSame = true;
                  else //else, get the object's current UPN suffix for re-use
                     sOldUPNSuffix = GetUPNSuffix(var.bstrVal);
               }
            }

            if (!bSame)
            {
               var = UPNStruc.sName.c_str();
                  //if replacing an existing object, use it's old UPN suffix
               if ((bReplace) && (sOldUPNSuffix.length() != 0))
               {
                     //change the suffix on the old name, since it may longer conflict
                  _bstr_t sUPN = ChangeUPNSuffix(UPNStruc.sOldName.c_str(), sOldUPNSuffix);
                     //if changed, make sure we don't still have a UPN conflict and save the 
                     //new UPN for setting
                  if (sUPN.length() != 0)
                  {
                     _bstr_t sTempUPN = sUPN;
                        //get unigue UPN on target, now that we could conflict
                     GetUniqueUPN(sUPN, pVs, true, _bstr_t(L""));
                     if (sUPN.length() > 0)
                     {
                            //if changed, set conflicted flag and names for error message
                         if (sUPN != sTempUPN)
                         {
                            UPNStruc.sName = sUPN;
                            UPNStruc.sOldName = sTempUPN;
                            UPNStruc.bConflicted = true;
                         }
                         else
                            UPNStruc.bConflicted = false;
                     }

                     var = sUPN;
                  }
               }

               //
               // If unable to determine if UPN is unique then GetUniqueUPN will
               // set the UPN to an empty string. If this is the case then don't
               // set the UPN attribute.
               //

               if ((V_VT(&var) == VT_BSTR) && (SysStringLen(V_BSTR(&var)) > 0))
               {
                   hr = pAds->Put(L"userPrincipalName", var);
                   if (SUCCEEDED(hr))
                   {
                      hr = pAds->SetInfo();
                      if (SUCCEEDED(hr))
                      {
                            // If we changed the UPN Name due to conflict, we need to log a 
                            //message indicating the fact that we changed it.
                         if (UPNStruc.bConflicted)
                            err.MsgWrite(1, DCT_MSG_CREATE_FAILED_UPN_CONF_SS, 
                                         UPNStruc.sOldName.c_str(), UPNStruc.sName.c_str());
                      }
                   }
               }
               else
               {
                   if (pStats != NULL)
                   {
                        pStats->errors.users++;
                   }
               }
            }
         }
      }
   }
   if ( pAds ) pAds->Release();

   return hr;
}

//---------------------------------------------------------------------------
// ProcessUndo : We are not going to undo this.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet,    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                       EAMAccountStats* pStats
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _bstr_t                   sTemp, sSUPN;
   IADs                    * pAds = NULL;
   _variant_t                var;
   HRESULT                   hr = S_OK;
   _bstr_t                   sAdsPath = L"";
   _bstr_t                   sTempUPN;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)sTemp,L"user") || _wcsicmp((WCHAR*)sTemp,L"inetOrgPerson") ) return S_OK;

    // get the original source account's UPN
   sSUPN = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceUPN));
   if (sSUPN.length())
   {
      sTempUPN = sSUPN;
      GetUniqueUPN(sTempUPN, pVs, true, sAdsPath);
      
      int len;
      WCHAR * ndx, * tempNdx = (WCHAR*)sTempUPN;
      do
      {
         tempNdx = wcschr(tempNdx + 1, L'@');
         if ( tempNdx ) 
            ndx = tempNdx;
      } while (tempNdx);

      if (ndx) len = ndx - sTempUPN;
      if (_wcsnicmp(sTempUPN, sSUPN, len) != 0)
          return S_OK;
        // And only need to process the accounts copied to Win2k domain.
      if ( pTarget )
      {
         //Get the IADs pointer to manipulate properties
         hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);

         if ( SUCCEEDED(hr) )
         {
            var = sSUPN;
            hr = pAds->Put(L"userPrincipalName", var);
            
            if (SUCCEEDED(hr))
            {
                hr = pAds->SetInfo();
            }
         }
      }
      if ( pAds ) pAds->Release();
   }

   return hr;
}

//---------------------------------------------------------------------------
// GetUniqueUPN : This function checks if the UPN is unique if not then 
//                appends a number starting with 0 and retries till a unique 
//                UPN is found.
//---------------------------------------------------------------------------
void CUpdtUPN::GetUniqueUPN(_bstr_t &sUPN, IVarSetPtr pVs, bool bUsingSamName, _bstr_t sAdsPath)
{
    // Here are the steps that we follow to get the unique UPN name
    // 1. Check if the current name is unique. If it is then return that.
    // 2. Append collision prefix and suffix if the sam account name has changed due to pref/suffix.
    // 3. Add a numeric suffix to the UPN and repeat till a unique UPN is found.

    c_array<WCHAR>              sTempUPN(5000);
    c_array<WCHAR>              sPath(5000);
    HRESULT                     hr = E_FAIL;
    LPWSTR                      pCols[] = { L"distinguishedName", L"sAMAccountName" };
    BSTR                      * pData = NULL;
    SAFEARRAY                 * pSaCols = NULL;
    SAFEARRAYBOUND              bd = { 2, 0 };
    _bstr_t                     sSrcDomain = pVs->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
    _bstr_t                     sTgtDomain = pVs->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
    INetObjEnumeratorPtr        pQuery(__uuidof(NetObjEnumerator));
    IEnumVARIANTPtr             pEnum;
    DWORD                       fetched = 0;
    _variant_t                  var;
    bool                        bCollPrefSufProcessed = false;
    _bstr_t                     sSourceSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
    _bstr_t                     sTargetSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
    _bstr_t                     sPrefix = pVs->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
    _bstr_t                     sSuffix = pVs->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
    _bstr_t                     sPref = pVs->get(GET_BSTR(DCTVS_Options_Prefix));
    _bstr_t                     sSuff = pVs->get(GET_BSTR(DCTVS_Options_Suffix));
    int                         offset = 0;
    c_array<WCHAR>              sTemp(5000);
    SAFEARRAY                 * psaPath = NULL;
    _bstr_t                     strDn;
    _bstr_t                     strSam;
    VARIANT                   * pVar;
    bool                        bReplace = false;
    WCHAR                       sTempSAM[MAX_PATH];
    _bstr_t                     sNewSAM;
    _bstr_t                     sUPNSuffix;
    _bstr_t                     sUPNPrefix;

    _bstr_t sReplace = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
    if (!UStrICmp(sReplace,GET_STRING(IDS_YES)))
        bReplace = true;

    wcscpy(sTempSAM, (WCHAR*)sSourceSam);
    StripSamName(sTempSAM);
    if ( sPref.length() )
        sNewSAM = sPref + _bstr_t(sTempSAM);
    else if ( sSuff.length() ) 
        sNewSAM = _bstr_t(sTempSAM) + sSuff;
    else
        sNewSAM = sTempSAM;

    wcscpy(sTempUPN, (WCHAR*) sUPN);

    //Get the stuff before the LAST @ sign.
    WCHAR             * ndx = NULL;
    WCHAR             * tempNdx = sTempUPN;
    do
    {
        tempNdx = wcschr(tempNdx + 1, L'@');
        if ( tempNdx ) 
            ndx = tempNdx;
    } while (tempNdx);

    //
    // If UPN prefix and suffix terminate prefix portion
    // otherwise return empty UPN as an internal error
    // has occurred so do not generate UPN for this user.
    //

    if (ndx)
    {
        *ndx = L'\0';
    }
    else
    {
        err.SysMsgWrite(ErrE, E_FAIL, DCT_MSG_UNABLE_TO_GENERATE_UNIQUE_UPN_S, (PCWSTR)sUPN);
        sUPN = L"";
        return;
    }

    sUPNSuffix = ndx+1;
    sUPNPrefix = sTempUPN;

    //
    // User principal names (UPN) must be unique across the forest therefore
    // the name of a global catalog server in the target forest must be
    // obtained so that the entire forest may be queried for user principal names.
    //
    // If unable to obtain name of a global catalog server then log error message
    // and set UPN to an empty string which will cause the UPN attribute not to
    // be set.
    //

    _bstr_t strGlobalCatalogServer;
       
    DWORD dwError = GetGlobalCatalogServer5(sTgtDomain, strGlobalCatalogServer);

    if ((dwError == ERROR_SUCCESS) && (strGlobalCatalogServer.length() > 0))
    {
        wsprintf(sPath, L"GC://%s", (PCWSTR)strGlobalCatalogServer);
    }
    else
    {
        err.SysMsgWrite(ErrE, HRESULT_FROM_WIN32(dwError), DCT_MSG_UNABLE_TO_QUERY_UPN_IN_GLOBAL_CATALOG_SERVER_S, (PCWSTR)sUPN);
        sUPN = L"";
        return;
    }

    // setup the columns that we want the query to return to us.
    pSaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
    if (pSaCols)
    {
        hr = SafeArrayAccessData(pSaCols, (void HUGEP **) &pData);
        if ( SUCCEEDED(hr) )
        {
            pData[0] = SysAllocString(pCols[0]);
            pData[1] = SysAllocString(pCols[1]);

            if (!pData[0] || !pData[1])
            {
                SafeArrayUnaccessData(pSaCols);
                sUPN = L"";
                return;
            }
        }
        hr = SafeArrayUnaccessData(pSaCols);
    }

    if ( SUCCEEDED(hr) )
    {
        // First we need to set up a query to find the UPN
        wcscpy(sTempUPN, (WCHAR*)sUPN);
        do
        {
            _bstr_t sQuery = L"(userPrincipalName=";
            sQuery += GetEscapedFilterValue(sTempUPN).c_str();
            sQuery += L")";
            hr = pQuery->raw_SetQuery(sPath, sTgtDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);

            if ( SUCCEEDED(hr) )
                hr = pQuery->raw_SetColumns(pSaCols);

            if ( SUCCEEDED(hr) ) 
                hr = pQuery->raw_Execute(&pEnum);

            if ( SUCCEEDED(hr) )
            {
                hr = pEnum->Next(1, &var, &fetched);
                while ( hr == S_OK )
                {
                    if ( var.vt & VT_ARRAY )
                    {
                        psaPath = var.parray;
                        hr = SafeArrayAccessData(psaPath, (void HUGEP**) &pVar);
                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Retrieve distinguishedName and sAMAccountName attributes.
                            //

                            if (V_VT(&pVar[0]) == VT_BSTR)
                            {
                                strDn = V_BSTR(&pVar[0]);
                            }

                            if (V_VT(&pVar[1]) == VT_BSTR)
                            {
                                strSam = V_BSTR(&pVar[1]);
                            }
                        }
                        SafeArrayUnaccessData(psaPath);

                        bool bContinue = false;

                        //
                        // If unable to query attributes generate error message and set UPN to empty string.
                        //

                        if (!strDn || !strSam)
                        {
                            err.SysMsgWrite(ErrE, E_FAIL, DCT_MSG_UNABLE_TO_QUERY_UPN_IN_GLOBAL_CATALOG_SERVER_S, (PCWSTR)sUPN);
                            wcscpy(sTempUPN, L"");
                            hr = S_FALSE;
                        }
                        else
                        {
                            //
                            // If the object found is the source domain object continue.
                            // This will be the case during intra-forest migrations.
                            //

                            if (sSrcDomain.length() && (_wcsicmp((wchar_t*)strSam, (wchar_t*)sSourceSam) == 0))
                            {
                                _bstr_t strDomain = GetDomainDNSFromPath(strDn);

                                if (_wcsicmp((wchar_t*)strDomain, (wchar_t*)sSrcDomain) == 0)
                                {
                                    bContinue = true;
                                }
                            }

                            //
                            // If the object found is the target domain object to be replaced continue.
                            //

                            if (!bContinue && bReplace && (_wcsicmp((wchar_t*)strSam, (wchar_t*)sNewSAM) == 0))
                            {
                                _bstr_t strDomain = GetDomainDNSFromPath(strDn);

                                if (_wcsicmp((wchar_t*)strDomain, (wchar_t*)sTgtDomain) == 0)
                                {
                                    bContinue = true;
                                }
                            }
                        }

                        // If the account found is the same as the account being processed then we
                        // need to see if any other accounts have this UPN. if they do then we need
                        // to change it other wise we do not need to process this any further.

                        if (bContinue)
                        {
                            var.Clear();
                            hr = pEnum->Next(1, &var, &fetched);
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                if ( hr == S_OK )
                {
                    // If we are here that means we have a collision So we need to update the UPN and try again
                    // See if we have processed the Prefix/Suffix
                    if ( !bCollPrefSufProcessed )
                    {
                        // See if we renamed the samAccountName with the prefix/suffix. If we are already using 
                        // sam name then there is no need to add the prefix/suffix.
                        if ( !bUsingSamName && RenamedWithPrefixSuffix(sSourceSam, sTargetSam, sPrefix, sSuffix))
                        {
                            // Since we renamed the sam names we can rename the UPN
                            if ( sPrefix.length() )
                                wsprintf(sTempUPN, L"%s%s", (WCHAR*)sPrefix, (WCHAR*)sUPNPrefix);

                            if ( sSuffix.length() )
                                wsprintf(sTempUPN, L"%s%s",(WCHAR*)sUPNPrefix, (WCHAR*)sSuffix);

                            sUPNPrefix = sTempUPN;   // we want to apply the prefix/suffix in any case.
                        }
                        else
                        {
                            // just add a number to the end of the name.
                            wsprintf(sTempUPN, L"%s%d", (WCHAR*)sUPNPrefix, offset);
                            offset++;
                        }
                        bCollPrefSufProcessed = true;
                    }
                    else
                    {
                        //
                        // Attempt sequence numbers only to some reasonable upper limit.
                        //

                        if (offset <= SEQUENCE_UPPER_BOUND)
                        {
                            // we went through prefix/suffix and still found a collision so we need to go by the count now.
                            wsprintf(sTempUPN, L"%s%d", (WCHAR*)sUPNPrefix, offset);
                            offset++;
                        }
                        else
                        {
                            //
                            // If unable to find a unique UPN then must return empty UPN.
                            //

                            err.MsgWrite(ErrE, DCT_MSG_UNABLE_TO_GENERATE_UNIQUE_UPN_S, (PCWSTR)sUPN);
                            wcscpy(sTempUPN, L"");
                            break;
                        }
                    }
                    if (wcslen(sTempUPN) > 0)
                    {
                        wcscpy(sTemp, sTempUPN);
                        wsprintf(sTempUPN, L"%s@%s", (WCHAR*)sTemp, (WCHAR*)sUPNSuffix);
                    }
                }
                var.Clear();
            }
            else
            {
                err.SysMsgWrite(ErrE, hr, DCT_MSG_UNABLE_TO_QUERY_UPN_IN_GLOBAL_CATALOG_SERVER_S, (PCWSTR)sUPN);
            }
        } while ( hr == S_OK );
        SafeArrayDestroy(pSaCols);
    }

    if (FAILED(hr))
    {
        sUPN = L"";
    }
    else
    {
        sUPN = sTempUPN;
    }
}

//---------------------------------------------------------------------------
// RenamedWithPrefixSuffix : Checks to see if the Target sam name 
//                           was renamed with a prefix/suffix.
//---------------------------------------------------------------------------
bool CUpdtUPN::RenamedWithPrefixSuffix(_bstr_t sSourceSam, _bstr_t sTargetSam, _bstr_t sPrefix, _bstr_t sSuffix)
{
   bool retVal = false;
   if ( sSourceSam != sTargetSam )
   {
      if ( sPrefix.length() )
      {
         if ( !wcsncmp((WCHAR*) sTargetSam, (WCHAR*) sPrefix, sPrefix.length()) )
            retVal = true;
      }

      if ( sSuffix.length() )
      {
         if ( !wcscmp((WCHAR*) sTargetSam + (sTargetSam.length() - sSuffix.length()), (WCHAR*) sSuffix ) )
            retVal = true;
      }
   }
   return retVal;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 24 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the default UPN   *
 * suffix to be used in making UPN names.  The suffix will be stored *
 * in a class member variable.                                       *
 *     First, using the given target OU path, see if the target OU   *
 * has any UPN suffixes defined for it.  If so, return store the     *
 * last one enumerated.  Otherwise, see if any UPN suffixes have     *
 * been defined on the configuration's partition.  If so, store the  *
 * last one enumerated.  If no success yet, use the forest root's    *
 * domain DNS name.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDefaultUPNSuffix
bool CUpdtUPN::GetDefaultUPNSuffix(_bstr_t sDomainDNS, _bstr_t sTargetOU)
{
/* local variables */
   IADs                 * pDSE = NULL;
   IADs                 * pCont = NULL;
   WCHAR                  sRoot[1000];
   HRESULT                hr = S_OK;
   _variant_t             var;
   _variant_t   HUGEP   * pVar;
   int                    nLast;

/* function body */
      //check incoming parameters
   if ((sDomainDNS.length() == 0) || (sTargetOU.length() == 0))
      return false;

  /* first see if the target OU has UPN suffixes defined */
     //get a pointer to the target OU
  hr = ADsGetObject(sTargetOU,IID_IADs,(void**)&pCont);
  if ( SUCCEEDED(hr) )
  {
        //get any UPN suffixes defined
     hr = pCont->Get( L"uPNSuffixes", &var);
     if ( SUCCEEDED(hr) ) 
     {
        //if one, store it and return
        if ( var.vt == VT_BSTR )
        {
           m_sUPNSuffix = var.bstrVal;  //store the suffix
           pCont->Release();
           return true;
        }
           //else if nore than one, get the first one, store it, and return
        else if ( var.vt & VT_ARRAY )
        {
           SAFEARRAY * multiVals = var.parray; 
           SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
           nLast = multiVals->rgsabound->cElements - 1;
           m_sUPNSuffix = _bstr_t(V_BSTR(&pVar[nLast]));
           SafeArrayUnaccessData(multiVals);
           pCont->Release();
           return true;
        }
     }//end if suffixes defined on the partition
     pCont->Release();
     pCont = NULL;
  }//if got partition

  /* next try the UPN suffixes on the partition container or the root
     domain's DNS name */
     //get the root DSE container
  _snwprintf(sRoot, sizeof(sRoot) / sizeof(sRoot[0]), L"LDAP://%s/RootDSE", (WCHAR*)sDomainDNS);
  sRoot[sizeof(sRoot) / sizeof(sRoot[0]) - 1] = L'\0';
  hr = ADsGetObject(sRoot,IID_IADs,(void**)&pDSE);
  if ( SUCCEEDED(hr) )
  {
        //get the suffixes listed on the configuration partition
     hr = pDSE->Get(L"configurationNamingContext",&var);
     if ( SUCCEEDED(hr) )
     {
        swprintf(sRoot,L"LDAP://%ls/CN=Partitions,%ls", (WCHAR*)sDomainDNS, var.bstrVal);
        hr = ADsGetObject(sRoot,IID_IADs,(void**)&pCont);
        if ( SUCCEEDED(hr) )
        {
              //get any UPN suffixes defined
           hr = pCont->Get( L"uPNSuffixes", &var);
           if ( SUCCEEDED(hr) ) 
           {
                 //if one, store it and return
              if ( var.vt == VT_BSTR )
              {
                 m_sUPNSuffix = var.bstrVal;  //store the suffix
                 pDSE->Release();
                 pCont->Release();
                 return true;
              }
                 //else if nore than one, get the first one, store it, and return
              else if ( var.vt & VT_ARRAY )
              {
                 SAFEARRAY * multiVals = var.parray; 
                 SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
                 nLast = multiVals->rgsabound->cElements - 1;
                 m_sUPNSuffix = _bstr_t(V_BSTR(&pVar[nLast]));
                 SafeArrayUnaccessData(multiVals);
                 pDSE->Release();
                 pCont->Release();
                 return true;
              }
           }//end if suffixes defined on the partition
           pCont->Release();
           pCont = NULL;
        }//if got partition
     }//if got config naming context

     //since no UPN suffixes defined on the partition, try the root domain's
     //DNS name
     hr = pDSE->Get(L"RootDomainNamingContext",&var);
     if ( SUCCEEDED(hr) )
     {
           //convert the DN of the root domain to a DNS name, store it, and return
        m_sUPNSuffix = GetDomainDNSFromPath(_bstr_t(var.bstrVal));
        pDSE->Release();
        return true;
     }
     pDSE->Release();
     pDSE = NULL;
  }//if got rootDSE
  return false;
}
//END GetDefaultUPNSuffix


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for extracting the UPN Suffix    *
 * from a given UPN name and returning that suffix.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetUPNSuffix
_bstr_t CUpdtUPN::GetUPNSuffix(_bstr_t sUPNName)
{
/* local variables */
   _bstr_t      sUPNSuffix = L"";
   WCHAR *      pTemp;

/* function body */
      //check incoming parameters
   if (sUPNName.length() == 0)
      return sUPNSuffix;

      //find the last '@'
   pTemp = wcsrchr((WCHAR*)sUPNName, L'@');

      //if found, copy the suffix to the return variable
   if (pTemp)
      sUPNSuffix = pTemp+1;

   return sUPNSuffix;
}
//END GetUPNSuffix


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for replacing the UPN Suffix     *
 * on a given UPN name with the given suffix and returning the new   *
 * UPN name.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN ChangeUPNSuffix
_bstr_t CUpdtUPN::ChangeUPNSuffix(_bstr_t sUPNName, _bstr_t sNewSuffix)
{
/* local variables */
   _bstr_t      sNewUPN = L"";
   WCHAR *      pTemp;

/* function body */
      //check incoming parameters
   if (sUPNName.length() == 0)
      return sNewUPN;

      //create a temporary buffer to hold the UPN Name
   WCHAR* sUPN = new WCHAR[sUPNName.length() + 1];
   if (!sUPN)
      return sNewUPN;

      //copy the UPN to this buffer
   wcscpy(sUPN, sUPNName);

      //find the last '@'
   pTemp = wcsrchr(sUPN, L'@');

      //if found, make the new UPN with the old Prefix and given suffix
   if (pTemp)
   {
        //end the string after the '@'
      *(pTemp+1) = L'\0';

        //copy the Prefix plus the new Suffix to the new UPN name
      sNewUPN = sUPN + sNewSuffix;
   }
      //delete the prefix string
   delete [] sUPN;

   return sNewUPN;
}
//END ChangeUPNSuffix
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\arext\upnupdt\upnupdt.cpp ===
// UPNUpdt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UPNUpdtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UPNUpdt.h"

#include "UPNUpdt_i.c"
#include "UpdtUPN.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_UpdtUPN, CUpdtUPN)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_UPNUPDTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\argument.h ===
#pragma once


//---------------------------------------------------------------------------
// Arguments Class
//---------------------------------------------------------------------------


class CArguments
{
public:

	CArguments(int argc, wchar_t* argv[]) :
		m_iArg(1),
		m_cArg(argc),
		m_ppszArg(argv)
	{
	}

	LPCTSTR Value()
	{
		LPCTSTR pszArg = NULL;

		if ((m_iArg > 0) && (m_iArg < m_cArg))
		{
			pszArg = m_ppszArg[m_iArg];
		}

		return pszArg;
	}

	bool Next()
	{
		if (m_iArg < m_cArg)
		{
			++m_iArg;
		}

		return (m_iArg < m_cArg);
	}

	bool Prev()
	{
		if (m_iArg > 0)
		{
			--m_iArg;
		}

		return (m_iArg > 0);
	}

protected:

	CArguments(const CArguments& r) {}
	CArguments& operator =(const CArguments& r) { return *this; }

protected:

	int m_iArg;
	int m_cArg;
	_TCHAR** m_ppszArg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\admtcommand.cpp ===
#include "StdAfx.h"
#include "Argument.h"
#include "Parameter.h"
#include "Migration.h"
#include "Switch.h"
#include "MonitorThread.h"
#include "GenerateKey.h"
#include "RegistryHelper.h"
#include "IsAdmin.hpp"


namespace PrintUsage
{

void __stdcall PrintADMTUsage();
void __stdcall PrintUserUsage();
void __stdcall PrintGroupUsage();
void __stdcall PrintComputerUsage();
void __stdcall PrintSecurityUsage();
void __stdcall PrintServiceUsage();
void __stdcall PrintReportUsage();
void __stdcall PrintKeyUsage();
void __stdcall PrintUsage(UINT uId[], UINT cId);
void __stdcall GetString(UINT uId, LPTSTR pszBuffer, int cchBuffer);

}

using namespace PrintUsage;


//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------


int __cdecl _tmain(int argc, LPTSTR argv[])
{
	HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

	if (SUCCEEDED(hr))
	{
		_RPT0(_CRT_WARN, _T("{ADMT.exe}_tmain() : Enter\n"));
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

		
		try
		{
		       DWORD lRet = MoveRegistry();
		       if (lRet != ERROR_SUCCESS)
        		       ThrowError(HRESULT_FROM_WIN32(lRet), IDS_E_UPDATE_REGISTRY_FAILED);

			CArguments aArgs(argc, argv);
			CParameterMap mapParams(aArgs);

			long lTask;

			if (mapParams.GetValue(SWITCH_TASK, lTask))
			{
				bool bHelp;

				if (!mapParams.GetValue(SWITCH_HELP, bHelp))
				{
					bHelp = false;
				}

				switch (lTask)
				{
					case TASK_USER:
					{
						if (bHelp)
						{
							PrintUserUsage();
						}
						else
						{							
							CUserMigration(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_GROUP:
					{
						if (bHelp)
						{
							PrintGroupUsage();
						}
						else
						{							
							CGroupMigration(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_COMPUTER:
					{
						if (bHelp)
						{
							PrintComputerUsage();
						}
						else
						{							
							CComputerMigration(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_SECURITY:
					{
						if (bHelp)
						{
							PrintSecurityUsage();
						}
						else
						{							
							CSecurityTranslation(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_SERVICE:
					{
						if (bHelp)
						{
							PrintServiceUsage();
						}
						else
						{							
							CServiceEnumeration(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_REPORT:
					{
						if (bHelp)
						{
							PrintReportUsage();
						}
						else
						{							
							CReportGeneration(CMigration(mapParams), mapParams);							
						}
						break;
					}
					case TASK_KEY:
					{
						if (bHelp)
						{
							PrintKeyUsage();
						}
						else
						{
						       lRet = IsAdminLocal();
                                                 if (lRet != ERROR_SUCCESS)
                                                    ThrowError(HRESULT_FROM_WIN32(lRet), IDS_E_LOCAL_ADMIN_CHECK_FAILED);

							_bstr_t strKeyId;

							if (!mapParams.GetValue(SWITCH_KEY_IDENTIFIER, strKeyId))
							{
								ThrowError(E_INVALIDARG, IDS_E_NO_KEY_DOMAIN);
							}

							_bstr_t strDrive;

							if (!mapParams.GetValue(SWITCH_KEY_FOLDER, strDrive))
							{
								ThrowError(E_INVALIDARG, IDS_E_NO_KEY_FOLDER);
							}

							_bstr_t strPassword;

							mapParams.GetValue(SWITCH_KEY_PASSWORD, strPassword);

							GeneratePasswordKey(strKeyId, strPassword, strDrive);
						}
						break;
					}
					default:
					{
						_ASSERT(false);
						break;
					}
				}
			}
			else
			{
				PrintADMTUsage();
			}
		}
		catch (_com_error& ce)
		{
			
			_com_error ceNew(ce);

			_bstr_t strDescription = ceNew.Description();

			if (!strDescription)
			{
			   IErrorInfo* pErrorInfo = NULL;

			   if (GetErrorInfo(0, &pErrorInfo) == S_OK)
			   {
				  ceNew = _com_error(ceNew.Error(), pErrorInfo);
			   }
			}

			strDescription = ceNew.Description();

			if (strDescription.length())
			{
				My_fwprintf(_T("%s (0x%08lX)\n"), (LPCTSTR)strDescription, ceNew.Error());
			}
			else
			{
				My_fwprintf(_T("%s (0x%08lX)\n"), (LPCTSTR)ceNew.ErrorMessage(), ceNew.Error());
			}
		}
		catch (...)
		{
			My_fwprintf(_T("%s (0x%08lX)\n"), _com_error(E_FAIL).ErrorMessage(), E_FAIL);
		}

		_RPT0(_CRT_WARN, _T("{ADMT.exe}_tmain() : Leave\n"));

		CoUninitialize();
	}

	return 0;
}


// Print Usage --------------------------------------------------------------


namespace PrintUsage
{


void __stdcall PrintADMTUsage()
{
	static UINT s_uId[] =
	{
		IDS_USAGE_SYNTAX,
		IDS_USAGE_ADMT,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintUserUsage()
{
	static UINT s_uId[] =
	{
		// user command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_USER,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// user migration options
		IDS_USAGE_PASSWORDOPTION,
		IDS_USAGE_PASSWORDSERVER,
		IDS_USAGE_PASSWORDFILE,
		IDS_USAGE_DISABLEOPTION,
		IDS_USAGE_SOURCEEXPIRATION,
		IDS_USAGE_MIGRATESIDS,
		IDS_USAGE_TRANSLATEROAMINGPROFILE,
		IDS_USAGE_UPDATEUSERRIGHTS,
		IDS_USAGE_MIGRATEGROUPS,
		IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS,
		IDS_USAGE_FIXGROUPMEMBERSHIP,
		IDS_USAGE_MIGRATESERVICEACCOUNTS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_U,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_USERPROPERTIESTOEXCLUDE,
		IDS_USAGE_INETORGPERSONPROPERTIESTOEXCLUDE,
		IDS_USAGE_GROUPPROPERTIESTOEXCLUDE,
		// users to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintGroupUsage()
{
	static UINT s_uId[] =
	{
		// group command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_GROUP,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// group migration options
		IDS_USAGE_UPDATEGROUPRIGHTS,
		IDS_USAGE_FIXGROUPMEMBERSHIP,
		IDS_USAGE_MIGRATESIDS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_G,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_GROUPPROPERTIESTOEXCLUDE,
		// member migration options
		IDS_USAGE_MIGRATEMEMBERS,
		IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS,
		IDS_USAGE_PASSWORDOPTION,
		IDS_USAGE_PASSWORDSERVER,
		IDS_USAGE_PASSWORDFILE,
		IDS_USAGE_DISABLEOPTION,
		IDS_USAGE_SOURCEEXPIRATION,
		IDS_USAGE_TRANSLATEROAMINGPROFILE,
		IDS_USAGE_USERPROPERTIESTOEXCLUDE,
		IDS_USAGE_INETORGPERSONPROPERTIESTOEXCLUDE,
		// groups to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintComputerUsage()
{
	static UINT s_uId[] =
	{
		// computer command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_COMPUTER,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// computer migration options
		IDS_USAGE_TRANSLATIONOPTION,
		IDS_USAGE_TRANSLATEFILESANDFOLDERS,
		IDS_USAGE_TRANSLATELOCALGROUPS,
		IDS_USAGE_TRANSLATEPRINTERS,
		IDS_USAGE_TRANSLATEREGISTRY,
		IDS_USAGE_TRANSLATESHARES,
		IDS_USAGE_TRANSLATEUSERPROFILES,
		IDS_USAGE_TRANSLATEUSERRIGHTS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_C,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_RESTARTDELAY,
		IDS_USAGE_COMPUTERPROPERTIESTOEXCLUDE,
		// computers to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintSecurityUsage()
{
	static UINT s_uId[] =
	{
		// security command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_SECURITY,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		// security migration options
		IDS_USAGE_TRANSLATIONOPTION,
		IDS_USAGE_TRANSLATEFILESANDFOLDERS,
		IDS_USAGE_TRANSLATELOCALGROUPS,
		IDS_USAGE_TRANSLATEPRINTERS,
		IDS_USAGE_TRANSLATEREGISTRY,
		IDS_USAGE_TRANSLATESHARES,
		IDS_USAGE_TRANSLATEUSERPROFILES,
		IDS_USAGE_TRANSLATEUSERRIGHTS,
		IDS_USAGE_SIDMAPPINGFILE,
		// computers to perform security translation on
		IDS_USAGE_INCLUDE_C,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintServiceUsage()
{
	static UINT s_uId[] =
	{
		// security command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_SERVICE,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		// computers to perform security translation on
		IDS_USAGE_INCLUDE_C,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintReportUsage()
{
	static UINT s_uId[] =
	{
		// report command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_REPORT,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		// report options
		IDS_USAGE_REPORTTYPE,
		IDS_USAGE_REPORTFOLDER,
		// computers to generate reports for
		IDS_USAGE_INCLUDE_D,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintKeyUsage()
{
	static UINT s_uId[] =
	{
		IDS_USAGE_SYNTAX,
		IDS_USAGE_KEY,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintUsage(UINT uId[], UINT cId)
{
	_TCHAR szBuffer[512];

	// print this is command syntax line

	if (cId > 0)
	{
		GetString(uId[0], szBuffer, countof(szBuffer));
		My_fwprintf(_T("%s\n\n"), szBuffer);
	}

	// print command

	if (cId > 1)
	{
		GetString(uId[1], szBuffer, countof(szBuffer));
		My_fwprintf(_T("%s\n\n"), szBuffer);
	}

	// print options

	if (cId > 2)
	{
		for (UINT i = 2; i < cId; i++)
		{
			GetString(uId[i], szBuffer, countof(szBuffer));

			My_fwprintf(_T("%s\n"), szBuffer);
		}
	}
}

void __stdcall GetString(UINT uId, LPTSTR pszBuffer, int cchBuffer)
{
	if (pszBuffer)
	{
		if (LoadString(GetModuleHandle(NULL), uId, pszBuffer, cchBuffer) == 0)
		{
			pszBuffer[0] = _T('\0');
		}
	}
}


}



//
// Based on LDIFDE/CSVDE.
//
// Prints Unicode formatted string to console window using WriteConsoleW.
// Note: This My_fwprintf() is used to workaround the problem in c-runtime
// which looks up LC_CTYPE even for Unicode string.
//

int __cdecl
My_fwprintf(
    const WCHAR *format,
    ...
   )
{
    DWORD  cchChar;

    va_list args;
    va_start( args, format );

    cchChar = My_vfwprintf(format, args);

    va_end(args);

    return cchChar;
}


int __cdecl
My_vfwprintf(
    const WCHAR *format,
    va_list argptr
   )
{
    
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD currentMode;
    DWORD cchChar;
    
    const DWORD dwBufferMessageSize = 4096;
    WCHAR  szBufferMessage[dwBufferMessageSize];

    _vsnwprintf( szBufferMessage, dwBufferMessageSize, format, argptr );
    szBufferMessage[dwBufferMessageSize-1] = L'\0';
    
    cchChar = wcslen(szBufferMessage);

    if (GetFileType(hOut) == FILE_TYPE_CHAR && GetConsoleMode(hOut, &currentMode))
    {
        WriteConsoleW(hOut, szBufferMessage, cchChar, &cchChar, NULL);
    }
    else
    {
        int charCount = WideCharToMultiByte(CP_ACP, 0, szBufferMessage, -1, 0, 0, 0, 0);
        char* szaStr = new char[charCount];
        if (szaStr != NULL)
        {
            DWORD dwBytesWritten;
            WideCharToMultiByte(CP_ACP, 0, szBufferMessage, -1, szaStr, charCount, 0, 0);
            WriteFile(hOut, szaStr, charCount - 1, &dwBytesWritten, 0);
            delete[] szaStr;
        }
        else
        {
            cchChar = 0;
        }
    }

    return cchChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\generatekey.cpp ===
#include "StdAfx.h"
#include "GenerateKey.h"

#include <AdmtCrypt.h>


void __stdcall GeneratePasswordKey(LPCTSTR pszDomainName, LPCTSTR pszPassword, LPCTSTR pszFolder)
{
    // validate parameters

    if ((pszFolder == NULL) || (pszFolder[0] == NULL))
    {
        ThrowError(E_INVALIDARG);
    }

    // generate full path to folder

    _TCHAR szPath[_MAX_PATH];
    LPTSTR pszFilePart;

    DWORD cchPath = GetFullPathName(pszFolder, _MAX_PATH, szPath, &pszFilePart);

    if ((cchPath == 0) || (cchPath >= _MAX_PATH))
    {
        DWORD dwError = GetLastError();
        HRESULT hr = (dwError != ERROR_SUCCESS) ? HRESULT_FROM_WIN32(dwError) : E_INVALIDARG;

        ThrowError(hr, IDS_E_INVALID_FOLDER, pszFolder);
    }

    // path must be terminated with path separator otherwise
    // _tsplitpath will treat last path component as file name

    if (szPath[cchPath - 1] != _T('\\'))
    {
        _tcscat(szPath, _T("\\"));
    }

    _TCHAR szDrive[_MAX_DRIVE];
    _TCHAR szDir[_MAX_DIR];

    _tsplitpath(szPath, szDrive, szDir, NULL, NULL);

    // verify drive is a local drive

    _TCHAR szTestDrive[_MAX_PATH];
    _tmakepath(szTestDrive, szDrive, _T("\\"), NULL, NULL);

    if (GetDriveType(szTestDrive) == DRIVE_REMOTE)
    {
        ThrowError(E_INVALIDARG, IDS_E_NOT_LOCAL_DRIVE, pszFolder);
    }

    // generate random name

    static _TCHAR s_chName[] = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");

    BYTE bRandom[8];

    try
    {
        CCryptProvider crypt;
        crypt.GenerateRandom(bRandom, 8);
    }
    catch (_com_error& ce)
    {
        //
        // The message 'keyset not defined' is returned when
        // the enhanced provider (128 bit) is not available
        // therefore return a more meaningful message to user.
        //

        if (ce.Error() == NTE_KEYSET_NOT_DEF)
        {
            ThrowError(ce, IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED);
        }
        else
        {
            throw;
        }
    }

    _TCHAR szName[9];

    for (int i = 0; i < 8; i++)
    {
        szName[i] = s_chName[bRandom[i] % (countof(s_chName) - 1)];
    }

    szName[8] = _T('\0');

    // generate path to key file

    _TCHAR szKeyFile[_MAX_PATH];
    _tmakepath(szKeyFile, szDrive, szDir, szName, _T(".pes"));

    // generate key

    IPasswordMigrationPtr spPasswordMigration(__uuidof(PasswordMigration));
    spPasswordMigration->GenerateKey(pszDomainName, szKeyFile, pszPassword);

    // print success message to console

    _TCHAR szFormat[256];

    if (LoadString(GetModuleHandle(NULL), IDS_MSG_KEY_CREATED, szFormat, countof(szFormat)) > 0)
    {
        My_fwprintf(szFormat, pszDomainName, szKeyFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\generatekey.h ===
#pragma once

#include "Resource.h"


void __stdcall GeneratePasswordKey(LPCTSTR pszDomainName, LPCTSTR pszPassword, LPCTSTR pszFolder);

#ifdef _DEBUG

void __stdcall ImportPasswordKey(LPCTSTR pszFolder, LPCTSTR pszPassword);
void TestSession(LPCTSTR pszDomainName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\less.h ===
#pragma once

#include <functional>


//---------------------------------------------------------------------------
// String Ignore Case Less Structure
//---------------------------------------------------------------------------


struct StringIgnoreCaseLess :
	public std::binary_function<_bstr_t, _bstr_t, bool>
{
	bool operator()(const _bstr_t& x, const _bstr_t& y) const
	{
		bool bLess;

		LPCTSTR pszThis = x;
		LPCTSTR pszThat = y;

		if (pszThis == pszThat)
		{
			bLess = false;
		}
		else if (pszThis == NULL)
		{
			bLess = true;
		}
		else if (pszThat == NULL)
		{
			bLess = false;
		}
		else
		{
			bLess = _tcsicmp(pszThis, pszThat) < 0;
		}

		return bLess;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\monitorthread.h ===
#pragma once

#include "Thread.h"


//---------------------------------------------------------------------------
// MonitorThread Class
//---------------------------------------------------------------------------


class CMonitorThread : public CThread
{
public:

	CMonitorThread();
	virtual ~CMonitorThread();

	void Start();
	void Stop();

protected:

	virtual void Run();

	void ProcessMigrationLog(bool bCheckModifyTime = true);
	void ProcessDispatchLog(bool bInitialize = false, bool bCheckModifyTime = true);

private:

	_bstr_t m_strMigrationLog;
	HANDLE m_hMigrationLog;
	FILETIME m_ftMigrationLogLastWriteTime;

	_bstr_t m_strDispatchLog;
	HANDLE m_hDispatchLog;
	FILETIME m_ftDispatchLogLastWriteTime;
	FILETIME m_ftMonitorBeginTime;
	bool m_bDontNeedCheckMonitorBeginTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\migration.h ===
#pragma once

#include "Parameter.h"
#include <MigrationMutex.h>
#include "MonitorThread.h"


//---------------------------------------------------------------------------
// Migration Class
//---------------------------------------------------------------------------

namespace
{
inline void __stdcall GetString(UINT uId, LPTSTR pszBuffer, int cchBuffer)
{
	if (pszBuffer)
	{
		if (LoadString(GetModuleHandle(NULL), uId, pszBuffer, cchBuffer) == 0)
		{
			pszBuffer[0] = _T('\0');
		}
	}
}
}


class CMigration
{
public:

	CMigration(CParameterMap& mapParams) :
		m_spMigration(__uuidof(Migration))
	{
		Initialize(mapParams);
	}

	IUserMigrationPtr CreateUserMigration()
	{
		return m_spMigration->CreateUserMigration();
	}

	IGroupMigrationPtr CreateGroupMigration()
	{
		return m_spMigration->CreateGroupMigration();
	}

	IComputerMigrationPtr CreateComputerMigration()
	{
		return m_spMigration->CreateComputerMigration();
	}

	ISecurityTranslationPtr CreateSecurityTranslation()
	{
		return m_spMigration->CreateSecurityTranslation();
	}

	IServiceAccountEnumerationPtr CreateServiceAccountEnumeration()
	{
		return m_spMigration->CreateServiceAccountEnumeration();
	}

	IReportGenerationPtr CreateReportGeneration()
	{
		return m_spMigration->CreateReportGeneration();
	}

protected:

	CMigration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IMigrationPtr m_spMigration;
};


class CCmdMigrationBase
{
    public:          	

        bool MutexWait(DWORD dwTimeOut = INFINITE)
        {
            return m_Mutex.ObtainOwnership(dwTimeOut);
        }

        void MutexRelease()
        {
            m_Mutex.ReleaseOwnership();
        }

        void StartMonitoring()
        {
            // check if the other admt process is already running (by trying to obtain the mutex), if true, print out 
            // an error message. This should handle most of the cases
            bool bStatus;
            _TCHAR szBuffer[512] = _T("");
            DWORD dwCharsWritten;
            HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

            bStatus = MutexWait(1);
            

            if(!bStatus)
            {
                GetString(IDS_E_PROCESS_RUNNING, szBuffer, countof(szBuffer));
                WriteConsole(hStdOut, szBuffer, _tcslen(szBuffer), &dwCharsWritten, NULL); 

                MutexWait();
                
            }

            // start the monitoring thread
            
            m_Monitor.Start();            
        }

        void StopMonitoring()
        {
            m_Monitor.Stop();

	        MutexRelease();
        }
    	
    protected:
    	CCmdMigrationBase() :
    		m_Mutex(ADMT_MUTEX)
    	{
    	}

    	~CCmdMigrationBase() {}

    	

    protected:
    	CMigrationMutex m_Mutex;
    	CMonitorThread m_Monitor;
    	
};



//---------------------------------------------------------------------------
// User Migration Class
//---------------------------------------------------------------------------


class CUserMigration :
    public CCmdMigrationBase
{
public:

	CUserMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spUser(rMigration.CreateUserMigration())		
	{
		Initialize(mapParams);
	}

	
protected:

	CUserMigration() 	{}	

	void Initialize(CParameterMap& mapParams);

protected:

	IUserMigrationPtr m_spUser;	
};


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


class CGroupMigration :
    public CCmdMigrationBase
{
public:

	CGroupMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spGroup(rMigration.CreateGroupMigration())		
	{
		Initialize(mapParams);
	}

	
protected:

	CGroupMigration() {}	

	void Initialize(CParameterMap& mapParams);

protected:

	IGroupMigrationPtr m_spGroup;	
};


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


class CComputerMigration :
    public CCmdMigrationBase
{
public:

	CComputerMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spComputer(rMigration.CreateComputerMigration())		
	{
		Initialize(mapParams);
	}

	
protected:

	CComputerMigration() {}	

	void Initialize(CParameterMap& mapParams);

protected:

	IComputerMigrationPtr m_spComputer;	
};


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


class CSecurityTranslation :
    public CCmdMigrationBase
{
public:

	CSecurityTranslation(CMigration& rMigration, CParameterMap& mapParams) :
		m_spSecurity(rMigration.CreateSecurityTranslation())		
	{
		Initialize(mapParams);
	}


protected:

	CSecurityTranslation() {}	

	void Initialize(CParameterMap& mapParams);

protected:

	ISecurityTranslationPtr m_spSecurity;	
};


//---------------------------------------------------------------------------
// Service Enumeration Class
//---------------------------------------------------------------------------


class CServiceEnumeration :
    public CCmdMigrationBase
{
public:

	CServiceEnumeration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spService(rMigration.CreateServiceAccountEnumeration())		
	{
		Initialize(mapParams);
	}
	
protected:

	CServiceEnumeration() {}	

	void Initialize(CParameterMap& mapParams);

protected:

	IServiceAccountEnumerationPtr m_spService;	
};


//---------------------------------------------------------------------------
// Report Generation Class
//---------------------------------------------------------------------------


class CReportGeneration :
    public CCmdMigrationBase
{
public:

	CReportGeneration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spReport(rMigration.CreateReportGeneration())		
	{
		Initialize(mapParams);
	}

protected:

	CReportGeneration() {}	

	void Initialize(CParameterMap& mapParams);

protected:

	IReportGenerationPtr m_spReport;	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\migration.cpp ===
#include "StdAfx.h"
#include "Migration.h"
#include "Switch.h"


namespace
{

void __stdcall AdmtCheckError(HRESULT hr)
{
	if (FAILED(hr))
	{
		IErrorInfo* pErrorInfo = NULL;

		if (GetErrorInfo(0, &pErrorInfo) == S_OK)
		{
			_com_raise_error(hr, pErrorInfo);
		}
		else
		{
			_com_issue_error(hr);
		}
	}
}


}


//---------------------------------------------------------------------------
// Migration Class
//---------------------------------------------------------------------------


void CMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_TEST_MIGRATION, bValue))
	{
		m_spMigration->TestMigration = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_INTRA_FOREST, bValue))
	{
		m_spMigration->IntraForest = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_DOMAIN, strValue))
	{
		m_spMigration->SourceDomain = strValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_OU, strValue))
	{
		m_spMigration->SourceOu = strValue;
	}

	if (mapParams.GetValue(SWITCH_TARGET_DOMAIN, strValue))
	{
		m_spMigration->TargetDomain = strValue;
	}

	if (mapParams.GetValue(SWITCH_TARGET_OU, strValue))
	{
		m_spMigration->TargetOu = strValue;
	}

	if (mapParams.GetValue(SWITCH_RENAME_OPTION, lValue))
	{
		m_spMigration->RenameOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_RENAME_PREFIX_OR_SUFFIX, strValue))
	{
		m_spMigration->RenamePrefixOrSuffix = strValue;
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_OPTION, lValue))
	{
		m_spMigration->PasswordOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_SERVER, strValue))
	{
		AdmtCheckError(m_spMigration->put_PasswordServer(strValue));
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_FILE, strValue))
	{
		m_spMigration->PasswordFile = strValue;
	}

	if (mapParams.GetValue(SWITCH_CONFLICT_OPTIONS, lValue))
	{
		m_spMigration->ConflictOptions = lValue;
	}

	if (mapParams.GetValue(SWITCH_CONFLICT_PREFIX_OR_SUFFIX, strValue))
	{
		m_spMigration->ConflictPrefixOrSuffix = strValue;
	}

	if (mapParams.GetValue(SWITCH_USER_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->UserPropertiesToExclude = strValue;
	}

	if (mapParams.GetValue(SWITCH_INETORGPERSON_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->InetOrgPersonPropertiesToExclude = strValue;
	}

	if (mapParams.GetValue(SWITCH_GROUP_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->GroupPropertiesToExclude = strValue;
	}

	if (mapParams.GetValue(SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->ComputerPropertiesToExclude = strValue;
	}
}


//---------------------------------------------------------------------------
// User Migration Class
//---------------------------------------------------------------------------


void CUserMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_DISABLE_OPTION, lValue))
	{
		m_spUser->DisableOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spUser->SourceExpiration = lValue;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_SIDS, bValue))
	{
		m_spUser->MigrateSIDs = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_ROAMING_PROFILE, bValue))
	{
		m_spUser->TranslateRoamingProfile = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_USER_RIGHTS, bValue))
	{
		m_spUser->UpdateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_GROUPS, bValue))
	{
		m_spUser->MigrateGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, bValue))
	{
		m_spUser->UpdatePreviouslyMigratedObjects = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_FIX_GROUP_MEMBERSHIP, bValue))
	{
		m_spUser->FixGroupMembership = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_SERVICE_ACCOUNTS, bValue))
	{
		m_spUser->MigrateServiceAccounts = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spUser->SourceExpiration = lValue;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spUser->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spUser->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spUser->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}

	StopMonitoring();
	
}


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


void CGroupMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_MIGRATE_SIDS, bValue))
	{
		m_spGroup->MigrateSIDs = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_GROUP_RIGHTS, bValue))
	{
		m_spGroup->UpdateGroupRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, bValue))
	{
		m_spGroup->UpdatePreviouslyMigratedObjects = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_FIX_GROUP_MEMBERSHIP, bValue))
	{
		m_spGroup->FixGroupMembership = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_MEMBERS, bValue))
	{
		m_spGroup->MigrateMembers = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_DISABLE_OPTION, lValue))
	{
		m_spGroup->DisableOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spGroup->SourceExpiration = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_ROAMING_PROFILE, bValue))
	{
		m_spGroup->TranslateRoamingProfile = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spGroup->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spGroup->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spGroup->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}

	StopMonitoring();
	
}


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


void CComputerMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_TRANSLATION_OPTION, lValue))
	{
		m_spComputer->TranslationOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_FILES_AND_FOLDERS, bValue))
	{
		m_spComputer->TranslateFilesAndFolders = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_LOCAL_GROUPS, bValue))
	{
		m_spComputer->TranslateLocalGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_PRINTERS, bValue))
	{
		m_spComputer->TranslatePrinters = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_REGISTRY, bValue))
	{
		m_spComputer->TranslateRegistry = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_SHARES, bValue))
	{
		m_spComputer->TranslateShares = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_PROFILES, bValue))
	{
		m_spComputer->TranslateUserProfiles = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_RIGHTS, bValue))
	{
		m_spComputer->TranslateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_RESTART_DELAY, lValue))
	{
		m_spComputer->RestartDelay = lValue;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spComputer->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spComputer->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spComputer->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}

	StopMonitoring();
	
}


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


void CSecurityTranslation::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_TRANSLATION_OPTION, lValue))
	{
		m_spSecurity->TranslationOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_FILES_AND_FOLDERS, bValue))
	{
		m_spSecurity->TranslateFilesAndFolders = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_LOCAL_GROUPS, bValue))
	{
		m_spSecurity->TranslateLocalGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_PRINTERS, bValue))
	{
		m_spSecurity->TranslatePrinters = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_REGISTRY, bValue))
	{
		m_spSecurity->TranslateRegistry = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_SHARES, bValue))
	{
		m_spSecurity->TranslateShares = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_PROFILES, bValue))
	{
		m_spSecurity->TranslateUserProfiles = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_RIGHTS, bValue))
	{
		m_spSecurity->TranslateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SID_MAPPING_FILE, strValue))
	{
		AdmtCheckError(m_spSecurity->put_SidMappingFile(strValue));
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spSecurity->raw_Translate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spSecurity->raw_Translate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spSecurity->raw_Translate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}

	StopMonitoring();
	
}


//---------------------------------------------------------------------------
// Service Enumeration Class
//---------------------------------------------------------------------------


void CServiceEnumeration::Initialize(CParameterMap& mapParams)
{
	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spService->raw_Enumerate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spService->raw_Enumerate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spService->raw_Enumerate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}

	StopMonitoring();
	
}


//---------------------------------------------------------------------------
// Report Generation Class
//---------------------------------------------------------------------------


void CReportGeneration::Initialize(CParameterMap& mapParams)
{
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_REPORT_TYPE, lValue))
	{
		m_spReport->Type = lValue;
	}

	if (mapParams.GetValue(SWITCH_REPORT_FOLDER, strValue))
	{
		AdmtCheckError(m_spReport->put_Folder(strValue));
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	StartMonitoring();

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		m_spReport->raw_Generate(admtData, vntIncludeNames, vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		m_spReport->raw_Generate(admtFile, _variant_t(strIncludeFile), vntExcludeNames);
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		m_spReport->raw_Generate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames);
	}
	else
	{
		m_spReport->raw_Generate(admtNone, _variant_t(), _variant_t());
	}

	StopMonitoring();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\monitorthread.cpp ===
#include "StdAfx.h"
#include "MonitorThread.h"
#include <Folders.h>


namespace nsMonitorThread
{

_bstr_t __stdcall GetLogFolder(LPCTSTR pszLog);
bool __stdcall OpenFile(LPCTSTR pszFile, HANDLE& hFile, FILETIME ftFile, bool bDontCheckLastWriteTime = false);
bool __stdcall IsLastWriteTimeUpdated(HANDLE hFile, FILETIME& ftFile);
void __stdcall DisplayFile(HANDLE hFile);
bool __stdcall CheckBeginTime(LPCTSTR pszFile, FILETIME ftFile, bool& bNeedCheckMonitorBeginTime);

}

using namespace nsMonitorThread;


//---------------------------------------------------------------------------
// MonitorThread Class
//---------------------------------------------------------------------------


// Constructor

CMonitorThread::CMonitorThread() :
	m_strMigrationLog(GetMigrationLogPath()),
	m_hMigrationLog(INVALID_HANDLE_VALUE),
	m_strDispatchLog(GetDispatchLogPath()),
	m_hDispatchLog(INVALID_HANDLE_VALUE),
	m_bDontNeedCheckMonitorBeginTime(FALSE)
{
	FILETIME ft;
	SYSTEMTIME st;

	GetSystemTime(&st);
	
	if (SystemTimeToFileTime(&st, &ft))
	{
		m_ftMigrationLogLastWriteTime = ft;
		m_ftDispatchLogLastWriteTime = ft;		
		m_ftMonitorBeginTime = ft;
	}
	else
	{
		m_ftMigrationLogLastWriteTime.dwLowDateTime = 0;
		m_ftMigrationLogLastWriteTime.dwHighDateTime = 0;
		m_ftDispatchLogLastWriteTime.dwLowDateTime = 0;
		m_ftDispatchLogLastWriteTime.dwHighDateTime = 0;
        m_ftMonitorBeginTime.dwLowDateTime = 0;
        m_ftMonitorBeginTime.dwHighDateTime = 0;
	}
}


// Destructor

CMonitorThread::~CMonitorThread()
{
}


// Start Method

void CMonitorThread::Start()
{
	CThread::StartThread();
}


// Stop Method

void CMonitorThread::Stop()
{
	CThread::StopThread();
}


// Run Method

void CMonitorThread::Run()
{    
    try
    {
        // position file pointer at end of dispatch log as this log is always appended to

        ProcessDispatchLog(true); // binitialize is true, bCheckModifyTime is default to true

        _bstr_t strMigration = GetLogFolder(m_strMigrationLog);
        _bstr_t strDispatch = GetLogFolder(m_strDispatchLog);

        HANDLE hHandles[3] = { StopEvent(), NULL, NULL };

        // obtain change notification handle for migration log folder
        // note that an invalid handle value is returned if the folder does not exist

        HANDLE hMigrationChange = INVALID_HANDLE_VALUE;
        HANDLE hDispatchChange = INVALID_HANDLE_VALUE;

        do
        {
            hMigrationChange = FindFirstChangeNotification(strMigration, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE);

            if (hMigrationChange != INVALID_HANDLE_VALUE)
            {
                break;
            }
        }
        while (WaitForSingleObject(hHandles[0], 1000) == WAIT_TIMEOUT);

        // if valid change notification handle then...

        if (hMigrationChange != INVALID_HANDLE_VALUE)
        {
            DWORD dwHandleCount = 2;
            hHandles[1] = hMigrationChange;

            // until stop event is signaled...

            for (bool bWait = true; bWait;)
            {
                // if change notification handle for dispatch log has not been obtained...

                if (hDispatchChange == INVALID_HANDLE_VALUE)
                {
                    hDispatchChange = FindFirstChangeNotification(strDispatch, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_LAST_WRITE);

                    if (hDispatchChange != INVALID_HANDLE_VALUE)
                    {
                        dwHandleCount = 3;
                        hHandles[1] = hDispatchChange;
                        hHandles[2] = hMigrationChange;
                    }
                }

                // process signaled event

                switch (WaitForMultipleObjects(dwHandleCount, hHandles, FALSE, INFINITE))
                {
                    case WAIT_OBJECT_0:
                    {
                        bWait = false;
                        break;
                    }
                    case WAIT_OBJECT_0 + 1:
                    {
                        if (dwHandleCount == 2)
                        {
                            ProcessMigrationLog();
                            FindNextChangeNotification(hMigrationChange);
                        }
                        else
                        {
                            ProcessDispatchLog();   // use default parameter values
                            FindNextChangeNotification(hDispatchChange);
                        }
                        break;
                    }
                    case WAIT_OBJECT_0 + 2:
                    {
                        ProcessMigrationLog();
                        FindNextChangeNotification(hMigrationChange);
                        break;
                    }
                    default:
                    {
                        bWait = false;
                        break;
                    }
                }
            }
        }

        // close change notification handles

        if (hDispatchChange != INVALID_HANDLE_VALUE)
        {
            FindCloseChangeNotification(hDispatchChange);
        }

        if (hMigrationChange != INVALID_HANDLE_VALUE)
        {
            FindCloseChangeNotification(hMigrationChange);
        }

        // process logs one last time to display end of logs
        
        ProcessDispatchLog(false, false); // bInitialize is false, bCheckModifyTime is false
        ProcessMigrationLog(false);

        // close file handles

        if (m_hDispatchLog != INVALID_HANDLE_VALUE)
        {
            CloseHandle(m_hDispatchLog);
        }

        if (m_hMigrationLog != INVALID_HANDLE_VALUE)
        {
            CloseHandle(m_hMigrationLog);
        }
    }
    catch (...)
    {
        ;
    }
}


// ProcessMigrationLog Method

void CMonitorThread::ProcessMigrationLog(bool bCheckModifyTime)
{
    // first make sure that the last written time of the file is greater than the monitor start time, so 
    // we can be certain that we are actually reading the most recent log file.
    
    if(m_bDontNeedCheckMonitorBeginTime || CheckBeginTime(m_strMigrationLog, m_ftMonitorBeginTime, m_bDontNeedCheckMonitorBeginTime))
    {
	    if (OpenFile(m_strMigrationLog, m_hMigrationLog, m_ftMigrationLogLastWriteTime))
	    { 
	        if(bCheckModifyTime)
	        {
		        if (IsLastWriteTimeUpdated(m_hMigrationLog, m_ftMigrationLogLastWriteTime))
		        {		             
     			    DisplayFile(m_hMigrationLog);
     			}
	        }
	        else
	        {	             
     			DisplayFile(m_hMigrationLog);
	        }
	    }
    }     
}


// ProcessDispatchLog Method

void CMonitorThread::ProcessDispatchLog(bool bInitialize, bool bCheckModifyTime)
{     
	if (OpenFile(m_strDispatchLog, m_hDispatchLog, m_ftDispatchLogLastWriteTime, bInitialize))
	{	     
		if (bInitialize)
		{
			SetFilePointer(m_hDispatchLog, 0, NULL, FILE_END);			 
		}

		if(bCheckModifyTime)
		{
		    if (IsLastWriteTimeUpdated(m_hDispatchLog, m_ftDispatchLogLastWriteTime))
		    {		     
		        DisplayFile(m_hDispatchLog);
		    }
		}
		else
		{            
		    DisplayFile(m_hDispatchLog);
		}
	}	 
}

namespace nsMonitorThread
{


_bstr_t __stdcall GetLogFolder(LPCTSTR pszLog)
{
	_TCHAR szPath[_MAX_PATH];
	_TCHAR szDrive[_MAX_DRIVE];
	_TCHAR szDir[_MAX_DIR];

	if (pszLog)
	{
		_tsplitpath(pszLog, szDrive, szDir, NULL, NULL);
		_tmakepath(szPath, szDrive, szDir, NULL, NULL);
	}
	else
	{
		szPath[0] = _T('\0');
	}

	return szPath;
}


bool __stdcall OpenFile(LPCTSTR pszFile, HANDLE& hFile, FILETIME ftFile, bool bDontCheckLastWriteTime)
{
	HANDLE h = hFile;

	if (h == INVALID_HANDLE_VALUE)
	{	      
		h = CreateFile(
			pszFile,
			GENERIC_READ,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		if (h != INVALID_HANDLE_VALUE)
		{
			FILETIME ft = ftFile;

			if (bDontCheckLastWriteTime || IsLastWriteTimeUpdated(h, ft))
			{
				_TCHAR ch;
				DWORD cb;

				if (ReadFile(h, &ch, sizeof(ch), &cb, NULL) && (cb >= sizeof(ch)))
				{
					if (ch != _T('\xFEFF'))
					{
						SetFilePointer(h, 0, NULL, FILE_BEGIN);
					}

					hFile = h;
				}
				else
				{
					CloseHandle(h);
				}
			}
			else
			{
				CloseHandle(h);
			}
		}
	}

	return (hFile != INVALID_HANDLE_VALUE);
}


bool __stdcall IsLastWriteTimeUpdated(HANDLE hFile, FILETIME& ftFile)
{
	bool bUpdated = false;

	BY_HANDLE_FILE_INFORMATION bhfi;

	if (GetFileInformationByHandle(hFile, &bhfi))
	{         
		if (CompareFileTime(&bhfi.ftLastWriteTime, &ftFile) > 0)
		{
			ftFile = bhfi.ftLastWriteTime;
			bUpdated = true;			 
		}	 
		
	}

	return bUpdated;
}


void __stdcall DisplayFile(HANDLE hFile)
{
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	DWORD dwBytesRead;
	DWORD dwCharsWritten;
	_TCHAR szBuffer[1024];	 

	while (ReadFile(hFile, szBuffer, sizeof(szBuffer), &dwBytesRead, NULL) && (dwBytesRead > 0))
	{
		WriteConsole(hStdOut, szBuffer, dwBytesRead / sizeof(_TCHAR), &dwCharsWritten, NULL);
	}
}

bool __stdcall CheckBeginTime(LPCTSTR pszFile, FILETIME ftFile, bool& bDontNeedCheckMonitorBeginTime)
{
    bool bLatestFile = false;
    HANDLE h = INVALID_HANDLE_VALUE;
    
    // Make sure that the monitor open the correct log file, not the old one
    h = CreateFile(
	        pszFile,
			0,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
	);

    // if we fail to get the file handle, we will treat the file as not the newest one
    if(h != INVALID_HANDLE_VALUE)
    {
        // compare the monitor begin time with the last write time of the log file
        bLatestFile = IsLastWriteTimeUpdated(h, ftFile);
        
        CloseHandle(h);

        // mark the bDontNeedCheckMonitorBeginTime, so we don't have to go through this next time
        bDontNeedCheckMonitorBeginTime = bLatestFile;
    }    

    return bLatestFile;
    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\parameter.h ===
#pragma once

#include "Resource.h"
#include <map>

#ifndef StringVector
#include <vector>
typedef std::vector<_bstr_t> StringVector;
#endif

#include "Argument.h"
#include "Switch.h"


enum ETask
{
	TASK_NONE,
	TASK_USER,
	TASK_GROUP,
	TASK_COMPUTER,
	TASK_SECURITY,
	TASK_SERVICE,
	TASK_REPORT,
	TASK_KEY,
};


//---------------------------------------------------------------------------
// Parameter Map
//---------------------------------------------------------------------------


class CParameterMap :
	public std::map<int, _variant_t>
{
public:

	CParameterMap(CArguments& rArgs)
	{
		Initialize(rArgs);
	}

	bool IsExist(int nParam)
	{
		return (find(nParam) != end());
	}

	bool GetValue(int nParam, bool& bValue);
	bool GetValue(int nParam, long& lValue);
	bool GetValue(int nParam, _bstr_t& strValue);

	bool GetValues(int nParam, _variant_t& vntValues);
	bool GetValues(int nParam, StringVector& vecValues);

protected:

	void Initialize(CArguments& rArgs);

	bool DoTask(LPCTSTR pszArg);
	void DoSwitches(CArguments& rArgs);
	void DoSwitch(int nSwitch, CArguments& rArgs);

	_variant_t& Insert(int nParam);

	void DoOptionFile(LPCTSTR pszFileName);
	FILE* OpenOptionFile(LPCTSTR pszFileName);
	int FindTask(FILE* fp);
	void DoTask(FILE* fp, CSwitchMap& mapSwitchs);
	void DoParameter(int nSwitch, LPCTSTR pszValue);
	void DoTaskKey(CArguments& rArgs);
	void VerifyIncludeExclude();

protected:

	CSwitchMap m_mapSwitchs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Command.rc
//
#define IDS_E_NOT_LOCAL_DRIVE           1
#define IDS_E_CANT_CREATE_FILE          2
#define IDS_E_CANT_WRITE_FILE           3
#define IDS_E_INVALID_FIRST_ARGUMENT    4
#define IDS_E_NO_KEY_DOMAIN             5
#define IDS_E_NO_KEY_FOLDER             6
#define IDS_TYPE_PASSWORD               7
#define IDS_CONFIRM_PASSWORD            8
#define IDS_E_CANT_GET_PASSWORD         9
#define IDS_E_OPTION_UNRECOGNIZED       10
#define IDS_E_TASK_NOT_FIRST            11
#define IDS_E_INVALID_OPTION_FORMAT     12
#define IDS_E_NO_ARGUMENTS              13
#define IDS_E_OPTION_FORMAT_INVALID     14
#define IDS_E_NO_OPTION_VALUE           15
#define IDS_CANT_GET_OPTION_VALUE       16
#define IDS_E_OPTION_VALUE_INVALID      17
#define IDS_E_OPTION_VALUE_TOO_LONG     18
#define IDS_E_OPTION_FORMAT_INVALID2    19
#define IDS_E_CANT_GET_OPTION_VALUE2    20
#define IDS_E_OPTION_VALUE_UNRECOGNIZED 21
#define IDS_E_MULTIPLE_INCLUDE_OPTIONS  22
#define IDS_E_MULTIPLE_EXCLUDE_OPTIONS  23
#define IDS_E_OPTION_FILE_OPEN          24
#define IDS_E_OPTION_FILE_READ_SIGNATURE 25
#define IDS_E_OPTION_FILE_UNICODE_BIG_ENDIAN 26
#define IDS_E_OPTION_FILE_UTF_8         27
#define IDS_E_OPTION_FILE_TASK          28
#define IDS_E_NO_INCLUDE_OPTION_SPECIFIED 29
#define IDS_USAGE_SYNTAX                49
#define IDS_USAGE_ADMT                  50
#define IDS_USAGE_USER                  51
#define IDS_USAGE_GROUP                 52
#define IDS_USAGE_COMPUTER              53
#define IDS_USAGE_SECURITY              54
#define IDS_USAGE_SERVICE               55
#define IDS_USAGE_REPORT                56
#define IDS_USAGE_KEY                   57
#define IDS_USAGE_OPTIONFILE            58
#define IDS_USAGE_INCLUDE_A             59
#define IDS_USAGE_INCLUDE_B             60
#define IDS_USAGE_INCLUDE_C             61
#define IDS_USAGE_INCLUDE_D             62
#define IDS_USAGE_EXCLUDE               63
#define IDS_USAGE_TESTMIGRATION         64
#define IDS_USAGE_INTRAFOREST           65
#define IDS_USAGE_SOURCEDOMAIN          66
#define IDS_USAGE_SOURCEOU              67
#define IDS_USAGE_TARGETDOMAIN          68
#define IDS_USAGE_TARGETOU              69
#define IDS_USAGE_RENAMEOPTION          70
#define IDS_USAGE_RENAMEPREFIXORSUFFIX  71
#define IDS_USAGE_PASSWORDOPTION        72
#define IDS_USAGE_PASSWORDSERVER        73
#define IDS_USAGE_PASSWORDFILE          74
#define IDS_USAGE_CONFLICTOPTIONS_U     75
#define IDS_USAGE_CONFLICTOPTIONS_G     76
#define IDS_USAGE_CONFLICTOPTIONS_C     77
#define IDS_USAGE_CONFLICTPREFIXORSUFFIX 78
#define IDS_USAGE_USERPROPERTIESTOEXCLUDE 79
#define IDS_USAGE_GROUPPROPERTIESTOEXCLUDE 80
#define IDS_USAGE_COMPUTERPROPERTIESTOEXCLUDE 81
#define IDS_USAGE_DISABLEOPTION         82
#define IDS_USAGE_SOURCEEXPIRATION      83
#define IDS_USAGE_MIGRATESIDS           84
#define IDS_USAGE_TRANSLATEROAMINGPROFILE 85
#define IDS_USAGE_UPDATEUSERRIGHTS      86
#define IDS_USAGE_MIGRATEGROUPS         87
#define IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS 88
#define IDS_USAGE_FIXGROUPMEMBERSHIP    89
#define IDS_USAGE_UPDATEGROUPRIGHTS     90
#define IDS_USAGE_MIGRATEMEMBERS        91
#define IDS_USAGE_TRANSLATIONOPTION     92
#define IDS_USAGE_TRANSLATEFILESANDFOLDERS 93
#define IDS_USAGE_TRANSLATELOCALGROUPS  94
#define IDS_USAGE_TRANSLATEPRINTERS     95
#define IDS_USAGE_TRANSLATEREGISTRY     96
#define IDS_USAGE_TRANSLATESHARES       97
#define IDS_USAGE_TRANSLATEUSERPROFILES 98
#define IDS_USAGE_TRANSLATEUSERRIGHTS   99
#define IDS_USAGE_RESTARTDELAY          100
#define IDS_USAGE_SIDMAPPINGFILE        101
#define IDS_USAGE_REPORTTYPE            102
#define IDS_USAGE_REPORTFOLDER          103
#define IDS_USAGE_FOOTER                104
#define IDS_E_INVALID_FOLDER            105
#define IDS_USAGE_MIGRATESERVICEACCOUNTS 106
#define IDS_USAGE_INETORGPERSONPROPERTIESTOEXCLUDE 107
#define IDS_E_PROCESS_RUNNING          108
#define IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED 109
#define IDS_E_PASSWORD_TOO_LONG         110
#define IDS_MSG_KEY_CREATED             111
#define IDS_E_TOO_MANY_ARGUMENTS        112
#define IDS_E_UPDATE_REGISTRY_FAILED   113
#define IDS_E_LOCAL_ADMIN_CHECK_FAILED  114
#define IDS_E_OPTION_FILE_SEEK      115

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\parameter.cpp ===
#include "StdAfx.h"
#include "Parameter.h"

#define NO_WBEM
#include "T_SafeVector.h"


namespace Parameter_cpp
{

inline bool IsPrefix(_TCHAR ch)
{
	return ((ch == _T('/')) || (ch == _T('-')));
}

inline bool IsSpacer(_TCHAR ch)
{
    return ((ch == _T(':')) || _istspace(ch));
}

struct SNameToTask
{
	LPCTSTR pszName;
	int nTask;
};

SNameToTask s_TaskValues[] =
{
	{ _T("User"),     TASK_USER     },
	{ _T("Group"),    TASK_GROUP    },
	{ _T("Computer"), TASK_COMPUTER },
	{ _T("Security"), TASK_SECURITY },
	{ _T("Service"),  TASK_SERVICE  },
	{ _T("Report"),   TASK_REPORT   },
	{ _T("Key"),      TASK_KEY      },
	{ NULL,           TASK_NONE     },
};

struct SNameToBool
{
	LPCTSTR pszName;
	bool bValue;
};

SNameToBool s_BoolValues[] =
{
	{ _T("Yes"),   true  },
	{ _T("No"),    false },
	{ _T("True"),  true  },
	{ _T("False"), false },
	{ NULL,        false },
};

struct SNameToLong
{
	LPCTSTR pszName;
	long lValue;
};

SNameToLong s_RenameOptionValues[] =
{
	{ _T("Dont"),   admtDoNotRename      },
	{ _T("Prefix"), admtRenameWithPrefix },
	{ _T("Suffix"), admtRenameWithSuffix },
	{ NULL,                          -1L },
};

SNameToLong s_PasswordOptionValues[] =
{
	{ _T("Name"),    admtPasswordFromName },
	{ _T("Complex"), admtComplexPassword  },
	{ _T("Copy"),    admtCopyPassword     },
	{ NULL,                           -1L },
};

SNameToLong s_ConflictOptionValues[] =
{
	{ _T("Ignore"),  admtIgnoreConflicting           },
	{ _T("Replace"), admtReplaceConflicting          },
	{ _T("Prefix"),  admtRenameConflictingWithPrefix },
	{ _T("Suffix"),  admtRenameConflictingWithSuffix },
	{ NULL,                                      -1L },
};

SNameToLong s_ConflictOptionFlagValues[] =
{
	{ _T("RemoveUserRights"),     admtRemoveExistingUserRights },
	{ _T("RemoveMembers"),        admtRemoveExistingMembers    },
	{ _T("MoveReplacedAccounts"), admtMoveReplacedAccounts     },
	{ NULL,                                                -1L },
};

SNameToLong s_DisableOptionValues[] =
{
	{ _T("EnableTarget"),       admtEnableTarget       },
	{ _T("DisableSource"),      admtDisableSource      },
	{ _T("DisableTarget"),      admtDisableTarget      },
	{ _T("TargetSameAsSource"), admtTargetSameAsSource },
	{ NULL,                                  -1L },
};

SNameToLong s_SourceExpirationValues[] =
{
	{ _T("None"), admtNoExpiration },
	{ NULL,                     0L },
};

SNameToLong s_TranslationOptionValues[] =
{
	{ _T("Replace"), admtTranslateReplace },
	{ _T("Add"),     admtTranslateAdd     },
	{ _T("Remove"),  admtTranslateRemove  },
	{ NULL,                           -1L },
};

SNameToLong s_ReportTypeValues[] =
{
	{ _T("MigratedAccounts"),  admtReportMigratedAccounts  },
	{ _T("MigratedComputers"), admtReportMigratedComputers },
	{ _T("ExpiredComputers"),  admtReportExpiredComputers  },
	{ _T("AccountReferences"), admtReportAccountReferences },
	{ _T("NameConflicts"),     admtReportNameConflicts     },
	{ NULL,                                            -1L },
};

SNameToLong s_DomainOptionFlagAValues[] =
{
	{ _T("Recurse"),  admtRecurse },
	{ NULL,                   -1L },
};

SNameToLong s_DomainOptionFlagBValues[] =
{
	{ _T("Flatten"),  admtFlattenHierarchy  },
	{ _T("Maintain"), admtMaintainHierarchy },
	{ NULL,                             -1L },
};

bool GetBoolValue(LPCTSTR pszArg);
bool GetBoolFromName(LPCTSTR pszName, SNameToBool* pNameToBool);
long GetLongValue(LPCTSTR pszArg, SNameToLong* pNameToLong);
long GetLongFromName(LPCTSTR pszName, SNameToLong* pNameToLong);

// Note that the maximum password length is the maximum
// supported by the password export server installation.

#define MAX_PASSWORD_LENGTH (MAX_PATH - 1)

bool GetPasswordFromUser(LPCTSTR pszKeyId, _bstr_t& strPassword);

_bstr_t LoadStringHelper(UINT uId);

}

using namespace Parameter_cpp;


//---------------------------------------------------------------------------
// Parameter Map
//---------------------------------------------------------------------------


// Public Methods -----------------------------------------------------------


// GetValue Method

bool CParameterMap::GetValue(int nParam, bool& bValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		bValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValue Method

bool CParameterMap::GetValue(int nParam, long& lValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		lValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValue Method

bool CParameterMap::GetValue(int nParam, _bstr_t& strValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		strValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValues Method

bool CParameterMap::GetValues(int nParam, _variant_t& vntValues)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		vntValues = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValues Method

bool CParameterMap::GetValues(int nParam, StringVector& vecValues)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		vecValues = T_SafeVector2<VT_BSTR, _bstr_t, StringVector, T_Extract_bstr_t<StringVector> >(it->second);

		bGet = true;
	}

	return bGet;
}


// Protected Methods --------------------------------------------------------


// Initialize Method

void CParameterMap::Initialize(CArguments& rArgs)
{
	if (DoTask(rArgs.Value()))
	{
		long lTask;

		if (GetValue(SWITCH_TASK, lTask))
		{
			if (lTask == TASK_KEY)
			{
				DoTaskKey(rArgs);
			}
			else
			{
				DoSwitches(rArgs);

				VerifyIncludeExclude();
			}
		}
	}

//	if (empty())
//	{
//		ThrowError(E_INVALIDARG, IDS_E_NO_ARGUMENTS);
//	}
}


// DoTask

bool CParameterMap::DoTask(LPCTSTR pszArg)
{
	bool bTask = false;

	if (pszArg != NULL)
	{
		// first switch must specify task or help

		int nSwitch = m_mapSwitchs.GetSwitch(pszArg);

		if (nSwitch == SWITCH_TASK)
		{
			int nTask = TASK_NONE;

			for (SNameToTask* p = s_TaskValues; p->pszName; p++)
			{
				if (_tcsicmp(p->pszName, pszArg) == 0)
				{
					nTask = p->nTask;
					break;
				}
			}

			insert(value_type(SWITCH_TASK, _variant_t(long(nTask))));

			bTask = true;
		}
		else
		{
			_TCHAR chPrefix;
			_TCHAR szSwitch[16];

			if ((_stscanf(pszArg, _T(" %c%15s "), &chPrefix, szSwitch) == 2) && IsPrefix(chPrefix) && (m_mapSwitchs.GetSwitch(szSwitch) == SWITCH_HELP))
			{
				insert(value_type(SWITCH_HELP, _variant_t(true)));
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_INVALID_FIRST_ARGUMENT, pszArg);
			}
		}
	}
	else
	{
	//	ThrowError(E_INVALIDARG, IDS_E_NO_ARGUMENTS);
	}

	return bTask;
}


// DoSwitches Method

void CParameterMap::DoSwitches(CArguments& rArgs)
{
	LPCTSTR pszArg = NULL;

	while (rArgs.Next())
	{
		pszArg = rArgs.Value();

		_TCHAR chPrefix;
		_TCHAR szSwitch[64];
		_TCHAR chSpacer;

              int nFields = _stscanf(pszArg, _T(" %c%63[A-Za-z?]%c"), &chPrefix, szSwitch, &chSpacer);
              if (nFields >= 2 && IsPrefix(chPrefix) && (nFields == 2 || IsSpacer(chSpacer)))
              {
			int nSwitch = m_mapSwitchs.GetSwitch(szSwitch);

			if (nSwitch == -1)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_UNRECOGNIZED, pszArg);
			}

			if (nSwitch == SWITCH_TASK)
			{
				ThrowError(E_INVALIDARG, IDS_E_TASK_NOT_FIRST, pszArg);
			}

			if (nSwitch == SWITCH_HELP)
			{
				insert(value_type(SWITCH_HELP, _variant_t(true)));
				break;
			}

			DoSwitch(nSwitch, rArgs);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_INVALID_OPTION_FORMAT, pszArg);
		}
	}

	// if no switches/options then display help

	if (pszArg == NULL)
	{
		insert(value_type(SWITCH_HELP, _variant_t(true)));
	}
}


// DoSwitch Method

void CParameterMap::DoSwitch(int nSwitch, CArguments& rArgs)
{
	_variant_t& vntValue = Insert(nSwitch);

	switch (nSwitch)
	{
		// boolean values

		case SWITCH_TEST_MIGRATION:
		case SWITCH_INTRA_FOREST:
		case SWITCH_MIGRATE_SIDS:
		case SWITCH_TRANSLATE_ROAMING_PROFILE:
		case SWITCH_UPDATE_USER_RIGHTS:
		case SWITCH_MIGRATE_GROUPS:
		case SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS:
		case SWITCH_FIX_GROUP_MEMBERSHIP:
		case SWITCH_MIGRATE_SERVICE_ACCOUNTS:
		case SWITCH_UPDATE_GROUP_RIGHTS:
		case SWITCH_MIGRATE_MEMBERS:
		case SWITCH_TRANSLATE_FILES_AND_FOLDERS:
		case SWITCH_TRANSLATE_LOCAL_GROUPS:
		case SWITCH_TRANSLATE_PRINTERS:
		case SWITCH_TRANSLATE_REGISTRY:
		case SWITCH_TRANSLATE_SHARES:
		case SWITCH_TRANSLATE_USER_PROFILES:
		case SWITCH_TRANSLATE_USER_RIGHTS:
		{
			vntValue = GetBoolValue(rArgs.Value());
			break;
		}

		// long values

		case SWITCH_RENAME_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_RenameOptionValues);
			break;
		}
		case SWITCH_PASSWORD_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_PasswordOptionValues);
			break;
		}
		case SWITCH_CONFLICT_OPTIONS:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];
			_TCHAR szValueC[32];
			_TCHAR szValueD[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB, szValueC, szValueD);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = GetLongFromName(szValueA, s_ConflictOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_ConflictOptionFlagValues);
			}

			if (cFields >= 3)
			{
				lValue |= GetLongFromName(szValueC, s_ConflictOptionFlagValues);
			}

			if (cFields >= 4)
			{
				lValue |= GetLongFromName(szValueD, s_ConflictOptionFlagValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_DISABLE_OPTION:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = GetLongFromName(szValueA, s_DisableOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DisableOptionValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_SOURCE_EXPIRATION:
		{
			long lValue;
			_TCHAR szValue[32];

			if (_stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z]"), szValue) == 1)
			{
				vntValue = GetLongFromName(szValue, s_SourceExpirationValues);
			}
			else if (_stscanf(rArgs.Value(), _T("%*[^:]: %ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}
			break;
		}
		case SWITCH_TRANSLATION_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_TranslationOptionValues);
			break;
		}
		case SWITCH_RESTART_DELAY:
		{
			long lValue;

			if (_stscanf(rArgs.Value(), _T("%*[^:]: %ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}
			break;
		}
		case SWITCH_INCLUDE_DOMAIN:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields < 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = 0;

			if (cFields >= 1)
			{
				lValue |= GetLongFromName(szValueA, s_DomainOptionFlagAValues);
			}

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DomainOptionFlagBValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_REPORT_TYPE:
		{
			vntValue = GetLongValue(rArgs.Value(), s_ReportTypeValues);
			break;
		}

		// string values

		case SWITCH_SOURCE_DOMAIN:
		case SWITCH_SOURCE_OU:
		case SWITCH_TARGET_DOMAIN:
		case SWITCH_TARGET_OU:
		case SWITCH_RENAME_PREFIX_OR_SUFFIX:
		case SWITCH_PASSWORD_SERVER:
		case SWITCH_PASSWORD_FILE:
		case SWITCH_CONFLICT_PREFIX_OR_SUFFIX:
		case SWITCH_USER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_INETORGPERSON_PROPERTIES_TO_EXCLUDE:
		case SWITCH_GROUP_PROPERTIES_TO_EXCLUDE:
		case SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_SID_MAPPING_FILE:
		case SWITCH_REPORT_FOLDER:
		case SWITCH_INCLUDE_FILE:
		case SWITCH_EXCLUDE_FILE:
		{
			_TCHAR szValue[4096];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%4095[^\0]"), szValue) == 1)
			{
				if (_tcslen(szValue) > 2047)
				{
					ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
				}

				vntValue = szValue;
			}
			else
			{
				if (rArgs.Next())
				{
					LPCTSTR pszArg = rArgs.Value();

					if (IsPrefix(pszArg[0]))
					{
						rArgs.Prev();
						ThrowError(E_INVALIDARG, IDS_E_NO_OPTION_VALUE, rArgs.Value());
					}

					if (_tcslen(pszArg) > 2047)
					{
						ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
					}

					vntValue = pszArg;
				}
				else
				{
					ThrowError(E_INVALIDARG, IDS_E_NO_OPTION_VALUE, rArgs.Value());
				}
			}
			break;
		}

		// multi-string values

		case SWITCH_INCLUDE_NAME:
		case SWITCH_EXCLUDE_NAME:
		{
			T_SafeVector2<VT_BSTR, _bstr_t, StringVector, T_Extract_bstr_t<StringVector> > svValues(vntValue);

			_TCHAR szValue[4096];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%4095[^\0]"), szValue) == 1)
			{
				if (_tcslen(szValue) > 2047)
				{
					ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
				}

				svValues.push_back(_bstr_t(szValue));
			}

			while (rArgs.Next())
			{
				LPCTSTR pszArg = rArgs.Value();

				if (IsPrefix(pszArg[0]))
				{
					rArgs.Prev();
					break;
				}

				if (_tcslen(pszArg) > 2047)
				{
					ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
				}

				svValues.push_back(_bstr_t(pszArg));
			}

			vntValue = svValues.GetVariant();
			break;
		}

		// option files

		case SWITCH_OPTION_FILE:
		{
			_TCHAR szValue[1024];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%1023[^\0]"), szValue) == 1)
			{
				DoOptionFile(szValue);
			}
			else
			{
				if (rArgs.Next())
				{
					LPCTSTR pszArg = rArgs.Value();

					if (IsPrefix(pszArg[0]))
					{
						rArgs.Prev();
					}
					else
					{
						DoOptionFile(pszArg);
					}
				}
			}
			break;
		}

		// default

		default:
		{
			_ASSERT(false);
			break;
		}
	}
}


// Insert Method

_variant_t& CParameterMap::Insert(int nParam)
{
	iterator it = find(nParam);

	if (it == end())
	{
		std::pair<iterator, bool> pair = insert(value_type(nParam, _variant_t()));

		it = pair.first;
	}

	return it->second;
}


// DoOptionFile Method

void CParameterMap::DoOptionFile(LPCTSTR pszFileName)
{
	CSwitchMap mapSwitchs;

	FILE* fp = OpenOptionFile(pszFileName);

	try
	{
		iterator it = find(SWITCH_TASK);

		if (it == end())
		{
			ThrowError(E_FAIL, IDS_E_OPTION_FILE_TASK, pszFileName);
		}

		int nCurrentTask = long(it->second);

		int nTask;

		do
		{
			nTask = FindTask(fp);

			if ((nTask == 0) || (nTask == nCurrentTask))
			{
				DoTask(fp, mapSwitchs);
			}
		}
		while (nTask >= 0);
	}
	catch (...)
	{
		fclose(fp);
		throw;
	}

	fclose(fp);
}


// OpenOptionFile Method

FILE* CParameterMap::OpenOptionFile(LPCTSTR pszFileName)
{
	// open in binary mode first in order to check for UNICODE byte order
	// mark if the file is UNICODE then it must be read in binary mode
	// with the stream i/o functions

	FILE* fp = _tfopen(pszFileName, _T("rb"));

	if (fp == NULL)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_OPEN, pszFileName);
	}

	// check if file is ANSI or UNICODE or UTF-8

	BYTE byteSignature[3];

	if (fread(byteSignature, sizeof(BYTE), 3, fp) == 3)
	{
		static BYTE byteUtf8[] = { 0xEF, 0xBB, 0xBF };
		static BYTE byteUnicodeLE[] = { 0xFF, 0xFE };
		static BYTE byteUnicodeBE[] = { 0xFE, 0xFF };

		// check for signature or byte order mark

		if (memcmp(byteSignature, byteUtf8, sizeof(byteUtf8)) == 0)
		{
			// UTF-8 signature
			// TODO: not currently supported
			fclose(fp);
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_UTF_8, pszFileName);
		}
		else if (memcmp(byteSignature, byteUnicodeLE, sizeof(byteUnicodeLE)) == 0)
		{
			// UNICODE Little Endian Byte Order Mark
			// supported
			// must read in binary mode
			// move file pointer back one byte because we read 3 bytes
			if (fseek(fp, -1, SEEK_CUR))
			{
			    // if cannot move file pointer back, try to reopen and read in two bytes
			    fclose(fp);
			    fp = NULL;
			    ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_SEEK);
			}
		}
		else if (memcmp(byteSignature, byteUnicodeBE, sizeof(byteUnicodeBE)) == 0)
		{
			// UNICODE Big Endian Byte Order Mark
			// TODO: not currently supported
			fclose(fp);
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_UNICODE_BIG_ENDIAN, pszFileName);
		}
		else
		{
			// assume ANSI
			// re-open file in text mode as the stream i/o functions will
			// treat the file as multi-byte characters and will convert them
			// to UNICODE

			fclose(fp);

			fp = _tfopen(pszFileName, _T("rt"));

			if (fp == NULL)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_OPEN, pszFileName);
			}
		}
	}
	else
	{
		fclose(fp);
		ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_READ_SIGNATURE, pszFileName);
	}

	return fp;
}


// FindTask Method

int CParameterMap::FindTask(FILE* fp)
{
	int nTask = -1;

	_TCHAR szBuffer[1024];

	while (_fgetts(szBuffer, countof(szBuffer), fp))
	{
		_TCHAR szTask[64];
		
		if (_stscanf(szBuffer, _T(" [ %63[A-Za-z] ] "), szTask) == 1)
		{
		//	My_fwprintf(_T("FindTask() : '%s'\n"), szTask);

			if (_tcsicmp(szTask, _T("Migration")) == 0)
			{
				nTask = TASK_NONE;
				break;
			}

			if ((_tcsicmp(szTask, _T("User")) == 0) || (_tcsicmp(szTask, _T("UserMigration")) == 0))
			{
				nTask = TASK_USER;
				break;
			}

			if ((_tcsicmp(szTask, _T("Group")) == 0) || (_tcsicmp(szTask, _T("GroupMigration")) == 0))
			{
				nTask = TASK_GROUP;
				break;
			}

			if ((_tcsicmp(szTask, _T("Computer")) == 0) || (_tcsicmp(szTask, _T("ComputerMigration")) == 0))
			{
				nTask = TASK_COMPUTER;
				break;
			}

			if ((_tcsicmp(szTask, _T("Security")) == 0) || (_tcsicmp(szTask, _T("SecurityTranslation")) == 0))
			{
				nTask = TASK_SECURITY;
				break;
			}

			if ((_tcsicmp(szTask, _T("Service")) == 0) || (_tcsicmp(szTask, _T("ServiceAccountEnumeration")) == 0))
			{
				nTask = TASK_SERVICE;
				break;
			}

			if ((_tcsicmp(szTask, _T("Report")) == 0) || (_tcsicmp(szTask, _T("ReportGeneration")) == 0))
			{
				nTask = TASK_REPORT;
				break;
			}
		}
	}

	return nTask;
}


// DoTask Method

void CParameterMap::DoTask(FILE* fp, CSwitchMap& mapSwitchs)
{
	_TCHAR szBuffer[8192];

	for (;;)
	{
		long lOffset = ftell(fp);

		if (_fgetts(szBuffer, countof(szBuffer), fp) == NULL)
		{
			break;
		}

		_TCHAR szTask[64];

		if (_stscanf(szBuffer, _T(" [ %63[A-Za-z] ] "), szTask) == 1)
		{
			if (fseek(fp, lOffset, SEEK_SET))
			{
			    ThrowError(E_FAIL, IDS_E_OPTION_FILE_SEEK);
			}
			break;
		}

		_TCHAR szName[64];
		_TCHAR szValue[4096];

		try
		{
			if ((szBuffer[0] != _T(';')) && (_stscanf(szBuffer, _T(" %63[A-Za-z] = %4095[^\r\n]"), szName, szValue) == 2))
			{
			//	My_fwprintf(_T("DoTask() : %s='%s'\n"), szName, szValue);

				CSwitchMap::iterator it = mapSwitchs.find(_bstr_t(szName));

				if ((it != mapSwitchs.end()) && (it->second != SWITCH_TASK))
				{
					DoParameter(it->second, szValue);
				}
			}
		}
		catch (_com_error& ce)
		{
			ThrowError(ce, IDS_CANT_GET_OPTION_VALUE, szName, szValue);
		}
		catch (...)
		{
			ThrowError(E_FAIL, IDS_CANT_GET_OPTION_VALUE, szName, szValue);
		}
	}
}


// DoParameter Method

void CParameterMap::DoParameter(int nSwitch, LPCTSTR pszValue)
{
	_variant_t& vntValue = Insert(nSwitch);

	switch (nSwitch)
	{
		// boolean values

		case SWITCH_TEST_MIGRATION:
		case SWITCH_INTRA_FOREST:
		case SWITCH_MIGRATE_SIDS:
		case SWITCH_TRANSLATE_ROAMING_PROFILE:
		case SWITCH_UPDATE_USER_RIGHTS:
		case SWITCH_MIGRATE_GROUPS:
		case SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS:
		case SWITCH_FIX_GROUP_MEMBERSHIP:
		case SWITCH_MIGRATE_SERVICE_ACCOUNTS:
		case SWITCH_UPDATE_GROUP_RIGHTS:
		case SWITCH_MIGRATE_MEMBERS:
		case SWITCH_TRANSLATE_FILES_AND_FOLDERS:
		case SWITCH_TRANSLATE_LOCAL_GROUPS:
		case SWITCH_TRANSLATE_PRINTERS:
		case SWITCH_TRANSLATE_REGISTRY:
		case SWITCH_TRANSLATE_SHARES:
		case SWITCH_TRANSLATE_USER_PROFILES:
		case SWITCH_TRANSLATE_USER_RIGHTS:
		{
			vntValue = GetBoolFromName(pszValue, s_BoolValues);
			break;
		}

		// long values

		case SWITCH_RENAME_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_RenameOptionValues);
			break;
		}
		case SWITCH_PASSWORD_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_PasswordOptionValues);
			break;
		}
		case SWITCH_CONFLICT_OPTIONS:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];
			_TCHAR szValueC[32];
			_TCHAR szValueD[32];

			int cFields = _stscanf(pszValue, _T("%31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB, szValueC, szValueD);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}

			long lValue = GetLongFromName(szValueA, s_ConflictOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_ConflictOptionFlagValues);
			}

			if (cFields >= 3)
			{
				lValue |= GetLongFromName(szValueC, s_ConflictOptionFlagValues);
			}

			if (cFields >= 4)
			{
				lValue |= GetLongFromName(szValueD, s_ConflictOptionFlagValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_DISABLE_OPTION:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(pszValue, _T("%31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, pszValue);
			}

			long lValue = GetLongFromName(szValueA, s_DisableOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DisableOptionValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_SOURCE_EXPIRATION:
		{
			long lValue;
			_TCHAR szValue[32];

			if (_stscanf(pszValue, _T("%31[A-Za-z]"), szValue) == 1)
			{
				vntValue = GetLongFromName(szValue, s_SourceExpirationValues);
			}
			else if (_stscanf(pszValue, _T("%ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}
			break;
		}
		case SWITCH_TRANSLATION_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_TranslationOptionValues);
			break;
		}
		case SWITCH_RESTART_DELAY:
		{
			long lValue;

			if (_stscanf(pszValue, _T("%ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}
			break;
		}
		case SWITCH_REPORT_TYPE:
		{
			vntValue = GetLongFromName(pszValue, s_ReportTypeValues);
			break;
		}

		// string values

		case SWITCH_SOURCE_DOMAIN:
		case SWITCH_SOURCE_OU:
		case SWITCH_TARGET_DOMAIN:
		case SWITCH_TARGET_OU:
		case SWITCH_RENAME_PREFIX_OR_SUFFIX:
		case SWITCH_PASSWORD_SERVER:
		case SWITCH_PASSWORD_FILE:
		case SWITCH_CONFLICT_PREFIX_OR_SUFFIX:
		case SWITCH_USER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_INETORGPERSON_PROPERTIES_TO_EXCLUDE:
		case SWITCH_GROUP_PROPERTIES_TO_EXCLUDE:
		case SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_SID_MAPPING_FILE:
		case SWITCH_REPORT_FOLDER:
		{
			_TCHAR szValue[2048];

			UINT cch = _tcslen(pszValue);

			if (cch > 2047)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
			}

			_tcscpy(szValue, pszValue);

			if ((szValue[0] == _T('"')) && (szValue[cch - 1] == _T('"')))
			{
				szValue[cch - 1] = _T('\0');
				vntValue = &szValue[1];
			}
			else
			{
				vntValue = szValue;
			}
			break;
		}

		// default

		default:
		{
			_ASSERT(false);
			break;
		}
	}
}


// DoTaskKey Method

void CParameterMap::DoTaskKey(CArguments& rArgs)
{
    // key identifier

    LPCTSTR pszKeyId = NULL;

    if (rArgs.Next())
    {
        pszKeyId = rArgs.Value();

        _TCHAR chPrefix;
        _TCHAR szSwitch[16];

        if ((_stscanf(pszKeyId, _T(" %c%15s "), &chPrefix, szSwitch) == 2) && IsPrefix(chPrefix) && (m_mapSwitchs.GetSwitch(szSwitch) == SWITCH_HELP))
        {
            insert(value_type(SWITCH_HELP, _variant_t(true)));
        }
        else
        {
            insert(value_type(SWITCH_KEY_IDENTIFIER, _variant_t(pszKeyId)));

            // drive

            if (rArgs.Next())
            {
                insert(value_type(SWITCH_KEY_FOLDER, _variant_t(rArgs.Value())));

                // password

                _bstr_t strPassword;

                if (rArgs.Next())
                {
                    strPassword = rArgs.Value();
                }

                //
                // Check for unexpected parameters or arguments.
                //

                if (rArgs.Next())
                {
                    ThrowError(E_INVALIDARG, IDS_E_TOO_MANY_ARGUMENTS);
                }

                if (strPassword.length() > 0)
                {
                    if (_tcscmp(strPassword, _T("*")) == 0)
                    {
                        if (!GetPasswordFromUser(pszKeyId, strPassword))
                        {
                            ThrowError(E_FAIL, IDS_E_CANT_GET_PASSWORD);
                        }
                    }
                }

                if (strPassword.length() > MAX_PASSWORD_LENGTH)
                {
                    ThrowError(E_INVALIDARG, IDS_E_PASSWORD_TOO_LONG, MAX_PASSWORD_LENGTH);
                }

                insert(value_type(SWITCH_KEY_PASSWORD, _variant_t(strPassword)));
            }
        }
    }

    if (pszKeyId == NULL)
    {
        insert(value_type(SWITCH_HELP, _variant_t(true)));
    }
}


// VerifyIncludeExclude Method

void CParameterMap::VerifyIncludeExclude()
{
	// verify that only one include option type was specified

	int cInclude = 0;

	if (find(SWITCH_INCLUDE_NAME) != end())
	{
		++cInclude;
	}

	if (find(SWITCH_INCLUDE_FILE) != end())
	{
		++cInclude;
	}

	if (find(SWITCH_INCLUDE_DOMAIN) != end())
	{
		++cInclude;
	}

	if (cInclude > 1)
	{
		ThrowError(E_INVALIDARG, IDS_E_MULTIPLE_INCLUDE_OPTIONS);
	}

	// verify that only one exclude option type was specified

	if ((find(SWITCH_EXCLUDE_NAME) != end()) && (find(SWITCH_EXCLUDE_FILE) != end()))
	{
		ThrowError(E_INVALIDARG, IDS_E_MULTIPLE_EXCLUDE_OPTIONS);
	}
}


namespace Parameter_cpp
{


// GetBoolValue Method

bool GetBoolValue(LPCTSTR pszArg)
{
	bool bValue;

	try
	{
		_TCHAR szValue[16];

		if (_stscanf(pszArg, _T("%*[^:]: %15[A-Za-z]"), szValue) == 1)
		{
			bValue = GetBoolFromName(szValue, s_BoolValues);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID2, pszArg);
		}
	}
	catch (_com_error& ce)
	{
		ThrowError(ce, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}
	catch (...)
	{
		ThrowError(E_FAIL, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}

	return bValue;
}


// GetBoolFromName Method

bool GetBoolFromName(LPCTSTR pszName, SNameToBool* pNameToBool)
{
	bool bValue;

	bool bFound = false;

	for (SNameToBool* p = pNameToBool; p->pszName; p++)
	{
		if (_tcsicmp(p->pszName, pszName) == 0)
		{
			bValue = p->bValue;
			bFound = true;
			break;
		}
	}

	if (!bFound)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_UNRECOGNIZED, pszName);
	}

	return bValue;
}


// GetLongValue Method

long GetLongValue(LPCTSTR pszArg, SNameToLong* pNameToLong)
{
	long lValue;

	try
	{
		_TCHAR szValue[32];

		if (_stscanf(pszArg, _T("%*[^:]: %31[A-Za-z]"), szValue) == 1)
		{
			lValue = GetLongFromName(szValue, pNameToLong);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID2, pszArg);
		}
	}
	catch (_com_error& ce)
	{
		ThrowError(ce, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}
	catch (...)
	{
		ThrowError(E_FAIL, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}

	return lValue;
}


// GetLongFromName Method

long GetLongFromName(LPCTSTR pszName, SNameToLong* pNameToLong)
{
	long lValue;

	bool bFound = false;

	for (SNameToLong* p = pNameToLong; p->pszName; p++)
	{
		if (_tcsicmp(p->pszName, pszName) == 0)
		{
			lValue = p->lValue;
			bFound = true;
			break;
		}
	}

	if (!bFound)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_UNRECOGNIZED, pszName);
	}

	return lValue;
}


// GetPasswordFromUser Method

bool GetPasswordFromUser(LPCTSTR pszKeyId, _bstr_t& strPassword)
{
	bool bGet = false;

	_bstr_t strFormat[2];
	strFormat[0] = LoadStringHelper(IDS_TYPE_PASSWORD);
	strFormat[1] = LoadStringHelper(IDS_CONFIRM_PASSWORD);

	_TCHAR szPassword[2][MAX_PASSWORD_LENGTH + 1];
	szPassword[0][0] = _T('\0');
	szPassword[1][0] = _T('\0');

	HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);
	HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

	if (hInput != INVALID_HANDLE_VALUE)
	{
		DWORD dwMode;

		if (GetConsoleMode(hInput, &dwMode))
		{
			if (SetConsoleMode(hInput, ENABLE_PROCESSED_INPUT))
			{
				while (bGet == false)
				{
					for (int nPass = 0; nPass < 2; nPass++)
					{
						My_fwprintf(strFormat[nPass], pszKeyId);

						_TCHAR ch;
						DWORD dwRead;
						int nIndex = 0;

						while (ReadConsole(hInput, &ch, 1, &dwRead, NULL))
						{
							if ((ch == _T('\r')) || (ch == _T('\n')))
							{
								break;
							}
							else if (ch == _T('\b'))
							{
								if (nIndex > 0)
								{
									CONSOLE_SCREEN_BUFFER_INFO csbi;

									if (GetConsoleScreenBufferInfo(hOutput, &csbi))
									{
										--csbi.dwCursorPosition.X;

										if (SetConsoleCursorPosition(hOutput, csbi.dwCursorPosition))
										{
											--nIndex;

											DWORD dwWritten;
											WriteConsole(hOutput, _T(" "), 1, &dwWritten, NULL);
											SetConsoleCursorPosition(hOutput, csbi.dwCursorPosition);
										}
									}
								}
							}
							else if ((nIndex < MAX_PASSWORD_LENGTH) && _istprint(ch))
							{
								szPassword[nPass][nIndex++] = ch;

								DWORD dwWritten;
								WriteConsole(hOutput, _T("*"), 1, &dwWritten, NULL);
							}
						}

						_puttchar(_T('\n'));

						szPassword[nPass][nIndex] = _T('\0');
					}

					if (_tcscmp(szPassword[0], szPassword[1]) == 0)
					{
						strPassword = szPassword[0];
						bGet = true;
						break;
					}
				}
			}
			
			SetConsoleMode(hInput, dwMode);
		}
	}

	return bGet;
}


_bstr_t LoadStringHelper(UINT uId)
{
	_TCHAR szBuffer[1024];

	if (LoadString(GetModuleHandle(NULL), uId, szBuffer, countof(szBuffer)) <= 0)
	{
		szBuffer[0] = _T('\0');
	}

	return szBuffer;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#pragma warning(disable : 4786)

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
//#define _ATL_DEBUG_INTERFACES
#endif

#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <tchar.h>
#include <crtdbg.h>

#import <MsPwdMig.tlb> no_namespace no_implementation
#import <ADMTScript.tlb> no_namespace no_implementation

#define countof(a) (sizeof(a) / sizeof(a[0]))

int __cdecl My_fwprintf ( const TCHAR *format, ... );
int __cdecl My_vfwprintf( const TCHAR *format, va_list argptr );


void __cdecl ThrowError(_com_error ce, UINT uId, ...);
void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\switch.h ===
#pragma once

#include <map>
#include "Less.h"


enum ESwitch
{
	// task switch
	SWITCH_TASK,
	// option switches
	SWITCH_OPTION_FILE,
	// migration switches
	SWITCH_TEST_MIGRATION,
	SWITCH_INTRA_FOREST,
	SWITCH_SOURCE_DOMAIN,
	SWITCH_SOURCE_OU,
	SWITCH_TARGET_DOMAIN,
	SWITCH_TARGET_OU,
	SWITCH_RENAME_OPTION,
	SWITCH_RENAME_PREFIX_OR_SUFFIX,
	SWITCH_PASSWORD_OPTION,
	SWITCH_PASSWORD_SERVER,
	SWITCH_PASSWORD_FILE,
	SWITCH_CONFLICT_OPTIONS,
	SWITCH_CONFLICT_PREFIX_OR_SUFFIX,
	SWITCH_USER_PROPERTIES_TO_EXCLUDE,
	SWITCH_INETORGPERSON_PROPERTIES_TO_EXCLUDE,
	SWITCH_GROUP_PROPERTIES_TO_EXCLUDE,
	SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE,
	// user migration switches
	SWITCH_DISABLE_OPTION,
	SWITCH_SOURCE_EXPIRATION,
	SWITCH_MIGRATE_SIDS,
	SWITCH_TRANSLATE_ROAMING_PROFILE,
	SWITCH_UPDATE_USER_RIGHTS,
	SWITCH_MIGRATE_GROUPS,
	SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS,
	SWITCH_FIX_GROUP_MEMBERSHIP,
	SWITCH_MIGRATE_SERVICE_ACCOUNTS,
	// group migration switches
//	SWITCH_MIGRATE_SIDS,
	SWITCH_UPDATE_GROUP_RIGHTS,
//	SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS,
//	SWITCH_FIX_GROUP_MEMBERSHIP,
	SWITCH_MIGRATE_MEMBERS,
//	SWITCH_DISABLE_OPTION,
//	SWITCH_SOURCE_EXPIRATION,
//	SWITCH_TRANSLATE_ROAMING_PROFILE,
	// computer migration switches
	SWITCH_TRANSLATION_OPTION,
	SWITCH_TRANSLATE_FILES_AND_FOLDERS,
	SWITCH_TRANSLATE_LOCAL_GROUPS,
	SWITCH_TRANSLATE_PRINTERS,
	SWITCH_TRANSLATE_REGISTRY,
	SWITCH_TRANSLATE_SHARES,
	SWITCH_TRANSLATE_USER_PROFILES,
	SWITCH_TRANSLATE_USER_RIGHTS,
	SWITCH_RESTART_DELAY,
	// security translation switches
//	SWITCH_TRANSLATION_OPTION,
//	SWITCH_TRANSLATE_FILES_AND_FOLDERS,
//	SWITCH_TRANSLATE_LOCAL_GROUPS,
//	SWITCH_TRANSLATE_PRINTERS,
//	SWITCH_TRANSLATE_REGISTRY,
//	SWITCH_TRANSLATE_SHARES,
//	SWITCH_TRANSLATE_USER_PROFILES,
//	SWITCH_TRANSLATE_USER_RIGHTS,
	SWITCH_SID_MAPPING_FILE,
	// service account enumeration switches
	// report generation
	SWITCH_REPORT_TYPE,
	SWITCH_REPORT_FOLDER,
	// include switches
	SWITCH_INCLUDE_NAME,
	SWITCH_INCLUDE_FILE,
	SWITCH_INCLUDE_DOMAIN,
	// exclude switches
	SWITCH_EXCLUDE_NAME,
	SWITCH_EXCLUDE_FILE,
	// key switches
	SWITCH_KEY_IDENTIFIER,
	SWITCH_KEY_FOLDER,
	SWITCH_KEY_PASSWORD,
	// help switch
	SWITCH_HELP,
};


//---------------------------------------------------------------------------
// Switch Map
//---------------------------------------------------------------------------


class CSwitchMap :
	public std::map<_bstr_t, int, StringIgnoreCaseLess>
{
public:

	CSwitchMap();

	int GetSwitch(LPCTSTR pszSwitch);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\switch.cpp ===
#include "StdAfx.h"
#include "Switch.h"


namespace
{


//---------------------------------------------------------------------------
// Switch Text Structure
//---------------------------------------------------------------------------


struct SSwitchText
{
	int nSwitch;
	LPCTSTR pszText;
};


const SSwitchText s_SwitchText[] =
{
	// tasks
	{ SWITCH_TASK,                               _T("user,group,computer,security,service,report,key") },
	// general task options
	{ SWITCH_OPTION_FILE,                        _T("o,OptionFile") },
	{ SWITCH_TEST_MIGRATION,                     _T("tm,TestMigration") },
	{ SWITCH_INTRA_FOREST,                       _T("if,IntraForest") },
	{ SWITCH_SOURCE_DOMAIN,                      _T("sd,SourceDomain") },
	{ SWITCH_SOURCE_OU,                          _T("so,SourceOu") },
	{ SWITCH_TARGET_DOMAIN,                      _T("td,TargetDomain") },
	{ SWITCH_TARGET_OU,                          _T("to,TargetOu") },
	{ SWITCH_RENAME_OPTION,                      _T("ro,RenameOption") },
	{ SWITCH_RENAME_PREFIX_OR_SUFFIX,            _T("rt,RenamePrefixOrSuffix") },
	{ SWITCH_PASSWORD_OPTION,                    _T("po,PasswordOption") },
	{ SWITCH_PASSWORD_SERVER,                    _T("ps,PasswordServer") },
	{ SWITCH_PASSWORD_FILE,                      _T("pf,PasswordFile") },
	{ SWITCH_CONFLICT_OPTIONS,                   _T("co,ConflictOptions") },
	{ SWITCH_CONFLICT_PREFIX_OR_SUFFIX,          _T("ct,ConflictPrefixOrSuffix") },
	{ SWITCH_USER_PROPERTIES_TO_EXCLUDE,         _T("ux,UserPropertiesToExclude") },
	{ SWITCH_INETORGPERSON_PROPERTIES_TO_EXCLUDE, _T("ix,InetOrgPersonPropertiesToExclude") },
	{ SWITCH_GROUP_PROPERTIES_TO_EXCLUDE,        _T("gx,GroupPropertiesToExclude") },
	{ SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE,     _T("cx,ComputerPropertiesToExclude") },
	// specific task options
	{ SWITCH_DISABLE_OPTION,                     _T("dot,DisableOption") },
	{ SWITCH_SOURCE_EXPIRATION,                  _T("sep,SourceExpiration") },
	{ SWITCH_MIGRATE_SIDS,                       _T("mss,MigrateSids") },
	{ SWITCH_TRANSLATE_ROAMING_PROFILE,          _T("trp,TranslateRoamingProfile") },
	{ SWITCH_UPDATE_USER_RIGHTS,                 _T("uur,UpdateUserRights") },
	{ SWITCH_MIGRATE_GROUPS,                     _T("mgs,MigrateGroups") },
	{ SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, _T("umo,UpdatePreviouslyMigratedObjects") },
	{ SWITCH_FIX_GROUP_MEMBERSHIP,               _T("fgm,FixGroupMembership") },
	{ SWITCH_MIGRATE_SERVICE_ACCOUNTS,           _T("msa,MigrateServiceAccounts") },
	{ SWITCH_UPDATE_GROUP_RIGHTS,                _T("ugr,UpdateGroupRights") },
	{ SWITCH_MIGRATE_MEMBERS,                    _T("mms,MigrateMembers") },
	{ SWITCH_TRANSLATION_OPTION,                 _T("tot,TranslationOption") },
	{ SWITCH_TRANSLATE_FILES_AND_FOLDERS,        _T("tff,TranslateFilesAndFolders") },
	{ SWITCH_TRANSLATE_LOCAL_GROUPS,             _T("tlg,TranslateLocalGroups") },
	{ SWITCH_TRANSLATE_PRINTERS,                 _T("tps,TranslatePrinters") },
	{ SWITCH_TRANSLATE_REGISTRY,                 _T("trg,TranslateRegistry") },
	{ SWITCH_TRANSLATE_SHARES,                   _T("tss,TranslateShares") },
	{ SWITCH_TRANSLATE_USER_PROFILES,            _T("tup,TranslateUserProfiles") },
	{ SWITCH_TRANSLATE_USER_RIGHTS,              _T("tur,TranslateUserRights") },
	{ SWITCH_RESTART_DELAY,                      _T("rdl,RestartDelay") },
	{ SWITCH_SID_MAPPING_FILE,                   _T("smf,SidMappingFile") },
	{ SWITCH_REPORT_TYPE,                        _T("rpt,ReportType") },
	{ SWITCH_REPORT_FOLDER,                      _T("rpf,ReportFolder") },
	// include switches
	{ SWITCH_INCLUDE_NAME,                       _T("n,IncludeName") },
	{ SWITCH_INCLUDE_FILE,                       _T("f,IncludeFile") },
	{ SWITCH_INCLUDE_DOMAIN,                     _T("d,IncludeDomain") },
	// exclude switches
	{ SWITCH_EXCLUDE_NAME,                       _T("en,ExcludeName") },
	{ SWITCH_EXCLUDE_FILE,                       _T("ef,ExcludeFile") },
	// help
	{ SWITCH_HELP,                               _T("?,h,help") },
};

const UINT SWITCH_COUNT = countof(s_SwitchText);


}


//---------------------------------------------------------------------------
// Switch Map
//---------------------------------------------------------------------------


// constructor

CSwitchMap::CSwitchMap()
{
	static const _TCHAR DELIMITERS[] = _T(",");

	_TCHAR szSwitch[256];

	for (UINT i = 0; i < SWITCH_COUNT; i++)
	{
		int nSwitch = s_SwitchText[i].nSwitch;
		_ASSERT(_tcslen(s_SwitchText[i].pszText) < countof(szSwitch));
		_tcscpy(szSwitch, s_SwitchText[i].pszText);

		for (LPTSTR psz = _tcstok(szSwitch, DELIMITERS); psz; psz = _tcstok(NULL, DELIMITERS))
		{
			insert(value_type(_bstr_t(psz), nSwitch));
		}
	}
}


// GetSwitch Method

int CSwitchMap::GetSwitch(LPCTSTR pszSwitch)
{
	int nSwitch = -1;

	iterator it = find(_bstr_t(pszSwitch));

	if (it != end())
	{
		nSwitch = it->second;
	}

	return nSwitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\thread.cpp ===
#include "StdAfx.h"
#include "Thread.h"


//---------------------------------------------------------------------------
// Thread Class
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Constructor
//---------------------------------------------------------------------------

CThread::CThread() :
	m_dwThreadId(0),
	m_hStopEvent(CreateEvent(NULL, TRUE, FALSE, NULL))
{
}


//---------------------------------------------------------------------------
// Destructor
//---------------------------------------------------------------------------

CThread::~CThread()
{
}


//---------------------------------------------------------------------------
// Start Thread
//---------------------------------------------------------------------------

void CThread::StartThread()
{
	// reset exit event

	ResetEvent(m_hStopEvent);

	// create thread

	m_hThread = CreateThread(NULL, 0, ThreadProc, this, 0, &m_dwThreadId);

	if (m_hThread == NULL)
	{
	//	ThrowError(HRESULT_FROM_WIN32(GetLastError()), _T("Unable to create thread."));
	}
}


//---------------------------------------------------------------------------
// Stop Thread
//---------------------------------------------------------------------------

void CThread::StopThread()
{
	SetEvent(m_hStopEvent);

	if (m_hThread != NULL)
	{
		WaitForSingleObject(m_hThread, INFINITE);
	}
}


//---------------------------------------------------------------------------
// Thread Procedure
//---------------------------------------------------------------------------

DWORD WINAPI CThread::ThreadProc(LPVOID pvParameter)
{
	// initialize COM library for this thread
	// setting thread concurrency model to multi-threaded

	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if (SUCCEEDED(hr))
	{
		CThread* pThis = reinterpret_cast<CThread*>(pvParameter);

		try
		{
			pThis->Run();
		}
		catch (...)
		{
			;
		}

		CoUninitialize();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\thread.h ===
#pragma once


//---------------------------------------------------------------------------
// Handle Class
//
// Wrapper class for Win32 HANDLE.
//---------------------------------------------------------------------------


class CHandle
{
public:
	CHandle(HANDLE h = NULL) :
		m_Handle(h)
	{
	}

	~CHandle()
	{
		if (m_Handle != NULL)
		{
			CloseHandle(m_Handle);
			m_Handle = NULL;
		}
	}

	HANDLE operator =(HANDLE h)
	{
		if (m_Handle != NULL)
		{
			CloseHandle(m_Handle);
		}

		m_Handle = h;

		return m_Handle;
	}

	operator HANDLE() const
	{
		return m_Handle;
	}

protected:

	HANDLE m_Handle;
};


//---------------------------------------------------------------------------
// Thread Class
//
// Provides methods for starting and stopping a thread.
// The derived class must implement the Run method and perform all thread
// activity within this method. Any wait logic must include the stop event.
//---------------------------------------------------------------------------


class CThread
{
public:

	virtual ~CThread();

protected:

	CThread();

	HANDLE StopEvent() const
	{
		return m_hStopEvent;
	}

	void StartThread();
	void StopThread();

	virtual void Run() = 0;

private:

	static DWORD WINAPI ThreadProc(LPVOID pvParameter);

private:

	CHandle m_hThread;
	DWORD m_dwThreadId;

	CHandle m_hStopEvent;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\admtcrypt.cpp ===
//#include <StdAfx.h>
#include "AdmtCrypt.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace
{

void __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;
}

_variant_t operator +(const _variant_t& vntByteArrayA, const _variant_t& vntByteArrayB)
{
	_variant_t vntByteArrayC;

	// validate parameters

	if ((vntByteArrayA.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayA.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntByteArrayB.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayB.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// concatenate byte arrays

	DWORD cbA = vntByteArrayA.parray->rgsabound[0].cElements;
	DWORD cbB = vntByteArrayB.parray->rgsabound[0].cElements;

	CreateByteArray(cbA + cbB, vntByteArrayC);

	memcpy(vntByteArrayC.parray->pvData, vntByteArrayA.parray->pvData, cbA);
	memcpy((BYTE*)vntByteArrayC.parray->pvData + cbA, vntByteArrayB.parray->pvData, cbB);

	return vntByteArrayC;
}

#ifdef _DEBUG

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	_bstr_t strArray;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && ((vnt.parray != NULL)))
	{
		_TCHAR szArray[256] = _T("");

		DWORD c = vnt.parray->rgsabound[0].cElements;
		BYTE* pb = (BYTE*) vnt.parray->pvData;

		for (DWORD i = 0; i < c; i++, pb++)
		{
			_TCHAR sz[48];
			wsprintf(sz, _T("%02X"), (UINT)(USHORT)*pb);

			if (i > 0)
			{
				_tcscat(szArray, _T(" "));
			}

			_tcscat(szArray, sz);
		}

		strArray = szArray;
	}

	return strArray;
}

#define TRACE_BUFFER_SIZE 1024

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[TRACE_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);

		_vsntprintf(szMessage, TRACE_BUFFER_SIZE, pszFormat, args);

		va_end(args);

	#if 0
		OutputDebugString(szMessage);
	#else
		HANDLE hFile = CreateFile(L"C:\\AdmtCrypt.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
			DWORD dwWritten;
			WriteFile(hFile, szMessage, _tcslen(szMessage) * sizeof(_TCHAR), &dwWritten, NULL);
			CloseHandle(hFile);
		}
	#endif
	}
}

#else

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	return _T("");
}

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
}

#endif

}


//---------------------------------------------------------------------------
// Target Crypt Class
//---------------------------------------------------------------------------


// Constructor

CTargetCrypt::CTargetCrypt()
{
	Trace(_T("CTargetCrypt::CTargetCrypt()\r\n"));
}


// Destructor

CTargetCrypt::~CTargetCrypt()
{
	Trace(_T("CTargetCrypt::~CTargetCrypt()\r\n"));
}


// CreateEncryptionKey Method

_variant_t CTargetCrypt::CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword)
{
	Trace(_T("CreateEncryptionKey(pszKeyId='%s', pszPassword='%s')\r\n"), pszKeyId, pszPassword);

	// generate encryption key bytes

	_variant_t vntBytes = GenerateRandom(ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// store encryption key bytes

	StoreBytes(pszKeyId, vntBytes);

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	_variant_t vntPasswordFlag;
	CreateByteArray(1, vntPasswordFlag);
	*((BYTE*)vntPasswordFlag.parray->pvData) = (pszPassword && pszPassword[0]) ? 0xFF : 0x00;

	// concatenate encryption key bytes and hash of encryption key bytes

	CCryptHash hashBytes(CreateHash(CALG_SHA1));
	hashBytes.Hash(vntBytes);

	_variant_t vntDecrypted = vntBytes + hashBytes.GetValue();

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// encrypt bytes / hash pair

	_variant_t vntEncrypted = keyPassword.Encrypt(NULL, true, vntDecrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	return vntPasswordFlag + vntEncrypted;
}


// CreateSession Method

_variant_t CTargetCrypt::CreateSession(LPCTSTR pszKeyId)
{
	Trace(_T("CreateSession(pszKeyId='%s')\r\n"), pszKeyId);

	// get encryption key

	CCryptHash hashEncryption(CreateHash(CALG_SHA1));
	hashEncryption.Hash(RetrieveBytes(pszKeyId));

	CCryptKey keyEncryption(DeriveKey(CALG_3DES, hashEncryption));

	// generate session key bytes

	_variant_t vntBytes = GenerateRandom(SESSION_KEY_SIZE);

	// create session key

	CCryptHash hash(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	m_keySession.Attach(DeriveKey(CALG_3DES, hash));

	// concatenate session key bytes and hash of session key bytes

	_variant_t vntDecrypted = vntBytes + hash.GetValue();

	// encrypt session bytes and include hash

	return keyEncryption.Encrypt(NULL, true, vntDecrypted);
}


// Encrypt Method

_variant_t CTargetCrypt::Encrypt(_bstr_t strData)
{
	Trace(_T("Encrypt(strData='%s')\r\n"), (LPCTSTR)strData);

	// convert string to byte array

	_variant_t vnt;

	HRESULT hr = VectorFromBstr(strData, &vnt.parray);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	vnt.vt = VT_UI1|VT_ARRAY;

	// encrypt data

	return m_keySession.Encrypt(NULL, true, vnt);
}


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------


// Constructor

CSourceCrypt::CSourceCrypt()
{
	Trace(_T("CSourceCrypt::CSourceCrypt()\r\n"));
}


// Destructor

CSourceCrypt::~CSourceCrypt()
{
	Trace(_T("CSourceCrypt::~CSourceCrypt()\r\n"));
}


// ImportEncryptionKey Method

void CSourceCrypt::ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword)
{
	Trace(_T("ImportEncryptionKey(vntEncryptedKey={ %s }, pszPassword='%s')\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey), pszPassword);

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// extract password flag and verify with password

	bool bPassword = *((BYTE*)vntEncryptedKey.parray->pvData) ? true : false;

	if (bPassword)
	{
		if ((pszPassword == NULL) || (pszPassword[0] == NULL))
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}
	else
	{
		if (pszPassword && pszPassword[0])
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	// encrypted data

	_variant_t vntEncrypted;
	DWORD cbEncrypted = vntEncryptedKey.parray->rgsabound[0].cElements - 1;
	CreateByteArray(cbEncrypted, vntEncrypted);
	memcpy(vntEncrypted.parray->pvData, (BYTE*)vntEncryptedKey.parray->pvData + 1, cbEncrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	// decrypt encryption key bytes plus hash

	_variant_t vntDecrypted = keyPassword.Decrypt(NULL, true, vntEncrypted);

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// extract encryption key bytes

	_variant_t vntBytes;
	CreateByteArray(ENCRYPTION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, (BYTE*)vntDecrypted.parray->pvData, ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// extract hash of encryption key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - ENCRYPTION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + ENCRYPTION_KEY_SIZE, cbHashValue);

//	Trace(_T(" vntHashValue={ %s }\n"), (LPCTSTR)DebugByteArray(vntHashValue));

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare store encryption key bytes

	if (hashA == hashB)
	{
		StoreBytes(m_szIdPrefix, vntBytes);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}
}


// ImportSessionKey Method

void CSourceCrypt::ImportSessionKey(const _variant_t& vntEncryptedKey)
{
	Trace(_T("ImportSessionKey(vntEncryptedKey={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey));

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encryption key

	CCryptKey keyEncryption(GetEncryptionKey(m_szIdPrefix));

	// decrypt session key bytes plus hash

	_variant_t vntDecrypted = keyEncryption.Decrypt(NULL, true, vntEncryptedKey);

	// extract session key bytes

	_variant_t vntBytes;
	CreateByteArray(SESSION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, vntDecrypted.parray->pvData, SESSION_KEY_SIZE);

	// extract hash of session key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare

	if (hashA == hashB)
	{
		// derive session key from session key bytes hash

		m_keySession.Attach(DeriveKey(CALG_3DES, hashA));
	}
	else
	{
		_com_issue_error(E_FAIL);
	}
}


// Decrypt Method

_bstr_t CSourceCrypt::Decrypt(const _variant_t& vntData)
{
	Trace(_T("Decrypt(vntData={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntData));

	// decrypt data

	_variant_t vnt = m_keySession.Decrypt(NULL, true, vntData);

	// convert into string

	BSTR bstr;

	HRESULT hr = BstrFromVector(vnt.parray, &bstr);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	return bstr;
}


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------


// Constructor

CDomainCrypt::CDomainCrypt()
{
	Trace(_T("CDomainCrypt::CDomainCrypt()\r\n"));
}


// Destructor

CDomainCrypt::~CDomainCrypt()
{
	Trace(_T("CDomainCrypt::~CDomainCrypt()\r\n"));
}


// GetEncryptionKey Method

HCRYPTKEY CDomainCrypt::GetEncryptionKey(LPCTSTR pszKeyId)
{
	// retrieve bytes

	_variant_t vntBytes = RetrieveBytes(pszKeyId);

	// set hash value

	CCryptHash hash;
	hash.Attach(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	// create encryption key derived from bytes

	return DeriveKey(CALG_3DES, hash);
}


// StoreBytes Method

void CDomainCrypt::StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
{
	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt != VT_EMPTY) && (vntBytes.vt != (VT_UI1|VT_ARRAY)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt == (VT_UI1|VT_ARRAY)) && (vntBytes.parray == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_CREATE_SECRET, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// store data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		PWSTR pwsData = NULL;
		USHORT cbData = 0;

		if (vntBytes.vt != VT_EMPTY)
		{
			pwsData = reinterpret_cast<PWSTR>(vntBytes.parray->pvData);
			cbData = (USHORT) vntBytes.parray->rgsabound[0].cElements;
		}

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		LSA_UNICODE_STRING lusData = { cbData, cbData, pwsData };

		ntsStatus = LsaStorePrivateData(hPolicy, &lusKey, &lusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}
}


// RetrievePrivateData Method

_variant_t CDomainCrypt::RetrieveBytes(LPCTSTR pszId)
{
	_variant_t vntBytes;

	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// retrieve data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		PLSA_UNICODE_STRING plusData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lusKey, &plusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plusData->Length);

		if (vntBytes.parray == NULL)
		{
			LsaFreeMemory(plusData);
			_com_issue_error(E_OUTOFMEMORY);
		}

		vntBytes.vt = VT_UI1|VT_ARRAY;

		memcpy(vntBytes.parray->pvData, plusData->Buffer, plusData->Length);

		LsaFreeMemory(plusData);

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}

	return vntBytes;
}


// private data key identifier

_TCHAR CDomainCrypt::m_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------


// Constructors
//
// Notes:
// If the enhanced provider is not installed, CryptAcquireContext() generates
// the following error: (0x80090019) The keyset is not defined.

CCryptProvider::CCryptProvider() :
	m_hProvider(NULL)
{
	Trace(_T("E CCryptProvider::CCryptProvider(this=0x%p)\r\n"), this);

	if (!CryptAcquireContext(&m_hProvider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

#ifdef _DEBUG
	char szProvider[256];
	DWORD cbProvider = sizeof(szProvider);

	if (CryptGetProvParam(m_hProvider, PP_NAME, (BYTE*) szProvider, &cbProvider, 0))
	{
	}

	DWORD dwVersion;
	DWORD cbVersion = sizeof(dwVersion);

	if (CryptGetProvParam(m_hProvider, PP_VERSION, (BYTE*) &dwVersion, &cbVersion, 0))
	{
	}

//	char szContainer[256];
//	DWORD cbContainer = sizeof(szContainer);

//	if (CryptGetProvParam(m_hProvider, PP_CONTAINER, (BYTE*) szContainer, &cbContainer, 0))
//	{
//	}
#endif

	Trace(_T("L CCryptProvider::CCryptProvider()\r\n"));
}

CCryptProvider::CCryptProvider(const CCryptProvider& r) :
	m_hProvider(r.m_hProvider)
{
//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}
}


// Destructor

CCryptProvider::~CCryptProvider()
{
	Trace(_T("E CCryptProvider::~CCryptProvider()\r\n"));

	if (m_hProvider)
	{
		if (!CryptReleaseContext(m_hProvider, 0))
		{
			#ifdef _DEBUG
			DebugBreak();
			#endif
		}
	}

	Trace(_T("L CCryptProvider::~CCryptProvider()\r\n"));
}


// assignment operators

CCryptProvider& CCryptProvider::operator =(const CCryptProvider& r)
{
	m_hProvider = r.m_hProvider;

//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}

	return *this;
}


// CreateHash Method

HCRYPTHASH CCryptProvider::CreateHash(ALG_ID aid)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(m_hProvider, aid, 0, 0, &hHash))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hHash;
}


// DeriveKey Method

HCRYPTKEY CCryptProvider::DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags)
{
	HCRYPTKEY hKey;

	if (!CryptDeriveKey(m_hProvider, aid, hHash, dwFlags, &hKey))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hKey;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

_variant_t CCryptProvider::GenerateRandom(DWORD dwNumberOfBytes) const
{
	_variant_t vntRandom;

	// create byte array of specified length

	vntRandom.parray = SafeArrayCreateVector(VT_UI1, 0, dwNumberOfBytes);

	if (vntRandom.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntRandom.vt = VT_UI1|VT_ARRAY;

	// generate specified number of random bytes

	GenerateRandom((BYTE*)vntRandom.parray->pvData, dwNumberOfBytes);

	return vntRandom;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

void CCryptProvider::GenerateRandom(BYTE* pbData, DWORD cbData) const
{
	// generate specified number of random bytes

	if (!CryptGenRandom(m_hProvider, cbData, pbData))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}
}


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------


// Constructor

CCryptKey::CCryptKey(HCRYPTKEY hKey) :
	m_hKey(hKey)
{
}


// Destructor

CCryptKey::~CCryptKey()
{
	if (m_hKey)
	{
		if (!CryptDestroyKey(m_hKey))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// Encrypt Method

_variant_t CCryptKey::Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntEncrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encrypted data size

	DWORD cbData = vntData.parray->rgsabound[0].cElements;
	DWORD cbBuffer = cbData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, NULL, &cbBuffer, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create encrypted data buffer

	vntEncrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cbBuffer);

	if (vntEncrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntEncrypted.vt = VT_UI1|VT_ARRAY;

	// copy data to encrypted buffer

	memcpy(vntEncrypted.parray->pvData, vntData.parray->pvData, cbData);

	// encrypt data

	BYTE* pbData = (BYTE*) vntEncrypted.parray->pvData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pbData, &cbData, cbBuffer))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntEncrypted;
}


// Decrypt Method

_variant_t CCryptKey::Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntDecrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// decrypt data

	_variant_t vnt = vntData;

	BYTE* pb = (BYTE*) vnt.parray->pvData;
	DWORD cb = vnt.parray->rgsabound[0].cElements;

	if (!CryptDecrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pb, &cb))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create decrypted byte array
	// the number of decrypted bytes may be less than
	// the number of encrypted bytes

	vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntDecrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntDecrypted.vt = VT_UI1|VT_ARRAY;

	memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

	return vntDecrypted;
}


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------


// Constructor

CCryptHash::CCryptHash(HCRYPTHASH hHash) :
	m_hHash(hHash)
{
}


// Destructor

CCryptHash::~CCryptHash()
{
	if (m_hHash)
	{
		if (!CryptDestroyHash(m_hHash))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// GetValue Method

_variant_t CCryptHash::GetValue() const
{
	_variant_t vntValue;

	// get hash size

	DWORD dwHashSize;
	DWORD cbHashSize = sizeof(DWORD);

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// allocate buffer

	vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, dwHashSize);

	if (vntValue.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntValue.vt = VT_UI1|VT_ARRAY;

	// get hash value

	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, (BYTE*)vntValue.parray->pvData, &dwHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntValue;
}


// SetValue Method

void CCryptHash::SetValue(const _variant_t& vntValue)
{
	// if parameter is valid

	if ((vntValue.vt == (VT_UI1|VT_ARRAY)) && ((vntValue.parray != NULL)))
	{
		// get hash size

		DWORD dwHashSize;
		DWORD cbHashSize = sizeof(DWORD);

		if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		// validate hash size

		BYTE* pbValue = (BYTE*)vntValue.parray->pvData;
		DWORD cbValue = vntValue.parray->rgsabound[0].cElements;

		if (cbValue != dwHashSize)
		{
			_com_issue_error(E_INVALIDARG);
		}

		// set hash value

		if (!CryptSetHashParam(m_hHash, HP_HASHVAL, (BYTE*)pbValue, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(LPCTSTR pszData)
{
	if (pszData && pszData[0])
	{
		Hash((BYTE*)pszData, _tcslen(pszData) * sizeof(_TCHAR));
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(const _variant_t& vntData)
{
	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		Hash((BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements);
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(BYTE* pbData, DWORD cbData)
{
	if ((pbData != NULL) && (cbData > 0))
	{
		if (!CryptHashData(m_hHash, pbData, cbData, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


bool CCryptHash::operator ==(const CCryptHash& hash)
{
	bool bEqual = false;

	DWORD cbSize = sizeof(DWORD);

	// compare hash sizes

	DWORD dwSizeA;
	DWORD dwSizeB;

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	if (!CryptGetHashParam(hash.m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeB, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// if sizes are equal

	if (dwSizeA == dwSizeB)
	{
		// compare hashes

		BYTE* pbA;
		BYTE* pbB;

		try
		{
			pbA = (BYTE*) _alloca(dwSizeA);
			pbB = (BYTE*) _alloca(dwSizeB);
		}
		catch (...)
		{
			_com_issue_error(E_OUTOFMEMORY);
		}

		if (!CryptGetHashParam(m_hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (!CryptGetHashParam(hash.m_hHash, HP_HASHVAL, pbB, &dwSizeB, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (memcmp(pbA, pbB, dwSizeA) == 0)
		{
			bEqual = true;
		}
	}

	return bEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\stdafx.cpp ===
#include "StdAfx.h"

#import <MsPwdMig.tlb> no_namespace implementation_only
#import <ADMTScript.tlb> no_namespace implementation_only


// ThrowError Methods -----------------------------------------------

namespace
{

void __stdcall ThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription)
{
	_bstr_t bstrNewDescription;

	try
	{
		bstrNewDescription = pszDescription;

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				bstrNewDescription += _T(" : ");
			}

			bstrNewDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				if (bstrSource.length() > 0)
				{
					bstrNewDescription += _T(": ");
				}
				else
				{
					bstrNewDescription += _T(" ");
				}
			}

			bstrNewDescription += bstrOldDescription;
		}
		else
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (bstrNewDescription.length() > 0)
				{
					bstrNewDescription += _T(" : ");
				}

				bstrNewDescription += pszErrorMessage;
			}
		}
	}
	catch (...)
	{
		;
	}

	ICreateErrorInfoPtr spCreateErrorInfo;
	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
		spCreateErrorInfo->SetSource(L"");
		spCreateErrorInfo->SetGUID(GUID_NULL);
		spCreateErrorInfo->SetDescription(bstrNewDescription);
		spCreateErrorInfo->SetHelpFile(L"");
		spCreateErrorInfo->SetHelpContext(0);
	}

	_com_raise_error(ce.Error(), IErrorInfoPtr(spCreateErrorInfo).Detach());
}

}


void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, countof(szDescription), pszFormat, args);
        szDescription[countof(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(ce, szDescription);
}


void __cdecl ThrowError(_com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(GetModuleHandle(NULL), uId, szFormat, countof(szFormat)) > 0)
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, countof(szDescription), szFormat, args);
        szDescription[countof(szDescription) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(ce, szDescription);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\adsihelpers.cpp ===
#include "AdsiHelpers.h"


//------------------------------------------------------------------------------
// IsUserRid Function
//
// Synopsis
// Verifies that the RID is a user RID and not a reserved or built-in RID.
//
// Arguments
// IN vntSid - SID as an array of bytes (this is the form received from ADSI)
//
// Return
// A true value means that the RID is a user RID. A false value indicates either
// that the SID is invalid or the RID is a built-in RID.
//------------------------------------------------------------------------------

bool __stdcall IsUserRid(const _variant_t& vntSid)
{
	bool bUser = false;

	if (V_VT(&vntSid) == (VT_ARRAY|VT_UI1))
	{
		PSID pSid = (PSID)vntSid.parray->pvData;

		if (IsValidSid(pSid))
		{
			PUCHAR puch = GetSidSubAuthorityCount(pSid);
			DWORD dwCount = static_cast<DWORD>(*puch);
			DWORD dwIndex = dwCount - 1;
			PDWORD pdw = GetSidSubAuthority(pSid, dwIndex);
			DWORD dwRid = *pdw;

			if (dwRid >= MIN_NON_RESERVED_RID)
			{
				bUser = true;
			}
		}
	}

	return bUser;
}


//------------------------------------------------------------------------------
// GetEscapedFilterValue Function
//
// Synopsis
// Generates an escaped name that may be used in an LDAP query. The characters
// ( ) * \ must be escaped when used in an LDAP query per RFC 2254.
//
// Arguments
// IN pszName - the name to be escaped
//
// Return
// Returns the escaped name.
//------------------------------------------------------------------------------

tstring __stdcall GetEscapedFilterValue(PCTSTR pszValue)
{
    tstring strEscapedValue;

    if (pszValue)
    {
        //
        // Generate escaped name.
        //

        for (LPCTSTR pch = pszValue; *pch; pch++)
        {
            switch (*pch)
            {
            case _T('('):
                {
                    strEscapedValue += _T("\\28");
                    break;
                }
            case _T(')'):
                {
                    strEscapedValue += _T("\\29");
                    break;
                }
            case _T('*'):
                {
                    strEscapedValue += _T("\\2A");
                    break;
                }
            case _T('\\'):
                {
                    strEscapedValue += _T("\\5C");
                    break;
                }
            default:
                {
                    strEscapedValue += *pch;
                    break;
                }
            }
        }
    }

    return strEscapedValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\bkuprstr.cpp ===
//#pragma title( "BkupRstr.cpp - Get backup and restore privileges" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  BkupRstr.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-05-30
Description -  Get backup and restore privileges
Updates     -
===============================================================================
*/

#include <stdio.h>
#include <windows.h>
#include <lm.h>

#include "Common.hpp"
#include "UString.hpp"
#include "BkupRstr.hpp"


// Get backup and restore privileges using WCHAR machine name.
BOOL                                       // ret-TRUE if successful.
   GetBkupRstrPriv(
      WCHAR          const * sMachineW,     // in -NULL or machine name
      BOOL             fOn                              // in - indicates whether the privileges should be turned on or not
   )
{
   BOOL                      bRc=FALSE;    // boolean return code.
   HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token.
   DWORD                     rcOs, rcOs2;  // OS return code.
   WKSTA_INFO_100          * pWkstaInfo;   // Workstation info
   
   struct
   {
      TOKEN_PRIVILEGES       tkp;          // token privileges.
      LUID_AND_ATTRIBUTES    x[3];         // room for several.
   }                         token;

   rcOs = OpenProcessToken(
         GetCurrentProcess(),
         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
         &hToken )
         ? 0 : GetLastError();

   if ( !rcOs )
   {
      memset( &token, 0, sizeof token );
      bRc = LookupPrivilegeValue(
            sMachineW,
            SE_BACKUP_NAME,
            &token.tkp.Privileges[0].Luid );
      if ( bRc )
      {
         bRc = LookupPrivilegeValue(
               sMachineW,
               SE_RESTORE_NAME,
               &token.tkp.Privileges[1].Luid );
      }
      if ( !bRc )
      {
         rcOs = GetLastError();
      }
      else
      {
         token.tkp.PrivilegeCount = 2;
         token.tkp.Privileges[0].Attributes = fOn ? SE_PRIVILEGE_ENABLED : 0;
         token.tkp.Privileges[1].Attributes = fOn ? SE_PRIVILEGE_ENABLED : 0;
         AdjustTokenPrivileges( hToken, FALSE, &token.tkp, 0, NULL, 0 );
         rcOs = GetLastError();
      }
   }

   if ( hToken != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
   }

   // If we had any error, try NetWkstaGetInfo.
   // If NetWkstaGetInfo fails, then use it's error condition instead.
   if ( rcOs )
   {
      pWkstaInfo = NULL,
      rcOs2 = NetWkstaGetInfo(
            const_cast<WCHAR *>(sMachineW),
            100,
            (BYTE **) &pWkstaInfo );
      if ( pWkstaInfo )
      {
         NetApiBufferFree( pWkstaInfo );
      }
      if ( rcOs2 )
      {
         rcOs = rcOs2;
      }
   }

   if ( !rcOs )
   {
      bRc = TRUE;
   }
   else
   {
      SetLastError(rcOs);
      bRc = FALSE;
   }

   return bRc;
}

// ===========================================================================
/*    Function    :  GetPrivilege
   Description    :  This function gives the requested privilege on the requested
                     computer.
*/
// ===========================================================================
BOOL                                       // ret-TRUE if successful.
   GetPrivilege(
      WCHAR          const * sMachineW,    // in -NULL or machine name
      LPCWSTR                pPrivilege,    // in -privilege name such as SE_SHUTDOWN_NAME
      BOOL                      fOn                 // in - indicates whether the privilege should be turned on or not

   )
{
   BOOL                      bRc=FALSE;    // boolean return code.
   HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token.
   DWORD                     rcOs, rcOs2;  // OS return code.
   WCHAR             const * sEpName;      // API EP name if failure.
   WKSTA_INFO_100          * pWkstaInfo;   // Workstation info

   struct
   {
      TOKEN_PRIVILEGES       tkp;          // token privileges.
      LUID_AND_ATTRIBUTES    x[3];         // room for several.
   }                         token;

   sEpName = L"OpenProcessToken";

   rcOs = OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                            &hToken )
         ? 0 : GetLastError();

   if ( !rcOs )
   {
      memset( &token, 0, sizeof token );
      sEpName = L"LookupPrivilegeValue";
      bRc = LookupPrivilegeValue( sMachineW,
                                  pPrivilege,
                                  &token.tkp.Privileges[0].Luid
                                );
      if ( !bRc )
      {
         rcOs = GetLastError();
      }
      else
      {
         token.tkp.PrivilegeCount = 1;
         token.tkp.Privileges[0].Attributes = fOn ? SE_PRIVILEGE_ENABLED : 0;
         sEpName = L"AdjustTokenPrivileges";
         AdjustTokenPrivileges( hToken, FALSE, &token.tkp, 0, NULL, 0 );
         rcOs = GetLastError();
      }
   }

   if ( hToken != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
   }

   // If we had any error, try NetWkstaGetInfo.
   // If NetWkstaGetInfo fails, then use it's error condition instead.
   if ( rcOs )
   {
      pWkstaInfo = NULL,
      rcOs2 = NetWkstaGetInfo(
            const_cast<WCHAR *>(sMachineW),
            100,
            (BYTE **) &pWkstaInfo );
      if ( pWkstaInfo )
      {
         NetApiBufferFree( pWkstaInfo );
      }
      if ( rcOs2 )
      {
         rcOs = rcOs2;
         sEpName = L"NetWkstaGetInfo";
      }
   }

   if ( !rcOs )
   {
      bRc = TRUE;
   }
   else
   {
     bRc = FALSE;
     SetLastError(rcOs);
   }

   return bRc;
}


// ===========================================================================
/*    Function    :  ComputerShutDown
   Description    :  This function shutsdown/restarts the given computer.

*/
// ===========================================================================

DWORD 
   ComputerShutDown(
      WCHAR          const * pComputerName,        // in - computer to reboot
      WCHAR          const * pMessage,             // in - message to display in NT shutdown dialog
      DWORD                  delay,                // in - delay, in seconds
      DWORD                  bRestart,             // in - flag, whether to reboot or just shutdown
      BOOL                   bNoChange             // in - flag, whether to really do it
   )
{
   BOOL                      bSuccess = FALSE;
   WCHAR                     wcsMsg[LEN_ShutdownMessage];
   WCHAR                     wcsComputerName[LEN_Computer];
   DWORD                     rc = 0;
   WKSTA_INFO_100          * localMachine;
   WKSTA_INFO_100          * targetMachine;

   
   if ( pMessage )
   {
      wcsncpy(wcsMsg,pMessage, LEN_ShutdownMessage);
      wcsMsg[LEN_ShutdownMessage-1] = L'\0';
   }
   else
   {
      wcsMsg[0] = 0;
   }

   if ( pComputerName && *pComputerName )
   {
      if ( ( pComputerName[0] == L'\\' ) && ( pComputerName[1] == L'\\' ) )
      {
         wcsncpy(wcsComputerName,pComputerName, LEN_Computer);
         wcsComputerName[LEN_Computer-1] = L'\0';
      }
      else
      {
         _snwprintf(wcsComputerName,LEN_Computer,L"\\\\%s",pComputerName);
         wcsComputerName[LEN_Computer-1] = L'\0';
      }
      
      // Get the name of the local machine
      rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&localMachine);
      if (! rc )
      {
         rc = NetWkstaGetInfo(wcsComputerName,100,(LPBYTE*)&targetMachine);
      }
      if ( ! rc )
      {
         // Get the privileges needed to shutdown a machine
         if ( !_wcsicmp(wcsComputerName + 2, localMachine->wki100_computername)  )
         {
            bSuccess = GetPrivilege(wcsComputerName, (LPCWSTR)SE_SHUTDOWN_NAME);
         }
         else
         {
            bSuccess = GetPrivilege(wcsComputerName, (LPCWSTR)SE_REMOTE_SHUTDOWN_NAME);
         }
         if ( ! bSuccess )
         {
            rc = GetLastError();
         }
      }
   }
   else
   {
         // Computer name not specified - the is the local machine
      wcsComputerName[0] = 0;   
      bSuccess = GetPrivilege(NULL, (LPCWSTR)SE_SHUTDOWN_NAME);
      if ( ! bSuccess )
      {
         rc = GetLastError();
      }
   }
   if ( bSuccess && ! bNoChange )
   {
      bSuccess = InitiateSystemShutdown( wcsComputerName,
                                      wcsMsg,
                                      delay,
                                      TRUE,
                                      bRestart
                                    );
      if ( !bSuccess )
      {
         rc = GetLastError();
      }
   }
   return rc;
}


// BkupRstr.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\agrpcutl.cpp ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.cpp

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif


// These global variables can be changed if required
TCHAR            const * gsEaDctProtoSeq = (TCHAR const *)TEXT("ncacn_np");
TCHAR            const * gsEaDctEndPoint = (TCHAR const *)TEXT("\\pipe\\EaDctRpc");


// Destroy RPC binding for connection with Agent service
DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   )
{
   if ( *phBinding )
   {
      RpcBindingFree( phBinding );
      *phBinding = NULL;
   }

   if ( *psBinding )
   {
      RpcStringFree( psBinding );
      *psBinding = NULL;
   }

   return 0;
}




// Create RPC binding for connection with Agent Service
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -flag whether to use authenticated RPC
   )
{
   DWORD                     rcOs;         // OS return code

   do // once or until break
   {
      EaxBindDestroy( phBinding, psBinding );
      rcOs = RpcStringBindingCompose(
            NULL,
            (TCHAR *) gsEaDctProtoSeq,
            (TCHAR *) sComputer,
            (TCHAR *) gsEaDctEndPoint,
            NULL,
            psBinding );
      if ( rcOs ) break;
      rcOs = RpcBindingFromStringBinding( *psBinding, phBinding );
      if ( rcOs || !bAuthn ) break;
      rcOs = RpcBindingSetAuthInfo(
            *phBinding,
            0,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            0,
            0 );
   }  while ( FALSE );

   if ( rcOs )
   {
      EaxBindDestroy( phBinding, psBinding );
   }

   return rcOs;
}



///////////////////////////////////////////////////////////////////////////////
// midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\cipher.cpp ===
//#pragma title( "Cipher.cpp - Very simple cipher for encryption" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc.  All rights reserved.
===============================================================================
Module      -  Cipher.cpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1996-01-21
Description -  Very simple Cipher routine for network packet password
               encryption.  This is a symmetrical cipher where applying
               it twice will revert it to its orignial form.  One of its
               functions is a one's complement so it assumes that no char
               will have the value of '\xff' to erroneously pre-terminate
               the resultant string.

               NOTE: This is obviously so simple that it can be easily
               cracked by either single stepping the code or comparing sequences
               of known values and their encrypted result.  Its only use
               is to keep out the casual observer/hacker.  It should be replaced
               by heavy public key encryption when possible.

Updates     -
===============================================================================
*/
#include <windows.h>
#include "Cipher.hpp"

void
   SimpleCipher(
      WCHAR                * str           // i/o-string to encrypt
   )
{
   WCHAR                   * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  *c;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

void
   SimpleCipher(
      char unsigned        * str           // i/o-string to encrypt
   )
{
   char unsigned           * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  *c;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

void
   SimpleCipher(
      char unsigned        * str          ,// i/o-string to encrypt
      int                    len           // in -length of string
   )
{
   char unsigned           * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  len--;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

// Cipher.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\commalog.cpp ===
/*---------------------------------------------------------------------------
  File: CommaLog.cpp

  Comments: TError based log file with optional NTFS security initialization.

  This can be used to write a log file which only administrators can access.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 10:49:07

  09/05/01 Mark Oluper - use Windows File I/O API
 ---------------------------------------------------------------------------
*/


//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <share.h>
#include <lm.h>
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "CommaLog.hpp"
#include "BkupRstr.hpp"
#include "Folders.h"



#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define USERS              6
#define SYSTEM             7


extern TErrorDct err;

#define  BYTE_ORDER_MARK   (0xFEFF)

PSID                                            // ret- SID for well-known account
   GetWellKnownSid(
      DWORD                  wellKnownAccount   // in - one of the constants #defined above for the well-known accounts
   )
{
   PSID                      pSid = NULL;
//   PUCHAR                    numsubs = NULL;
//   DWORD                   * rid = NULL;
   BOOL                      error = FALSE;

   
   
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY creatorIA =    SECURITY_CREATOR_SID_AUTHORITY;
    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //
   switch ( wellKnownAccount )
   {
      case CREATOR_OWNER:
         if( ! AllocateAndInitializeSid(
                  &creatorIA,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  SECURITY_CREATOR_OWNER_RID,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ADMINISTRATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ACCOUNT_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case BACKUP_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
     case USERS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_USERS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
     case SYSTEM:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  1,
                  SECURITY_LOCAL_SYSTEM_RID,
                  0, 0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
        
         break;

      default:
         MCSASSERT(FALSE);
         break;
   }
   if ( error )
   {
      FreeSid(pSid);
      pSid = NULL;
   }
   return pSid;
}


BOOL                                       // ret- whether log was successfully opened or not
   CommaDelimitedLog::LogOpen(
      PCTSTR                  filename,    // in - name for log file
      BOOL                    protect,     // in - if TRUE, try to ACL the file so only admins can access
      int                     mode         // in - mode 0=overwrite, 1=append
   )
{
    BOOL bOpen = FALSE;

    // close log if currently open

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        LogClose();
    }

    // if a file name was specified

    if (filename && filename[0])
    {
        // open or create file and share for both reading and writing

        m_hFile = CreateFile(
            filename,
            GENERIC_WRITE,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        // if file successfully opened

        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            // if append specified move file pointer to end of file
            // if overwrite specified move file pointer to beginning of file
            // either way if pointer is at beginning of file after moving then write byte order mark

            if (SetFilePointer(m_hFile, 0, NULL, mode ? FILE_END : FILE_BEGIN) == 0)
            {
                DWORD dwWritten;
                WCHAR chByteOrderMark = BYTE_ORDER_MARK;

                WriteFile(m_hFile, &chByteOrderMark, sizeof(chByteOrderMark), &dwWritten, NULL);
            }

            bOpen = TRUE;
        }
    }

    // if file successfully opened and protect specified
    // set permissions on file so that only Administrators alias has access

   if (bOpen && protect)
   {
      
      WCHAR               fname[MAX_PATH+1];
      
      safecopy(fname,filename);
   
      if ( GetBkupRstrPriv(NULL, TRUE) )
      {
         // Set the SD for the file to Administrators Full Control only.
         TFileSD                sd(fname);

         if ( sd.GetSecurity() != NULL )
         {
            PSID                mySid = GetWellKnownSid(ADMINISTRATORS);
            TACE                ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,mySid);
            PACL                acl = NULL;  // start with an empty ACL
         
            sd.GetSecurity()->ACLAddAce(&acl,&ace,-1);
            if (acl == NULL)
            {
                bOpen = FALSE;
            }
            else if (!sd.GetSecurity()->SetDacl(acl,TRUE))
            {
                bOpen = FALSE;
            }
            else if (!sd.WriteSD())
            {
                bOpen = FALSE;
            }
         }
         else
         {
            bOpen = FALSE;
         }
      }
      else
      {
         err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_NO_BR_PRIV_SD,fname,GetLastError());
         bOpen = FALSE;
      }
   }

    if (!bOpen && (m_hFile != INVALID_HANDLE_VALUE))
    {
        LogClose();
    }
    
   return bOpen;
}


BOOL CommaDelimitedLog::MsgWrite(
  const _TCHAR   msg[]        ,// in -error message to display
   ...                         // in -printf args to msg pattern
) const
{
  TCHAR                     suffix[350];
  int                       lenSuffix = sizeof(suffix)/sizeof(TCHAR);
  va_list                   argPtr;

  va_start(argPtr, msg);
  int cch = _vsntprintf(suffix, lenSuffix - 1, msg, argPtr);
  suffix[lenSuffix - 1] = '\0';
  va_end(argPtr);

    // append carriage return and line feed characters

    if ((cch >= 0) && (cch < (lenSuffix - 2)))
    {
        suffix[cch++] = _T('\r');
        suffix[cch++] = _T('\n');
        suffix[cch] = _T('\0');
    }
    else
    {
        suffix[lenSuffix - 3] = _T('\r');
        suffix[lenSuffix - 2] = _T('\n');
        cch = lenSuffix;
    }

  return LogWrite(suffix, cch);
}


BOOL CommaDelimitedLog::LogWrite(PCTSTR msg, int len) const
{
    BOOL bWrite = FALSE;

    // if file was successfully opened

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        // move file pointer to end of file and write data
        // moving file pointer to end guarantees that all writes append to file
        // especially when the file has been opened by multiple writers

        DWORD dwWritten;

        SetFilePointer(m_hFile, 0, NULL, FILE_END);

        bWrite = WriteFile(m_hFile, msg, len * sizeof(_TCHAR), &dwWritten, NULL);
    }

    return bWrite;
}


//----------------------------------------------------------------------------
// Password Log LogOpen Method
//
// Synopsis
// If the password log path is specified then attempt to open file. If unable
// to open specified file then attempt to open default file. Note that if the
// specified path is the same as the default path then no further attempt to
// open file is made.
// If the password log path is not specified then simply attempt to open the
// default file.
// Note that errors are logged to the current error log.
//
// Arguments
// pszPath - specified path to passwords log
//
// Return Value
// Returns TRUE if able to open a file otherwise FALSE.
//----------------------------------------------------------------------------

BOOL CPasswordLog::LogOpen(PCTSTR pszPath)
{
    //
    // If password file is specified then attempt to open it.
    //

    if (pszPath && _tcslen(pszPath) > 0)
    {
        if (CommaDelimitedLog::LogOpen(pszPath, TRUE, 1) == FALSE)
        {
            err.MsgWrite(ErrE, DCT_MSG_OPEN_PASSWORD_LOG_FAILURE_S, pszPath);
        }
    }

    //
    // If not specified or unable to open then attempt to open default passwords file.
    //

    if (IsOpen() == FALSE)
    {
        //
        // If able to retrieve default path for passwords file and the path is
        // different from the specified path then attempt to open the file.
        //

        _bstr_t strDefaultPath = GetLogsFolder() + _T("Passwords.txt");

        if (strDefaultPath.length() > 0)
        {
            if ((pszPath == NULL) || (_tcsicmp(pszPath, strDefaultPath) != 0))
            {
                //
                // If able to open default passwords file then
                // log message stating default path otherwise
                // log failure.
                //

                if (CommaDelimitedLog::LogOpen(strDefaultPath, TRUE, 1))
                {
                    err.MsgWrite(ErrI, DCT_MSG_NEW_PASSWORD_LOG_S, (_TCHAR*)strDefaultPath);
                }
                else
                {
                    err.MsgWrite(ErrE, DCT_MSG_OPEN_PASSWORD_LOG_FAILURE_S, (_TCHAR*)strDefaultPath);
                }
            }
        }
        else
        {
            err.MsgWrite(ErrE, DCT_MSG_CANNOT_RETRIEVE_DEFAULT_PASSWORD_LOG_PATH);
        }
    }

    return IsOpen();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\common.cpp ===
//#pragma title( "Common.cpp - Common class implementations" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common class implementations.
Updates     -  1997-09-09 RED ErrorCodeToText moved to Err.cpp
            -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"

///////////////////////////////////////////////////////////////////////////////
// TTime class member functions
///////////////////////////////////////////////////////////////////////////////

   TTime                     gTTime;       // global instance of TTime

time_t                                     // ret-current time
   TTime::Now(
      time_t               * pTime         // out-optional current time
   )  const
{
   time_t                    tTime;        // work copy of current time

   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   tTime = ConvertFiletimeToTimet( wTime.intTime );

   if ( pTime ) *pTime = tTime;
   return tTime;
}

__int64                                    // ret-current time
   TTime::NowAsFiletime(
      __int64              * pTime         // out-optional current time
   )  const
{
   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   if ( pTime ) *pTime = wTime.intTime;
   return wTime.intTime;
}

time_t                                     // ret-time_t representation
   TTime::ConvertFiletimeToTimet(
      __int64                fileTime      // in -filetime representation
   )  const
{
   __int64                   wTime;        // intermediate work area
   time_t                    retTime;      // returned time

   // If the source date/time is less than the minimum date/time supported
   // by time_t, then zero is returned.
   // If the source date/time is more that the maximum date/time supported
   // by time_t, then ULONG_MAX is returned.

   wTime = fileTime / 10000000;

   if ( wTime < 11644473600 )
   {
      retTime = 0;
   }
   else
   {
      wTime -= 11644473600;
      if ( wTime > ULONG_MAX )
      {
         retTime = ULONG_MAX;
      }
      else
      {
         retTime = (time_t) wTime;
      }
   }

   return retTime;
}


WCHAR *                                     // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoUtc(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   tmTime = gmtime( &tTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

WCHAR *                                    // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoLcl(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   TIME_ZONE_INFORMATION     infoTime;     // WIN32 time zone info
   time_t                    wTime;        // workarea
   switch ( GetTimeZoneInformation( &infoTime ) )
   {
      case TIME_ZONE_ID_STANDARD:
         wTime = infoTime.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         wTime = infoTime.DaylightBias;
         break;
      default:
         wTime = 0;
         break;
   }
   wTime = (infoTime.Bias + wTime) * 60;
   wTime = tTime - wTime;
   if ( wTime < 0 )
   {
      wTime = 0;
   }
   tmTime = gmtime( &wTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) plus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   )
{
   memset( pTimeZoneInfo, 0, sizeof *pTimeZoneInfo );
   BOOL                      retval=TRUE;  // returned value
   DWORD                     OsRc;         // OS return code
   TIME_ZONE_INFORMATION     TimeZoneInfo; // WIN32 time zone info

   OsRc = GetTimeZoneInformation( &TimeZoneInfo );
   switch ( OsRc )
   {
      case TIME_ZONE_ID_STANDARD:
         pTimeZoneInfo->dst = TimeZoneInfo.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         pTimeZoneInfo->dst = TimeZoneInfo.DaylightBias;
         break;
      case TIME_ZONE_ID_UNKNOWN:
         retval = TimeZoneInfo.Bias;
         break;
      default:
         retval = FALSE;
         break;
   }
   if ( retval )
   {
      pTimeZoneInfo->bias = TimeZoneInfo.Bias * 60;
      pTimeZoneInfo->dst *= 60;
      pTimeZoneInfo->biasdst = pTimeZoneInfo->bias + pTimeZoneInfo->dst;
   }
   return retval;
}

// Common.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\errdct.cpp ===
/*---------------------------------------------------------------------------
  File: ErrDct.cpp

  Comments: TError derived class for OnePoint Domain Administrator messages

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "ErrDct.hpp"
#include "AdsErr.h"

#define  TERR_MAX_MSG_LEN  (2000)

// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   )
{
   WCHAR                   * c;
   WCHAR                   * end;
   BOOL                      error = FALSE;
   DWORD                     rcOs;
   WCHAR                     dirName[MAX_PATH+1];
   BOOL                      isUNC = FALSE;
   BOOL                      skipShareName = FALSE;

   if ( !dirName )
      return ERROR_INVALID_PARAMETER;

   safecopy(dirName,dirToCreate);

   // Note: if the string is empty, that's ok - we will catch it when we don't see C:\ or C$\ below
   // walk through the string, and try to create at each step along the way

   do { // once
      c = dirName;
      end = dirName + UStrLen(dirName);
          // skip computer-name if UNC
      if ( *c == L'\\' && *(c + 1) == L'\\' )
      {
         isUNC = TRUE;
         for ( c=c+2 ; *c && *c != L'\\' ; c++ )
         ;
         if ( ! *c )
         {
            error = TRUE;
            rcOs = ERROR_INVALID_PARAMETER;
            break;
         }
         c++;
      }
      // skip C:\ or C$\.
      if ( *(c) &&  ( *(c+1)==L'$' || *(c+1)==L':' ) && *(c+2)==L'\\' )
      {
         c = c + 3;
         if ( c == end ) // They put in the root directory for some volume
            break;

      }
      else
      {
         if ( isUNC )
         {
            skipShareName = TRUE;
         }
         else
         {
            rcOs = ERROR_INVALID_PARAMETER;
            error = TRUE;
            break;
         }
      }
      // scan through the string looking for '\'
      for ( ; c <= end ; c++ )
      {
         if ( !*c || *c == L'\\' )
         {
            if ( skipShareName )
            {
               skipShareName = FALSE;
               continue;
            }
            // try to create at this level
            *c = L'\0';
            if ( ! CreateDirectory(dirName,NULL) )
            {
               rcOs = GetLastError();
               switch ( rcOs )
               {
               case 0:
               case ERROR_ALREADY_EXISTS:
                  break;
               default:
                  error = TRUE;
               }
            }
            if (c != end )
               *c = L'\\';
            if ( error )
                  break;
         }
      }
   } while ( FALSE );
   if ( !error )
      rcOs = 0;

   return rcOs;
}


WCHAR const *                               // ret- text for DCT message
   TErrorDct::LookupMessage(
      UINT                   msgNumber     // in - message number DCT_MSG_???
   )
{
   WCHAR             const * msg = NULL;

   return msg;
}

WCHAR *                                     // ret-text for system or EA error
   TErrorDct::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   if ( SUCCEEDED(code) )
   {
      return TError::ErrorCodeToText(code,lenMsg,msg);
   }
   else
   {
      if ( HRESULT_FACILITY(code) == FACILITY_WIN32 )
      {
         return TError::ErrorCodeToText(HRESULT_CODE(code),lenMsg,msg);
      }
      else
      {
         //Translate ADSI errors to DCT errors so message can be written.
         DWORD msgId = 0;
         switch ( code )
         {
            case (E_ADS_BAD_PATHNAME)              :   msgId = DCT_MSG_E_MSG_ADS_BAD_PATHNAME;
                                                      break;
            case (E_ADS_INVALID_DOMAIN_OBJECT)     :   msgId = DCT_MSG_E_ADS_INVALID_DOMAIN_OBJECT;
                                                      break;
            case (E_ADS_INVALID_USER_OBJECT)       :   msgId = DCT_MSG_E_ADS_INVALID_USER_OBJECT;
                                                      break;
            case (E_ADS_INVALID_COMPUTER_OBJECT)   :   msgId = DCT_MSG_E_ADS_INVALID_COMPUTER_OBJECT;
                                                      break;
            case (E_ADS_UNKNOWN_OBJECT)            :   msgId = DCT_MSG_E_ADS_UNKNOWN_OBJECT;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SET)          :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SET;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SUPPORTED)    :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SUPPORTED;
                                                      break;
            case (E_ADS_PROPERTY_INVALID)          :   msgId = DCT_MSG_E_ADS_PROPERTY_INVALID;
                                                      break;
            case (E_ADS_BAD_PARAMETER)             :   msgId = DCT_MSG_E_ADS_BAD_PARAMETER;
                                                      break;
            case (E_ADS_OBJECT_UNBOUND)            :   msgId = DCT_MSG_E_ADS_OBJECT_UNBOUND;
                                                      break;
            case (E_ADS_PROPERTY_NOT_MODIFIED)     :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_MODIFIED;
                                                      break;
            case (E_ADS_PROPERTY_MODIFIED)         :   msgId = DCT_MSG_E_ADS_PROPERTY_MODIFIED;
                                                      break;
            case (E_ADS_CANT_CONVERT_DATATYPE)     :   msgId = DCT_MSG_E_ADS_CANT_CONVERT_DATATYPE;
                                                      break;
            case (E_ADS_PROPERTY_NOT_FOUND)        :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_FOUND;
                                                      break;
            case (E_ADS_OBJECT_EXISTS)             :   msgId = DCT_MSG_E_ADS_OBJECT_EXISTS;
                                                      break;
            case (E_ADS_SCHEMA_VIOLATION)          :   msgId = DCT_MSG_E_ADS_SCHEMA_VIOLATION;
                                                      break;
            case (E_ADS_COLUMN_NOT_SET)            :   msgId = DCT_MSG_E_ADS_COLUMN_NOT_SET;
                                                      break;
            case (E_ADS_INVALID_FILTER)            :   msgId = DCT_MSG_E_ADS_INVALID_FILTER;
                                                      break;
            default                                :   msgId = 0;
         }

         if ( !msgId )
         {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | 80,
                           NULL,
                           code,
                           0,
                           msg,
                           lenMsg,
                           NULL );
         }
         else
         {
            static HMODULE            hDctMsg = NULL;
            DWORD                     rc = 0;   
            if ( ! hDctMsg )
            {
               hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
               if ( ! hDctMsg )
               {
                  rc = GetLastError();
               }
            }

            if ( ! rc )
            {
               FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          hDctMsg,
                          msgId,
                          0,
                          msg,
                          lenMsg,
                          NULL);
            }
            else
            {
               swprintf(msg,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgId);
            }
            
         }
      }
   }
   return msg;
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   )
{
    csLogError.Enter();

    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    WCHAR                   * pMsg = NULL;
    va_list                   argPtr;
    int                       len;

    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return;

    static HMODULE            hDctMsg = NULL;
    DWORD                     rc = 0;

    if ( ! hDctMsg )
    {
        hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
        if ( ! hDctMsg )
        {
            rc = GetLastError();
        }
    }

    va_start(argPtr,msgNumber);

    if ( ! rc )
    {
        len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                            hDctMsg,
                            msgNumber,
                            0,
                            suffix,
                            DIM(suffix),
                            &argPtr);
    }
    else
    {
        swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
    }
    va_end(argPtr);

    // Change any imbedded CR or LF to blank.
    for ( pMsg = suffix;
            *pMsg;
            pMsg++ )
    {
        if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
    }
    // append the system message for the lastRc at the end.
    len = UStrLen(suffix);
    if ( len < DIM(suffix) - 1 )
    {
        ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len );
    }
    suffix[DIM(suffix) - 1] = L'\0';

    va_end(argPtr);

    MsgProcess(num + HRESULT_CODE(msgNumber), suffix);

    csLogError.Leave();
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
    csLogError.Enter();

    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return;
    static HMODULE            hDctMsg = NULL;
    DWORD                     rc = 0;

    if ( ! hDctMsg )
    {
        hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
        if ( ! hDctMsg )
        {
            rc = GetLastError();
        }
    }

    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    va_list                   argPtr;

    va_start(argPtr,msgNumber);

    if ( rc == 0 )
    {
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                      hDctMsg,
                      msgNumber,
                      0,
                      suffix,
                      DIM(suffix),
                      &argPtr);
    }
    else
    {
        swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
    }
    
    if ( suffix[UStrLen(suffix)-1] == L'\n' )
    {
        suffix[UStrLen(suffix)-1] = L'\0';
    }

    va_end(argPtr);

    MsgProcess(num + HRESULT_CODE(msgNumber), suffix);

    csLogError.Leave();

}

void __cdecl
   TErrorDct::DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      )
{
    csLogError.Enter();

    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return;

    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    va_list                   argPtr;

    va_start(argPtr,msg);
    _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
    suffix[DIM(suffix) - 1] = L'\0';
    va_end(argPtr);

    MsgProcess(num, suffix);

    csLogError.Leave();
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
_bstr_t __cdecl
   TErrorDct::GetMsgText(
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
    csLogError.Enter();

    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return suffix;
    static HMODULE            hDctMsg = NULL;
    DWORD                     rc = 0;

    if ( ! hDctMsg )
    {
        hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
        if ( ! hDctMsg )
        {
            rc = GetLastError();
        }

    }

    va_list                   argPtr;
    va_start(argPtr,msgNumber);

    if ( rc == 0 )
    {
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                      hDctMsg,
                      msgNumber,
                      0,
                      suffix,
                      DIM(suffix),
                      &argPtr);
    }
    else
    {
        swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
    }
    if ( suffix[UStrLen(suffix)-1] == L'\n' )
    {
        suffix[UStrLen(suffix)-1] = L'\0';
    }

    _bstr_t returnedMessage;
    
    try
    {
        returnedMessage = suffix;
    }
    catch (...)
    {
    }

    csLogError.Leave();

    return returnedMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\exldap.cpp ===
#include "exldap.h"
#include "folders.h"
#include "treg.hpp"
#include "errdct.hpp"
#include "resstr.h"
#include "LSAUtils.h"

using namespace nsFolders;


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct              err;

CLdapConnection::CLdapConnection()
{ 
   m_exchServer[0] = 0; 
   m_LD = NULL; 
   m_port = LDAP_PORT;
   m_bUseSSL = FALSE;
   
   // try to dynamically load the LDAP DLL
   m_hDll = LoadLibrary(L"wldap32.dll");
   ldap_open = NULL;
   ldap_parse_result = NULL;
   ldap_parse_page_control = NULL;
   ldap_controls_free = NULL;
   ber_bvfree = NULL;
   ldap_first_entry = NULL;
   ldap_next_entry = NULL;
   ldap_value_free = NULL;
   ldap_get_values = NULL;
   ldap_create_page_control = NULL;
   ldap_search_ext_s = NULL;
   ldap_count_entries = NULL;
   ldap_msgfree = NULL;
   ldap_modify_s = NULL;
   LdapGetLastError = NULL;
   ldap_bind_sW = NULL;
   ldap_simple_bind_sW = NULL;
   ldap_unbind = NULL;
   ldap_connect = NULL;
   ldap_get_option = NULL;
   ldap_set_option = NULL;
   LdapMapErrorToWin32 = NULL;
   ldap_init = NULL;
   ldap_sslinit = NULL;

   if ( m_hDll )
   {
      ldap_open = (LDAP_OPEN *)GetProcAddress(m_hDll,"ldap_openW");
      ldap_parse_result = (LDAP_PARSE_RESULT *)GetProcAddress(m_hDll,"ldap_parse_resultW");
      ldap_parse_page_control = (LDAP_PARSE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_parse_page_controlW");
      ldap_controls_free = (LDAP_CONTROLS_FREE*)GetProcAddress(m_hDll,"ldap_controls_freeW");
      ber_bvfree = (BER_BVFREE*)GetProcAddress(m_hDll,"ber_bvfree");
      ldap_first_entry = (LDAP_FIRST_ENTRY*)GetProcAddress(m_hDll,"ldap_first_entry");
      ldap_next_entry = (LDAP_NEXT_ENTRY*)GetProcAddress(m_hDll,"ldap_next_entry");
      ldap_value_free = (LDAP_VALUE_FREE*)GetProcAddress(m_hDll,"ldap_value_freeW");
      ldap_get_values = (LDAP_GET_VALUES*)GetProcAddress(m_hDll,"ldap_get_valuesW");
      ldap_create_page_control = (LDAP_CREATE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_create_page_controlW");
      ldap_search_ext_s = (LDAP_SEARCH_EXT_S*)GetProcAddress(m_hDll,"ldap_search_ext_sW");
      ldap_count_entries = (LDAP_COUNT_ENTRIES*)GetProcAddress(m_hDll,"ldap_count_entries");
      ldap_msgfree = (LDAP_MSGFREE*)GetProcAddress(m_hDll,"ldap_msgfree");
      ldap_modify_s = (LDAP_MODIFY_S*)GetProcAddress(m_hDll,"ldap_modify_sW");
      LdapGetLastError = (LDAPGETLASTERROR*)GetProcAddress(m_hDll,"LdapGetLastError");
      ldap_bind_sW = (LDAP_BIND*)GetProcAddress(m_hDll,"ldap_bind_sW");
      ldap_simple_bind_sW = (LDAP_SIMPLE_BIND*)GetProcAddress(m_hDll,"ldap_simple_bind_sW");
      ldap_unbind = (LDAP_UNBIND*)GetProcAddress(m_hDll,"ldap_unbind");
      ldap_connect = (LDAP_CONNECT *)GetProcAddress(m_hDll,"ldap_connect");
      ldap_get_option = (LDAP_GET_OPTION*)GetProcAddress(m_hDll,"ldap_get_option");
      ldap_set_option = (LDAP_SET_OPTION*)GetProcAddress(m_hDll,"ldap_set_option");
      LdapMapErrorToWin32 = (LDAPMAPERRORTOWIN32*)GetProcAddress(m_hDll,"LdapMapErrorToWin32");
      ldap_init = (LDAP_INIT *)GetProcAddress(m_hDll,"ldap_initW");
      ldap_sslinit = (LDAP_SSLINIT *)GetProcAddress(m_hDll,"ldap_sslinitW");
   }
   
}

CLdapConnection::~CLdapConnection()
{
   Close();
   if ( m_hDll )
   {
      FreeLibrary(m_hDll);
      ldap_open = NULL;
      ldap_parse_result = NULL;
      ldap_parse_page_control = NULL;
      ldap_controls_free = NULL;
      ber_bvfree = NULL;
      ldap_first_entry = NULL;
      ldap_next_entry = NULL;
      ldap_value_free = NULL;
      ldap_get_values = NULL;
      ldap_create_page_control = NULL;
      ldap_search_ext_s = NULL;
      ldap_count_entries = NULL;
      ldap_msgfree = NULL;
      ldap_modify_s = NULL;
      LdapGetLastError = NULL;
      ldap_bind_sW = NULL;
      ldap_unbind = NULL;
      ldap_simple_bind_sW = NULL;
      ldap_connect = NULL;
      LdapMapErrorToWin32 = NULL;
      ldap_init = NULL;
      ldap_sslinit = NULL;
   }
}


void CLdapConnection::SetCredentials(WCHAR const * domain, WCHAR const * user, WCHAR const * pwd)
{
    WCHAR creds[LEN_Account + LEN_Domain + 6];
    
    // set the following for the simple bind
    swprintf(creds,L"cn=%ls,cn=%ls",(WCHAR*)user,(WCHAR*)domain);    
    safecopy(m_credentials,creds);
    safecopy(m_password,pwd);

    // set the following for using SSPI
    m_creds.User = const_cast<WCHAR*>(user);
    m_creds.UserLength = (user == NULL) ? 0 : wcslen(user);
    m_creds.Password = NULL;
    m_creds.PasswordLength = 0;
    m_creds.Domain = const_cast<WCHAR*>(domain);
    m_creds.DomainLength = (domain == NULL) ? 0 : wcslen(domain);
    m_creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
}

DWORD  CLdapConnection::Connect(WCHAR const * server, ULONG port = LDAP_PORT)
{
    DWORD                     rc = 0;
    safecopy(m_exchServer,server);

    //  m_LD = CLdapConnection::ldap_open(m_exchServer,LDAP_SSL_PORT);
    //  replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
    //  flag so that the following ldap calls (i.e. ldap_bind) will not need to 
    //  unnecessarily query for the domain controller

    if (m_LD)
        CLdapConnection::ldap_unbind(m_LD);
    
    m_LD = CLdapConnection::ldap_init(m_exchServer,port);

    if (!m_LD)
    {
        rc = CLdapConnection::LdapGetLastError();
        rc = CLdapConnection::LdapMapErrorToWin32(rc);
    }
    else
    {
        ULONG   flags = 0;

        //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
        //ldap_open will not need to unnecessarily query for the domain controller
        flags = PtrToUlong(LDAP_OPT_ON); 
        rc = ldap_set_option(m_LD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

        if (!rc)
        {
            flags = LDAP_VERSION3;
            rc = ldap_set_option(m_LD,LDAP_OPT_VERSION, &flags);
        }

        if (!rc)
            rc = ldap_connect(m_LD,NULL);

        if (!rc)
        {
            if (m_creds.User != NULL)
            {
                //
                // Retrieve specified password from LSA secret. As credentials have been specified the
                // password is required therefore if unable to retrieve password an error is returned.
                //

                WCHAR szPassword[LEN_Password];

                rc = RetrievePassword(m_password, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

                if (rc == ERROR_SUCCESS)
                {
                    m_creds.Password = szPassword;
                    m_creds.PasswordLength = wcslen(szPassword);

                    // use full credential and try only SSPI here and it will fall back on NTLM
                    rc = CLdapConnection::ldap_bind_sW(m_LD,NULL,(PWCHAR)&m_creds,LDAP_AUTH_SSPI);

                    if (rc)
                    {
                        rc = CLdapConnection::LdapMapErrorToWin32(rc);
                    }

                    m_creds.PasswordLength = 0;
                    m_creds.Password = NULL;

                    SecureZeroMemory(szPassword, sizeof(szPassword));
                }
            }
            else
            {
                // use NULL credential and try only SSPI here and it will fall back on NTLM
                rc = CLdapConnection::ldap_bind_sW(m_LD,NULL,NULL,LDAP_AUTH_SSPI);

                if (rc)
                {
                    rc = CLdapConnection::LdapMapErrorToWin32(rc);
                }
            }
        }
        else
        {
            rc = CLdapConnection::LdapMapErrorToWin32(rc);
        }
    }

    return rc;
}

DWORD  CLdapConnection::SSLConnect(WCHAR const * server, BOOL *sslEnabled, ULONG port)
{
    DWORD                     rc = 0;
    safecopy(m_exchServer,server);
    *sslEnabled = FALSE;

    //  m_LD = CLdapConnection::ldap_open(m_exchServer,LDAP_SSL_PORT);
    //  replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
    //  flag so that the following ldap calls (i.e. ldap_bind) will not need to 
    //  unnecessarily query for the domain controller

    if (m_LD)
        CLdapConnection::ldap_unbind(m_LD);
        
    m_LD = CLdapConnection::ldap_sslinit(m_exchServer,port,1);

    if (!m_LD)
    {
        rc = CLdapConnection::LdapGetLastError();
        rc = CLdapConnection::LdapMapErrorToWin32(rc);
    }
    else
    {
   
        ULONG   flags = 0;

        //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
        //ldap_open will not need to unnecessarily query for the domain controller
        flags = PtrToUlong(LDAP_OPT_ON); 
        rc = ldap_set_option(m_LD, LDAP_OPT_AREC_EXCLUSIVE, (void*)&flags);

        if (!rc)
        {
            flags = LDAP_VERSION3;
            rc = ldap_set_option(m_LD,LDAP_OPT_VERSION,&flags);
            if (!rc)
            {
                // we need to check whether SSL is truly enabled
                rc = ldap_get_option(m_LD,LDAP_OPT_SSL,&flags);
                if (!rc && flags == 0)
                    return rc;
            }
        }

        if (!rc)
            rc = ldap_connect(m_LD,NULL);

        if (!rc)
        {
            if (m_creds.User != NULL)
            {
                //
                // Retrieve specified password from LSA secret. As credentials have been specified the
                // password is required therefore if unable to retrieve password an error is returned.
                //

                WCHAR szPassword[LEN_Password];

                rc = RetrievePassword(m_password, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

                if (rc == ERROR_SUCCESS)
                {
                    m_creds.Password = szPassword;
                    m_creds.PasswordLength = wcslen(szPassword);

                    // use full credential and try SSPI here and it will fall back on NTLM
                    rc = CLdapConnection::ldap_bind_sW(m_LD,NULL,(PWCHAR)&m_creds,LDAP_AUTH_SSPI);

                    if (rc)
                        // it is Ok to use simple bind here since we're protected by SSL
                        rc = CLdapConnection::ldap_simple_bind_sW(m_LD,m_credentials,szPassword);

                    if (rc)
                    {
                        rc = CLdapConnection::LdapMapErrorToWin32(rc);
                    }

                    m_creds.PasswordLength = 0;
                    m_creds.Password = NULL;

                    SecureZeroMemory(szPassword, sizeof(szPassword));
                }
            }
            else
            {
                // use NULL credential and try only SSPI here and it will fall back on NTLM
                rc = CLdapConnection::ldap_bind_sW(m_LD,NULL,NULL,LDAP_AUTH_SSPI);

                if (rc)
                {
                    rc = CLdapConnection::LdapMapErrorToWin32(rc);
                }
            }
        }
        else
        {
            rc = CLdapConnection::LdapMapErrorToWin32(rc);
        }
    }
    if (!rc)
        *sslEnabled = TRUE;

    return rc;
}

void   CLdapConnection::Close()
{
   if ( m_LD )
   {
      CLdapConnection::ldap_unbind(m_LD);
      m_LD = NULL;
   }
}

DWORD CLdapConnection::UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value)
{
   DWORD             rc = ERROR_NOT_FOUND;

   if ( m_LD )
   {
      LDAPMod         * mods[2];
      LDAPMod           mod1;
      WCHAR           * strVals[] = { const_cast<WCHAR*>(value),NULL };
      mods[0] = &mod1;

      mods[0]->mod_op = LDAP_MOD_REPLACE;
      mods[0]->mod_type = const_cast<WCHAR*>(property);
      mods[0]->mod_vals.modv_strvals = strVals;
      mods[1] = NULL;

      rc = CLdapConnection::ldap_modify_s(m_LD,const_cast<WCHAR*>(dn),mods);
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }

   return rc;
}

// Helper function for SidToString - converts one BYTE of the SID into a string representation
void 
   CLdapConnection::AddByteToString(
      WCHAR               ** string,      // i/o- pointer to current location in string
      BYTE                   value        // in - value (from SID) to add to the string
   )
{
   WCHAR                     hi,
                             lo;
   BYTE                      hiVal, 
                             loVal;

   loVal = value & 0x0F;
   hiVal = value & 0xF0;
   hiVal = hiVal >> 4;

   if  ( hiVal < 10 )
   {
      hi=L'0' + hiVal;
   }
   else
   {
      hi=L'A' + ( hiVal - 10 );
   }

   if ( loVal < 10 )
   {
      lo=L'0' + loVal;
   }
   else
   {
      lo=L'A' + (loVal - 10 );
   }
   swprintf(*string,L"%c%c",hi,lo);

   *string+=2;
}

BYTE                                          // ret- value for the digit, or 0 if value is not a valid hex digit
   CLdapConnection::HexValue(
      WCHAR                  value           // in - character representing a hex digit
   )
{
   BYTE                      val = 0;
   switch ( toupper((char)value) )
   {
   case L'1': val = 1; break;
   case L'2': val = 2; break;
   case L'3': val = 3; break;
   case L'4': val = 4; break;
   case L'5': val = 5; break;
   case L'6': val = 6; break;
   case L'7': val = 7; break;
   case L'8': val = 8; break;
   case L'9': val = 9; break;
   case L'A': val = 0xA; break;
   case L'B': val = 0xB; break;
   case L'C': val = 0xC; break;
   case L'D': val = 0xD; break;
   case L'E': val = 0xE; break;
   case L'F': val = 0xF; break;
   }
   return val;
}


BOOL                                         // ret- 0=success, or ERROR_INSUFFICIENT_BUFFER 
   CLdapConnection::BytesToString(
      BYTE                 * pBytes,         // in - SID to represent as a string
      WCHAR                * sidString,      // out- buffer that will contain the 
      DWORD                  numBytes        // in - number of bytes in the buffer to copy
   )
{
   BOOL                      bSuccess = TRUE;
   WCHAR                   * curr = sidString;

   // add each byte of the SID to the output string
   for ( int i = 0 ; i < (int)numBytes ; i++)
   {  
      AddByteToString(&curr,pBytes[i]);
   }
   return bSuccess;
}

BOOL 
   CLdapConnection::StringToBytes(
      WCHAR          const * pString,     // in - string representing the data
      BYTE                 * pBytes       // out- binary representation of the data
   )
{
   BOOL                      bSuccess = TRUE;
   int                       len = UStrLen(pString) / 2;

   for ( int i = 0 ; i < len ; i++, pString += 2 )
   {
      // each byte is represented by 2 characters
      WCHAR                  str[3];
      BYTE                   hi,lo;

      safecopy(str,pString);
      
      hi = HexValue(str[0]);
      lo = HexValue(str[1]);

      pBytes[i] = ((hi << 4)+lo);
      
   }

   return bSuccess;
}

CLdapEnum::~CLdapEnum()
{
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }
}


DWORD 
   CLdapEnum::Open(
      WCHAR          const * query,          // in - query to execute
      WCHAR          const * basePoint,      // in - basepoint for query
      short                  scope,          // in - scope: 0=base only, 1=one level, 2=recursive
      long                   pageSize,       // in - page size to use for large searches
      int                    numAttributes,  // in - number of attributes to retrieve for each matching item
      WCHAR               ** attrs           // in - array of attribute names to retrieve for each matching item
   )
{
   // open and bind before calling this function
   ULONG                     result;
//   PLDAPSearch               searchBlock = NULL;
   PLDAPControl              serverControls[2];
//   l_timeval                 timeout = { 1000,1000 };
//   ULONG                     totalCount = 0;
   berval                    cookie1 = { 0, NULL };
//   DWORD                     numRead = 0;
 
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }

   LDAP                    * ld = m_connection.GetHandle();

   safecopy(m_query,query);
   safecopy(m_basepoint,basePoint);
   m_scope = scope;
   m_pageSize = pageSize;
   m_nAttributes = numAttributes;
   m_AttrNames = attrs;


   result = m_connection.ldap_create_page_control(ld,
                                     pageSize,
                                     &cookie1,
                                     FALSE, // is critical
                                     &serverControls[0]
                                    );

   serverControls[1] = NULL;

   result = m_connection.ldap_search_ext_s(ld,
                     m_basepoint,
                     m_scope,
                     m_query,
                     m_AttrNames,
                     FALSE,
                     serverControls,
                     NULL,
                     NULL,
                     0,
                     &m_message);
  
   if  ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;
      m_bOpen = TRUE;
   }

  
   return m_connection.LdapMapErrorToWin32(result);
}

DWORD 
   CLdapEnum::Next(
      PWCHAR              ** ppAttrs        // out- array of values for the next matching item
   )
{
   DWORD                     rc = 0;

   if ( ! m_bOpen )
   {
      rc = ERROR_NOT_FOUND;
   }
   else
   {
      if ( m_nReturned > m_nCurrent )
      {
         // return the next entry from the current page
         return GetNextEntry(ppAttrs);
      }
      else 
      {
         // see if there are more pages of results to get
         rc = GetNextPage();
         if (! rc )
         {
            return GetNextEntry(ppAttrs);
         }
      }


   }
   return rc;
}

void CLdapEnum::FreeData(WCHAR ** values)
{
   for ( int i = 0 ; m_AttrNames[i] ; i++ )
   {
      if ( values[i] )
      {
         delete [] values[i];
         values[i] = NULL;
      }
   }
   delete [] values;
}

DWORD 
   CLdapEnum::GetNextEntry(
      PWCHAR              ** ppAttrs
   )
{
   DWORD                     rc = 0;
   WCHAR                  ** pValues = new PWCHAR[m_nAttributes+1];

   if (!pValues)
      return ERROR_NOT_ENOUGH_MEMORY;

   if ( m_nCurrent == 0 )
   {

      m_currMsg = m_connection.ldap_first_entry(m_connection.GetHandle(),m_message);
   }
   else
   {
      m_currMsg = m_connection.ldap_next_entry(m_connection.GetHandle(),m_currMsg);
      
   }
   if ( m_currMsg )
   {

      int curr;

      for ( curr = 0 ; m_AttrNames[curr] ; curr++ )
      {
         pValues[curr] = NULL;

         WCHAR ** allvals = m_connection.ldap_get_values(m_connection.GetHandle(),m_currMsg,m_AttrNames[curr] );
         if ( allvals )
         {
            try
            {
            pValues[curr] = new WCHAR[UStrLen(allvals[0])+1];
            }
            catch (...)
            {
			   for (int j=0; j<curr; j++)
			   {
			      delete pValues[j];
			   }
			   delete pValues;
               throw;
			}


		    if (!(pValues[curr]))
			{
			   for (int j=0; j<curr; j++)
			   {
			      delete pValues[j];
			   }
			   delete pValues;
               return ERROR_NOT_ENOUGH_MEMORY;
			}


            UStrCpy(pValues[curr],allvals[0]);
            m_connection.ldap_value_free(allvals);
            allvals =NULL;
         }
      }
      
   }
   (*ppAttrs) = pValues;
   m_nCurrent++;
   return rc;
}

DWORD 
   CLdapEnum::GetNextPage()
{
   ULONG                     result = 0;
   LDAP                    * ld = m_connection.GetHandle();
   berval                  * currCookie = NULL;
//   berval                  * cookie2 = NULL;
//   WCHAR                   * matched = NULL;
   PLDAPControl            * currControls = NULL;
   ULONG                     retcode = 0;    
//   PLDAPControl            * clientControls = NULL;
//   WCHAR                   * errMsg = NULL;
   PLDAPControl              serverControls[2];
   
 
   
   // Get the server control from the message, and make a new control with the cookie from the server
   result = m_connection.ldap_parse_result(ld,m_message,&retcode,NULL,NULL,NULL,&currControls,FALSE);
   m_connection.ldap_msgfree(m_message);
   m_message = NULL;
   if ( ! result )
   {
      result = m_connection.ldap_parse_page_control(ld,currControls,&m_totalCount,&currCookie);
      // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are 
      // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will 
      // cause us to start over at the beginning of the search results.

   }
   if ( ! result )
   {
      if ( currCookie->bv_len == 0 && currCookie->bv_val == 0 )
      {
         // under Exchange 5.5, SP 2, this means we're at the end of the results.
         // if we pass in this cookie again, we will start over at the beginning of the search results.
         result = LDAP_CONTROL_NOT_FOUND;
      }
      
      serverControls[0] = NULL;
      serverControls[1] = NULL;
      if ( ! result )
      {
         result = m_connection.ldap_create_page_control(ld,
                                 m_pageSize,
                                 currCookie,
                                 FALSE,
                                 serverControls);
      }
      m_connection.ldap_controls_free(currControls);
      currControls = NULL;
      m_connection.ber_bvfree(currCookie);
      currCookie = NULL;
   }

   // continue the search with the new cookie
   if ( ! result )
   {
      result = m_connection.ldap_search_ext_s(ld,
            m_basepoint,
            m_scope,
            m_query,
            m_AttrNames,
            FALSE,
            serverControls,
            NULL,
            NULL,
            0,
            &m_message);

      if ( result && result != LDAP_CONTROL_NOT_FOUND )
      {
         // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results 
         // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there 
         // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page 
         // control from the search results).
         
      }
   }
   if ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;

   }
   return m_connection.LdapMapErrorToWin32(result);
}


void
GetLDAPPort(
	  DWORD                    * LDAPPort,
	  DWORD                    * SSLPort
	)
{
    TRegKey admtRegKey;
    DWORD rc;

    // assign the default values
    *LDAPPort = LDAP_PORT;
    *SSLPort = LDAP_SSL_PORT;
    
    // get ADMT key
    rc = admtRegKey.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
    if (rc == ERROR_SUCCESS)
    {
        DWORD portNumber;
        rc = admtRegKey.ValueGetDWORD(REGVAL_EXCHANGE_LDAP_PORT, &portNumber);
        if (rc == ERROR_SUCCESS)
        {
            *LDAPPort = portNumber;
        }
        else
        {
            err.MsgWrite(ErrW,
                          DCT_MSG_UNABLE_TO_READ_EXCHANGE_LDAP_PORT_SSD,
                          REGVAL_EXCHANGE_LDAP_PORT,
                          GET_STRING(IDS_HKLM_DomainAdmin_Key),
                          LDAP_PORT);
        }

        rc = admtRegKey.ValueGetDWORD(REGVAL_EXCHANGE_SSL_PORT, &portNumber);
        if (rc == ERROR_SUCCESS)
        {
            *SSLPort = portNumber;
        }
        else
        {
            err.MsgWrite(ErrW,
                          DCT_MSG_UNABLE_TO_READ_EXCHANGE_SSL_PORT_SSD,
                          REGVAL_EXCHANGE_SSL_PORT,
                          GET_STRING(IDS_HKLM_DomainAdmin_Key),
                          LDAP_SSL_PORT);
        }
    }
    else
    {
        err.MsgWrite(ErrW,
                      DCT_MSG_UNABLE_TO_READ_EXCHANGE_LDAP_PORT_SSD,
                      REGVAL_EXCHANGE_LDAP_PORT,
                      GET_STRING(IDS_HKLM_DomainAdmin_Key),
                      LDAP_PORT);
        err.MsgWrite(ErrW,
                      DCT_MSG_UNABLE_TO_READ_EXCHANGE_SSL_PORT_SSD,
                      REGVAL_EXCHANGE_SSL_PORT,
                      GET_STRING(IDS_HKLM_DomainAdmin_Key),
                      LDAP_SSL_PORT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\err.cpp ===
//#pragma title( "Err.cpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#ifndef WIN16_VERSION
   #include <lm.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <stdarg.h>
#include <share.h>
#include <time.h>
#include <rpc.h>
#include <rpcdce.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include <ResStr.h>
#include "TReg.hpp"

#define  TERR_MAX_MSG_LEN  (2000)
#define  BYTE_ORDER_MARK   (0xFEFF)

TCriticalSection csLogError;

TError::TError(
      int                    displevel    ,// in -mimimum severity level to display
      int                    loglevel     ,// in -mimimum severity level to log
      WCHAR          const * filename     ,// in -file name of log (NULL if none)
      int                    logmode      ,// in -0=replace, 1=append
      int                    beeplevel     // in -min error level for beeping
   )
{
   lastError = 0;
   maxError = 0;
   logLevel = loglevel;
   dispLevel = displevel;
   logFile = INVALID_HANDLE_VALUE;
   beepLevel = beeplevel;
   bWriteOnCurPos = FALSE;
   LogOpen(filename, logmode, loglevel);
}


TError::~TError()
{
   LogClose();
}

// Closes any existing open logFile and opens a new log file if the fileName is
// not null.  If it is a null string, then a default fileName of "Temp.log" is
// used.
BOOL
   TError::LogOpen(
      WCHAR           const * fileName ,// in -name of file including any path
      int                     mode     ,// in -0=overwrite, 1=append
      int                     level    ,// in -minimum level to log
      bool                   bBeginNew  // in -begin a new log file
   )
{
   BOOL                       retval=TRUE;

   if ( logFile != INVALID_HANDLE_VALUE )
   {
      CloseHandle(logFile);
      logFile = INVALID_HANDLE_VALUE;
   }

   if ( fileName && fileName[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(fileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);

         if (bBeginNew)
         {
            // rename existing log file

            // get next sequence number from registry
            DWORD dwSequence = 1;
            static WCHAR c_szValueName[] = L"LogSeqNum";
            TRegKey key(GET_STRING(IDS_HKLM_DomainAdmin_Key));
            key.ValueGetDWORD(c_szValueName, &dwSequence);

            // split path components
            WCHAR szPath[_MAX_PATH];
            WCHAR szDrive[_MAX_DRIVE];
            WCHAR szDir[_MAX_DIR];
            WCHAR szFName[_MAX_FNAME];
            WCHAR szExt[_MAX_EXT];
            _wsplitpath(fileName, szDrive, szDir, szFName, szExt);

            // find name for backup that isn't already used...

            for (bool bFoundName = false; bFoundName == false; dwSequence++)
            {
               // generate backup name using the sequence number
               WCHAR szFNameSeq[_MAX_FNAME];
               wsprintf(szFNameSeq, L"%s %04lu", szFName, dwSequence);

               // make path from path components
               _wmakepath(szPath, szDrive, szDir, szFNameSeq, szExt);

               // check if file exists
               WIN32_FIND_DATA fd;
               HANDLE hFind = FindFirstFile(szPath, &fd);

               if (hFind == INVALID_HANDLE_VALUE)
               {
                  DWORD dwError = GetLastError();

                  if (dwError == ERROR_FILE_NOT_FOUND)
                  {
                     bFoundName = true;
                  }
               }
               else
               {
                  FindClose(hFind);
               }
            }

            if (bFoundName)
            {
               // attempt to rename file
               if (MoveFile(fileName, szPath))
               {
                  // save next sequence number in registry
                  key.ValueSetDWORD(c_szValueName, dwSequence);
               }
               else
               {
                  bExisted = TRUE;
               }
            }

            if (!bExisted)
            {
               // get log history value from registry

               TRegKey keyHistory(GET_STRING(IDS_HKLM_DomainAdmin_Key));

               DWORD dwHistory = 20;
               static WCHAR c_szValueName[] = L"LogHistory";

               if (keyHistory.ValueGetDWORD(c_szValueName, &dwHistory) == ERROR_FILE_NOT_FOUND)
               {
                  keyHistory.ValueSetDWORD(c_szValueName, dwHistory);
               }

               keyHistory.Close();

               if (dwSequence > dwHistory)
               {
                  DWORD dwMinimum = dwSequence - dwHistory;

                  // generate migration log path specification

                  WCHAR szFNameSpec[_MAX_FNAME];
                  wsprintf(szFNameSpec, L"%s *", szFName);
                  _wmakepath(szPath, szDrive, szDir, szFNameSpec, szExt);

                  // for each migration older than minimum

                  WIN32_FIND_DATA fd;

                  HANDLE hFind = FindFirstFile(szPath, &fd);

                  if (hFind != INVALID_HANDLE_VALUE)
                  {
                     do
                     {
                        DWORD dwFileSequence;

                        if (swscanf(fd.cFileName, L"%*s %lu", &dwFileSequence) == 1)
                        {
                           // if file sequence less than minimum to keep...

                           if (dwFileSequence < dwMinimum)
                           {
                              // delete file
                              WCHAR szDeleteName[_MAX_FNAME];
                              _wsplitpath(fd.cFileName, 0, 0, szDeleteName, 0);
                              WCHAR szDeletePath[_MAX_PATH];
                              _wmakepath(szDeletePath, szDrive, szDir, szDeleteName, szExt);
                              DeleteFile(szDeletePath);
                           }
                        }
                     }
                     while (FindNextFile(hFind, &fd));

                     FindClose(hFind);
                  }
               }
            }

            key.Close();
         }
         else
         {
            // overwrite or append to existing log file

            bExisted = TRUE;
         }
      }

      logFile = CreateFile(fileName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           bExisted ? OPEN_EXISTING : CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
      if ( logFile == INVALID_HANDLE_VALUE )
      {
         retval = FALSE;
      }
      else
      {
         // the append case
         if (mode == 1)
         {
            if (SetFilePointer(logFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
                retval = FALSE;
         }

         // if it is a new file or in the overwrite mode, we write the
         // byte order mark into it
         if (retval && (!bExisted || mode == 0) )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            DWORD nWritten;
            if (!WriteFile(logFile, &x, sizeof(x), &nWritten, NULL))
                retval = FALSE;
         }

      }
   }

   logLevel = level;

   return retval;
}

DWORD TError::ExtendSize(DWORD dwNumOfBytes)
{
    DWORD rc = ERROR_SUCCESS;
    const int size = 4096;       // we write in 4K chunk
    BYTE* buffer;               // the buffer used to initialize the stream
    DWORD orig;                // the starting file pointer

    SetLastError(ERROR_SUCCESS);

    // to extend by 0 byte, we don't need to do anything
    if (dwNumOfBytes > 0)
    {
        // get the current file pointer
        if ((orig = SetFilePointer(logFile, 0, NULL, FILE_CURRENT)) != INVALID_SET_FILE_POINTER)
        {
            buffer = new BYTE[size];
            if (buffer != NULL)
            {
                memset((void*)buffer, 0, size);
                // seek forward dwNumOfBytes bytes, set the end of file and
                // then come back to the current file pointer
                if (SetFilePointer(logFile, dwNumOfBytes, NULL, FILE_CURRENT) != INVALID_SET_FILE_POINTER
                    && SetEndOfFile(logFile)
                    && SetFilePointer(logFile, orig, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
                {
                    // initialize the buffer
                    DWORD nWritten = size;
                    while (nWritten > 0 && dwNumOfBytes > 0)
                    {
                        if (!WriteFile(logFile,
                                      (void*)buffer,
                                      (dwNumOfBytes > size) ? size : dwNumOfBytes,
                                      &nWritten,
                                      NULL))
                        {
                            // if WriteFile failed, stop writing
                            break;
                        }
                        dwNumOfBytes -= nWritten;
                    }

                    // if dwNumOfBytes of bytes are written, we flush the file buffer
                    if (dwNumOfBytes == 0)
                    {
                        FlushFileBuffers(logFile);
                    }
                }
                
                rc = GetLastError();  // we catch any error code here
            }
            else
                rc = ERROR_OUTOFMEMORY;

            // clean up
            if (buffer)
                delete[] buffer;

            // we always try to restore the file pointer
            if (SetFilePointer(logFile, orig, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER
                && rc == ERROR_SUCCESS)
            {
                // we only need to get the error if we didn't fail before
                rc = GetLastError();
            }

        }
        else
            rc = GetLastError();

    }
    
    return rc;
}

//-----------------------------------------------------------------------------
// Writes formatted message to log file and flushes buffers
//-----------------------------------------------------------------------------
void TError::LogWrite(WCHAR const * msg)
{
    csLogError.Enter();
    
    WCHAR                     sTime[32];
    static WCHAR              sTemp[TERR_MAX_MSG_LEN];
    DWORD                     size = sizeof(sTemp) / sizeof(sTemp[0]);

    gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime );
    _snwprintf(sTemp, size - 2, L"%s %s", sTime, msg);  // leave room for "\r\n"
    sTemp[size - 3] = L'\0';  // make sure the string terminates
    DWORD dwLen = wcslen(sTemp);

    // Get rid of the <CR> from the end of the message because it causes things
    // to run together in the logs
    if ( sTemp[dwLen-1] == 0x0d )
        sTemp[dwLen-1] = 0x00;
    dwLen = wcslen(sTemp);
    wcscpy(&sTemp[dwLen], L"\r\n");
    dwLen = wcslen(sTemp);

    if ( logFile != INVALID_HANDLE_VALUE )
    {
        // make sure only one write at a time in the process
        criticalSection.Enter();
        BOOL bCanWrite = TRUE;

        if (!bWriteOnCurPos)
        {
            if (SetFilePointer(logFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
                bCanWrite = FALSE;
        }

        if (bCanWrite)
        {
            if (WriteFile(logFile, sTemp, dwLen * sizeof(WCHAR), &size, NULL))
                FlushFileBuffers(logFile);
        }
        
        criticalSection.Leave();
    }

    csLogError.Leave();
}

//-----------------------------------------------------------------------------
// Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   )
{
    csLogError.Enter();
    
    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    va_list                   argPtr;

    va_start(argPtr, msg);
    _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
    suffix[DIM(suffix) - 1] = L'\0';
    va_end(argPtr);
    MsgProcess(num, suffix);

    csLogError.Leave();
}

#ifndef WIN16_VERSION
//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
    csLogError.Enter();
    
    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    va_list                   argPtr;
    int                       len;

    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return;

    va_start(argPtr, msg);
    len = _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);

    // append the system message for the lastRc at the end.
    if ( len < DIM(suffix) - 1 )
    {
        ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
    }
    suffix[DIM(suffix) - 1] = L'\0';
    va_end(argPtr);
    MsgProcess(num, suffix);

    csLogError.Leave();
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
    csLogError.Enter();
    
    static WCHAR              suffix[TERR_MAX_MSG_LEN];
    va_list                   argPtr;
    int                       len;
    DWORD                     lastRc = GetLastError();

    // When an error occurs while in a constructor for a global object,
    // the TError object may not yet exist.  In this case, "this" is zero
    // and we gotta get out of here before we generate a protection exception.

    if ( !this )
        return;

    va_start( argPtr, msg );
    len = _vsnwprintf( suffix, DIM(suffix) - 1, msg, argPtr );

    // append the system message for the lastRc at the end.
    if ( len < DIM(suffix) - 1 )
    {
        ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
    }
    suffix[DIM(suffix) - 1] = L'\0';
    va_end(argPtr);
    MsgProcess(num, suffix);

    csLogError.Leave();
}

#endif

//-----------------------------------------------------------------------------
// Error message format, display and exception processing function
//-----------------------------------------------------------------------------
void __stdcall
   TError::MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   )
{
    csLogError.Enter();
    
    static WCHAR               fullmsg[TERR_MAX_MSG_LEN];
    struct
    {
        USHORT                 frequency;    // audio frequency
        USHORT                 duration;     // duration in mSec
    } audio[] = {{ 300,  20},{ 500,  50},{ 700, 100},
                        { 800, 200},{1000, 300},{1500, 400},
                        {2500, 750},{2500,1000},{2500,1000}};

    if ( num >= 0 )
        level = num / 10000;                 // 10000's position of error number
    else
        level = -1;

    if ( level <= 0 )
    {
        wcsncpy(fullmsg, str, DIM(fullmsg));
        fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
    }
    else
    {
        if ( num > maxError )
            maxError = num;
        _snwprintf(fullmsg, DIM(fullmsg), L"%s%1d:%04d %-s", (level <= 1) ? L"WRN" : L"ERR", level, num % 10000, str);
        fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
    }

    lastError = num;

    if ( level >= beepLevel )
        Beep(audio[level].frequency, audio[level].duration);

    if ( level >= logLevel )
        LogWrite(fullmsg);

    if ( level > 4 )
    {
        exit(level);
    }

    csLogError.Leave();
}

//-----------------------------------------------------------------------------
// Return text for error code
//-----------------------------------------------------------------------------

WCHAR *        
   TError::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   static HMODULE            hNetMsg = NULL;
   DWORD                     rc;
   WCHAR                   * pMsg;

   msg[0] = '\0'; // force to null

   if ( code >= NERR_BASE && code < MAX_NERR )
   {
      if ( !hNetMsg )
         hNetMsg = LoadLibrary(L"netmsg.dll");
      rc = 1;
   }
   else
   {
      rc = DceErrorInqText( code, msg );
      // Change any imbedded CR or LF to blank.
      for ( pMsg = msg;
            *pMsg;
            pMsg++ )
      {
         if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
      }
      // Remove trailing blanks
      for ( pMsg--;
            pMsg >= msg;
            pMsg-- )
      {
         if ( *pMsg == L' ' )
            *pMsg = L'\0';
         else
            break;
      }
   }
   if ( rc )
   {
      if ( code >= NERR_BASE && code < MAX_NERR && hNetMsg )
      {
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        hNetMsg,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
      else
      {
         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        NULL,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
   }
   return msg;
}

// Err.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\hrmsg.cpp ===
/******************************************************************
 *                                                                *
 * CPP file for common error handling functions.                  *
 *                                                                *
 ******************************************************************/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "HrMsg.h"
#include <stdio.h>
#include <stdarg.h>


namespace HrMsg_cpp
{

void __stdcall AdmtThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription);

}

using namespace HrMsg_cpp;


//---------------------------------------------------------------------------
// GetError Helper Function
//---------------------------------------------------------------------------

_com_error GetError(HRESULT hr)
{
   _com_error ce(hr);

   IErrorInfo* pErrorInfo = NULL;

   if (GetErrorInfo(0, &pErrorInfo) == S_OK)
   {
      ce = _com_error(FAILED(hr) ? hr : E_FAIL, pErrorInfo);
   }
   else
   {
      ce = _com_error(FAILED(hr) ? hr : S_OK);
   }

   return ce;
}

//-----------------------------------------------------------------------------
// Return text for hresults
//-----------------------------------------------------------------------------
_bstr_t __stdcall HResultToText2(HRESULT hr)
{
	_bstr_t bstrError;

	LPTSTR pszError = NULL;

	try
	{
		switch (HRESULT_FACILITY(hr))
		{
		//	case FACILITY_NULL:        //  0
		//	case FACILITY_RPC:         //  1
		//	case FACILITY_DISPATCH:    //  2
		//	case FACILITY_STORAGE:     //  3
			case FACILITY_ITF:         //  4
			{
				HMODULE hModule = LoadLibrary(_T("MSDAERR.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
			case FACILITY_WIN32:       //  7
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		//	case FACILITY_WINDOWS:     //  8
		//	case FACILITY_SSPI:        //  9
		//	case FACILITY_SECURITY:    //  9
			case FACILITY_CONTROL:     // 10
			{
				HMODULE hModule = LoadLibrary(_T("MSADER15.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
		//	case FACILITY_CERT:        // 11
		//	case FACILITY_INTERNET:    // 12
		//	case FACILITY_MEDIASERVER: // 13
			case FACILITY_MSMQ:        // 14
			{
				HMODULE hModule = LoadLibrary(_T("MQUTIL.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
		//	case FACILITY_SETUPAPI:    // 15
		//	case FACILITY_SCARD:       // 16
		//	case FACILITY_COMPLUS:     // 17
		//	case FACILITY_AAF:         // 18
		//	case FACILITY_URT:         // 19
		//	case FACILITY_ACS:         // 20
			default:
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		}

		if (pszError)
		{
			size_t cch = _tcslen(pszError);

			if ((cch > 1) && (pszError[cch - 1] == _T('\n')))
			{
				pszError[cch - 1] = 0;

				if (pszError[cch - 2] == _T('\r'))
				{
					pszError[cch - 2] = 0;
				}
			}

			bstrError = pszError;
		}
		else
		{
			_TCHAR szError[32];
			_stprintf(szError, _T("Unknown error 0x%08lX."), hr);

			bstrError = szError;
		}
	}
	catch (...)
	{
		;
	}

	if (pszError)
	{
		LocalFree((HLOCAL)pszError);
	}

    return bstrError;
}


_bstr_t __stdcall HResultToText(HRESULT hr)
{
	return GetError(hr).Description();
}


//---------------------------------------------------------------------------
// AdmtThrowError
//
// Generates formatted error description and generates exception.
//
// 2000-??-?? Mark Oluper - initial
// 2001-02-13 Mark Oluper - moved to commonlib
//---------------------------------------------------------------------------

void __cdecl AdmtThrowError(_com_error ce, HINSTANCE hInstance, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(hInstance, uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, sizeof(szDescription) / sizeof(szDescription[0]), szFormat, args);
		szDescription[sizeof(szDescription) / sizeof(szDescription[0]) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(ce, szDescription);
}


void __cdecl AdmtThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, sizeof(szDescription) / sizeof(szDescription[0]), pszFormat, args);
		szDescription[sizeof(szDescription) / sizeof(szDescription[0]) - 1] = _T('\0');
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(ce, szDescription);
}


namespace HrMsg_cpp
{


//---------------------------------------------------------------------------
// AdmtThrowErrorImpl
//
// Concatenates rich error information and throws exception.
//
// 2000-??-?? Mark Oluper - initial
// 2001-02-13 Mark Oluper - moved to commonlib
//---------------------------------------------------------------------------

void __stdcall AdmtThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription)
{
	_bstr_t bstrNewDescription;

	try
	{
		bstrNewDescription = pszDescription;

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				bstrNewDescription += _T(" : ");
			}

			bstrNewDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				if (bstrSource.length() > 0)
				{
					bstrNewDescription += _T(": ");
				}
				else
				{
					bstrNewDescription += _T(" ");
				}
			}

			bstrNewDescription += bstrOldDescription;
		}
		else
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (bstrNewDescription.length() > 0)
				{
					bstrNewDescription += _T(" : ");
				}

				bstrNewDescription += pszErrorMessage;
			}
		}
	}
	catch (...)
	{
		;
	}

	ICreateErrorInfoPtr spCreateErrorInfo;
	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
	//	LPOLESTR pszProgId;

	//	if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
	//	{
	//		spCreateErrorInfo->SetSource(pszProgId);
	//		CoTaskMemFree(pszProgId);
	//	}
	//	else
	//	{
			spCreateErrorInfo->SetSource(L"");
	//	}

	//	spCreateErrorInfo->SetGUID(iid);
		spCreateErrorInfo->SetGUID(GUID_NULL);
		spCreateErrorInfo->SetDescription(bstrNewDescription);
		spCreateErrorInfo->SetHelpFile(L"");
		spCreateErrorInfo->SetHelpContext(0);
	}

	_com_raise_error(ce.Error(), IErrorInfoPtr(spCreateErrorInfo).Detach());
}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\htmlhelputil.cpp ===
#include <windows.h>

//----------------------------------------------------------------------------
// Function:   IsInWorkArea
//
// Synopsis:   Tests whether a help viewer window is in the work area.
//
// Arguments:
//   hwndHelpViewer:    the handle (HWND) to a help viewer window
//
// Returns:    TRUE if in the work area, otherwise, FALSE
//
// Modifies:   None.
//
//----------------------------------------------------------------------------

BOOL IsInWorkArea(HWND hwndHelpViewer)
{
    RECT rectHelpViewer;
    BOOL bIsInWorkArea = FALSE;
    if (GetWindowRect(hwndHelpViewer, &rectHelpViewer))
    {
        RECT rectWorkArea;
        if (SystemParametersInfo(SPI_GETWORKAREA, NULL, (PVOID)&rectWorkArea, NULL))
        {
            bIsInWorkArea = (rectHelpViewer.left >= rectWorkArea.left) && (rectHelpViewer.top >= rectWorkArea.top)
                                        && (rectHelpViewer.right <= rectWorkArea.right) && (rectHelpViewer.bottom <= rectWorkArea.bottom);
        }
    }

    return bIsInWorkArea;
}

//----------------------------------------------------------------------------
// Function:   PlaceInWorkArea
//
// Synopsis:   Place a help viewer in the work area.
//                  The width becomes 0.6 of original width.  The left margin is 0.2 of original width.
//                  The height becomes 0.7 of original height.  The top margin is 0.075 of original height.
//
// Arguments:
//   hwndHelpViewer:    the handle (HWND) to a help viewer
//
// Returns:    None.
//
// Modifies:   Modifies the window position and size as specified above.
//
//----------------------------------------------------------------------------

void PlaceInWorkArea(HWND hwndHelpViewer)
{
    RECT rectWorkArea;
    if (SystemParametersInfo(SPI_GETWORKAREA, NULL, (PVOID) &rectWorkArea, NULL))
    {
        FLOAT fOrigWidth = (FLOAT) (rectWorkArea.right - rectWorkArea.left);
        FLOAT fOrigHeight = (FLOAT) (rectWorkArea.bottom - rectWorkArea.top);
        FLOAT fHRatio = (FLOAT) 0.6;
        FLOAT fHMarginRatio = (FLOAT) ((1.0 - fHRatio) / 2.0);
        FLOAT fVRatio = (FLOAT) 0.7;
        FLOAT fVMarginRatio = (FLOAT) ((1.0 - fVRatio) / 4.0);
        int iWidth = (int) (fOrigWidth * fHRatio);
        int iHeight = (int) (fOrigHeight * fVRatio);
        int iLeft = (int) rectWorkArea.left + (int) (fOrigWidth * fHMarginRatio);
        int iTop = (int) rectWorkArea.top + (int) (fOrigHeight * fVMarginRatio);
        MoveWindow(hwndHelpViewer, iLeft, iTop, iWidth, iHeight, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\getdcname.cpp ===
#include <Windows.h>
#include <LM.h>
#include <DsRole.h>
#include <Ntdsapi.h>
#include "Common.hpp"
#include "EaLen.hpp"
#include "AdsiHelpers.h"
#include "GetDcName.h"


namespace
{

//-----------------------------------------------------------------------------
// CApi Class
//
// This template class wraps the logic for loading a library and retrieving
// a procedure address. It manages loading and unloading of the library.
//-----------------------------------------------------------------------------

template<class T>
class CApi
{
public:

    CApi(PCWSTR pszLibrary, PCSTR pszProcedure) :
        m_dwError(ERROR_SUCCESS),
        m_pApi(NULL)
    {
        m_hLibrary = LoadLibrary(pszLibrary);

        if (m_hLibrary)
        {
            m_pApi = (T) GetProcAddress(m_hLibrary, pszProcedure);

            if (m_pApi == NULL)
            {
                m_dwError = ::GetLastError();
            }
        }
        else
        {
            m_dwError = ::GetLastError();
        }
    }

    ~CApi()
    {
        if (m_hLibrary)
        {
            FreeLibrary(m_hLibrary);
        }
    }

    operator T()
    {
        return m_pApi;
    }

    DWORD GetLastError() const
    {
        return m_dwError;
    }

protected:

    DWORD m_dwError;
    HMODULE m_hLibrary;
    T m_pApi;
};

}

//
// Declare pointer to DsGetDcName API.
//

typedef DSGETDCAPI DWORD (WINAPI* PDSGETDCNAME)(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

typedef DWORD (WINAPI* PDSROLEGETPRIMARYDOMAININFORMATION)(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer 
);

typedef VOID (WINAPI* PDSROLEFREEMEMORY)(
    IN PVOID    Buffer
);

typedef NTDSAPI DWORD (WINAPI* PDSBIND)(LPCWSTR, LPCWSTR, HANDLE*);
typedef NTDSAPI DWORD (WINAPI* PDSUNBIND)(HANDLE*);
typedef NTDSAPI DWORD (WINAPI* PDSLISTROLES)(HANDLE, PDS_NAME_RESULTW*);
typedef NTDSAPI void (WINAPI* PDSFREENAMERESULT)(DS_NAME_RESULTW*);
typedef HRESULT (WINAPI* PADSGETOBJECT)(LPCWSTR, REFIID, VOID**);


//-----------------------------------------------------------------------------
// GetDcName4 Function
//
// Synopsis
// Retrieves the DNS and flat (NetBIOS) names of a domain controller in the
// specified domain.
//
// Note that this function is for use in code that may be loaded on NT4 or
// earlier machines. If code is only loaded on W2K or later machines then use
// GetDcName5 function instead.
//
// Arguments
// IN pszDomainName - the DNS or NetBIOS name of the domain or null which means
//    the domain that this machine belongs to
// IN ulFlags - DsGetDcName option flags
// OUT strNameDns - if available, the DNS name of a domain controller
// OUT strNameFlat - if available, the flat name of a domain controller
//
// Return Value
// A Win32 error code.
//-----------------------------------------------------------------------------

DWORD __stdcall GetDcName4(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strNameDns, _bstr_t& strNameFlat)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // Must load procedure address explicitly as this function
    // must be loadable in code that may be running on NT4 machines.
    //

    PDSGETDCNAME pDsGetDcName = NULL;

    HMODULE hNetApi32 = LoadLibrary(L"NetApi32.dll");

    if (hNetApi32)
    {
        pDsGetDcName = (PDSGETDCNAME)GetProcAddress(hNetApi32, "DsGetDcNameW");
    }

    //
    // If address of DsGetDcName function obtained then use
    // this API otherwise use NetGetDCName function.
    //

    if (pDsGetDcName)
    {
        ULONG ul = ulFlags & ~(DS_RETURN_DNS_NAME|DS_RETURN_FLAT_NAME);

        PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

        dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, ul, &pdciInfo);

        if (dwError == ERROR_SUCCESS)
        {
            if (pdciInfo->Flags & DS_DS_FLAG)
            {
                if (pdciInfo->Flags & DS_DNS_CONTROLLER_FLAG)
                {
                    strNameDns = pdciInfo->DomainControllerName;

                    NetApiBufferFree(pdciInfo);
                    pdciInfo = NULL;

                    dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, ul | DS_RETURN_FLAT_NAME, &pdciInfo);

                    if (dwError == ERROR_SUCCESS)
                    {
                        strNameFlat = pdciInfo->DomainControllerName;
                    }
                }
                else
                {
                    strNameFlat = pdciInfo->DomainControllerName;

                    NetApiBufferFree(pdciInfo);
                    pdciInfo = NULL;

                    dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, ul | DS_RETURN_DNS_NAME, &pdciInfo);

                    if (dwError == ERROR_SUCCESS)
                    {
                        strNameDns = pdciInfo->DomainControllerName;
                    }
                }
            }
            else
            {
                strNameDns = (LPCTSTR)NULL;
                strNameFlat = pdciInfo->DomainControllerName;
            }
        }

        if (pdciInfo)
        {
            NetApiBufferFree(pdciInfo);
        }
    }
    else
    {
        //
        // Retrieve name of primary domain controller for specified domain.
        // Cannot use NetGetAnyDCName because this function will only work
        // with trusted domains therefore must use NetGetDCName which
        // always returns the PDC name.
        //

        PWSTR pszName = NULL;

        dwError = NetGetDCName(NULL, pszDomainName, (LPBYTE*)&pszName);

        if (dwError == ERROR_SUCCESS)
        {
            strNameDns = (LPCTSTR)NULL;
            strNameFlat = pszName;
        }

        if (pszName)
        {
            NetApiBufferFree(pszName);
        }
    }

    if (hNetApi32)
    {
        FreeLibrary(hNetApi32);
    }

    return dwError;
}


//-----------------------------------------------------------------------------
// GetDcName5 Function
//
// Synopsis
// Retrieves the DNS and flat (NetBIOS) names of a domain controller in the
// specified domain.
//
// Note that this function is for use in code that is only loaded on W2K or
// later machines. If code may loaded on NT4 or earlier machines then use
// GetDcName4 function instead.
//
// Arguments
// IN pszDomainName - the DNS or NetBIOS name of the domain or null which means
//    the domain that this machine belongs to
// IN ulFlags - DsGetDcName option flags
// OUT strNameDns - if available, the DNS name of a domain controller
// OUT strNameFlat - if available, the flat name of a domain controller
//
// Return Value
// A Win32 error code.
//-----------------------------------------------------------------------------

DWORD __stdcall GetDcName5(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strNameDns, _bstr_t& strNameFlat)
{
    ULONG ul = ulFlags & ~(DS_RETURN_DNS_NAME|DS_RETURN_FLAT_NAME);

    PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

    DWORD dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, ul, &pdciInfo);

    if (dwError == ERROR_SUCCESS)
    {
        if (pdciInfo->Flags & DS_DS_FLAG)
        {
            if (pdciInfo->Flags & DS_DNS_CONTROLLER_FLAG)
            {
                strNameDns = pdciInfo->DomainControllerName;

                NetApiBufferFree(pdciInfo);
                pdciInfo = NULL;

                dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, ul | DS_RETURN_FLAT_NAME, &pdciInfo);

                if (dwError == ERROR_SUCCESS)
                {
                    strNameFlat = pdciInfo->DomainControllerName;
                }
            }
            else
            {
                strNameFlat = pdciInfo->DomainControllerName;

                NetApiBufferFree(pdciInfo);
                pdciInfo = NULL;

                dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, ul | DS_RETURN_DNS_NAME, &pdciInfo);

                if (dwError == ERROR_SUCCESS)
                {
                    strNameDns = pdciInfo->DomainControllerName;
                }
            }
        }
        else
        {
            strNameDns = (LPCTSTR)NULL;
            strNameFlat = pdciInfo->DomainControllerName;
        }
    }

    if (pdciInfo)
    {
        NetApiBufferFree(pdciInfo);
    }

    return dwError;
}


//----------------------------------------------------------------------------
// GetGlobalCatalogServer4 Function
//
// Synopsis
// Retrieves the name of a global catalog server for the specified domain.
//
// Arguments
// pszDomainName - the NetBIOS or DNS name of the domain
// strServer     - DNS name of global catalog server
//
// Return Value
// Win32 error code.
//----------------------------------------------------------------------------

DWORD __stdcall GetGlobalCatalogServer4(PCWSTR pszDomainName, _bstr_t& strServer)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // must load procedures explicitly as this component
    // must be loadable on Windows NT4 machines as well
    // even though this code is not used on remote agents
    //

    PDSGETDCNAME DsGetDcName = NULL;

    HMODULE hNetApi32 = LoadLibrary(L"NetApi32.dll");

    if (hNetApi32)
    {
        DsGetDcName = (PDSGETDCNAME)GetProcAddress(hNetApi32, "DsGetDcNameW");
    }
    else
    {
        dwError = GetLastError();
    }

    if (DsGetDcName)
    {
        //
        // retrieve name of domain controller for specified domain
        //

        PDOMAIN_CONTROLLER_INFO pdciDomain;

        dwError = DsGetDcName(
            NULL, pszDomainName, NULL, NULL,
            DS_DIRECTORY_SERVICE_REQUIRED|DS_RETURN_DNS_NAME,
            &pdciDomain
        );

        if (dwError == NO_ERROR)
        {
            //
            // retrieve name of global catalog domain controller for specified forest
            //

            PDOMAIN_CONTROLLER_INFO pdciForest;

            dwError = DsGetDcName(NULL, pdciDomain->DnsForestName, NULL, NULL, DS_GC_SERVER_REQUIRED, &pdciForest);

            if (dwError == NO_ERROR)
            {
                //
                // remove leading \\ so callers don't have to remove
                //

                PWSTR pszServer = pdciForest->DomainControllerName;

                if (pszServer && (pszServer[0] == L'\\') && (pszServer[1] == L'\\'))
                {
                    strServer = pszServer + 2;
                }
                else
                {
                    strServer = pszServer;
                }

                NetApiBufferFree(pdciForest);
            }

            NetApiBufferFree(pdciDomain);
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if (hNetApi32)
    {
        FreeLibrary(hNetApi32);
    }

    return dwError;
}


//----------------------------------------------------------------------------
// GetGlobalCatalogServer5 Function
//
// Synopsis
// Retrieves the name of a global catalog server for the specified domain.
//
// Arguments
// pszDomainName - the NetBIOS or DNS name of the domain
// strServer     - DNS name of global catalog server
//
// Return Value
// Win32 error code.
//----------------------------------------------------------------------------

DWORD __stdcall GetGlobalCatalogServer5(PCWSTR pszDomainName, _bstr_t& strServer)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // retrieve name of domain controller for specified domain
    //

    PDOMAIN_CONTROLLER_INFO pdciDomain;

    dwError = DsGetDcName(
        NULL, pszDomainName, NULL, NULL,
        DS_DIRECTORY_SERVICE_REQUIRED|DS_RETURN_DNS_NAME,
        &pdciDomain
    );

    if (dwError == NO_ERROR)
    {
        //
        // retrieve name of global catalog domain controller for specified forest
        //

        PDOMAIN_CONTROLLER_INFO pdciForest;

        dwError = DsGetDcName(NULL, pdciDomain->DnsForestName, NULL, NULL, DS_GC_SERVER_REQUIRED, &pdciForest);

        if (dwError == NO_ERROR)
        {
            //
            // remove leading \\ so callers don't have to remove
            //

            PWSTR pszServer = pdciForest->DomainControllerName;

            if (pszServer && (pszServer[0] == L'\\') && (pszServer[1] == L'\\'))
            {
                strServer = pszServer + 2;
            }
            else
            {
                strServer = pszServer;
            }

            NetApiBufferFree(pdciForest);
        }

        NetApiBufferFree(pdciDomain);
    }

    return dwError;
}


//-----------------------------------------------------------------------------
// GetDomainNames4 Function
//
// Synopsis
// Retrieves a domain's flat (NetBIOS) and DNS names given either form of the
// domain name.
//
// Arguments
// IN  pszDomainName     - either flat (NetBIOS) or DNS domain name
// OUT strFlatName - domain flat (NetBIOS) name
// OUT strDnsName  - domain DNS name
//
// ReturnValue
// The function returns DWORD Win32 error code. ERROR_SUCCESS is returned if
// names are retrieved successfully.
//-----------------------------------------------------------------------------

DWORD __stdcall GetDomainNames4(PCWSTR pszDomainName, _bstr_t& strFlatName, _bstr_t& strDnsName)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // must load procedures explicitly as this component
    // must be loadable on Windows NT4 machines as well
    // even though this code is not used on remote agents
    //
#if 0
    PDSROLEGETPRIMARYDOMAININFORMATION pDsRoleGetPrimaryDomainInformation = NULL;
    PDSROLEFREEMEMORY pDsRoleFreeMemory = NULL;

    HMODULE hNetApi32 = LoadLibrary(L"NetApi32.dll");

    if (hNetApi32)
    {
        pDsRoleGetPrimaryDomainInformation = (PDSROLEGETPRIMARYDOMAININFORMATION)GetProcAddress(hNetApi32, "DsRoleGetPrimaryDomainInformation");
        pDsRoleFreeMemory = (PDSROLEFREEMEMORY)GetProcAddress(hNetApi32, "DsRoleFreeMemory");
    }

    if (pDsRoleGetPrimaryDomainInformation && pDsRoleFreeMemory)
    {
        //
        // retrieve name of domain controller for specified domain
        // and then retrieve the domain's DNS and NetBIOS names
        //

        _bstr_t strDomainControllerName;

        DWORD dwError = GetDcName4(pszDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strDomainControllerName);

        if (dwError == NO_ERROR)
        {
	        PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

	        dwError = pDsRoleGetPrimaryDomainInformation(
                strDomainControllerName,
                DsRolePrimaryDomainInfoBasic,
                (BYTE**)&ppdib
            );

            if (dwError == NO_ERROR)
            {
                strDnsName = ppdib->DomainNameDns;
                strFlatName = ppdib->DomainNameFlat;

        	    pDsRoleFreeMemory(ppdib);
            }
        }
    }
#else
    strDnsName = (LPCTSTR)NULL;
    strFlatName = (LPCTSTR)NULL;

    PDSGETDCNAME pDsGetDcName = NULL;

    HMODULE hNetApi32 = LoadLibrary(L"NetApi32.dll");

    if (hNetApi32)
    {
        pDsGetDcName = (PDSGETDCNAME)GetProcAddress(hNetApi32, "DsGetDcNameW");
    }

    //
    // If address of DsGetDcName function obtained then use
    // this API otherwise use NetGetDCName function.
    //

    if (pDsGetDcName)
    {
        PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

        DWORD dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pdciInfo);

        if (dwError == ERROR_SUCCESS)
        {
            if (pdciInfo->Flags & DS_DS_FLAG)
            {
                if (pdciInfo->Flags & DS_DNS_DOMAIN_FLAG)
                {
                    strDnsName = pdciInfo->DomainName;

                    NetApiBufferFree(pdciInfo);
                    pdciInfo = NULL;

                    dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, DS_RETURN_FLAT_NAME, &pdciInfo);

                    if (dwError == ERROR_SUCCESS)
                    {
                        strFlatName = pdciInfo->DomainName;
                    }
                }
                else
                {
                    strFlatName = pdciInfo->DomainName;

                    NetApiBufferFree(pdciInfo);
                    pdciInfo = NULL;

                    dwError = pDsGetDcName(NULL, pszDomainName, NULL, NULL, DS_RETURN_DNS_NAME, &pdciInfo);

                    if (dwError == ERROR_SUCCESS)
                    {
                        strDnsName = pdciInfo->DomainName;
                    }
                }
            }
            else
            {
                strFlatName = pdciInfo->DomainName;
            }
        }

        if (pdciInfo)
        {
            NetApiBufferFree(pdciInfo);
        }
    }
    else
    {
        strFlatName = pszDomainName;
    }
#endif
    if (hNetApi32)
    {
        FreeLibrary(hNetApi32);
    }

    return dwError;
}


//-----------------------------------------------------------------------------
// GetDomainNames5 Function
//
// Synopsis
// Retrieves a domain's flat (NetBIOS) and DNS names given either form of the
// domain name.
//
// Arguments
// IN  pszName     - either flat (NetBIOS) or DNS domain name
// OUT strFlatName - domain flat (NetBIOS) name
// OUT strDnsName  - domain DNS name
//
// ReturnValue
// The function returns DWORD Win32 error code. ERROR_SUCCESS is returned if
// names are retrieved successfully.
//-----------------------------------------------------------------------------

DWORD __stdcall GetDomainNames5(PCWSTR pszDomainName, _bstr_t& strFlatName, _bstr_t& strDnsName)
{
#if 0
    //
    // Retrieve name of domain controller for specified domain
    // and then retrieve the domain's DNS and flat (NetBIOS) names.
    //

    _bstr_t strDomainControllerName;

    DWORD dwError = GetDcName5(pszDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strDomainControllerName);

    if (dwError == NO_ERROR)
    {
        PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

        dwError = DsRoleGetPrimaryDomainInformation(
            strDomainControllerName,
            DsRolePrimaryDomainInfoBasic,
            (PBYTE*)&ppdib
        );

        if (dwError == NO_ERROR)
        {
            strDnsName = ppdib->DomainNameDns;
            strFlatName = ppdib->DomainNameFlat;

            DsRoleFreeMemory(ppdib);
        }
    }

    return dwError;
#else
    strDnsName = (LPCTSTR)NULL;
    strFlatName = (LPCTSTR)NULL;

    PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

    DWORD dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pdciInfo);

    if (dwError == ERROR_SUCCESS)
    {
        if (pdciInfo->Flags & DS_DS_FLAG)
        {
            if (pdciInfo->Flags & DS_DNS_DOMAIN_FLAG)
            {
                strDnsName = pdciInfo->DomainName;

                NetApiBufferFree(pdciInfo);
                pdciInfo = NULL;

                dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, DS_RETURN_FLAT_NAME, &pdciInfo);

                if (dwError == ERROR_SUCCESS)
                {
                    strFlatName = pdciInfo->DomainName;
                }
            }
            else
            {
                strFlatName = pdciInfo->DomainName;

                NetApiBufferFree(pdciInfo);
                pdciInfo = NULL;

                dwError = DsGetDcName(NULL, pszDomainName, NULL, NULL, DS_RETURN_DNS_NAME, &pdciInfo);

                if (dwError == ERROR_SUCCESS)
                {
                    strDnsName = pdciInfo->DomainName;
                }
            }
        }
        else
        {
            strFlatName = pdciInfo->DomainName;
        }
    }

    if (pdciInfo)
    {
        NetApiBufferFree(pdciInfo);
    }

    return dwError;
#endif
}


//-----------------------------------------------------------------------------
// GetRidPoolAllocator Function
//
// Synopsis
// Retrieves the name of the domain controller in the domain that holds the
// RID master role. Both the DNS and NetBIOS names are returned.
//
// Arguments
// IN  pszName     - either flat (NetBIOS) or DNS domain name
// OUT strDnsName  - domain controller DNS name
// OUT strFlatName - domain controller flat (NetBIOS) name
//
// ReturnValue
// The function returns an HRESULT. S_OK is returned if names are retrieved
// successfully.
//-----------------------------------------------------------------------------

HRESULT __stdcall GetRidPoolAllocator4(PCWSTR pszDomainName, _bstr_t& strDnsName, _bstr_t& strFlatName)
{
    //
    // Load APIs explicitly so that this code may run in a NT4 loadable component.
    //

    CApi<PDSBIND> DsBindApi(L"NtDsApi.dll", "DsBindW");
    CApi<PDSUNBIND> DsUnBindApi(L"NtDsApi.dll", "DsUnBindW");
    CApi<PDSLISTROLES> DsListRolesApi(L"NtDsApi.dll", "DsListRolesW");
    CApi<PDSFREENAMERESULT> DsFreeNameResultApi(L"NtDsApi.dll", "DsFreeNameResultW");
    CApi<PADSGETOBJECT> ADsGetObjectApi(L"ActiveDs.dll", "ADsGetObject");

    DWORD dwError;

    if (DsBindApi.GetLastError() != ERROR_SUCCESS)
    {
        dwError = DsBindApi.GetLastError();
    }
    else if (DsUnBindApi.GetLastError() != ERROR_SUCCESS)
    {
        dwError = DsUnBindApi.GetLastError();
    }
    else if (DsListRolesApi.GetLastError() != ERROR_SUCCESS)
    {
        dwError = DsListRolesApi.GetLastError();
    }
    else if (DsFreeNameResultApi.GetLastError() != ERROR_SUCCESS)
    {
        dwError = DsFreeNameResultApi.GetLastError();
    }
    else if (ADsGetObjectApi.GetLastError() != ERROR_SUCCESS)
    {
        dwError = ADsGetObjectApi.GetLastError();
    }
    else
    {
        dwError = ERROR_SUCCESS;
    }

    if (dwError != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    //
    // Retrieve the name of a domain controller in the specified domain.
    //

    _bstr_t strDcNameDns;
    _bstr_t strDcNameFlat;

    dwError = GetDcName4(pszDomainName, DS_DIRECTORY_SERVICE_REQUIRED, strDcNameDns, strDcNameFlat);

    if (dwError != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    //
    // Bind to domain controller and retrieve distinguished name of
    // NTDS-DSA object that is the RID owner (master) in the domain.
    //

    HANDLE hDs;

    dwError = DsBindApi(strDcNameDns, NULL, &hDs);

    if (dwError != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    PDS_NAME_RESULTW pdnrResult;

    dwError = DsListRolesApi(hDs, &pdnrResult);

    if (dwError != ERROR_SUCCESS)
    {
        DsUnBindApi(&hDs);
        return HRESULT_FROM_WIN32(dwError);
    }

    if (DS_ROLE_RID_OWNER >= pdnrResult->cItems)
    {
        DsFreeNameResultApi(pdnrResult);
        DsUnBindApi(&hDs);
        return E_FAIL;
    }

    DS_NAME_RESULT_ITEM& dnriItem = pdnrResult->rItems[DS_ROLE_RID_OWNER];

    if (dnriItem.status != DS_NAME_NO_ERROR)
    {
        DsFreeNameResultApi(pdnrResult);
        DsUnBindApi(&hDs);
        return E_FAIL;
    }

    _bstr_t strFSMORoleOwner = dnriItem.pName;

    DsFreeNameResultApi(pdnrResult);
    DsUnBindApi(&hDs);

    WCHAR szADsPath[LEN_Path];

    //
    // Bind to NTDS-DSA object and retrieve ADsPath of parent Server object.
    //

    IADsPtr spNTDSDSA;
    _bstr_t strServer;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    int cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        (PCWSTR)strDcNameDns + 2,
        (PCWSTR)strFSMORoleOwner
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    HRESULT hr = ADsGetObjectApi(szADsPath, IID_IADs, (VOID**)&spNTDSDSA);

    if (FAILED(hr))
    {
        return hr;
    }

    BSTR bstrServer;

    hr = spNTDSDSA->get_Parent(&bstrServer);

    if (FAILED(hr))
    {
        return hr;
    }

    strServer = _bstr_t(bstrServer, false);

    //
    // Bind to Server object and retrieve distinguished name of Computer object.
    //

    IADsPtr spServer;
    _bstr_t strServerReference;

    hr = ADsGetObjectApi(strServer, IID_IADs, (VOID**)&spServer);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varServerReference;
    VariantInit(&varServerReference);

    hr = spServer->Get(L"serverReference", &varServerReference);

    if (FAILED(hr))
    {
        return hr;
    }

    strServerReference = _variant_t(varServerReference, false);

    //
    // Bind to Computer object and retrieve DNS host name and SAM account name.
    //

    IADsPtr spComputer;
    _bstr_t strDNSHostName;
    _bstr_t strSAMAccountName;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        (PCWSTR)strDcNameDns + 2,
        (PCWSTR)strServerReference
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    hr = ADsGetObjectApi(szADsPath, IID_IADs, (VOID**)&spComputer);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varDNSHostName;
    VariantInit(&varDNSHostName);

    hr = spComputer->Get(L"dNSHostName", &varDNSHostName);

    if (FAILED(hr))
    {
        return hr;
    }

    strDNSHostName = _variant_t(varDNSHostName, false);

    VARIANT varSAMAccountName;
    VariantInit(&varSAMAccountName);

    hr = spComputer->Get(L"SAMAccountName", &varSAMAccountName);

    if (FAILED(hr))
    {
        return hr;
    }

    strSAMAccountName = _variant_t(varSAMAccountName, false);

    if ((strDNSHostName.length() == 0) || (strSAMAccountName.length() == 0))
    {
        return E_OUTOFMEMORY;
    }

    // Remove trailing $ character from SAM account name.

    *((PWSTR)strSAMAccountName + strSAMAccountName.length() - 1) = L'\0';

    //
    // Set domain controller names.
    //

    strDnsName = strDNSHostName;
    strFlatName = strSAMAccountName;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\folders.cpp ===
#include <TChar.h>
#include <StdLib.h>
#include <Windows.h>
#include <Folders.h>


namespace nsFolders
{
const _TCHAR REGKEY_MCSHKCU[] = _T("Software\\Mission Critical Software\\EnterpriseAdmin");
const _TCHAR REGKEY_MSHKCU[] = _T("Software\\ADMT\\EnterpriseAdmin");
const _TCHAR REGKEY_MSADMT[] = _T("Software\\Microsoft\\ADMT");
const _TCHAR REGKEY_MCSADMT[] = _T("Software\\Mission Critical Software\\DomainAdmin");
const _TCHAR REGKEY_ADMT[] = _T("Software\\Microsoft\\ADMT");
const _TCHAR REGKEY_REPORTING[] = _T("Software\\Microsoft\\ADMT\\Reporting");
const _TCHAR REGKEY_EXTENSIONS[] = _T("Software\\Microsoft\\ADMT\\Extensions");
const _TCHAR REGVAL_DIRECTORY[] = _T("Directory");
const _TCHAR REGVAL_DIRECTORY_MIGRATIONLOG[] = _T("DirectoryMigrationLog");
const _TCHAR REGVAL_REGISTRYUPDATED[] = _T("RegistryUpdated");
const _TCHAR REGKEY_APPLICATION_LOG[] = _T("System\\CurrentControlSet\\Services\\EventLog\\Application");
const _TCHAR REGKEY_ADMTAGENT_EVENT_SOURCE[] = _T("ADMTAgent");
const _TCHAR REGVAL_EVENT_CATEGORYCOUNT[] = _T("CategoryCount");
const _TCHAR REGVAL_EVENT_CATEGORYMESSAGEFILE[] = _T("CategoryMessageFile");
const _TCHAR REGVAL_EVENT_EVENTMESSAGEFILE[] = _T("EventMessageFile");
const _TCHAR REGVAL_EVENT_TYPESSUPPORTED[] = _T("TypesSupported");
const _TCHAR REGKEY_CURRENT_VERSION[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
const _TCHAR REGVAL_PROGRAM_FILES_DIRECTORY[] = _T("ProgramFilesDir");
const _TCHAR REGVAL_EXCHANGE_LDAP_PORT[] = _T("ExchangeLDAPPort");
const _TCHAR REGVAL_EXCHANGE_SSL_PORT[] = _T("ExchangeSSLPort");
const _TCHAR REGVAL_ALLOW_NON_CLOSEDSET_MOVE[] = _T("AllowNonClosedSetMove");

const _TCHAR DIR_LOGS[] = _T("Logs");
const _TCHAR DIR_REPORTS[] = _T("Reports");
const _TCHAR FNAME_MIGRATION[] = _T("Migration");
const _TCHAR FNAME_DISPATCH[] = _T("Dispatch");
const _TCHAR EXT_LOG[] = _T(".log");

_bstr_t __stdcall GetPath(LPCTSTR pszRegKey, LPCTSTR pszRegVal, LPCTSTR pszDir, LPCTSTR pszFName = NULL, LPCTSTR pszExt = NULL);

}

using namespace nsFolders;


// GetLogsFolder Method
//
// Retrieves default Logs folder.

_bstr_t __stdcall GetLogsFolder()
{
	return GetPath(REGKEY_ADMT, REGVAL_DIRECTORY, DIR_LOGS);
}


// GetReportsFolder Method
//
// Retrieves default Reports folder and also creates folder if it doesn't exist.

_bstr_t __stdcall GetReportsFolder()
{
    _bstr_t strFolder = GetPath(REGKEY_REPORTING, REGVAL_DIRECTORY, DIR_REPORTS);

    if (strFolder.length())
    {
        if (!CreateDirectory(strFolder, NULL))
        {
            DWORD dwError = GetLastError();

            if (dwError != ERROR_ALREADY_EXISTS)
            {
                _com_issue_error(HRESULT_FROM_WIN32(dwError));
            }
        }
    }

    return strFolder;
}


// GetMigrationLogPath Method
//
// Retrieves path to migration log. First tries user specified path and then default path.

_bstr_t __stdcall GetMigrationLogPath()
{
	// retrieve user specified path

	_bstr_t strPath = GetPath(REGKEY_ADMT, REGVAL_DIRECTORY_MIGRATIONLOG, NULL, FNAME_MIGRATION, EXT_LOG);

	// if user path not specified...

	if (strPath.length() == 0)
	{
		// then retrieve default path
		strPath = GetPath(REGKEY_ADMT, REGVAL_DIRECTORY, DIR_LOGS, FNAME_MIGRATION, EXT_LOG);
	}

	return strPath;
}


// GetDispatchLogPath Method
//
// Retrieves default path to dispatch log.

_bstr_t __stdcall GetDispatchLogPath()
{
	return GetPath(REGKEY_ADMT, REGVAL_DIRECTORY, DIR_LOGS, FNAME_DISPATCH, EXT_LOG);
}


namespace nsFolders
{


// GetPath Function
//
// This function attempts to generate a complete path to a folder or file. The function first retrieves
// a folder path from the specified registry value. If a sub-folder is specified then the sub-folder is
// concatenated onto the path. If file name and/or file name extension is specified then they are also
// concatenated onto the path. The function returns an empty string if unable to query the specified
// registry value.

_bstr_t __stdcall GetPath(LPCTSTR pszRegKey, LPCTSTR pszRegVal, LPCTSTR pszDir, LPCTSTR pszFName, LPCTSTR pszExt)
{
	_TCHAR szPath[_MAX_PATH];
	_TCHAR szDrive[_MAX_DRIVE];
	_TCHAR szDir[_MAX_DIR];

	memset(szPath, 0, sizeof(szPath));

	HKEY hKey;

	DWORD dwError = RegOpenKey(HKEY_LOCAL_MACHINE, pszRegKey, &hKey);

	if (dwError == ERROR_SUCCESS)
	{
		DWORD cbPath = sizeof(szPath);

		dwError = RegQueryValueEx(hKey, pszRegVal, NULL, NULL, (LPBYTE)szPath, &cbPath);

		if (dwError == ERROR_SUCCESS)
		{
			// if the path does not contain a trailing backslash character the
			// splitpath function assumes the last component of the path is a file name
			// this function assumes that only folder paths are specified in the registry

			if (szPath[_tcslen(szPath) - 1] != _T('\\'))
			{
				_tcscat(szPath, _T("\\"));
			}

			_tsplitpath(szPath, szDrive, szDir, NULL, NULL);

			// if sub-folder specified then add to path

			if (pszDir)
			{
				_tcscat(szDir, pszDir);
			}

			_tmakepath(szPath, szDrive, szDir, pszFName, pszExt);
		}

		RegCloseKey(hKey);
	}

	return szPath;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\isadmin.cpp ===
//#pragma title( "IsAdmin.cpp - Determine if user is administrator" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  IsAdmin.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-06-04
Description -  Determine if user is administrator (local or remote)
Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <lm.h>

#include "Common.hpp"
#include "UString.hpp"
#include "IsAdmin.hpp"


namespace
{

#ifndef SECURITY_MAX_SID_SIZE
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#endif
const DWORD MAX_VERSION_2_ACE_SIZE = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + SECURITY_MAX_SID_SIZE;


// GetEffectiveToken
//
// Brown, Keith. 2000. Programming Windows Security. Reading MA: Addison-Wesley
// Pages 120-121

HANDLE __stdcall GetEffectiveToken(DWORD dwDesiredAccess, BOOL bImpersonation, SECURITY_IMPERSONATION_LEVEL silLevel)
{
	HANDLE hToken = 0;

	if (!OpenThreadToken(GetCurrentThread(), dwDesiredAccess, TRUE, &hToken))
	{
		if (GetLastError() == ERROR_NO_TOKEN)
		{
			DWORD dwAccess = bImpersonation ? TOKEN_DUPLICATE : dwDesiredAccess;

			if (OpenProcessToken(GetCurrentProcess(), dwAccess, &hToken))
			{
				if (bImpersonation)
				{
					// convert primary to impersonation token

					HANDLE hImpersonationToken = 0;
					DuplicateTokenEx(hToken, dwDesiredAccess, 0, silLevel, TokenImpersonation, &hImpersonationToken);
					CloseHandle(hToken);
					hToken = hImpersonationToken;
				}
			}
		}
	}

	return hToken;
}


// CheckTokenMembership
//
// Brown, Keith. 2000. Programming Windows Security. Reading MA: Addison-Wesley
// Pages 130-131

//#if (_WIN32_WINNT < 0x0500)
#if TRUE // always use our function
BOOL WINAPI AdmtCheckTokenMembership(HANDLE hToken, PSID pSid, PBOOL pbIsMember)
{
	// if no token was passed, CTM uses the effective
	// security context (the thread or process token)

	if (!hToken)
	{
		hToken = GetEffectiveToken(TOKEN_QUERY, TRUE, SecurityIdentification);
	}

	if (!hToken)
	{
		return FALSE;
	}

	// create a security descriptor that grants a
	// specific permission only to the specified SID

	BYTE dacl[sizeof ACL + MAX_VERSION_2_ACE_SIZE];
	ACL* pdacl = (ACL*)dacl;
	if (!InitializeAcl(pdacl, sizeof dacl, ACL_REVISION))
	   return FALSE;
	AddAccessAllowedAce(pdacl, ACL_REVISION, 1, pSid);

	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
		return FALSE;
	SID sidWorld = { SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
	SetSecurityDescriptorOwner(&sd, &sidWorld, FALSE);
	SetSecurityDescriptorGroup(&sd, &sidWorld, FALSE);
	SetSecurityDescriptorDacl(&sd, TRUE, pdacl, FALSE);

	// now let AccessCheck do all the hard work

	GENERIC_MAPPING gm = { 0, 0, 0, 1 };
	PRIVILEGE_SET ps;
	DWORD cb = sizeof ps;
	DWORD ga;

	return AccessCheck(&sd, hToken, 1, &gm, &ps, &cb, &ga, pbIsMember);
}
#else
#define AdmtCheckTokenMembership CheckTokenMembership
#endif

} // namespace


///////////////////////////////////////////////////////////////////////////////
// Determine if user is administrator on local machine                       //
///////////////////////////////////////////////////////////////////////////////

typedef BOOL (APIENTRY *PCHECKTOKENMEMBERSHIP)(HANDLE, PSID, PBOOL);

DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminLocal()
{
    DWORD dwError = NO_ERROR;
    PCHECKTOKENMEMBERSHIP pCheckTokenMembershipInDll = NULL;

    // try to load the CheckTokenMembership function from advapi32.dl
    HMODULE hAdvApi32 = LoadLibrary(L"advapi32.dll");
    if (hAdvApi32 != NULL)
    {
        pCheckTokenMembershipInDll = 
            (PCHECKTOKENMEMBERSHIP) GetProcAddress(hAdvApi32, "CheckTokenMembership");
    }

    // create well known SID Administrators

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    PSID psidAdministrators;

    BOOL bSid = AllocateAndInitializeSid(
    	&siaNtAuthority,
    	2,
    	SECURITY_BUILTIN_DOMAIN_RID,
    	DOMAIN_ALIAS_RID_ADMINS,
    	0,
    	0,
    	0,
    	0,
    	0,
    	0,
    	&psidAdministrators
    );

    if (bSid)
    {
    	// check if token membership includes Administrators

    	BOOL bIsMember;
    	BOOL result;
    	if (pCheckTokenMembershipInDll != NULL) 
        {
            result = (*pCheckTokenMembershipInDll)(0, psidAdministrators, &bIsMember);
        }
    	else
    	    result = AdmtCheckTokenMembership(0, psidAdministrators, &bIsMember);

    	if (result != FALSE)
    	{
    		dwError = bIsMember ? NO_ERROR : ERROR_ACCESS_DENIED;
    	}
    	else
    	{
    		dwError = GetLastError();
    	}

    	FreeSid(psidAdministrators);
    }
    else
    {
    	dwError = GetLastError();
    }

    if (hAdvApi32 != NULL)
        FreeLibrary(hAdvApi32);
    
    return dwError;
}


//------------------------------------------------------------------------------
// IsDomainAdmin Function
//
// Synopsis
// Checks if caller is a domain administrator in the specified domain.
//
// Arguments
// psidDomain - SID for domain of interest
//
// Return Value
// Returns ERROR_SUCCESS if caller is a domain administrator,
// ERROR_ACCESS_DENIED if not or other error code if unable to check token
// membership.
//------------------------------------------------------------------------------

DWORD __stdcall IsDomainAdmin(PSID psidDomain)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // Validate argument.
    //

    if ((psidDomain == NULL) || (IsValidSid(psidDomain) == FALSE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // try to load the CheckTokenMembership function from advapi32.dl

    HMODULE hAdvApi32 = LoadLibrary(L"advapi32.dll");
    PCHECKTOKENMEMBERSHIP pCheckTokenMembership = NULL;

    if (hAdvApi32 != NULL)
    {
        pCheckTokenMembership = (PCHECKTOKENMEMBERSHIP) GetProcAddress(hAdvApi32, "CheckTokenMembership");
    }

    //
    // create well known SID Administrators
    //

    PSID psidDomainAdmins = NULL;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PUCHAR pcSubAuthority = GetSidSubAuthorityCount(psidDomain);

    BOOL bSid = AllocateAndInitializeSid(
        &siaNtAuthority,
        *pcSubAuthority + 1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &psidDomainAdmins
    );

    if (bSid)
    {
        //
        //
        //

        if (CopySid(GetLengthSid(psidDomain), psidDomainAdmins, psidDomain))
        {
            pcSubAuthority = GetSidSubAuthorityCount(psidDomainAdmins);
            PDWORD pdwRid = GetSidSubAuthority(psidDomainAdmins, *pcSubAuthority);
            ++(*pcSubAuthority);
            *pdwRid = DOMAIN_GROUP_RID_ADMINS;

            //
            // check if token membership includes Domain Admins
            //

            BOOL bCheck;
            BOOL bIsMember;

            if (pCheckTokenMembership != NULL) 
            {
                bCheck = (*pCheckTokenMembership)(0, psidDomainAdmins, &bIsMember);
            }
            else
            {
                bCheck = AdmtCheckTokenMembership(0, psidDomainAdmins, &bIsMember);
            }

            if (bCheck)
            {
                dwError = bIsMember ? ERROR_SUCCESS : ERROR_ACCESS_DENIED;
            }
            else
            {
                dwError = GetLastError();
            }
        }
        else
        {
            dwError = GetLastError();
        }

        FreeSid(psidDomainAdmins);
    }
    else
    {
        dwError = GetLastError();
    }

    if (hAdvApi32 != NULL)
    {
        FreeLibrary(hAdvApi32);
    }

    return dwError;
}


///////////////////////////////////////////////////////////////////////////////
// Determine if user is administrator on remote machine                      //
///////////////////////////////////////////////////////////////////////////////

DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminRemote(
      WCHAR          const * pMachine      // in -\\machine name
   )
{
   DWORD                     osRc;         // OS return code
   WCHAR                     grpName[255];
   PSID                      pSid;
   SID_NAME_USE              use;
   DWORD                     dwNameLen = 255;
   DWORD                     dwDomLen = 255;
   WCHAR                     domain[255];
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
   BOOL                      bIsAdmin = FALSE;

   // build the Administrators SID
   if ( AllocateAndInitializeSid(
            &sia,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pSid
      ) )
   {
         // and look up the administrators group on the specified machine
      if ( LookupAccountSid(pMachine, pSid, grpName, &dwNameLen, domain, &dwDomLen, &use) )
      {
         // remove explict administrator check
         bIsAdmin = TRUE;
      }
      else 
         osRc = GetLastError();
      FreeSid(pSid);
   }
   else 
      osRc = GetLastError();
   
   if ( bIsAdmin  )
      osRc = 0;
   else
      if ( ! osRc )
         osRc = ERROR_ACCESS_DENIED;
      
   return osRc;
}

// IsAdmin.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\lsautils.cpp ===
/*---------------------------------------------------------------------------
  File: LSAUtils.cpp

  Comments: Code to change the domain membership of a workstation.
  

  This file also contains some general helper functions, such as:

  GetDomainDCName
  EstablishNullSession
  EstablishSession
  EstablishShare   // connects to a share
  InitLsaString
  GetDomainSid


  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/03/99 12:37:51

 ---------------------------------------------------------------------------
*/

//

//#include "stdafx.h"
#include <windows.h>
#include <process.h>

#ifndef UNICODE
#define UNICODE
#define _UNICODE
#endif

#include <lm.h>         // for NetXxx API
#include <RpcDce.h>
#include <stdio.h>

#include "LSAUtils.h"
#include "ErrDct.hpp"
#include "ResStr.h"
#include "ealen.hpp"


#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

extern TErrorDct        err;


BOOL 
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   return EstablishSession(Server,L"",L"",L"",bEstablish);
}

BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain name for user credentials
      LPWSTR                 UserName,     // in - username for credentials to use
      LPWSTR                 Password,     // in - password for credentials 
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   LPCWSTR                   szIpc = L"\\IPC$";
   WCHAR                     RemoteResource[2 + LEN_Computer + 5 + 1]; // \\ + computername + \IPC$ + NULL
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > LEN_Computer) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }
   if(lstrcatW(RemoteResource, szIpc) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_IPC;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      // try establishing session for one minute
      // if computer is not accepting any more connections

      for (int i = 0; i < (60000 / 5000); i++)
      {
         nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);

         if (nas != ERROR_REQ_NOT_ACCEP)
         {
            break;
         }

         Sleep(5000);
      }
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}

BOOL
   EstablishShare(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Share,        // in - share name
      LPWSTR                 Domain,       // in - domain name for credentials to connect with
      LPWSTR                 UserName,     // in - user name to connect as
      LPWSTR                 Password,     // in - password for username
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    )
{
   WCHAR                     RemoteResource[MAX_PATH];
   DWORD                     dwArraySizeOfRemoteResource = sizeof(RemoteResource)/sizeof(RemoteResource[0]);
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }

   // assume that Share has to be non-NULL
   if(Share == NULL 
      || wcslen(RemoteResource) + wcslen(Share) >= dwArraySizeOfRemoteResource
      || lstrcatW(RemoteResource, Share) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_DISKDEV;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      // try establishing session for one minute
      // if computer is not accepting any more connections

      for (int i = 0; i < (60000 / 5000); i++)
      {
         nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);

         if (nas != ERROR_REQ_NOT_ACCEP)
         {
            break;
         }

         Sleep(5000);
      }
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}



void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,    // i/o- pointer to LSA string to initialize
      LPWSTR                 String        // in - value to initialize LSA string to
    )
{
   DWORD                     StringLength;

   if( String == NULL ) 
   {
       LsaString->Buffer = NULL;
       LsaString->Length = 0;
       LsaString->MaximumLength = 0;
   }
   else
   {
      StringLength = lstrlenW(String);
      LsaString->Buffer = String;
      LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
      LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
   }
}

BOOL
   GetDomainSid(
      LPWSTR                 PrimaryDC,   // in - domain controller of domain to acquire Sid
      PSID                 * pDomainSid   // out- points to allocated Sid on success
    )
{
   NET_API_STATUS            nas;
   PUSER_MODALS_INFO_2       umi2 = NULL;
   DWORD                     dwSidSize;
   BOOL                      bSuccess = FALSE; // assume this function will fail
   
   *pDomainSid = NULL;    // invalidate pointer

   __try {

   //
   // obtain the domain Sid from the PDC
   //
   nas = NetUserModalsGet(PrimaryDC, 2, (LPBYTE *)&umi2);
   
   if(nas != NERR_Success) __leave;
   //
   // if the Sid is valid, obtain the size of the Sid
   //
   if(!IsValidSid(umi2->usrmod2_domain_id)) __leave;
   
   dwSidSize = GetLengthSid(umi2->usrmod2_domain_id);

   //
   // allocate storage and copy the Sid
   //
   *pDomainSid = LocalAlloc(LPTR, dwSidSize);
   
   if(*pDomainSid == NULL) __leave;

   if(!CopySid(dwSidSize, *pDomainSid, umi2->usrmod2_domain_id)) __leave;

   bSuccess = TRUE; // indicate success

    } // try
    
    __finally 
    {

      if(umi2 != NULL)
      {
         NetApiBufferFree(umi2);
      }

      if(!bSuccess) 
      {
        //
        // if the function failed, free memory and indicate result code
        //

         if(*pDomainSid != NULL) 
         {
            FreeSid(*pDomainSid);
            *pDomainSid = NULL;
         }

         if( nas != NERR_Success ) 
         {
            SetLastError(nas);
         }
      }

   } // finally

   return bSuccess;
}

NTSTATUS 
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - access rights needed for policy
      PLSA_HANDLE            PolicyHandle    // out- LSA handle
    )
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   LSA_UNICODE_STRING        ComputerString;
   PLSA_UNICODE_STRING       Computer = NULL;

   //
   // Always initialize the object attributes to all zeroes
   //
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   if(ComputerName != NULL) 
   {
      //
      // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
      //
      InitLsaString(&ComputerString, ComputerName);

      Computer = &ComputerString;
   }

   //
   // Attempt to open the policy
   //
   NTSTATUS status = LsaOpenPolicy(Computer,&ObjectAttributes,DesiredAccess,PolicyHandle);

   return status;
}

/*++
 This function sets the Primary Domain for the workstation.

 To join the workstation to a Workgroup, ppdi.Name should be the name of
 the Workgroup and ppdi.Sid should be NULL.

--*/
NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,      // in -policy handle for computer
      PSID                   DomainSid,         // in - sid for new domain
      LPWSTR                 TrustedDomainName  // in - name of new domain
    )
{
   POLICY_PRIMARY_DOMAIN_INFO ppdi;

   InitLsaString(&ppdi.Name, TrustedDomainName);
   
   ppdi.Sid = DomainSid;

   return LsaSetInformationPolicy(PolicyHandle,PolicyPrimaryDomainInformation,&ppdi);
}


// This function removes the information from the domain the computer used to
// be a member of
NTSTATUS 
   QueryWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,   // in - policy handle for computer
      PSID                   DomainSid,      // in - SID for new domain the computer is member of
      BOOL                   bNoChange       // in - flag indicating whether to write changes
   )
{
   // This function is not currently used.
   NTSTATUS                  Status;
   LSA_ENUMERATION_HANDLE    h = 0;
   LSA_TRUST_INFORMATION   * ti = NULL;
   ULONG                     count;

   Status = LsaEnumerateTrustedDomains(PolicyHandle,&h,(void**)&ti,50000,&count);

   if ( Status == STATUS_SUCCESS )
   {
      for ( UINT i = 0 ; i < count ; i++ )
      {
         if ( !bNoChange && !EqualSid(DomainSid,ti[i].Sid) )
         {
            // Remove the old trust
            Status = LsaDeleteTrustedDomain(PolicyHandle,ti[i].Sid);

            if ( Status != STATUS_SUCCESS )
            {
                LsaFreeMemory(ti);
                return Status;
            }
         }
      }
      LsaFreeMemory(ti);
   }
   else
   {
      return Status;
   }

   return STATUS_SUCCESS;
}


/*++
 This function manipulates the trust associated with the supplied
 DomainSid.

 If the domain trust does not exist, it is created with the
 specified password.  In this case, the supplied PolicyHandle must
 have been opened with POLICY_TRUST_ADMIN and POLICY_CREATE_SECRET
 access to the policy object.

--*/
NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text if function fails
    )
{
   LSA_UNICODE_STRING        LsaPassword;
   LSA_UNICODE_STRING        KeyName;
   LSA_UNICODE_STRING        LsaDomainName;
   DWORD                     cchDomainName; // number of chars in TrustedDomainName
   NTSTATUS                  Status;

   InitLsaString(&LsaDomainName, TrustedDomainName);

   //
   // ...convert TrustedDomainName to uppercase...
   //
   cchDomainName = LsaDomainName.Length / sizeof(WCHAR);
   
   while(cchDomainName--) 
   {
      LsaDomainName.Buffer[cchDomainName] = towupper(LsaDomainName.Buffer[cchDomainName]);
   }

   //
   // ...create the trusted domain object
   //
   Status = LsaSetTrustedDomainInformation(
     PolicyHandle,
     DomainSid,
     TrustedDomainNameInformation,
     &LsaDomainName
     );

   if(Status == STATUS_OBJECT_NAME_COLLISION)
   {
      //printf("LsaSetTrustedDomainInformation: Name Collision (ok)\n");
   }
   else if (Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaSetTrustedDomainInformation", Status);
      return RTN_ERROR;
   }

   InitLsaString(&KeyName, L"$MACHINE.ACC");
   InitLsaString(&LsaPassword, Password);

   //
   // Set the machine password
   //
   Status = LsaStorePrivateData(
     PolicyHandle,
     &KeyName,
     &LsaPassword
     );

   if(Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaStorePrivateData", Status);
      return RTN_ERROR;
   }

   return STATUS_SUCCESS;

}


//------------------------------------------------------------------------------
// StorePassword Function
//
// Synopsis
// Stores a password in LSA secret.
//
// Arguments
// IN pszIdentifier - the key name to store the password under
// IN pszPassword   - the clear-text password to be stored
//
// Return
// Returns Win32 error code.
//------------------------------------------------------------------------------

DWORD __stdcall StorePassword(PCWSTR pszIdentifier, PCWSTR pszPassword)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // The identifier parameter must specify a pointer to a non-zero length string. Note
    // that a null password parameter is valid as this will delete the data and the key
    // named by the identifier parameter.
    //

    if (pszIdentifier && *pszIdentifier)
    {
        //
        // Open policy object with create secret access right.
        //

        LSA_HANDLE hPolicy = NULL;
        LSA_OBJECT_ATTRIBUTES oa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

        NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &oa, POLICY_CREATE_SECRET, &hPolicy);

        if (LSA_SUCCESS(ntsStatus))
        {
            //
            // Store specified password under key named by the identifier parameter.
            //

            PWSTR pszKey = const_cast<PWSTR>(pszIdentifier);
            USHORT cbKey = wcslen(pszIdentifier) * sizeof(WCHAR);
            LSA_UNICODE_STRING usKey = { cbKey, cbKey, pszKey };

            if (pszPassword)
            {
                PWSTR pszData = const_cast<PWSTR>(pszPassword);
                USHORT cbData = wcslen(pszPassword) * sizeof(WCHAR);
                LSA_UNICODE_STRING usData = { cbData, cbData, pszData };

                ntsStatus = LsaStorePrivateData(hPolicy, &usKey, &usData);
            }
            else
            {
                ntsStatus = LsaStorePrivateData(hPolicy, &usKey, NULL);
            }

            if (!LSA_SUCCESS(ntsStatus))
            {
                dwError = LsaNtStatusToWinError(ntsStatus);
            }

            //
            // Close policy object.
            //

            LsaClose(hPolicy);
        }
        else
        {
            dwError = LsaNtStatusToWinError(ntsStatus);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}


//------------------------------------------------------------------------------
// RetrievePassword Function
//
// Synopsis
// Retrieves a password from LSA secret.
//
// Arguments
// IN  pszIdentifier - the key name to retrieve the password from
// OUT pszPassword   - the address of a buffer to return the clear-text password
// IN  cchPassword   - the size of the buffer in characters
//
// Return
// Returns Win32 error code.
//------------------------------------------------------------------------------

DWORD __stdcall RetrievePassword(PCWSTR pszIdentifier, PWSTR pszPassword, size_t cchPassword)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // The identifier parameter must specify a pointer to a non-zero length string. The
    // password parameters must specify a pointer to a buffer with length greater than
    // zero.
    //

    if (pszIdentifier && *pszIdentifier && pszPassword && (cchPassword > 0))
    {
        memset(pszPassword, 0, cchPassword * sizeof(pszPassword[0]));

        //
        // Open policy object with get private information access right.
        //

        LSA_HANDLE hPolicy = NULL;
        LSA_OBJECT_ATTRIBUTES oa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

        NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &oa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

        if (LSA_SUCCESS(ntsStatus))
        {
            //
            // Retrieve password from key named by specified identifier.
            //

            PWSTR pszKey = const_cast<PWSTR>(pszIdentifier);
            USHORT cbKey = wcslen(pszIdentifier) * sizeof(pszIdentifier[0]);
            LSA_UNICODE_STRING usKey = { cbKey, cbKey, pszKey };

            PLSA_UNICODE_STRING pusData;

            ntsStatus = LsaRetrievePrivateData(hPolicy, &usKey, &pusData);

            if (LSA_SUCCESS(ntsStatus))
            {
                size_t cch = pusData->Length / sizeof(WCHAR);

                if (cch < cchPassword)
                {
                    wcsncpy(pszPassword, pusData->Buffer, cch);
                    pszPassword[cch] = 0;
                }
                else
                {
                    dwError = ERROR_INSUFFICIENT_BUFFER;
                }

                SecureZeroMemory(pusData->Buffer, pusData->Length);

                LsaFreeMemory(pusData);
            }
            else
            {
                dwError = LsaNtStatusToWinError(ntsStatus);
            }

            //
            // Close policy object.
            //

            LsaClose(hPolicy);
        }
        else
        {
            dwError = LsaNtStatusToWinError(ntsStatus);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}


//------------------------------------------------------------------------------
// GeneratePasswordIdentifier Function
//
// Synopsis
// Generates a key name used to store a password under.
//
// Note that is important to delete the key after use as the system only allows
// 2048 LSA secrets to be stored by all applications on a given machine.
//
// Arguments
// IN  pszIdentifier - the key name to retrieve the password from
// OUT pszPassword   - the address of a buffer to return the clear-text password
// IN  cchPassword   - the size of the buffer in characters
//
// Return
// Returns Win32 error code.
//------------------------------------------------------------------------------

DWORD __stdcall GeneratePasswordIdentifier(PWSTR pszIdentifier, size_t cchIdentifier)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // The identifier parameter must specify a pointer to a buffer with a length
    // greater than or equal to the length of the password identifier.
    //

    if (pszIdentifier && (cchIdentifier > 0))
    {
        memset(pszIdentifier, 0, cchIdentifier * sizeof(pszIdentifier[0]));

        //
        // Generate unique identifier.
        //

        UUID uuid;
        UuidCreate(&uuid);

        PWSTR pszUuid;
        RPC_STATUS rsStatus = UuidToString(&uuid, &pszUuid);

        if (rsStatus == RPC_S_OK)
        {
            //
            // Concatenate prefix and unique identifier. This makes
            // it possible to identify keys generated by ADMT.
            //

            static const WCHAR IDENTIFIER_PREFIX[] = L"L$ADMT_PI_";

            if ((wcslen(IDENTIFIER_PREFIX) + wcslen(pszUuid)) < cchIdentifier)
            {
                wcscpy(pszIdentifier, IDENTIFIER_PREFIX);
                wcscat(pszIdentifier, pszUuid);
            }
            else
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
            }

            RpcStringFree(&pszUuid);
        }
        else
        {
            dwError = rsStatus;
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#   include <stdlib.h>
#endif

#include <time.h>
//#include <strstrea.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      if (m_fileName) { UStrCpy (m_fileName, fileNameIn); }
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path, MAX_PATH);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      fullFilePath[MAX_PATH - 1] = '\0';

      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP, MAX_PATH-len);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName,
                     MAX_PATH-UStrLen(logFileName));
      } else {
         UStrCpy (logFileName, fileName, MAX_PATH);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME, MAX_PATH);
   }
   strncat (logFileName + UStrLen (logFileName), EXT, MAX_PATH-UStrLen(logFileName));
   logFileName[MAX_PATH-1] = '\0';

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
//   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\names.cpp ===
#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <Windows.h>
#endif

#include <memory>
#include <string.h>
#include <ComDef.h>
#include "Common.hpp"
#include "ErrDct.hpp"


extern TErrorDct              err;


//---------------------------------------------------------------------------
// StripSamName Function
//
// Replaces invalid SAM account name characters with a replacement character.
//---------------------------------------------------------------------------

void StripSamName(WCHAR* pszName)
{
	// invalid punctuation characters in any position
	const WCHAR INVALID_CHARACTERS_ABC[] = L"\"*+,/:;<=>?[\\]|";
	// invalid punctuation characters only in last position
	const WCHAR INVALID_CHARACTERS_C[] = L".";
	// replacement character
	const WCHAR REPLACEMENT_CHARACTER = L'_';

	// if name specified...

	if (pszName)
	{
		size_t cchName = wcslen(pszName);

		// if length of name is valid...

		if ((cchName > 0) && (cchName < MAX_PATH))
		{
			bool bChanged = false;

			// save old name

			WCHAR szOldName[MAX_PATH];
			wcscpy(szOldName, pszName);

			// get character type information

			WORD wTypes[MAX_PATH];
			GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, pszName, cchName, wTypes);

			// for each character in name...

			for (size_t ich = 0; ich < cchName; ich++)
			{
				bool bReplace = false;

				WORD wType = wTypes[ich];

				// if character is of specified type...

				if ((wType == 0) || (wType & C1_CNTRL))
				{
					// replace un-classified or control type
					bReplace = true;
				}
			//	Note: Windows 2000 & Windows XP allows space characters as first or last character
			//	else if (wType & (C1_BLANK|C1_SPACE))
			//	{
					// blank or space type

					// if first or last character...

			//		if ((ich == 0) || (ich == (cchName - 1)))
			//		{
						// then replace 
			//			bReplace = true;
			//		}
			//	}
				else if (wType & C1_PUNCT)
				{
					// punctuation type

					// if invalid punctuation character in any position...

					if (wcschr(INVALID_CHARACTERS_ABC, pszName[ich]))
					{
						// then replace
						bReplace = true;
					}
					else
					{
						// otherwise if invalid punctuation character in last position...

						if ((ich == (cchName - 1)) && wcschr(INVALID_CHARACTERS_C, pszName[ich]))
						{
							// then replace
							bReplace = true;
						}
					}
				}
				else
				{
					// alphabetic, digit and variations are valid types
				}

				// if replacement indicated...

				if (bReplace)
				{
					// then replace invalid character with replacement
					// character and set name changed to true
					pszName[ich] = REPLACEMENT_CHARACTER;
					bChanged = true;
				}
			}

			// if name has changed...

			if (bChanged)
			{
				// log name change
				err.MsgWrite(ErrW, DCT_MSG_SAMNAME_CHANGED_SS, szOldName, pszName);
			}
		}
	}
}


//---------------------------------------------------------------------------
// GetDomainDNSFromPath Function
//
// Generates a domain DNS name from a distinguished name or ADsPath.
//---------------------------------------------------------------------------

_bstr_t GetDomainDNSFromPath(_bstr_t strPath)
{
	static wchar_t s_szDnDelimiter[] = L",";
	static wchar_t s_szDcPrefix[] = L"DC=";
	static wchar_t s_szDnsDelimiter[] = L".";

	#define DC_PREFIX_LENGTH (sizeof(s_szDcPrefix) / sizeof(s_szDcPrefix[0]) - 1)

	std::auto_ptr<wchar_t> apDNS;

	// if non empty path...

	if (strPath.length() > 0)
	{
		// allocate buffer for DNS name
		apDNS = std::auto_ptr<wchar_t>(new wchar_t[strPath.length() + 1]);

		// allocate temporary buffer for path
		std::auto_ptr<wchar_t> apPath(new wchar_t[strPath.length() + 1]);

		// if allocations succeeded...

		if ((apDNS.get() != 0) && (apPath.get() != 0))
		{
			// initialize DNS name to empty
			*apDNS = L'\0';

			// copy path to temporary buffer
			wcscpy(apPath.get(), strPath);

			// then for each component in path...
			//
			// Note: if any path components contain the path delimiter character they will be skipped as
			//       they wont begin with domain component prefix. The domain component prefix contains
			//       a special character that must be escaped if part of path component name.

			for (wchar_t* pszDC = wcstok(apPath.get(), s_szDnDelimiter); pszDC; pszDC = wcstok(0, s_szDnDelimiter))
			{
				// if domain component...

				if (_wcsnicmp(pszDC, s_szDcPrefix, DC_PREFIX_LENGTH) == 0)
				{
					//
					// then concatenate to DNS name
					//

					// if not first component...

					if (*apDNS)
					{
						// then append delimiter
						wcscat(apDNS.get(), s_szDnsDelimiter);
					}

					// append domain component name without type prefix
					wcscat(apDNS.get(), pszDC + DC_PREFIX_LENGTH);
				}
			}
		}
	}

	return apDNS.get();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\pwdfuncs.cpp ===
#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
//#include <stdio.h>
#endif

#include <stdio.h>
#include <NtSecApi.h>
#include <comdef.h>
#include <io.h>
#include <winioctl.h>
#include <lm.h>
#include <Dsgetdc.h>
#include "mcsdmmsg.h"
#include "pwdfuncs.h"
#include "PWGen.hpp"
#include "UString.hpp"

using namespace _com_util;

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for enumerating all floppy drives*
 * on this server.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN EnumLocalDrives
_bstr_t EnumLocalDrives()
{
/* local constants */
    const int ENTRY_SIZE = 4; // Drive letter, colon, backslash, NULL

/* local variables */
	_bstr_t			strDrives = L"";
	WCHAR			sDriveList[MAX_PATH];
    DWORD			dwRes;

/* function body */
	try
	{
       dwRes = GetLogicalDriveStrings(MAX_PATH, sDriveList);
	   if (dwRes != 0)
	   {
          LPWSTR pTmpBuf = sDriveList;

			 //check each one to see if it is a floppy drive
          while (*pTmpBuf != NULL)
		  {
		        //check the type of this drive
             UINT uiType = GetDriveType(pTmpBuf);
			 if ((uiType == DRIVE_REMOVABLE) || (uiType == DRIVE_FIXED) || 
				 (uiType == DRIVE_CDROM) || (uiType == DRIVE_RAMDISK))
			 {
			    strDrives += pTmpBuf;
			    strDrives += L",";
			 }
             pTmpBuf += ENTRY_SIZE;
		  }
		     //remove the trailing ','
		  WCHAR* pEnd = (WCHAR*)strDrives;
		  pEnd[strDrives.length() - 1] = L'\0';
	   }
	   else
	   {
		  _com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	   }
	}
	catch (...)
	{
	   throw;
	}

	return strDrives;
}
//END EnumLocalDrives


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for saving binary data to a given*
 * file path on a floppy drive.                                      *
 *                                                                   *
 *********************************************************************/

//BEGIN StoreDataToFloppy
void StoreDataToFloppy(LPCWSTR sPath, _variant_t & varData)
{
/* local variables */
    FILE		  * floppyfile = NULL;
    LPBYTE			pByte = NULL;
	HRESULT			hr;

/* function body */
	try
	{
	      //check incoming parameters
	   if ((!sPath) || (varData.vt != (VT_ARRAY | VT_UI1)) || 
		   (!varData.parray))
	   {
	      _com_issue_error(HRESULT_FROM_WIN32(E_INVALIDARG));
	   }

	      //open the file
	   floppyfile = _wfopen(sPath, L"wb");
       if (!floppyfile)
	      _com_issue_error(HRESULT_FROM_WIN32(CO_E_FAILEDTOCREATEFILE));

	      //get the array size
	   long uLBound, uUBound;
       size_t uSLength;
	   hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
       if (FAILED(hr))
          _com_issue_error(hr);
       hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
       if (FAILED(hr))
          _com_issue_error(hr);
	   uSLength = size_t(uUBound - uLBound + 1);
	  
	      //write the data to the file
       hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
       if (FAILED(hr))
          _com_issue_error(hr);
	   if (fwrite((void *)pByte, 1, uSLength, floppyfile) != uSLength)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_WRITE_FAULT));
       hr = SafeArrayUnaccessData(varData.parray);
       if (FAILED(hr))
          _com_issue_error(hr);

	      //close the file
	   if (floppyfile)
	      fclose(floppyfile);
	}
	catch (...)
	{
	   if (floppyfile)
	      fclose(floppyfile);
	   throw;
	}
}
//END StoreDataToFloppy



/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for retrieving binary data from a*
 * given file path on a floppy drive.  The _variant_t variable       *
 * returned is of the type VT_UI1 | VT_ARRAY upoin success or        *
 * VT_EMPTY upon a failure.                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDataFromFloppy
_variant_t GetDataFromFloppy(LPCWSTR sPath)
{
/* local variables */
    FILE		  * floppyfile = NULL;
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	_variant_t		varData;
    SAFEARRAY     * pSa = NULL;
    SAFEARRAYBOUND  bd;

/* function body */
	try
	{
	      //check incoming parameters
	   if (!sPath)
	      _com_issue_error(HRESULT_FROM_WIN32(E_INVALIDARG));

	      //path must have the '\' escaped
//	   _bstr_t sFile = EscapeThePath(sPath);

	      //open the file
	   floppyfile = _wfopen(sPath, L"rb");
       if (!floppyfile)
	      _com_issue_error(HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES));

          //get the number of bytes in the file
	   long fileLen = _filelength(_fileno(floppyfile));
	   if (fileLen == -1)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_READ_FAULT));
       bd.cElements = fileLen;
       bd.lLbound = 0;

	      //read the data from the file one byte at a time
       pSa = SafeArrayCreate(VT_UI1, 1, &bd);
	   if (!pSa)
	      _com_issue_error(E_FAIL);
       hr = SafeArrayAccessData(pSa,(void**)&pByte);
       if (FAILED(hr))
          _com_issue_error(hr);
       
	   long nTotalRead = 0;
	   while(!feof(floppyfile) && !ferror(floppyfile))
	   {
	      if (fread((void *)(pByte+nTotalRead), 1, 1, floppyfile) == 1)
		     nTotalRead++;
	   }

       if (ferror(floppyfile)) {
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_READ_FAULT));
       }

       hr = SafeArrayUnaccessData(pSa);
       if (FAILED(hr))
          _com_issue_error(hr);

	      //close the file
	   if (floppyfile)
	   {
	      fclose(floppyfile);
          floppyfile = NULL;
	   }

	   if (nTotalRead != fileLen)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_READ_FAULT));

	   varData.vt = VT_UI1 | VT_ARRAY;
       if (FAILED(SafeArrayCopy(pSa, &varData.parray)))
          _com_issue_error(hr);
       if (FAILED(SafeArrayDestroy(pSa)))
          _com_issue_error(hr);
	}
	catch (...)
	{
	   if (floppyfile)
	      fclose(floppyfile);
	   throw;
	}

	return varData;
}
//END GetDataFromFloppy


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is convert a _variant_t parameter of the type   *
 * VT_ARRAY | VT_UI1 and returns it in a char array.  The caller must*
 * free the array with the delete [] call.  This function return NULL*
 * if the data was not placed in the array.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetBinaryArrayFromVariant
char* GetBinaryArrayFromVariant(_variant_t varData)
{
/* local variables */
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	char          * cArray;
	int				i;

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return NULL;

	   //get the array size
	long uLBound, uUBound, uSLength;
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return NULL;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return NULL;
	uSLength = uUBound - uLBound + 1;

	   //create an array to hold all this data
    cArray = new char[uSLength+1];
	if (!cArray)
	   return NULL;
	  
	   //write the data to the file
    hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
    if (FAILED(hr))
	{
       delete [] cArray;
       return NULL;
	}
	for (i=0; i<uSLength; i++)
	{
	   cArray[i] = pByte[i];
	}
	cArray[i] = L'\0';
    hr = SafeArrayUnaccessData(varData.parray);
    if (FAILED(hr))
	{
       delete [] cArray;
       return NULL;
	}

	return cArray;
}
//END GetBinaryArrayFromVariant


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is convert a char array of binary data to a     *
 * _variant_t of the type VT_ARRAY | VT_UI1 and returns it.          *
 *                                                                   *
 *********************************************************************/

//BEGIN SetVariantWithBinaryArray
_variant_t SetVariantWithBinaryArray(char * aData, DWORD dwArray)
{
/* local variables */
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	_variant_t		varData;
    SAFEARRAY     * pSa = NULL;
    SAFEARRAYBOUND  bd;
	DWORD			i;

/* function body */
	   //check incoming parameters
	if (!aData)
	   return varData;

    bd.cElements = dwArray;
    bd.lLbound = 0;

	   //read the data from the file one byte at a time
    pSa = SafeArrayCreate(VT_UI1, 1, &bd);
	if (!pSa)
	   return varData;
    hr = SafeArrayAccessData(pSa,(void**)&pByte);
    if (FAILED(hr))
	   return varData;
       
    for (i=0; i<dwArray; i++)
	{
	   pByte[i] = aData[i];
	}
	  
    hr = SafeArrayUnaccessData(pSa);
    if (FAILED(hr))
	   return varData;

	varData.vt = VT_UI1 | VT_ARRAY;
    if (FAILED(SafeArrayCopy(pSa, &varData.parray)))
	{
       varData.Clear();
	   return varData;
	}
    SafeArrayDestroy(pSa);

	return varData;
}
//END SetVariantWithBinaryArray


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is returns the size, in bytes, of the given     *
 * variant array.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN GetVariantArraySize
DWORD GetVariantArraySize(_variant_t & varData)
{
/* local variables */
	HRESULT			hr;
	DWORD           uSLength = 0;
	long			uLBound, uUBound;

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return uSLength;

	   //get the array size
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return uSLength;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return uSLength;
	uSLength = DWORD(uUBound - uLBound + 1);

	return uSLength;
}
//END GetVariantArraySize


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is returns the size, in bytes, of the given     *
 * variant array.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN PrintVariant
void PrintVariant(const _variant_t & varData)
{
/* local variables */
	HRESULT			hr;
    LPBYTE			pByte = NULL;
	long			i;
	WCHAR			sData[MAX_PATH] = L"";

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return;

	   //get the array size
	long uLBound, uUBound, uSLength;
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return;
	uSLength = uUBound - uLBound + 1;

	   //write the data to the file
    hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
    if (FAILED(hr))
       return;
	FILE * myfile;
	myfile = _wfopen(L"c:\\CryptCheck.txt", L"a+");
	if (myfile == NULL) {
        SafeArrayUnaccessData(varData.parray);
        return;
	}
	
	for (i=0; i<uSLength; i++)
	{
	   fwprintf(myfile, L"%x ", pByte[i]);
	}
    hr = SafeArrayUnaccessData(varData.parray);
    if (FAILED(hr))
       return;

	fwprintf(myfile, L"\n");
	fclose(myfile);

	return;
}
//END PrintVariant
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\registryhelper.cpp ===
#include <stdio.h>
#include <windows.h> 
#include <winuser.h>
#include <lm.h>
#include <shlwapi.h>
#include <comdef.h>
#include "RegistryHelper.h"
#include "BkupRstr.hpp"
#include "folders.h"
#include <memory>

using namespace nsFolders;
using namespace std;


//----------------------------------------------------------------------------
// Function:   CopyRegistryKey
//
// Synopsis:   Copies a source registry key and all its subkeys to a target registry key.
//                  Note: the target registry key has to exist already.  No roll back.
//
// Arguments:
//
// sourceKey    the handle for source registry key
// targetKey     the handle for target registry key
// fSetSD         whether to set the security descriptor
//
// Returns:    ERROR_SUCCESS if successful; otherwise an error code
//
// Modifies:   Modifies the target registry key.
//
//----------------------------------------------------------------------------

DWORD CopyRegistryKey(HKEY sourceKey, HKEY targetKey, BOOL fSetSD)
{
    WCHAR     className[MAX_PATH] = L"";  // buffer for class name 
    DWORD    classNameLen = sizeof(className)/sizeof(className[0]);  // length of class string 
    DWORD    numOfSubKeys;                 // number of subkeys 
    DWORD    maxSubKeySize;              // longest subkey size 
    DWORD    maxClassSize;              // longest class string 
    DWORD    numOfValues;              // number of values for key 
    DWORD    maxValueSize;          // longest value name 
    DWORD    maxValueDataSize;       // longest value data 
    DWORD    securityDescriptorSize; // size of security descriptor
    FILETIME   lastWriteTime;
 
    DWORD i, j; 
    DWORD retValue = ERROR_SUCCESS;
    
    // Get the class name and the value count. 
    retValue = RegQueryInfoKey(sourceKey,        // key handle 
        className,                // buffer for class name 
        &classNameLen,           // length of class string 
        NULL,                    // reserved 
        &numOfSubKeys,               // number of subkeys 
        &maxSubKeySize,            // longest subkey size 
        &maxClassSize,            // longest class string 
        &numOfValues,                // number of values for this key 
        &maxValueSize,            // longest value name 
        &maxValueDataSize,         // longest value data 
        &securityDescriptorSize,   // security descriptor 
        &lastWriteTime);       // last write time

    // fix up the security attributes for the target key
    if (retValue == ERROR_SUCCESS && fSetSD)
    {
        PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) new BYTE[securityDescriptorSize];
        if (pSD != NULL)
        {
            SECURITY_INFORMATION secInfo =
                DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                | OWNER_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION;

            retValue = RegGetKeySecurity(sourceKey, secInfo, pSD, &securityDescriptorSize);
            if (retValue == ERROR_SUCCESS)
                retValue = RegSetKeySecurity(targetKey, secInfo, pSD);
            delete[] pSD;
        }
        else
            retValue = E_OUTOFMEMORY;
    }            

    // subkeys and values related variables
    auto_ptr<WCHAR> subKeyName;
    DWORD subKeyNameSize;
    auto_ptr<WCHAR> subKeyClassName;
    DWORD subKeyClassNameSize;
    auto_ptr<WCHAR> valueName;
    DWORD valueNameSize;
    DWORD valueType;
    auto_ptr<BYTE> valueData;
    DWORD valueDataSize;

    // copy registry values
    if (retValue == ERROR_SUCCESS && numOfValues > 0)
    {
        valueName = auto_ptr<WCHAR>(new WCHAR[maxValueSize + 1]);
        valueData = auto_ptr<BYTE>(new BYTE[maxValueDataSize]);

        if (valueName.get() != NULL && valueData.get() != NULL)
        {
            // copy all values from source key to target key          
            for (i = 0; i < numOfValues; i++) 
            { 
                valueNameSize = maxValueSize + 1;
                valueDataSize = maxValueDataSize;
                retValue = RegEnumValue(sourceKey, i, valueName.get(), &valueNameSize, NULL, &valueType, valueData.get(), &valueDataSize);
                if (retValue == ERROR_SUCCESS)
                    retValue = RegSetValueEx(targetKey, valueName.get(), NULL, valueType, valueData.get(), valueDataSize);
                if (retValue != ERROR_SUCCESS)
                    break; 
            }
        }
        else
            retValue = E_OUTOFMEMORY;
    }

    // copy registry subkeys
    if (retValue == ERROR_SUCCESS && numOfSubKeys > 0)
    {
        subKeyName = auto_ptr<WCHAR>(new WCHAR[maxSubKeySize + 1]);
        subKeyClassName = auto_ptr<WCHAR>(new WCHAR[maxClassSize + 1]);

        if (subKeyName.get() != NULL && subKeyClassName.get() != NULL)
        {
            // process all subkeys
            for (i = 0; i < numOfSubKeys; i++) 
            { 
                subKeyNameSize = maxSubKeySize + 1;
                subKeyClassNameSize = maxClassSize + 1;

                HKEY sourceSubKey;
                retValue = RegEnumKeyEx(sourceKey, i, subKeyName.get(), &subKeyNameSize, NULL, subKeyClassName.get(), &subKeyClassNameSize, &lastWriteTime);
                if (retValue == ERROR_SUCCESS)
                    retValue = RegOpenKeyEx(sourceKey, subKeyName.get(), NULL, KEY_ALL_ACCESS|READ_CONTROL|ACCESS_SYSTEM_SECURITY, &sourceSubKey);
                
                if (retValue == ERROR_SUCCESS) 
                {
                    BOOL created = FALSE;
                    HKEY newSubKey;
                    retValue = RegOpenKeyEx(targetKey, subKeyName.get(), 0,
                                            KEY_ALL_ACCESS|READ_CONTROL |ACCESS_SYSTEM_SECURITY, &newSubKey);
                    if (retValue == ERROR_FILE_NOT_FOUND)
                    {
                        created = TRUE;
                        retValue = RegCreateKeyEx(targetKey, subKeyName.get(), NULL, subKeyClassName.get(), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS|ACCESS_SYSTEM_SECURITY, NULL, &newSubKey, NULL);
                    }
                    if (retValue == ERROR_SUCCESS)
                    {
                        retValue = CopyRegistryKey(sourceSubKey, newSubKey, created);
                        RegCloseKey(newSubKey);
                    }
                    RegCloseKey(sourceSubKey);
                }

                if (retValue != ERROR_SUCCESS)
                    break;                        
             }
        }
        else
            retValue = E_FAIL;
    }

    return retValue;
}
    
//----------------------------------------------------------------------------
// Function:   DeleteRegistryKey
//
// Synopsis:   Deletes a registry key and all its subkeys.
//
// Arguments:
//
// hKey            the handle for the registry key to be deleted
// lpSubKey     the name string for the key to be deleted
//
// Returns:    ERROR_SUCCESS if successful; otherwise an error code
//
// Modifies:   Modifies the subkey.
//
//----------------------------------------------------------------------------

DWORD DeleteRegistryKey(HKEY hKey, LPCTSTR lpSubKey)
{
    DWORD retValue = ERROR_SUCCESS;
    _TCHAR subKeyName[MAX_PATH];
    DWORD subKeyNameSize = MAX_PATH;
    
    // open the key 
    HKEY hKeyToDelete;
    BOOL bKeyOpened = FALSE;
    retValue = RegOpenKeyEx(hKey, lpSubKey, 0, KEY_ALL_ACCESS, &hKeyToDelete);

    // delete subkeys
    if (retValue == ERROR_SUCCESS)
    {
        bKeyOpened = TRUE;

        do
        {
            retValue = RegEnumKey(hKeyToDelete, 0, subKeyName, subKeyNameSize);
            if (retValue == ERROR_SUCCESS)
            {
                retValue = DeleteRegistryKey(hKeyToDelete, subKeyName);
            }
            else if (retValue == ERROR_NO_MORE_ITEMS)
            {
                retValue = ERROR_SUCCESS;
                break;
            }
        }
        while (retValue == ERROR_SUCCESS);
    }

    // close key
    if (bKeyOpened == TRUE)
        RegCloseKey(hKeyToDelete);
    
    if (retValue == ERROR_SUCCESS)
    {
        retValue = RegDeleteKey(hKey, lpSubKey);
    }

    return retValue;
}
    
//----------------------------------------------------------------------------
// Function:   MoveRegistryFromSourceToTarget
//
// Synopsis:   Moves registry key from a source to a taget
//
// Arguments:
//  hSrcParent:         the handle to source parent registry key
//  sSrcKey:             the name of source registry key
//  hTgtParent:         the handle to target parent registry key
//  sTgtKey:             the name of target registry key
//  bTgtKeyCreated: indicate whether the target key is created or not
//  bTgtKeyUpdated: indicate whether the target key is updated or not
//
// Returns:    ERROR_SUCCESS if successful; otherwise, returns an error code
//
// Modifies:    Create and/or modify the target registry key
//
//----------------------------------------------------------------------------

DWORD MoveRegFromSourceToTarget(HKEY hSrcParent,
                                                                        const _TCHAR* sSrcKey,
                                                                        HKEY hTgtParent,
                                                                        const _TCHAR* sTgtKey,
                                                                        BOOL* bTgtKeyCreated)
{
    HKEY hSrcKey, hTgtKey;
    DWORD lret;
    *bTgtKeyCreated = FALSE;
    
    //open the source Registry key, if it exists
    lret = RegOpenKeyEx(hSrcParent, sSrcKey, 0, 
                                    KEY_ALL_ACCESS|READ_CONTROL|ACCESS_SYSTEM_SECURITY, &hSrcKey);
    if (lret == ERROR_SUCCESS)
    {
        //
        // copy over the registry from source key to target key
        //
        
        // open the target key
        lret = RegOpenKeyEx(hTgtParent, sTgtKey, 0,
                                        KEY_ALL_ACCESS|READ_CONTROL |ACCESS_SYSTEM_SECURITY, &hTgtKey);

        // if cannot open it, create it
        if (lret == ERROR_FILE_NOT_FOUND)
        {
            lret = RegCreateKeyEx(hTgtParent, sTgtKey, NULL, NULL, REG_OPTION_NON_VOLATILE,
                                              KEY_ALL_ACCESS|ACCESS_SYSTEM_SECURITY, NULL, &hTgtKey, NULL);
            if (lret == ERROR_SUCCESS)
                *bTgtKeyCreated = TRUE;
        }

        // time to copy registry
        if (lret == ERROR_SUCCESS)
        {
            lret = CopyRegistryKey(hSrcKey, hTgtKey, *bTgtKeyCreated);
            RegCloseKey(hTgtKey);
        }
        
        RegCloseKey(hSrcKey);   // we need to close Mission Critical Software registry key anyway
    }
    else if (lret == ERROR_FILE_NOT_FOUND)
    {
        // if the source key is not found, assume it is a success
        lret = ERROR_SUCCESS;
    }

    return lret;
}

//----------------------------------------------------------------------------
// Function:   MoveRegistry
//
// Synopsis:   Moves registry key from Mission Critical Software\DomainAdmin to Microsoft\ADMT.
//
// Arguments:
//
// Returns:    ERROR_SUCCESS if successful; otherwise retuns an error code
//
// Modifies:   Deletes the old Mission Critical Software key and creates new Microsoft\ADMT key.
//
//----------------------------------------------------------------------------

DWORD MoveRegistry()
{
    DWORD				lret = ERROR_SUCCESS;
    
    // some key names
    HKEY hMcsADMTKey;   // Mission Critical Software ADMT registry key
    HKEY hMSADMTKey;    // Microsoft ADMT registry key
    HKEY hMcsHKCUKey;   // Mission Critical Software HKCU registry key
    HKEY hMSHKCUKey;    // Microsoft HKCU registry key
    const _TCHAR* sMcsADMTKey = REGKEY_MCSADMT;
    const _TCHAR* sMSADMTKey = REGKEY_MSADMT;
    const _TCHAR* sMcsHKCUKey = REGKEY_MCSHKCU;
    const _TCHAR* sMSHKCUKey = REGKEY_MSHKCU;

    // check whether we need to move the registry key from Mission Critical Software to Microsoft\ADMT or not
    // this information is recorded in a REG_DWORD value in Microsoft\ADMT key
    lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sMSADMTKey, 0, KEY_READ, &hMSADMTKey);
    if (lret == ERROR_SUCCESS)
    {
        DWORD type;
        DWORD value;
        DWORD valueSize = sizeof(value);
        lret = RegQueryValueEx(hMSADMTKey, REGVAL_REGISTRYUPDATED, NULL, &type, (LPBYTE)&value, &valueSize);
        if (lret == ERROR_SUCCESS && type == REG_DWORD && value == 1)
        {
            // if RegistryUpdated is REG_DWORD and 1, we don't need to move registry key
            RegCloseKey(hMSADMTKey);
            return ERROR_SUCCESS;
        }
        else if (lret == ERROR_FILE_NOT_FOUND)
            lret = ERROR_SUCCESS;

        RegCloseKey(hMSADMTKey);
    }
    else if (lret == ERROR_FILE_NOT_FOUND)
    {
        // if the key does not exist, we should go ahead and move the registry
        lret = ERROR_SUCCESS;
    }
            
    // check whether MCS ADMT is available or not
    if (lret == ERROR_SUCCESS)
    {
        lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sMcsADMTKey, 0, KEY_READ, &hMcsADMTKey);
        if (lret == ERROR_SUCCESS)
        {
            // if RegistryUpdated is REG_DWORD and 1, we don't need to move registry key
            RegCloseKey(hMcsADMTKey);
        }
        else if (lret == ERROR_FILE_NOT_FOUND)
            return ERROR_SUCCESS;
    }
    
    // get backup/restore and system security privileges
    BOOL fBkupRstrPrivOn = FALSE, fSystemSecurityPrivOn = FALSE;
    if (lret == ERROR_SUCCESS)
    {
        fBkupRstrPrivOn = GetBkupRstrPriv(NULL, TRUE);
        if (fBkupRstrPrivOn == FALSE)
            lret = GetLastError();
    }

    if (lret == ERROR_SUCCESS)
    {
        fSystemSecurityPrivOn = GetPrivilege(NULL, SE_SECURITY_NAME, TRUE);
        if (fSystemSecurityPrivOn == FALSE)
            lret = GetLastError();
    }

    // these two flags are used to keep track of whether two registry keys are created/updated or not
    BOOL fMSADMTKeyCreated = FALSE;
    BOOL fMSHKCUKeyCreated = FALSE;
    
    if (lret == ERROR_SUCCESS)
    {
        lret =  MoveRegFromSourceToTarget(HKEY_LOCAL_MACHINE, sMcsADMTKey,
                                                                    HKEY_LOCAL_MACHINE, sMSADMTKey,
                                                                    &fMSADMTKeyCreated);
    }

    if (lret == ERROR_SUCCESS)
    {
        lret = MoveRegFromSourceToTarget(HKEY_CURRENT_USER, sMcsHKCUKey,
                                                                   HKEY_CURRENT_USER, sMSHKCUKey,
                                                                   &fMSHKCUKeyCreated);
    }

    //
    // delete keys that we do not need
    //
    if (lret != ERROR_SUCCESS)
    {
        if (fMSADMTKeyCreated)
            DeleteRegistryKey(HKEY_LOCAL_MACHINE, sMSADMTKey);
        if (fMSHKCUKeyCreated)
            DeleteRegistryKey(HKEY_CURRENT_USER, sMSHKCUKey);
    }
    // we have successfully created and copied two registry keys, we delete the old Mission Critical Software keys
    // and mark RegistryUpdated registry value
    else
    {
        // set RegistryUpdated registry value to 1
        lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sMSADMTKey, 0, KEY_ALL_ACCESS, &hMSADMTKey);
        if (lret == ERROR_SUCCESS)
        {
            DWORD type = REG_DWORD;
            DWORD value = 1;
            lret = RegSetValueEx(hMSADMTKey, REGVAL_REGISTRYUPDATED, NULL, type, (BYTE*)&value, sizeof(value));
            RegCloseKey(hMSADMTKey);
        }
        
        // if we successfully set RegistryUpdated to 1, delete both old keys
        if (lret == ERROR_SUCCESS)
        {
            DeleteRegistryKey(HKEY_LOCAL_MACHINE, sMcsADMTKey);
            DeleteRegistryKey(HKEY_CURRENT_USER, sMcsHKCUKey);
        }
    }

    //
    // release privileges
    //
    if (fBkupRstrPrivOn)
        GetBkupRstrPriv(NULL, FALSE);
    if (fSystemSecurityPrivOn)
        GetPrivilege(NULL, SE_SECURITY_NAME, FALSE);

    return lret;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\pwrpcutl.cpp ===
/*---------------------------------------------------------------------------
  File: PwdRpcUtil.cpp

  Comments: Functions to establish binding to Password Migration Lsa 
  Notifications packages.  These functions are used by the password extension 
  to bind to the password migration Lsa notification package on remote source 
  domain DCs.
    This files was copied from AgRpcUtil.cpp, which was created by Christy Boles
  of NetIQ Corporation.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/
//#include "StdAfx.h"
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>


// These global variables can be changed if required
#define gsPwdProtoSeq TEXT("ncacn_np")
#define gsPwdEndPoint TEXT("\\pipe\\PwdMigRpc")

// Destroy RPC binding for connection with an Lsa notification package
DWORD                                      // ret-OS return code
   PwdBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   )
{
   if ( *phBinding )
   {
      RpcBindingFree( phBinding );
      *phBinding = NULL;
   }

   if ( *psBinding )
   {
      RpcStringFree( psBinding );
      *psBinding = NULL;
   }

   return 0;
}




// Create RPC binding for connection with an Lsa notification package
DWORD                                      // ret-OS return code
   PwdBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -flag whether to use authenticated RPC
   )
{
   DWORD                     rcOs;         // OS return code

   do // once or until break
   {
      PwdBindDestroy( phBinding, psBinding );
      rcOs = RpcStringBindingCompose(
            NULL,
            (TCHAR *) gsPwdProtoSeq,
            (TCHAR *) sComputer,
            (TCHAR *) gsPwdEndPoint,
            NULL,
            psBinding );
      if ( rcOs ) break;
      rcOs = RpcBindingFromStringBinding( *psBinding, phBinding );
      if ( rcOs || !bAuthn ) break;
      rcOs = RpcBindingSetAuthInfo(
            *phBinding,
            0,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            0,
            0 );
   }  while ( FALSE );

   if ( rcOs )
   {
      PwdBindDestroy( phBinding, psBinding );
   }

   return rcOs;
}



/*/////////////////////////////////////////////////////////////////////////////
// midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
   return;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\samutils.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>
#include <ntsam.h>
#include <String.h>
#include <ntdsapi.h>

//#pragma comment(lib, "samlib.lib")

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
SamConnectWithCreds(
    IN  PUNICODE_STRING             ServerName,
    OUT PSAM_HANDLE                 ServerHandle,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    IN  RPC_AUTH_IDENTITY_HANDLE    Creds,
    IN  PWCHAR                      Spn,
    OUT BOOL                        *pfDstIsW2K
    );

#ifdef __cplusplus
}
#endif


namespace
{

//------------------------------------------------------------------------------
// ConnectToSam Function
//
// Synopsis
// Connects to Sam Server on specified domain controller using specified
// credentials.
//
// Arguments
// IN pszDomain           - the domain name
// IN pszDomainController - the domain controller to connect to
// IN pszUserName         - the credentials user
// IN pszPassword         - the credentials password
// IN pszUserDomain       - the credentials domain
// OUT phSam              - the handle to the SAM server
//
// Return
// Win32 error code
//------------------------------------------------------------------------------

DWORD __stdcall ConnectToSam
    (
        PCWSTR pszDomain,
        PCWSTR pszDomainController,
        PCWSTR pszUserName,
        PCWSTR pszPassword,
        PCWSTR pszUserDomain,
        SAM_HANDLE* phSam
    )
{
    DWORD dwError = ERROR_SUCCESS;

    *phSam = NULL;

    // SAM server name

    UNICODE_STRING usServerName;
    usServerName.Length = wcslen(pszDomainController) * sizeof(WCHAR);
    usServerName.MaximumLength = usServerName.Length + sizeof(WCHAR);
    usServerName.Buffer = const_cast<PWSTR>(pszDomainController);

    // object attributes

    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

    // authorization identity

    SEC_WINNT_AUTH_IDENTITY_W swaiAuthIdentity;
	swaiAuthIdentity.User = const_cast<PWSTR>(pszUserName);
	swaiAuthIdentity.UserLength = wcslen(pszUserName);
	swaiAuthIdentity.Domain = const_cast<PWSTR>(pszUserDomain);
	swaiAuthIdentity.DomainLength = wcslen(pszUserDomain);
	swaiAuthIdentity.Password = const_cast<PWSTR>(pszPassword);
	swaiAuthIdentity.PasswordLength = wcslen(pszPassword);
	swaiAuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // service principal name ?

    const WCHAR c_szA[] = L"cifs/";
    const WCHAR c_szC[] = L"@";

    PWSTR pszSpn = new WCHAR[wcslen(c_szA) + wcslen(pszDomainController) + wcslen(c_szC) + wcslen(pszDomain) + 1];

    if (pszSpn)
    {
	    wcscpy(pszSpn, c_szA);
	    wcscat(pszSpn, pszDomainController);
	    wcscat(pszSpn, c_szC);
	    wcscat(pszSpn, pszDomain);
    }
    else {

        return ERROR_OUTOFMEMORY;
    }

    BOOL fSrcIsW2K;

    NTSTATUS ntsStatus = SamConnectWithCreds(
        &usServerName,
        phSam,
        MAXIMUM_ALLOWED,
        &oa,
        &swaiAuthIdentity,
        pszSpn,
        &fSrcIsW2K
    );

    if (ntsStatus == RPC_NT_UNKNOWN_AUTHN_SERVICE)
    {
        // Note that following comment is from the DsAddSidHistory
        // implementation.
        //
	    // It might be that the SrcDc is NT4 and the client is
		// running locally. This config is supported so try the
		// binding with a NULL SrcSpn to force the underlying code
		// to use AUTH_WINNT instead of AUTH_NEGOTIATE.

        ntsStatus = SamConnectWithCreds(
            &usServerName,
            phSam,
            MAXIMUM_ALLOWED,
            &oa,
            &swaiAuthIdentity,
            NULL,
            &fSrcIsW2K
        );
    }

    delete [] pszSpn;

    if (ntsStatus != STATUS_SUCCESS)
    {
        //
        // SamConnectWithCreds sometimes returns Win32 errors instead of an
        // NT status. Therefore assume that if the severity is success that a
        // Win32 error has been returned.
        //

        if (NT_SUCCESS(ntsStatus))
        {
            dwError = ntsStatus;
        }
        else
        {
            dwError = RtlNtStatusToDosError(ntsStatus);
        }
    }

    return dwError;
}


//------------------------------------------------------------------------------
// OpenDomain Function
//
// Synopsis
// Opens the specified domain and returns a handle that may be used to open
// objects in the domain.
//
// Arguments
// IN hSam      - SAM handle
// IN pszDomain - domain to open
// OUT phDomain - domain handle
//
// Return
// Win32 error code
//------------------------------------------------------------------------------

DWORD __stdcall OpenDomain(SAM_HANDLE hSam, PCWSTR pszDomain, SAM_HANDLE* phDomain)
{
    DWORD dwError = ERROR_SUCCESS;

    *phDomain = NULL;

    //
    // Retrieve domain SID from SAM server.
    //

    PSID pSid;
    UNICODE_STRING usDomain;
    usDomain.Length = wcslen(pszDomain) * sizeof(WCHAR);
    usDomain.MaximumLength = usDomain.Length + sizeof(WCHAR);
    usDomain.Buffer = const_cast<PWSTR>(pszDomain);

    NTSTATUS ntsStatus = SamLookupDomainInSamServer(hSam, &usDomain, &pSid);

    if (ntsStatus == STATUS_SUCCESS)
    {
        //
        // Open domain object in SAM server.
        //

        ntsStatus = SamOpenDomain(hSam, DOMAIN_LOOKUP, pSid, phDomain);

        if (ntsStatus != STATUS_SUCCESS)
        {
            dwError = RtlNtStatusToDosError(ntsStatus);
        }

        SamFreeMemory(pSid);
    }
    else
    {
        dwError = RtlNtStatusToDosError(ntsStatus);
    }

    return dwError;
}


//------------------------------------------------------------------------------
// OpenDomain Function
//
// Synopsis
// Verifies that the principal which obtained the domain handle has domain
// admin rights in the domain.
//
// Note that the comments and logic were borrowed from the DsAddSidHistory code.
// //depot/Lab03_N/ds/ds/src/ntdsa/dra/addsid.c
//
// Arguments
// IN hDomain - domain handle
//
// Return
// Win32 error code
//------------------------------------------------------------------------------

DWORD __stdcall VerifyDomainAdminRights(SAM_HANDLE hDomain)
{
    DWORD dwError = ERROR_SUCCESS;

    // We need to verify that the credentials used to get hSam have domain
    // admin rights in the source domain.  RichardW observes that we can
    // do this easily for both NT4 and NT5 cases by checking whether we
    // can open the domain admins object for write.  On NT4, the principal
    // would have to be an immediate member of domain admins.  On NT5 the
    // principal may transitively be a member of domain admins.  But rather
    // than checking memberships per se, the ability to open domain admins
    // for write proves that the principal could add himself if he wanted
    // to, thus he/she is essentially a domain admin.  I.e. The premise is
    // that security is set up such that only domain admins can modify the
    // domain admins group.  If that's not the case, the customer has far
    // worse security issues to deal with than someone stealing a SID.

    // You'd think we should ask for GROUP_ALL_ACCESS.  But it turns out
    // that in 2000.3 DELETE is not given by default to domain admins.
    // So we modify the access required accordingly.  PraeritG has been
    // notified of this phenomena.

    SAM_HANDLE  hGroup;

    NTSTATUS ntsStatus = SamOpenGroup(hDomain, GROUP_ALL_ACCESS & ~DELETE, DOMAIN_GROUP_RID_ADMINS, &hGroup);

    if (ntsStatus == STATUS_SUCCESS)
    {
        SamCloseHandle(hGroup);
    }
    else
    {
        dwError = RtlNtStatusToDosError(ntsStatus);
    }

    return dwError;
}

} // namespace


//------------------------------------------------------------------------------
// VerifyAdminCredentials Function
//
// Synopsis
// Verifies that the given credentials are valid in the specified domain and
// that the account has domain admin rights in the domain.
//
// Arguments
// IN pszDomain
// IN pszDomainController
// IN pszUserName
// IN pszPassword
// IN pszUserDomain
//
// Return
// Win32 error code
// ERROR_SUCCESS       - credentials are valid and the account does have domain
//                       admin rights in the domain
// ERROR_ACCESS_DENIED - either the credentials are invalid or the account does
//                       not have domain admin rights in the domain
//------------------------------------------------------------------------------

DWORD __stdcall VerifyAdminCredentials
    (
        PCWSTR pszDomain,
        PCWSTR pszDomainController,
        PCWSTR pszUserName,
        PCWSTR pszPassword,
        PCWSTR pszUserDomain
    )
{
    //
    // Connect to SAM server.
    //

    SAM_HANDLE hSam;

    DWORD dwError = ConnectToSam(pszDomain, pszDomainController, pszUserName, pszPassword, pszUserDomain, &hSam);

    if (dwError == ERROR_SUCCESS)
    {
        //
        // Open domain object on SAM server.
        //

        SAM_HANDLE hDomain;

        dwError = OpenDomain(hSam, pszDomain, &hDomain);

        if (dwError == ERROR_SUCCESS)
        {
            //
            // Verify credentials have administrative rights in domain.
            //

            dwError = VerifyDomainAdminRights(hDomain);

            SamCloseHandle(hDomain);
        }

        SamCloseHandle(hSam);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\sd.cpp ===
/*---------------------------------------------------------------------------
  File: SD.cpp
  Comments: class for manipulating security descriptors
  This class provides a thin wrapper around the security descriptor APIs, and 
  also helps us with some of our processing heuristics.

  The NT APIs to read and write security descriptors for files, etc. generally
  return a self-relative SD when reading, but expect an absolute SD when writing

  Thus, we keep the original data of the SD as read, in self-relative form in m_relSD,
  and store any changes in absolute form in m_absSD.  This allows us to easily track
  which parts of the SD have been modified, and to compare the before and after versions
  of the SD.  

  As an optimization in our ACL translation, we can compare each SD to the initial 
  state of the last SD we processed.  If it is the same, we can simply write the 
  result we have already calculated, instead of calculating it again.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01-Oct-98 15:51:41

 ---------------------------------------------------------------------------
*/
#include <windows.h>
#include "McsDebug.h"
#include "McsDbgU.h"
#include "SD.hpp"

   TSD::TSD(
      SECURITY_DESCRIPTOR   * pSD,           // in - pointer to self-relative security descriptor
      SecuredObjectType       objectType,    // in - type of object this security descriptor secures
      BOOL                    bResponsibleForDelete // in - if TRUE, this class will delete the memory for pSD
   )
{
   m_absSD         = MakeAbsSD(pSD);
   m_bOwnerChanged = FALSE;
   m_bGroupChanged = FALSE;
   m_bDACLChanged  = FALSE;
   m_bSACLChanged  = FALSE;
   m_bNeedToFreeSD = TRUE;
   m_bNeedToFreeOwner = TRUE;
   m_bNeedToFreeGroup = TRUE;
   m_bNeedToFreeDacl  = TRUE;
   m_bNeedToFreeSacl  = TRUE;
   m_ObjectType    = objectType;
   
   if ( bResponsibleForDelete )
   {
      free(pSD);
   }
}   

   TSD::TSD(
      TSD                  * pSD             // in - another security descriptor
   )
{
   MCSVERIFY(pSD);

   if ( pSD )
   {
      m_absSD         = pSD->MakeAbsSD();
      m_bOwnerChanged = FALSE;
      m_bGroupChanged = FALSE;
      m_bDACLChanged  = FALSE;
      m_bSACLChanged  = FALSE;
      m_bNeedToFreeSD = TRUE;     
      m_bNeedToFreeOwner = TRUE;
      m_bNeedToFreeGroup = TRUE;
      m_bNeedToFreeDacl  = TRUE;
      m_bNeedToFreeSacl  = TRUE;
      m_ObjectType    = pSD->GetType();
   }
}

//
// This constructor allows for construction of an empty security descriptor. This is useful
// if one wishes to create a security descriptor for an object that does not currently have
// one such as a newly created share with default permissions.
//

   TSD::TSD(
      SecuredObjectType       objectType    // in - type of object this security descriptor secures
   )
{
    m_absSD = (SECURITY_DESCRIPTOR*) malloc(sizeof(SECURITY_DESCRIPTOR));

    if (m_absSD)
    {
        InitializeSecurityDescriptor(m_absSD, SECURITY_DESCRIPTOR_REVISION);
    }

    m_bOwnerChanged = FALSE;
    m_bGroupChanged = FALSE;
    m_bDACLChanged  = FALSE;
    m_bSACLChanged  = FALSE;
    m_bNeedToFreeSD = TRUE;
    m_bNeedToFreeOwner = FALSE;
    m_bNeedToFreeGroup = FALSE;
    m_bNeedToFreeDacl  = FALSE;
    m_bNeedToFreeSacl  = FALSE;
    m_ObjectType    = objectType;
}   

   TSD::~TSD()
{
   MCSVERIFY(m_absSD);

   if ( m_bNeedToFreeSD )
   {
      if (m_absSD)
         FreeAbsSD(m_absSD,FALSE);
      m_absSD = NULL;
   }
}

void 
   TSD::FreeAbsSD(
      SECURITY_DESCRIPTOR  * pSD,          // in - pointer to security descriptor to free
      BOOL                   bAll          // in - flag whether to free all parts of the SD, or only those 
                                           //      allocated by this class
   )
{
   PSID                      sid = NULL;
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorOwner(pSD,&sid,&defaulted);

   if ( sid && ( m_bNeedToFreeOwner || bAll ) )
   {
      free(sid);
      sid = NULL;
   }

   GetSecurityDescriptorGroup(pSD,&sid,&defaulted);
   if ( sid && ( m_bNeedToFreeGroup || bAll ) )
   {
      free(sid);
      sid = NULL;
   }

   GetSecurityDescriptorDacl(pSD,&present,&acl,&defaulted);
   if ( acl && (m_bNeedToFreeDacl || bAll ) )
   {
      free(acl);
      acl = NULL;
   }

   GetSecurityDescriptorSacl(pSD,&present,&acl,&defaulted);
   if ( acl && ( m_bNeedToFreeSacl || bAll ) )
   {
      free(acl);
      acl = NULL;
   }

   free(pSD);
}


SECURITY_DESCRIPTOR *                        // ret- copy of the SD, in Absolute format
   TSD::MakeAbsSD(
      SECURITY_DESCRIPTOR  * pSD             // in - security descriptor to copy
   ) const
{
   DWORD                     sd_size    = (sizeof SECURITY_DESCRIPTOR); 
   DWORD                     dacl_size  = 0;
   DWORD                     sacl_size  = 0;
   DWORD                     owner_size = 0;
   DWORD                     group_size = 0;
   
   // Allocate space for the SD and its parts
   SECURITY_DESCRIPTOR     * absSD = (SECURITY_DESCRIPTOR *) malloc(sd_size);
   if (!absSD || !pSD)
   {
	  if (absSD)
	  {
	     free(absSD);
		 absSD = NULL;
	  }
      return NULL;
   }

   PACL                      absDacl = NULL;
   PACL                      absSacl = NULL;
   PSID                      absOwner = NULL;
   PSID                      absGroup = NULL;
   
   if ( ! MakeAbsoluteSD(pSD,absSD,&sd_size,absDacl,&dacl_size,absSacl,&sacl_size
                         ,absOwner,&owner_size,absGroup,&group_size) )
   {
//      DWORD rc = GetLastError();
      // didn't work:  increase sizes and try again
      
      if ( sd_size > (sizeof SECURITY_DESCRIPTOR) )
      {
         free(absSD);
         absSD = (SECURITY_DESCRIPTOR *) malloc(sd_size);
         if (!absSD)
            return NULL;
      }
      if ( dacl_size )
      {
         absDacl = (PACL)malloc(dacl_size);
         if (!absDacl)
		 {
			free(absSD);
			absSD = NULL;
            return NULL;
		 }
      }
      if ( sacl_size )
      {
         absSacl = (PACL)malloc(sacl_size);
		 if (!absSacl)
		 {
            free(absSD);
            free(absDacl);
            absSD    = NULL;
            absDacl  = NULL;
			return NULL;
		 }
      }
      if ( owner_size )
      {
         absOwner = (PSID)malloc(owner_size);
		 if (!absOwner)
		 {
            free(absSD);
            free(absDacl);
            free(absSacl);
            absSD    = NULL;
            absDacl  = NULL;
            absSacl  = NULL;
			return NULL;
		 }
      }
      if ( group_size )
      {
         absGroup = (PSID)malloc(group_size);
		 if (!absGroup)
		 {
            free(absSD);
            free(absDacl);
            free(absSacl);
            free(absOwner);
            absSD    = NULL;
            absDacl  = NULL;
            absSacl  = NULL;
            absOwner = NULL;
			return NULL;
		 }
      }              
      
      // try again with bigger buffers
      if ( ! MakeAbsoluteSD(pSD,absSD,&sd_size,absDacl,&dacl_size,absSacl,&sacl_size
                           ,absOwner,&owner_size,absGroup,&group_size) )
      {
         free(absSD);
         free(absDacl);
         free(absSacl);
         free(absOwner);
         free(absGroup);
         absSD    = NULL;
         absDacl  = NULL;
         absSacl  = NULL;
         absOwner = NULL;
         absGroup = NULL;    
      }
   }
   return absSD;
}

SECURITY_DESCRIPTOR *                        // ret- copy of the SD, in Absolute format
   TSD::MakeAbsSD() const
{
   SECURITY_DESCRIPTOR     * absSD = NULL;
   SECURITY_DESCRIPTOR     * relSD = MakeRelSD();
   if (relSD)
   {
      absSD = MakeAbsSD(relSD);
      free(relSD);
   }

   return absSD;
}

SECURITY_DESCRIPTOR *                       // ret- copy of the SD, in self-relative form
   TSD::MakeRelSD() const
{
   DWORD                     nBytes;
   SECURITY_DESCRIPTOR     * relSD = NULL;

   nBytes = GetSecurityDescriptorLength(m_absSD);
   relSD = (SECURITY_DESCRIPTOR *)malloc(nBytes);
   if (!relSD)
      return NULL;

   if (! MakeSelfRelativeSD(m_absSD,relSD,&nBytes) )
   {
      free(relSD);
      relSD = NULL;
   }
   return relSD;
}

PSID const                                 // ret- sid for security descriptor owner field
   TSD::GetOwner() const
{
   PSID                      ownersid = NULL;
   BOOL                      ownerDefaulted;

   GetSecurityDescriptorOwner(m_absSD,&ownersid,&ownerDefaulted);
   
   return ownersid;
}
void       
   TSD::SetOwner(
      PSID                   pNewOwner     // in - new value for owner field
   )
{
   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   
   if ( IsValidSid(pNewOwner) )
   {
      if ( m_bNeedToFreeOwner )
      {
         PSID                old = GetOwner();

         free(old);
      }
      
      SetSecurityDescriptorOwner(m_absSD,pNewOwner,FALSE);
      m_bOwnerChanged = TRUE;
      m_bNeedToFreeOwner = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}

PSID const                                   // ret- sid for security descriptor owner field
   TSD::GetGroup() const
{
   PSID                      grpsid = NULL;
   BOOL                      grpDefaulted;

   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   GetSecurityDescriptorGroup(m_absSD,&grpsid,&grpDefaulted);

   return grpsid;
}

void       
   TSD::SetGroup(
      PSID                   pNewGroup       // in - new value for primary group field.
   )
{
   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   
   if ( IsValidSid(pNewGroup) )
   {
      if ( m_bNeedToFreeGroup )
      {
         PSID                old = GetGroup();

         free(old);
      }
      SetSecurityDescriptorGroup(m_absSD,pNewGroup,FALSE);
      m_bGroupChanged = TRUE;
      m_bNeedToFreeGroup = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}

PACL const                                  // ret- pointer to DACL
   TSD::GetDacl() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return acl;
}
BOOL       
   TSD::SetDacl(
      PACL                   pNewAcl,     // in - new DACL
      BOOL                   present      // in - flag, TRUE means DACL is present.
   )
{
   BOOL                      defaulted = FALSE;
   BOOL                      success = TRUE;
   
   if ( IsValidAcl(pNewAcl) )
   {
      if ( m_bNeedToFreeDacl )
      {
         PACL old = GetDacl();
         
         if ( old != pNewAcl )
         {
            free(old);
         }
      }
      if (! SetSecurityDescriptorDacl(m_absSD,present,pNewAcl,defaulted) )
      {
//         DWORD rc = GetLastError();
           success = FALSE;
      }
      m_bDACLChanged = TRUE;
      m_bNeedToFreeDacl = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
      success = FALSE;
   }

   return success;
}
                                           
PACL const                                 // ret- pointer to SACL
   TSD::GetSacl() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return acl;
}

void       
   TSD::SetSacl(
      PACL                   pNewAcl,      // in - new SACL
      BOOL                   present       // in - flag, TRUE means SACL is present
   )
{
   BOOL                      defaulted = FALSE;

   if ( IsValidAcl(pNewAcl) )
   {
      if ( m_bNeedToFreeSacl )
      {
         PACL                old = GetSacl();
         
         if ( old != pNewAcl )
         {
            free(old);
         }
      }
      SetSecurityDescriptorSacl(m_absSD,present,pNewAcl,defaulted);
      m_bSACLChanged = TRUE;
      m_bNeedToFreeSacl = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}


             
BOOL                                       
   TSD::IsOwnerDefaulted() const
{
   PSID                      ownersid = NULL;
   BOOL                      ownerDefaulted = FALSE;

   GetSecurityDescriptorOwner(m_absSD,&ownersid,&ownerDefaulted);
   
   return ownerDefaulted;
}

BOOL 
   TSD::IsGroupDefaulted() const
{
   PSID                      groupsid = NULL;
   BOOL                      groupDefaulted = FALSE;

   GetSecurityDescriptorGroup(m_absSD,&groupsid,&groupDefaulted);
   
   return groupDefaulted;

}
BOOL 
   TSD::IsDaclDefaulted() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted = FALSE;
   BOOL                      present;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return defaulted;
}

BOOL 
   TSD::IsDaclPresent() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present = FALSE;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return present;
}

BOOL 
   TSD::IsSaclDefaulted() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted = FALSE;
   BOOL                      present;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return defaulted;
}

BOOL 
   TSD::IsSaclPresent() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present = FALSE;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return present;
}

int                                        // ret- number of aces in the ACL
   TSD::ACLGetNumAces(
      PACL                   acl           // in - DACL or SACL
   )
{
   int                       nAces = 0;
   ACL_SIZE_INFORMATION      info;
   
   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nAces = info.AceCount;
      }
      else
      {
//         DWORD rc=GetLastError();
      }
   }
   return nAces;
}

DWORD                                     // ret- number of free bytes in the ACL
   TSD::ACLGetFreeBytes(
      PACL                   acl          // in - DACL or SACL
   )
{
   int                       nFree = 0;

   ACL_SIZE_INFORMATION      info;

   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nFree = info.AclBytesFree;
      }
   }
   return nFree;
}


DWORD                                     // ret- number of used bytes in the ACL
   TSD::ACLGetBytesInUse(
      PACL                   acl          // in - DACL or SACL
   )
{
   int                       nBytes = 0;

   ACL_SIZE_INFORMATION      info;

   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nBytes = info.AclBytesInUse;
      }
   }
   return nBytes;
}



void *                                     // ret- pointer to ace  
   TSD::ACLGetAce(
      PACL                   acl,          // in - DACL or SACL
      int                    ndx           // in - index of ace to retrieve
   )
{
   void                    * ace = NULL;

   if ( ndx < ACLGetNumAces(acl) )
   {
      if ( ! GetAce(acl,ndx,(void**)&ace) )
      {
         ace = NULL;
      }
   }
   else
   {
      MCSASSERT(FALSE); // you specified a non-existant index
   }
   return ace;
}  

void 
   TSD::ACLDeleteAce(
      PACL                      acl,      // in - DACL or SACL
      int                       ndx       // in - index of ace to delete
   )
{
   int                       nAces = ACLGetNumAces(acl);

   if ( ndx < nAces )
   {
      DeleteAce(acl,ndx);
   }
   else
   {
      MCSASSERT(FALSE); // you specified an invalid index
   }
}

// Access allowed aces are added at the beginning of the list, access denied aces are added at the end of the list
// Note: ppAcl and pAce should be of the same revision level, otherwise AddAce will fail
//       Most usage of ACLAddAce includes two situations:
//           1) pAce is from ppAcl or a copy of ace from ppAcl
//           2) ppAcl is NULL and pAce is ACCESS_ALLOWED_ACE_TYPE
void 
   TSD::ACLAddAce(
      PACL                 * ppAcl,        // i/o- DACL or SACL (this function may reallocate if the acl doesn't have room
      TACE                 * pAce,         // in - ACE to add
      int                    pos           // in - position
   )
{
    DWORD                     ndx = (DWORD)pos;
    DWORD                     rc;
    PACL                      acl = (*ppAcl);
    PACL                      newAcl = NULL;
    BOOL bSuccess = TRUE;  // indicates whether the ACE has been added into the ACL
    BOOL bOwnAcl = FALSE;  // indicates whether the passed ACL is NULL so that we have to create it
    DWORD                     numaces = ACLGetNumAces(acl);
    DWORD                     freebytes = ACLGetFreeBytes(acl);

    // allocate a new ACL if it doesn't already exist
    if ( ! acl )
    {
        bOwnAcl = TRUE;
        acl = (PACL) malloc(SD_DEFAULT_ACL_SIZE);
        if (!acl)
            return;
        InitializeAcl(acl,SD_DEFAULT_ACL_SIZE,ACL_REVISION);
        numaces = ACLGetNumAces(acl);
        freebytes = ACLGetFreeBytes(acl);
    }

    if ( pos == -1 )
    {
        if ( pAce->IsAccessAllowedAce() )
        {
            ndx = 0;
        }
        else
        {
            ndx = MAXDWORD; // insert at end of the list
        }
    }

    WORD                      currAceSize = pAce->GetSize();

    if ( freebytes < currAceSize ) // we must allocate more space for the ace
    {
        // if acl is created by us, we need to free it first
        if (bOwnAcl)
        {
            free(acl);
            acl = NULL;
        }
        
        // make a bigger acl
        newAcl = (ACL*)malloc(ACLGetBytesInUse(acl) + freebytes + currAceSize);
        if (!newAcl)
        {
            bSuccess = FALSE;
        }
        else
        {
            memcpy(newAcl,acl,ACLGetBytesInUse(acl) + freebytes);
            newAcl->AclSize +=currAceSize;
            acl = newAcl;
        }
    }

    if (bSuccess)
    {
        if (!pAce->GetBuffer())
        {
            bSuccess = FALSE;
        }
    }

    if  (bSuccess)
    {
        if (! AddAce(acl,acl->AclRevision,ndx,pAce->GetBuffer(),currAceSize) )
        {
            bSuccess = FALSE;
        }
    }

    if (!bSuccess)
    {
        if (newAcl)
            free(newAcl);
        else if (bOwnAcl)  // if acl is created by us, we need to free it
                                    // note: we only need to do this when newAcl is NULL
            free(acl);
        acl = NULL;
    }

    (*ppAcl) = acl;
} 

// creates a new ace with the specified properties
   TACE::TACE(
      BYTE                   type,         // in - type of ace (ACCESS_ALLOWED_ACE_TYPE, etc.)
      BYTE                   flags,        // in - ace flags (controls inheritance, etc.  use 0 for files)
      DWORD                  mask,         // in - access control mask (see constants in sd.hpp)
      PSID                   sid           // in - pointer to sid for this ace
   )
{
   MCSVERIFY(sid);
   // allocate memory for the new ace
   DWORD                      size = (sizeof ACCESS_ALLOWED_ACE) + GetLengthSid(sid) - (sizeof DWORD);

   m_pAce = (ACCESS_ALLOWED_ACE *)malloc(size);

   // Initialize the ACE
   if (m_pAce)
   {
      m_bNeedToFree = TRUE;
      m_pAce->Header.AceType = type;
      m_pAce->Header.AceFlags = flags;
      m_pAce->Header.AceSize = (WORD) size;
      m_pAce->Mask = mask;
      memcpy(&m_pAce->SidStart,sid,GetLengthSid(sid));
   }
}

BYTE                          // ret- ace type (ACCESS_ALLOWED_ACE_TYPE, etc.)
   TACE::GetType()
{
   MCSVERIFY(m_pAce);

   BYTE                      type = ACCESS_ALLOWED_ACE_TYPE;

   if (m_pAce)
	  type = m_pAce->Header.AceType;
   
   return type;
}

BYTE                         // ret- ace flags (OBJECT_INHERIT_ACE, etc.)
   TACE::GetFlags()
{
   MCSVERIFY(m_pAce);

   BYTE                      flags = OBJECT_INHERIT_ACE;
   
   if (m_pAce)
	  flags = m_pAce->Header.AceFlags;
   
   return flags;
}

DWORD                        // ret- access control mask
   TACE::GetMask()
{
   MCSVERIFY(m_pAce);

   DWORD                     mask = 0;
   
   if (m_pAce)
	  mask = m_pAce->Mask;
   
   return mask;

}

PSID                        // ret- sid for this ace
   TACE::GetSid()
{
   MCSVERIFY(m_pAce);

   PSID                      pSid = NULL;
   
   if (m_pAce)
	  pSid = &m_pAce->SidStart;

   return pSid;
}

WORD                       // ret- size of the ace, in bytes
   TACE::GetSize()
{
   MCSVERIFY(m_pAce);

   WORD                      size = 0;
   
   if (m_pAce)
	  size = m_pAce->Header.AceSize;

   return size;
}

   
BOOL                                   
   TACE::SetType(
      BYTE                   newType   // in -new type for ace
   )
{
   MCSVERIFY(m_pAce);

   if (!m_pAce)
	  return FALSE;
   
   MCSASSERT( newType=ACCESS_ALLOWED_ACE_TYPE || 
              newType==ACCESS_DENIED_ACE_TYPE || 
              newType==SYSTEM_AUDIT_ACE_TYPE  );

   m_pAce->Header.AceType = newType;           

   return TRUE;
}

BOOL 
   TACE::SetFlags(
      BYTE                   newFlags     // in - new flags for ace
   )
{
   MCSVERIFY(m_pAce);
  
   if (!m_pAce)
	  return FALSE;
   
   m_pAce->Header.AceFlags = newFlags;

   return TRUE;
}

BOOL 
   TACE::SetMask(
      DWORD                  newMask       // in - new access control mask
   )
{
   MCSVERIFY(m_pAce);

   if (!m_pAce)
	  return FALSE;
   
   m_pAce->Mask = newMask;

   return TRUE;
}

DWORD 
   TACE::SetSid(
      PSID                   sid           // in - new SID for this ace
   )
{
   DWORD                    result = SET_SID_NOTLARGEENOUGH;

   MCSVERIFY( m_pAce );
   MCSASSERT( IsValidSid(sid) );   
   
   if (!m_pAce)
	  return SET_SID_FAILED;
   
   if ( GetLengthSid(sid) <= GetLengthSid(GetSid()) )
   {
      memcpy(&m_pAce->SidStart,sid,GetLengthSid(sid));
      result = SET_SID_SUCCEEDED;
   }
   return result;
}

BOOL 
   TACE::IsAccessAllowedAce()
{
   MCSVERIFY(m_pAce);
   
   return ( GetType() == ACCESS_ALLOWED_ACE_TYPE );      
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\pwgen.cpp ===
//#pragma title( "PwGen.cpp - PasswordGenerate implementation" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  PwGen.cpp
System      -  EnterpriseAdministrator
Author      -  Steven Bailey, Marcus Erickson
Created     -  1997-05-30
Description -  PasswordGenerate implementation
Updates     -
===============================================================================
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <WinCrypt.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "pwgen.hpp"

DWORD __stdcall GenerateRandom(DWORD dwCount, BYTE* pbRandomType, BYTE* pbRandomChar);

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate a password from the rules provided.
// Returns ERROR_SUCCESS if successful, else ERROR_INVALID_PARAMETER.
// If successful, the new password is returned in the supplied buffer.
// The buffer must be long enough to hold the minimum length password
//   that is required by the rules, plus a terminating NULL.
DWORD __stdcall                            // ret-EA/OS return code
   EaPasswordGenerate(
      DWORD                  dwMinUC,              // in -minimum upper case chars
      DWORD                  dwMinLC,              // in -minimum lower case chars
      DWORD                  dwMinDigits,          // in -minimum numeric digits
      DWORD                  dwMinSpecial,         // in -minimum special chars
      DWORD                  dwMaxConsecutiveAlpha,// in -maximum consecutive alpha chars
      DWORD                  dwMinLength,          // in -minimum length
      WCHAR                * newPassword,          // out-returned password
      DWORD                  dwBufferLength        // in -returned area buffer length
   )
{
   DWORD dwMaxLength = PWGEN_MAX_LENGTH;
   DWORD dwNewLength;      // actual length of new password
   DWORD dwUC = dwMinUC;   // actual numbers of these characters
   DWORD dwLC = dwMinLC;
   DWORD dwDigits = dwMinDigits;
   DWORD dwSpecial = dwMinSpecial;
   DWORD dwActualLength = dwUC + dwLC + dwDigits + dwSpecial;  // total length specified by the minima
   TCHAR pszNewPassword[PWGEN_MAX_LENGTH+1];                   // out-returned password
   BYTE  bRandomType[PWGEN_MAX_LENGTH];                        // cryptographically generated random bytes for type
   BYTE  bRandomChar[PWGEN_MAX_LENGTH];                        // cryptographically generated random bytes for character
   const TCHAR *szSourceString[4] = {                          // the lists of characters by type
      { TEXT("ABDEFGHJKLMNQRTY") },
      { TEXT("abcdefghkmnpqrstuvwxyz") },
      { TEXT("23456789") },
      { TEXT("~!@#$%^+=") }
      };
   DWORD dwToPlace[4];  // number of characters of a type to place
   int   iType[4];      // type of each character class
   int   iTypes;        // total number of types
   enum {               // types of chars
      eUC = 0,
      eLC,
      eDigit,
      eSpecial
   };

   DWORD err;

   // Sanity checking

   // Does the minimum passed to us exceed the maximum?
   if (dwMinLength > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Adjust the minimum length
   dwMinLength = max(dwMinLength, dwMinUC + dwMinLC + dwMinDigits + dwMinSpecial);
   dwMinLength = max(dwMinLength, PWGEN_MIN_LENGTH);

   // Do the minimum requirements make the password too long?
   if ((dwMinUC + dwMinLC + dwMinDigits + dwMinSpecial) > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Adjust maximum length to size of buffer.
   dwMaxLength = min(dwMaxLength, dwBufferLength - 1);

   // Do the min LC and UC characters make it impossible to satisfy the maximum consecutive alpha characters?
   if (dwMaxConsecutiveAlpha) {
      if (dwMaxLength - dwMaxLength / (dwMaxConsecutiveAlpha + 1) < (dwMinUC + dwMinLC))
         return ERROR_INVALID_PARAMETER;
   }

   // Adjust the minimum length to accomodate the rules about max consecutive alphas.
   if (dwMaxConsecutiveAlpha) {
      DWORD dwTotalAlpha = dwUC + dwLC;
      if (dwTotalAlpha) {
         DWORD dwMinGroups = dwTotalAlpha / dwMaxConsecutiveAlpha;   // we need at least this minus one separators
         if (dwTotalAlpha % dwMaxConsecutiveAlpha)
            ++dwMinGroups;

         dwMinLength = max(dwMinLength, dwTotalAlpha + dwMinGroups - 1);
      }
   }

   // Check confirmed min length against maximum length.
   if (dwMinLength > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Seed the random-number generator with current time so that
   // the numbers will be different every time we run.
#ifndef _DEBUG
   // Note for debugging: If this is run in a tight loop, the tick count
   // won't be incrementing between calls, so the same password will generate
   // repeatedly. That doesn't help you test anything.
   srand( (int)GetTickCount() );
#endif

   // Determine the actual length of new password.
   dwNewLength = dwMinLength;

   // Adjust max consecutive alpha
   if (dwMaxConsecutiveAlpha == 0)
      dwMaxConsecutiveAlpha = dwNewLength;

   // Determine the actual numbers of each type of character.
   if (dwActualLength < dwNewLength) {
      // Try to pad with alphabetic characters.
      // Determine the maximum number of alpha characters that could be added.
      int   iAddAlpha = (int)(dwNewLength - dwNewLength / (dwMaxConsecutiveAlpha + 1) - (dwUC + dwLC));

      // It cannot exceed the number of characters we need.
      if ((DWORD)iAddAlpha > (dwNewLength - dwActualLength))
         iAddAlpha = (int)(dwNewLength - dwActualLength);

      dwLC += (DWORD)iAddAlpha;
      dwActualLength += (DWORD)iAddAlpha;
   }

   // Make certain there are enough groups.
   if (dwActualLength < dwNewLength)
      // The padding is separators.
      dwDigits += dwNewLength - dwActualLength;

   // Prepare to generate the characters.
   dwToPlace[0] = dwUC;
   dwToPlace[1] = dwLC;
   dwToPlace[2] = dwDigits;
   dwToPlace[3] = dwSpecial;
   iType[0] = eUC;
   iType[1] = eLC;
   iType[2] = eDigit;
   iType[3] = eSpecial;
   iTypes   = 4;
   for (int iPos = 0; iPos < iTypes; ) {
      if (!dwToPlace[iPos]) {
         for (int iNextPos = iPos + 1; iNextPos < iTypes; ++iNextPos) {
            dwToPlace[iNextPos - 1] = dwToPlace[iNextPos];
            iType[iNextPos - 1] = iType[iNextPos];
         }
         --iTypes;
      }
      else
         ++iPos;
   }
   // Result: dwToPlace[0..iTypes - 1] contain all non-zero values;
   //         iType[0..iTypes - 1] contain the type of character they represent.

   // generate cryptographically random bytes
   // for choosing both the character type and character
   err = GenerateRandom(dwNewLength, bRandomType, bRandomChar);
   if (err != ERROR_SUCCESS)
   {
       return err;
   }

   // Generate a string.
   DWORD dwConsecAlpha = 0;
   int   iRemainingAlpha = (int)(dwUC + dwLC);
   int   iTypeList[PWGEN_MAX_LENGTH];     // A distributed list of types.
   for (int iNewChar = 0; (DWORD)iNewChar < dwNewLength; ++iNewChar) {
      // Determine whether the next char must be alpha or must not be alpha.
      BOOL  bMustBeAlpha = FALSE;
      BOOL  bMustNotBeAlpha = dwConsecAlpha == dwMaxConsecutiveAlpha;

      // If it can be alpha, determine whether it HAS to be alpha.
      if (!bMustNotBeAlpha) {
         // If, among the remaining chars after this one, it would be impossible to
         // fit the remaining alpha chars due to constraints of dwMaxConsecutiveAlpha,
         // then this character must be alpha.

         // Determine the minimum number of groups if we put remaining alpha chars
         // into groups that are the maximum width.
         int   iMinGroups = iRemainingAlpha / (int)dwMaxConsecutiveAlpha;
         if (iRemainingAlpha % (int)dwMaxConsecutiveAlpha)
            ++iMinGroups;

         // Determine the minimum number of non-alpha characters we'll need.
         int   iMinNonAlpha = iMinGroups - 1;

         // Determine the characters remaining.
         int   iRemaining = (int)dwNewLength - iNewChar;

         // Is there room for a non-alpha char here?
         if (iRemaining <= (iRemainingAlpha + iMinNonAlpha))
            // no.
            bMustBeAlpha = TRUE;
      }

      // Determine the type range.
      int   iMinType = 0;
      int   iMaxType = iTypes - 1;

      // If next char must be alpha, then alpha chars remain.
      // Type position 0 contains either UC or LC.
      // Type position 1 contains LC, non-alpha, or nothing.
      if (bMustBeAlpha) {
         if ((iType[1] == eLC) && (iTypes > 1))
            iMaxType = 1;
         else
            iMaxType = 0;
      }
      // If next char may not be alpha, there may be no alpha left to generate.
      // If so, type position 0 is non-alpha.
      // O.w., type positions 0 and 1 may both be alpha.
      else if (bMustNotBeAlpha) {
         if (iRemainingAlpha) {
            if (iType[1] >= eDigit)
               iMinType = 1;
            else
               iMinType = 2;
         }
      }

      // Get the type to generate.
      int            iTypePosition;
      int            iTypeToGenerate;
      const TCHAR   *pszSourceString;

      if (iMinType == iMaxType)  // There's only one type. Use it.
         iTypePosition = iMinType;
      else {
         // This algorithm distributes the chances for various types.
         // If there are 13 LCs to place and one special, there's a
         // 13/14 chance of placing an LC and a 1/14 chance of placing a
         // special, due to this algorithm.
         int   iNextTypePosition = 0;

         for (int i = iMinType; i <= iMaxType; ++i) {
            for (int j = 0; j < (int)dwToPlace[i]; ++j) {
               iTypeList[iNextTypePosition++] = i;
            }
         }

         iTypePosition = iTypeList[bRandomType[iNewChar] % iNextTypePosition];
      }

      iTypeToGenerate = iType[iTypePosition];
      pszSourceString = szSourceString[iTypeToGenerate];

      // Generate the next character.
	  pszNewPassword[iNewChar] = pszSourceString[bRandomChar[iNewChar] % UStrLen(pszSourceString)];

      // Keep track of those alphas.
      if (iTypeToGenerate < eDigit) {
         ++dwConsecAlpha;
         --iRemainingAlpha;
      }
      else
         dwConsecAlpha = 0;

      // Update the types to generate.
      if (!--dwToPlace[iTypePosition]) {
         for (int iNextTypePosition = iTypePosition + 1; iNextTypePosition < iTypes; ++iNextTypePosition) {
            dwToPlace[iNextTypePosition - 1] = dwToPlace[iNextTypePosition];
            iType[iNextTypePosition - 1] = iType[iNextTypePosition];
         }
         --iTypes;
      }
   }

   pszNewPassword[dwNewLength] = '\0';

   UStrCpy( newPassword, pszNewPassword );

   return ERROR_SUCCESS;
} /* PasswordGenerate() */


// GenerateRandom
//
// Fills buffers with cryptographically random bytes.

DWORD __stdcall GenerateRandom(DWORD dwCount, BYTE* pbRandomType, BYTE* pbRandomChar)
{
	bool bGenerated = false;

	HCRYPTPROV hProv = NULL;

	if (CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		if (CryptGenRandom(hProv, dwCount, pbRandomType) && CryptGenRandom(hProv, dwCount, pbRandomChar))
		{
			bGenerated = true;
		}

		CryptReleaseContext(hProv, 0);
	}

	// if cryptographic generation fails, don't fallback, we don't
	// want to risk predictable passwords

	if (!bGenerated)
	{
        return GetLastError();
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\sdhelper.cpp ===
#include <windows.h>
#include <objbase.h>
#include "sdhelper.h"
#include "commalog.hpp"

#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define USERS              6
#define SYSTEM             7

PSID ConvertSID(PSID originalSid)
{
    DWORD sidLen = GetLengthSid(originalSid);
    PSID copiedSid = (PSID) malloc(sidLen);
    if (copiedSid)
    {
        if (!CopySid(sidLen, copiedSid, originalSid))
        {
            free(copiedSid);
            copiedSid = NULL;
        }
    }
    return copiedSid;
}

TSD* BuildAdminsAndSystemSDForCOM()
{
    return BuildAdminsAndSystemSD(COM_RIGHTS_EXECUTE);
}

TSD* BuildAdminsAndSystemSD(DWORD accessMask)
{
    TSD* builtSD = NULL;
    PSID adminsSid = GetWellKnownSid(ADMINISTRATORS);
    PSID systemSid = GetWellKnownSid(SYSTEM);
    if (adminsSid && systemSid)
    {
        PSID copiedAdminsSid = ConvertSID(adminsSid);
        PSID groupSid = ConvertSID(adminsSid);
        builtSD = new TSD(McsUnknownSD);
        BOOL bSuccess = FALSE;
        if (copiedAdminsSid && groupSid && builtSD)
        {
            TACE adminsAce(ACCESS_ALLOWED_ACE_TYPE,0,accessMask,copiedAdminsSid);
            TACE systemAce(ACCESS_ALLOWED_ACE_TYPE,0,accessMask,systemSid);

            // see if both TACE objects get allocated properly
            if (adminsAce.GetBuffer() && systemAce.GetBuffer())
            {
                PACL acl = NULL;  // start with an empty ACL
                PACL tempAcl;

                builtSD->ACLAddAce(&acl,&adminsAce,-1);
                if (acl != NULL)
                {
                    tempAcl = acl;
                    builtSD->ACLAddAce(&acl,&systemAce,-1);
                    if (acl != tempAcl)
                        free(tempAcl);
                }
                
                if (acl != NULL)
                {
                    // need to set the owner
                    builtSD->SetOwner(copiedAdminsSid);
                    copiedAdminsSid = NULL;  // memory is taken care of by builtSD destructor

                    // need to set the group
                    builtSD->SetGroup(groupSid);
                    groupSid = NULL;  // memory is taken care of by builtSD destructor
                
                    // set the DACL part                                            
                    builtSD->SetDacl(acl,TRUE);  // builtSD destructor will take care of acl

                    bSuccess = TRUE;
                }
            }
        }

        if (!bSuccess)
        {
            if (copiedAdminsSid)
                free(copiedAdminsSid);
            if (groupSid)
                free(groupSid);
            if (builtSD)
            {
                delete builtSD;
                builtSD = NULL;
            }
        }
    }

    if (adminsSid)
        FreeSid(adminsSid);

    if (systemSid)
        FreeSid(systemSid);

    return builtSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\secobj.cpp ===
/*Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecureObject.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes for objects that have security descriptors.
               
               TSecurableObject has a derived class for each type of object 
               we will process security descriptors for.  This class handles reading 
               and writing the security descriptor.  It contains a TSD object, which 
               will handle manipulation of the SD while it is in memory.

               The TSecurableObject class also contains functions to translate a security 
               descriptor, given an account mapping cache.  These routines are only included
               in the class if the preprocessor directive SDRESOLVE is #defined.  This allows
               the TSecurableObject class to be used for generic security descriptor manipulation,
               where the rest of the ACL translation code is not needed.

Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#   include <process.h>
#endif

#include <stdio.h>
#include <iostream.h>
#include <assert.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "Ustring.hpp"
#include "sd.hpp"
#include "SecObj.hpp"


#ifdef SDRESOLVE
   #include "sidcache.hpp"
   #include "enumvols.hpp"
   #include "txtsid.h"
#endif

#define PRINT_BUFFER_SIZE           2000

extern TErrorDct              err;

 
  TSecurableObject::~TSecurableObject()
{
#ifdef SDRESOLVE
   TStatNode *node;
   for ( node = (TStatNode *)changelog.Head() ; node ; node = (TStatNode * )changelog.Head() )
   {
      changelog.Remove((TNode *)node);
      delete node;
   }
#endif   
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }

   if ( m_sd )                        
   {
      delete m_sd; 
   }
}

#ifdef SDRESOLVE
PACL                                // ret -pointer to Resolved ACL 
   TSecurableObject::ResolveACL(
      PACL                   oldacl,      // in -acl to resolve
      TAccountCache        * cache,       // in -cache to lookup sids
      TSDResolveStats      * stat,        // in -stats object
      bool                 * changes,     // i/o-flag whether this SD has been modified
      BOOL                   verbose,     // in -flag whether to display lots of junk
      int                    opType,      // in - ADD_SECURITY, REPLACE_SECURITY, or REMOVE_SECURITY
      objectType             objType,     // in - the type of the object
      BOOL                   bUseMapFile  // in - flag - whether we are using a sID mapping file
   )
{  
   int                       nAces,curr;
   TRidNode                * tnode;
   PSID                      ps;
   bool                      aclchanges = false;
   PACL                      acl = oldacl;
   void                    * pAce;
   DWORD                     dwResult;

   nAces = m_sd->ACLGetNumAces(acl);
   
   for ( curr = 0 ; curr < nAces;  )
   {
      pAce = m_sd->ACLGetAce(acl,curr);
      if ( pAce )
      {
         TACE                 ace(pAce);  // in this case, the ace object does not take ownership of pAce
         ps = ace.GetSid();
         
         if (!bUseMapFile)
            tnode =(TRidNode *)cache->Lookup(ps);
         else
            tnode =(TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps);
         
         if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
         {
            if ( stat )
               stat->IncrementSACEExamined();
         }
         else
         {
            if ( stat) 
               stat->IncrementDACEExamined();
         }  

         if ( tnode == NULL )
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACENotSelected(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACENotSelected(this);
            }
      
         }

//         if ( (int)tnode == -1 )    // from Totally unknown
         if ( tnode == (TRidNode*)-1 )    // from Totally unknown
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACEUnknown(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACEUnknown(this);
            }
            tnode = NULL;
         }
   
         if ( tnode && (tnode->IsValidOnTgt() || opType == REMOVE_SECURITY) ) 
         {
            if ( verbose ) 
               DisplaySid(ps,cache);
            
            if (!bUseMapFile)
               ps = cache->GetTgtSid(tnode);
            else
               ps = ((TSDRidCache*)cache)->GetTgtSidWODomain(tnode);
            
            bool bChanged = false;
            
            // we need to get ACE type here because it is possible that the following two logics make
            // ace point to a freed block memory:
            //    1.  the later ACLAddAce creates a new ACL to fit in the added ACE (ADD_SECURITY case)
            //    2.  and after the ACLAddAce, there is the following code to free tempAcl which actually
            //         points to the acl where ace lives in
            //         if ( acl != tempAcl )
            //         {
            //            // we had to reallocate when we added the ace
            //            if ( tempAcl != oldacl )
            //            {
            //               // we had already reallocated once before -- free the intermediate acl
            //               free(tempAcl);
            //            }
            //         }
            // then ace.GetType() will AV.
            BYTE aceType = ace.GetType();
            
            switch ( opType )
            {
            case REPLACE_SECURITY:
               if (ps)
               {
                  aclchanges = true;
                  bChanged = true;
                  dwResult = ace.SetSid(ps);
                  if(dwResult == SET_SID_FAILED)
                  {
                     // we should not go on anymore since something really goes wrong, like out of memory
                     free(ps);
                     return NULL;
                  }
                  else if(dwResult == SET_SID_NOTLARGEENOUGH)
                  {
                     // it means that the new ace is larger than the ace we have
                     TACE* pTempAce = new TACE(ace.GetType(), ace.GetFlags(), ace.GetMask(), ps);
                     if(!pTempAce)
                     {
                         free(ps);
                         return NULL;
                     }
                     // remove the old ace
                     m_sd->ACLDeleteAce(acl, curr);
                     // add the new ace
                     m_sd->ACLAddAce(&acl, pTempAce, curr);
                     // release the memory
                     delete pTempAce;
                     
                  }
                  curr++;
               }
               break;
            case ADD_SECURITY:
               {
                  if (ps)
                  {
                     TACE       otherAce(ace.GetType(),ace.GetFlags(),ace.GetMask(),ps);
                             
                     PACL       tempAcl = acl;

                     // check to make sure we're not adding duplicates
                     // check the next ace, to see if it matches the one we're about to add
                     // unfortunately, we have to go through all ACE's
                     BOOL       bOkToAdd = TRUE;
                     for (int index = 0; index < nAces; index++)
                     {
                        TACE oldAce(m_sd->ACLGetAce(acl, index));
                        // check ACE type, flag, mask and sid parts
                        // note: ignore the ace size part because it is not determining factor
                        if (EqualSid(otherAce.GetSid(), oldAce.GetSid()) && otherAce.GetType() == oldAce.GetType()
                            && otherAce.GetFlags() == oldAce.GetFlags() && otherAce.GetMask() == oldAce.GetMask())
                        {
                            bOkToAdd = FALSE;
                            break;
                        }
                     }

                     if ( bOkToAdd )
                     {
                        m_sd->ACLAddAce(&acl,&otherAce,curr);
                        if (acl) 
                        {
                            aclchanges = true;
                            bChanged = true;
                            curr += 2;
                            nAces++;
                        }
                        else
                        {
                            // right now, if unable to add this particular ace, we simply skip this one
                            acl = tempAcl;  // we need to restore acl otherwise it will AV
                            curr++;
                        }
                     }
                     else
                     {
                        curr++;
                     }
                  
                     if ( acl != tempAcl )
                     {
                        // we had to reallocate when we added the ace
                        if ( tempAcl != oldacl )
                        {
                           // we had already reallocated once before -- free the intermediate acl
                           free(tempAcl);
                        }
                     }
                  }
               }
               break;
            case REMOVE_SECURITY:
               bChanged = true;
               aclchanges = true;
               m_sd->ACLDeleteAce(acl,curr);
               nAces--;
               break;
            }

            if (bChanged)
            {
                if ( aceType == SYSTEM_AUDIT_ACE_TYPE )
                {
                   if ( stat )
                      stat->IncrementSACEChange(tnode,objType,this);
                }
                else
                {
                   if ( stat) 
                      stat->IncrementDACEChange(tnode,objType,this);
                }
            }

            if (ps)
               free(ps);
         }  
         else 
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACENoTarget(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACENoTarget(this);
            }
         
            curr++;
         }
      }
      else
      {
         break;
      }
   }       
   if ( ! aclchanges ) 
   {
      acl = NULL;
   }
   if ( aclchanges )
   {
      (*changes) = true;
   }
   return acl;
}   


bool 
   TSecurableObject::ResolveSD(
      SecurityTranslatorArgs  * args,              // in -translation settings
      TSDResolveStats         * stat,              // in -stats object to increment counters
      objectType                objType,           // in -is this file, dir or share
      TSecurableObject        * Last               // in -Last SD for cache comparison
   )
{
   bool                      changes;
   bool                      iWillBeNewLast;
     
   if ( ! m_sd->m_absSD )  // Couldn't get SD for this object (or it doesn't have one).
   {
      return false;
   }
   MCSASSERT( m_sd && m_sd->IsValid() );

   if ( stat )
      stat->IncrementExamined(objType);

   if ( args->LogVerbose() )
      err.MsgWrite(0,DCT_MSG_EXAMINED_S,pathname);
   
   if ( ! Last || m_sd != Last->m_sd )
   {
      changes = ResolveSDInternal(args->Cache(),stat,args->LogVerbose(),args->TranslationMode(),objType,args->UsingMapFile());
      if ( changes )
      {
         if ( stat )
         {
               stat->IncrementChanged(objType);
         }
         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"BEFORE:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
         if ( ! args->NoChange() ) 
         {
            if ( args->LogMassive() )
            {
               err.DbgMsgWrite(0,L"IN MEMORY:*********************************************",pathname);
               PrintSD(m_sd->m_absSD,pathname);
            }
            WriteSD();
         }
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"AFTER:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      else
      {
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"UNCHANGED:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      iWillBeNewLast = true;
      
   }
   else
   {        // cache hit
      if ( stat )
         stat->IncrementLastFileChanges(Last,objType);
      iWillBeNewLast = false;
      if ( Last->Changed() )
      {
         Last->CopyAccessData(this);
         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"BEFORE:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
         if ( ! args->NoChange() )
            Last->WriteSD();

         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);

         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"AFTER:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      else
      {
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"UNCHANGED:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      if ( stat )
         stat->IncrementCacheHit(objType);
     
   }
   return iWillBeNewLast;
}

bool                                                      // ret -true if changes made, otherwise false
   TSecurableObject::ResolveSDInternal(
      TAccountCache        * cache,                      // in -cache to lookup sids
      TSDResolveStats      * stat,                       // in -stats object
      BOOL                   verbose,                    // in -flag - whether to display stuff
      int                    opType,                     // in -operation type Add, Replace, or Remove
      objectType             objType,                    // in - type of object 
      BOOL                   bUseMapFile                 // in - flag - whether we are using a sID mapping file
   )
{
   /* Examine each part of the SD, looking for SIDs in the cache */
   PSID                      ps;
   TRidNode                * acct;
   bool bIsSDChanged = false;
   PACL                      pacl;
   PACL                      newacl;
   PSID                      newsid;
   
   MCSVERIFY(m_sd);
   
   // Process owner part of SD
   ps = m_sd->GetOwner(); 
   if ( ps )      
   {
      if (!bUseMapFile)
         acct = (TRidNode *)cache->Lookup(ps); // See if owner SID is in the cache
      else
         acct = (TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps); // See if owner SID is in the cache
      if ( stat) 
         stat->IncrementOwnerExamined();
      if (acct == NULL  )
      {
         if ( stat )
            stat->IncrementOwnerNotSelected();
      }
//      else if ((int)acct == -1 )
      else if (acct == (TRidNode*)-1 )
      {
         if (stat)
            stat->IncrementOwnerUnknown();
         unkown = true;
         acct = NULL;
      }
      BOOL bChanged = FALSE;
      if ( acct && acct->IsValidOnTgt() ) 
      {
         if ( verbose ) 
         {
            err.DbgMsgWrite(0,L"Owner: ");
            DisplaySid(ps,cache);
         }
         if (!bUseMapFile)
            newsid = cache->GetTgtSid(acct);
         else
            newsid = ((TSDRidCache*)cache)->GetTgtSidWODomain(acct);
         if (newsid)
         {
                    m_sd->SetOwner(newsid);
                    bChanged = TRUE;
                    owner_changed = TRUE;
                    bIsSDChanged = true;
         }
         //free(newsid);
      }
      else
        stat->IncrementOwnerNoTarget();
      
       if (bChanged && acct && stat )
      {
         stat->IncrementOwnerChange(acct,objType,this);
      }
  }
   // Process primary group part of SD
   ps = m_sd->GetGroup();
   if ( ps )
   {
      if (!bUseMapFile)
         acct = (TRidNode *)cache->Lookup(ps);
      else
         acct = (TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps);
      if ( stat) 
         stat->IncrementGroupExamined();
      if (acct == NULL )
      {
         if ( stat )
            stat->IncrementGroupNotSelected();
      }
//      else if ((int)acct == -1 )
      else if (acct == (TRidNode*)-1 )
      {
         if (stat)
            stat->IncrementGroupUnknown();
         acct = NULL;
         unkgrp = true;
      }
      BOOL bChanged = FALSE;
      if ( acct && acct->IsValidOnTgt() )
      {
         if ( verbose ) 
         {
            err.DbgMsgWrite(0,L"Group: ");
            DisplaySid(ps,cache);
         }
         if (!bUseMapFile)
            newsid = cache->GetTgtSid(acct);
         else
            newsid = ((TSDRidCache*)cache)->GetTgtSidWODomain(acct);
      if (newsid)
      {
            group_changed = true;
            m_sd->SetGroup(newsid);
            bChanged = TRUE;
            bIsSDChanged = TRUE;
      }
         //free(newsid);
      }
      else
        stat->IncrementGroupNoTarget();
      
      if ( bChanged && acct && stat )
      {
         stat->IncrementGroupChange(acct,objType,this);
      }
   }
   
   pacl = m_sd->GetDacl();
   if ( pacl && m_sd->IsDaclPresent() )
   {
      if ( stat )
         stat->IncrementDACLExamined();
      if ( verbose ) 
         err.DbgMsgWrite(0,L"DACL");
      if (!bUseMapFile)
         newacl = ResolveACL(pacl,cache,stat,&bIsSDChanged,verbose,opType,objType, FALSE);
      else
         newacl = ResolveACL(pacl,cache,stat,&bIsSDChanged,verbose,opType,objType, TRUE);
      if ( newacl )
      {
         m_sd->SetDacl(newacl,m_sd->IsDaclPresent());
         dacl_changed = true;
         if ( stat ) 
            stat->IncrementDACLChanged();
      }
   }
   pacl = NULL;
   pacl = m_sd->GetSacl();

   if ( pacl && m_sd->IsSaclPresent() )
   {
      if ( stat )
         stat->IncrementSACLExamined();
      if ( verbose ) 
         err.DbgMsgWrite(0,L"SACL");
      if (!bUseMapFile)
         newacl = ResolveACL(pacl,cache,stat,&bIsSDChanged,verbose,opType,objType, FALSE);
      else
         newacl = ResolveACL(pacl,cache,stat,&bIsSDChanged,verbose,opType,objType, TRUE);
      if ( newacl )
      {
         m_sd->SetSacl(newacl,m_sd->IsSaclPresent());
         sacl_changed = true;
         if ( stat )
            stat->IncrementSACLChanged();
      }
   }
   return bIsSDChanged;
}
#else

WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   )
{
   int                       i;
   WCHAR                   * machinename = NULL; 
   if (    pathname
        && pathname[0] == L'\\'
        && pathname[1] == L'\\'
      )
   {
      for ( i = 2 ; pathname[i] && pathname[i] != L'\\' ; i++ ) 
      ;
      machinename = new WCHAR[i+2];
      if (machinename)
      {
         UStrCpy(machinename,pathname,i+1);
         machinename[i] = 0;
      }
   }
   return machinename;
}


#endif

void 
   TSecurableObject::CopyAccessData(
       TSecurableObject    * sourceFSD    // in - sd from which to copy name & handle
   )
{
   
   pathname[0] = 0;
   safecopy(pathname,sourceFSD->GetPathName());
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
   }
   handle = sourceFSD->handle;   
   sourceFSD->ResetHandle();
}

            
               


/************************************************TFileSD Implementation*************************/
 TFileSD::TFileSD(
      const LPWSTR           path,               // in -pathname for this SD
      bool                   bSystemFile         // in -whether the file is a system file or not
   ) :
   m_bSystemFile(bSystemFile)
{
   daceNS = 0;
   saceNS = 0;
   daceEx = 0;
   saceEx = 0;
   daceU  = 0;
   saceU  = 0;
   daceNT = 0;
   saceNT = 0;
   unkown = false;
   unkgrp = false;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);
}
 

   TFileSD::~TFileSD()
{
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }
   pathname[0]=0;
}

  
// writes the Absolute SD to the file "pathname"  
bool                                         // ret -true iff successful
   TFileSD::WriteSD()
{
//   DWORD                     rc    = 0;
   bool                      error = false;
   SECURITY_DESCRIPTOR     * sd = NULL;
   MCSVERIFY( m_sd && m_sd->IsValid() );
   
   if ( handle == INVALID_HANDLE_VALUE )
   {
      err.MsgWrite(ErrS,DCT_MSG_FST_WRITESD_INVALID);
      error = true;
   }
   SECURITY_INFORMATION si;
   if ( ! error )
   {
      si = 0;
      if ( m_sd->IsOwnerChanged() )
         si |= OWNER_SECURITY_INFORMATION;
      if ( m_sd->IsGroupChanged() )
         si |= GROUP_SECURITY_INFORMATION;
      if ( m_sd->IsDACLChanged() )
         si |=  DACL_SECURITY_INFORMATION;
      if ( m_sd->IsSACLChanged() )
         si |= SACL_SECURITY_INFORMATION;

      sd = m_sd->MakeAbsSD();
      if (!sd)
         return false;
      if ( ! SetKernelObjectSecurity(handle, si, sd ) ) 
      {
         err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_FILE_WRITESD_FAILED_SD,pathname,GetLastError());
         error = true;
      }
      m_sd->FreeAbsSD(sd);
   }
   return ! error;
}

bool                          // ret -pointer to SD, (or NULL if failure)
   TFileSD::ReadSD(
      const LPWSTR           path      // in -file to get SD from
   )
{                                         
   DWORD                     req;
   DWORD                     rc;
//   void                    * r = NULL;
   SECURITY_DESCRIPTOR     * sd = NULL;
   bool                      error = false;
   WCHAR                   * longpath= NULL;

   if ( handle != INVALID_HANDLE_VALUE)
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }
   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   
   if ( UStrLen(path) >= MAX_PATH && path[2] != L'?' )
   {
      longpath = new WCHAR[UStrLen(path) + 10];
      if (!longpath)
         return true;
      UStrCpy(longpath,L"\\\\?\\");
      UStrCpy(longpath + UStrLen(longpath),path);
      
   }
   else
   {
      longpath = path;
   }
   handle = CreateFileW(longpath,
                     READ_CONTROL | ACCESS_SYSTEM_SECURITY | WRITE_OWNER |WRITE_DAC ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_BACKUP_SEMANTICS, 
                     0);
   if ( handle == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_SHARING_VIOLATION )
      {
         //
         // Only generate warning message if not a system file.
         //

         if (!m_bSystemFile)
         {
            err.MsgWrite(ErrW, DCT_MSG_FST_FILE_IN_USE_S, path);
         }
      }
      else
      {
         err.SysMsgWrite(ErrE, rc, DCT_MSG_FST_FILE_OPEN_FAILED_SD,longpath,rc);
      }
      error = true;
   }
   else 
   {
      sd = (SECURITY_DESCRIPTOR *)malloc(SD_DEFAULT_SIZE);
      if (!sd)
      {
         if ( longpath != path )
            delete [] longpath;
         return true;
      }
      req = 0;
      if ( ! GetKernelObjectSecurity(handle, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                      | DACL_SECURITY_INFORMATION
                                                                      | SACL_SECURITY_INFORMATION
                                                                       ,
               sd,
               SD_DEFAULT_SIZE,
               &req) )
      {
         if ( req <= SD_DEFAULT_SIZE )
         {
            err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_FST_GET_FILE_SECURITY_FAILED_SD, 
                            longpath, GetLastError());
             error = true;
         }
         else 
         {
            free(sd);
            sd = (SECURITY_DESCRIPTOR *)malloc(req);
            if (!sd)
            {
               if ( longpath != path )
                  delete [] longpath;
               return true;
            }
            if ( ! GetKernelObjectSecurity(handle,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                             | DACL_SECURITY_INFORMATION
                                                                             | SACL_SECURITY_INFORMATION
                                                                             ,
                  sd,
                  req,
                  &req) )   
            {
               err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_FST_GET_FILE_SECURITY_FAILED_SD,
                            longpath, GetLastError());
               error = true;
            }
         }
      }
   }
   if ( error && sd ) // free the space allocated
   {
      free(sd);
      sd = NULL;
   }
   if ( sd )
   {
      m_sd = new TSD(sd,McsFileSD,TRUE);
      if (!m_sd)
         error = true;
   }
   else
   {
      m_sd = NULL;
   }
   if (! error )
   {
      safecopy(pathname,longpath);
   }
   if ( longpath != path )
      delete [] longpath;

   return error;
}

//////////////////////////TShareSD implementation///////////////////////////////////////////////////////////
TShareSD::TShareSD(
      const LPWSTR           path                // in -pathname for this SD           
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;
   shareInfo = NULL;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);                           
}
 
bool                                       // ret-error=true
   TShareSD::ReadSD(
      const LPWSTR           path          // in -sharename
   )
{
   DWORD                     rc;
//   void                    * r = NULL;
   SECURITY_DESCRIPTOR     * sd = NULL;
   bool                      error = false;
   DWORD                     lenServerName = 0;

   if ( m_sd )
   {
      delete m_sd;
   }

   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   serverName = GetMachineName(path);

   if ( serverName )
      lenServerName = UStrLen(serverName) + 1;
   
   safecopy(pathname,path + lenServerName);
      

   rc = NetShareGetInfo(serverName, pathname, 502, (LPBYTE *)&shareInfo);
   if ( rc )
   {
      err.SysMsgWrite(ErrE, rc, DCT_MSG_FST_GET_SHARE_SECURITY_FAILED_SD, 
                      path, rc);
      error = true;
   }
   else
   {
      sd = (SECURITY_DESCRIPTOR *)shareInfo->shi502_security_descriptor;
      if ( sd )
      {
         m_sd = new TSD(sd,McsShareSD,FALSE);
         if (!m_sd)
            error = true;
      }
      else
      {
         m_sd = NULL;
      }
   }
  
   return error;
}


//------------------------------------------------------------------------------
// SetSD Method
//
// Synopsis
// Sets a security descriptor to be assigned to the share. This is needed in
// the case where a security descriptor does not already exist on the share
// which is the case with a newly created share that was not assigned a
// security descriptor.
//
// Arguments
// IN sd - pointer to security descriptor class which defines the security
//         descriptor to be assigned to the share
//
// Return
// The boolean return value is true if security descriptor is successfully
// set otherwise it is false.
//------------------------------------------------------------------------------

bool TShareSD::SetSD(TSD* sd)
{
    if (m_sd)
    {
        delete m_sd;
    }

    m_sd = new TSD(sd);

    return (m_sd != NULL);
}


bool                                       // ret-error=true
   TShareSD::WriteSD()
{
   bool                      error   = false;
   DWORD                     rc      = 0;
   DWORD                     parmErr = 0;
   SECURITY_DESCRIPTOR     * pSD = NULL;   

   // Build an absolute SD
   if ( m_sd )
   {
      pSD = m_sd->MakeAbsSD();
      if (!pSD)
         return false;
      shareInfo->shi502_security_descriptor = pSD;
   
      rc = NetShareSetInfo(serverName,pathname,502,(BYTE *)shareInfo,&parmErr);
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_FST_SHARE_WRITESD_FAILED_SD,pathname,rc);
      }
      free(pSD);
   }
   else
   {
      MCSASSERT(FALSE); // SD does not exist
   }
   return error;
}


TRegSD::TRegSD(
      const LPWSTR           path,               // in -pathname for this SD           
      HKEY                   hKey                // in -handle for the registry key
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   m_hKey = hKey;
   ReadSD(m_hKey);                           
}

bool 
   TRegSD::ReadSD(HKEY       hKey)
{
   DWORD                     rc = 0;
   DWORD                     lenBuffer = SD_DEFAULT_SIZE;
   SECURITY_DESCRIPTOR     * sd = NULL;

   m_hKey = hKey;

   sd = (SECURITY_DESCRIPTOR *)malloc(SD_DEFAULT_SIZE);
   if (!sd)
      return false;

   rc = RegGetKeySecurity(hKey,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                          | DACL_SECURITY_INFORMATION
                                                          | SACL_SECURITY_INFORMATION,
                                                          sd,&lenBuffer);

   if ( rc == ERROR_INSUFFICIENT_BUFFER )
   {
      free(sd);
      
      sd = (SECURITY_DESCRIPTOR *)malloc(lenBuffer);
      if (!sd)
         return false;
      rc = RegGetKeySecurity(hKey,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                             | DACL_SECURITY_INFORMATION
                                                             | SACL_SECURITY_INFORMATION,
                                                               sd,&lenBuffer);
   }                                       

   if ( rc )
   {
      free(sd);
   }
   else
   {
      m_sd = new TSD(sd,McsRegistrySD,TRUE);
      if (!m_sd)
         rc = ERROR_NOT_ENOUGH_MEMORY;
   }
   return ( rc == 0 );
}

bool
   TRegSD::WriteSD()
{
   DWORD                     rc = 0;
   SECURITY_DESCRIPTOR     * sd = NULL;
   
   MCSVERIFY( m_sd && m_sd->IsValid() );
   
   SECURITY_INFORMATION si;
   
   si = 0;
   if ( m_sd->IsOwnerChanged() )
      si |= OWNER_SECURITY_INFORMATION;
   if ( m_sd->IsGroupChanged() )
      si |= GROUP_SECURITY_INFORMATION;
   if ( m_sd->IsDACLChanged() )
      si |=  DACL_SECURITY_INFORMATION;
   if ( m_sd->IsSACLChanged() )
      si |= SACL_SECURITY_INFORMATION;

   sd = m_sd->MakeAbsSD();     
   if (!sd)
      return false;
   
   rc = RegSetKeySecurity(m_hKey,si,sd);

   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_REG_SD_WRITE_FAILED_SD,name,rc);
   }
   m_sd->FreeAbsSD(sd);
   
   return ( rc == 0 );
}



//////////////////////////TPrintSD implementation///////////////////////////////////////////////////////////
TPrintSD::TPrintSD(
      const LPWSTR           path                // in -pathname for this SD           
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;
   buffer    = NULL;
   
   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);                           
}
 
bool                                       // ret-error=true
   TPrintSD::ReadSD(
      const LPWSTR           path          // in -sharename
   )
{
   DWORD                     rc = 0;
   SECURITY_DESCRIPTOR     * sd = NULL;
   
   if ( m_sd )
   {
      delete m_sd;
   }

   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   PRINTER_DEFAULTS         defaults;
   DWORD                    needed = 0;
   PRINTER_INFO_3         * pInfo;

   defaults.DesiredAccess = READ_CONTROL | PRINTER_ACCESS_ADMINISTER | WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY;
   defaults.pDatatype = NULL;
   defaults.pDevMode = NULL;

   buffer = new BYTE[PRINT_BUFFER_SIZE];
   if (!buffer)
      return false;

   // Get the security descriptor for the printer

   if(hPrinter != INVALID_HANDLE_VALUE)
   {
      // we need to release the handle 
      ClosePrinter(hPrinter);
   }
   
   if ( ! OpenPrinter(path,&hPrinter,&defaults) )
   {
      // set the handle to default value
      hPrinter = INVALID_HANDLE_VALUE;
      
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_OPEN_PRINTER_FAILED_SD,path,rc);
   }
   else
   {
      if ( ! GetPrinter(hPrinter,3,buffer,PRINT_BUFFER_SIZE,&needed) )
      {
         rc = GetLastError();
         if ( rc == ERROR_INSUFFICIENT_BUFFER )
         {
            delete [] buffer;
            buffer = new BYTE[needed];
            if (!buffer)
               rc = ERROR_NOT_ENOUGH_MEMORY;
            else if (! GetPrinter(hPrinter,3,buffer, needed, &needed ) )
            {
               rc = GetLastError();
            }
         }
      }
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_PRINTER_FAILED_SD,path,rc);
      }
      else
      {
         pInfo = (PRINTER_INFO_3*)buffer;         
         
         sd = (SECURITY_DESCRIPTOR *)pInfo->pSecurityDescriptor;
            
         if ( sd )
         {
            m_sd = new TSD(sd,McsPrinterSD,FALSE);
            if (!m_sd)
               rc = ERROR_NOT_ENOUGH_MEMORY;
         }
         else
         {
            m_sd = NULL;
         }
            
      }
   }
   return (rc == 0);
}
   


bool                                       // ret-error=true
   TPrintSD::WriteSD()
{
//   bool                      error   = false;
   DWORD                     rc      = 0;
   SECURITY_DESCRIPTOR     * pSD = NULL;   
   PRINTER_INFO_3            pInfo;

   // Build an absolute SD
   MCSVERIFY(hPrinter != INVALID_HANDLE_VALUE);
   if ( m_sd )
   {
      pSD = m_sd->MakeAbsSD();
      if (!pSD)
         return false;
      pInfo.pSecurityDescriptor = pSD;
   
      SetLastError(0);
      // Clear the primary group from the security descriptor, since in NT 4, setting a security descriptor
      // with a non-NULL primary group sometimes doesn't work
      SetSecurityDescriptorGroup(pSD,NULL,FALSE);
      
      if (! SetPrinter(hPrinter,3,(LPBYTE)&pInfo,0) )
      {
         rc = GetLastError();
      }
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_PRINTER_WRITESD_FAILED_SD,pathname,rc);
      }
      free(pSD);
   }
   else
   {
      MCSASSERT(FALSE); // SD does not exist
   }
   return (rc == 0);
}


#ifdef SDRESOLVE   
/////////////////////////////////////////////////Utility routines to print security descriptors for debug logging
//#pragma title("PrintSD- Formats/prints security info")
// Author - Tom Bernhardt
// Created- 09/11/93

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <malloc.h>
#include <winbase.h>
#include <lm.h>



#include "common.hpp"
#include "err.hpp"
#include "Ustring.hpp"
 
#define SDBUFFSIZE (sizeof (SECURITY_DESCRIPTOR) + 10000)
static const char            sidType[][16]= {"--0--"  , "User"          ,
                                             "Group"  , "Domain"        ,
                                             "Alias"  , "WellKnownGroup",
                                             "Deleted", "Invalid"       ,
                                             "Unknown"};


class SidTree
{
public:   
   SidTree                 * left;
   SidTree                 * right;
   SID_NAME_USE              sidUse;
   USHORT                    lenSid;
   char                      buffer[1];   // contains sid, account name and domain

                        SidTree() {};
   SidTree *                              // ret-found/created node
      Find(
         SidTree             ** sidTree  ,// i/o-head of extension tree
         PSID const             pSid      // in -file extension
      );
};

static char * 
   AclType(
      BOOL                   isPresent    ,// in -1 if present
      BOOL                   isDefault     // in -1 if default ACL
   )
{
   if ( !isPresent )
      return "none";
   if ( isDefault )
      return "default";
   return "present";
}

                           
//#pragma page()
// For each "on" bit in the bitmap, appends the corresponding char in
// mapStr to retStr, thus forming a recognizable form of the bit string.
static
int _stdcall                              // ret-legngth of string written
   BitMapStr(
      DWORD                  bitmap      ,// in -bits to map
      char const           * mapStr      ,// in -map character array string
      char                 * retStr       // out-return selected map char string
   )
{
   char const              * m;
   char                    * r = retStr;

   for ( m = mapStr;  *m;  m++, bitmap >>= 1 )
      if ( bitmap & 1 )   // if current permission on
         *r++ = *m;       //    set output string to corresponding char
   *r = '\0';
   
   return (int)(r - retStr);
}

//#pragma page()
// converts an ACE access mask to a semi-undertandable string
static
char * _stdcall
   PermStr(
      DWORD                  access      ,// in -access mask
      char                 * retStr       // out-return permissions string
   )
{
// static char const         fileSpecific[] = "R W WaErEwX . ArAw";
// static char const         dirSpecific[]  = "L C M ErEwT D ArAw";
   static char const         specific[] = "RWbeEXDaA.......",
                             standard[] = "DpPOs...",
                             generic[] =  "SM..AXWR";
   char                    * o = retStr;

   if ( (access & FILE_ALL_ACCESS) == FILE_ALL_ACCESS )
      *o++ = '*';
   else
      o += BitMapStr(access, specific, o);

   access >>= 16;
   *o++ = '-';
   if ( (access & (STANDARD_RIGHTS_ALL >> 16)) == (STANDARD_RIGHTS_ALL >> 16) )
      *o++ = '*';
   else
      o += BitMapStr(access, standard, o);

   access >>= 8;
   if ( access )
   {
      *o++ = '-';
      o += BitMapStr(access, generic, o);
   }
   *o = '\0';                // null terminate string
      
   return retStr;
}


//#pragma page()
// Binary tree insertion/searching of Sids that obviates the constant
// use of LookupAccount and speeds execution by 100x!!!!!
SidTree *                                 // ret-found/created node
   SidTree::Find(
      SidTree             ** sidTree     ,// i/o-head of extension tree
      PSID const             pSid         // in -file extension
   )
{
   SidTree                 * curr,
                          ** prevNext = sidTree; // &forward-chain
   int                       cmp;          // compare result
   DWORD                     lenSid;
   WCHAR                     name[60],
                             domain[60];
   DWORD                     lenName,
                             lenDomain,
                             rc;
   SID_NAME_USE              sidUse;
   static int                nUnknown = 0;

   for ( curr = *prevNext;  curr;  curr = *prevNext )
   {
      if ( (cmp = memcmp(pSid, curr->buffer, curr->lenSid)) < 0 )
         prevNext = &curr->left;           // go down left side
      else if ( cmp > 0 )
         prevNext = &curr->right;          // go down right side
      else
         return curr;                      // found it and return address
   }

   // not found in tree -- create it
   lenName = DIM(name);
   lenDomain = DIM(domain);
   if ( !LookupAccountSid(NULL, pSid, name, &lenName,
                          domain, &lenDomain, &sidUse) )
   {
      rc = GetLastError();
      if ( rc != ERROR_NONE_MAPPED )
         err.DbgMsgWrite(0, L"LookupAccountSid()=%ld", rc);
      lenName = swprintf(name, L"**Unknown%d**", ++nUnknown);
      UStrCpy(domain, "-unknown-");
      lenDomain = 9;
      sidUse = (_SID_NAME_USE)0;
   }
   
   lenSid = GetLengthSid(pSid);
   *prevNext = (SidTree *)malloc(sizeof **prevNext + lenSid + lenName + lenDomain + 1);
   if (!(*prevNext))
      return NULL;
   memset(*prevNext, '\0', sizeof **prevNext);
   memcpy((*prevNext)->buffer, pSid, lenSid);
   (*prevNext)->lenSid = (USHORT)lenSid;
   (*prevNext)->sidUse = sidUse;
   UStrCpy((*prevNext)->buffer + lenSid, name, lenName + 1);
   UStrCpy((*prevNext)->buffer + lenSid + lenName + 1, domain, lenDomain + 1);
   return *prevNext;
}


//#pragma page()
SidTree               gSidTree;
SidTree             * sidHead = &gSidTree;
SECURITY_DESCRIPTOR * sd = NULL;


// Formats and prints (to stdout) the contents of the argment ACL
static
void _stdcall
   PrintACL(
      const PACL             acl         ,// in -ACL (SACL or DACL)
      WCHAR const           * resource     // in -resource name
   )
{
   ACCESS_ALLOWED_ACE      * ace;
   DWORD                     nAce;
   static char const         typeStr[] = "+-A*";
   SidTree                 * sidTree;
   char                      permStr[33],
                             inherStr[5];
   WCHAR                     txtSid[200];
   char                      sTxtSid[200];
   DWORD                     txtSidLen = DIM(txtSid);
   err.DbgMsgWrite(0,L" T Fl Acc Mask Permissions      Account name     "
          L"Domain         Acct Type");

   for ( nAce = 0;  nAce < acl->AceCount;  nAce++ )
   {
      if ( !GetAce(acl, nAce, (LPVOID *)&ace) )
      {
         err.DbgMsgWrite(0,L"GetAclInformation()=%ld ", GetLastError());
         return;
      }
      sidTree = sidHead->Find(&sidHead, &ace->SidStart);
      BitMapStr(ace->Header.AceFlags, "FDNI", inherStr);
      txtSid[0] = 0;
      txtSidLen = DIM(txtSid);
      GetTextualSid(&ace->SidStart,txtSid,&txtSidLen);
      safecopy(sTxtSid,txtSid);
      err.DbgMsgWrite(0,L" %c%-3S %08x %-16S %-16S %-14S %S",
              typeStr[ace->Header.AceType], 
              inherStr, 
              ace->Mask,
              PermStr(ace->Mask, permStr),
              (*(sidTree->buffer + sidTree->lenSid)) ? (sidTree->buffer + sidTree->lenSid) : sTxtSid, 
              sidTree->buffer + sidTree->lenSid + strlen(sidTree->buffer + sidTree->lenSid) + 1,
              sidType[sidTree->sidUse]);
   }
}


SECURITY_DESCRIPTOR *
GetSD(
      WCHAR                * path
      )
{                                         //added by christy
                                          //this does the same stuff as 
                                          // PermsPrint, but doesn't print
                       
   DWORD                     req = 0;
  
   HANDLE                    hSrc;
   DWORD                     rc = 0;
  
//   void                    * r = NULL;
//   WIN32_STREAM_ID         * s = (WIN32_STREAM_ID *)copyBuffer;
   char static const       * streamName[] = {"Err", "Data", "EA", "Security", "Alternate", "Link", "Err6"}; 
   
   
   
   
   hSrc = CreateFile(path,
                     GENERIC_READ |ACCESS_SYSTEM_SECURITY,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_BACKUP_SEMANTICS, 
                     0);
   
   if ( hSrc == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_SHARING_VIOLATION )
         err.DbgMsgWrite(ErrE, L"Source file in use %S", path );
      else
         err.DbgMsgWrite(ErrS,L"OpenR(%S) ", path);
      return NULL;
   }

   if ( ! GetKernelObjectSecurity(hSrc, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                   | DACL_SECURITY_INFORMATION
                                                                   | SACL_SECURITY_INFORMATION
                                                                    ,
            sd,
            SDBUFFSIZE,
            &req) )
   {
      err.DbgMsgWrite(0, L"GetKernelObjectSecurity(%S)=%ld req=%ld ",
                         path, GetLastError(),req);
      return NULL;
   }

   CloseHandle(hSrc);

   return sd;
}

                  
//#pragma page()
// Gets the security descriptors for a resource (path), format the owner
// information, gets the ACL and SACL and prints them.

DWORD 
   PermsPrint(
        WCHAR                 * path,         // in -iterate directory paths
        objectType              objType       // in -type of the object
   )
{
   TFileSD                   fsd(path);
   TShareSD                  ssd(path);
   TPrintSD                  psd(path);
   TRegSD                    rsd(path,NULL);
   SECURITY_DESCRIPTOR const* pSD = NULL;

   switch ( objType )
   {
   case file:
   case directory:
      fsd.ReadSD(path);
      if ( fsd.GetSecurity() )
      {
         pSD = fsd.GetSecurity()->GetSD();
      }
      break;
   case printer:
      psd.ReadSD(path);
      if ( psd.GetSecurity() )
      {
         pSD = psd.GetSecurity()->GetSD();
      }
      break;
   case share:
      ssd.ReadSD(path);
      if ( ssd.GetSecurity() )
      {
         pSD = ssd.GetSecurity()->GetSD();
      }
      break;
   case regkey:
      rsd.ReadSD(path);
      if ( rsd.GetSecurity() )
      {
         pSD = rsd.GetSecurity()->GetSD();
      }
      break;
   default:
      break;
   }
   if ( pSD )
   {
      PrintSD(const_cast<SECURITY_DESCRIPTOR*>(pSD),path);
   }
   else
   {
      err.DbgMsgWrite(0,L"Couldn't load Security descriptor for %ls",path);
   }
   return 0;
}

DWORD PrintSD(SECURITY_DESCRIPTOR * sd,WCHAR const * path)
{
   BOOL                      isPresent,
                             isDefault;
   PACL                      dacl;
   PACL                      sacl;
   PSID                      pSidOwner;
   SidTree                 * sidTree = &gSidTree;

//   DWORD                     rc = 0;
  
   if ( !GetSecurityDescriptorOwner(sd, &pSidOwner, &isDefault) )
   {
      err.DbgMsgWrite(0,L"GetSecurityDescriptorOwner()=%ld ", GetLastError());
      return 1;
   }
   
   err.DbgMsgWrite(0,L"%s",path);
   if ( pSidOwner )
   {
      sidTree = sidHead->Find(&sidHead, pSidOwner);
      if (sidTree)
      {
         err.DbgMsgWrite(0,L"owner=%S\\%S, type=%S, ", 
             //path,
             sidTree->buffer + sidTree->lenSid + strlen(sidTree->buffer + sidTree->lenSid) + 1,
             sidTree->buffer + sidTree->lenSid, 
             sidType[sidTree->sidUse]);
      }
   }
   else
   {
      err.DbgMsgWrite(0,L"owner=NULL");
   }
   if ( !GetSecurityDescriptorDacl(sd, &isPresent, &dacl, &isDefault) )
   {
      err.DbgMsgWrite(0, L"GetSecurityDescriptorDacl()=%ld ", GetLastError());
      return 1;
   }


   err.DbgMsgWrite(0,L" DACL=%S", AclType(isPresent, isDefault) );
   if ( dacl )
      PrintACL(dacl, path);

   if ( !GetSecurityDescriptorSacl(sd, &isPresent, &sacl, &isDefault) )
   {
      err.DbgMsgWrite(0, L"GetSecurityDescriptorSacl()=%ld ", GetLastError());
      return 1;
   }

   if ( isPresent )
   {
      err.DbgMsgWrite(0,L" SACL %S", AclType(isPresent, isDefault) );
      if (!sacl) 
      {  
         err.DbgMsgWrite(0,L"SACL is empty.");
      }
     else PrintACL(sacl, path);
   }
   return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\taskchk.cpp ===
/*Copyright (c) 1995-1999, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TaskCheck.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  99/07/01
Description -  Routines that examine a the job defined by a varset and determine 
               whether specific migration tasks need to be performed.

Updates     -
===============================================================================
*/

//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
//#include <process.h>

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "Common.hpp"
#include "TaskChk.h"
#include "ResStr.h"
#include "UString.hpp"
#include "ErrDct.hpp"

extern TErrorDct        errTrace;

BOOL                                   // ret- BOOL, whether account replicator should be called
   NeedToUseAR(
      IVarSet              * pVarSet   // in - varset containing migration settings
   )
{
   _bstr_t                   text;
   BOOL                      bResult = FALSE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying users");
      bResult = TRUE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying groups");
      bResult = TRUE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying computers");
      bResult = TRUE;
   }
   
   text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
   // account replication is only done locally on the machine where Domain Migrator is running
   // it cannot be dispatched to run on a different machine.
   // (you can't very well copy accounts from one domain to another while running as localsystem)
   if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
   {
      errTrace.DbgMsgWrite(0,L"Never use AR when running remotely.");
      bResult = FALSE; 
   }

   // Account replicator should not be run when gathering information
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");
   if (((WCHAR*)wizard) && (!_wcsicmp((WCHAR*) wizard, L"reporting")))
   {
      errTrace.DbgMsgWrite(0,L"Never use AR when Gathering Information.");
      bResult = FALSE; 
   }

   if (((WCHAR*)wizard) && (!_wcsicmp((WCHAR*) wizard, L"sidremove")))
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR. We are removing sids.");
      bResult = TRUE; 
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   if ( text.length() == 0 )
   {
      // no accounts were specified
      bResult = FALSE;
   }
   return ( bResult );
}

BOOL                                       // ret- BOOL, whether security translator should be called
   NeedToUseST(
      IVarSet              * pVarSet,       // in - varset containing migration settings
      BOOL                   bForceRemoteCheck // in - forces checking to be done based on the remote operations, not local ones 
   ) 
{
   BOOL                      bResult = FALSE;
   BOOL                      bLocalAgent;

   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));

   if (!text)
      return FALSE;

   bLocalAgent = ( UStrICmp(text,GET_STRING(IDS_YES)) == 0 );

   if ( bLocalAgent || bForceRemoteCheck )
   {
      // the agent dispatched to remote machines does translation for 
      // files

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));

      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Files");
         bResult = TRUE;
      }
      // and Shares
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Shares");
         bResult = TRUE;
      }
      // and User Rights
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Rights");
         bResult = TRUE;
      }
      // and Local Groups   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  LGroups");
         bResult = TRUE;
      }
      // and Printers
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Printers");
         bResult = TRUE;
      }
      // and User Profiles
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Local User Profiles");
         bResult = TRUE;
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Registry");
         bResult = TRUE;
      }
      // when dispatching, the settings are per-job, not per-server
      // it is possible to choose whether to migrate, translate, or both,
      // for each computer in the server list.
      // this setting indicates that the translation will not be run on this computer
      // even though other computers are being translated during this same job
      text = pVarSet->get(GET_BSTR(DCTVS_LocalServer_MigrateOnly));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))

      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  but not on this computer");
         bResult = FALSE;
      }
   }
   else
   {
      // The local engine does exchange translation for 
      // mailboxes 
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateMailboxes));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Mailboxes");
         bResult = TRUE;
      }
      // and containers
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Containers");
         bResult = TRUE;
      }
      // The local engine is also used to build an account mapping file to
      // send out with the dispatched agents for security translation
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  BuildCacheFile");
         bResult = TRUE;
      }
   }   
   return bResult;
}

BOOL                                         // ret- whether agents need to be dispatched to remote machines
   NeedToDispatch(
      IVarSet              * pVarSet         // in - varset describing migration job
   )
{
   BOOL                      bNeedToDispatch = FALSE;
   _bstr_t                   text;
   long                      count;
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");

   if (!wizard)
      return FALSE;

   if (! UStrICmp(wizard,L"user") )
   {
      bNeedToDispatch = FALSE;
   }
   else if (! UStrICmp(wizard,L"group") )
   {
      bNeedToDispatch = FALSE;
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"security" ) )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"service" ) )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"retry") )
   {
      bNeedToDispatch = TRUE;
   }


   // the dispatcher is used to migrate computers, and to translate security
   count = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
   if ( count > 0 )
   {
      bNeedToDispatch = TRUE;
   }
   return bNeedToDispatch;
}

BOOL 
   NeedToRunReports(
      IVarSet              * pVarSet       // in - varset describing migration job
   )
{
   BOOL                      bNeedToReport = FALSE;
   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));

   if (!text)
      return FALSE;

   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      bNeedToReport = TRUE;
   }

   return bNeedToReport;
}

BOOL                                       // ret- whether the local engine needs to be called to perform domain specific tasks
   NeedToRunLocalAgent(
      IVarSet              * pVarSet       // in - varset describing migration job
   )
{
   BOOL                      bNeedToRunLocal = FALSE;
   _bstr_t                   text;
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");
   
   if (!wizard)
      return FALSE;

   // if the wizard type is specified, use it to determine what to do
   if ( ! UStrICmp(wizard,L"user") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if (! UStrICmp(wizard,L"group") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( !UStrICmp(wizard,L"security") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( !UStrICmp(wizard,L"undo") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"service") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( !UStrICmp(wizard, "exchange") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if (! UStrICmp(wizard,L"retry") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( ! UStrICmp(wizard,L"reporting") )
   {
      text = pVarSet->get(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge));
      if (((WCHAR*)text) && (!UStrICmp(text,GET_STRING(IDS_YES))))
      {
         bNeedToRunLocal = TRUE;
      }
   }
   else
   {
      // wizard type is not specified, try to determine what needs to be done from the varset entries
      // The local agent is used for account replication and exchange translation
      if ( NeedToUseAR(pVarSet) )
         bNeedToRunLocal = TRUE;

      if ( NeedToUseST(pVarSet) )
         bNeedToRunLocal = TRUE;

   }
   return bNeedToRunLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\strhelp.cpp ===
/*---------------------------------------------------------------------------
  File: StrHelp.cpp

  Comments: Contains general string helper functions.


  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/02/00 

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
#include <stdio.h>
#endif

/*********************************************************************
 *                                                                   *
 * Revised 20 May 2001 Mark Oluper - wrote case in-sensitive version *
 * Written by: Paul Thompson                                         *
 * Date: 2 NOV 2000                                                  *
 *                                                                   *
 *     This function is responsible for determining if a given string*
 * is found, in whole, in a given delimited string.  The string      *
 * delimitedr can be most any character except the NULL char ('\0'). *
 *     By the term "in whole", we mean to say that the given string  *
 * to find is not solely a substring of another string in the        *
 * delimited string.                                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN IsStringInDelimitedString
BOOL                                         //ret- TRUE=string found
   IsStringInDelimitedString(    
      LPCWSTR                sDelimitedString, // in- delimited string to search
      LPCWSTR                sString,          // in- string to search for
      WCHAR                  cDelimitingChar   // in- delimiting character used in the delimited string
   )
{
	BOOL bFound = FALSE;

	// if search and delimited strings are specified

	if (sString && sDelimitedString)
	{
		// initialize string segment beginning

		LPCTSTR pszBeg = sDelimitedString;

		for (;;)
		{
			// find delimiter which marks string segment end

			LPCTSTR pszEnd = wcschr(pszBeg, cDelimitingChar);

			// if delimiter found...

			if (pszEnd)
			{
				// if string segment matches search string

				if (_wcsnicmp(pszBeg, sString, pszEnd - pszBeg) == 0)
				{
					// then search string found
					bFound = TRUE;
					break;
				}
				else
				{
					// else set start of next string segment to character after delimiter
					pszBeg = pszEnd + 1;
				}
			}
			else
			{
				// otherwise if last string segment matches search string

				if (_wcsicmp(pszBeg, sString) == 0)
				{
					// then search string found
					bFound = TRUE;
				}

				break;
			}
		}
	}

	return bFound;
}
//END IsStringInDelimitedString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\tnode.cpp ===
//#pragma title( "TNode.cpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      - TNode.cpp
System      - Common
Author      - Tom Bernhardt
Created     - 1989-11-19
Description - List/Tree base classes.
              TNode is a base class to define a collection element.  It
              contains a left and right pointer to another TNode item and
              these may be organized as a double-linked linear list or
              binary tree in the collection classes that use TNode items.

              Central to its utility are member functions to convert between
              binary tree, sorted 2-way linear linked lists, and unsorted 2-way
              linked linear lists.

 Collection and enum classes
   TNodeList         A simple collection of TNode elements.
   TNodeListSortable A TNodeList that is sortable by one or more compare functions.


 Conversion member functions for TNodeListSortable:
   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
Updates     -
1995-05-01 TPB Converted to C++ classes.
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include "TNode.hpp"
#include "common.hpp"


//#pragma page()
//------------------------------------------------------------------------------
// Warning: Must not pass top == NULL
//------------------------------------------------------------------------------
TNode *                                    // ret-head of sorted list
   TNodeListSortable::TreeToSortedList(
      TNode                * top          ,// i/o-top of [sub]tree to squash
      TNode               ** newhead      ,// out-leftmost branch from tree
      TNode               ** newtail       // out-rightmost branch from tree
   )
{
   TNode                   * temp;         // temporary pointer placeholder

   if ( top->left == NULL )
      *newhead = top;                      // this is leftmost of parent node
   else
   {
      TreeToSortedList(top->left, newhead, &temp);
      top->left = temp;                    // left = tail of sub-list
      top->left->right = top;
   }
   if ( top->right == NULL )
      *newtail = top;                      // tree is rightmost of parent node
   else
   {
      TreeToSortedList(top->right, &temp, newtail);
      top->right = temp;                   // right = head of sub-list
      top->right->left = top;
   }
   return *newhead;
}


//------------------------------------------------------------------------------
// converts sorted 2-linked list into balanced binary tree
//------------------------------------------------------------------------------
TNode *                                    // ret-middle of list (head of Btree)
   TNodeListSortable::ListSortedToTree(
      TNode                * top           // i/o-top of [sub]list to tree-ify
   )
{
   TNode                   * mid = top    ,// middle of list
                           * curr;
   int                       odd = 1;

   if ( top == NULL )
      return NULL;
   for ( curr = top;  curr;  curr = curr->right ) // find list middle
   {
      if ( odd ^= 1 )
         mid = mid->right;
   }
   if ( mid->left )                        // split list around mid point
   {
      mid->left->right = NULL;             // right terminate new sublist
      mid->left = ListSortedToTree(top);   // recursive call to set left side
   }
   if ( mid->right )
   {
      mid->right->left = NULL;             // left terminate new sublist
      mid->right = ListSortedToTree(mid->right);// recursive call to set right side
   }
   return mid;
}


//#pragma page()
TNode *                                    // ret-new head of tree
   TNodeListSortable::UnsortedToTree()
{
   TNode                   * treehead = NULL,
                           * tree,
                           * curr,
                           * next;

   MCSASSERTSZ( !IsTree(), "TNodeListSortable::UnsortedToTree - list is already a tree" );

   if ( !IsTree() )
   {
      for ( curr = head;  curr;  curr = next )// insert each node into BinTree
      {
         next = curr->right;                  // save right pointer
         curr->right = curr->left = NULL;     // break chains for insertion node
         if ( treehead == NULL )
            treehead = curr;                  // first node become BinTree head
         else
         {
            for ( tree = treehead;  ; )       // iterative BinTree insert algorithm
            {
               if ( PCompare(curr, tree) <=0 )// if belongs left of current node
                  if ( tree->left == NULL )   //    if left tree empty
                  {
                     tree->left = curr;       //       insert here
                     break;                   //       and process right node
                  }
                  else                        //    else
                     tree = tree->left;       //       go down left side 1 level
               else                           // must be right side
               {
                  if ( tree->right == NULL )
                  {
                     tree->right = curr;
                     break;
                  }
                  else
                     tree = tree->right;
               }
            }
         }
      }
      TypeSetTree();
   }
   return treehead;
}

//#pragma page()

//------------------------------------------------------------------------------
// comparison function used for scrambling a sorted linked list
//------------------------------------------------------------------------------
TNodeCompare(ScrambledCompare)
{
   return (rand() - RAND_MAX/2);
}

//------------------------------------------------------------------------------
// converts sorted 2-linked list into a scrambled random binary tree
//------------------------------------------------------------------------------
void
   TNodeListSortable::SortedToScrambledTree()
{
   MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToScrambledTree - list is already a tree" );

   if ( !IsTree() )
   {
      TNodeCompare((*pOldCompare));
      pOldCompare = PCompare;
      CompareSet(ScrambledCompare);
      UnsortedToTree();
      CompareSet(pOldCompare);
   }
}

//#pragma page()
TNodeList::~TNodeList()
{

// _ASSERTE( (count == 0) && (head == NULL) );

   if ( (count == 0) && (head == NULL) )
      ;
   else
   {
      //printf( "\aTNodeList destructor failure - list is not empty!\a\n" );
   }
}

void
   TNodeList::InsertTop(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = head;
   eIns->left  = NULL;
   if ( head )
      head->left = eIns;
   else
      tail = eIns;
   head = eIns;
   count++;
   return;
}

void
   TNodeList::InsertBottom(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = NULL;
   eIns->left  = tail;
   if ( tail )
      tail->right = eIns;
   else
      head = eIns;
   tail = eIns;
   count++;
   return;
}

void
   TNodeList::InsertAfter(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eAft          // i/o-element insert point
   )
{
   TNode                   * eFwd;         // element after inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eAft )
      InsertTop( eIns );
   else
   {
      eFwd = eAft->right;
      eIns->right = eFwd;
      eIns->left  = eAft;
      if ( eFwd )
         eFwd->left  = eIns;
      else
         tail = eIns;
      eAft->right = eIns;
      count++;
   }
}

void
   TNodeList::InsertBefore(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eBef          // i/o-element insert point
   )
{
   TNode                   * eBwd;         // element before inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eBef )
      InsertBottom( eIns );
   else
   {
      eBwd = eBef->left;
      eIns->right = eBef;
      eIns->left  = eBwd;
      if ( eBwd )
         eBwd->right = eIns;
      else
         head = eIns;
      eBef->left = eIns;
      count++;
   }
   return;
}

void
   TNodeList::Remove(
      TNode          const * t             // i/o-new node to remove from list but not delete
   )
{
   MCSVERIFY(this);
   MCSVERIFY(t);

   if ( t->left )
      t->left->right = t->right;
   else
      head = t->right;

   if ( t->right )
      t->right->left = t->left;
   else
      tail = t->left;
   count--;

   //Remove links to the list from t. We cant do this because
   // t is a const *
   //t->left = t->right = NULL;
}


void
   TNodeList::Reverse()
{
   TNode                   * node;
   TNode                   * swap;

   MCSVERIFY(this);

   for ( node = head;  node;  node = node->left )
   {
       swap        = node->left;
       node->left  = node->right;
       node->right = swap;
   }
   swap = head;
   head = tail;
   tail = swap;
}


TNode *
   TNodeList::Find(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr;

   MCSASSERT(this);

   for ( curr = head;  curr;  curr = curr->right )
   {
      if ( !Compare( curr, findval ) )
         break;
   }
   return curr;
}

BOOL                                       // ret-TRUE if valid
   TNodeListSortable::CountTree(
      TNode                * pCurrentTop  ,// i/o-top of [sub]tree to count nodes
      DWORD                * pCount        // i/o-Number of nodes encountered in the tree
   )
{
   if ( !pCurrentTop )
      return TRUE;

   (*pCount)++;

   if( (*pCount) > count )
      return FALSE;

   if(!CountTree(pCurrentTop->left,pCount))
      return FALSE;

   if(!CountTree(pCurrentTop->right,pCount))
      return FALSE;

   return TRUE;
}


BOOL                                       // TRUE if Valid and FALSE if not
   TNodeListSortable::ValidateTree()
{
   DWORD                     dwTempCount=0;
   DWORD                     bValid;

   MCSVERIFY(listType == TNodeTypeTree);

   bValid = CountTree(head,&dwTempCount);

   return bValid;
}

// Routine to validate the state of the list
DWORD
   TNodeList::Validate(
      TNode               ** pErrorNode
   )
{
   DWORD                     dwError=0;
   DWORD                     nNodesVisited=0;
   TNode                   * pCurrentNode;
   DWORD                     dwNodeCount = Count();

   if(pErrorNode)
      *pErrorNode = NULL;

#ifndef WIN16_VERSION
   try
   {
#endif
      pCurrentNode = head;

      if ( pCurrentNode)  // If the list is not empty
      {
         if ( pCurrentNode->left)
         {
            dwError = MCS_ListError_InvalidHead;
         }
         else
         {
            while ( pCurrentNode->right )
            {
               if(pCurrentNode->right->left != pCurrentNode)
               {
                  dwError = MCS_ListError_InvalidPtr;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
                  break;
               }

               nNodesVisited++;

               if ( nNodesVisited > dwNodeCount )
               {
                  dwError = MCS_ListError_InvalidCount;
                  break;
               }
               pCurrentNode = pCurrentNode->right;
            }

            if ( (!dwError) && (!pCurrentNode->right) )
            {
               if ( pCurrentNode != tail)
               {
                  dwError = MCS_ListError_InvalidTail;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
               }
            }
         }
      }
      else  // if the list is empty
      {
         if(dwNodeCount)
         {
            dwError = MCS_ListError_InvalidCount;
         }
      }
#ifndef WIN16_VERSION
   }
   catch(...)
   {
      dwError = MCS_ListError_Exception;
   }
#endif

   return dwError;
}

void
   TNodeListSortable::TreeRemove(
      TNode                * item          // i/o-node to remove from binary tree
   )
{
   TNode                  ** prevNext = &head,
                           * rep,
                           * repLeft,
                           * temp;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   while ( *prevNext )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
      {
         // we've found a matching 'name' (they compare equal)
         if ( *prevNext == item )
         {
            // we've found the address we're looking for
            if ( (*prevNext)->right )
            {
               rep = repLeft = (*prevNext)->right;
               for ( temp = rep->left;  temp;  temp = temp->left )
                  repLeft = temp;
               repLeft->left = (*prevNext)->left;
               temp = *prevNext;
               *prevNext = rep;
            }
            else
            {
               temp = *prevNext;
               *prevNext = (*prevNext)->left; // simple case
            }

            // break removed nodes links to existing tree
            temp->left = temp->right = NULL;
            count--;
            break;
         }
      }
   }
   return;
}

// returns the insert point in a sorted list for a prospective node
TNode *                                    // ret-insert before point or NULL
   TNodeListSortable::SortedFindInsertBefore(
      TNode                * item         ,// i/o-node to insert into TNode
      BOOL                 * exists        // out-TRUE if already exists
   )
{
   int                       c;
   TNode                   * curr;

   *exists = FALSE;
   if ( !lastInsert )
   {
      if ( !head )           // if null head, empty list, return NULL
         return NULL;
      lastInsert = head;
   }

   c = PCompare(item, lastInsert);
   if ( c < 0 )
      lastInsert = head;

   for ( curr = lastInsert;  curr;  curr = curr->right )
   {
      c = PCompare(item, curr);
      if ( c <= 0 )
         if ( c == 0 )
            *exists = TRUE;
         else
            break;
   }

   return curr;
}

// inserts node into sorted linear list
void
   TNodeListSortable::SortedInsert(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;

   MCSVERIFY(listType != TNodeTypeTree);

   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   InsertBefore(item, insertPoint);
   lastInsert = item;
}


BOOL
   TNodeListSortable::SortedInsertIfNew(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;
   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   if ( !exists )
   {
      InsertBefore(item, insertPoint);
      lastInsert = item;
   }
   return !exists;
}


void
   TNodeListSortable::TreeInsert(
      TNode                * item         ,// i/o-node to insert into binary tree
      short                * depth         // out-tree/recursion depth of new item
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp <= 0 )
         prevNext = &(*prevNext)->left;
      else
         prevNext = &(*prevNext)->right;
   }
   *prevNext = item;
   item->left = item->right = NULL;
   count++;
   return;
}


TNode *
   TNodeListSortable::TreeFind(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr = head;
   int                       cmp;

   while ( curr )
   {
      cmp = Compare( curr, findval );
      if ( cmp > 0 )
         curr = curr->left;
      else if ( cmp < 0 )
         curr = curr->right;
      else   // cmp == 0
         break;
   }
   return curr;
}


TNode *                                    // ret-TNode at pos n or NULL
   TNodeListOrdEnum::Get(
      long                   n             // in -new position
   )
{
   long                 disCurr = n - nCurr, // distance to curr
                        disTop  = n < (long)list->Count()/2 ? n : n - list->Count();

#ifdef WIN16_VERSION
   long absDisTop  = (disTop<0)  ? -disTop  : disTop;
   long absDisCurr = (disCurr<0) ? -disCurr : disCurr;
   if ( absDisTop < absDisCurr )
#else
   if ( abs(disTop) < abs(disCurr) )
#endif
   {
      Top();
      disCurr = disTop;
   }
   if ( disCurr < 0 )
      for ( Prev();  n < nCurr  &&  Prev(); );
   else
      for (       ;  n > nCurr  &&  Next(); );

   return curr;
}

// returns the first node of the tree
TNode *
   TNodeTreeEnum::First()
{
   if (stackBase)
   {
      stackPos = stackBase;
      if ( top )
         Push(top);
      return Next();
   }
   else
   {
      return NULL;
   }
}

// Returns the tree node logically following the value per the sort organization
// specified by Compare, and sets up the enumeration to continue from that point.
TNode *
   TNodeTreeEnum::FirstAfter(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void  const          * findVal       // in -findVal to position after
   )
{
   TNode                   * tn;
   int                       cmp;

   if (stackBase)
   {
      stackPos = stackBase;
      for ( tn = top;  tn;  )
      {
         Push(tn);
         cmp = Compare( tn, findVal );
         if ( cmp < 0 )
         {
            stackPos->state = Sright;
            if ( tn->right )
               tn = tn->right;
            else
               return Next();
         }
         else if ( cmp > 0 )
         {
            stackPos->state = Sleft;
            if ( tn->left )
               tn = tn->left;
            else
            {
               stackPos->state = Sused;
               return tn;
            }
         }
         else
         {
            stackPos->state = Sused;
            return Next();
         }
      }
   }

   return NULL;
}


// returns the Next logical node of the tree ending with NULL when complete
TNode *
   TNodeTreeEnum::Next()
{
   if (stackBase)
   {
      for ( ;; )
      {
         switch ( stackPos->state )
         {
            case Snone:                       // we've done nothing here
               stackPos->state = Sleft;
               if ( stackPos->save->left )
                  Push(stackPos->save->left);
               break;
            case Sleft:                       // we've gone left and are back
               stackPos->state = Sused;
               return stackPos->save;
            case Sused:                       // we've used the node
               stackPos->state = Sright;
               if ( stackPos->save->right )
                  Push(stackPos->save->right);// process right side of branch
               break;
            case Sright:                      // we've gone right and are back
               if ( !Pop() )
                  return NULL;
               break;
            case SComplete:
               return NULL;
               break;                         // Do we need this?
            default:                          // bad error
               MCSASSERT(FALSE);
               return NULL;
         }
      }
   }

   return NULL;
}

// Returns the address of the forward (left/right) pointer where the find node
// already exists or would be inserted.  If the singly deferenced result is not
// null, the node's key value already exists in the tree.
// If, after obtaining the insertion point, you want to insert the node, just
// assign its address to the singly deferenced return value.  The following inserts
// the node "f" if it is not alread in the tree:
//    TNode **r = tree.TreeFindInsert(f);
//    if ( !*r )
//       *r = f;
TNode **                                   // ret-pointer forward pointer to find
   TNodeListSortable::TreeFindInsert(
      TNode const          * find         ,// in -node to find
      short                * depth         // out-tree depth of insertion point
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( find, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
         break;
   }

   return prevNext;
}

// TNode.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\treg.cpp ===
//#pragma title( "TReg.cpp - NT registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-09-01
Description -  NT registry class.
Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "TNode.hpp"

#include "TReg.hpp"

// Short term solution
#define MAX_REG_NAMELEN    512
#define MAX_REG_VALUELEN   2048


// Destructor function was formerly inline.
// It is here to facilitate handle leak tracing.

   TRegKey::~TRegKey()
{
   Close();
};

// Close function was formerly inline.
// It is here to facilitate handle leak tracing.
void
   TRegKey::Close()
{
   if ( hKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey( hKey );
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

};

// open registry on remote computer
DWORD
   TRegKey::Connect(
      HKEY                  hPreDefined   ,// in -must be HKEY_LOCAL_MACHINE or HKEY_USERS
      TCHAR         const * machineName    // in -remote computer name
   )
{
   LONG                     rc;           // return code

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegConnectRegistry( const_cast<TCHAR *>(machineName), hPreDefined, &hKey );

   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// create new key
DWORD
   TRegKey::Create(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// create new key (using backup/restore)
DWORD
   TRegKey::CreateBR(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_BACKUP_RESTORE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// open existing key
DWORD
   TRegKey::Open(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                  access        // in -security access mask for key
   )
{
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegOpenKeyEx( hParent,
                       keyname,
                       0,
                       access,
                       &hKey );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// Recursively delete the subkey
DWORD                                      // ret-os return code
    TRegKey::SubKeyRecursiveDel(
        TCHAR const               * keyname      // in - the subkey name
    ) const
{
    TRegKey subKey;
    DWORD retval;
    
    retval = subKey.Open(keyname, this);
    if (retval == ERROR_SUCCESS)
    {
        retval = subKey.HiveDel();
        subKey.Close();
    }
    if (retval == ERROR_SUCCESS)
        retval = SubKeyDel(keyname);

    return retval;
}

// Gets the subkey value of the specified index number
DWORD                                      // ret-os return code
   TRegKey::SubKeyEnum(
      DWORD                  n            ,// in -ordinal number of subkey
      TCHAR                * keyname      ,// out-key name
      DWORD                  keylen        // in -max size of key name in TCHARs
   ) const
{
   LONG                      rc;
   DWORD                     keyLen = keylen;
   FILETIME                  lastWrite;

   rc = RegEnumKeyEx( hKey,
                      n,
                      keyname,
                      &keyLen,
                      0,
                      NULL,
                      NULL,
                      &lastWrite );

   return (DWORD)rc;
}

// Enumerate value
DWORD                                      // ret-0 or error code
   TRegKey::ValueEnum(
      DWORD                  index        ,// in -ordinal number of subkey
      TCHAR                * name         ,// out-name
      DWORD                  namelen      ,// in -name size in TCHARs
      void                 * value        ,// out-value
      DWORD                * valuelen     ,// i/o-value size in BYTEs
      DWORD                * type          // out-value type code
   ) const
{
   return (DWORD)RegEnumValue( hKey, index, name, &namelen, NULL, type, (BYTE *) value, valuelen );
}

// Get REG_DWORD value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetDWORD(
      TCHAR          const * name         ,// in -value name
      DWORD                * value         // out-returned DWORD value
   ) const
{
   LONG                      osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len = sizeof *value; // value length

   osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );

   if ( !osRc && (type != REG_DWORD) )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }

   return (DWORD)osRc;
}

// Get REG_SZ value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR                * value        ,// out-value buffer
      DWORD                  maxlen        // in -sizeof value buffer
   ) const
{
   LONG                      osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len;          // value length

   // force maxlen to an integral number of TEXT characters
   maxlen = maxlen / (sizeof value[0]) * (sizeof value[0]);

   if ( !maxlen )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }
   else
   {
      len = maxlen;
      osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );
      len = len / (sizeof value[0]) * (sizeof value[0]);
      if ( !osRc && (type != REG_SZ) )
      {
         osRc = ERROR_FILE_NOT_FOUND;
      }
      if ( osRc )
      {
         value[0] = TEXT('\0');
      }
      else
      {  // return of a null-terminated string is not guaranteed by API!
         // force null-terminated string, truncate string if necessary.
         if ( len >= maxlen )
         {
            len = maxlen - sizeof value[0];
         }
         value[len/(sizeof value[0])] = TEXT('\0');
      }
   }

   return (DWORD)osRc;
}

DWORD
   TRegKey::ValueGet(
      TCHAR          const * name         ,// in -name
      void                 * value        ,// out-value
      DWORD                * lenvalue     ,// i/o-length of value
      DWORD                * typevalue     // out-type of value
   ) const
{
   return (DWORD)RegQueryValueEx( hKey, name, 0, typevalue, (UCHAR *) value, lenvalue );
}

// Set REG_SZ value
DWORD
   TRegKey::ValueSetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR          const * value        ,// out-value
      DWORD                  type          // in -value type
   ) const
{
   return (DWORD)RegSetValueEx( hKey,
                         name,
                         NULL,
                         type,
                         (LPBYTE) value,
                         (UStrLen(value) + 1) * sizeof value[0] );
}

DWORD
   TRegKey::ValueSet(
      TCHAR          const * name         ,// in -name
      void           const * value        ,// in -value
      DWORD                  lenvalue     ,// in -length of value
      DWORD                  typevalue     // in -type of value
   ) const
{
   return (DWORD)RegSetValueEx( hKey,
                         name,
                         0,
                         typevalue,
                         (UCHAR const *) value,
                         lenvalue );
}

DWORD                                      // ret-0 or error code
   TRegKey::ValueDel(
      TCHAR          const * name          // in -value name
   ) const
{
   LONG                      rc;

   rc = (DWORD)RegDeleteValue(hKey, name);

   return rc;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveCopy(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key/value index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   TCHAR                     value[MAX_REG_VALUELEN];   // value name
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // process values at this level
   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = source->ValueEnum( index, name, MAX_REG_NAMELEN, value, &valuelen, &type );
      if ( !retval )
      {
         retval = this->ValueSet( name, value, valuelen, type );
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         index++ )
   {
      retval = source->SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         retval = srcNest.Open( name, source );
         if ( !retval )
         {
            retval = trgNest.Create( name, this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveDel()
{
   DWORD                     retval = 0;   // returned value
   DWORD                     index;        // value/key index
   TCHAR                     name[MAX_REG_NAMELEN];    // name
   DWORD                     namelen;      // name length
   BYTE                      value[MAX_REG_VALUELEN];   // value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type code
   TRegKey                   trgNest;      // nested target registry

   // delete values at this level
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      namelen = MAX_REG_NAMELEN;
      valuelen = sizeof value;
      retval = ValueEnum( index, name, namelen, value, &valuelen, &type );
      if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
      if ( !retval )
      {
         retval = ValueDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      retval = SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         retval = trgNest.Open( name, this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// These four classes are used only by TRegReplicate
// Class to represent one registry key
class RKey : public TNode
{
   friend class RKeyList;
private:
   TCHAR                   * name;         // key name
protected:
public:
   RKey() { name = NULL; };
   ~RKey() { if ( name ) delete [] name; };
   BOOL New( TCHAR const * aname );
   TCHAR const * GetName() const { return name; };
};

BOOL
   RKey::New(
      TCHAR          const * aname         // in -key name
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   return !!name;
}

// Class to represent the set of registry keys at one level
class RKeyList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RKey const *) v1)->name,
         ((RKey const *) v2)->name ); }
protected:
public:
   RKeyList() : TNodeListSortable( Compare ) {}
   ~RKeyList();
};

// RKeyList object destructor
   RKeyList::~RKeyList()
{
   DeleteAllListItems( RKey );
}

// Class to represent one registry value
class RValue : public TNode
{
   friend class RValueList;
private:
   TCHAR                   * name;         // value's name
   BYTE                    * value;        // value's value
   DWORD                     valuelen;     // value's value length
   DWORD                     type;         // value's type
protected:
public:
   RValue() { name = NULL; value = NULL; valuelen = type = 0; };
   ~RValue() { if ( name ) delete [] name;
               if ( value ) delete [] value; };
   BOOL New( TCHAR const * aname, BYTE const * avalue, DWORD valuelen, DWORD type );
   TCHAR const * GetName() const { return name; };
   BYTE const * GetValue() const { return value; };
   DWORD GetValueLen() const { return valuelen; };
   DWORD GetType() const { return type; };
};

BOOL
   RValue::New(
      TCHAR          const * aname        ,// in -value's name
      BYTE           const * avalue       ,// in -value's value
      DWORD                  avaluelen    ,// in -value's value length
      DWORD                  atype         // in -value's type
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   value = new BYTE[avaluelen];

   if ( value )
   {
      memcpy( value, avalue, avaluelen );
   }

   valuelen = avaluelen;
   type = atype;

   return name && value;
}

// Class to represent the set of registry values at one level
class RValueList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RValue const *)v1)->name,
         ((RValue const *)v2)->name ); }
protected:
public:
   RValueList() : TNodeListSortable( Compare ) {}
   ~RValueList();
};

// RValueList object destructor
   RValueList::~RValueList()
{
   DeleteAllListItems( RValue );
}

// Static subroutine used only by TRegReplicate
// collect all values at one registry level into a RValueList
DWORD static
   CollectValues(
      RValueList           * pValueList   ,// out-value list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // value enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // value name
   BYTE                      value[MAX_REG_VALUELEN];   // value value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   RValue                  * pValue;       // new value

   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = pRegKey->ValueEnum( index, name, MAX_REG_NAMELEN, value, &valuelen, &type );
      if ( !retval )
      {
         pValue = new RValue;
         if ( pValue )
         {
            try
            {
                if ( pValue->New( name, value, valuelen, type ) )
                {
                   pValueList->Insert( pValue );
                }
                else
                {
                   delete pValue;
                   pValue = NULL;
                }
            }
            catch(...)
            {
               delete pValue;
               pValue = NULL;
               throw;
            }
         }
         if ( !pValue )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }
   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Static subroutine used only by TRegReplicate
// collect all keys at one registry level into a RKeyList
DWORD static
   CollectKeys(
      RKeyList             * pKeyList     ,// out-key list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   RKey                    * pKey;         // new key object

   for ( index = 0;
         !retval;
         index++ )
   {
      retval = pRegKey->SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         pKey = new RKey;
         if ( pKey )
         {
            try
            {
                if ( pKey->New( name ) )
                {
                   pKeyList->Insert( pKey );
                }
                else
                {
                   delete pKey;
                   pKey = NULL;
                }
            }
            catch(...)
            {
                delete pKey;
                pKey = NULL;
                throw;
            }
         }
         if ( !pKey )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Replicate registry hive
DWORD                                      // ret-OS return code
   TRegKey::HiveReplicate(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   RValueList                srcValues;    // source values
   RValueList                trgValues;    // target values
   TNodeListEnum             eSrcValue;    // enumerate source values
   RValue            const * pSrcValue;    // source value
   TNodeListEnum             eTrgValue;    // enumerate target values
   RValue            const * pTrgValue;    // target value
   RKeyList                  srcKeys;      // source keys
   RKeyList                  trgKeys;      // target keys
   TNodeListEnum             eSrcKey;      // enumerate source keys
   RKey              const * pSrcKey;      // source key
   TNodeListEnum             eTrgKey;      // enumerate target keys
   RKey              const * pTrgKey;      // target key
   int                       cmpRc;        // compare return code
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // handle replication of values at this level
   CollectValues( &srcValues, source );
   CollectValues( &trgValues, this );

   // now merge the values
   pSrcValue = (RValue const *) eSrcValue.OpenFirst( &srcValues );
   pTrgValue = (RValue const *) eTrgValue.OpenFirst( &trgValues );
   while ( !retval && (pSrcValue || pTrgValue) )
   {
      if ( !pTrgValue )
      {
         cmpRc = -1;
      }
      else if ( !pSrcValue )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcValue->GetName(), pTrgValue->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source value only (copy)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
      }
      else if ( cmpRc > 0 )
      {  // target value only (delete)
         retval = this->ValueDel( pTrgValue->GetName() );
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical value names (replicate)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
   }

   eSrcValue.Close();
   eTrgValue.Close();

   // handle replication of keys at this level
   CollectKeys( &srcKeys, source );
   CollectKeys( &trgKeys, this );

   // now merge the values
   pSrcKey = (RKey const *) eSrcKey.OpenFirst( &srcKeys );
   pTrgKey = (RKey const *) eTrgKey.OpenFirst( &trgKeys );

   while ( !retval && (pSrcKey || pTrgKey) )
   {
      if ( !pTrgKey )
      {
         cmpRc = -1;
      }
      else if ( !pSrcKey )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcKey->GetName(), pTrgKey->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source key only (copy hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Create( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
      }
      else if ( cmpRc > 0 )
      {  // target key only (delete hive)
         retval = trgNest.Open( pTrgKey->GetName(), this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( pTrgKey->GetName() );
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical keys (replicate hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Open( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveReplicate( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
   }

   eSrcKey.Close();
   eTrgKey.Close();

   return retval;
}

// TReg.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\tevent.cpp ===
//#pragma title( "TEvent.cpp - Log events" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TAudit.cpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1995-11-10
Description -  TErrorEventLog class
Updates     -
===============================================================================
*/

#include <stdio.h>
#include <windows.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"

#include "TEvent.hpp"

BOOL
   TErrorEventLog::LogOpen(
      WCHAR          const * svcName      ,// in -service name
      int                    mode         ,// in -0=overwrite, 1=append
      int                    level         // in -minimum level to log
   )
{
   if (hEventSource != NULL)
        DeregisterEventSource(hEventSource);
   hEventSource = RegisterEventSourceW( NULL, svcName );
   if ( hEventSource == NULL )
      lastError = GetLastError();

   return hEventSource != NULL;
}

void
   TErrorEventLog::LogWrite(
      WCHAR          const * msg
   )
{
   BOOL                      rcBool;
   DWORD                     rcErr;
   static const WORD         levelTranslate[] = {EVENTLOG_INFORMATION_TYPE,
                                                 EVENTLOG_WARNING_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE};

   SID                     * pSid = NULL;
   HANDLE                    hToken = NULL;
   TOKEN_USER                tUser[10];
   ULONG                     len;

   if ( OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hToken) )
   {
      if ( GetTokenInformation(hToken,TokenUser,tUser,10*(sizeof TOKEN_USER),&len) )
      {
         pSid = (SID*)tUser[0].User.Sid;
      }
      else
      {
         rcErr = GetLastError();
      }
      CloseHandle(hToken);
   }
   else
   {
      rcErr = GetLastError();
   }

   // TODO:  setup event category
   // TODO:  log events in Unicode

   rcBool = ReportEventW( hEventSource,    // handle of event source
               levelTranslate[level],      // event type
               0,                          // event category
//               CAT_AGENT,                  // event category
               DCT_MSG_GENERIC_S,          // event ID
               pSid,                       // current user's SID
               1,                          // strings in lpszStrings
               0,                          // no bytes of raw data
               &msg,                       // array of error strings
               NULL );                     // no raw data
   if ( !rcBool )
   {
      rcErr = GetLastError();
   }
}

void
   TErrorEventLog::LogClose()
{
   if ( hEventSource != NULL )
   {
      DeregisterEventSource( hEventSource );
      hEventSource = NULL;
   }
};

// TEvent.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\tsync.cpp ===
//#pragma title( "TSync.cpp - Common synchronization classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes
               TCriticalSection
               TSemaphoreNamed
Updates     -
===============================================================================
*/

#include <stdio.h>
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <time.h>

#include "Common.hpp"
#include "Err.hpp"
#include "TSync.hpp"

///////////////////////////////////////////////////////////////////////////////
// TSemaphoreNamed member functions
///////////////////////////////////////////////////////////////////////////////

// Create named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Create(
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted     // out-TRUE=previously existed
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = CreateSemaphore( NULL, nInitial, nMaximum, sNameT );
   if ( handle == NULL )
   {
      rcOs = GetLastError();
   }
   else if ( pbExisted )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case 0:
            *pbExisted = FALSE;
            break;
         case ERROR_ALREADY_EXISTS:
            *pbExisted = TRUE;
            rcOs = 0;
            break;
         default:
            break;
      }
   }
   return rcOs;
}

// Open named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Open(
      TCHAR          const * sNameT        // in -semaphore name
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, sNameT );
   if ( handle == NULL ) rcOs = GetLastError();
   return rcOs;
}

// Release semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Release(
      long                   nRelease      // in -number to release
   )
{
   DWORD                     rcOs;         // OS return code
   long                      nPrevious=0;  // previous count
   rcOs = ReleaseSemaphore( Handle(), nRelease, &nPrevious )
         ? 0 : GetLastError();
   return rcOs;
}


// TSync.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\tservice.cpp ===
//#pragma title( "TService.cpp - SCM interface for MCS service" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TService.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-08-17
Description -  Service Control Manager interface for MCS service
Updates     -
===============================================================================
*/

#include <windows.h>
#include <stdio.h>

#include "TService.hpp"

///////////////////////////////////////////////////////////////////////////////
// Private data declarations
///////////////////////////////////////////////////////////////////////////////

#define  WAIT_HINT_SECONDS  (10)
#define  WAIT_HINT_MILLISECONDS  (WAIT_HINT_SECONDS*1000)

static
   TCHAR                   * gNameService;
static
   SERVICE_STATUS            gServiceStatus;
static
   SERVICE_STATUS_HANDLE     ghServiceStatus;
static
   HANDLE                    ghServDoneEvent=INVALID_HANDLE_VALUE;
static
   DWORD                     gArgc;
static
   TCHAR                  ** gArgv;
static
   TScmEpRc                  grcScmEp=TScmEpRc_Unknown; // TScmEp return code

///////////////////////////////////////////////////////////////////////////////
// Private function prototypes
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceMain(
      DWORD                  argc         ,// in -number of arguments
      TCHAR               ** argv          // in -string argument array
   );

static
void
   TScmServiceCtrl(
      DWORD                  dwCtrlCode
   );

static
DWORD WINAPI                               // ret-OS return code
   TScmServiceWorker(
      void                 * notUsed       // i/o-not used
   );

static
BOOL                                       // ret-TRUE if successful
   TScmReportStatusToSCMgr(
      DWORD                  dwCurrentState,
      DWORD                  dwWin32ExitCode,
      DWORD                  dwCheckPoint,
      DWORD                  dwWaitHint
   );

///////////////////////////////////////////////////////////////////////////////
// Entry point from caller's 'main' function
///////////////////////////////////////////////////////////////////////////////

TScmEpRc                                   // TScmEp return code
   TScmEp(
      int                    argc         ,// in -argument count
      char          const ** argv         ,// in -argument array
      TCHAR                * nameService   // in -name of service
   )
{
   int                       argn;         // argument number

   SERVICE_TABLE_ENTRY       dispatchTable[] =
   {
      { nameService, (LPSERVICE_MAIN_FUNCTION) TScmServiceMain },
      { NULL, NULL }
   };

   gNameService = nameService;
   grcScmEp = TScmEpRc_Unknown;

   for ( argn = 1;
         argn < argc;
         argn++ )
   {
      if ( !UScmCmdLineArgs( argv[argn] ) )
      {
         grcScmEp = TScmEpRc_InvArgCli;
      }
   }

   if ( grcScmEp == TScmEpRc_Unknown )
   {
      if ( UScmForceCli() || !StartServiceCtrlDispatcher( dispatchTable ) )
      {
//         UScmEp( FALSE );
         UScmEp();
         grcScmEp = TScmEpRc_OkCli;
      }
      else
      {
         grcScmEp = TScmEpRc_OkSrv;
      }
   }

   return grcScmEp;
}

///////////////////////////////////////////////////////////////////////////////
// Mainline for service
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceMain(
      DWORD                  argc         ,// in -number of arguments
      TCHAR               ** argv          // in -string argument array
   )
{
   DWORD                     dwWait;
   DWORD                     idThread;
   HANDLE                    hThread=INVALID_HANDLE_VALUE;

   gArgc = argc;
   gArgv = argv;

   do // once or until break
   {
      ghServiceStatus = RegisterServiceCtrlHandler(
            gNameService,
            (LPHANDLER_FUNCTION) TScmServiceCtrl );
      if ( !ghServiceStatus )
      {
         break;
      }
      gServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
      gServiceStatus.dwServiceSpecificExitCode = 0;
      if ( !TScmReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 1,
            WAIT_HINT_MILLISECONDS ) )
      {
         break;
      }
      ghServDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
      if ( ghServDoneEvent == INVALID_HANDLE_VALUE )
      {
         break;
      }
      if ( !TScmReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 2,
            WAIT_HINT_MILLISECONDS ) )
      {
         break;
      }
      hThread = CreateThread( NULL, 0, TScmServiceWorker, NULL, 0, &idThread );
      if ( hThread == INVALID_HANDLE_VALUE )
      {
         break;
      }
      if ( !TScmReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0, 0 ) )
      {
         break;
      }
      dwWait = WaitForSingleObject( ghServDoneEvent, INFINITE );
   }  while ( FALSE );

   if ( hThread != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hThread );
      hThread = INVALID_HANDLE_VALUE;
   }

   if ( ghServDoneEvent != INVALID_HANDLE_VALUE )
   {
      CloseHandle( ghServDoneEvent );
      ghServDoneEvent = INVALID_HANDLE_VALUE;
   }

   if ( ghServiceStatus )
   {
      TScmReportStatusToSCMgr( SERVICE_STOPPED, 0, 0, 0 );
   }
}

///////////////////////////////////////////////////////////////////////////////
// Service control handler
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceCtrl(
      DWORD                  dwCtrlCode
   )
{
   DWORD                     dwState = SERVICE_RUNNING;

   switch ( dwCtrlCode )
   {
      case SERVICE_CONTROL_STOP:
      case SERVICE_CONTROL_SHUTDOWN:
         dwState = SERVICE_STOP_PENDING;
         TScmReportStatusToSCMgr( SERVICE_STOP_PENDING, NO_ERROR, 1,
               WAIT_HINT_MILLISECONDS );
         SetEvent( ghServDoneEvent );
         return;
      case SERVICE_CONTROL_INTERROGATE:
         break;
      default:
         break;
   }

   TScmReportStatusToSCMgr( dwState, NO_ERROR, 0, 0 );
}

///////////////////////////////////////////////////////////////////////////////
// Service worker thread
///////////////////////////////////////////////////////////////////////////////

static
DWORD WINAPI                               // ret-OS return code
   TScmServiceWorker(
      void                 * notUsed       // i/o-not used
   )
{
   for ( DWORD i = 1;
         i < gArgc;
         i++ )
   {
      if ( !UScmCmdLineArgs( gArgv[i] ) )
      {
         grcScmEp = TScmEpRc_InvArgSrv;
      }
   }

   if ( grcScmEp != TScmEpRc_InvArgSrv )
   {
//      UScmEp( TRUE );
      UScmEp();
   }

   SetEvent( ghServDoneEvent );

   return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Report status to Service Control Manager
///////////////////////////////////////////////////////////////////////////////

static
BOOL                                       // ret-TRUE if successful
   TScmReportStatusToSCMgr(
      DWORD                  dwCurrentState,
      DWORD                  dwWin32ExitCode,
      DWORD                  dwCheckPoint,
      DWORD                  dwWaitHint
   )
{
   BOOL                      bRc;          // boolean return code

   if ( dwCurrentState == SERVICE_START_PENDING )
   {
      gServiceStatus.dwControlsAccepted = 0;
   }
   else
   {
      gServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
   }

   gServiceStatus.dwCurrentState = dwCurrentState;
   gServiceStatus.dwWin32ExitCode = dwWin32ExitCode;
   gServiceStatus.dwCheckPoint = dwCheckPoint;
   gServiceStatus.dwWaitHint = dwWaitHint;
   bRc = SetServiceStatus( ghServiceStatus, &gServiceStatus );

   if ( !bRc )
   {
      SetEvent( ghServDoneEvent );
   }

   return bRc;
}

// TService.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\validation.cpp ===
#include <TChar.h>
#include <ComDef.h>
#include <Windows.h>
#include <Validation.h>
#include <ResStr.h>


// IsValidPrefixOrSuffix Function

bool __stdcall IsValidPrefixOrSuffix(LPCTSTR pszPrefixOrSuffix)
{
	bool bValid = false;

	if (pszPrefixOrSuffix)
	{
		int cchPrefixOrSuffix = _tcslen(pszPrefixOrSuffix);

	//	if (cchPrefixOrSuffix <= MAXIMUM_PREFIX_SUFFIX_LENGTH)
	//	{
		//	BOOL bDefaultUsed;
		//	CHAR szAnsi[2 * MAXIMUM_PREFIX_SUFFIX_LENGTH];

		//	int cchAnsi = WideCharToMultiByte(
		//		CP_ACP,
		//		WC_NO_BEST_FIT_CHARS,
		//		pszPrefixOrSuffix,
		//		cchPrefixOrSuffix,
		//		szAnsi,
		//		sizeof(szAnsi) / sizeof(szAnsi[0]),
		//		NULL,
		//		&bDefaultUsed
		//	);

		//	if ((cchAnsi != 0) && (bDefaultUsed == FALSE))
		//	{
				_TCHAR szInvalidPunctuation[256];

				_bstr_t strInvalid(GET_WSTR(IDS_INVALID_PREFIX_SUFFIX));

				if (strInvalid.length() > 0)
				{
					_tcsncpy(szInvalidPunctuation, strInvalid, 255);
					szInvalidPunctuation[255] = _T('\0');
				}
				else
				{
					szInvalidPunctuation[0] = _T('\0');
				}

				WORD wCharType;

				bool bInvalidTypeFound = false;

				for (int i = 0; i < cchPrefixOrSuffix; i++)
				{
					if (GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, &pszPrefixOrSuffix[i], 1, &wCharType))
					{
						if (wCharType & C1_CNTRL)
						{
							bInvalidTypeFound = true;
							break;
						}

						if (wCharType & C1_PUNCT)
						{
							if (_tcschr(szInvalidPunctuation, pszPrefixOrSuffix[i]) != NULL)
							{
								bInvalidTypeFound = true;
								break;
							}
						}
					}
				}

				if (bInvalidTypeFound == false)
				{
					bValid = true;
				}
		//	}
	//	}
	}

	return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\txtsid.cpp ===
/*---------------------------------------------------------------------------
  File: TextualSid.cpp

  Comments: Converts a SID to and from its canonical textual representation.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:33:52

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#endif
#include "Mcs.h"
#include "TxtSid.h"

#ifndef SECURITY_MAX_SID_SIZE
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#endif

BOOL 
   GetTextualSid(    
      PSID                   pSid,           // in - binary Sid
      LPTSTR                 TextualSid,     // i/o- buffer for Textual representation of Sid
      LPDWORD                lpdwBufferLen   // in - required/provided TextualSid buffersize    
   )
{
   PSID_IDENTIFIER_AUTHORITY psia;    
   DWORD                     dwSubAuthorities;
   DWORD                     dwSidRev=SID_REVISION;    
   DWORD                     dwCounter;    
   DWORD                     dwSidSize;
   
   // Validate the binary SID.    
   if(!IsValidSid(pSid))
   {
      SetLastError(ERROR_INVALID_SID); 
      return FALSE;
   }
   // Get the identifier authority value from the SID.
   psia = GetSidIdentifierAuthority(pSid);
   // Get the number of subauthorities in the SID.
   dwSubAuthorities = *GetSidSubAuthorityCount(pSid);
   // Compute the buffer length.
   // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL
   dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);
   
   // Check input buffer length.
   // If too small, indicate the proper size and set last error.
   if (*lpdwBufferLen < dwSidSize)    
   {        
      *lpdwBufferLen = dwSidSize;
      SetLastError(ERROR_INSUFFICIENT_BUFFER);        
      return FALSE;    
   }
   // Add 'S' prefix and revision number to the string.
   dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );
   // Add SID identifier authority to the string.
   if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )    
   {
      dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                   (USHORT)psia->Value[0],
                   (USHORT)psia->Value[1],
                   (USHORT)psia->Value[2],
                   (USHORT)psia->Value[3],
                   (USHORT)psia->Value[4],
                   (USHORT)psia->Value[5]);    
   }    
   else    
   {
      dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("%lu"),
                   (ULONG)(psia->Value[5]      )   +
                   (ULONG)(psia->Value[4] <<  8)   +
                   (ULONG)(psia->Value[3] << 16)   +
                   (ULONG)(psia->Value[2] << 24)   );    
   }
   // Add SID subauthorities to the string.    //
   for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)    
   {
      dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                   *GetSidSubAuthority(pSid, dwCounter) );    
   }    
   return TRUE;
} 

PSID                                       // ret- binary representation of SID, or NULL caller must free using FreeSid()
   SidFromString(
      WCHAR          const * strSid        // in - string representation of SID
   )
{
   BOOL                      bSuccess = TRUE;
   PSID                      pSid = NULL;
   DWORD                     dwSidRev;
//   WCHAR                   * strPtr = NULL;
   WCHAR                     sidIA[100];
   WCHAR                     sidSubs[100];
   int                       ia0,ia1,ia2,ia3,ia4,ia5;
   SID_IDENTIFIER_AUTHORITY  sia;
   
   do 
   {
      if ( strSid[0] != L'S' || strSid[1] != L'-' )
      {
         bSuccess = FALSE;
         break;
      }
      // Read SID revision level
      sidSubs[0] = 0;
      int result = swscanf(strSid,L"S-%d-%[^-]-%ls",&dwSidRev,sidIA,sidSubs);
      if ( result == 3 )
      {
         // evaluate the IA
         if ( sidIA[1] == L'x' )
         {
            // full format
            result = swscanf(sidIA,L"0x%02hx%02hx%02hx%02hx%02hx%02hx",&ia0,&ia1,&ia2,&ia3,&ia4,&ia5);
            if ( result == 6 )
            {
               sia.Value[0] = (BYTE) ia0; 
               sia.Value[1] = (BYTE) ia1; 
               sia.Value[2] = (BYTE) ia2; 
               sia.Value[3] = (BYTE) ia3; 
               sia.Value[4] = (BYTE) ia4; 
               sia.Value[5] = (BYTE) ia5; 
               
            }
            else
            {
               bSuccess = FALSE;
               break;
            }
         }
         else
         {
            DWORD            bignumber;

            result = swscanf(sidIA,L"%lu",&bignumber);
            sia.Value[0] = 0;
            sia.Value[1] = 0;
            sia.Value[2] = BYTE( (bignumber & 0xff000000) >> 24);
            sia.Value[3] = BYTE( (bignumber & 0x00ff0000) >> 16);
            sia.Value[4] = BYTE( (bignumber & 0x0000ff00) >>  8);
            sia.Value[5] = BYTE(bignumber & 0x000000ff);
         }

         // read the subauthorities 
         DWORD           subs[10];

         memset(subs,0,(sizeof subs));

         result = swscanf(sidSubs,L"%lu-%lu-%lu-%lu-%lu-%lu-%lu-%lu",&subs[0],&subs[1],&subs[2],&subs[3],&subs[4],
                           &subs[5],&subs[6],&subs[7]);

         if ( result )
         {
            if ( !AllocateAndInitializeSid(&sia,(BYTE)result,subs[0],subs[1],subs[2],subs[3],subs[4],subs[5],subs[6],subs[7],&pSid) )
            {
               pSid = NULL;
               bSuccess = FALSE;
            }
         }
      }
   } while ( false);

      //see if IsValidSid also thinks this is valid
   if (pSid)
   {
	     //if not valid, free it and return NULL
      if (!IsValidSid(pSid))
	  {
		  FreeSid(pSid);
		  pSid = NULL;
	  }
   }

   return pSid;
}

/*****************************************************************************************************/
/*   DomainizeSid: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSid(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   ) 
{
   MCSASSERT(psid);

   UCHAR                     len = (* GetSidSubAuthorityCount(psid));
   PDWORD                    sub = GetSidSubAuthority(psid,len-1);
   
   if ( *sub != -1 )
   {
      DWORD                  sdsize = GetSidLengthRequired(len+1);  // sid doesn't already have -1 as rid
      PSID                   newsid = (SID *)malloc(sdsize); // copy the sid, and add -1 to the end

      if (newsid)
      {
         if ( ! InitializeSid(newsid,GetSidIdentifierAuthority(psid),len+1) )  // make a bigger sid w/same IA
         {
            MCSASSERT(false);
         }
         for ( DWORD i = 0 ; i < len ; i++ )
         {
            sub = GetSidSubAuthority(newsid,i);                        // copy subauthorities
            (*sub) = (*GetSidSubAuthority(psid,i));
         }
         sub = GetSidSubAuthority(newsid,len);
         *sub = -1;                                                  // set rid =-1
         if ( freeOldSid )
         {
            FreeSid(psid);
         }
         psid = newsid;
         len++;
      }
      else
      {
         return NULL;
      }
   }
  return psid;   
}            

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for taking the given source and  *
 * target account SIDs and breaking them up and returning the src    *
 * domain sid, src account rid, tgt domain sid, and tgt account rid. *
 *     The caller must call "FreeSid" on the src and tgt domain sid   *
 * pointers.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN SplitAccountSids
BOOL                                            // ret - Success ? TRUE | FALSE
   SplitAccountSids(
      PSID					 srcSid,			// in - src account sid
	  WCHAR                 *srcDomainSid,		// out - src domain sid textual
	  DWORD                 *srcRid,			// out - src account rid
	  PSID                   tgtSid,			// in - tgt account sid
	  WCHAR                 *tgtDomainSid,		// out - tgt domain sid textual
	  DWORD                 *tgtRid				// out - tgt account rid
   )
{
/* local variables */
   DWORD    sidLen;
   UCHAR    Count;
   PDWORD   psubAuth;
   BOOL		bSuccess = TRUE;
   DWORD	lenTxt = MAX_PATH;
   
/* function body */
   if ((!IsValidSid(srcSid)) && (!IsValidSid(tgtSid)))
      return FALSE;

      //split up the src account sid
   sidLen = GetLengthSid(srcSid);
   PSID srcDomSid = new BYTE[sidLen+1];
   if (!srcDomSid)
	  return FALSE;

   if (!CopySid(sidLen+1, srcDomSid, srcSid))
   {
	  delete [] srcDomSid;
	  return FALSE;
   }

      //get the RID out of the SID and get the domain SID
   Count = (* GetSidSubAuthorityCount(srcDomSid));
   psubAuth = GetSidSubAuthority(srcDomSid, Count-1);
   if (psubAuth) 
   {
      *srcRid = *psubAuth;
      *psubAuth = -1;
   }
   
      //convert domain sid to text format
   if (srcDomSid)
   {
      if (!GetTextualSid(srcDomSid,srcDomainSid,&lenTxt)) {
    	  delete [] srcDomSid;
          return FALSE;
      }
      
	  delete [] srcDomSid;
   }

     //split up the tgt account sid
   sidLen = GetLengthSid(tgtSid);
   PSID tgtDomSid = new BYTE[sidLen+1];
   if (!tgtDomSid)
	  return FALSE;
      
   if (!CopySid(sidLen+1, tgtDomSid, tgtSid))
   {
	  delete [] tgtDomSid;
	  return FALSE;
   }

      //get the RID out of the SID and get the domain SID
   Count = (* GetSidSubAuthorityCount(tgtDomSid));
   psubAuth = GetSidSubAuthority(tgtDomSid, Count-1);
   if (psubAuth) 
   {
      *tgtRid = *psubAuth;
      *psubAuth = -1;
   }
   
      //convert domain sid to text format
   lenTxt = MAX_PATH;
   if (tgtDomSid)
   {
      if (!GetTextualSid(tgtDomSid,tgtDomainSid,&lenTxt)) {
    	  delete [] tgtDomSid;
          return FALSE;
      }
      
	  delete [] tgtDomSid;
   }

   return bSuccess;
}
//END SplitAccountSids


PSID                                       // ret- binary representation of SID, or NULL caller must free using free()
   MallocedSidFromString(
      WCHAR          const * strSid        // in - string representation of SID
   )
{
/* local constants */
   const BYTE				 NUM_OF_SUBAUTHS = 8;

/* local variables */
   BOOL                      bSuccess = TRUE;
   PSID                      pSid = (SID *)malloc(SECURITY_MAX_SID_SIZE); // create a new sid
   DWORD                     dwSidRev;
   WCHAR                     sidIA[100];
   WCHAR                     sidSubs[100];
   int                       ia0,ia1,ia2,ia3,ia4,ia5;
   SID_IDENTIFIER_AUTHORITY  sia;
   
/* function body */
	if (!pSid)
		return pSid;

	do
	{
		if ( strSid[0] != L'S' || strSid[1] != L'-' )
		{
			bSuccess = FALSE;
			break;
		}

			// Read SID revision level
		sidSubs[0] = 0;
		int result = swscanf(strSid,L"S-%d-%[^-]-%ls",&dwSidRev,sidIA,sidSubs);
		if ( result == 3 )
		{
				// evaluate the IA
			if ( sidIA[1] == L'x' )
			{
					// full format
				result = swscanf(sidIA,L"0x%02hx%02hx%02hx%02hx%02hx%02hx",&ia0,&ia1,&ia2,&ia3,&ia4,&ia5);
				if ( result == 6 )
				{
					sia.Value[0] = (BYTE) ia0; 
					sia.Value[1] = (BYTE) ia1; 
					sia.Value[2] = (BYTE) ia2; 
					sia.Value[3] = (BYTE) ia3; 
					sia.Value[4] = (BYTE) ia4; 
					sia.Value[5] = (BYTE) ia5; 
				}
				else
				{
					bSuccess = FALSE;
					break;
				}
			}
			else
			{
				DWORD            bignumber;
	
				result = swscanf(sidIA,L"%lu",&bignumber);
				sia.Value[0] = 0;
				sia.Value[1] = 0;
				sia.Value[2] = BYTE( (bignumber & 0xff000000) >> 24);
				sia.Value[3] = BYTE( (bignumber & 0x00ff0000) >> 16);
				sia.Value[4] = BYTE( (bignumber & 0x0000ff00) >>  8);
				sia.Value[5] = BYTE(bignumber & 0x000000ff);
			}

				// read the subauthorities 
			DWORD           subs[10];

			memset(subs,0,(sizeof subs));

			result = swscanf(sidSubs,L"%lu-%lu-%lu-%lu-%lu-%lu-%lu-%lu",&subs[0],&subs[1],&subs[2],&subs[3],&subs[4],
								&subs[5],&subs[6],&subs[7]);

			if ( result )
			{
					//initialize the new SID (result ids the number of sub authorities)
				if (!InitializeSid(pSid, &sia, (BYTE)result))
				{
					bSuccess = FALSE;
					break;
				}

					//add the sub authorities
				PDWORD   sub;
				for (int ndx = 0; ndx < result; ndx++)
				{
					sub = GetSidSubAuthority(pSid, ndx);
					*sub = subs[ndx];
				}
			}
		}
		else
		{
		    bSuccess = FALSE;
		    break;
	       }
	} while (FALSE);

		//if we failed above, free the sid
	if (!bSuccess)
	{
		free(pSid);
		pSid = NULL;
	}

		//see if IsValidSid also thinks this is valid
	if (pSid)
	{
			//if not valid, free it and return NULL
		if (!IsValidSid(pSid))
		{
			free(pSid);
			pSid = NULL;
		}
	}

	return pSid;
}


//---------------------------------------------------------------------------
// SafeCopySid Function
//
// Synopsis
// Creates a copy of the given SID if the given SID is valid.
//
// Arguments
// IN pSidOld - the SID which is to be copied
//
// Return
// A new SID which is a copy of the given SID. Must be freed using FreeSid().
//---------------------------------------------------------------------------

PSID __stdcall SafeCopySid(PSID pSidOld)
{
    PSID pSidNew = NULL;

    if (pSidOld)
    {
        if (IsValidSid(pSidOld))
        {
            SID_IDENTIFIER_AUTHORITY sia = SECURITY_NULL_SID_AUTHORITY;
            PUCHAR pucCount = GetSidSubAuthorityCount(pSidOld);

            if (AllocateAndInitializeSid(&sia, *pucCount, 0, 0, 0, 0, 0, 0, 0, 0, &pSidNew))
            {
                if (!CopySid(GetLengthSid(pSidNew), pSidNew, pSidOld))
                {
                    FreeSid(pSidNew);
                    pSidNew = NULL;
                }
            }
        }
    }

    return pSidNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\admtcrypt.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


#define ENCRYPTION_KEY_SIZE 16 // in bytes
#define SESSION_KEY_SIZE    16 // in bytes


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------

class CCryptProvider
{
public:

	CCryptProvider();
	CCryptProvider(const CCryptProvider& r);
	~CCryptProvider();

	CCryptProvider& operator =(const CCryptProvider& r);

	HCRYPTHASH CreateHash(ALG_ID aid);
	HCRYPTKEY DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags = 0);

	_variant_t GenerateRandom(DWORD cbData) const;
	void GenerateRandom(BYTE* pbData, DWORD cbData) const;

protected:

	HCRYPTPROV m_hProvider;
};


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------

class CCryptKey
{
public:

	CCryptKey(HCRYPTKEY hKey = NULL);
	~CCryptKey();

	operator HCRYPTKEY()
	{
		return m_hKey;
	}

	void Attach(HCRYPTKEY hKey)
	{
		m_hKey = hKey;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}

	_variant_t Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);
	_variant_t Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);

protected:

	CCryptKey(const CCryptKey& key) {}
	CCryptKey& operator =(const CCryptKey& key) { return *this; }

protected:

	HCRYPTKEY m_hKey;
};


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------

class CCryptHash
{
public:

	CCryptHash(HCRYPTHASH hHash = NULL);
	~CCryptHash();

	operator HCRYPTHASH()
	{
		return m_hHash;
	}

	void Attach(HCRYPTHASH hHash)
	{
		m_hHash = hHash;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hHash = m_hHash;
		m_hHash = NULL;
		return hHash;
	}

	_variant_t GetValue() const;
	void SetValue(const _variant_t& vntValue);

	void Hash(LPCTSTR pszData);
	void Hash(const _variant_t& vntData);
	void Hash(BYTE* pbData, DWORD cbData);

	bool operator ==(const CCryptHash& hash);

	bool operator !=(const CCryptHash& hash)
	{
		return !this->operator ==(hash);
	}

protected:

	CCryptHash(const CCryptKey& hash) {}
	CCryptHash& operator =(const CCryptHash& hash) { return *this; }

protected:

	HCRYPTHASH m_hHash;
};


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------

class CDomainCrypt : public CCryptProvider
{
protected:

	CDomainCrypt();
	~CDomainCrypt();

	HCRYPTKEY GetEncryptionKey(LPCTSTR pszKeyId);

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes);
	void StoreBytes(LPCTSTR pszId, BYTE* pBytes, DWORD cBytes);
	_variant_t RetrieveBytes(LPCTSTR pszId);

protected:

	static _TCHAR m_szIdPrefix[];
};


//---------------------------------------------------------------------------
// Target Crypt Class
//
// CreateEncryptionKey
// - creates encryption key
// - stores encryption key using key identifier
// - returns encryption key encrypted with given password
//---------------------------------------------------------------------------

class CTargetCrypt : public CDomainCrypt
{
public:

	CTargetCrypt();
	~CTargetCrypt();

	_variant_t CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword = NULL);

	_variant_t CreateSession(LPCTSTR pszKeyId);

	_variant_t Encrypt(_bstr_t strData);

protected:

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		CDomainCrypt::StoreBytes(psz, vntBytes);
	}

	_variant_t RetrieveBytes(LPCTSTR pszId)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		return CDomainCrypt::RetrieveBytes(psz);
	}

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------

class CSourceCrypt : public CDomainCrypt
{
public:

	CSourceCrypt();
	~CSourceCrypt();

	void ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword = NULL);

	void ImportSessionKey(const _variant_t& vntEncryptedKey);

	_bstr_t Decrypt(const _variant_t& vntData);

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Use Cases
//---------------------------------------------------------------------------
//
// Target Domain Controller
// ------------------------
// Generate Encryption Key
// - given source domain name and optional password
// - generate 128 bit encryption key
// - store encryption key using source domain name
// - if given optional password encrypt key with password
// - return encrypted key
//
// Generate Session Key
// - given source domain name
// - generate 128 bit session key
// - generate hash of session key
// - retrieve encryption key using source domain name
// - encrypt session key and hash with encryption key
// - return encrypted session key/hash
//
// Encrypt Data
// - given data
// - encrypt data using session key
// - return encrypted data
//
// Password Export Server (PES)
// ----------------------------
// Store Encryption Key
// - given encrypted encryption key and password
// - decrypt key using password
// - store key
//
// Decrypt Session Key
// - given an encrypted session key / hash
// - decrypt using encryption key
// - generate hash of decrypted session key
// - compare against decrypted hash
// - store session key
// - return success or failure
//
// Decrypt Data
// - given encrypted data
// - decrypt data using session key
// - return un-encrypted data
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\adsihelpers.h ===
#pragma once

#include <map>
#include <string>
#include <vector>
#include <TChar.h>
#include <ComDef.h>
#include <ActiveDS.h>

#ifndef tstring
typedef std::basic_string<_TCHAR> tstring;
#endif

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef IADsUserPtr
_COM_SMARTPTR_TYPEDEF(IADsUser, IID_IADsUser);
#endif

#ifndef IADsADSystemInfoPtr
_COM_SMARTPTR_TYPEDEF(IADsADSystemInfo, IID_IADsADSystemInfo);
#endif
#ifndef IADsPathnamePtr
_COM_SMARTPTR_TYPEDEF(IADsPathname, IID_IADsPathname);
#endif

#ifndef IDirectoryObjectPtr
_COM_SMARTPTR_TYPEDEF(IDirectoryObject, IID_IDirectoryObject);
#endif

#ifndef IADsDeleteOpsPtr
_COM_SMARTPTR_TYPEDEF(IADsDeleteOps, IID_IADsDeleteOps);
#endif

#ifndef IDirectorySearchPtr
_COM_SMARTPTR_TYPEDEF(IDirectorySearch, IID_IDirectorySearch);
#endif


//---------------------------------------------------------------------------
// CADs Class
//---------------------------------------------------------------------------


class CADs
{
public:

	CADs(IADsPtr spADs) :
		m_spADs(spADs)
	{
	}

	CADs(LPCTSTR pszADsPath = NULL)
	{
		if (pszADsPath)
		{
			CheckResult(ADsGetObject(pszADsPath, IID_IADs, (VOID**)&m_spADs));
		}
	}

	CADs(const CADs& r) :
		m_spADs(r.m_spADs)
	{
	}

	operator bool() const
	{
		return m_spADs;
	}

	operator IADs*() const
	{
		return m_spADs;
	}

	CADs& operator =(IADsPtr spADs)
	{
		m_spADs = spADs;
		return *this;
	}

	CADs& operator =(const CADs& r)
	{
		m_spADs = r.m_spADs;
		return *this;
	}

	_bstr_t GetName()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Name(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetClass()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Class(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetGUID()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_GUID(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetADsPath()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_ADsPath(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetParent()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Parent(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSchema()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Schema(&bstr));
		return _bstr_t(bstr, false);
	}

	void GetInfo()
	{
		CheckResult(m_spADs->GetInfo());
	}

	void SetInfo()
	{
		CheckResult(m_spADs->SetInfo());
	}

	_variant_t Get(_bstr_t strName)
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADs->Get(strName, &vnt));
		return _variant_t(vnt, false);
	}

	void Put(_bstr_t strName, const _variant_t& vntValue)
	{
		CheckResult(m_spADs->Put(strName, vntValue));
	}

	_variant_t GetEx(_bstr_t strName)
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADs->GetEx(strName, &vnt));
		return _variant_t(vnt, false);
	}

	void PutEx(long lControlCode, _bstr_t strName, const _variant_t& vntValue)
	{
		CheckResult(m_spADs->PutEx(lControlCode, strName, vntValue));
	}

	void GetInfoEx(const _variant_t& vntProperties, long lReserved)
	{
		CheckResult(m_spADs->GetInfoEx(vntProperties, lReserved));
	}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADs), IID_IADs);
		}
	}

protected:

	IADsPtr m_spADs;
};


//---------------------------------------------------------------------------
// CADsContainer Class
//---------------------------------------------------------------------------


class CADsContainer : public CADs
{
protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADsContainer), IID_IADsContainer);
		}
	}

public:

	CADsContainer(IADsContainerPtr spADsContainer) :
		CADs(spADsContainer),
		m_spADsContainer(spADsContainer)
	{
	}

	CADsContainer(LPCTSTR pszADsPath = NULL) :
		CADs(pszADsPath)
	{
		m_spADsContainer = m_spADs;
	}

	CADsContainer(const CADsContainer& r) :
		CADs(r),
		m_spADsContainer(r.m_spADsContainer)
	{
	}

	operator bool() const
	{
		return m_spADsContainer;
	}

	operator IADsContainer*() const
	{
		return m_spADsContainer;
	}

	CADsContainer& operator =(IADsContainerPtr spADsContainer)
	{
		m_spADs = spADsContainer;
		m_spADsContainer = spADsContainer;
		return *this;
	}

	CADsContainer& operator =(const CADsContainer& r)
	{
		m_spADs = r.m_spADs;
		m_spADsContainer = r.m_spADsContainer;
		return *this;
	}

	long GetCount()
	{
		long l;
		CheckResult(m_spADsContainer->get_Count(&l));
		return l;
	}

	IEnumVARIANTPtr GetEnumerator()
	{
		IUnknown* punk;
		CheckResult(m_spADsContainer->get__NewEnum(&punk));
		return IEnumVARIANTPtr(IUnknownPtr(punk, false));
	}

	_variant_t GetFilter()
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADsContainer->get_Filter(&vnt));
		return _variant_t(vnt, false);
	}

	void SetFilter(const _variant_t& vnt)
	{
		CheckResult(m_spADsContainer->put_Filter(vnt));
	}

	_variant_t GetHints()
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADsContainer->get_Hints(&vnt));
		return _variant_t(vnt, false);
	}

	void SetHints(const _variant_t& vnt)
	{
		CheckResult(m_spADsContainer->put_Hints(vnt));
	}

	IDispatchPtr GetObject(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->GetObject(strClassName, strRelativeName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	IDispatchPtr Create(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->Create(strClassName, strRelativeName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	void Delete(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		CheckResult(m_spADsContainer->Delete(strClassName, strRelativeName));
	}

	IDispatchPtr CopyHere(_bstr_t strSourceName, _bstr_t strNewName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->CopyHere(strSourceName, strNewName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	IDispatchPtr MoveHere(_bstr_t strSourceName, _bstr_t strNewName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->MoveHere(strSourceName, strNewName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

protected:

	IADsContainerPtr m_spADsContainer;
};


//---------------------------------------------------------------------------
// CADsUser Class
//---------------------------------------------------------------------------


class CADsUser : public CADs
{
public:

	CADsUser(IADsUserPtr spADsUser) :
		CADs(spADsUser),
		m_spADsUser(spADsUser)
	{
	}

	CADsUser(LPCTSTR pszADsPath = NULL) :
		CADs(pszADsPath)
	{
		m_spADsUser = m_spADs;
	}

	CADsUser(const CADsUser& r) :
		CADs(r),
		m_spADsUser(r.m_spADsUser)
	{
	}

	operator bool() const
	{
		return m_spADsUser;
	}

	operator IADsUser*() const
	{
		return m_spADsUser;
	}

	CADsUser& operator =(IADsUserPtr spADsUser)
	{
		m_spADs = spADsUser;
		m_spADsUser = spADsUser;
		return *this;
	}

	CADsUser& operator =(const CADsUser& r)
	{
		m_spADs = r.m_spADs;
		m_spADsUser = r.m_spADsUser;
		return *this;
	}

	_bstr_t GetBadLoginAddress()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_BadLoginAddress(&bstr));
		return _bstr_t(bstr, false);
	}

	DATE GetLastLogin()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastLogin(&d));
		return d;
	}

	DATE GetLastLogoff()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastLogoff(&d));
		return d;
	}

	DATE GetLastFailedLogin()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastFailedLogin(&d));
		return d;
	}

	DATE GetPasswordLastChanged()
	{
		DATE d;
		CheckResult(m_spADsUser->get_PasswordLastChanged(&d));
		return d;
	}

	_bstr_t GetDescription()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Description(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDescription(_bstr_t strDescription)
	{
		CheckResult(m_spADsUser->put_Description(strDescription));
	}

	_bstr_t GetDivision()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Division(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDivision(_bstr_t strDivision)
	{
		CheckResult(m_spADsUser->put_Division(strDivision));
	}

	_bstr_t GetDepartment()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Department(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDepartment(_bstr_t strDepartment)
	{
		CheckResult(m_spADsUser->put_Department(strDepartment));
	}

	_bstr_t GetEmployeeId()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_EmployeeID(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetEmployeeId(_bstr_t strEmployeeId)
	{
		CheckResult(m_spADsUser->put_EmployeeID(strEmployeeId));
	}

	_bstr_t GetFullName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_FullName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetFullName(_bstr_t strFullName)
	{
		CheckResult(m_spADsUser->put_FullName(strFullName));
	}

	_bstr_t GetFirstName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_FirstName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetFirstName(_bstr_t strFirstName)
	{
		CheckResult(m_spADsUser->put_FirstName(strFirstName));
	}

	_bstr_t GetLastName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_LastName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetLastName(_bstr_t strLastName)
	{
		CheckResult(m_spADsUser->put_LastName(strLastName));
	}

	_bstr_t GetOtherName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_OtherName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetOtherName(_bstr_t strOtherName)
	{
		CheckResult(m_spADsUser->put_OtherName(strOtherName));
	}

	_bstr_t GetNamePrefix()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_NamePrefix(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetNamePrefix(_bstr_t strNamePrefix)
	{
		CheckResult(m_spADsUser->put_NamePrefix(strNamePrefix));
	}

	_bstr_t GetNameSuffix()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_NameSuffix(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetNameSuffix(_bstr_t strNameSuffix)
	{
		CheckResult(m_spADsUser->put_NameSuffix(strNameSuffix));
	}

	_bstr_t GetTitle()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Title(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetTitle(_bstr_t strTitle)
	{
		CheckResult(m_spADsUser->put_Title(strTitle));
	}

	_bstr_t GetManager()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Manager(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetManager(_bstr_t strManager)
	{
		CheckResult(m_spADsUser->put_Manager(strManager));
	}
/*
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneHome( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneHome( 
            VARIANT vTelephoneHome) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneMobile( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneMobile( 
            VARIANT vTelephoneMobile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            VARIANT vTelephoneNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephonePager( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephonePager( 
            VARIANT vTelephonePager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            VARIANT vFaxNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_OfficeLocations( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_OfficeLocations( 
            VARIANT vOfficeLocations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PostalAddresses( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PostalAddresses( 
            VARIANT vPostalAddresses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PostalCodes( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PostalCodes( 
            VARIANT vPostalCodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SeeAlso( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SeeAlso( 
            VARIANT vSeeAlso) = 0;
*/
		bool GetAccountDisabled()
		{
			VARIANT_BOOL b;
			CheckResult(m_spADsUser->get_AccountDisabled(&b));
			return b ? true : false;
		}

		void SetAccountDisabled(bool bAccountDisabled)
		{
			CheckResult(m_spADsUser->put_AccountDisabled(bAccountDisabled ? VARIANT_TRUE : VARIANT_FALSE));
		}
/*
        virtual HRESULT STDMETHODCALLTYPE get_AccountExpirationDate( 
            DATE __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_AccountExpirationDate( 
            DATE daAccountExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GraceLoginsAllowed( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_GraceLoginsAllowed( 
            long lnGraceLoginsAllowed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GraceLoginsRemaining( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_GraceLoginsRemaining( 
            long lnGraceLoginsRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_IsAccountLocked( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IsAccountLocked( 
            VARIANT_BOOL fIsAccountLocked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginHours( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginHours( 
            VARIANT vLoginHours) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginWorkstations( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginWorkstations( 
            VARIANT vLoginWorkstations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MaxLogins( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MaxLogins( 
            long lnMaxLogins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MaxStorage( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MaxStorage( 
            long lnMaxStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordExpirationDate( 
            DATE __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordExpirationDate( 
            DATE daPasswordExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordMinimumLength( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordMinimumLength( 
            long lnPasswordMinimumLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordRequired( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordRequired( 
            VARIANT_BOOL fPasswordRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_RequireUniquePassword( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_RequireUniquePassword( 
            VARIANT_BOOL fRequireUniquePassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            BSTR bstrEmailAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HomeDirectory( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_HomeDirectory( 
            BSTR bstrHomeDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Languages( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Languages( 
            VARIANT vLanguages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Profile( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Profile( 
            BSTR bstrProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginScript( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginScript( 
            BSTR bstrLoginScript) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Picture( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Picture( 
            VARIANT vPicture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HomePage( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_HomePage( 
            BSTR bstrHomePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Groups( 
            IADsMembers __RPC_FAR *__RPC_FAR *ppGroups) = 0;
*/
		void SetPassword(_bstr_t strNewPassword)
		{
			CheckResult(m_spADsUser->SetPassword(strNewPassword));
		}

		void ChangePassword(_bstr_t strOldPassword, _bstr_t strNewPassword)
		{
			CheckResult(m_spADsUser->ChangePassword(strOldPassword, strNewPassword));
		}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADsUser), IID_IADsUser);
		}
	}

protected:

	IADsUserPtr m_spADsUser;
};


//---------------------------------------------------------------------------
// CADsADSystemInfo Class
//---------------------------------------------------------------------------


class CADsADSystemInfo
{
public:

	CADsADSystemInfo() :
		m_sp(CLSID_ADSystemInfo)
	{
	}

	CADsADSystemInfo(IADsADSystemInfo* pADsADSystemInfo) :
		m_sp(pADsADSystemInfo)
	{
	}

	CADsADSystemInfo(const CADsADSystemInfo& r) :
		m_sp(r.m_sp)
	{
	}

	operator IADsADSystemInfo*() const
	{
		return m_sp;
	}

	_bstr_t GetUserName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_UserName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetComputerName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_ComputerName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSiteName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_SiteName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDomainShortName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_DomainShortName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDomainDNSName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_DomainDNSName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetForestDNSName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_ForestDNSName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetPDCRoleOwner()
	{
		BSTR bstr;
		CheckResult(m_sp->get_PDCRoleOwner(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSchemaRoleOwner()
	{
		BSTR bstr;
		CheckResult(m_sp->get_SchemaRoleOwner(&bstr));
		return _bstr_t(bstr, false);
	}

	bool GetIsNativeMode()
	{
		VARIANT_BOOL b;
		CheckResult(m_sp->get_IsNativeMode(&b));
		return b ? true : false;
	}

	_bstr_t GetAnyDCName()
	{
		BSTR bstr;
		CheckResult(m_sp->GetAnyDCName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDCSiteName(_bstr_t strServer)
	{
		BSTR bstr;
		CheckResult(m_sp->GetDCSiteName(strServer, &bstr));
		return _bstr_t(bstr, false);
	}

	void RefreshSchemaCache()
	{
		CheckResult(m_sp->RefreshSchemaCache());
	}

	_variant_t GetTrees()
	{
		VARIANT vnt;
		CheckResult(m_sp->GetTrees(&vnt));
		return _variant_t(vnt, false);
	}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_sp), IID_IADsADSystemInfo);
		}
	}

protected:

	IADsADSystemInfoPtr m_sp;
};


//---------------------------------------------------------------------------
// CADsPathName Class
//---------------------------------------------------------------------------


class CADsPathName
{
	// ADS_DISPLAY_ENUM
	// ADS_DISPLAY_FULL       = 1
	// ADS_DISPLAY_VALUE_ONLY = 2

	// ADS_FORMAT_ENUM
	// ADS_FORMAT_WINDOWS           =  1
	// ADS_FORMAT_WINDOWS_NO_SERVER =  2
	// ADS_FORMAT_WINDOWS_DN        =  3
	// ADS_FORMAT_WINDOWS_PARENT    =  4
	// ADS_FORMAT_X500              =  5
	// ADS_FORMAT_X500_NO_SERVER    =  6
	// ADS_FORMAT_X500_DN           =  7
	// ADS_FORMAT_X500_PARENT       =  8
	// ADS_FORMAT_SERVER            =  9
	// ADS_FORMAT_PROVIDER          = 10
	// ADS_FORMAT_LEAF              = 11

	// ADS_SETTYPE_ENUM
	// ADS_SETTYPE_FULL     = 1
	// ADS_SETTYPE_PROVIDER = 2
	// ADS_SETTYPE_SERVER   = 3
	// ADS_SETTYPE_DN       = 4
public:

	CADsPathName(_bstr_t strPath = _bstr_t(), long lSetType = ADS_SETTYPE_FULL) :
		m_sp(CLSID_Pathname)
	{
		if (strPath.length() > 0)
		{
			CheckResult(m_sp->Set(strPath, lSetType));
		}
	}

	void Set(_bstr_t strADsPath, long lSetType)
	{
		CheckResult(m_sp->Set(strADsPath, lSetType));
	}

	void SetDisplayType(long lDisplayType)
	{
		CheckResult(m_sp->SetDisplayType(lDisplayType));
	}

	_bstr_t Retrieve(long lFormatType)
	{
		BSTR bstr;
		CheckResult(m_sp->Retrieve(lFormatType, &bstr));
		return _bstr_t(bstr, false);
	}

	long GetNumElements()
	{
		long l;
		CheckResult(m_sp->GetNumElements(&l));
		return l;
	}

	_bstr_t GetElement(long lElementIndex)
	{
		BSTR bstr;
		CheckResult(m_sp->GetElement(lElementIndex, &bstr));
		return _bstr_t(bstr, false);
	}

	void AddLeafElement(_bstr_t strLeafElement)
	{
		CheckResult(m_sp->AddLeafElement(strLeafElement));
	}

	void RemoveLeafElement()
	{
		CheckResult(m_sp->RemoveLeafElement());
	}

	CADsPathName CopyPath()
	{
		IDispatch* pdisp;
		CheckResult(m_sp->CopyPath(&pdisp));
		return CADsPathName(IADsPathnamePtr(IDispatchPtr(pdisp, false)));
	}

	_bstr_t GetEscapedElement(long lReserved, _bstr_t strInStr)
	{
		BSTR bstr;
		CheckResult(m_sp->GetEscapedElement(lReserved, strInStr, &bstr));
		return _bstr_t(bstr, false);
	}

	long GetEscapedMode()
	{
		long l;
		CheckResult(m_sp->get_EscapedMode(&l));
		return l;
	}

	void PutEscapedMode(long l)
	{
		CheckResult(m_sp->put_EscapedMode(l));
	}

protected:

	CADsPathName(const CADsPathName& r) :
		m_sp(r.m_sp)
	{
	}

	CADsPathName(IADsPathnamePtr& r) :
		m_sp(r)
	{
	}

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_sp), IID_IADsPathname);
		}
	}

protected:

	IADsPathnamePtr m_sp;
};


//---------------------------------------------------------------------------
// Directory Attributes Class
//---------------------------------------------------------------------------


class CDirectoryAttributes :
	public std::map<tstring, _variant_t>
{
public:

	CDirectoryAttributes()
	{
	}

	//

	void AddAttribute(LPCTSTR pszName)
	{
		insert(value_type(tstring(pszName), _variant_t()));
	}

	void ClearValues()
	{
		for (iterator it = begin(); it != end(); it++)
		{
			it->second.Clear();
		}
	}

	const _variant_t& GetValue(LPCTSTR pszName) const
	{
		static _variant_t s_vntEmptyValue;

		const_iterator it = find(tstring(pszName));

		if (it != end())
		{
			return it->second;
		}
		else
		{
			return s_vntEmptyValue;
		}
	}

	void SetADsValue(LPCTSTR pszName, ADSTYPE atType, PADSVALUE pavValue, DWORD dwCount)
	{
		iterator it = find(tstring(pszName));

		if (it != end())
		{
			GetADsValue(atType, pavValue, dwCount, it->second);
		}
	}

protected:

	void GetADsValue(ADSTYPE atType, PADSVALUE pavValue, DWORD dwCount, _variant_t& vntValue)
	{
		switch (atType)
		{
			case ADSTYPE_DN_STRING:
			{
				vntValue = pavValue->DNString;
				break;
			}
			case ADSTYPE_CASE_EXACT_STRING:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->CaseExactString;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->CaseExactString);
					}
				}
				break;
			}
			case ADSTYPE_CASE_IGNORE_STRING:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->CaseIgnoreString;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->CaseIgnoreString);
					}
				}
				break;
			}
			case ADSTYPE_PRINTABLE_STRING:
			{
				vntValue = pavValue->PrintableString;
				break;
			}
			case ADSTYPE_NUMERIC_STRING:
			{
				vntValue = pavValue->NumericString;
				break;
			}
			case ADSTYPE_BOOLEAN:
			{
				vntValue = pavValue->Boolean ? true : false;
				break;
			}
			case ADSTYPE_INTEGER:
			{
				vntValue = static_cast<long>(pavValue->Integer);
				break;
			}
			case ADSTYPE_OCTET_STRING:
			{
				vntValue.vt = VT_ARRAY|VT_UI1;
				vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, pavValue->OctetString.dwLength);
				memcpy(vntValue.parray->pvData, pavValue->OctetString.lpValue, pavValue->OctetString.dwLength);
				break;
			}
			case ADSTYPE_UTC_TIME:
			{
				DATE dt;
				SystemTimeToVariantTime(&pavValue->UTCTime, &dt);
				vntValue = dt;
				vntValue.ChangeType(VT_DATE);
				break;
			}
		//	case ADSTYPE_LARGE_INTEGER:
			case ADSTYPE_OBJECT_CLASS:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->ClassName;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->ClassName);
					}
				}
				break;
			}
		//	case ADSTYPE_PROV_SPECIFIC:
		//	case ADSTYPE_CASEIGNORE_LIST:
		//	case ADSTYPE_OCTET_LIST:
		//	case ADSTYPE_PATH:
		//	case ADSTYPE_POSTALADDRESS:
		//	case ADSTYPE_TIMESTAMP:
		//	case ADSTYPE_BACKLINK:
		//	case ADSTYPE_TYPEDNAME:
		//	case ADSTYPE_HOLD:
		//	case ADSTYPE_NETADDRESS:
		//	case ADSTYPE_REPLICAPOINTER:
		//	case ADSTYPE_FAXNUMBER:
		//	case ADSTYPE_EMAIL:
			case ADSTYPE_NT_SECURITY_DESCRIPTOR:
			{
				ADS_NT_SECURITY_DESCRIPTOR& sd = pavValue->SecurityDescriptor;
				vntValue.vt = VT_ARRAY|VT_UI1;
				vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, sd.dwLength);
				memcpy(vntValue.parray->pvData, sd.lpValue, sd.dwLength);
				break;
			}
		//	case ADSTYPE_DN_WITH_BINARY:
		//	case ADSTYPE_DN_WITH_STRING:
			default:
			{
				vntValue.Clear();
				break;
			}
		}
	}
};


//---------------------------------------------------------------------------
// Directory Attributes Name Array Class
//---------------------------------------------------------------------------


class CDirectoryAttributesNameArray
{
public:

	CDirectoryAttributesNameArray(const CDirectoryAttributes& daAttributes) :
		m_ppszNames(NULL)
	{
		m_ppszNames = new LPTSTR[daAttributes.size()];

		if (m_ppszNames)
		{
			LPTSTR* ppsz = m_ppszNames;

			for (CDirectoryAttributes::const_iterator it = daAttributes.begin(); it != daAttributes.end(); it++)
			{
				*ppsz++ = const_cast<LPTSTR>(it->first.c_str());
			}
		}
		else
		{
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	~CDirectoryAttributesNameArray()
	{
		if (m_ppszNames)
		{
			delete [] m_ppszNames;
		}
	}

	operator LPTSTR*()
	{
		return m_ppszNames;
	}

protected:

	LPTSTR* m_ppszNames;
};


#define ATTRIBUTE_ADS_PATH _T("ADsPath")
#define ATTRIBUTE_CANONICAL_NAME _T("canonicalName")
#define ATTRIBUTE_DISTINGUISHED_NAME _T("distinguishedName")
#define ATTRIBUTE_NAME _T("name")
#define ATTRIBUTE_OBJECT_CATEGORY _T("objectCategory")
#define ATTRIBUTE_OBJECT_CLASS _T("objectClass")
#define ATTRIBUTE_OBJECT_SID _T("objectSid")
#define ATTRIBUTE_SAM_ACCOUNT_NAME _T("sAMAccountName")
#define ATTRIBUTE_USER_ACCOUNT_CONTROL _T("userAccountControl")
#define ATTRIBUTE_USER_PRINCIPAL_NAME _T("userPrincipalName")


//---------------------------------------------------------------------------
// Directory Object Class
//---------------------------------------------------------------------------


class CDirectoryObject
{
public:

	CDirectoryObject(LPCTSTR pszPath = NULL)
	{
		if (pszPath)
		{
			_com_util::CheckError(ADsGetObject(pszPath, IID_IDirectoryObject, (VOID**)&m_spObject));
		}
	}

	CDirectoryObject(IDispatchPtr spDispatch) :
		m_spObject(spDispatch)
	{
	}

	~CDirectoryObject()
	{
		if (m_spObject)
		{
			m_spObject.Release();
		}
	}

	CDirectoryObject& operator =(LPCTSTR pszPath)
	{
		_com_util::CheckError(ADsGetObject(pszPath, IID_IDirectoryObject, (VOID**)&m_spObject));

		return *this;
	}

	void AddAttribute(LPCTSTR pszName)
	{
		m_daAttributes.AddAttribute(pszName);
	}

	void GetAttributes()
	{
		PADS_ATTR_INFO pAttrInfo = NULL;

		try
		{
			// clear any existing attribute values

			m_daAttributes.ClearValues();

			// get attribute values

			DWORD cAttr;

			_com_util::CheckError(
				m_spObject->GetObjectAttributes(
					CDirectoryAttributesNameArray(m_daAttributes), m_daAttributes.size(), &pAttrInfo, &cAttr
				)
			);

			// assign attribute values to directory attributes

			PADS_ATTR_INFO pai = pAttrInfo;

			for (DWORD iAttr = 0; iAttr < cAttr; iAttr++, pai++)
			{
				m_daAttributes.SetADsValue(pai->pszAttrName, pai->dwADsType, pai->pADsValues, pai->dwNumValues);
			}

			// clean up

			if (pAttrInfo)
			{
				FreeADsMem(pAttrInfo);
			}
		}
		catch (...)
		{
			if (pAttrInfo)
			{
				FreeADsMem(pAttrInfo);
			}

			throw;
		}
	}

	const _variant_t& GetAttributeValue(LPCTSTR pszName)
	{
		return m_daAttributes.GetValue(pszName);
	}

protected:

	IDirectoryObjectPtr m_spObject;
	CDirectoryAttributes m_daAttributes;
};


//---------------------------------------------------------------------------
// DirectorySearch Class
//---------------------------------------------------------------------------


class CDirectorySearch
{
public:

	//

	CDirectorySearch() :
		m_hSearch(NULL)
	{
	}

	CDirectorySearch(IDispatchPtr spDispatch) :
		m_spSearch(spDispatch),
		m_hSearch(NULL)
	{
	}

	~CDirectorySearch()
	{
		CloseSearchHandle();
	}

	void operator =(const IDispatchPtr& spDispatch)
	{
		m_spSearch = spDispatch;
	}

	//

	void SetFilter(LPCTSTR pszFilter)
	{
		m_strFilter = pszFilter;
	}

	void SetPreferences(ADS_INTEGER nScope = ADS_SCOPE_SUBTREE)
	{
		ADS_SEARCHPREF_INFO siPreferences[4];

		siPreferences[0].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
		siPreferences[0].vValue.dwType = ADSTYPE_BOOLEAN;
		siPreferences[0].vValue.Integer = TRUE;

		siPreferences[1].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
		siPreferences[1].vValue.dwType = ADSTYPE_BOOLEAN;
		siPreferences[1].vValue.Integer = FALSE;

		siPreferences[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
		siPreferences[2].vValue.dwType = ADSTYPE_INTEGER;
		siPreferences[2].vValue.Integer = 100;

		siPreferences[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		siPreferences[3].vValue.dwType = ADSTYPE_INTEGER;
		siPreferences[3].vValue.Integer = nScope;

		m_spSearch->SetSearchPreference(siPreferences, sizeof(siPreferences) / sizeof(siPreferences[0]));
	}

	void AddAttribute(LPCTSTR pszName)
	{
		m_daAttributes.AddAttribute(pszName);
	}

	void Search()
	{
		CloseSearchHandle();

		_com_util::CheckError(m_spSearch->ExecuteSearch(
			const_cast<LPTSTR>(m_strFilter.c_str()),
			CDirectoryAttributesNameArray(m_daAttributes),
			m_daAttributes.size(),
			&m_hSearch
		));
	}

	bool GetFirstRow()
	{
		bool bGet = false;

		HRESULT hr = m_spSearch->GetFirstRow(m_hSearch);

		if (FAILED(hr))
		{
			_com_issue_error(hr);
		}

		if (hr == S_OK)
		{
			GetColumns();

			bGet = true;
		}

		return bGet;
	}

	bool GetNextRow()
	{
		bool bGet = false;

		HRESULT hr = m_spSearch->GetNextRow(m_hSearch);

		if (FAILED(hr))
		{
			_com_issue_error(hr);
		}

		if (hr == S_OK)
		{
			GetColumns();

			bGet = true;
		}

		return bGet;
	}

	const _variant_t& GetAttributeValue(LPCTSTR pszName)
	{
		return m_daAttributes.GetValue(pszName);
	}

protected:

	void GetColumns()
	{
		for (CDirectoryAttributes::iterator it = m_daAttributes.begin(); it != m_daAttributes.end(); it++)
		{
			const tstring& strName = it->first;

			ADS_SEARCH_COLUMN scColumn;

			if (m_spSearch->GetColumn(m_hSearch, const_cast<LPTSTR>(strName.c_str()), &scColumn) == S_OK)
			{
				m_daAttributes.SetADsValue(strName.c_str(), scColumn.dwADsType, scColumn.pADsValues, scColumn.dwNumValues);

				m_spSearch->FreeColumn(&scColumn);
			}
			else
			{
				it->second.Clear();
			}
		}
	}

	void CloseSearchHandle()
	{
		if (m_hSearch)
		{
			m_spSearch->CloseSearchHandle(m_hSearch);

			m_hSearch = NULL;
		}
	}

protected:

	IDirectorySearchPtr m_spSearch;
	tstring m_strFilter;
	CDirectoryAttributes m_daAttributes;
	ADS_SEARCH_HANDLE m_hSearch;
};


//
// Object SID helpers
//

#define MIN_NON_RESERVED_RID 1000

bool __stdcall IsUserRid(const _variant_t& vntSid);


//
// Other helpers.
//

tstring __stdcall GetEscapedFilterValue(PCTSTR pszValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\arutil.hpp ===
/*---------------------------------------------------------------------------
  File: ARUtil.hpp

  Comments: Definitions for helper routines and command-line parsing for Account Replicator

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 6/23/98 4:31:22 PM

 ---------------------------------------------------------------------------
*/

#include "UserCopy.hpp"

int 
   CompVal(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   );

int 
   CompNode(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   );


int 
   CompSid(
      const TNode          * v1,      // in -first node to compare
      const TNode          * v2       // in -second node to compare
   );

int 
   CompSidVal(
      const TNode          * tn,     // in -node to compare
      const void           * pVal    // in -value to compare
   );

BOOL                                            // ret-TRUE if the password is successfully generated
   PasswordGenerate(
      Options const        * options,           // in  -includes PW Generating options
      WCHAR                * password,          // out -buffer for generated password
      DWORD                  dwPWBufferLength,  // in  -DIM length of password buffer
      BOOL                   isAdminAccount = FALSE // in  -Whether to use the Admin rules 
   );

//------------------------------------------------------------------------------
// ParseParms: parse out source & target servers plus any switches.
//------------------------------------------------------------------------------
BOOL                               // ret-TRUE=success
   ParseParms(
      TCHAR const         ** argv        ,// in -argument list
      Options              * options      // out-options
   );



PSID 
   GetWellKnownSid(
      DWORD                  wellKnownAccount,     // in - which well known account to get sid for (constants defined in UserCopy.hpp)
      Options              * opt,                  // in - options structure containing source and target domains
      BOOL                   bTarget = FALSE       // in - flag, whether to use source or target domain information
   );

// GenerateSidAsString
// generates string SID after using GetWellKnownSid to generate SID

_bstr_t __stdcall GenerateSidAsString(Options* pOptions, BOOL bTarget, DWORD dwRid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\array.h ===
#pragma once

#include <ComDef.h>


//---------------------------------------------------------------------------
// C Array Class
//
// Implements a very simple heap based array. Replaces stack based arrays
// in order to reduce stack space used when long string arrays are declared.
//---------------------------------------------------------------------------

template<class T>
struct c_array
{
    //
    // Constructors and Destructors
    //

    c_array(size_t s) :
        s(s),
        p(new T[s])
    {
        if (p == NULL)
        {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    c_array(const c_array& a) :
        s(a.s),
        p(new T[a.s])
    {
        if (p != NULL)
        {
            memcpy(p, a.p, a.s * sizeof(T));
        }
        else
        {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    ~c_array()
    {
        delete [] p;
    }

    //
    // Access Operators
    //
    // Note that defining array operators was creating an ambiguity for
    // the compiler therefore only the pointer operator is defined.
    //

    operator T*()
    {
        return p;
    }

    //T& operator[](ptrdiff_t i)
    //{
    //    return p[i];
    //}

    //const T& operator[](ptrdiff_t i) const
    //{
    //    return p[i];
    //}

    //
    // Properties
    //

    size_t size() const
    {
        return s;
    }

    T* p;
    size_t s;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\commonlib\verifyconfiguration.cpp ===
#include <Windows.h>
#include "VerifyConfiguration.h"

#include <crtdbg.h>
#define SECURITY_WIN32
#include <Security.h>
#include "AdsiHelpers.h"

#pragma comment(lib, "secur32.lib")


//-----------------------------------------------------------------------------
// IsCallerDelegatable Function
//
// Synopsis
// If an intra-forest move operation is being performed then verify that the
// calling user's account has not been marked as sensitive and therefore
// cannot be delegated. As the move operation is performed on the domain
// controller which has the RID master role in the source domain it is
// necessary to delegate the user's security context.
//
// Arguments
// bDelegatable - this out parameter is set to true if the account is
//                delegatable otherwise it is set to false
//
// Return Value
// The return value is a HRESULT. S_OK is returned if successful.
//-----------------------------------------------------------------------------

HRESULT __stdcall IsCallerDelegatable(bool& bDelegatable)
{
    HRESULT hr = S_OK;

    bDelegatable = true;

    //
    // Retrieve distinguished name of caller.
    //

    ULONG cchCallerDn = 0;

    if (GetUserNameEx(NameFullyQualifiedDN, NULL, &cchCallerDn) == FALSE)
    {
        DWORD dwError = GetLastError();

        if ((dwError == ERROR_SUCCESS) || (dwError == ERROR_MORE_DATA))
        {
            PTSTR pszCallerDn = new _TCHAR[cchCallerDn];

            if (pszCallerDn)
            {
                if (GetUserNameEx(NameFullyQualifiedDN, pszCallerDn, &cchCallerDn))
                {
                    //
                    // Retrieve user account control attribute for user and check
                    // whether the 'not delegated' flag is set. If this flag is set
                    // then the user's account has been marked as sensitive and
                    // therefore cannot be delegated.
                    //

                    try
                    {
                        tstring strADsPath = _T("LDAP://");
                        strADsPath += pszCallerDn;

                        CDirectoryObject user(strADsPath.c_str());

                        user.AddAttribute(ATTRIBUTE_USER_ACCOUNT_CONTROL);
                        user.GetAttributes();

                        DWORD dwUserAccountControl = (DWORD)(long) user.GetAttributeValue(ATTRIBUTE_USER_ACCOUNT_CONTROL);

                        if (dwUserAccountControl & ADS_UF_NOT_DELEGATED)
                        {
                            bDelegatable = false;
                        }
                    }
                    catch (std::exception& e)
                    {
                        hr = E_FAIL;
                    }
                    catch (_com_error& ce)
                    {
                        hr = ce.Error();
                    }
                }
                else
                {
                    dwError = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwError);
                }

                delete [] pszCallerDn;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    else
    {
        _ASSERT(FALSE);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\agrpcutl.h ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.h

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


// Create RPC binding for connection with DCT Agent
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -authentication option
   );

DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\cipher.hpp ===
//#pragma title( "Cipher.hpp" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Cipher.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  19??-??-??
Description -
Updates     -
===============================================================================
*/

#ifndef  MCSINC_Cipher_hpp
#define  MCSINC_Cipher_hpp

void
   SimpleCipher(
      WCHAR                * str           // i/o-string to encrypt/decrypt
   );

void
   SimpleCipher(
      char unsigned        * str          ,// i/o-string to encrypt/decrypt
      int                    len           // in -length of string
   );

#endif  // MCSINC_Cipher_hpp

// Cipher.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\commalog.hpp ===
#ifndef __COMMALOG_HPP__
#define __COMMALOG_HPP__
/*---------------------------------------------------------------------------
  File: CommaLog.hpp

  Comments: TError based log file with optional security.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 10:49:50

  09/05/01 Mark Oluper - use Windows File I/O API
 ---------------------------------------------------------------------------
*/

#include <stdio.h>
#include <tchar.h>

class CommaDelimitedLog
{
public:
    CommaDelimitedLog()
    {
        m_hFile = INVALID_HANDLE_VALUE;
    }

    virtual ~CommaDelimitedLog()
    {
        LogClose();
    }

    BOOL IsOpen() const
    {
        return (m_hFile != INVALID_HANDLE_VALUE);
    }

    BOOL LogOpen(PCTSTR filename, BOOL protect, int mode = 0); // mode 0=overwrite, 1=append

    virtual void LogClose()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }

    BOOL MsgWrite(const _TCHAR msg[], ...) const;

protected:
    BOOL LogWrite(PCTSTR msg, int len) const;

protected:
    HANDLE m_hFile;
};


//----------------------------------------------------------------------------
// Password Log Class
//
// Overrides LogOpen to attempt to open specified file and then default file
// if different.
//----------------------------------------------------------------------------

class CPasswordLog : public CommaDelimitedLog
{
public:

    CPasswordLog() {}

    BOOL LogOpen(PCTSTR pszPath);
};


PSID GetWellKnownSid(DWORD wellKnownAccount);

#endif //__COMMALOG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\bkuprstr.hpp ===
//#pragma title( "BkupRstr.hpp - Get backup and restore privileges" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  BkupRstr.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-05-30
Description -  Get backup and restore privileges
Updates     -
===============================================================================
*/

#include "ealen.hpp"

#ifndef  MCSINC_BkupRstr_hpp
#define  MCSINC_BkupRstr_hpp

// Get backup and restore privileges using WCHAR machine name.
BOOL                                       // ret-TRUE if successful.
   GetBkupRstrPriv(
      WCHAR          const * sMachineW, // in -NULL or machine name
      BOOL              fOn = TRUE             // in - indicates whether the privileges should be turned on or not
   );

// ===========================================================================
/*    Function    :  GetPrivilege
   Description    :  This function enables the requested privilege on the requested
                     computer.
*/
// ===========================================================================
BOOL                                       // ret-TRUE if successful.
   GetPrivilege(
      WCHAR          const * sMachineW,    // in -NULL or machine name
      LPCWSTR                pPrivilege,    // in -privilege name such as SE_SHUTDOWN_NAME
      BOOL                      fOn = TRUE       // in - indicates whether the privilege should be turned on or not      
   );

// ===========================================================================
/*    Function    :  ComputerShutDown
   Description    :  This function shutsdown/restarts the given computer.

*/
// ===========================================================================

DWORD 
   ComputerShutDown(
      WCHAR          const * pComputerName,  // in - computer name to shut down
      WCHAR          const * pMessage,       // in - message to display in NT shutdown dialog
      DWORD                  delay,          // in - delay, in seconds
      DWORD                  bRestart,       // in - flag, whether to reboot
      BOOL                   bNoChange       // in - flag, whether to really do it
   );

#endif  MCSINC_BkupRstr_hpp

// BkupRstr.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );


#define countof(a) (sizeof(a) / sizeof(a[0]))


#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\err.hpp ===
//#pragma title( "Err.hpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Err_hpp
#define  MCSINC_Err_hpp

// Start of header file dependencies

#ifndef  MCSINC_Common_hpp
#include "Common.hpp"
#endif

#include "TSync.hpp"

extern TCriticalSection csLogError;

// End of header file dependencies

// ErrMsg error level constants
#define ErrT            (00000 - __LINE__) // Testing
#define ErrI            (00000) // Information
#define ErrW            (10000) // Warning
#define ErrE            (20000) // Error
#define ErrS            (30000) // Severe error
#define ErrV            (40000) // Very sever error
#define ErrU            (50000) // Unrecoverable error
#define ErrX            (60000) // extremely unrecoverable <g>

#define ErrNone         (0)

class TError
{
protected:
   int                       level;
   int                       lastError;
   int                       maxError;
   int                       logLevel;     // minimum level to log
   int                       dispLevel;    // minimum level to display
   HANDLE                    logFile;
   int                       beepLevel;
   BOOL                      bWriteOnCurPos;  // write on the current position
   TCriticalSection          criticalSection;  // used to make sure write is atomic
public:
                        TError(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      WCHAR          const * filename = L"",// in -file name of log (NULL if none)
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
                                             //     Some people dont like the beeps so we turned it off by default.

                        );
                        ~TError();

   void __cdecl         MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   );
#ifndef WIN16_VERSION

   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
#endif

   void __stdcall       MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   );

   virtual void __stdcall StrWrite(int level, WCHAR const * str) const { if (level >= dispLevel) wprintf(L"%s\n", str); };

   virtual BOOL         LogOpen(
      WCHAR          const * fileName          ,// in -name of file including any path
      int                    mode = 0          ,// in -0=overwrite, 1=append
      int                    level = 0         ,// in -minimum level to log
      bool                   bBeginNew = false  // in -begin a new log file
   );
   virtual DWORD        ExtendSize(
      DWORD             dwNumOfBytes           // number of bytes to extend
   );
   virtual void         SetWriteOnCurrentPosition(BOOL bSet) { bWriteOnCurPos = bSet; } 
   virtual void         LogClose() { if ( logFile != INVALID_HANDLE_VALUE) CloseHandle(logFile); logFile = INVALID_HANDLE_VALUE; };
   virtual void         LogWrite(WCHAR const * msg);
   void                 LevelSet(int displevel=0, int loglevel=-1, int beeplevel=2)
                           { dispLevel = displevel; logLevel = loglevel; beepLevel = beeplevel; };
   void                 LevelDispSet(int  displevel=0)
                           { dispLevel = displevel; };
   void                 LevelLogSet(int  loglevel=-1)
                           { logLevel = loglevel; };
   void                 LevelBeepSet(int  beeplevel=-1)
                           { beepLevel = beeplevel; };
   DWORD                MaxError()  const { return maxError; };
   DWORD                LastError() const { return lastError; };

   int                  GetMaxSeverityLevel () { return maxError / 10000; }

   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );
};

extern TError              & errCommon;

#endif  // MCSINC_Err_hpp

// Err.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\exldap.h ===
#ifndef EXLDAP_H
#define EXLDAP_H

#include <windows.h>
#include <winldap.h>
#include <stdio.h>

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"

typedef WINLDAPAPI LDAP * LDAPAPI LDAP_OPEN( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI LDAP * LDAPAPI LDAP_INIT( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI LDAP * LDAPAPI LDAP_SSLINIT(PWCHAR HostName, ULONG PortNumber, int secure);
typedef WINLDAPAPI ULONG LDAPAPI LDAPMAPERRORTOWIN32( ULONG LdapError );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_UNBIND( LDAP *ld );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_BIND( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_CONNECT(LDAP* ld, struct l_timeval* timeout);
typedef WINLDAPAPI ULONG LDAPAPI LDAP_SIMPLE_BIND(LDAP* ld, PWCHAR dn, PWCHAR passwd);

typedef WINLDAPAPI ULONG LDAPAPI LDAPGETLASTERROR( VOID );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MODIFY_S( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MSGFREE( LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_COUNT_ENTRIES( LDAP *ld, LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_SEARCH_EXT_S(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_CREATE_PAGE_CONTROL(
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_PAGE_CONTROL (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie     // Use ber_bvfree to free
        );
typedef WINLDAPAPI PWCHAR *LDAPAPI LDAP_GET_VALUES(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_VALUE_FREE( PWCHAR *vals );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_NEXT_ENTRY( LDAP *ld, LDAPMessage *entry );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_FIRST_ENTRY( LDAP *ld, LDAPMessage *res );

typedef WINLDAPAPI VOID LDAPAPI BER_BVFREE( struct berval *bv );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_CONTROLS_FREE (
        LDAPControlW **Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_RESULT (
        LDAP *Connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_memfree
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfree
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,    // free with ldap_free_controlsW
        BOOLEAN Freeit
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_GET_OPTION( LDAP *ld, int option, void *outvalue );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_SET_OPTION( LDAP *ld, int option, void *invalue );

class CLdapConnection
{
   WCHAR                     m_exchServer[LEN_Computer];
   LDAP                    * m_LD;
   ULONG                     m_port;
   HMODULE                   m_hDll;
   BOOL                      m_bUseSSL;
   WCHAR                     m_credentials[300];
   WCHAR                     m_password[LEN_Password];
   SEC_WINNT_AUTH_IDENTITY_W m_creds;
public:
   LDAP_PARSE_RESULT        * ldap_parse_result;
   LDAP_PARSE_PAGE_CONTROL  * ldap_parse_page_control;
   LDAP_CONTROLS_FREE       * ldap_controls_free;
   BER_BVFREE               * ber_bvfree;
   LDAP_FIRST_ENTRY         * ldap_first_entry;
   LDAP_NEXT_ENTRY          * ldap_next_entry;
   LDAP_VALUE_FREE          * ldap_value_free;
   LDAP_GET_VALUES          * ldap_get_values;
   LDAP_CREATE_PAGE_CONTROL * ldap_create_page_control;
   LDAP_SEARCH_EXT_S        * ldap_search_ext_s;
   LDAP_COUNT_ENTRIES       * ldap_count_entries;
   LDAP_MSGFREE             * ldap_msgfree;
   LDAP_MODIFY_S            * ldap_modify_s;
   LDAPGETLASTERROR         * LdapGetLastError;
   LDAP_BIND                * ldap_bind_sW;
   LDAP_SIMPLE_BIND	 * ldap_simple_bind_sW;
   LDAP_CONNECT         * ldap_connect;
   LDAP_UNBIND              * ldap_unbind;
   LDAPMAPERRORTOWIN32      * LdapMapErrorToWin32;
   LDAP_OPEN                * ldap_open;
   LDAP_GET_OPTION          * ldap_get_option;
   LDAP_SET_OPTION          * ldap_set_option;
   LDAP_INIT                * ldap_init;
   LDAP_SSLINIT		 *ldap_sslinit;

public:
   CLdapConnection();
   ~CLdapConnection();

   void   SetCredentials(WCHAR const *domain, WCHAR const * cred, WCHAR const * pwd);
   LDAP * GetHandle() { return m_LD; }
   DWORD  Connect(WCHAR const * server,ULONG port);
   DWORD SSLConnect(WCHAR const * server, BOOL* sslEnabled, ULONG port = LDAP_SSL_PORT);
   DWORD UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value);
   void   Close();

   BOOL StringToBytes(WCHAR const * pString,BYTE * pBytes);
   BOOL BytesToString(BYTE * pBytes,WCHAR * sidString,DWORD numBytes);
protected:
   // helper functions
   BYTE HexValue(WCHAR value);
   void AddByteToString(WCHAR ** string,BYTE value);
};


class CLdapEnum
{
   BOOL                      m_bOpen;
   ULONG                     m_nReturned;
   ULONG                     m_nCurrent;
   ULONG                     m_totalCount;
   LDAPMessage             * m_message;
   LDAPMessage             * m_currMsg;
   WCHAR                     m_query[1000];
   WCHAR                     m_basepoint[LEN_DistName];
   int                       m_scope;
   long                      m_pageSize;
   int                       m_nAttributes;
   WCHAR                  ** m_AttrNames;
public:
    CLdapConnection           m_connection;
public:
   CLdapEnum() { m_bOpen = FALSE; m_nReturned = 0; m_nCurrent = 0; m_totalCount = 0; m_message = NULL; 
                 m_query[0] = 0; m_basepoint[0] = 0; m_scope = 2; m_pageSize = 100; m_currMsg = NULL;
                 m_nAttributes = 0; m_AttrNames =NULL;}
   ~CLdapEnum();

   DWORD          InitConnection(WCHAR const * server,ULONG port) { return m_connection.Connect(server,port); }
   DWORD          InitSSLConnection(WCHAR const * server,BOOL* sslEnabled,ULONG port) { return m_connection.SSLConnect(server,sslEnabled,port); }
   DWORD          Open(WCHAR const * query,WCHAR const * basePoint,short scope, long pageSize,int numAttributes,
                  WCHAR ** attrs);
   DWORD          Next(PWCHAR ** ppAttrs);
   void           FreeData(PWCHAR* pValues);
protected:

   DWORD          GetNextEntry(PWCHAR ** ppAttrs);
   DWORD          GetNextPage();

};

void     GetLDAPPort(DWORD *LDAPPort, DWORD *SSLPort);

#endif // EXLDAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\ealen.hpp ===
//#pragma title( "EaLen.hpp - EA defined length fields" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  EaLen.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1996-03-22
Description -  EA defined length fields
Updates     -
===============================================================================
*/

#ifndef  MCSINC_EaLen_hpp
#define  MCSINC_EaLen_hpp

// Definitions - object name lengths.
// These lengths include trailing null.
// These definitions are used to be independent of values in <lm.h>, which
// may not reflect the actual limits of all target operating systems.
// These values are also usually rounded up to a four byte boundary.
// The LEN_ values reflect the size reserved in structures for object names.
// The MAXLEN_ values reflect the actual valid maximum length imposed by EA.

#define  LEN_Computer                      (260)
#define  LEN_Domain                        (260)

#define  LEN_Account                       (260)
#define  LEN_Comment                       (260)
#define  LEN_Group                         (260)
#define  LEN_Member                        (260)
#define  LEN_Password                      (260)
#define  LEN_Path                          (1260)
#define  LEN_ShutdownMessage               (128)

#define  LEN_Sid                           (80)

#define  LEN_DistName                      (260)
#define  LEN_DisplayName                   (260)

#define  LEN_Guid                          (128)

#define  LEN_WTSPhoneNumber                (50)
#define  LEN_HomeDir                       (4)

// Definitions - maximum valid length of object name
// These lengths do NOT include trailing null.
// These definitions must always be smaller that the corresponding
// definitions above.

// Other EA defined constants
// type of account
#define  EA_AccountGGroup                        (0x00000001)
#define  EA_AccountLGroup                        (0x00000002)
#define  EA_AccountUser                          (0x00000004)
#define  EA_AccountUcLGroup                      (0x00000008)

#define  EA_AccountGroup                         (EA_AccountGGroup|EA_AccountLGroup)
#define  EA_AccountAll                           (EA_AccountGroup|EA_AccountUser)


#endif  // MCSINC_EaLen_hpp

// EaLen.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\errdct.hpp ===
#ifndef __ERRDCT_HPP__
#define __ERRDCT_HPP__
/*---------------------------------------------------------------------------
  File: ErrDct.hpp

  Comments: TError derived class that specifies a numeric code for each message 
  format.  The goal is to make it easy to convert this to a real message file 
  later.

  This class also improves on the behavior of the TError class by returning text
  for HRESULT error codes.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 13:04:51

 ---------------------------------------------------------------------------
*/
#include <comdef.h>
#include "Err.hpp"
#include "Common.hpp"
#include "UString.hpp"    
#include "McsDmMsg.h"

// These codes are passed as the messageNumber argument to MsgWrite and SysMsgWrite.


// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   );

class TErrorDct : public TError
{
public:
   TErrorDct(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
      ) : TError(displevel,loglevel,NULL,logmode,beeplevel)
   {}
   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );   

   WCHAR const * LookupMessage(UINT msgNumber);

   virtual void __cdecl
   SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   );

   virtual void __cdecl
   MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

   void __cdecl
      DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      );

   virtual BOOL         LogOpen(
      WCHAR          const * fileName          ,// in -name of file including any path
      int                    mode = 0          ,// in -0=overwrite, 1=append
      int                    level = 0         ,// in -minimum level to log
      bool                   bBeginNew = false  // in -begin a new log file
   )
   {
      WCHAR                  directory[MAX_PATH];

      safecopy(directory,fileName);

      WCHAR                * x = wcsrchr(directory,'\\');
      
      if ( x )
      {
         (*x) = 0;
         DirectoryCreateR(directory);
      }
      
      return TError::LogOpen(fileName,mode,level,bBeginNew);
   }

   _bstr_t __cdecl
   GetMsgText(
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

};

#endif //__ERRDCT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\extseq.h ===
#ifndef EXT_SEQ_H
#define EXT_SEQ_H

#define AREXT_EARLIER_SEQUENCE_NUMBER        (100)
#define AREXT_DEFAULT_SEQUENCE_NUMBER        (200)
#define AREXT_LATER_SEQUENCE_NUMBER          (300)
#define AREXT_EVEN_LATER_SEQUENCE_NUMBER     (400)

#define AREXT_SEQUENCE_NUMBER_DisAcct        (6000)
#define AREXT_SEQUENCE_NUMBER_RidSave        (2000)
#define AREXT_SEQUENCE_NUMBER_UpdtModel      (9000)
#define AREXT_SEQUENCE_NUMBER_PwdCopy        (3000)
#define AREXT_SEQUENCE_NUMBER_SvcAcct        (4000)
#define AREXT_SEQUENCE_NUMBER_ScriptEng      (11000)
#define AREXT_SEQUENCE_NUMBER_SetPass        (5000)
#define AREXT_SEQUENCE_NUMBER_CleanupSid     (7000)
#define AREXT_SEQUENCE_NUMBER_SkipUser       (1000)
#define AREXT_SEQUENCE_NUMBER_StoreInfo      (10000)
#define AREXT_SEQUENCE_NUMBER_UPNUpdt        (8000)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_DOMAIN_SELECTION_GROUP=WindowDomainSelectGroup.htm
IDH_WINDOW_DOMAIN_SELECTION_GROUPMAP=WindowDomainSelectGroupMap.htm
IDH_WINDOW_DOMAIN_SELECTION_REPORT=WindowDomainSelectReport.htm
IDH_WINDOW_DOMAIN_SELECTION_SECURITY=WindowDomainSelectSecurity.htm
IDH_WINDOW_DOMAIN_SELECTION_SERVICE=WindowDomainSelectService.htm
IDH_WINDOW_DOMAIN_SELECTION_TRUST=WindowDomainSelectTrust.htm
IDH_WINDOW_DOMAIN_SELECTION_USER=WindowDomainSelectUser.htm
IDH_WINDOW_DOMAIN_SELECTION_EXCHANGE=WindowDomainSelectExchange.htm

IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_GROUP_SELECTION_GROUPMAP=WindowGroupSelectGroupMap.htm


IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_COMPUTER_SELECTION_REPORT=WindowComputerSelectReport.htm
IDH_WINDOW_COMPUTER_SELECTION_SECURITY=WindowComputerSelectSecurity.htm

IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OU_SELECTION_GROUP=WindowOUSelectGroup.htm
IDH_WINDOW_OU_SELECTION_GROUPMAP=WindowOUSelectGroupMap.htm
IDH_WINDOW_OU_SELECTION_USER=WindowOUSelectUser.htm

IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION_SECURITY=WindowObjectTypeSelectSecurity.htm


IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_OPTION_GROUPMAP=WindowGroupOptionGroupMap.htm

IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_SECURITY_OPTION_SECURITY=WindowSecurityOptionSecurity.htm
IDH_WINDOW_SECURITY_OPTION_EXCHANGE=WindowSecurityOptionExchange.htm

IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_NAME_CONFLICT_GROUP=WindowNameConflictGroup.htm
IDH_WINDOW_NAME_CONFLICT_USER=WindowNameConflictUser.htm


IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_USER=WindowSIDHistoryCredentialUser.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_GROUPMAP=WindowSIDHistoryCredentialGroupMap.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_UNDO=WindowSIDHistoryCredentialUndo.htm

IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_CONFIRMATION_GROUP=WindowConfirmationGroup.htm
IDH_WINDOW_CONFIRMATION_GROUPMAP=WindowConfirmationGroupMap.htm
IDH_WINDOW_CONFIRMATION_REPORT=WindowConfirmationReport.htm
IDH_WINDOW_CONFIRMATION_RETRY=WindowConfirmationRetry.htm
IDH_WINDOW_CONFIRMATION_SECURITY=WindowConfirmationSecurity.htm
IDH_WINDOW_CONFIRMATION_SERVICE=WindowConfirmationService.htm
IDH_WINDOW_CONFIRMATION_UNDO=WindowConfirmationUndo.htm
IDH_WINDOW_CONFIRMATION_USER=WindowConfirmationUser.htm
IDH_WINDOW_CONFIRMATION_EXCHANGE=WindowConfirmationExchange.htm


IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_COMMIT_EXCHANGE=WindowCommitChangesExchange.htm
IDH_WINDOW_COMMIT_GROUP=WindowCommitChangesGroup.htm
IDH_WINDOW_COMMIT_GROUPMAP=WindowCommitChangesGroupMap.htm
IDH_WINDOW_COMMIT_SECURITY=WindowCommitChangesSecurity.htm
IDH_WINDOW_COMMIT_USER=WindowCommitChangesUser.htm

IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_USER_SERVICE_ACCOUNT_GROUP=WindowUserServiceAccountGroup.htm
IDH_WINDOW_USER_SERVICE_ACCOUNT_INFO=WindowUserServiceAccountInfo.htm


IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm

IDH_WINDOW_GROUP_MEM_TRANS_OPTION=WindowGroupMemTransOption.htm
IDH_WINDOW_REPORT_COMP_SELECT=WindowReportCompSelect.htm
IDH_WINDOW_REPORT_WIZ=WindowReportWiz.htm
IDH_WINDOW_SERV_ACC_WIZ=WindowServAccWiz.htm
IDH_WINDOW_COMP_WIZ=WindowCompWiz.htm
IDH_WINDOW_UNDO_WIZ=WindowUndoWiz.htm
IDH_WINDOW_TRUST_WIZ=WindowTrustWiz.htm
IDH_WINDOW_EXCHANGE_WIZ=WindowExchangeWiz.htm
IDH_WINDOW_GROUP_MAP_MERGE_WIZ=WindowGroupMapMergeWiz.htm
IDH_WINDOW_GROUP_WIZ=WindowGroupWiz.htm
IDH_WINDOW_RETRY_WIZ=WindowRetryWiz.htm
IDH_WINDOW_SEC_TRANS_WIZ=WindowSecTransWiz.htm
IDH_WINDOW_USER_WIZ=WindowUserWiz.htm

IDH_WINDOW_TRANSLATION_OPTION=WindowTranslationOption.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION=WindowObjectPropertyExclusion.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_GROUP=WindowObjectPropertyExclusionGroup.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_USER=WindowObjectPropertyExclusionUser.htm
IDH_WINDOW_USER_ACC_PASS=WindowUserAccPass.htm
IDH_WINDOW_CONFIRMATION_TRUST=WindowConfirmationTrust.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\getdcname.h ===
#pragma once

#include <ComDef.h>
#include <DsGetDc.h>


//
// These functions are used to obtain the name of a domain controller in the
// specified domain. The 4 version is for code that must be loadable on NT4
// or earlier machines. The 5 version is for code that only is loaded on W2K
// or later machines.
//

DWORD __stdcall GetDcName4(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strNameDns, _bstr_t& strNameFlat);
DWORD __stdcall GetDcName5(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strNameDns, _bstr_t& strNameFlat);

inline DWORD __stdcall GetDcName4(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strName)
{
    _bstr_t strNameDns;
    _bstr_t strNameFlat;

    DWORD dwError = GetDcName4(pszDomainName, ulFlags, strNameDns, strNameFlat);

    if (dwError == ERROR_SUCCESS)
    {
        strName = !strNameDns ? strNameFlat : strNameDns;
    }

    return dwError;
}

inline DWORD __stdcall GetDcName5(PCWSTR pszDomainName, ULONG ulFlags, _bstr_t& strName)
{
    _bstr_t strNameDns;
    _bstr_t strNameFlat;

    DWORD dwError = GetDcName5(pszDomainName, ulFlags, strNameDns, strNameFlat);

    if (dwError == ERROR_SUCCESS)
    {
        strName = !strNameDns ? strNameFlat : strNameDns;
    }

    return dwError;
}

inline DWORD __stdcall GetAnyDcName4(PCWSTR pszDomainName, _bstr_t& strName)
{
    return GetDcName4(pszDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strName);
}

inline DWORD __stdcall GetAnyDcName5(PCWSTR pszDomainName, _bstr_t& strName)
{
    return GetDcName5(pszDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strName);
}


//
// This function obtains the name of a
// global catalog server for the specified domain.
//

DWORD __stdcall GetGlobalCatalogServer4(PCWSTR pszDomainName, _bstr_t& strServer);
DWORD __stdcall GetGlobalCatalogServer5(PCWSTR pszDomainName, _bstr_t& strServer);


//
// These functions are used to obtain the flat and DNS names for a specified domain.
// The 4 version is for code that must be loadable on NT4 or earlier machines. The 5
// version is for code that only is loaded on W2K or later machines.
//

DWORD __stdcall GetDomainNames4(PCWSTR pszDomainName, _bstr_t& strFlatName, _bstr_t& strDnsName);
DWORD __stdcall GetDomainNames5(PCWSTR pszDomainName, _bstr_t& strFlatName, _bstr_t& strDnsName);

inline bool __stdcall GetDnsAndNetbiosFromName(PCWSTR pszName, PWSTR pszFlatName, PWSTR pszDnsName)
{
    *pszDnsName = L'\0';
    *pszFlatName = L'\0';

    _bstr_t strDnsName;
    _bstr_t strFlatName;

    DWORD dwError = GetDomainNames4(pszName, strDnsName, strFlatName);

    if (dwError == ERROR_SUCCESS)
    {
        if (strDnsName.length() > 0)
        {
            wcscpy(pszDnsName, strDnsName);
        }

        if (strFlatName.length() > 0)
        {
            wcscpy(pszFlatName, strFlatName);
        }
    }

    return (dwError == ERROR_SUCCESS);
}


HRESULT __stdcall GetRidPoolAllocator4(PCWSTR pszDomainName, _bstr_t& strDnsName, _bstr_t& strFlatName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\hrmsg.h ===
#ifndef  MCSINC_HrMsg_h
#define  MCSINC_HrMsg_h

#include <string>
#include <tchar.h>
#include <comdef.h>

/******************************************************************
 *                                                                *
 * Header file for common error handling functions.               *
 *                                                                *
 ******************************************************************/

_bstr_t __stdcall HResultToText(HRESULT hr);
_bstr_t __stdcall HResultToText2(HRESULT hr);
_com_error GetError(HRESULT hr);
void __cdecl AdmtThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
void __cdecl AdmtThrowError(_com_error ce, HINSTANCE hInstance, UINT uId, ...);

#endif // MCSINC_HrMsg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\folders.h ===
#pragma once

#include <ComDef.h>
#include <TChar.h>

namespace nsFolders
{

extern const _TCHAR REGKEY_MCSHKCU[];
extern const _TCHAR REGKEY_MSHKCU[];
extern const _TCHAR REGKEY_MSADMT[];
extern const _TCHAR REGKEY_MCSADMT[];
extern const _TCHAR REGKEY_ADMT[];
extern const _TCHAR REGKEY_REPORTING[];
extern const _TCHAR REGKEY_EXTENSIONS[];
extern const _TCHAR REGVAL_DIRECTORY[];
extern const _TCHAR REGVAL_DIRECTORY_MIGRATIONLOG[];
extern const _TCHAR REGVAL_REGISTRYUPDATED[];
extern const _TCHAR REGKEY_APPLICATION_LOG[];
extern const _TCHAR REGKEY_ADMTAGENT_EVENT_SOURCE[];
extern const _TCHAR REGVAL_EVENT_CATEGORYCOUNT[];
extern const _TCHAR REGVAL_EVENT_CATEGORYMESSAGEFILE[];
extern const _TCHAR REGVAL_EVENT_EVENTMESSAGEFILE[];
extern const _TCHAR REGVAL_EVENT_TYPESSUPPORTED[];
extern const _TCHAR REGKEY_CURRENT_VERSION[] ;
extern const _TCHAR REGVAL_PROGRAM_FILES_DIRECTORY[];
extern const _TCHAR REGVAL_EXCHANGE_LDAP_PORT[];
extern const _TCHAR REGVAL_EXCHANGE_SSL_PORT[];
extern const _TCHAR REGVAL_ALLOW_NON_CLOSEDSET_MOVE[];

extern const _TCHAR DIR_LOGS[];
extern const _TCHAR DIR_REPORTS[];
extern const _TCHAR FNAME_MIGRATION[];
extern const _TCHAR FNAME_DISPATCH[];
extern const _TCHAR EXT_LOG[];

}

_bstr_t __stdcall GetLogsFolder();
_bstr_t __stdcall GetReportsFolder();

_bstr_t __stdcall GetMigrationLogPath();
_bstr_t __stdcall GetDispatchLogPath();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300

#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
#define IDH_WINDOW_TRANSLATION_OPTION             5060
#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION      5070
#define IDH_WINDOW_USER_SERVICE_ACCOUNT_GROUP     5080
#define IDH_WINDOW_USER_SERVICE_ACCOUNT_INFO      5090

#define IDH_WINDOW_GROUP_MEM_TRANS_OPTION         6000
#define IDH_WINDOW_REPORT_COMP_SELECT			  6010
#define IDH_WINDOW_REPORT_WIZ					  6020
#define IDH_WINDOW_SERV_ACC_WIZ					  6030
#define IDH_WINDOW_COMP_WIZ						  6040
#define IDH_WINDOW_UNDO_WIZ						  6050
#define IDH_WINDOW_TRUST_WIZ					  6060
#define IDH_WINDOW_EXCHANGE_WIZ					  6070
#define IDH_WINDOW_GROUP_MAP_MERGE_WIZ			  6080
#define IDH_WINDOW_GROUP_WIZ					  6090
#define IDH_WINDOW_RETRY_WIZ					  6100
#define IDH_WINDOW_SEC_TRANS_WIZ				  6110
#define IDH_WINDOW_USER_WIZ						  6120

#define IDH_WINDOW_COMMIT_EXCHANGE                7000
#define IDH_WINDOW_COMMIT_GROUP                   7010
#define IDH_WINDOW_COMMIT_GROUPMAP                7020
#define IDH_WINDOW_COMMIT_SECURITY                7030
#define IDH_WINDOW_COMMIT_USER					  7040
#define IDH_WINDOW_DOMAIN_SELECTION_GROUP         7050
#define IDH_WINDOW_DOMAIN_SELECTION_GROUPMAP      7060
#define IDH_WINDOW_DOMAIN_SELECTION_REPORT        7070
#define IDH_WINDOW_DOMAIN_SELECTION_SECURITY      7080
#define IDH_WINDOW_DOMAIN_SELECTION_SERVICE       7090
#define IDH_WINDOW_DOMAIN_SELECTION_TRUST         7100
#define IDH_WINDOW_DOMAIN_SELECTION_USER          7110
#define IDH_WINDOW_DOMAIN_SELECTION_EXCHANGE      7120

#define IDH_WINDOW_COMPUTER_SELECTION_REPORT      7130
#define IDH_WINDOW_COMPUTER_SELECTION_SECURITY    7140
#define IDH_WINDOW_OU_SELECTION_GROUP		      7150
#define IDH_WINDOW_OU_SELECTION_GROUPMAP          7160
#define IDH_WINDOW_OU_SELECTION_USER              7170

#define IDH_WINDOW_OBJECTTYPE_SELECTION_SECURITY  7180

#define IDH_WINDOW_SECURITY_OPTION_SECURITY       7190
#define IDH_WINDOW_SECURITY_OPTION_EXCHANGE       7200

#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_GROUP   7210
#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_USER    7220

#define IDH_WINDOW_NAME_CONFLICT_GROUP             7230
#define IDH_WINDOW_NAME_CONFLICT_USER              7240

#define IDH_WINDOW_CONFIRMATION_GROUP              7250
#define IDH_WINDOW_CONFIRMATION_GROUPMAP           7260
#define IDH_WINDOW_CONFIRMATION_REPORT             7270
#define IDH_WINDOW_CONFIRMATION_RETRY              7280
#define IDH_WINDOW_CONFIRMATION_SECURITY           7290
#define IDH_WINDOW_CONFIRMATION_SERVICE            7300
#define IDH_WINDOW_CONFIRMATION_UNDO               7310
#define IDH_WINDOW_CONFIRMATION_USER               7320
#define IDH_WINDOW_CONFIRMATION_EXCHANGE           7330

#define IDH_WINDOW_GROUP_OPTION_GROUPMAP           7340
#define IDH_WINDOW_GROUP_SELECTION_GROUPMAP        7350

#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_USER     7360
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_UNDO     7370
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_GROUPMAP 7380
#define IDH_WINDOW_USER_ACC_PASS		   7390
#define IDH_WINDOW_CONFIRMATION_TRUST      	   7400
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\isadmin.hpp ===
//#pragma title( "IsAdmin.hpp - Determine if user is administrator" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  IsAdmin.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-06-04
Description -  Determine if user is administrator (local or remote)
Updates     -
===============================================================================
*/

#ifndef  MCSINC_IsAdmin_hpp
#define  MCSINC_IsAdmin_hpp

// Determine if user is administrator on local machine
DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminLocal();

// Determine if user is a Domain Admin in target domain.
DWORD __stdcall IsDomainAdmin(PSID psidDomain);

// Determine if user is administrator on remote machine
DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminRemote(
      WCHAR          const * pMachine      // in -\\machine name
   );

#endif  // MCSINC_IsAdmin_hpp

// IsAdmin.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\htmlhelputil.h ===
/*
===============================================================================
Module      -  HtmlHelpUtil.h
System      -  Common
Author      -  Xuesong Yuan
Created     -  2001-12-14
Description -  Utils related to HtmlHelp
Updates     -
===============================================================================
*/

#ifndef  HTMLHELPUTIL_H
#define  HTMLHELPUTIL_H

BOOL IsInWorkArea(HWND hwndHelpViewer);
void PlaceInWorkArea(HWND hwndHelpViewer);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\lsautils.h ===
/*---------------------------------------------------------------------------
  File: LSAUtils.h

  Comments: Utility functions to change the domain affiliation of a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_INVALID_SID              ((NTSTATUS)0xC0000078L)
#endif


BOOL
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=connect,FALSE=disconnect
    );

void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,   // in - pointer to LSA string to initialize
      LPWSTR                 String       // in - value to initialize string to
    );

NTSTATUS
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - required access
      PLSA_HANDLE            PolicyHandle    // out- policy handle
    );

BOOL
   GetDomainSid(
      LPWSTR                 DomainName,   // in - domain name to acquire Sid of
      PSID                 * pDomainSid    // out- points to allocated Sid on success
    );

NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text, if failure
    );

NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - SID for new primary domain
      LPWSTR                 TrustedDomainName     // in - name of new primary domain
    );

NTSTATUS  
   QueryWorkstationTrustedDomainInfo(
       LSA_HANDLE            PolicyHandle,   // in - policy handle
       PSID                  DomainSid,      // in - SID for new primary domain
       BOOL                  bNoChange       // in - flag, no change mode
   );


BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain for Username account
      LPWSTR                 Username,     // in - username to connnect as
      LPWSTR                 Password,     // in - password for Username account
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    );

BOOL
   EstablishShare(
      LPCWSTR                Server,      // in - server name
      LPWSTR                 Share,       // in - share name to connect to
      LPWSTR                 Domain,      // in - domain for credentials
      LPWSTR                 UserName,    // in - username to connect as
      LPWSTR                 Password,    // in - password for credentials
      BOOL                   bEstablish   // in - TRUE=connect, FALSE=disconnect
    );


//
// Password Functionality
//

DWORD __stdcall StorePassword(PCWSTR pszIdentifier, PCWSTR pszPassword);
DWORD __stdcall RetrievePassword(PCWSTR pszIdentifier, PWSTR pszPassword, size_t cchPassword);
DWORD __stdcall GeneratePasswordIdentifier(PWSTR pszIdentifier, size_t cchIdentifier);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\names.hpp ===
/*---------------------------------------------------------------------------
  File: Names.hpp

  Comments: Definitions for helper functions for name modifying and converting

 ---------------------------------------------------------------------------*/

// removes invalid characters, such as ( ) from SAM account name
void 
   StripSamName(
      WCHAR                * samName              // i/o - SAM account name to process
   );

_bstr_t
   GetDomainDNSFromPath(
      _bstr_t				 sPath				  // in - path of object
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\migrationmutex.h ===
#pragma once


#define ADMT_MUTEX _T("Global\\{9DC80865-6CC7-4988-8CC0-2AC5CA01879C}")
#define AGENT_MUTEX _T("Global\\{E2624042-8C80-4A83-B3DF-2B840DE366E5}")
#define AGENT_MUTEX_NT4 _T("{E2624042-8C80-4A83-B3DF-2B840DE366E5}")
#define DISPATCHER_MUTEX _T("Global\\{7C84F7DB-CF48-4B59-99D8-6B5A95276DBD}")


//---------------------------------------------------------------------------
// MigrationMutex Class
//
// This class may be used to prevent more than one instance of a migration
// task to run at the same time.
//
//
// Revision
// Initial	01/26/01 Mark Oluper
//---------------------------------------------------------------------------

class CMigrationMutex
{
public:

	CMigrationMutex(LPCTSTR pszMutexName, bool bObtainOwnership = false) :
		m_hMutex(CreateMutex(NULL, FALSE, pszMutexName))
	{
		if (bObtainOwnership)
		{
			ObtainOwnership();
		}
	}

	~CMigrationMutex()
	{
		if (m_hMutex)
		{
			ReleaseOwnership();
			CloseHandle(m_hMutex);
		}
	}

	bool ObtainOwnership(DWORD dwTimeOut = INFINITE)
	{
		bool bObtain = false;

		if (m_hMutex)
		{
			if (WaitForSingleObject(m_hMutex, dwTimeOut) == WAIT_OBJECT_0)
			{
				bObtain = true;
			}
		}

		return bObtain;
	}

	void ReleaseOwnership()
	{
		if (m_hMutex)
		{
			ReleaseMutex(m_hMutex);
		}
	}

protected:

	HANDLE m_hMutex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\pwdfuncs.h ===
#ifndef __PASSWORDFUNCTIONS_H__
#define __PASSWORDFUNCTIONS_H__
/*---------------------------------------------------------------------------
  File: PwdFuncs.h

  Comments: Contains general password migration helper functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/08/00 

  ---------------------------------------------------------------------------
*/

        
_bstr_t EnumLocalDrives();
void StoreDataToFloppy(LPCWSTR sPath, _variant_t & varData);
_variant_t GetDataFromFloppy(LPCWSTR sPath);
char* GetBinaryArrayFromVariant(_variant_t varData);
_variant_t SetVariantWithBinaryArray(char * aData, DWORD dwArray);
DWORD GetVariantArraySize(_variant_t & varData);
void PrintVariant(const _variant_t & varData);
#endif //__PASSWORDFUNCTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\pwgen.hpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate a password from the rules provided.
// Returns ERROR_SUCCESS if successful, else ERROR_INVALID_PARAMETER.
// If successful, the new password is returned in the supplied buffer.
// The buffer must be long enough to hold the minimum length password
//   that is required by the rules, plus a terminating NULL.

// Password generation service
#define PWGEN_MIN_LENGTH    8    // enforced minimum password length
#define PWGEN_MAX_LENGTH   14    // enforced maximum password length

DWORD __stdcall                            // ret-EA/OS return code
   EaPasswordGenerate(
      DWORD                  dwMinUC,              // in -minimum upper case chars
      DWORD                  dwMinLC,              // in -minimum lower case chars
      DWORD                  dwMinDigits,          // in -minimum numeric digits
      DWORD                  dwMinSpecial,         // in -minimum special chars
      DWORD                  dwMaxConsecutiveAlpha,// in -maximum consecutive alpha chars
      DWORD                  dwMinLength,          // in -minimum length
      WCHAR                * newPassword,          // out-returned password
      DWORD                  dwBufferLength        // in -returned area buffer length
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h
//
// The debug macros and support classes are declared in
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The
// usage of these macros is outlined in the MCS Coding
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.
// In the debug mode these macros are the same as
// MCSASSERT(SZ).  In the release mode they throw an
// exception McsException The usage of these macros is
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.
// In the debug mode these macros are the same as
// MCSASSERT(SZ).  In the release mode they log the
// message using McsVerifyLog class.  The usage of these
// macros is outlined in the MCS Coding Standards document.
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.
// The output log file is created in the directory
// defined by MCS_LOG environment variable, or in the
// TEMP directory, or in the current directory.  The name
// of the output log file is <module name>.err.
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// -------------------------------
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      int getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// -------------------------------
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException
// -----------------
inline McsDebugException::McsDebugException ()
: m_message (0), m_fileName (0), m_lineNum (0)
{ /* EMPTY */ }

inline McsDebugException::~McsDebugException() {
   delete [] m_message;
   delete [] m_fileName;
}

inline const char *McsDebugException::getMessage
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void)
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void)
: m_isTested (FALSE), m_isTestMode_ (FALSE)
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\registryhelper.h ===
/*
===============================================================================
Module      -  RegistryHelper.hpp
System      -  Common
Author      -  Xuesong Yuan
Created     -  2001-09-06
Description -  Registry helper functions
Updates     -
===============================================================================
*/

#ifndef  REGISTRYHELPER_H
#define  REGISTRYHELPER_H

DWORD CopyRegistryKey(HKEY sourceKey, HKEY targetKey, BOOL fSetSD);
DWORD DeleteRegistryKey(HKEY hKey, LPCTSTR lpSubKey);
DWORD MoveRegistry();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\samutils.h ===
#pragma once


//
// Verifies that the given credentials have
// administrative privileges on the specified domain.
//

DWORD __stdcall VerifyAdminCredentials
    (
        PCWSTR pszDomain,
        PCWSTR pszDomainController,
        PCWSTR pszUserName,
        PCWSTR pszPassword,
        PCWSTR pszUserDomain
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\pwrpcutl.h ===
/*---------------------------------------------------------------------------
  File: PwdRpcUtil.h

  Comments: Functions to establish binding to Password Migration Lsa 
  Notifications packages.  These functions are used by the password extension 
  to bind to the password migration Lsa notification package on remote source 
  domain DCs.
    This files was copied from AgRpcUtil.h, which was created by Christy Boles
  of NetIQ Corporation.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/


// Create RPC binding for connection with a remote Lsa notification package Dll
DWORD                                      // ret-OS return code
   PwdBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -authentication option
   );

DWORD                                      // ret-OS return code
   PwdBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\resstr.h ===
#ifndef RES_STRING_H
#define RES_STRING_H
#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "TSync.hpp"

#define MAX_STRING_SIZE          (5000)
#include "Mcs.h"
#include "McsRes.h"
#include "UString.hpp"
#include "folders.h"

using namespace nsFolders;

class StringLoader
{
   HINSTANCE                 m_hInstance; // handle to resources to load from
   TCriticalSection          m_cs;
   WCHAR                     m_buffer[MAX_STRING_SIZE];
   DWORD                     rc;
public:
   StringLoader() 
   { 
      WCHAR                  fullpath[400];
      DWORD                  lenValue = sizeof(fullpath);
      DWORD                  type;
	  LONG					 lRet = 0;
         // first, try to load from our install directory
      HKEY           hKey;

      m_hInstance = NULL;
      
      lRet = RegOpenKey((HKEY)HKEY_LOCAL_MACHINE,REGKEY_ADMT,&hKey);
      if ( !lRet )
      {
         
         lRet = RegQueryValueEx(hKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
         if (!lRet )
         {
            if (type == REG_SZ)
            {
               // ensure NULL termination
               fullpath[(lenValue >= sizeof(WCHAR)) ? ((lenValue/sizeof(WCHAR))-1) : 0] = L'\0';

               //make sure we have enough space in the buffer
               if ((UStrLen(fullpath) + UStrLen(L"McsDmRes.DLL")) < (sizeof(fullpath)/sizeof(WCHAR)))
               {
                   UStrCpy(fullpath+UStrLen(fullpath),L"McsDmRes.DLL");
                   
                   m_hInstance = LoadLibrary(fullpath);
               }
            }
         }
         RegCloseKey(hKey);
      }

      // If that fails, see if there's one anywhere in the path
      if ( ! m_hInstance )
      {
         m_hInstance = LoadLibrary(L"McsDmRes.DLL");
      }
      if (! m_hInstance ) 
      {
         MCSASSERTSZ(FALSE,"Failed to load McsDmRes.DLL");
         rc = GetLastError(); 
      }
   }

   WCHAR                   * GetString(UINT nID)
   {
      int                    len;
      WCHAR                * result = NULL;

      m_cs.Enter();
      m_buffer[0] = 0;
      len = LoadString(m_hInstance,nID,m_buffer,MAX_STRING_SIZE);
      if (! len )
      {
//         DWORD               rc = GetLastError();
         GetLastError();
      }
      result = new WCHAR[len+1];
	  if (!result)
	  {
	     m_cs.Leave();
         _com_issue_error(E_OUTOFMEMORY);
	     return NULL;
	  }
      wcscpy(result,m_buffer);
      m_cs.Leave();

      return result;
   }
};
          
extern StringLoader gString;
  
class TempString
{
   WCHAR                   * m_data;
public:
   TempString(WCHAR * data) { m_data = data; }
   ~TempString() { if ( m_data ) delete [] m_data; }
   operator WCHAR * () { return m_data; }
   operator WCHAR const * () { return (WCHAR const*)m_data; }
};

//#define GET_BSTR(nID) _bstr_t(SysAllocString(GET_STRING(nID)),false)
#define GET_BSTR(nID)   _bstr_t((WCHAR*)TempString(gString.GetString(nID)))

#define GET_STRING(nID) GET_STRING2(gString,nID)

#define GET_STRING2(strObj,nID) TempString(strObj.GetString(nID))

#define GET_WSTR(nID) ((WCHAR*)TempString(gString.GetString(nID)))
#endif RES_STRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\sdhelper.h ===
#ifndef SDHELPER_H
#define SDHELPER_H

#include "sd.hpp"

//----------------------------------------------------------------------------
// Function:   ConvertSID
//
// Synopsis:   Converts a sid to a form that can be deallocated using free.
//
// Arguments:
//
// originaSid       a sid to be converted
//
// Returns:    a pointer to a SID; otherwise, returns NULL
//                 the caller is responsible for freeing the memory
//
// Modifies:
//
// Note:        this function does not try to validate the input SID.
//
//----------------------------------------------------------------------------
PSID ConvertSID(PSID originalSid);

//----------------------------------------------------------------------------
// Function:   BuildAdminsAndSystemSDForCOM
//
// Synopsis:   Builds a TSD object that allows Local Administrators and System
//                  COM_RIGHTS_EXECUTE access.
//
// Arguments:
//
// Returns:    A pointer to a TSD object; otherwise, returns NULL
//                 the caller is responsible for freeing the memory
//
// Modifies:
//
//----------------------------------------------------------------------------
TSD* BuildAdminsAndSystemSDForCOM();

//----------------------------------------------------------------------------
// Function:   BuildAdminsAndSystemSD
//
// Synopsis:   Builds a TSD object that allows Local Administrators and System
//                  access as specified by accessMask.
//                      owner is set to administrators
//                      group is set to administrators
//
// Arguments:
//
// accessMask       the access mask
//
// Returns:    A pointer to a TSD object; otherwise, returns NULL
//                 the caller is responsible for freeing the memory
//
// Modifies:
//
//----------------------------------------------------------------------------
TSD* BuildAdminsAndSystemSD(DWORD accessMask);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\sd.hpp ===
/*---------------------------------------------------------------------------
  File: SD.hpp

  Comments: A generic class for managing security descriptors. 
  The constructor takes a security descriptor in self-relative format.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01-Oct-98 12:30:26

 ---------------------------------------------------------------------------
*/
#include <stdlib.h>
#include <malloc.h>

#define SD_DEFAULT_STRUCT_SIZE (sizeof (SECURITY_DESCRIPTOR) )
#define SD_DEFAULT_ACL_SIZE 787
#define SD_DEFAULT_SID_SIZE 30
#define SD_DEFAULT_SIZE 400

#define DACL_FULLCONTROL_MASK (FILE_GENERIC_READ | FILE_ALL_ACCESS)
#define DACL_CHANGE_MASK (FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE)
#define DACL_READ_MASK ( FILE_GENERIC_READ | FILE_GENERIC_EXECUTE )
#define DACL_NO_MASK 0

#define SACL_READ_MASK (ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ)
#define SACL_WRITE_MASK (ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE)
#define SACL_EXECUTE_MASK ( SYNCHRONIZE | FILE_GENERIC_EXECUTE )
#define SACL_DELETE_MASK (DELETE)
#define SACL_CHANGEPERMS_MASK (WRITE_DAC)
#define SACL_CHANGEOWNER_MASK (WRITE_OWNER)

#define SET_SID_FAILED -1
#define SET_SID_NOTLARGEENOUGH 0
#define SET_SID_SUCCEEDED 1

typedef enum { McsUnknownSD=0, McsFileSD, McsDirectorySD, McsShareSD, McsMailboxSD, McsExchangeSD, McsRegistrySD, McsPrinterSD } SecuredObjectType;

class TSecurableObject;
class TACE
{
   ACCESS_ALLOWED_ACE      * m_pAce;
   BOOL                      m_bNeedToFree;
   
public:
   TACE(BYTE type,BYTE flags,DWORD mask, PSID sid); // allocates and initializes a new ace 
   TACE(void * pAce) { m_pAce = (ACCESS_ALLOWED_ACE *)pAce; m_bNeedToFree = FALSE; } // manages an existing ace
   ~TACE() { if ( m_bNeedToFree ) free(m_pAce); }
   void * GetBuffer() { return m_pAce; }
   void SetBuffer(void * pAce, BOOL bNeedToFree = FALSE) { m_pAce = (ACCESS_ALLOWED_ACE *)pAce; m_bNeedToFree = bNeedToFree;}
   
   BYTE   GetType();
   BYTE   GetFlags();
   DWORD  GetMask();
   PSID   GetSid();
   WORD   GetSize();
   
   BOOL SetType(BYTE newType);
   BOOL SetFlags(BYTE newFlags);
   BOOL SetMask(DWORD newMask);
   DWORD SetSid(PSID sid);

   BOOL IsAccessAllowedAce();
};

class TSD
{
   friend class TSecurableObject;
protected:
   SECURITY_DESCRIPTOR     * m_absSD;             // SD in absolute format
   BOOL                      m_bOwnerChanged;
   BOOL                      m_bGroupChanged;
   BOOL                      m_bDACLChanged;
   BOOL                      m_bSACLChanged;
   BOOL                      m_bNeedToFreeSD;
   BOOL                      m_bNeedToFreeOwner;
   BOOL                      m_bNeedToFreeGroup;
   BOOL                      m_bNeedToFreeDacl;
   BOOL                      m_bNeedToFreeSacl;
   SecuredObjectType         m_ObjectType;

public:
   TSD(SECURITY_DESCRIPTOR * pSD, SecuredObjectType objectType, BOOL bResponsibleForDelete);
   TSD(TSD * pTSD);
   TSD(SecuredObjectType objectType);
   ~TSD();
   
   SECURITY_DESCRIPTOR const * GetSD() const { return m_absSD; }  // returns a pointer to the absolute-format SD
   
   SECURITY_DESCRIPTOR * MakeAbsSD() const; // returns a copy of the SD in absolute format
   SECURITY_DESCRIPTOR * MakeRelSD() const; // returns a copy of the SD in self-relative format

   // type of secured object 
   SecuredObjectType GetType() const { return m_ObjectType; }
   void              SetType(SecuredObjectType newType) { m_ObjectType = newType;}

   // Security Descriptor parts
   PSID const GetOwner() const;
   void       SetOwner(PSID pNewOwner);
   PSID const GetGroup() const;
   void       SetGroup(PSID const pNewGroup);
   PACL const GetDacl() const;
   // SetDacl will free the buffer pNewAcl.
   BOOL       SetDacl(PACL pNewAcl,BOOL present = TRUE);
   PACL const GetSacl() const;
   // SetSacl will free the buffer pNewAcl.
   void       SetSacl(PACL pNewAcl, BOOL present = TRUE);

   // Security Descriptor flags
   BOOL IsOwnerDefaulted() const;
   BOOL IsGroupDefaulted() const;
   BOOL IsDaclDefaulted() const;
   BOOL IsDaclPresent() const;
   BOOL IsSaclDefaulted() const;
   BOOL IsSaclPresent() const;

   // Change tracking functions
   BOOL IsOwnerChanged() const { return m_bOwnerChanged; }
   BOOL IsGroupChanged() const { return m_bGroupChanged; }
   BOOL IsDACLChanged()  const { return m_bDACLChanged; }
   BOOL IsSACLChanged()  const { return m_bSACLChanged; }
   BOOL IsChanged() const { return ( m_bOwnerChanged || m_bGroupChanged || m_bDACLChanged || m_bSACLChanged ); }
   void MarkAllChanged(BOOL bChanged) { m_bOwnerChanged=bChanged; m_bGroupChanged=bChanged; m_bDACLChanged=bChanged; m_bSACLChanged=bChanged; }
   // Functions to manage ACLs
   int    GetNumDaclAces() { return ACLGetNumAces(GetDacl()); }
   void   AddDaclAce(TACE * pAce);
   void   RemoveDaclAce(int ndx);
   void * GetDaclAce(int ndx) { return ACLGetAce(GetDacl(),ndx); }

   int    GetNumSaclAces() { return ACLGetNumAces(GetSacl()); }
   void   AddSaclAce(TACE * pAce);
   void   RemoveSaclAce(int ndx);
   void * GetSaclAce(int ndx) { return ACLGetAce(GetSacl(),ndx); }

   BOOL   IsValid() { return (m_absSD && IsValidSecurityDescriptor(m_absSD)); } 
   
   void FreeAbsSD(SECURITY_DESCRIPTOR * pSD, BOOL bAll = TRUE);
   void   ACLAddAce(PACL * ppAcl, TACE * pAce, int pos);
   void * ACLGetAce(PACL acl, int ndx);
protected:
   // Implementation - helper functions
   // Comparison functions
   
   // ACL manipulation functions
   int    ACLGetNumAces(PACL acl);
   DWORD  ACLGetFreeBytes(PACL acl);
   DWORD  ACLGetBytesInUse(PACL acl);
   
   void   ACLDeleteAce(PACL acl, int ndx);
   SECURITY_DESCRIPTOR * MakeAbsSD(SECURITY_DESCRIPTOR * pSD) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\sidhistoryflags.h ===
#pragma once

#define  F_WORKS                    0x00000000
#define  F_WRONGOS                  0x00000001
#define  F_NO_REG_KEY               0x00000002
#define  F_NO_AUDITING_SOURCE       0x00000004
#define  F_NO_AUDITING_TARGET       0x00000008
#define  F_NO_LOCAL_GROUP           0x00000010
#define  F_NOT_DOMAIN_ADMIN         0x00000020
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\secpi.h ===
/*---------------------------------------------------------------------------
  File: SecPI.h

  Comments: Structure definition for the structure used for challenge/response
  authentication of our plug ins.  The dispatcher sends this structure to each 
  plug-in before adding the plug-in to the list of plug-ins to be dispatched.  
  The plug-in must modify this structure in the correct way, and return it to 
  the dispatcher.  This will make it more difficult for others to use our 
  undocumented plug-in interface.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:33:52

 ---------------------------------------------------------------------------
*/
#pragma once

typedef struct 
{
   long                      lTime;
   long                      lRand1;
   long                      lRand2;
   char                      MCS[4];
}McsChallenge;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\secobj.hpp ===
//#pragma title( "SDResolve.hpp - SDResolve Class definitions" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecureObject.hpp
System      -  Domain Consolidation Toolkit
Author      -  Christy Boles
Created     -  97/06/27
Description -  Securable object classes (File, Share, and Exchange) for FST and EST.    
Updates     -
===============================================================================
*/

#include <lm.h>
#include <lmshare.h>
#include <winspool.h>

//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <process.h>

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif


#ifdef SDRESOLVE 
   #include "sdstat.hpp"
   #include "STArgs.hpp"
#endif
#include "UString.hpp"
#include "EaLen.hpp"

class TSecurableObject
{
   protected:
   
   TNodeList                 changelog;
   WCHAR                     pathname[LEN_Path];  
   HANDLE                    handle;     
   bool                      owner_changed;
   bool                      group_changed;
   bool                      dacl_changed;
   bool                      sacl_changed;
   TSD                     * m_sd;

public:
                             TSecurableObject(){ 
                                                pathname[0]=0; handle = INVALID_HANDLE_VALUE;
                                                daceNS = 0;saceNS = 0;daceEx = 0;saceEx = 0;
                                                daceU  = 0;saceU  = 0;daceNT = 0;saceNT = 0;
                                                unkown = false; unkgrp = false; m_sd = NULL;
                             }
  
                             ~TSecurableObject();
   LPWSTR                    GetPathName() const { return (LPWSTR) &pathname; }
   void                      ResetHandle() { handle = INVALID_HANDLE_VALUE; }
   
   bool                      Changed() const { return (owner_changed || group_changed || dacl_changed || sacl_changed) ; }
   void                      Changed(bool bChanged) { m_sd->MarkAllChanged(bChanged); }
   int                       daceNS;   // not selected
   int                       saceNS;
   int                       daceU;    // unknown
   int                       saceU;
   int                       daceEx;   // examined
   int                       saceEx;
   int                       daceNT;   // no target
   int                       saceNT;
   bool                      unkown;   // unknown owners
   bool                      unkgrp;   // unknown groups

   bool                       UnknownOwner() const { return unkown;}
   bool                       UnknownGroup() const { return unkgrp; }
   void                      CopyAccessData(TSecurableObject * sourceFSD);
   
   virtual bool              WriteSD() = 0;
   virtual bool              ReadSD(const LPWSTR path) = 0;   
   bool                      HasSecurity() const { return m_sd != NULL; }
   bool                      HasDacl() const { return ( m_sd && (m_sd->GetDacl()!=NULL) ) ; }
   bool                      HasSacl() const { return ( m_sd && (m_sd->GetSacl()!=NULL) ) ; }
   bool                      IsDaclChanged() const { return dacl_changed; }
   bool                      IsSaclChanged() const { return sacl_changed; }
   TSD                     * GetSecurity() { return m_sd; }
#ifdef SDRESOLVE
   const TNodeList         * GetChangeLog() const { return &changelog; }
   void                      LogOwnerChange(TAcctNode *acct){ changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::owner,TRUE)); }
   void                      LogGroupChange(TAcctNode *acct){ changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::group,TRUE)); }
   void                      LogDACEChange(TAcctNode *acct) { changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::dace,TRUE)); }
   void                      LogSACEChange(TAcctNode *acct) { changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::sace,TRUE)); }
   
   bool                      ResolveSD(
      SecurityTranslatorArgs * args,              // in -cache to lookup accounts in 
      TSDResolveStats        * stat,              // in -stats object to increment counters
      objectType               type,              // in -is this file or dir or share
      TSecurableObject       * Last               // in -Last SD for cache comparison
   );   

protected:
  
   PACL                     ResolveACL(PACL acl, TAccountCache *cache, TSDResolveStats *stat, 
                                        bool *changes, BOOL verbose,int opType,objectType objType, BOOL bUseMapFile);
    
public:
   bool                     ResolveSDInternal( TAccountCache *cache, TSDResolveStats *stat, BOOL verbose,int opType, objectType objType, BOOL bUseMapFile);
   
#endif
   
};

/////////////////////////////////////////////////////////////////////////////////
///////////File and directory Acls  
/////////////////////////////////////////////////////////////////////////////////

class TFileSD:public TSecurableObject
{
protected:
   bool m_bSystemFile;

public:
                              TFileSD(const LPWSTR fpath, bool bSystemFile = false);
                             ~TFileSD();
   virtual bool              WriteSD();
   virtual bool              ReadSD(const LPWSTR path);   
};




class TShareSD : public TSecurableObject
{
private:   
   SHARE_INFO_502          * shareInfo;
   WCHAR                   * serverName;
public:
                        TShareSD(const LPWSTR name);
                        ~TShareSD() { if (shareInfo) 
                                       { NetApiBufferFree(shareInfo); 
                                         shareInfo = NULL; 
                                       }
                                      if ( serverName ) 
                                      {
                                          delete serverName;
                                          serverName = NULL;
                                      }
                        }
   
   virtual bool         WriteSD();
   virtual bool         ReadSD(const LPWSTR path); 
           bool         SetSD(TSD* sd);
};


class TMapiSD : public TSecurableObject
{
   WCHAR                     name[LEN_DistName];

public:
   TMapiSD(SECURITY_DESCRIPTOR * pSD) { m_sd = new TSD(pSD,McsMailboxSD,FALSE); }
   void SetName(WCHAR const * str) { safecopy(name,str); }
   bool ReadSD(const LPWSTR path) { MCSASSERT(FALSE); return false; }
   bool WriteSD() { MCSASSERT(FALSE);return false; }
};


class TRegSD : public TSecurableObject
{
   HKEY                      m_hKey;
   WCHAR                     name[LEN_DistName];
public:
   TRegSD(const LPWSTR name, HKEY hKey);
   ~TRegSD() { }
   virtual bool         WriteSD();
   virtual bool         ReadSD(HKEY hKey);
   virtual bool         ReadSD(const LPWSTR path) { MCSASSERT(FALSE); return false; }
};

class TPrintSD: public TSecurableObject
{
   WCHAR                    name[MAX_PATH];
   HANDLE                   hPrinter;
   BYTE                   * buffer;
public:
   TPrintSD(const LPWSTR name);
   ~TPrintSD() 
    { 
      if ( hPrinter != INVALID_HANDLE_VALUE ) 
         ClosePrinter(hPrinter);
      if ( buffer )
         delete buffer;
   }
   virtual bool         WriteSD();
   virtual bool         ReadSD(const LPWSTR path); 
};

#ifdef SDRESOLVE
int
   ResolveAll(
      SecurityTranslatorArgs  * args,           // in - arguments that determine settings for the translation
      TSDResolveStats         * stats           // in - object used for counting objects examined, modified, etc.
   );
#endif

WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   );

int EqualSignIndex(char * str);
int ColonIndex(TCHAR * str);
BOOL BuiltinRid(DWORD rid);
#ifdef SDRESOLVE
DWORD PrintSD(SECURITY_DESCRIPTOR * sd,WCHAR const * path);
DWORD PermsPrint(WCHAR* path,objectType objType);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\strhelp.h ===
#ifndef __STRINGHELP_H__
#define __STRINGHELP_H__
/*---------------------------------------------------------------------------
  File: StrHelp.h

  Comments: Contains general string helper functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/02/00 

  ---------------------------------------------------------------------------
*/

        
BOOL                                         //ret- TRUE=string found
   IsStringInDelimitedString(    
      LPCWSTR                sDelimitedString, // in- delimited string to search
      LPCWSTR                sString,          // in- string to search for
      WCHAR                  cDelimitingChar   // in- delimiting character used in the delimited string
   );

#endif //__STRINGHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\taskchk.h ===
BOOL NeedToRunLocalAgent(IVarSet * pVarSet);
BOOL NeedToDispatch(IVarSet * pVarSet);
BOOL NeedToUseAR(IVarSet * pVarSet);
BOOL NeedToUseST(IVarSet * pVarSet, BOOL bForceRemoteCheck = FALSE); 
BOOL NeedToRunReports(IVarSet * pVarSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\tevent.hpp ===
//#pragma title( "TEvent.hpp - Log events" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TEvent.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1995-11-16
Description -  TErrorEventLog derived class.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TEvent_hpp
#define  MCSINC_TEvent_hpp

// Start of header file dependencies

#include "ErrDct.hpp"

#ifndef  MCSINC_UString_hpp
#include "UString.hpp"
#endif

// End of header file dependencies

class TErrorEventLog : public TErrorDct
{
private:
   HANDLE                    hEventSource;
public:
   TErrorEventLog(
      WCHAR          const * server       ,// in -UNC name of server
      WCHAR          const * subkey       ,// in -event log subkey name
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
   ) : TErrorDct( displevel, loglevel, logmode, beeplevel )
   {
      hEventSource = RegisterEventSourceW( server, subkey );
   }

   ~TErrorEventLog() { LogClose(); }

   virtual BOOL         LogOpen(
      WCHAR           const * fileName    ,// in -name of file including any path
      int                     mode = 0    ,// in -0=overwrite, 1=append
      int                     level = 0    // in -minimum level to log
   );
   virtual void         LogWrite(WCHAR const * msg);
   virtual void         LogClose();
};

#endif  // MCSINC_TEvent_hpp

// TEvent.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\tservice.hpp ===
//#pragma title( "TService.hpp - SCM interface for MCS service" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TService.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-08-17
Description -  SCM interface for MCS service
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TService_hpp
#define  MCSINC_TService_hpp

enum  TScmEpRc
{
   TScmEpRc_Unknown,                       // unknown
   TScmEpRc_OkCli,                         // normal completion (run as CLI)
   TScmEpRc_OkSrv,                         // normal completion (run as service)
   TScmEpRc_InvArgCli,                     // invalid arguments (command line)
   TScmEpRc_InvArgSrv,                     // invalid arguments (service start)
};

// Provided by TService.cpp

TScmEpRc                                   // TScmEp return code
   TScmEp(
      int                    argc         ,// in -argument count
      char          const ** argv         ,// in -argument array
      TCHAR                * nameService   // in -name of service
   );

// Provided by TService user

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      char           const * arg           // in -command line argument
   );

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      WCHAR          const * arg           // in -command line argument
   );

BOOL                                       // ret-TRUE if force CLI
   UScmForceCli();

void
   UScmEp(
//      BOOL                   bService      // in -FALSE=Cli,TRUE=Service
   );

#endif  // MCSINC_TService_hpp

// TService.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\tsync.hpp ===
//#pragma title( "TSync.hpp - Common synchronization classes header file" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes header file
               This includes TCriticalSection, and TNamedSemaphore
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TSync_hpp
#define  MCSINC_TSync_hpp

#ifndef _INC_TIME
#include <time.h>
#endif

class TCriticalSection
{
   CRITICAL_SECTION          cs;
public:
                        TCriticalSection() { InitializeCriticalSection(&cs); }
                        ~TCriticalSection() { DeleteCriticalSection(&cs); }
   void                 Enter() { EnterCriticalSection(&cs); }
   void                 Leave() { LeaveCriticalSection(&cs); }
};

class TSynchObject
{
public:
   HANDLE                    handle;
   TSynchObject()
   { handle = NULL; }
   ~TSynchObject()
   { Close(); }
   void Close()
   { if ( handle != NULL ) { CloseHandle( handle ); handle = NULL; } }

   DWORD                WaitSingle(DWORD msec) const { return WaitForSingleObject(handle, msec); }
   DWORD                WaitSingle()           const { return WaitForSingleObject(handle, INFINITE); }
   HANDLE               Handle() { return handle; }
};

///////////////////////////////////////////////////////////////////////////////
// Named semaphores
///////////////////////////////////////////////////////////////////////////////

class TSemaphoreNamed : public TSynchObject
{
public:
   TSemaphoreNamed() {};
   ~TSemaphoreNamed() {};
   DWORD Create(                           // ret-OS return code
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted=NULL // out-TRUE=previously existed
   );
   DWORD Open(                             // ret-OS return code
      TCHAR          const * sNameT        // in -semaphore name
   );
   DWORD Release(                          // ret-OS return code
      long                   nRelease=1    // in -number to release
   );
};


#endif  // MCSINC_TSync_hpp

// TSync.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\treg.hpp ===
//#pragma title( "TReg.hpp - Registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham, Jay Berlin
Created     -  1995-09-01
Description -  Registry class.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TReg_hpp
#define  MCSINC_TReg_hpp


class TRegKey
{
private:

   HKEY                      hKey;

public:

   TRegKey() { hKey = (HKEY)INVALID_HANDLE_VALUE; };
   TRegKey( HKEY hPreDefined, TCHAR const * machineName ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Connect( hPreDefined, machineName ); };
   TRegKey( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, hParent ); };
   TRegKey( TCHAR const * keyname, TRegKey const * regParent ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, regParent->hKey ); };
   ~TRegKey();

   DWORD Connect( HKEY hPreDefined, TCHAR const * machineName );

   DWORD Open( TCHAR const * keyname, TRegKey const * regParent, DWORD access = KEY_ALL_ACCESS ) { return Open( keyname, regParent->hKey, access ); };
   DWORD Open( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD access = KEY_ALL_ACCESS );
   DWORD OpenRead( TCHAR const * keyname, TRegKey const * regParent ) { return Open( keyname, regParent->hKey, KEY_READ ); };
   DWORD OpenRead( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE ) { return Open( keyname, hParent, KEY_READ ); };

   DWORD Create( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return Create( keyname, regParent->hKey, pDisp, access ); };
   DWORD Create( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );
   DWORD CreateBR( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return CreateBR( keyname, regParent->hKey, pDisp, access ); };
   DWORD CreateBR( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );

   HKEY KeyGet() { return hKey; }

   void Close();

   DWORD SubKeyDel( TCHAR const * keyname ) const { return RegDeleteKey( hKey, keyname ); };
   DWORD SubKeyRecursiveDel(TCHAR const* keyname) const;
   DWORD SubKeyEnum( DWORD index, TCHAR * keyname, DWORD keylen ) const;

// Note that "namelen" must be "sizeof name", not "DIM(name)"
// Same for "valuelen"

   DWORD ValueEnum( DWORD index, TCHAR * name, DWORD namelen, void * value, DWORD * valuelen, DWORD * valuetype ) const;

   DWORD ValueGet( TCHAR const * name, void * value, DWORD * lenvalue, DWORD * typevalue ) const;
   DWORD ValueGetDWORD( TCHAR const * name, DWORD * value ) const;
   DWORD ValueGetStr( TCHAR const * name, TCHAR * value, DWORD maxlen ) const;

   DWORD ValueSet( TCHAR const * name, void const * value, DWORD lenvalue, DWORD typevalue ) const;
   DWORD ValueSetDWORD( TCHAR const * name, DWORD value) const { return ValueSet(name, &value, sizeof value, REG_DWORD); }
   DWORD ValueSetStr( TCHAR const * name, TCHAR const * value, DWORD type = REG_SZ ) const;

   DWORD ValueDel( TCHAR const * name = NULL ) const;

   DWORD HiveCopy( TRegKey const * source );
   DWORD HiveDel();
   DWORD HiveReplicate( TRegKey const * source );
};

#endif // MCSINC_TReg.hpp

// TReg.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\txtsid.h ===
#ifndef __TEXTUALSID_H__
#define __TEXTUALSID_H__
/*---------------------------------------------------------------------------
  File: TextualSid.h

  Comments: Converts a SID between binary and textual representations.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/05/99 14:52:27

 ---------------------------------------------------------------------------
*/


        
BOOL                                         //ret- TRUE=success
   GetTextualSid(    
      PSID                   pSid,           // in - binary Sid
      LPTSTR                 TextualSid,     // out- textual representation of sid
      LPDWORD                lpdwBufferLen   // in - DIM length of buffer for TextualSid
   );


// The PSID returned from this function should be freed by the caller, using FreeSid
PSID                                        // ret- binary SID, or NULL
   SidFromString(
      WCHAR          const * strSid         // in - string representation of SID
   );


/*****************************************************************************************************/
/*   DomainizeSid: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSid(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   );

//takes a source and target account sid and breaks it into a src and tgt
//domain sid and src and tgt account rid
BOOL                                            // ret -Success ? TRUE | FALSE
   SplitAccountSids(
      PSID					 srcSid,			// in - src account sid
	  WCHAR                 *srcDomainSid,		// out - src domain sid (textual)
	  DWORD                 *srcRid,			// out - src account rid
	  PSID                   tgtSid,			// in - tgt account sid
	  WCHAR                 *tgtDomainSid,		// out - tgt domain sid (textual)
	  DWORD                 *tgtRid				// out - tgt account rid
   );


// The PSID returned from this function should be freed by the caller, using free()
PSID                                        // ret- binary SID, or NULL
   MallocedSidFromString(
      WCHAR          const * strSid         // in - string representation of SID
   );


//
// If SID is NULL or invalid returns NULL else makes
// a copy of the SID which must be freed using FreeSid.
//
PSID __stdcall SafeCopySid(PSID pSid);

#endif //__TEXTUALSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\tnode.hpp ===
//#pragma title( "TNode.hpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TNode.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1989-11-19
Description -  List/Tree base classes.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TNode_hpp
#define  MCSINC_TNode_hpp

#include "common.hpp"

#define MCS_ListError_InvalidHead       0x00000001
#define MCS_ListError_InvalidTail       0x00000002
#define MCS_ListError_InvalidCount      0x00000004
#define MCS_ListError_InvalidPtr        0x00000008
#define MCS_ListError_Exception         0x00000010

#define TNodeCompare(name)                                                     \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                    \
         TNode       const * v1          ,/* in -value1 to compare           */\
         TNode       const * v2           /* in -value2 to compare           */\
      )

#define TNodeCompareValue(name)                                               \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                   \
         TNode       const * tnode       ,/* in -value1 to compare           */\
         void        const * value        /* in -value2 to compare           */\
      )

#define DeleteAllListItems(datatype)                                          \
   TNodeListEnum             tenum;        /* enumerate values             */ \
   datatype                * tnode;        /* this node                    */ \
   datatype                * tnext;        /* next node                    */ \
   for ( tnode = (datatype *) tenum.OpenFirst( this );                        \
         tnode;                                                               \
         tnode = tnext )                                                      \
   {                                                                          \
      tnext = (datatype *) tenum.Next();                                      \
      Remove( tnode );                                                        \
      delete tnode;                                                           \
   }                                                                          \
   tenum.Close()

// TNode is a a base class for any derived object to be put into one of the
// TNodeList classes.
class TNode
{
   friend class TNodeList;
   friend class TNodeListSortable;
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
   TNode                   * left;
   TNode                   * right;
public:
   TNode                * Next() const { MCSASSERT(this); return right; }
// virtual ~TNode() {}
};


class TNodeList
{
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
protected:
   TNode                   * head,
                           * tail;
   DWORD                     count;
public:
                        TNodeList() { head = tail = NULL; count = 0; };
                        ~TNodeList();
   void                 InsertTop( TNode * eIns );
   void                 InsertBottom( TNode * eIns );
   void                 InsertAfter( TNode * eIns, TNode * eAft );
   void                 InsertBefore( TNode * eIns, TNode * eBef );
   void                 Remove(TNode const * t);
// void                 Delete(TNode * t) { Remove(t); delete t; };
   void                 Reverse();
   TNode *              Find(TNodeCompareValue((* Compare)), void const * findval) const;
   long                 Pos(TNode const * t) const
                        {
                           long n;
                           TNode * c;
                           MCSASSERT(this);
                           for (c=head, n=0; c!=t; c=c->right,n++);
                           return c ? n : -1;
                        }
   TNode              * Head() const { MCSASSERT(this); return head; }
   DWORD                Count() const { MCSASSERT (this); return count; }

protected:
   DWORD                Validate( TNode  ** pErrorNode );
};

/*
   A dynamically sortable collection of TNode entries.  The TNodes are arranged
   in either of two forms: a sorted linked linear list or a binary tree.  The
   current data data structure (form) is stored in the listType member.

   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
*/
enum TNodeListType { TNodeTypeError, TNodeTypeUnsorted, TNodeTypeLinear, TNodeTypeTree };

class TNodeListSortable : public TNodeList
{
private:
   TNode                   * lastInsert;
   static TNode *                          // ret-head of sorted list
                        TreeToSortedList(
         TNode                * top       ,// i/o-top of [sub]tree to squash
         TNode               ** newhead   ,// out-leftmost branch from tree
         TNode               ** newtail    // out-rightmost branch from tree
      );
   static TNode *                          // ret-middle of list (head of Btree)
                        ListSortedToTree(
         TNode                * top        // i/o-top of [sub]list to tree-ify
      );

   BOOL                 CountTree( TNode * pCurrentTop, DWORD * pCount);

protected:
   TNodeListType        listType;
                        TNodeCompare((* PCompare));
public:
                        TNodeListSortable(TNodeCompare((* pCompare)) = NULL, TNodeListType t = TNodeTypeLinear)
                           { lastInsert = NULL; listType = t; PCompare = pCompare; };
                                                      ~TNodeListSortable() { if ( IsTree() ) ToSorted(); }

   void                 CompareSet(TNodeCompare((* pCompare))) { PCompare = pCompare; }
   void                 TypeSetTree()   { listType = TNodeTypeTree; }
   void                 TypeSetSorted() { listType = TNodeTypeLinear; }

   void                 TreeInsert(TNode * item, short * depth);
   TNode **             TreeFindInsert(TNode const * item, short * depth);
   BOOL                 TreeInsertIfNew(TNode * item, short * depth)
   {
      TNode ** r=TreeFindInsert(item,depth);
      if (*r) return FALSE;
      *r=item;
      item->left = item->right = NULL;
      count++;
      return TRUE;
   }
   void                 TreeInsert(TNode * item) { short discard; TreeInsert(item, &discard); };
   void                 TreeRemove(TNode * item);
   TNode *              TreeFind(TNodeCompareValue((* pCompare)), void const * findval) const;

   void                 SortedInsert(TNode * t);
   BOOL                 SortedInsertIfNew(TNode * t);
   TNode *              SortedFindInsertBefore(TNode * item, BOOL * exists);

   void                 Insert(TNode * t) { if (IsTree()) TreeInsert(t); else SortedInsert(t); }
   BOOL                 InsertIfNew(TNode * t) { short depth; if (IsTree()) return TreeInsertIfNew(t,&depth);
                                                              else return SortedInsertIfNew(t); }
   virtual void         Remove(TNode * t) { if (t==lastInsert) lastInsert = NULL;
                                            if (IsTree()) TreeRemove(t);
                                            else TNodeList::Remove(t); };
// void                 Delete(TNode * t) { Remove(t); delete t; };
   TNode *              Find(TNodeCompareValue((* pCompare)), void const * findval) const
                           { if (IsTree()) return TreeFind(pCompare,findval); return TNodeList::Find(pCompare,findval); }

   void                 SortedToTree()
   {
      MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToTree - list is already a tree" );
      if ( !IsTree() )
      {
         head = ListSortedToTree( head );
         tail = NULL;
         listType = TNodeTypeTree;
      }
   }
   TNode *              UnsortedToTree();
   void                 ToSorted()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::ToSorted - list is not a tree" );
      if ( IsTree() )
      {
         MCSASSERT( ValidateTree() );
         if ( head )
            TreeToSortedList( head, &head, &tail );
         listType = TNodeTypeLinear;
      }
   }
   void                 Balance()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::Balance - list is not a tree" );
      if ( IsTree() )
      {
         ToSorted();
         SortedToTree();
      }
   }
   void                 Sort(TNodeCompare((* pCompare))) { TNodeListType lt = listType;
                                          if (lt == TNodeTypeTree) ToSorted();
                                          CompareSet(pCompare);
                                          UnsortedToTree();
                                          if (lt != TNodeTypeTree) ToSorted(); }
   void                 SortedToScrambledTree();
   BOOL                 IsTree() const { return listType == TNodeTypeTree; };

   BOOL                 ValidateTree( );
   DWORD                ValidateList( TNode  ** pErrorNode = NULL)
                        {
                           MCSASSERT(listType != TNodeTypeTree);
                           return Validate(pErrorNode);
                        }
};


/*
   TNodeListEnum is a 'friend' of TNode used to enumerate/iterate through
   TNodeList in linear list form.  It is an error to give it a TNodeList in
   tree form.
*/
class TNodeListEnum
{
protected:
   TNodeList         const * list;   // list for which enums are carried out
   TNode                   * curr;   // last node processed by enum functions
public:
                        TNodeListEnum() { list = NULL; curr = NULL; };
                        TNodeListEnum(TNodeList const * tlist) { Open(tlist); }
                        ~TNodeListEnum() { };

   void                 Open(TNodeList const * tlist) { list = tlist; Top(); };
   TNode              * OpenFirst(TNodeList const * tlist) { list = tlist; return First(); }
   TNode              * First() { return curr = list->head; };
   TNode              * Next() { return curr = (curr ? curr->right : list->head); }
   TNode              * Prev() { return curr = (curr ? curr->left  : list->tail); }
   TNode              * Last() { return curr = list->tail; };
   TNode *              Get() { return curr; }
   TNode *              Get(long n) { TNode * c; Top(); while ( n-->=0 && (c=Next()) ); return c; }
   void                 Close() { curr = NULL; }
   void                 Top() { curr = NULL; };
};

// provides optimized direct accessibility by ordinal to TNodeList at some
// expense to sequential traversal performance
class TNodeListOrdEnum : public TNodeListEnum
{
private:
   long                 nCurr;
public:
                        TNodeListOrdEnum() : TNodeListEnum() { nCurr = -1; };
                        TNodeListOrdEnum(TNodeList const * tlist) { Open(tlist); };

   void                 Open(TNodeList const * tlist) { TNodeListEnum::Open(tlist); nCurr = -1; };
   TNode              * OpenFirst(TNodeList const * tlist) { Open(tlist); return First(); }
   TNode              * First() { nCurr = list->head ? 0 : -1; return TNodeListEnum::First(); };
   TNode              * Next() { TNode * t = TNodeListEnum::Next(); if (curr) nCurr++; else nCurr=-1; return t; }
   TNode              * Prev() { TNode * t = TNodeListEnum::Prev(); if (curr) if (nCurr>0) nCurr--; else nCurr=list->Count()-1; else nCurr=-1; return t; }
   void                 Close() { nCurr=-1; TNodeListEnum::Close(); }
   void                 Top() { nCurr=-1; TNodeListEnum::Top(); };

   long                 Pos() const { return nCurr; };
   long                 Pos(TNode const * t) { long n; TNode * c;
                                               for (c=list->head, n=0; c!=t; c=c->right,n++);
                                               if (c) nCurr=n; else nCurr=-1; curr=c; return nCurr; }
   TNode *              Get(long n);
};


/*
   TNodeTreeEnum enumerates a TNodeListSortable that is in tree form.  It is an error
   to give it a TNodeListSortable that is in linear list form.
*/
enum TNodeTreeStackEntryState {Snone, Sleft, Sused, Sright, SComplete};
struct TNodeTreeStackEntry
{
   TNode                * save;
   TNodeTreeStackEntryState state;
};

const TREE_STACKSIZE = 200;            // default maximum recursion depth
class TNodeTreeEnum
{
private:
   TNodeTreeStackEntry     * stackBase,
                           * stackPos;
   int                       stackSize;
   void                 Push(TNode * item) { (++stackPos)->save = item; stackPos->state = Snone; };
   BOOL                 Pop() { if (stackBase) return --stackPos >= stackBase; else return FALSE; };
   void                 StackAlloc(int stacksize)
                           { stackSize = stacksize;
                             stackBase = new TNodeTreeStackEntry[stacksize]; };
protected:
   TNode                   * top;    // tree top for which enums are carried out
   TNode                   * curr;   // next node processed by enum functions
public:
                        TNodeTreeEnum(int stacksize = TREE_STACKSIZE) { top = NULL; StackAlloc(stacksize); };
                        TNodeTreeEnum(TNodeListSortable const * tlist, int stacksize = TREE_STACKSIZE) { StackAlloc(stacksize); Open(tlist); };
                        ~TNodeTreeEnum() { Close(); if (stackBase) delete [] stackBase; };

   void                 Open(TNodeListSortable const * tlist)
                           {
                              if (stackBase)
                              {
                                 stackPos = stackBase;
                                 stackPos->save = NULL;
                                 stackPos->state = SComplete;

                                 top = tlist->head;

                                 if ( top )
                                    Push(top);
                              }
                           }

   TNode              * First();
   TNode              * FirstAfter(TNodeCompareValue((* Compare) ), void const * findVal);
   TNode              * OpenFirst(TNodeListSortable const * tlist) { if (stackBase) { Open(tlist);  return Next(); } else return NULL; }

   TNode              * Next();
   TNode              * StackTop() { if (stackBase) return stackPos->save; else return NULL; }
   void                 Close() { stackPos = stackBase; }
};

#endif  // MCSINC_TNode_hpp

// TNode.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\validation.h ===
#pragma once


#define MAXIMUM_PREFIX_SUFFIX_LENGTH 8

bool __stdcall IsValidPrefixOrSuffix(LPCTSTR pszPrefixOrSuffix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\t_safevector.h ===
//-------------------------------------------------------------------------------------
// T_SafeVector.h
//
//  The follwing template classes provide a way of creating and accessing SafeArrays.
//  They are derived from the C++ standard library (STL) vector class and can be used
//  the same way. They can be accessed just like an array (with the [] operator).
//
//  Use the constructors or assignment operators to extract the SafeArray from a 
//  SAFEARRAY* or array variant (VARIANT or _variant_t). The elements will be 
//  copied into the vector.  Use the GetSafeArray() or GetVariant() methods to pack
//  the elements back into a SafeArray.
//
//  To create a new SafeArray, declare a varaible of the appropriate type and call
//  resize() to set the size, or push_back() to grow the array. Call GetSafeArray() 
//  or GetVariant() to produce a SafeArray.
//
//  See the T_SafeVector2 class at the bottom of this file for more information 
//  about the constructors, extractors, and assignment operators.
// 
//  Use the following pre-defined array types:
//
//           Array Type              -    Element Type
//    -----------------------------------------------------------------------------
//       _bstr_tSafeVector           -    BSTR (uses _bstr_t)
//       longSafeVector              -    long
//       shortSafeVector             -    short
//       byteSafeVector              -    byte 
//       boolSafeVector              -    bool
//       CWbemClassObjectSafeVector  -    IWbemClassObject (uses CWbemClassObject)
//
//  Copyright (c)1997 - 1999 Microsoft Corporation, All Rights Reserved
//------------------------------------------------------------------------------------

#if !defined(__T_SafeVector_H)
#define      __T_SafeVector_H
#pragma once

#pragma warning( disable : 4786) // identifier was truncated to 'number' characters in the debug information
#pragma warning( disable : 4503) // decorated name length exceeded, name was truncated


typedef std::vector<_bstr_t>            _bstr_tVec;
typedef std::vector<long>               longVec;
typedef std::vector<short>              shortVec;
typedef std::vector<unsigned char>      byteVec;
typedef std::vector<bool>               boolVec;

#if !defined(NO_WBEM)
typedef std::vector<CWbemClassObject>   coVec;
#endif



template<typename TNContainer,typename TNDataType>
class T_SAExtractScaler
{
    public:
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 TNDataType * pWalk = reinterpret_cast<TNDataType *>(pData);
			 
			 for(;l < (u+1);l++,pWalk++)
			 {
				 _cont.push_back( *pWalk);
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 typename TNContainer::iterator walk,
			 typename TNContainer::iterator finish
			 )
		 {
			 TNDataType * pWalk = reinterpret_cast<TNDataType *>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 *pWalk = *walk;
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 typename TNContainer::iterator first,
			 typename TNContainer::iterator item,
			 typename TNContainer::iterator last
			 )
		 {
			 _bstr_t sRet;
			 
			 try
			 {
				 _variant_t v;
				 
				 v = v.operator=(TNDataType(*item));
				 
				 v.ChangeType(VT_BSTR);
				 
				 sRet = (_bstr_t) v;
				 
				 if( (item+1)!=last )
				 {
					 sRet += ", ";
				 }
			 }
			 catch(_com_error&)
			 {
				 sRet = "Not supported";
			 }
			 
			 return sRet;
		 }
};





template<typename TNContainer>
class T_Extract_bstr_t
{
    public:
		 T_Extract_bstr_t()
		 {
		 }
		 
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 BSTR * pWalk = reinterpret_cast<BSTR*>(pData);
			 
			 for(;l < (u+1);l++,pWalk++)
			 {
				 _cont.push_back( _bstr_t(*pWalk,true) );
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 typename TNContainer::iterator walk,
			 typename TNContainer::iterator finish
			 )
		 {
			 BSTR * pWalk = reinterpret_cast<BSTR*>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 *pWalk = (*walk).copy();
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 typename TNContainer::iterator first,
			 typename TNContainer::iterator item,
			 typename TNContainer::iterator last
			 )
		 {
			 _bstr_t sRet;
			 
			 sRet += "\"";
			 sRet += (*item);
			 sRet += "\"";
			 
			 if( (item+1)!=last )
			 {
				 sRet += ", ";
			 }
			 
			 return sRet;
		 }
		 
};



#if !defined(NO_WBEM)

template<typename TNContainer>
class T_Extract_IUnknown
{
    public:
		 T_Extract_IUnknown()
		 {
		 }
		 
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 IUnknown ** pWalk = reinterpret_cast<IUnknown **>(pData);
			 
			 for(;l< (u+1);l++,pWalk++)
			 {
				 _cont.push_back( CWbemClassObject((IWbemClassObject*)*pWalk) );
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 TNContainer::iterator walk,
			 TNContainer::iterator finish
			 )
		 {
			 IUnknown ** pWalk = reinterpret_cast<IUnknown **>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 (*walk)->AddRef();
				 *pWalk = (*walk);
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 TNContainer::iterator   first,    
			 TNContainer::iterator   item,
			 TNContainer::iterator   last
			 )
		 {
			 _bstr_t sRet;
			 
			 try
			 {
				 _variant_t v( long(item -first) );
				 v.ChangeType(VT_BSTR);
				 _variant_t v2( long(last-first-1) );
				 v2.ChangeType(VT_BSTR);
				 
				 sRet += "Object [";
				 sRet += (_bstr_t)v;
				 sRet += " of ";
				 sRet += (_bstr_t)v2;
				 sRet += "]\n";
				 
				 sRet += (*item).GetObjectText();
				 
				 if( (item+1) != last )
				 {
					 sRet += "\n";
				 }
			 }
			 catch(_com_error&)
			 {
				 sRet = "Not supported";
			 }
			 
			 return sRet;
		 }
		 
};

#endif


typedef T_SAExtractScaler<longVec,long>             __exptExtractlong;
typedef T_SAExtractScaler<shortVec,short>           __exptExtractshort;
typedef T_SAExtractScaler<byteVec,unsigned char>    __exptExtractbyte;
typedef T_SAExtractScaler<boolVec,bool>             __exptExtractbool;
typedef T_Extract_bstr_t<_bstr_tVec>                __exptExtract_bstr_t;

#if !defined(NO_WBEM)
typedef T_Extract_IUnknown<coVec>                   __exptExtractco;
#endif


template<typename TNContainer,typename TNExtractor>
class T_SafeArrayImp
{
    public:
		 void ConstructContainerFromSafeArray
			 (
			 TNExtractor&  _extract,
			 TNContainer& _cont,
			 SAFEARRAY * _pSA
			 )
		 {
			 long l = 0;
			 long u = 0;
			 
			 HRESULT hr;
			 void * pData;
			 
			 hr = SafeArrayGetLBound(_pSA,1,&l);
			 hr = SafeArrayGetUBound(_pSA,1,&u);
			 
			 hr = SafeArrayAccessData(_pSA,&pData);
			 
			 if(hr == S_OK)
			 {
				 _extract.SetToContainer(_cont,pData,l,u);
				 
				 SafeArrayUnaccessData(_pSA);
			 }
		 }
		 
		 SAFEARRAY * ConstructSafeArrayFromConatiner
			 (
			 TNExtractor&            _extract,
			 VARTYPE                 _vt,
			 TNContainer&            _cont,
			 typename TNContainer::iterator   start,
			 typename TNContainer::iterator   finish
			 )
		 {
			 HRESULT         hr   = S_OK;
			 SAFEARRAY *     pRet = NULL;
			 SAFEARRAYBOUND  rgsabound[1];
			 void * pData;
			 
			 rgsabound[0].lLbound    = 0;
			 rgsabound[0].cElements  = _cont.size();
			 
			 pRet = SafeArrayCreate(_vt,1,rgsabound);
			 
			 if(pRet)
			 {
				 hr = SafeArrayAccessData(pRet,&pData);
				 
				 if(hr == S_OK)
				 {
					 _extract.GetFromContainer(_cont,pData,start,finish);
					 
					 SafeArrayUnaccessData(pRet);
				 }
			 }
			 
			 return pRet;
		 }
};

///////////////////////////////////////////////////////////////////////////
// T_SafeVector2
//
// Derived from TNContainer which should be a type of STL vector.
// Provides for the conversion between vector and SafeArray.
// 

template
<
VARTYPE TNVariant,
typename TNDataType,
typename TNContainer = std::vector<TNDataType>,
typename TNExtractor = T_SAExtractScaler<TNContainer,TNDataType>
>
class T_SafeVector2 : public TNContainer 
{
    private:
		 T_SafeArrayImp<TNContainer,TNExtractor> m_Array;
    protected:
    public:
		 
		 T_SafeVector2()
		 {
		 }
		 
		 // copy constructor
		 T_SafeVector2(const TNContainer& _copy) : TNContainer(_copy)
		 {
		 }
		 
		 
		 // Construct vector from array variant, extracts elements
		 T_SafeVector2(_variant_t& _ValueArray)
		 {
			 if(_ValueArray.vt & VT_ARRAY)
			 {
				 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_ValueArray.parray);
			 }
		 }
		 
		 // Construct vector from SAFEARRAY, extracts elements
		 T_SafeVector2(SAFEARRAY * _pArray)
		 {
			 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_pArray);
		 }
		 
		 // assign vector from array variant, extracts elements
		 T_SafeVector2& operator=(_variant_t& _ValueArray)
		 {
			 clear();
			 
			 if(_ValueArray.vt & VT_ARRAY)
			 {
				 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_ValueArray.parray);
			 }
			 
			 return *this;
		 }
		 
		 // assign vector from SAFEARRAY, extracts elements
		 T_SafeVector2& operator=(SAFEARRAY * _pArray)
		 {
			 clear();
			 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_pArray);
			 return *this;
		 }
		 
		 // assign vector from another vector, copies elements
		 T_SafeVector2& operator=(const TNContainer& _copy)
		 {
			 TNContainer::operator=(_copy);
			 return *this;
		 }
		 
		 ~T_SafeVector2()
		 {
		 }
		 
		 // create SafeArray from a portion of the vector elements and return a SAFEARRAY*
		 SAFEARRAY *  GetSafeArray(typename TNContainer::iterator start, typename TNContainer::iterator finish)
		 {
			 return m_Array.ConstructSafeArrayFromConatiner(TNExtractor(),TNVariant,*this,start,finish);
		 }
		 
		 // create SafeArray from the vector elements and return a SAFEARRAY*
       SAFEARRAY * GetSafeArray()
		 {
			 return GetSafeArray(begin(),end());
		 }
		 
       // create SafeArray from a portion of the vector elements and return as an array variant
       _variant_t GetVariant(typename TNContainer::iterator start, typename TNContainer::iterator finish)
		 {
			 _variant_t vRet;
			 
			 vRet.vt        = TNVariant|VT_ARRAY;
			 vRet.parray    = GetSafeArray(start,finish);
			 
			 return vRet;
		 }
		 
       // create SafeArray from the vector elements and return as an array variant
       _variant_t GetVariant()
		 {
			 return GetVariant(begin(),end());
		 }
		 
		 _bstr_t FormatDebugOutput()
		 {
			 _bstr_t sOutput;
			 
			 for(iterator walk = begin();walk != end();walk++)
			 {
				 sOutput += TNExtractor().FormatDebugOutput(begin(),walk,end());
			 }
			 
			 return sOutput;
		 }
};



typedef T_SafeVector2
<
VT_BSTR,
_bstr_t,
_bstr_tVec,
T_Extract_bstr_t<_bstr_tVec>
>  
_bstr_tSafeVector;


typedef T_SafeVector2<VT_I4,long>           longSafeVector;
typedef T_SafeVector2<VT_I2,short>          shortSafeVector;
typedef T_SafeVector2<VT_UI1,unsigned char> byteSafeVector;
typedef T_SafeVector2<VT_BOOL,bool>         boolSafeVector;

#if !defined(NO_WBEM)
typedef T_SafeVector2
<
VT_UNKNOWN,
CWbemClassObject,
std::vector<CWbemClassObject>,
T_Extract_IUnknown<std::vector<CWbemClassObject> >
> 
CWbemClassObjectSafeVector;
#endif


#endif // __T_SafeVector_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) ((src) ? UStrCpy(trg,src,DIM(trg)) : trg[0] = 0)

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, s1, -1, s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, s1, -1, (char const *) s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, (char const *) s1, -1, s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, (char const *) s1, -1, (char const *) s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, s1, len, (char const *) s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, (char const *) s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, (char const *) s1, len, (char const *) s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, -1, s2, -1 ) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, -1, (char const *) s2, -1 ) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (char const *) s1, -1, s2, -1 ) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (char const *) s1, -1, (char const *) s2, -1 ) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, len, (char const *) s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (char const *) s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (char const *) s1, len, (char const *) s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return (char) tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return (UCHAR) tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return (char) toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return (UCHAR) toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringW(LOCALE_SYSTEM_DEFAULT, 0, s1, -1, s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringW(LOCALE_SYSTEM_DEFAULT, 0, s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
    if (s1 && s2)
    {
        return CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, -1, s2, -1) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
    if (s1 && s2)
    {
        return CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s1, len, s2, len) - 2;
    }
    else
    {
        return s1 ? 1 : (s2 ? -1 : 0);
    }
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return _wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return _wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\mcsdmmsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsDomMsg.rc
//
#define IDR_MESSAGE_TABLE               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\include\verifyconfiguration.h ===
#pragma once


//-----------------------------------------------------------------------------
// IsCallerDelegatable Function
//
// Synopsis
// If an intra-forest move operation is being performed then verify that the
// calling user's account has not been marked as sensitive and therefore
// cannot be delegated. As the move operation is performed on the domain
// controller which has the RID master role in the source domain it is
// necessary to delegate the user's security context.
//
// Arguments
// bDelegatable - this out parameter is set to true if the account is
//                delegatable otherwise it is set to false
//
// Return Value
// The return value is a Win32 error code. ERROR_SUCCESS is returned if
// successful.
//-----------------------------------------------------------------------------

HRESULT __stdcall IsCallerDelegatable(bool& bDelegatable);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\common\mcsdmres\mcsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McDomRes.rc
//
#define DCTVS_Options_SourceDomain      1
#define DCTVS_Options_TargetDomain      2
#define DCTVS_Options_NoChange          3
#define DCTVS_Options_LogLevel          4
#define DCTVS_Options_LogToTemp         5
#define DCTVS_Options_Logfile           6
#define DCTVS_Options_Credentials_Server 10
#define DCTVS_Options_ResultFile        12
#define DCTVS_Options_DeleteFileAfterLoad 13
#define DCTVS_Options_RemoveAgentOnCompletion 14
#define DCTVS_Options_SourceDomainSid   15
#define DCTVS_Options_TargetDomainSid   16
#define DCTVS_Options_LocalProcessingOnly 17
#define DCTVS_ConfigurationFile         18
#define DCTVS_InstallToServer           19
#define DCTVS_Dispatcher_ResultPath     20
#define DCTVS_StatusObject              21
#define DCTVS_Options_UniqueNumberForResultsFile 22
#define DCTVS_Options_MaxThreads        23
#define DCTVS_Options_DispatchLog       24
#define DCTVS_GatherInformation_UserRights 25
#define DCTVS_GatherInformation_ComputerPasswordAge 26
#define DCTVS_Security_ReportAccountReferences 27
#define DCTVS_Security_GatherInformation 28
#define DCTVS_Security_TranslationMode  29
#define DCTVS_Security_BuildCacheFile   30
#define DCTVS_Security_TranslateFiles   31
#define DCTVS_Security_TranslateShares  32
#define DCTVS_Security_TranslateUserRights 33
#define DCTVS_Security_TranslateMailboxes 34
#define DCTVS_Security_TranslateContainers 35
#define DCTVS_Security_TranslateLocalGroups 36
#define DCTVS_Security_TranslatePrinters 37
#define DCTVS_Security_TranslateUserProfiles 38
#define DCTVS_Security_MapiProfile      39
#define DCTVS_Accounts_InputFile        40
#define DCTVS_Accounts_WildcardSpec     41
#define DCTVS_Accounts_WildcardSpec_Computer 42
#define DCTVS_Accounts_NumItems         43
#define DCTVS_AccountOptions_CopyUsers  44
#define DCTVS_AccountOptions_CopyLocalGroups 45
#define DCTVS_AccountOptions_CopyGlobalGroups 46
#define DCTVS_AccountOptions_CopyComputers 47
#define DCTVS_AccountOptions_Prefix     48
#define DCTVS_AccountOptions_AddToGroup 49
#define DCTVS_AccountOptions_AddToGroupOnSourceDomain 50
#define DCTVS_AccountOptions_DisableCopiedAccounts 51
#define DCTVS_AccountOptions_DisableSourceAccounts 52
#define DCTVS_AccountOptions_CopyPasswords 53
#define DCTVS_AccountOptions_GenerateStrongPasswords 54
#define DCTVS_AccountOptions_PasswordFile 55
#define DCTVS_AccountOptions_UpdateUserRights 56
#define DCTVS_AccountOptions_ReplaceExistingAccounts 57
#define DCTVS_AccountOptions_ReplaceExistingGroupMembers 58
#define DCTVS_AccountOptions_RemoveExistingUserRights 59
#define DCTVS_AccountOptions_CSVResultFile 60
#define DCTVS_AccountOptions_RenameOnly 61
#define DCTVS_AccountOptions_AddSidHistory 62
#define DCTVS_AccountOptions_TranslateRoamingProfiles 63
#define DCTVS_LocalServer_RenameTo      64
#define DCTVS_LocalServer_ChangeDomain  65
#define DCTVS_LocalServer_Reboot        66
#define DCTVS_LocalServer_RebootDelay   67
#define DCTVS_LocalServer_MigrateOnly   68
#define DCTVS_Servers_NumItems          69
#define DCTVS_JobStatus                 70
#define DCTVS_CurrentPath               71
#define DCTVS_Server_Index              72
#define DCTVS_Options_DontBeginNewLog   73
#define DCTVS_CurrentOperation          141
#define DCTVS_Results_ErrorLevel        142
#define DCTVS_Stats_Paths               144
#define DCTVS_Stats_Servers             145
#define DCTVS_Stats_Files_Examined      146
#define DCTVS_Stats_Files_Changed       147
#define DCTVS_Stats_Files_Skipped       148
#define DCTVS_Stats_Files_CacheHits     149
#define DCTVS_Stats_Directories_Examined 150
#define DCTVS_Stats_Directories_Changed 151
#define DCTVS_Stats_Directories_Skipped 152
#define DCTVS_Stats_Directories_CacheHits 153
#define DCTVS_Stats_Shares_Examined     154
#define DCTVS_Stats_Shares_Changed      155
#define DCTVS_Stats_Shares_Skipped      156
#define DCTVS_Stats_Shares_CacheHits    157
#define DCTVS_Stats_Members_Examined    158
#define DCTVS_Stats_Members_Changed     159
#define DCTVS_Stats_Members_Skipped     160
#define DCTVS_Stats_Members_CacheHits   161
#define DCTVS_Stats_UserRights_Examined 162
#define DCTVS_Stats_UserRights_Changed  163
#define DCTVS_Stats_UserRights_Skipped  164
#define DCTVS_Stats_UserRights_CacheHits 165
#define DCTVS_Stats_Mailboxes_Examined  166
#define DCTVS_Stats_Mailboxes_Changed   167
#define DCTVS_Stats_Mailboxes_Skipped   168
#define DCTVS_Stats_Mailboxes_CacheHits 169
#define DCTVS_Stats_Containers_Examined 170
#define DCTVS_Stats_Containers_Changed  171
#define DCTVS_Stats_Containers_Skipped  172
#define DCTVS_Stats_Containers_CacheHits 173
#define DCTVS_Stats_Owners_Examined     174
#define DCTVS_Stats_Groups_Examined     175
#define DCTVS_Stats_DACL_Examined       176
#define DCTVS_Stats_SACL_Examined       177
#define DCTVS_Stats_DACE_Examined       178
#define DCTVS_Stats_SACE_Examined       179
#define DCTVS_Stats_Owners_Changed      180
#define DCTVS_Stats_Groups_Changed      181
#define DCTVS_Stats_DACL_Changed        182
#define DCTVS_Stats_SACL_Changed        183
#define DCTVS_Stats_DACE_Changed        184
#define DCTVS_Stats_SACE_Changed        185
#define DCTVS_Stats_Owners_NoTarget     186
#define DCTVS_Stats_Groups_NoTarget     187
#define DCTVS_Stats_DACE_NoTarget       188
#define DCTVS_Stats_SACE_NoTarget       189
#define DCTVS_Stats_Owners_NotSelected  190
#define DCTVS_Stats_Groups_NotSelected  191
#define DCTVS_Stats_DACE_NotSelected    192
#define DCTVS_Stats_SACE_NotSelected    193
#define DCTVS_Stats_Owners_Unknown      194
#define DCTVS_Stats_Groups_Unknown      195
#define DCTVS_Stats_DACE_Unknown        196
#define DCTVS_Stats_SACE_Unknown        197
#define DCTVS_Stats_Accounts_NumUsers   198
#define DCTVS_Stats_Accounts_NumGlobalGroups 199
#define DCTVS_Stats_Accounts_NumLocalGroups 200
#define DCTVS_Stats_Accounts_NumOther   201
#define DCTVS_Stats_Users_Examined      202
#define DCTVS_Stats_Users_Created       203
#define DCTVS_Stats_Users_Replaced      204
#define DCTVS_Stats_Users_Warnings      205
#define DCTVS_Stats_Users_Errors        206
#define DCTVS_Stats_GlobalGroups_Examined 207
#define DCTVS_Stats_GlobalGroups_Created 208
#define DCTVS_Stats_GlobalGroups_Replaced 209
#define DCTVS_Stats_GlobalGroups_Warnings 210
#define DCTVS_Stats_GlobalGroups_Errors 211
#define DCTVS_Stats_LocalGroups_Examined 212
#define DCTVS_Stats_LocalGroups_Created 213
#define DCTVS_Stats_LocalGroups_Replaced 214
#define DCTVS_Stats_LocalGroups_Warnings 215
#define DCTVS_Stats_LocalGroups_Errors  216
#define DCTVS_Stats_Computers_Examined  217
#define DCTVS_Stats_Computers_Created   218
#define DCTVS_Stats_Computers_Replaced  219
#define DCTVS_Stats_Computers_Warnings  220
#define DCTVS_Stats_Computers_Errors    221
#define DCTVS_AgentService_DebugMode    222
#define IDS_DISPLAY_NAME                223
#define IDS_SERVICE_NAME                224
#define IDS_LOCALSERVICE_PATH           225
#define IDS_SERVICE_PATH                226
#define IDS_AGENT_EXE                   227
#define IDS_SERVICE_EXE                 228
#define IDS_WORKER_DLL                  229
#define IDS_VARSET_DLL                  230
#define IDS_DATA_FILE                   231
#define IDS_EVENTSOURCE                 232
#define IDS_APPNAME                     233
#define IDS_LOG_FILENAME                234
#define DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha 235
#define DCTVS_AccountOptions_PasswordPolicy_MinUpper 236
#define DCTVS_AccountOptions_PasswordPolicy_MinLower 237
#define DCTVS_AccountOptions_PasswordPolicy_MinSpecial 238
#define DCTVS_AccountOptions_PasswordPolicy_MinDigit 239
#define IDS_DOMAIN_ADMIN_REGKEY         240
#define IDS_AgentResultFileFmt          241
#define IDS_ACCT_REPL_OPERATION_TEXT    242
#define IDS_FST_OPERATION_TEXT          243
#define IDS_EST_OPERATION_TEXT          244
#define IDS_DCT_Status_Completed        245
#define DCTVSFmt_Accounts_D             246
#define DCTVSFmt_Accounts_TargetName_D  247
#define DCTVSFmt_Accounts_Type_D        248
#define IDS_LGST_OPERATION_TEXT         249
#define IDS_URST_OPERATION_TEXT         250
#define DCTVSFmt_Servers_D              251
#define IDS_RESULT_SHARE_NAME           252
#define IDS_RESULT_SHARE_REMARK         253
#define IDS_CACHE_FILE_NAME             254
#define IDS_DCTVSFmt_MigrateServers_D   255
#define IDS_DCTVSFmt_MigrateServers_RenameTo_D 256
#define IDS_DCTVSFmt_MigrateServers_ChangeDomain_D 257
#define IDS_DCTVSFmt_MigrateServers_Reboot_D 258
#define IDS_DCTVSFmt_MigrateServers_RebootDelay_D 259
#define IDS_DCTVSFmt_Servers_RenameTo_D 260
#define IDS_DCTVSFmt_Servers_ChangeDomain_D 261
#define IDS_DCTVSFmt_Servers_Reboot_D   262
#define IDS_DCTVSFmt_Servers_RebootDelay_D 263
#define IDS_DCTVSFmt_Servers_MigrateOnly_D 264
#define DCTVS_Options_CreateTempCredentials 265
#define DCTVS_Options_OuPath            266
#define IDS_DCTVSFmt_PlugIn_RegisterFiles_D 267
#define IDS_YES                         268
#define IDS_DEBUG_SWITCH                269
#define IDS_HKLM_DomainAdmin_Key        270
#define IDS_AGENT_DIRECTORY             271
#define IDS_DCTVS_Fmt_PlugIn_D          272
#define DCTVS_Options                   273
#define DCTVS_Accounts                  274
#define IDS_Replace                     275
#define IDS_MSG_ComputerAccountNotWorkstation 276
#define IDS_DCT_Status_NotStarted       277
#define IDS_DCT_Status_InProgress       278
#define IDS_DCT_Status_Aborting         279
#define IDS_DCT_Status_Aborted          280
#define IDS_DCT_Status_Unknown          281
#define DCTVS_Stats                     282
#define IDS_DCT_NoStatsAvailable        283
#define IDS_DCTVSFmt_Job_D              284
#define IDS_DCTVSFmt_JobStatus_D        285
#define IDS_DCTVSFmt_Job_StartTime_D    286
#define IDS_DCTVSFmt_Job_EndTime_D      287
#define IDS_DCTVSFmt_PlugIn_D           288
#define IDS_DCTVSFmt_PlugIn_Interface_D 289
#define DCTVS_PlugIn_Interface_Count    290
#define DCTVS_CopiedAccount_SourceName  291
#define DCTVS_CopiedAccount_SourcePath  292
#define DCTVS_CopiedAccount_SourceRID   293
#define DCTVS_CopiedAccount_SourceSam   294
#define DCTVS_CopiedAccount_SourceProfile 295
#define DCTVS_CopiedAccount_Status      296
#define DCTVS_CopiedAccount_TargetName  297
#define DCTVS_CopiedAccount_TargetPath  298
#define DCTVS_CopiedAccount_TargetProfile 299
#define DCTVS_CopiedAccount_TargetRID   300
#define DCTVS_CopiedAccount_TargetSam   301
#define DCTVS_CopiedAccount_Type        302
#define IDS_Special                     303
#define IDS_All                         304
#define IDS_AccountMigration            305
#define IDS_WriteChanges_No             306
#define IDS_CopyUsers_Yes               307
#define IDS_CopyUsers_No                308
#define IDS_CopyGlobalGroups_Yes        309
#define IDS_CopyGlobalGroups_No         310
#define IDS_CopyLocalGroups_Yes         311
#define IDS_CopyLocalGroups_No          312
#define IDS_CopyComputers_Yes           313
#define IDS_CopyComputers_No            314
#define IDS_ReplaceExisting_Yes         315
#define IDS_DisableAll_Yes              316
#define IDS_DisableSpecial_Yes          317
#define IDS_DisableSourceAccounts_Yes   318
#define IDS_StrongPwd_All               319
#define IDS_StrongPwd_Special           320
#define IDS_PasswordFile                321
#define IDS_AddToGroup                  322
#define IDS_AddToGroupOnTargetDescription_S 323
#define IDS_AddToGroupOnSourceDescription_S 324
#define IDS_NotAllowedOnDomainController 325
#define IDS_CannotTrustSelf             326
#define IDS_CannotGetDCName             327
#define IDS_No                          328
#define IDS_ScanningExchangeDirectory   329
#define IDS_Examining                   331
#define IDS_Add                         332
#define IDS_Remove                      333
#define DCTVS_Options_DispatchCSV       334
#define DCTVS_SUB_ERROR                 335
#define IDS_UNKNOWN_TYPE                336
#define DCTVS_Options_SourceServer      337
#define DCTVS_Options_TargetServer      338
#define DCTVS_AccountOptions_Suffix     339
#define DCTVS_AccountOptions_CopyCompters 340
#define DCTVS_AccountOptions_CopyOUs    341
#define DCTVS_AccountOptions_CopyContainerContents 342
#define DB_ActionID                     343
#define DB_Time                         344
#define DB_SourceDomain                 345
#define DB_TargetDomain                 346
#define DB_SourceAdsPath                347
#define DB_TargetAdsPath                348
#define DB_SourceSamName                349
#define DB_TargetSamName                350
#define DB_Type                         351
#define DB_GUID                         352
#define DB_status                       353
#define DCTVS_CopiedAccount_GUID        354
#define IDS_CLSET_MEMBER_NOT_INCLUDED   355
#define IDS_CLSET_GROUP_NOT_INCLUDED    356
#define DCTVS_Options_AppendToLogs      357
#define DCTVS_Options_Undo              358
#define DCTVS_Options_GlobalOperationMask 359
#define DCTVS_Accounts_D_OperationMask  360
#define DCTVS_ActionID_D                361
#define DCTVS_ActionID_Servers_SD       362
#define DCTVS_ActionID_Servers_Status_SD 363
#define DCTVS_AREXT_NUMITEM             364
#define DCTVS_AREXTENSIONS_D            365
#define DCTVS_Security_TranslateMigratedObjects 366
#define DCTVS_AccountOptions_ExpireSourceAccounts 367
#define DCTVS_AccountOptions_SidHistoryCredentials_Domain 368
#define DCTVS_AccountOptions_SidHistoryCredentials_UserName 369
#define DCTVS_AccountOptions_SidHistoryCredentials_Password 370
#define DCTVS_AccountOptions_CopyMemberOf 371
#define DCTVS_DBManager                 372
#define DCTVS_Servers                   373
#define DCTVS_Reports_Generate          374
#define DCTVS_Reports_Directory         375
#define DCTVS_Reports_MigratedAccounts  376
#define DCTVS_Reports_MigratedComputers 377
#define DCTVS_Reports_ExpiredComputers  378
#define DCTVS_Reports_AccountReferences 379
#define DCTVS_Reports_NameConflicts     380
#define IDS_REGKEY_REPORTS              381
#define IDS_REGST_OPERATION_TEXT        382
#define DCTVS_Security_TranslateRegistry 383
#define DCTVS_AccountOptions_IncludeMigratedAccts 384
#define DCTVS_GatherInformation         385
#define DCTVS_Options_Prefix            386
#define DCTVS_Options_Suffix            387
#define DCTVS_AccountOptions_PasswordPolicy_MinLength 388
#define DCTVS_Options_SourceDomainDns   389
#define DCTVS_Options_TargetDomainDns   390
#define IDS_REPORT_MigratedAccounts     391
#define IDS_REPORT_MigratedComputers    392
#define IDS_REPORT_ExpiredComputers     393
#define IDS_REPORT_AccountReferences    394
#define IDS_REPORT_NameConflicts        395
#define IDS_TABLE_FIELD_SourceDomain    396
#define IDS_TABLE_FIELD_TargetDomain    397
#define IDS_TABLE_FIELD_Type            398
#define IDS_TABLE_FIELD_SourceAdsPath   399
#define IDS_TABLE_FIELD_TargetAdsPath   400
#define IDS_TABLE_FIELD_Status          401
#define IDS_TABLE_FIELD_Time            402
#define IDS_TABLE_FIELD_DomainName      403
#define IDS_TABLE_FIELD_CompName        404
#define IDS_TABLE_FIELD_Description     405
#define IDS_TABLE_FIELD_PwdAge          406
#define IDS_TABLE_FIELD_Account         407
#define IDS_TABLE_FIELD_Server          408
#define IDS_TABLE_FIELD_RefCount        409
#define IDS_TABLE_FIELD_RefType         410
#define IDS_TABLE_FIELD_SourceType      411
#define IDS_TABLE_FIELD_TargetType      412
#define IDS_TABLE_FIELD_SourceDesc      413
#define IDS_TABLE_FIELD_TargetDesc      414
#define IDS_TABLE_FIELD_SrcFullName     415
#define IDS_TABLE_FIELD_TgtFullName     416
#define IDS_NAMECONFLICTS               417
#define IDS_DISPATCHING                 418
#define DCTVS_Options_Wizard            419
#define DCTVS_Reports_MigratedAccounts_TimeGenerated 421
#define DCTVS_Reports_MigratedComputers_TimeGenerated 422
#define DCTVS_Reports_ExpiredComputers_TimeGenerated 423
#define DCTVS_Reports_AccountReferences_TimeGenerated 424
#define DCTVS_Reports_NameConflicts_TimeGenerated 425
#define DCTVS_Options_GuiOnlyRebootSaver 426
#define DCTVS_CopiedAccount_DoNotUpdatePassword 427
#define IDS_TEMP_FILE_1                 428
#define IDS_TEMP_FILE_2                 429
#define IDS_HKLM_WINDOWS_NT             430
#define IDS_CurrentVersion              431
#define IDS_CSDVersion                  432
#define IDS_HKLM_MICROSOFT              433
#define IDS_START_FAILED                434
#define IDS_UNSOUPPORTED_OS             435
#define IDS_AGENT_RUNNING               436
#define DCTVS_Options_DeleteJobFile     437
#define IDS_BUILDING_ACCOUNT_LIST       438
#define IDS_EXPANDING_MEMBERSHIP        439
#define IDS_EXPANDING_CONTAINERS        440
#define IDS_MERGING_EXPANDED_LISTS      441
#define IDS_CREATING_S                  442
#define IDS_MAPPING_PROPS_S             443
#define IDS_UPDATING_PROPS_S            444
#define IDS_EVENT_SOURCE                445
#define IDS_RUNNING_EXTS_S              446
#define IDS_TRANSLATE_ROAMING_PROFILE_S 447
#define IDS_ADDING_SIDHISTORY_S         448
#define IDS_UPDATING_GROUP_MEMBERSHIPS_S 449
#define IDS_EXPANDING_ADDING_SS         450
#define IDS_EXPANDING_IGNORING_SS       451
#define IDS_EXPANDING_GROUP_ADDING_SS   452
#define IDS_DELETING_S                  453
#define DCTVS_Options_IsIntraforest     454
#define IDS_EXTRACTING_COMP_PWD_AGE     455
#define IDS_Gathering_SvcAcct           456
#define DCTVS_Results_LogFile           457
#define IDS_REGKEY_PROFILE_EXTENSIONS   458
#define IDS_COM_DisTarget               459
#define IDS_COM_DisPid                  460
#define IDS_COM_DisPidVer               461
#define IDS_COM_AcctReplName            462
#define IDS_COM_AcctReplPid             463
#define IDS_COM_AcctReplPidVer          464
#define IDS_COM_ChgDomName              465
#define IDS_COM_ChgDomPidVer            466
#define IDS_COM_ChgDomPid               467
#define IDS_COM_ChkName                 468
#define IDS_COM_ChkPid                  469
#define IDS_COM_ChkPidVer               470
#define IDS_COM_PIInfoName              471
#define IDS_COM_PIInfoPid               472
#define IDS_COM_PIInfoPidVer            473
#define IDS_COM_CompAgeName             474
#define IDS_COM_CompAgePid              475
#define IDS_COM_CompAgePidVer           476
#define IDS_COM_RebootName              477
#define IDS_COM_RebootPid               478
#define IDS_COM_RebootPidVer            479
#define IDS_COM_RenameName              480
#define IDS_COM_RenamePid               481
#define IDS_COM_RenamePidVer            482
#define IDS_COM_SecTransName            483
#define IDS_COM_SecTransPid             484
#define IDS_COM_SecTransPidVer          485
#define IDS_COM_StatusObjName           486
#define IDS_COM_StatusObjPid            487
#define IDS_COM_StatusObjPidVer         488
#define IDS_COM_URName                  489
#define IDS_COM_URPid                   490
#define IDS_COM_URPidVer                491
#define DB_SourceRid                    492
#define DB_TargetRid                    493
#define IDS_DOM_LOC_GRP_COMMENT         494
#define DCTVS_CopiedAccount_Operations  495
#define IDS_Reporting                   496
#define IDS_ReportsMMCNode              497
#define IDS_ActiveDirectoryMigrationTool 503
#define DCTVS_Stats_Generic_Errors      504
#define DCTVS_Stats_Generic_Warnings    505
#define DCTVS_Stats_Generic_Examined    506
#define DCTVS_Stats_Generic_Created     507
#define DCTVS_Stats_Generic_Replaced    508
#define IDS_Unspecified_Failure         509
#define IDS_RegKeyRebootMessage         510
#define IDS_UNRESOLVED                  511
#define IDS_AGENT_INTEL_DIR             512
#define IDS_AGENT_ALPHA_DIR             513
#define IDS_STReference_File            514
#define IDS_STReference_Dir             515
#define IDS_STReference_Share           516
#define IDS_STReference_Mailbox         517
#define IDS_STReference_Container       518
#define IDS_STReference_Member          519
#define IDS_STReference_UserRight       520
#define IDS_STReference_RegKey          521
#define IDS_STReference_Printer         522
#define DCTVS_Options_SourceServerOverride 523
#define DCTVS_Options_TargetServerOverride 524
#define DCTVS_Options_AllowDuplicateUPNs 525
#define DCT_MSG_CHANGE_GROUP_TYPE_S     526
#define DCT_MSG_RECORD_REMOVE_MEMBER_S  527
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_S 528
#define DCT_MSG_UPDATE_MEMBER_LIST_S    529
#define DCT_MSG_RESET_GROUP_MEMBERS_S   530
#define DCT_MSG_RESET_MEMBERSHIP_S      531
#define DCT_MSG_MOVING_S                532
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_SS 533
#define DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS 534
#define DCT_MSG_RECORD_REMOVE_MEMBER_SS 535
#define DCT_MSG_RESET_GROUP_MEMBERS_SS  536
#define IDS_HiddenShare                 537
#define IDS_AgentDirectoryName          538
#define IDS_HiddenShareRemark           539
#define DCTVS_Security_AlternateCacheFile 540
#define IDS_RenamedRecyclerSuffix       541
#define DCTVS_Security                  542
#define DCTVS_CopiedAccount_ExpDate     543
#define DCTVS_CopiedAccount_UserFlags   544
#define DB_ExpDate                      545
#define DB_UserFlags                    546
#define IDS_TRUST_DIRECTION_DISABLED    547
#define IDS_TRUST_DIRECTION_INBOUND     548
#define IDS_TRUST_DIRECTION_OUTBOUND    549
#define IDS_TRUST_DIRECTION_BIDIRECTIONAL 550
#define IDS_TRUST_TYPE_DOWNLEVEL        551
#define IDS_TRUST_TYPE_CHILD            552
#define IDS_EVENTVW_MSG_MONJOBSTAT      553
#define IDS_EVENTVW_MSG_MONERROR        554
#define IDS_EVENTVW_MSG_MONEXIT         555
#define IDS_EVENTVW_MSG_STARTPLUGREG    556
#define IDS_EVENTVW_MSG_FILEREG         557
#define IDS_EVENTVW_MSG_PLUGREGDONE     558
#define IDS_EVENTVW_MSG_JOBDEL          559
#define IDS_EVENTVW_MSG_SETFLAG         560
#define IDS_EVENTVW_MSG_NOSETFLAG       561
#define IDS_EVENTVW_MSG_REMOVEAGENT     562
#define IDS_EVENTVW_MSG_UNREGFILES      563
#define IDS_EVENTVW_MSG_FILEDEL         564
#define IDS_EVENTVW_MSG_REMOVESVC       565
#define IDS_EVENTVW_MSG_NOREMOVEAGENT   566
#define IDS_EVENTVW_MSG_STOPLISTEN      567
#define IDS_EVENTVW_MSG_AGENTSVCINSTALLED 568
#define IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED 569
#define IDS_EVENTVW_MSG_OSVERSION       570
#define IDS_EVENTVW_MSG_REGISTERED      571
#define IDS_EVENTVW_MSG_UNREGISTERED    572
#define IDS_EVENTVW_MSG_INITOLE         573
#define IDS_EVENTVW_MSG_REGCOMPNT       574
#define IDS_EVENTVW_MSG_CREATEAGT       575
#define IDS_EVENTVW_MSG_INITRPC         576
#define IDS_EVENTVW_MSG_LISTENQ         577
#define IDS_EVENTVW_MSG_EXITENTRYP      578
#define IDS_EVENTVW_MSG_AGTEXITQ        579
#define IDS_EVENTVW_MSG_AGTEXITS        580
#define IDS_STOptions_Start             581
#define IDS_STOptions_WriteChng         582
#define IDS_STOptions_Files             583
#define IDS_STOptions_Shares            584
#define IDS_STOptions_LocalGroup        585
#define IDS_STOptions_URights           586
#define IDS_STOptions_Profiles          587
#define IDS_STOptions_RBin              588
#define IDS_STOptions_LogName           589
#define IDS_STOptions_AddMode           590
#define IDS_STOptions_RemoveMode        591
#define IDS_STOptions_ReplaceMode       592
#define IDS_STOptions_Printers          593
#define IDS_TypeUser                    594
#define IDS_TypeGroup                   595
#define IDS_TypeComputer                596
#define IDS_TypeUnknown                 597
#define IDS_DCTVSFmt_Servers_SkipDispatch_D 598
#define DCTVS_AccountOptions_FixMembership 599
#define DCTVSFmt_Accounts_SourceUPN_D   600
#define DCTVS_CopiedAccount_SourceUPN   601
#define IDS_PwdAgeDays                  602
#define DB_SourceDomainSid              603
#define DCTVS_CopiedAccount_SourceDomainSid 604
#define DCTVS_AccountOptions_PasswordDC 605
#define DCTVS_Options_AutoCloseHideDialogs 606
#define IDS_TABLE_FIELD_AccountSid      607
#define IDS_TABLE_NC_SDOMAIN            608
#define IDS_TABLE_NC_TDOMAIN            609
#define IDS_TABLE_AR_MOT_HDR            610
#define IDS_TABLE_AR_NOTMOT_HDR         611
#define DCTVS_AccountOptions_SecurityMapFile 612
#define DCTVS_AccountOptions_SecurityInputMOT 613
#define IDS_UnknownSid                  614
#define DCTVS_AccountOptions_MoveReplacedAccounts 615
#define IDS_USERPROPS                   616
#define IDS_GROUPPROPS                  617
#define IDS_COMPUTERPROPS               618
#define DCTVS_AccountOptions_ExcludedUserProps 619
#define DCTVS_AccountOptions_ExcludedGroupProps 620
#define DCTVS_AccountOptions_ExcludedComputerProps 621
#define DCTVS_AccountOptions_ExcludeProps 622
#define IDS_UPDATING_MGR_PROPS_S        623
#define IDS_TRUST_RELATION_ROOT         624
#define IDS_TRUST_RELATION_PARENT       625
#define IDS_TRUST_RELATION_CHILD        626
#define IDS_TRUST_RELATION_SHORTCUT     627
#define IDS_TRUST_RELATION_EXTERNAL     628
#define IDS_TRUST_RELATION_FOREST       629
#define IDS_TRUST_RELATION_INDIRECT     630
#define IDS_TRUST_RELATION_SELF         631
#define IDS_TRUST_RELATION_MIT          632
#define IDS_TRUST_RELATION_UNKNOWN      634
#define IDS_INVALID_PREFIX_SUFFIX       635
#define IDS_LG_MEMBER_FIXUP_UNDO        636
#define IDS_ADMT_ACCOUNT_DESCRIPTION    637
#define DCTVS_AccountOptions_TgtStateSameAsSrc 638
#define IDS_TABLE_FIELD_SourceRDN       639
#define IDS_TABLE_FIELD_ConflictAtt     640
#define IDS_TABLE_FIELD_TargetCanonicalName 641
#define IDS_TABLE_SAM_CONFLICT_VALUE    642
#define IDS_TABLE_RDN_CONFLICT_VALUE    643
#define IDS_AGENT_NT4_DIR               644
#define DCTVS_CopiedAccount_GroupType   645
#define DCTVS_AccountOptions_ExcludedSystemProps 646
#define IDS_MSVCP60_DLL                 647
#define IDS_DCT_Status_Completed_With_Errors 648
#define DCTVS_AccountOptions_ExcludedInetOrgPersonProps 649
#define IDS_INETORGPERSONPROPS          650
#define DCTVS_Options_AlternativeLogfile	651
#define DCTVS_CacheFile                 652
#define DCTVS_Options_RelativeResultFileName     653
#define DCTVS_Security_ReportAccountReferencesRelativeFileName  654
#define DCTVS_ShutdownStatus  655
#define IDS_DCT_Status_Shutdown  656
#define IDS_DCT_Status_Wait_For_Shutdown_Signal 657
#define IDS_EVENTVW_MSG_CANNOT_STOP_LISTENING  658
#define IDS_EVENTVW_MSG_UNREGISTER_INTERFACE  659
#define IDS_EVENTVW_MSG_CANNOT_UNREGISTER_INTERFACE  660
#define IDS_DCTVSFmt_PlugIn_Interface_GUID_D  661
#define IDS_DCTVSFmt_PlugIn_Interface_File_D  662
#define IDS_EVENTVW_MSG_CANNOT_MONITOR_JOB  663
#define DCTVS_Options_SourceServerOverrideDns 664
#define DCTVS_Options_TargetServerOverrideDns 665
#define DCTVS_Options_SourceServerDns   666
#define DCTVS_Options_SourceServerFlat  667
#define DCTVS_Options_TargetServerDns   668
#define DCTVS_Options_TargetServerFlat  669
#define IDS_DCTVSFmt_Servers_DnsName_D  670
#define DCTVS_Options_SourceDomainFlat  671
#define DCTVS_Options_TargetDomainFlat  672
#define DCTVS_Results_LogFileIsInvalid  673
#define DCTVS_AccountOptions_ExcludedSystemPropsSet 674
#define DCTVS_Options_AllowSwitchingFromReplaceToAddInProfileTranslation 675

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\dbmgr.cpp ===
// DBManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DBManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DBMgr.h"

#include "DBMgr_i.c"
#include "MgeDB.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IManageDB, CIManageDB)
END_OBJECT_MAP()

class CDBManagerApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDBManagerApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CDBManagerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDBManagerApp, CWinApp)
	//{{AFX_MSG_MAP(CDBManagerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDBManagerApp theApp;

BOOL CDBManagerApp::InitInstance()
{
	ATLTRACE(_T("{DBManager.dll}CDBManagerApp::InitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_DBMANAGERLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CDBManagerApp::ExitInstance()
{
	ATLTRACE(_T("{DBManager.dll}CDBManagerApp::ExitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DBMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_ReportingTitle              101
#define IDR_IMANAGEDB                   102
#define IDS_E_UPGRADE_TO_4X             102
#define IDS_E_UPGRADE_TO_TEMPORARY      103
#define IDS_E_UPGRADE_RENAME_ORIGINAL   104
#define IDS_E_UPGRADE_RENAME_UPGRADED   105
#define IDS_E_CANNOT_FIND_DATABASE      106
#define IDS_E_UNABLE_TO_UPDATE_COLUMNS  107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\mgedb.cpp ===
/*---------------------------------------------------------------------------
  File: MgeDB.cpp

  Comments: Implementation of DBManager COM object.
  This is interface that the Domain Migrator uses to communicate to the 
  Database (PROTAR.MDB). This interface allows Domain Migrator to Save and
  later retrieve information/Setting to run the Migration process.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
  
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "mcs.h"
#include "ErrDct.hpp"
#include "DBMgr.h"
#include "MgeDB.h"
#include <share.h>
#include <comdef.h>
#include <lm.h>
#include "UString.hpp"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "HrMsg.h"
#include "StringConversion.h"
#include <GetDcName.h>
#include <iads.h>
#include <adshlp.h>

#import "msado21.tlb" no_namespace implementation_only rename("EOF", "EndOfFile")
#import "msadox.dll" implementation_only exclude("DataTypeEnum")
//#import <msjro.dll> no_namespace implementation_only
#include <msjro.tlh>
#include <msjro.tli>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TErrorDct                    err;

using namespace _com_util;

#define MAX_BUF_LEN 255

#ifndef JET_DATABASELOCKMODE_PAGE
#define JET_DATABASELOCKMODE_PAGE   0
#endif
#ifndef JET_DATABASELOCKMODE_ROW
#define JET_DATABASELOCKMODE_ROW    1
#endif

#ifndef JETDBENGINETYPE_JET4X
#define JETDBENGINETYPE_JET4X 0x05	// from MSJetOleDb.h
#endif

StringLoader gString;
/////////////////////////////////////////////////////////////////////////////
// CIManageDB
TError   dct;
TError&  errCommon = dct;


//----------------------------------------------------------------------------
// Constructor / Destructor
//----------------------------------------------------------------------------


CIManageDB::CIManageDB()
{
}


CIManageDB::~CIManageDB()
{
}


//----------------------------------------------------------------------------
// FinalConstruct
//----------------------------------------------------------------------------

HRESULT CIManageDB::FinalConstruct()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        _bstr_t                   sMissing(L"");
        _bstr_t                   sUser(L"Admin");
        WCHAR                     sConnect[LEN_Path];
        WCHAR                     sDir[LEN_Path];

        // Get the path to the MDB file from the registry
        TRegKey        key;
        DWORD rc = key.Open(sKeyBase);
        if ( !rc ) 
            rc = key.ValueGetStr(L"Directory", sDir, LEN_Path);
        if (rc)
        {
            CString errMsg;
            hr = HRESULT_FROM_WIN32(rc);
            errMsg.Format(IDS_E_CANNOT_FIND_DATABASE, _com_error(hr).ErrorMessage());
            return Error((LPCTSTR)errMsg, GUID_NULL, hr);
        }

        // Now build the connect string.
        //
        // Set page level locking to reduce the probability of exceeding
        // the maximum locks per file limit. ADMT does not require row
        // level locking as there is effectively only one updater.
        //

        _snwprintf(
            sConnect,
            sizeof(sConnect) / sizeof(sConnect[0]),
            L"Provider=Microsoft.Jet.OLEDB.4.0;Jet OLEDB:Database Locking Mode=%d;Data Source=%sprotar.mdb",
            JET_DATABASELOCKMODE_PAGE,
            sDir
        );
        sConnect[sizeof(sConnect) / sizeof(sConnect[0]) - 1] = L'\0';

        CheckError(m_cn.CreateInstance(__uuidof(Connection)));
        m_cn->Open(sConnect, sUser, sMissing, adConnectUnspecified);
        m_vtConn = (IDispatch *) m_cn;

        // if necessary, upgrade database to 4.x

        long lEngineType = m_cn->Properties->Item[_T("Jet OLEDB:Engine Type")]->Value;

        if (lEngineType < JETDBENGINETYPE_JET4X)
        {
            m_cn->Close();

            UpgradeDatabase(sDir);

            m_cn->Open(sConnect, sUser, sMissing, adConnectUnspecified);
        }

        //
        // If necessary, widen columns containing domain and server names in order to support DNS names.
        //
        // This change is required in order to be NetBIOS-less compliant.
        //

        UpdateDomainAndServerColumnWidths(m_cn);

        //
        // Create the Settings2 table if it does not already exist.
        //

        CreateSettings2Table(m_cn);

        reportStruct * prs = NULL;
        _variant_t     var;
        // Migrated accounts report information
        CheckError(m_pQueryMapping.CreateInstance(__uuidof(VarSet)));
        m_pQueryMapping->put(L"MigratedAccounts", L"Select SourceDomain, TargetDomain, Type, SourceAdsPath, TargetAdsPath from MigratedObjects where Type <> 'computer' order by time");
        prs = new reportStruct();
        if (!prs)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        prs->sReportName = GET_BSTR(IDS_REPORT_MigratedAccounts);
        prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_SourceDomain);
        prs->arReportSize[0] = 10;
        prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_TargetDomain);
        prs->arReportSize[1] = 10;
        prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_Type);
        prs->arReportSize[2] = 10;
        prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_SourceAdsPath);
        prs->arReportSize[3] = 35;
        prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_TargetAdsPath);
        prs->arReportSize[4] = 35;
        prs->colsFilled = 5;
        var.vt = VT_BYREF | VT_UI1;
        var.pbVal = (unsigned char *)prs;
        m_pQueryMapping->putObject(L"MigratedAccounts.DispInfo", var);

        // Migrated computers report information
        m_pQueryMapping->put(L"MigratedComputers", L"Select SourceDomain, TargetDomain, Type, SourceAdsPath, TargetAdsPath from MigratedObjects where Type = 'computer' order by time");
        prs = new reportStruct();
        if (!prs)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        prs->sReportName = GET_BSTR(IDS_REPORT_MigratedComputers);
        prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_SourceDomain);
        prs->arReportSize[0] = 10;
        prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_TargetDomain);
        prs->arReportSize[1] = 10;
        prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_Type);
        prs->arReportSize[2] = 10;
        prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_SourceAdsPath);
        prs->arReportSize[3] = 35;
        prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_TargetAdsPath);
        prs->arReportSize[4] = 35;
        prs->colsFilled = 5;
        var.vt = VT_BYREF | VT_UI1;
        var.pbVal = (unsigned char *)prs;
        m_pQueryMapping->putObject(L"MigratedComputers.DispInfo", var);

        // Expired computers report information
        prs = new reportStruct();
        if (!prs)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        prs->sReportName = GET_BSTR(IDS_REPORT_ExpiredComputers);
        prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_Time);
        prs->arReportSize[0] = 20;
        prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_DomainName);
        prs->arReportSize[1] = 15;
        prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_CompName);
        prs->arReportSize[2] = 15;
        prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_Description);
        prs->arReportSize[3] = 35;
        prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_PwdAge);
        prs->arReportSize[4] = 15;
        prs->colsFilled = 5;
        var.vt = VT_BYREF | VT_UI1;
        var.pbVal = (unsigned char *)prs;
        m_pQueryMapping->putObject(L"ExpiredComputers.DispInfo", var);

        // Account reference report informaiton.
        m_pQueryMapping->put(L"AccountReferences", L"Select DomainName, Account, AccountSid, Server, RefCount as '# of Ref', RefType As ReferenceType from AccountRefs where RefCount > 0 order by DomainName, Account, Server");
        prs = new reportStruct();
        if (!prs)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        prs->sReportName = GET_BSTR(IDS_REPORT_AccountReferences);
        prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_DomainName);
        prs->arReportSize[0] = 15;
        prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_Account);
        prs->arReportSize[1] = 20;
        prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_AccountSid);
        prs->arReportSize[2] = 25;
        prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_Server);
        prs->arReportSize[3] = 15;
        prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_RefCount);
        prs->arReportSize[4] = 10;
        prs->arReportFields[5] = GET_BSTR(IDS_TABLE_FIELD_RefType);
        prs->arReportSize[5] = 15;
        prs->colsFilled = 6;
        var.vt = VT_BYREF | VT_UI1;
        var.pbVal = (unsigned char *)prs;
        m_pQueryMapping->putObject(L"AccountReferences.DispInfo", var);


        // Name conflict report information
        m_pQueryMapping->put(L"NameConflicts",
            L"SELECT"
            L" SourceAccounts.Name,"
            L" SourceAccounts.RDN,"
            L" SourceAccounts.Type,"
            L" TargetAccounts.Type,"
            L" IIf(SourceAccounts.Name=TargetAccounts.Name,'" +
            GET_BSTR(IDS_TABLE_SAM_CONFLICT_VALUE) +
            L"','') +"
            L" IIf(SourceAccounts.Name=TargetAccounts.Name And SourceAccounts.RDN=TargetAccounts.RDN,',','') +"
            L" IIf(SourceAccounts.RDN=TargetAccounts.RDN,'" +
            GET_BSTR(IDS_TABLE_RDN_CONFLICT_VALUE) +
            L"',''),"
            L" TargetAccounts.[Canonical Name] "
            L"FROM SourceAccounts, TargetAccounts "
            L"WHERE"
            L" SourceAccounts.Name=TargetAccounts.Name OR SourceAccounts.RDN=TargetAccounts.RDN "
            L"ORDER BY"
            L" SourceAccounts.Name, TargetAccounts.Name");
        //		m_pQueryMapping->put(L"NameConflicts", L"SELECT SourceAccounts.Name as AccountName, SourceAccounts.Type as SourceType, TargetAccounts.Type as TargetType, SourceAccounts.Description as \
        //							 SourceDescription, TargetAccounts.Description as TargetDescription, SourceAccounts.FullName as SourceFullName, TargetAccounts.FullName as TargetFullName \
        //							 FROM SourceAccounts, TargetAccounts WHERE (((SourceAccounts.Name)=[TargetAccounts].[Name])) ORDER BY SourceAccounts.Name");
        prs = new reportStruct();						
        if (!prs)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        prs->sReportName = GET_BSTR(IDS_REPORT_NameConflicts);
        prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_Account);
        prs->arReportSize[0] = 20;
        prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_SourceRDN);
        prs->arReportSize[1] = 20;
        prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_SourceType);
        prs->arReportSize[2] = 10;
        prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_TargetType);
        prs->arReportSize[3] = 10;
        prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_ConflictAtt);
        prs->arReportSize[4] = 15;
        prs->arReportFields[5] = GET_BSTR(IDS_TABLE_FIELD_TargetCanonicalName);
        prs->arReportSize[5] = 25;
        prs->colsFilled = 6;
        var.vt = VT_BYREF | VT_UI1;
        var.pbVal = (unsigned char *)prs;
        m_pQueryMapping->putObject(L"NameConflicts.DispInfo", var);

        // we will handle the cleanup ourselves.
        VariantInit(&var);

        CheckError(m_rsAccounts.CreateInstance(__uuidof(Recordset)));
    }
    catch (_com_error& ce)
    {
        hr = Error((LPCOLESTR)ce.Description(), ce.GUID(), ce.Error());
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//----------------------------------------------------------------------------
// FinalRelease
//----------------------------------------------------------------------------

void CIManageDB::FinalRelease()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		if (m_rsAccounts)
		{
			m_rsAccounts.Release();
		}

		if (m_pQueryMapping)
		{
			// we need to cleanup all the reportStruct objects.
			_variant_t                      var;
			reportStruct                  * pRs;
			// Cleanup the MigratedAccounts information
			var = m_pQueryMapping->get(L"MigratedAccounts.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*) var.pbVal;
			delete pRs;
			}
			// Cleanup the MigratedComputers information
			var = m_pQueryMapping->get(L"MigratedComputers.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the ExpiredComputers information
			var = m_pQueryMapping->get(L"ExpiredComputers.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the AccountReferences information
			var = m_pQueryMapping->get(L"AccountReferences.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the NameConflicts information
			var = m_pQueryMapping->get(L"NameConflicts.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}

			m_pQueryMapping.Release();
		}

		if (m_cn)
		{
			m_cn.Release();
		}
	}
	catch (...)
	{
	 //eat it
	}
}

//---------------------------------------------------------------------------------------------
// SetVarsetToDB : Saves a varset into the table identified as sTableName. ActionID is also
//                 stored if one is provided.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetVarsetToDB(IUnknown *pUnk, BSTR sTableName, VARIANT ActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try 
	{
		IVarSetPtr                pVSIn = pUnk;
		IVarSetPtr                pVS(__uuidof(VarSet));
		IEnumVARIANTPtr           varEnum;
		_bstr_t                   keyName;
		_variant_t                value;
		_variant_t                varKey;
		_variant_t                vTable = sTableName;
		_variant_t                vtConn;
		_variant_t                varAction;
		DWORD                     nGot = 0;
		long						 lActionID;

		pVS->ImportSubTree(L"", pVSIn);
		ClipVarset(pVS);

      if (ActionID.vt == VT_I4)
		  lActionID = ActionID.lVal;
	  else
		  lActionID = -1;

	   // Open the recordset object.
      _RecordsetPtr             rs(__uuidof(Recordset));
      rs->Open(vTable, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);

      // we are now going to enumerate through the varset and put the values into the DB
      // Get the IEnumVARIANT pointer to enumerate
	  varEnum = pVS->_NewEnum;

      if (varEnum)
      {
         value.vt = VT_EMPTY;
         // For each value in the varset get the property name and put it into the
         // database with the string representation of its value with its type.
         while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
         {
            if ( nGot > 0 )
            {
               keyName = V_BSTR(&varKey);
               value = pVS->get(keyName);
               rs->AddNew();
               if ( lActionID > -1 )
               {
                  // This is going to be actionID information
                  // So lets put in the actionID in the database.
                  varAction.vt = VT_I4;
                  varAction.lVal = lActionID;
                  rs->Fields->GetItem(L"ActionID")->Value = varAction;
               }
               rs->Fields->GetItem(L"Property")->Value = keyName;
               hr = PutVariantInDB(rs, value);
               rs->Update();
               if (FAILED(hr))
                  _com_issue_errorex(hr, pVS, __uuidof(VarSet));
            }
         }
         varEnum.Release();
      }
      // Cleanup
      rs->Close();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// PutVariantInDB : Stores a variant into a DB table by decoding it.
//---------------------------------------------------------------------------------------------
HRESULT CIManageDB::PutVariantInDB(_RecordsetPtr pRs, _variant_t val)
{
   // This function puts the value passed as a variant into the current record of the recordset 
   // It updates the VarType and the Value fields of the given property
   _variant_t                varType;  // Numeric value for the type of value
   _variant_t                varVal;   // String representation of the value field
   WCHAR                     strTemp[255];

   varType.vt = VT_UI4;
   varType.lVal = val.vt;
   switch ( val.vt )
   {
      case VT_BSTR :          varVal = val;
                              break;

      case VT_UI4 :           wsprintf(strTemp, L"%d", val.lVal);
                              varVal = strTemp;
                              break;
      
      case VT_I4 :           wsprintf(strTemp, L"%d", val.lVal);
                              varVal = strTemp;
                              break;
	  
	  case VT_EMPTY :		  break;
     case VT_NULL:        break;

      default :               MCSASSERT(FALSE);    // What ever this type is we are not supporting it
                                                   // so put the support in for this.
                              return E_INVALIDARG;
   }
   pRs->Fields->GetItem(L"VarType")->Value = varType;
   pRs->Fields->GetItem(L"Value")->Value = varVal;
   return S_OK;
}

//---------------------------------------------------------------------------------------------
// ClearTable : Deletes a table indicated by sTableName and applies a filter if provided.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::ClearTable(BSTR sTableName, VARIANT Filter)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		// Build a SQL string to Clear the table.
		WCHAR                     sSQL[2000];
		WCHAR                     sFilter[2000];
		_variant_t                varSQL;

		if (Filter.vt == VT_BSTR)
		   wcscpy(sFilter, (WCHAR*)Filter.bstrVal);
		else
		   wcscpy(sFilter, L"");

		wsprintf(sSQL, L"Delete from %s", sTableName);
		if ( wcslen(sFilter) > 0 )
		{
		  wcscat(sSQL, L" where ");
		  wcscat(sSQL, sFilter);
		}

		varSQL = sSQL;

		_RecordsetPtr                pRs(__uuidof(Recordset));
		pRs->Open(varSQL, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SaveSettings : This method saves the GUI setting varset into the Settings table.
//---------------------------------------------------------------------------------------------

STDMETHODIMP CIManageDB::SaveSettings(IUnknown *pUnk)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        //
        // Update excluded system properties.
        //

        IVarSetPtr spVarSet(pUnk);

        _variant_t vntSystemExclude = spVarSet->get(_T("AccountOptions.ExcludedSystemProps"));

        if (V_VT(&vntSystemExclude) != VT_EMPTY)
        {
            _CommandPtr spCommand(__uuidof(Command));

            spCommand->ActiveConnection = m_cn;
            spCommand->CommandType = adCmdText;
            spCommand->CommandText =
                _T("PARAMETERS A Text; ")
                _T("UPDATE Settings2 SET [Value]=[A] WHERE [Property]='AccountOptions.ExcludedSystemProps';");

            ParametersPtr spParameters = spCommand->Parameters;
            spParameters->Append(spCommand->CreateParameter(L"A", adBSTR, adParamInput, 65535L, vntSystemExclude));

            VARIANT varRecordsAffected;
            VariantInit(&varRecordsAffected);

            spCommand->Execute(&varRecordsAffected, NULL, adExecuteNoRecords);

            //
            // If the record does not exist then insert a new record.
            //

            if ((V_VT(&varRecordsAffected) == VT_I4) && (V_I4(&varRecordsAffected) == 0))
            {
                spCommand->CommandText =
                    _T("PARAMETERS A Text; ")
                    _T("INSERT INTO Settings2 (Property, VarType, [Value]) ")
                    _T("VALUES ('AccountOptions.ExcludedSystemProps', 8, [A]);");

                spCommand->Execute(NULL, NULL, adExecuteNoRecords);
            }

            spVarSet->put(_T("AccountOptions.ExcludedSystemProps"), _variant_t());

            //
            // Set value of AccountOptions.ExcludedSystemPropsSet to 1 which
            // indicates that the excluded system properties has been set.
            //

            m_cn->Execute(
                _T("UPDATE Settings2 SET [Value]='1' ")
                _T("WHERE [Property]='AccountOptions.ExcludedSystemPropsSet';"),
                &varRecordsAffected,
                adCmdText|adExecuteNoRecords
            );

            if ((V_VT(&varRecordsAffected) == VT_I4) && (V_I4(&varRecordsAffected) == 0))
            {
                m_cn->Execute(
                    _T("INSERT INTO Settings2 (Property, VarType, [Value]) ")
                    _T("VALUES ('AccountOptions.ExcludedSystemPropsSet', 3, '1');"),
                    NULL,
                    adCmdText|adExecuteNoRecords
                );
            }
        }

        //
        // The last generated report times are persisted in the Settings table and therefore
        // must be retrieved and re-stored. Note that an old persisted value is only added to the
        // current migration task VarSet if the VarSet does not already define the report time.
        //

        const _TCHAR szReportTimesQuery[] =
            _T("SELECT Property, Value FROM Settings WHERE Property LIKE 'Reports.%.TimeGenerated'");

        _RecordsetPtr rsReportTimes = m_cn->Execute(szReportTimesQuery, &_variant_t(), adCmdText);

        FieldsPtr spFields = rsReportTimes->Fields;

        while (rsReportTimes->EndOfFile == VARIANT_FALSE)
        {
            // Retrieve property name and retrieve corresponding value from VarSet.

            _bstr_t strProperty = spFields->Item[0L]->Value;
            _variant_t vntValue = spVarSet->get(strProperty);

            // If the value returned from the VarSet is empty then the value is not
            // defined therefore add value retrieved from settings table to VarSet.

            if (V_VT(&vntValue) == VT_EMPTY)
            {
                vntValue = spFields->Item[1L]->Value;
                spVarSet->put(strProperty, vntValue);
            }

            rsReportTimes->MoveNext();
        }

        // delete previous settings
        CheckError(ClearTable(_T("Settings")));

        // insert updated settings
        CheckError(SetVarsetToDB(pUnk, _T("Settings")));
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}

//---------------------------------------------------------------------------------------------
// GetVarFromDB : Retrieves a variant from the DB table by encoding it.
//---------------------------------------------------------------------------------------------
HRESULT CIManageDB::GetVarFromDB(_RecordsetPtr pRec, _variant_t& val)
{
	HRESULT hr = S_OK;

	try
	{
		// retrieve data type

		VARTYPE vt = VARTYPE(long(pRec->Fields->GetItem(L"VarType")->Value));

		// if data type is empty or null...

		if ((vt == VT_EMPTY) || (vt == VT_NULL))
		{
			// then clear value
			val.Clear();
		}
		else
		{
			// otherwise retrieve value and convert to given data type
			_variant_t vntValue = pRec->Fields->GetItem(L"Value")->Value;
			val.ChangeType(vt, &vntValue);
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetVarsetFromDB : Retrieves a varset from the specified table. and fills the argument
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetVarsetFromDB(BSTR sTable, IUnknown **ppVarset, VARIANT ActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr                pVS = *ppVarset;
	   _bstr_t                   sKeyName;
	   _variant_t                val;
	   _variant_t                varQuery;
	   WCHAR                     sQuery[1000];
	   long						 lActionID;

      if (ActionID.vt == VT_I4)
		  lActionID = ActionID.lVal;
	  else
		  lActionID = -1;

      if ( lActionID == -1 )
         wsprintf(sQuery, L"Select * from %s", sTable);
      else
         wsprintf(sQuery, L"Select * from %s where ActionID = %d", sTable, lActionID);

      varQuery = sQuery;
      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(varQuery, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
	  if (!pRs->EndOfFile)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 val = pRs->Fields->GetItem(L"Property")->Value;
			 sKeyName = val.bstrVal;
			 hr = GetVarFromDB(pRs, val);
			 if ( FAILED(hr) )
				_com_issue_errorex(hr, pRs, __uuidof(_Recordset));
			 pVS->put(sKeyName, val);
			 pRs->MoveNext();
		  }
		  RestoreVarset(pVS);
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetSettings : Retrieves the settings from the Settings table and fills up the varset
//---------------------------------------------------------------------------------------------

STDMETHODIMP CIManageDB::GetSettings(IUnknown **ppUnk)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        // retrieve settings from Settings Table

        CheckError(GetVarsetFromDB(L"Settings", ppUnk));

        //
        // Retrieve value which indicates whether excluded system properties has been set.
        //

        IVarSetPtr spVarSet(*ppUnk);
        _RecordsetPtr spRecordset;

        spRecordset = m_cn->Execute(
            _T("SELECT Value FROM Settings2 WHERE Property = 'AccountOptions.ExcludedSystemPropsSet'"),
            NULL,
            adCmdText
        );

        long lSet = 0;

        if (spRecordset->EndOfFile == VARIANT_FALSE)
        {
            lSet = spRecordset->Fields->GetItem(0L)->Value;
        }

        spVarSet->put(_T("AccountOptions.ExcludedSystemPropsSet"), lSet);

        //
        // Retrieve excluded system properties from Settings2 table and add to VarSet.
        //

        spRecordset = m_cn->Execute(
            _T("SELECT Value FROM Settings2 WHERE Property = 'AccountOptions.ExcludedSystemProps'"),
            NULL,
            adCmdText
        );

        if (spRecordset->EndOfFile == VARIANT_FALSE)
        {
            //
            // If the returned variant is of type null then must convert
            // to type empty as empty may be converted to string whereas
            // null cannot.
            //

            _variant_t vnt = spRecordset->Fields->GetItem(0L)->Value;

            if (V_VT(&vnt) == VT_NULL)
            {
                vnt.Clear();
            }

            spVarSet->put(_T("AccountOptions.ExcludedSystemProps"), vnt);
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}

//---------------------------------------------------------------------------------------------
// SetActionHistory : Saves action history information into the Action history table.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetActionHistory(long lActionID, IUnknown *pUnk)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    USES_CONVERSION;

    try
    {
        //
        // If the excluded system properties value is defined in the VarSet
        // set the value to empty to prevent this value from being saved to
        // the action history and settings tables.
        //
        // Note that this value is no longer required so the value does not
        // need to be restored in the VarSet. This value is updated in the
        // Settings2 table by explicitly calling the SaveSettings method and
        // should never be updated during a normal migration task.
        //

        static const _TCHAR s_szExcludedSystemProps[] = _T("AccountOptions.ExcludedSystemProps");

        IVarSetPtr spVarSet(pUnk);
        _variant_t vntSystemExclude = spVarSet->get(s_szExcludedSystemProps);

        if (V_VT(&vntSystemExclude) != VT_EMPTY)
        {
            vntSystemExclude.Clear();
            spVarSet->put(s_szExcludedSystemProps, vntSystemExclude);
        }

        // Call the set varset method to set the values into the database.
        SetVarsetToDB(pUnk, L"ActionHistory", _variant_t(lActionID));

        //
        // remove obsolete records from the distributed action table
        // as the action id has now been re-used
        //

        _TCHAR szSQL[LEN_Path];
        _variant_t vntRecordsAffected;

        _stprintf(szSQL, L"DELETE FROM DistributedAction WHERE ActionID = %ld", lActionID);

        m_cn->Execute(_bstr_t(szSQL), &vntRecordsAffected, adExecuteNoRecords);
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetActionHistory : Retrieves action history information into the varset
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetActionHistory(long lActionID, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   // Get the varset from the database
   _variant_t ActionID = lActionID;
//   GetVarsetFromDB(L"ActionHistory", ppUnk, ActionID);
//	return S_OK;
	return GetVarsetFromDB(L"ActionHistory", ppUnk, ActionID);
}

//---------------------------------------------------------------------------------------------
// GetNextActionID : Rotates the Action ID between 1 and MAXID as specified in the system table
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetNextActionID(long *pActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

   // We open the system table and look at the NextActionID field.
   // if the value of the NextActionID is greater than value in MaxID field
   // then we return the nextactionid = 1.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"System";
      _variant_t                   next, max, curr;
      WCHAR                        sActionID[LEN_Path];
      next.vt = VT_I4;
      max.vt = VT_I4;
      curr.vt = VT_I4;

      pRs->Filter = L"";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  next.lVal = pRs->Fields->GetItem(L"NextActionID")->Value;
		  max.lVal = pRs->Fields->GetItem(L"MaxID")->Value;
		  if ( next.lVal > max.lVal )
			 next.lVal = 1;
		  long currentID = next.lVal;
		  *pActionID = currentID;
		  curr.lVal = currentID;
		  next.lVal++;
		  pRs->Fields->GetItem(L"NextActionID")->Value = next;
		  pRs->Fields->GetItem(L"CurrentActionID")->Value = curr;
		  pRs->Update();
		  // Delete all entries for this pirticular action.
		  wsprintf(sActionID, L"ActionID=%d", currentID);
		  _variant_t ActionID = sActionID;
		  ClearTable(L"ActionHistory", ActionID);
		  //TODO:: Add code to delete entries from any other tables if needed
		  // Since we are deleting the actionID in the the ActionHistory table we can
		  // not undo this stuff. But we still need to keep it around so that the report
		  // and the GUI can work with it. I am going to set all actionIDs to -1 if actionID is
		  // cleared
		  SetActionIDInMigratedObjects(sActionID);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SaveMigratedObject : Saves information about a object that is migrated.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SaveMigratedObject(long lActionID, IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

   // This fucntion updates the migrated objects table in the DB with the
   // information in the varset. If the information is not found in the Varset
   // then an error may occur.

	try
	{
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   //dt= COleDateTime::GetCurrentTime();

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      IVarSetPtr                   pVs = pUnk;
      WCHAR                        sQuery[LEN_Path];
      WCHAR                        sSource[LEN_Path], sTarget[LEN_Path], sDomain[LEN_Path];
      HRESULT                      hr = S_OK;
      bool                         bComp = false;
      WCHAR                        sTemp[LEN_Path];
      _bstr_t                      tempName;

      // Delete the record if one already exists in the table. In case it is remigrated/replaced.
      var = pVs->get(GET_BSTR(DB_SourceDomain));
      wcscpy(sSource, (WCHAR*)V_BSTR(&var));
      var = pVs->get(GET_BSTR(DB_TargetDomain));
      wcscpy(sTarget, (WCHAR*)V_BSTR(&var));
      var = pVs->get(GET_BSTR(DB_SourceSamName));
      wcscpy(sDomain, (WCHAR*)V_BSTR(&var));
      wsprintf(sQuery, L"delete from MigratedObjects where SourceDomain=\"%s\" and TargetDomain=\"%s\" and SourceSamName=\"%s\"", 
                        sSource, sTarget, sDomain);
      vtSource = _bstr_t(sQuery);
      hr = pRs->raw_Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      vtSource = L"MigratedObjects";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      var.vt = VT_UI4;
      var.lVal = lActionID;
      pRs->Fields->GetItem(L"ActionID")->Value = var;
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
      var = pVs->get(GET_BSTR(DB_SourceDomain));
      pRs->Fields->GetItem(L"SourceDomain")->Value = var;
      var = pVs->get(GET_BSTR(DB_TargetDomain));
      pRs->Fields->GetItem(L"TargetDomain")->Value = var;
      var = pVs->get(GET_BSTR(DB_SourceAdsPath));
      pRs->Fields->GetItem(L"SourceAdsPath")->Value = var;
      var = pVs->get(GET_BSTR(DB_TargetAdsPath));
      pRs->Fields->GetItem(L"TargetAdsPath")->Value = var;
      var = pVs->get(GET_BSTR(DB_status));
      pRs->Fields->GetItem(L"status")->Value = var;
      var = pVs->get(GET_BSTR(DB_SourceDomainSid));
      pRs->Fields->GetItem(L"SourceDomainSid")->Value = var;

      var = pVs->get(GET_BSTR(DB_Type));
      // make the string into an uppercase string.
      if ( var.vt == VT_BSTR )
      {
         var.bstrVal = UStrLwr((WCHAR*) var.bstrVal);
         if ( !_wcsicmp(L"computer", (WCHAR*) var.bstrVal) )
            bComp = true;
         else
            bComp = false;
      }

      pRs->Fields->GetItem(L"Type")->Value = var;
      
      var = pVs->get(GET_BSTR(DB_SourceSamName));
      // for computer accounts make sure the good old $ sign is there.
      if (bComp)
      {
         wcscpy(sTemp, (WCHAR*) var.bstrVal);
         if ( sTemp[wcslen(sTemp) - 1] != L'$' )
         {
            tempName = sTemp;
            tempName += L"$";
            var = tempName;
         }
      }
      pRs->Fields->GetItem(L"SourceSamName")->Value = var;

      var = pVs->get(GET_BSTR(DB_TargetSamName));
      // for computer accounts make sure the good old $ sign is there.
      if (bComp)
      {
         wcscpy(sTemp, (WCHAR*) var.bstrVal);
         if ( sTemp[wcslen(sTemp) - 1] != L'$' )
         {
            tempName = sTemp;
            tempName += L"$";
            var = tempName;
         }
      }
      pRs->Fields->GetItem(L"TargetSamName")->Value = var;

      var = pVs->get(GET_BSTR(DB_GUID));
      pRs->Fields->GetItem(L"GUID")->Value = var;

      var = pVs->get(GET_BSTR(DB_SourceRid));
      if ( var.vt == VT_UI4 || var.vt == VT_I4 )
         pRs->Fields->GetItem("SourceRid")->Value = var;
      else
         pRs->Fields->GetItem("SourceRid")->Value = _variant_t((long)0);

      var = pVs->get(GET_BSTR(DB_TargetRid));
      if ( var.vt == VT_UI4 || var.vt == VT_I4 )
         pRs->Fields->GetItem("TargetRid")->Value = var;
      else
         pRs->Fields->GetItem("TargetRid")->Value = _variant_t((long)0);

      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetMigratedObjects : Retrieves information about previously migrated objects withis a given
//                      action or as a whole
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjects(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			    //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			    //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			    //code still expects "group" returned (only GetMigratedObjectByType will return this new
			    //delineation
			 _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
			 if (wcsstr((WCHAR*)sType, L"group"))
			    sType = L"group";
			 pVs->put(sActionInfo, sType);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetMigratedObjectsWithSSid : Retrieves information about previously migrated objects within
//                      a given action or as a whole with a valid Source Domain Sid
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjectsWithSSid(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomainSid IS NOT NULL"); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			    //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			    //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			    //code still expects "group" returned (only GetMigratedObjectByType will return this new
			    //delineation
			 _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
			 if (wcsstr((WCHAR*)sType, L"group"))
			    sType = L"group";
			 pVs->put(sActionInfo, sType);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetActionIDInMigratedObjects : For a discarded actionID sets its ActionID to -1 in MO table.
//---------------------------------------------------------------------------------------------
void CIManageDB::SetActionIDInMigratedObjects(_bstr_t sFilter)
{
   _bstr_t sQuery = _bstr_t(L"Update MigratedObjects Set ActionID = -1 where ") + sFilter;
   _variant_t vt = sQuery;
   try
   {
      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vt, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
   }
   catch (...)
   {
      ;
   }
}

//---------------------------------------------------------------------------------------------
// GetRSForReport : Returns a recordset for a given report.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetRSForReport(BSTR sReport, IUnknown **pprsData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		// For a given report we have a mapping in the varset. We can get the query
		// from that varset and execute it and return the varset.

		_variant_t var = m_pQueryMapping->get(sReport);

		if ( var.vt == VT_BSTR )
		{
		  _RecordsetPtr                pRs(__uuidof(Recordset));
		  pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

		  // Now that we have the recordset pointer we can get IUnknown pointer to it and return that
		  *pprsData = IUnknownPtr(pRs).Detach();
		}
		else
		{
		  hr = E_NOTIMPL;
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SaveSCMPasswords(IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   return SetVarsetToDB(pUnk, L"SCMPasswords");
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetSCMPasswords(IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   return GetVarsetFromDB(L"SCMPasswords", ppUnk);
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::ClearSCMPasswords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   ClearTable(L"SCMPasswords");
	return S_OK;
}

//---------------------------------------------------------------------------------------------
// GetCurrentActionID : Retrieves the actionID currently in use.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetCurrentActionID(long *pActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"System";
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);

      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  *pActionID = pRs->Fields->GetItem(L"CurrentActionID")->Value;
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetAMigratedObject : Given the source name, and the domain information retrieves info about
//                      a previous migration.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObject(BSTR sSrcSamName, BSTR sSrcDomain, BSTR sTgtDomain, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      //if ( (SysStringLen(sSrcSamName) == 0) || (SysStringLen(sSrcDomain) == 0) || (SysStringLen(sTgtDomain) == 0))
      if ( (sSrcSamName == 0) || (sSrcDomain == 0) || (sTgtDomain == 0) || (wcslen(sSrcSamName) == 0) || (wcslen(sSrcDomain) == 0) || (wcslen(sTgtDomain) == 0))
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND SourceSamName=\"%s\" AND TargetDomain=\"%s\"", sSrcDomain, sSrcSamName, sTgtDomain); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
			 //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			 //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			 //code still expects "group" returned (only GetMigratedObjectByType will return this new
			 //delineation
	      _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
		  if (wcsstr((WCHAR*)sType, L"group"))
		     sType = L"group";
	      pVs->put(sActionInfo, sType);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//---------------------------------------------------------------------------------------------
// GetAMigratedObjectToAnyDomain : Given the source name, and the domain information retrieves info about
//                      a previous migration.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObjectToAnyDomain(BSTR sSrcSamName, BSTR sSrcDomain, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( (wcslen(sSrcSamName) == 0) || (wcslen(sSrcDomain) == 0))
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND SourceSamName=\"%s\" Order by Time", sSrcDomain, sSrcSamName);
//      pRs->Filter = sActionInfo;
//      wcscpy(sActionInfo, L"Time");
//      pRs->Sort = sActionInfo;
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
			 //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			 //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			 //code still expects "group" returned (only GetMigratedObjectByType will return this new
			 //delineation
	      _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
		  if (wcsstr((WCHAR*)sType, L"group"))
		     sType = L"group";
	      pVs->put(sActionInfo, sType);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GenerateReport Generates an HTML report for the given Query and saves it in the File.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GenerateReport(BSTR sReportName, BSTR sFileName, BSTR sSrcDomain, BSTR sTgtDomain, LONG bSourceNT4)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	FILE* logFile = NULL;

	try
	{
	   _RecordsetPtr             pRs;
	   IUnknownPtr               pUnk;
	   _variant_t                var;
	   WCHAR                     sKey[LEN_Path];
	   CString                   reportingTitle;
	   CString                   srcDm = (WCHAR*) sSrcDomain;
	   CString                   tgtDm = (WCHAR*) sTgtDomain;

			//convert source and target domain names, only used in the name conflict report,
			//to uppercase
	   srcDm.MakeUpper();
	   tgtDm.MakeUpper();

        // construct the statement if the report is "ExpiredComputers"
        if (wcscmp((WCHAR*) sReportName, L"ExpiredComputers") == 0)
        {
            WCHAR newCmdText[256];
            IADsDomain *pDomain;
            _bstr_t sSrcDom(L"WinNT://");
            sSrcDom += sSrcDomain;

            hr = ADsGetObject(sSrcDom, IID_IADsDomain, (void **) &pDomain);
            if (FAILED(hr))
                _com_issue_error(hr);
            long lMaxPassAge;
            hr = pDomain->get_MaxPasswordAge(&lMaxPassAge);
            pDomain->Release();
            if (FAILED(hr))
                _com_issue_error(hr);
            _snwprintf(newCmdText,sizeof(newCmdText)/sizeof(newCmdText[0]),
                       L"Select Time, DomainName, CompName, Description, int(pwdage/86400) & ' days' as 'Password Age' from PasswordAge where pwdage > %ld order by DomainName, CompName",
                       lMaxPassAge);
            newCmdText[sizeof(newCmdText)/sizeof(newCmdText[0]) - 1] = 0;
            m_pQueryMapping->put(sReportName,newCmdText);
        }

	   CheckError(GetRSForReport(sReportName, &pUnk));
	   pRs = pUnk;
   
	   // Now that we have the recordset we need to get the number of columns
	   int numFields = pRs->Fields->Count;
	   int size = 100 / numFields;

	   reportingTitle.LoadString(IDS_ReportingTitle);

	   // Open the html file to write to
	   logFile = fopen(_bstr_t(sFileName), "wb");
	   if ( !logFile )
		  _com_issue_error(HRESULT_FROM_WIN32(GetLastError())); //TODO: stream i/o doesn't set last error

	   //Put the header information into the File.
	   fputs("<HTML>\r\n", logFile);
	   fputs("<HEAD>\r\n", logFile);
	   fputs("<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; CHARSET=utf-8\">\r\n", logFile);
	   fprintf(logFile, "<TITLE>%s</TITLE>\r\n", WTUTF8(reportingTitle.GetBuffer(0)));
	   fputs("</HEAD>\r\n", logFile);
	   fputs("<BODY TEXT=\"#000000\" BGCOLOR=\"#ffffff\">\r\n", logFile);

	   fprintf(logFile, "<B><FONT SIZE=5><P ALIGN=\"CENTER\">%s</P>\r\n", WTUTF8(reportingTitle.GetBuffer(0)));

	   // Get the display information for the report 
	   // I know I did not need to do all this elaborate setup to get the fieldnames and the report names
	   // I could have gotten this information dynamically but had to change it because we need to get the 
	   // info from the Res dll for internationalization.
	   wsprintf(sKey, L"%s.DispInfo", (WCHAR*) sReportName);
	   _variant_t  v1;
	   reportStruct * prs;
	   v1 = m_pQueryMapping->get(sKey);
	   prs = (reportStruct *) v1.pbVal;
	   VariantInit(&v1);

	   fprintf(logFile, "</FONT><FONT SIZE=4><P ALIGN=\"CENTER\">%s</P>\r\n", WTUTF8(prs->sReportName));
	   fputs("<P ALIGN=\"CENTER\"><CENTER><TABLE WIDTH=90%%>\r\n", logFile);
	   fputs("<TR>\r\n", logFile);
	   for (int i = 0; i < numFields; i++)
	   {
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" BGCOLOR=\"#000080\">\r\n", prs->arReportSize[i]);
		     //if Canonical Name column, left align text since the name can be really long
		  if (i==5)
		     fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#00ff00\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(prs->arReportFields[i]));
		  else
		     fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#00ff00\"><P ALIGN=\"CENTER\">%s</B></FONT></TD>\r\n", WTUTF8(prs->arReportFields[i]));
	   }
	   fputs("</TR>\r\n", logFile);

		//if name conflict report, add domains to the top of the report
	   if (wcscmp((WCHAR*) sReportName, L"NameConflicts") == 0)
	   {
		  fputs("</TR>\r\n", logFile);
			 //add "Source Domain ="
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_NC_SDOMAIN)));
		   //add %SourceDomainName%
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[1]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\"> = %s</B></FONT></TD>\r\n", WTUTF8(LPCTSTR(srcDm)));
		  fputs("<TD>\r\n", logFile);
		  fputs("<TD>\r\n", logFile);
		   //add "Target Domain ="
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[4]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_NC_TDOMAIN)));
		   //add %TargetDomainName%
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[5]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\"> = %s</B></FONT></TD>\r\n", WTUTF8(LPCTSTR(tgtDm)));
		  fputs("</TR>\r\n", logFile);
	   }

	      //write Account Reference report here since we need to build lists and
	      //categorize
	   if (wcscmp((WCHAR*) sReportName, L"AccountReferences") == 0)
	   {
	      CStringList inMotList;
		  CString accountName;
		  CString domainName;
		  CString listName;
          POSITION currentPos; 

	         //add "Migrated by ADMT" as section header for Account Reference report
		  fputs("</TR>\r\n", logFile);
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_AR_MOT_HDR)));
		  fputs("</TR>\r\n", logFile);

		     //look at each entry in the recordset and add the the migrated list if it was
		     //migrated and in the MOT
	      while ( !pRs->EndOfFile )
		  {
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

			    //see if this account is in the Migrated Objects table
             IVarSetPtr pVsMot(__uuidof(VarSet));
             IUnknown  * pMotUnk;
             pVsMot->QueryInterface(IID_IUnknown, (void**) &pMotUnk);
             HRESULT hrFind = GetAMigratedObjectToAnyDomain(accountName.AllocSysString(), 
				                                            domainName.AllocSysString(), &pMotUnk);
             pMotUnk->Release();
			    //if this entry was in the MOT, save in the list
             if ( hrFind == S_OK )
			 {
				   //list stores the account in the form domain\account
				listName = domainName;
				listName += L"\\";
				listName += accountName;
			       //add the name to the list, if not already in it
		        currentPos = inMotList.Find(listName);
		        if (currentPos == NULL)
			       inMotList.AddTail(listName);
			 }
  		     pRs->MoveNext();
		  }//end while build MOT list

		     //go back to the top of the recordset and print each entry that is in the
		     //list created above
  		  pRs->MoveFirst();
	      while ( !pRs->EndOfFile )
		  {
			 BOOL bInList = FALSE;
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

				//list stored the accounts in the form domain\account
		     listName = domainName;
			 listName += L"\\";
			 listName += accountName;
			    //see if this entry name is in the list, if so, print it
		     if (inMotList.Find(listName) != NULL)
			 {
		        fputs("<TR>\r\n", logFile);
		        for (int i = 0; i < numFields; i++)
				{
			       fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			       var = pRs->Fields->Item[(long) i]->GetValue();
			       if ( var.vt == VT_BSTR )
					  fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(EscapeSpecialChars(V_BSTR(&var))));
				   else
				      fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		        fputs("</TR>\r\n", logFile);
			 }//end if in list and need to print
  		     pRs->MoveNext();
		  }//end while print those in MOT

	         //add "Not Migrated by ADMT" as section header for Account Reference report
		  fputs("</TR>\r\n", logFile);
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_AR_NOTMOT_HDR)));
		  fputs("</TR>\r\n", logFile);

		     //go back to the top of the recordset and print each entry that is NOT
		     //in the list created above
  		  pRs->MoveFirst();
	      while ( !pRs->EndOfFile )
		  {
			 BOOL bInList = FALSE;
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

				//list stored the accounts in the form domain\account
		     listName = domainName;
			 listName += L"\\";
			 listName += accountName;
			    //see if this entry name is in the list, if not, print it
		     if (inMotList.Find(listName) == NULL)
			 {
		        fputs("<TR>\r\n", logFile);
		        for (int i = 0; i < numFields; i++)
				{
			       fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			       var = pRs->Fields->Item[(long) i]->GetValue();
			       if ( var.vt == VT_BSTR )
					  fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(EscapeSpecialChars(V_BSTR(&var))));
				   else
				      fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		        fputs("</TR>\r\n", logFile);
			 }//end if NOT in list and need to print
  		     pRs->MoveNext();
		  }//end while print those NOT in Mot
		  inMotList.RemoveAll(); //free the list
	   }//end if Account Ref report


	   while ((!pRs->EndOfFile) && (wcscmp((WCHAR*) sReportName, L"AccountReferences")))
	   {
		  fputs("<TR>\r\n", logFile);
		  for (int i = 0; i < numFields; i++)
		  {
			 bool bTranslateType = false;
			 bool bHideRDN = false;
			 fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			 var = pRs->Fields->Item[(long) i]->GetValue();
			 if ( var.vt == VT_BSTR )
			 {
					//set flag for translating type fields to localizable strings
				if ((!wcscmp((WCHAR*) sReportName, L"NameConflicts")) && ((i==2) || (i==3)))
						bTranslateType = true;
				if ((!wcscmp((WCHAR*) sReportName, L"MigratedComputers")) && (i==2))
						bTranslateType = true;
				if ((!wcscmp((WCHAR*) sReportName, L"MigratedAccounts")) && (i==2))
						bTranslateType = true;
					//clear flag for not displaying RDN for NT 4.0 Source domains
				if ((!wcscmp((WCHAR*) sReportName, L"NameConflicts")) && (i==1) && bSourceNT4)
						bHideRDN = true;

				if (bTranslateType)
				{
					 //convert type from English only to a localizable string
					CString          atype;
					if (!_wcsicmp((WCHAR*)V_BSTR(&var), L"user") || !_wcsicmp((WCHAR*)V_BSTR(&var), L"inetOrgPerson"))
						atype = GET_STRING(IDS_TypeUser);
					else if (wcsstr((WCHAR*)V_BSTR(&var), L"group"))
						atype = GET_STRING(IDS_TypeGroup);
					else if (!_wcsicmp((WCHAR*)V_BSTR(&var), L"computer"))
						atype = GET_STRING(IDS_TypeComputer);
					else 
						atype = GET_STRING(IDS_TypeUnknown);
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(LPCTSTR(atype)));
				}
					//replace hard-coded "days" with a localizable string
				else if((!wcscmp((WCHAR*) sReportName, L"ExpiredComputers")) && (i==4))
				{
					CString          apwdage;
					WCHAR *			 ndx;
					if ((ndx = wcsstr((WCHAR*)V_BSTR(&var), L"days")) != NULL)
					{
						*ndx = L'\0';
						apwdage = (WCHAR*)V_BSTR(&var);
						apwdage += GET_STRING(IDS_PwdAgeDays);
					}
					else
						apwdage = (WCHAR*)V_BSTR(&var);

					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(EscapeSpecialChars(LPCTSTR(apwdage))));
				}
				   //else if NT 4.0 Source do not show our fabricated RDN
				else if (bHideRDN)
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(L""));
				else
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(EscapeSpecialChars(V_BSTR(&var))));
			}	
			else
				if ( var.vt == VT_DATE )
				{
				   _variant_t v1;
				   VariantChangeType(&v1, &var, VARIANT_NOVALUEPROP, VT_BSTR);
				   WCHAR    sMsg[LEN_Path];
				   wcscpy(sMsg, (WCHAR*) V_BSTR(&v1));
				   fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%s</FONT></TD>\r\n", WTUTF8(EscapeSpecialChars(LPCTSTR(sMsg))));
				}
				else
				{
				   //TODO :: The types need more work
				   fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		  }
		  fputs("</TR>\r\n", logFile);
		  pRs->MoveNext();
	   }
	   fputs("</TABLE>\r\n", logFile);
	   fputs("</CENTER></P>\r\n", logFile);

	   fputs("<B><FONT SIZE=5><P ALIGN=\"CENTER\"></P></B></FONT></BODY>\r\n", logFile);
	   fputs("</HTML>\r\n", logFile);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	if (logFile)
	{
		fclose(logFile);
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// AddDistributedAction : Adds a distributed action record to the DistributedAction table.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::AddDistributedAction(BSTR sServerName, BSTR sResultFile, long lStatus, BSTR sText)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    USES_CONVERSION;

    try
    {
        // Get the current action ID.
        long lActionID;
        CheckError(GetCurrentActionID(&lActionID));

        _TCHAR szSQL[1024];

        //
        // try to insert a new failed distributed action record for this action id and server
        //

        _stprintf(
            szSQL,
            _T("INSERT INTO DistributedAction")
            _T(" (ActionID, ServerName, ResultFile, Status, StatusText) ")
            _T("VALUES")
            _T(" (%ld, '%s', '%s', %ld, '%s')"),
            lActionID,
            OLE2CT(sServerName),
            OLE2CT(sResultFile),
            lStatus,
            OLE2CT(sText)
        );

        _variant_t vntRecordsAffected;
        _RecordsetPtr spRecordset;

        hr = m_cn->raw_Execute(_bstr_t(szSQL), &vntRecordsAffected, adExecuteNoRecords, &spRecordset);

        //
        // if insert failed then try to update existing record for this action id and server
        //
        // The action identifier used by ADMT to identify a migration task has a maximum value
        // of 50. After a task has been executed with an id of 50 the id for the next task is
        // reset back to 1. The tuple of the action id and the server name uniquely identifies a
        // failed distributed task. The insert will fail if a record with the same action id
        // and server name already exist. The only way out of this situation is to replace
        // the existing record with the updated result file and status information. This means
        // that the user will not be able to retry the old failed distributed task but at least
        // they will be able to retry the later failed distributed task.
        //

        if (FAILED(hr))
        {
            _stprintf(
                szSQL,
                _T("UPDATE DistributedAction")
                _T(" SET ResultFile = '%s', Status = %ld, StatusText = '%s' ")
                _T("WHERE ActionID = %ld AND ServerName = '%s'"),
                OLE2CT(sResultFile),
                lStatus,
                OLE2CT(sText),
                lActionID,
                OLE2CT(sServerName)
            );

            m_cn->Execute(_bstr_t(szSQL), &vntRecordsAffected, adExecuteNoRecords);
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}

//---------------------------------------------------------------------------------------------
// GetFailedDistributedActions : Returns all the failed distributed action
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetFailedDistributedActions(long lActionID, IUnknown ** pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr             pVs = * pUnk;
	   WCHAR                  sQuery[LEN_Path];
	   int                    nCnt = 0, nCntActionID = 1;
	   WCHAR                  sKey[LEN_Path];
	   _variant_t             var;

	   // The failed action has the 0x80000000 bit set so we check for that (2147483648)
	   if ( lActionID == -1 )
		  wcscpy(sQuery, L"Select * from DistributedAction where status < 0");
	   else
		  wsprintf(sQuery, L"Select * from DistributedAction where ActionID=%d and status < 0", lActionID);
	   _variant_t             vtSource = _bstr_t(sQuery);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      while (!pRs->EndOfFile)
      {
         wsprintf(sKey, L"DA.%d.ActionID", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ActionID")->Value);

         wsprintf(sKey, L"DA.%d.Server", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ServerName")->Value);

         wsprintf(sKey, L"DA.%d.Status", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"Status")->Value);

         wsprintf(sKey, L"DA.%d.JobFile", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ResultFile")->Value);
         
         wsprintf(sKey, L"DA.%d.StatusText", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"StatusText")->Value);

         nCnt++;
         pRs->MoveNext();
      }
      pVs->put(L"DA", (long) nCnt);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetServiceAccount : This method is saves the account info for the Service on a pirticular
//                     machine.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetServiceAccount(
                                             BSTR System,   //in- System name
                                             BSTR Service,  //in- Service name
                                             BSTR ServiceDisplayName, // in - Display name for service
                                             BSTR Account   //in- Account used by this service
                                          )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   // Create a new record and save the information
	   _variant_t                var;
	   WCHAR                     sFilter[LEN_Path];

	   wsprintf(sFilter, L"System = \"%s\" and Service = \"%s\"", System, Service);
	   var = sFilter;
	   ClearTable(L"ServiceAccounts", var);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"ServiceAccounts";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      var = _bstr_t(System);
      pRs->Fields->GetItem(L"System")->Value = var;
      var = _bstr_t(Service);
      pRs->Fields->GetItem(L"Service")->Value = var;
      
      var = _bstr_t(ServiceDisplayName);
      pRs->Fields->GetItem(L"ServiceDisplayName")->Value = var;
      
      var = _bstr_t(Account);
      pRs->Fields->GetItem(L"Account")->Value = var;
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetServiceAccount : This method gets all the Services referencing the Account specified. The
//                     values are returned in System.Service format in the VarSet.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetServiceAccount(
                                             BSTR Account,     //in- The account to lookup
                                             IUnknown ** pUnk  //out-Varset containing Services 
                                          )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr                pVs = * pUnk;
	   _bstr_t                   sQuery;
	   _bstr_t                   sKey;
	   WCHAR                     key[500];
	   _variant_t                var;
	   long                      ndx = 0;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      // Set up the query to lookup a pirticular account or all accounts
      if ( wcslen((WCHAR*)Account) == 0 )
         sQuery = _bstr_t(L"Select * from ServiceAccounts order by System, Service");
      else
         sQuery = _bstr_t(L"Select * from ServiceAccounts where Account = \"") + _bstr_t(Account) + _bstr_t(L"\" order by System, Service");
      var = sQuery;
      // Get the data, Setup the varset and then return the info
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      while (!pRs->EndOfFile)
      {
         // computer name
         swprintf(key,L"Computer.%ld",ndx);
         var = pRs->Fields->GetItem("System")->Value;
         pVs->put(key,var);
         // service name
         swprintf(key,L"Service.%ld",ndx);
         var = pRs->Fields->GetItem("Service")->Value;
         pVs->put(key,var);

         swprintf(key,L"ServiceDisplayName.%ld",ndx);
         var = pRs->Fields->GetItem("ServiceDisplayName")->Value;
         pVs->put(key,var);

         // account name
         swprintf(key,L"ServiceAccount.%ld",ndx);
         var = pRs->Fields->GetItem("Account")->Value;
         pVs->put(key, var);
   
         swprintf(key,L"ServiceAccountStatus.%ld",ndx);
         var = pRs->Fields->GetItem("Status")->Value;
         pVs->put(key,var);

         pRs->MoveNext();
         ndx++;
         pVs->put(L"ServiceAccountEntries",ndx);
      }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SavePasswordAge : Saves the password age of the computer account at a given time.
//                   It also stores the computer description.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SavePasswordAge(BSTR sDomain, BSTR sComp, BSTR sDesc, long lAge)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
   
	   // Delete the entry if one exists.
	   wsprintf(sTemp, L"DomainName=\"%s\" and compname=\"%s\"", (WCHAR*) sDomain, (WCHAR*) sComp);
	   var = sTemp;
	   ClearTable(L"PasswordAge", var);

	   var = L"PasswordAge";
      _RecordsetPtr                 pRs(__uuidof(Recordset));
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
      pRs->Fields->GetItem(L"DomainName")->Value = sDomain;
      pRs->Fields->GetItem(L"CompName")->Value = sComp;
      pRs->Fields->GetItem(L"Description")->Value = sDesc;
      pRs->Fields->GetItem(L"PwdAge")->Value = lAge;
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//---------------------------------------------------------------------------------------------
// GetPasswordAge : Gets the password age and description of a given computer
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetPasswordAge(BSTR sDomain, BSTR sComp, BSTR *sDesc, long *lAge, long *lTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   DATE                      val;

	   wsprintf(sTemp, L"DomainName =\"%s\" AND CompName = \"%s\"", (WCHAR*) sDomain, (WCHAR*) sComp);
	   sQuery = _bstr_t(L"Select * from PasswordAge where  ") + _bstr_t(sTemp);
	   var = sQuery;

      _RecordsetPtr                 pRs(__uuidof(Recordset));
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( ! pRs->EndOfFile )
      {
         val = pRs->Fields->GetItem(L"Time")->Value;  
         *sDesc = pRs->Fields->GetItem(L"Description")->Value.bstrVal;
         *lAge = pRs->Fields->GetItem(L"PwdAge")->Value;
      }
	  else
	  {
		hr = S_FALSE;
	  }
      pRs->Close();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetServiceAcctEntryStatus : Sets the Account and the status for a given service on a given
//                             computer.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetServiceAcctEntryStatus(BSTR sComp, BSTR sSvc, BSTR sAcct, long Status)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _variant_t                var;
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];

	   wsprintf(sTemp, L"Select * from ServiceAccounts where System = \"%s\" and Service = \"%s\"", (WCHAR*) sComp, (WCHAR*) sSvc);
	   sQuery = sTemp;
	   _variant_t                vtSource = sQuery;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( !pRs->EndOfFile )
      {
         if (  sAcct )
         {
            var = _bstr_t(sAcct);
            pRs->Fields->GetItem(L"Account")->Value = var;
         }
         var = Status;
         pRs->Fields->GetItem(L"Status")->Value = var;
         pRs->Update();
      }
	  else
	  {
	     hr = E_INVALIDARG;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetDistActionStatus : Sets the Distributed action's status and its message.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetDistActionStatus(long lActionID, BSTR sComp, long lStatus, BSTR sText)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _variant_t                var;
	   _bstr_t                   sQuery; 
	   WCHAR                     sTemp[LEN_Path];

	   if ( lActionID == -1 )
	   {
		  // lookup by the job filename
		  wsprintf(sTemp,L"Select * from  DistributedAction where ResultFile = \"%s\"",(WCHAR*) sComp);
	   }
	   else
	   {
		  // lookup by action ID and computer name
		  wsprintf(sTemp, L"Select * from  DistributedAction where ServerName = \"%s\" and ActionID = %d", (WCHAR*) sComp, lActionID);
	   }
	   sQuery = sTemp;
	   _variant_t                vtSource = sQuery;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( !pRs->EndOfFile )
      {
         var = _bstr_t(sText);
         pRs->Fields->GetItem(L"StatusText")->Value = var;
         var = lStatus;
         pRs->Fields->GetItem(L"Status")->Value = var;
         pRs->Update();
      }
	  else
	  {
	     hr = E_INVALIDARG;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// CancelDistributedAction : Deletes a pirticular distributed action
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::CancelDistributedAction(long lActionID, BSTR sComp)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   WCHAR                     sFilter[LEN_Path];
   wsprintf(sFilter, L"ActionID = %d and ServerName = \"%s\"", lActionID, (WCHAR*) sComp);
   _variant_t Filter = sFilter;
   return ClearTable(L"DistributedAction", Filter);
}

//---------------------------------------------------------------------------------------------
// AddAcctRef : Adds an account reference record.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::AddAcctRef(BSTR sDomain, BSTR sAcct, BSTR sAcctSid, BSTR sComp, long lCount, BSTR sType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   _variant_t                var;
	   WCHAR                     sFilter[LEN_Path];
	   VARIANT_BOOL				 bSidColumn = VARIANT_FALSE;

	      //find out if the new sid column is there, if not, don't try
	      //writing to it
	   SidColumnInARTable(&bSidColumn);

	   wsprintf(sFilter, L"DomainName = \"%s\" and Server = \"%s\" and Account = \"%s\" and RefType = \"%s\"", sDomain, sComp, sAcct, sType);
	   var = sFilter;
	   ClearTable(L"AccountRefs", var);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"AccountRefs";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
      pRs->Fields->GetItem(L"DomainName")->Value = sDomain;
      pRs->Fields->GetItem(L"Server")->Value = sComp;
      pRs->Fields->GetItem(L"Account")->Value = sAcct;
      pRs->Fields->GetItem(L"RefCount")->Value = lCount;
      pRs->Fields->GetItem(L"RefType")->Value = sType;
	  if (bSidColumn)
	  {
         wcscpy((WCHAR*) sAcctSid, UStrUpr((WCHAR*)sAcctSid));
         pRs->Fields->GetItem(L"AccountSid")->Value = sAcctSid;
	  }

      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

void CIManageDB::ClipVarset(IVarSetPtr pVS)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   sTemp, keyName, sTempKey;
   long                      offset = 0;
   bool                      cont = true;
   WCHAR                     sKeyName[MAX_BUF_LEN];
   _variant_t                varKey, value;
   IEnumVARIANT            * varEnum;
   DWORD                     nGot = 0;
   IUnknown                * pEnum = NULL;
   CString                   strTemp;
   int                       len;

   // we are now going to enumerate through the varset and clip the strings if larger then MAX_BUFFER
   hr = pVS->get__NewEnum(&pEnum);
   if ( SUCCEEDED(hr) )
   {
      // Get the IEnumVARIANT pointer to enumerate
      hr = pEnum->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pEnum->Release();
      pEnum = NULL;
   }

   if ( SUCCEEDED(hr))
   {
      while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
      {
         if ( nGot > 0 )
         {
            keyName = V_BSTR(&varKey);
            value = pVS->get(keyName);
            if ( value.vt == VT_BSTR )
            {
               sTemp = value;
               if ( sTemp.length() > MAX_BUF_LEN )
               {
                  CString str((WCHAR*) sTemp);
                  // This won't fit in the buffer. We need to break it up and save
                  while (cont)
                  {
                     cont = false;
                     strTemp = str.Mid((offset*255), 255);                     
                     len = strTemp.GetLength();
                     if ( len )
                     {
                        offset++;
                        wsprintf(sKeyName, L"BROKEN.%s.%d", (WCHAR*) keyName, offset);
                        sTempKey = sKeyName;
                        sTemp = strTemp;
                        pVS->put(sTempKey, sTemp);
                        cont = (len == 255);
                     }
                  }
                  pVS->put(keyName, L"DIVIDED_KEY");
                  wsprintf(sKeyName, L"BROKEN.%s", (WCHAR*) keyName);
                  sTempKey = sKeyName;
                  pVS->put(sTempKey, offset);
                  cont = true;
                  offset = 0;
               }
            }
         }
      }
      varEnum->Release();
   }
}

void CIManageDB::RestoreVarset(IVarSetPtr pVS)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   sTemp, keyName, sTempKey;
   long                      offset = 0;
   bool                      cont = true;
   WCHAR                     sKeyName[MAX_BUF_LEN];
   _variant_t                varKey, value;
   IEnumVARIANT            * varEnum;
   DWORD                     nGot = 0;
   IUnknown                * pEnum = NULL;
   _bstr_t                   strTemp;

   // we are now going to enumerate through the varset and clip the strings if larger then MAX_BUFFER
   hr = pVS->get__NewEnum(&pEnum);
   if ( SUCCEEDED(hr) )
   {
      // Get the IEnumVARIANT pointer to enumerate
      hr = pEnum->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pEnum->Release();
      pEnum = NULL;
   }

   if ( SUCCEEDED(hr))
   {
      while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
      {
         if ( nGot > 0 )
         {
            keyName = V_BSTR(&varKey);
            value = pVS->get(keyName);
            if ( value.vt == VT_BSTR )
            {
               sTemp = value;
               if (!_wcsicmp((WCHAR*)sTemp, L"DIVIDED_KEY"))
               {
                  wsprintf(sKeyName, L"BROKEN.%s", (WCHAR*) keyName);
                  sTempKey = sKeyName;
                  value = pVS->get(sTempKey);
                  if ( value.vt == VT_I4 )
                  {
                     offset = value.lVal;
                     for ( long x = 1; x <= offset; x++ )
                     {
                        wsprintf(sKeyName, L"BROKEN.%s.%d", (WCHAR*) keyName, x);
                        sTempKey = sKeyName;
                        value = pVS->get(sTempKey);
                        if ( value.vt == VT_BSTR )
                        {
                           sTemp = value;
                           strTemp += V_BSTR(&value);
                        }
                     }
                     pVS->put(keyName, strTemp);
                     strTemp = L"";
                  }
               }
            }
         }
      }
      varEnum->Release();
   }
}

STDMETHODIMP CIManageDB::AddSourceObject(BSTR sDomain, BSTR sSAMName, BSTR sType, BSTR sRDN, BSTR sCanonicalName, LONG bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      m_rsAccounts->AddNew();
      m_rsAccounts->Fields->GetItem(L"Domain")->Value = sDomain;
      m_rsAccounts->Fields->GetItem(L"Name")->Value = sSAMName;
      wcscpy((WCHAR*) sType, UStrLwr((WCHAR*)sType));
      m_rsAccounts->Fields->GetItem(L"Type")->Value = sType;
      m_rsAccounts->Fields->GetItem(L"RDN")->Value = sRDN;
      m_rsAccounts->Fields->GetItem(L"Canonical Name")->Value = sCanonicalName;
      m_rsAccounts->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::OpenAccountsTable(LONG bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		if (m_rsAccounts->State == adStateClosed)
		{
			_variant_t vtSource;
			if ( bSource )
				vtSource = L"SourceAccounts";
			else
				vtSource = L"TargetAccounts";
				   
			   //if not modified already, modify the table
		    if (!NCTablesColumnsChanged(bSource))
			   hr = ChangeNCTableColumns(bSource);

			if (SUCCEEDED(hr))
			   m_rsAccounts->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
		}
		else
			hr = S_FALSE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::CloseAccountsTable()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		if (m_rsAccounts->State == adStateOpen)
		{
			m_rsAccounts->Close();
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

// Returns the number of entries in the migratedobjects table.
STDMETHODIMP CIManageDB::AreThereAnyMigratedObjects(long *count)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      WCHAR                        sActionInfo[LEN_Path];
      _variant_t                   var;
      
      wcscpy(sActionInfo, L"Select count(*) as NUM from MigratedObjects");
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      var = pRs->Fields->GetItem((long)0)->Value;
      * count = var.lVal;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetActionHistoryKey(long lActionID, BSTR sKeyName, VARIANT *pVar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      WCHAR                        sActionInfo[LEN_Path];
      _variant_t                   var;
      
      wsprintf(sActionInfo, L"Select * from ActionHistory where Property = \"%s\" and ActionID = %d", (WCHAR*) sKeyName, lActionID);
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if ((pRs->BOF == VARIANT_FALSE) && (pRs->EndOfFile == VARIANT_FALSE))
      {
         GetVarFromDB(pRs, var);
      }

      *pVar = var.Detach();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetMigratedObjectBySourceDN(BSTR sSourceDN, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( (wcslen(sSourceDN) == 0) )
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"SELECT * FROM MigratedObjects WHERE SourceAdsPath Like '%%%s'", (WCHAR*) sSourceDN); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
			 //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			 //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			 //code still expects "group" returned (only GetMigratedObjectByType will return this new
			 //delineation
	      _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
		  if (wcsstr((WCHAR*)sType, L"group"))
		     sType = L"group";
	      pVs->put(sActionInfo, sType);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::SaveUserProps(IUnknown * pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      IVarSetPtr                   pVs = pUnk;
      WCHAR                        sQuery[LEN_Path];
      WCHAR                        sSource[LEN_Path], sDomain[LEN_Path];
      HRESULT                      hr = S_OK;
      bool                         bComp = false;
      _variant_t                   var;
      
      var = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
      wcscpy(sDomain, (WCHAR*)V_BSTR(&var));

      var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
      wcscpy(sSource, (WCHAR*)V_BSTR(&var));
      
      wsprintf(sQuery, L"delete from UserProps where SourceDomain=\"%s\" and SourceSam=\"%s\"", 
                        sDomain, sSource);
      vtSource = _bstr_t(sQuery);
      hr = pRs->raw_Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      vtSource = L"UserProps";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"ActionID")->Value = pVs->get(GET_BSTR(DB_ActionID));
      pRs->Fields->GetItem(L"SourceDomain")->Value = sDomain;
      pRs->Fields->GetItem(L"SourceSam")->Value = sSource;
      pRs->Fields->GetItem(L"Flags")->Value = pVs->get(GET_BSTR(DCTVS_CopiedAccount_UserFlags));
      pRs->Fields->GetItem(L"Expires")->Value = pVs->get(GET_BSTR(DCTVS_CopiedAccount_ExpDate));
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetUserProps(BSTR sDom, BSTR sSam, IUnknown **ppUnk)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        _RecordsetPtr                pRs(__uuidof(Recordset));
        IVarSetPtr                   pVs = *ppUnk;

        // If the parameters are not correct then we need to return an error
        if ( !wcslen((WCHAR*)sDom) && !wcslen((WCHAR*)sSam) )
            _com_issue_error(E_INVALIDARG);

        _CommandPtr spCommand (__uuidof(Command));
        spCommand->ActiveConnection = m_cn;
        spCommand->CommandText =
            L"PARAMETERS SD Text ( 255 ), SS Text ( 50 ); "
            L"SELECT UserProps.* "
            L"FROM UserProps "
            L"WHERE (((UserProps.SourceDomain)=[SD]) AND ((UserProps.SourceSam)=[SS])) ";
        spCommand->CommandType = adCmdText;
        spCommand->Parameters->Append(spCommand->CreateParameter(L"SD", adBSTR, adParamInput, 255, sDom));
        spCommand->Parameters->Append(spCommand->CreateParameter(L"SS", adBSTR, adParamInput,  50, sSam));
        _variant_t vntSource(IDispatchPtr(spCommand).GetInterfacePtr());
        pRs->Open(vntSource, vtMissing, adOpenStatic, adLockReadOnly, adCmdUnspecified);
        if (pRs->GetRecordCount() > 0)
        {
            // We want the latest move.
            pRs->MoveLast();
            pVs->put(L"ActionID",pRs->Fields->GetItem(L"ActionID")->Value);
            pVs->put(L"SourceDomain",pRs->Fields->GetItem(L"SourceDomain")->Value);
            pVs->put(L"SourceSam",pRs->Fields->GetItem(L"SourceSam")->Value); 
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags),pRs->Fields->GetItem(L"Flags")->Value);  
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_ExpDate),pRs->Fields->GetItem(L"Expires")->Value);  
        }
        else
        {
            hr = S_FALSE;
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB checks to see*
 * if the new Source domain SID column is in the MigratedObjects     *
 * table.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN SrcSidColumnInMigratedObjectsTable
STDMETHODIMP CIManageDB::SrcSidColumnInMigratedObjectsTable(VARIANT_BOOL *pbFound)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	*pbFound = VARIANT_FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
	  long						   numColumns;
	  long						   ndx = 0;
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (*pbFound == VARIANT_FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, GET_BSTR(DB_SourceDomainSid)))
             *pbFound = VARIANT_TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END SrcSidColumnInMigratedObjectsTable

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB retrieves    *
 * information about previously migrated objects, from a MOT missing *
 * the source sid column, within a given action or as a whole.       *
 *                                                                   *
 *********************************************************************/

//BEGIN GetMigratedObjectsFromOldMOT
STDMETHODIMP CIManageDB::GetMigratedObjectsFromOldMOT(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END GetMigratedObjectsFromOldMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB adds the     *
 * source domain SID column to the MigratedObjects table.            *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateSrcSidColumnInMOT
STDMETHODIMP CIManageDB::CreateSrcSidColumnInMOT(VARIANT_BOOL *pbCreated)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	*pbCreated = VARIANT_FALSE;

	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"MigratedObjects"];
         //append a new column to the end of the MOT
      m_pTable->Columns->Append(L"SourceDomainSid", adVarWChar, COLUMN_MAX_CHARS);
		 //set the column to be nullable
//	  ADOX::_ColumnPtr pColumn = m_pTable->Columns->Item[L"SourceDomainSid"];
//	  pColumn->Attributes = ADOX::adColNullable;
      *pbCreated = VARIANT_TRUE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END CreateSrcSidColumnInMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB deletes the  *
 * source domain SID column from the MigratedObjects table.          *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteSrcSidColumnInMOT
STDMETHODIMP CIManageDB::DeleteSrcSidColumnInMOT(VARIANT_BOOL *pbDeleted)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	*pbDeleted = VARIANT_FALSE;

	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"MigratedObjects"];
         //delete the column from the MOT
      m_pTable->Columns->Delete(L"SourceDomainSid");
      *pbDeleted = VARIANT_TRUE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END DeleteSrcSidColumnInMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 21 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB populates the*
 * new Source domain SID column in the MigratedObjects table for all *
 * entries from the given domain.  If the domain cannot be reached no*
 * entry is added.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN PopulateSrcSidColumnByDomain
STDMETHODIMP CIManageDB::PopulateSrcSidColumnByDomain(BSTR sDomainName,
													  BSTR sSid,
													  VARIANT_BOOL * pbPopulated)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())
        /* local variables */
    HRESULT                   hr = S_OK;
    PSID                      pSid = NULL;
    DWORD                     rc = 0;
    _bstr_t                   domctrl;
    WCHAR                     txtSid[MAX_PATH];
    DWORD                     dwArraySizeOfTxtSid = sizeof(txtSid)/sizeof(txtSid[0]);
    DWORD                     lenTxt = DIM(txtSid);


    /* function body */
    *pbPopulated = VARIANT_FALSE; //init flag to false

    try
    {
        _RecordsetPtr             pRs(__uuidof(Recordset));
        WCHAR                     sActionInfo[MAX_PATH];

        //if we don't already know the source sid then find it
        if (sSid == NULL)
            _com_issue_error(E_INVALIDARG);
        if (wcslen(sSid) >= dwArraySizeOfTxtSid)
            _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        wcscpy(txtSid, (WCHAR*)sSid);
        if (!wcscmp(txtSid, L""))
        {
            //get the sid for this domain
            if ( sDomainName[0] != L'\\' )
            {
                rc = GetAnyDcName5(sDomainName, domctrl);
            }
            if ( rc )
                return hr;

            rc = GetDomainSid(domctrl,&pSid);

            if ( !GetTextualSid(pSid,txtSid,&lenTxt) )
            {
                if (pSid)
                    FreeSid(pSid);
                return hr;
            }
            if (pSid)
                FreeSid(pSid);
        }

        //
        // Update source domain SID for all objects from specified source domain.
        //
        // Note that 'hand-constructed' SQL statement is okay here as the inputs
        // are internally generated by ADMT.
        //

        _snwprintf(
            sActionInfo,
            sizeof(sActionInfo) / sizeof(sActionInfo[0]),
            L"UPDATE MigratedObjects SET SourceDomainSid='%s' WHERE SourceDomain='%s'",
            txtSid,
            sDomainName
        );
        sActionInfo[sizeof(sActionInfo) / sizeof(sActionInfo[0]) - 1] = L'\0';

        m_cn->Execute(_bstr_t(sActionInfo), &_variant_t(), adExecuteNoRecords);

        *pbPopulated = VARIANT_TRUE; //set flag since populated
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}
//END PopulateSrcSidColumnByDomain

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 SEPT 2000                                                *
 *                                                                   *
 *     This protected member function of the CIManageDB checks to see*
 * if the new Account SID column is in the Account References table. *
 *                                                                   *
 *********************************************************************/

//BEGIN SidColumnInARTable
STDMETHODIMP CIManageDB::SidColumnInARTable(VARIANT_BOOL *pbFound)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	*pbFound = VARIANT_FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"AccountRefs";
	  long						   numColumns;
	  long						   ndx = 0;
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (*pbFound == VARIANT_FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, L"AccountSid"))
             *pbFound = VARIANT_TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END SidColumnInARTable


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 SEPT 2000                                                *
 *                                                                   *
 *     This protected member function of the CIManageDB adds the     *
 * SID column to the Account Reference table, if it is not already   *
 * there.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateSidColumnInAR
STDMETHODIMP CIManageDB::CreateSidColumnInAR()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"AccountRefs"];
         //append a new column to the end of the MOT
      m_pTable->Columns->Append(L"AccountSid", adVarWChar, COLUMN_MAX_CHARS);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END CreateSidColumnInAR


//---------------------------------------------------------------------------
// UpgradeDatabase
//
// Upgrades Protar.mdb database from version 3.x to 4.x. Version 4.x adds
// UNICODE support.
//
// 2001-02-13 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::UpgradeDatabase(LPCTSTR pszFolder)
{
	try
	{
		_bstr_t strFolder = pszFolder;
		_bstr_t strDatabase = strFolder + _T("Protar.mdb");
		_bstr_t strDatabase3x = strFolder + _T("Protar3x.mdb");
		_bstr_t strDatabase4x = strFolder + _T("Protar4x.mdb");

		_bstr_t strConnectionPrefix = _T("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=");
		_bstr_t strSourceConnection = strConnectionPrefix + strDatabase;
		_bstr_t strTargetConnection = strConnectionPrefix + strDatabase4x + _T(";Jet OLEDB:Engine Type=5");

		IJetEnginePtr spJetEngine(__uuidof(JetEngine));

		HRESULT hr = spJetEngine->raw_CompactDatabase(strSourceConnection, strTargetConnection);

		if (FAILED(hr))
		{
			AdmtThrowError(
				hr,
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_TO_TEMPORARY,
				(LPCTSTR)strDatabase,
				(LPCTSTR)strDatabase4x
			);
		}

		if (!MoveFileEx(strDatabase, strDatabase3x, MOVEFILE_WRITE_THROUGH))
		{
			DWORD dwError = GetLastError();

			DeleteFile(strDatabase4x);

			AdmtThrowError(
				HRESULT_FROM_WIN32(dwError),
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_RENAME_ORIGINAL,
				(LPCTSTR)strDatabase,
				(LPCTSTR)strDatabase3x
			);
		}

		if (!MoveFileEx(strDatabase4x, strDatabase, MOVEFILE_WRITE_THROUGH))
		{
			DWORD dwError = GetLastError();

			MoveFileEx(strDatabase3x, strDatabase, MOVEFILE_WRITE_THROUGH);
			DeleteFile(strDatabase4x);

			AdmtThrowError(
				HRESULT_FROM_WIN32(dwError),
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_RENAME_UPGRADED,
				(LPCTSTR)strDatabase4x,
				(LPCTSTR)strDatabase
			);
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(ce, _Module.GetResourceInstance(), IDS_E_UPGRADE_TO_4X);
	}
	catch (...)
	{
		AdmtThrowError(E_FAIL, _Module.GetResourceInstance(), IDS_E_UPGRADE_TO_4X);
	}
}


//---------------------------------------------------------------------------
// UpdateDomainAndServerColumnWidths
//
// Synopsis
// Updates column widths that hold domain or server names to the maximum
// supported column width of 255 characters which is also the maximum length
// of a DNS name.
//
// Arguments
// IN spConnection - a pointer to a connection interface for the
//                   Protar database
//
// Return Value
// None - if an error occurs an exception is thrown.
//
// 2002-06-22 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::UpdateDomainAndServerColumnWidths(_ConnectionPtr spConnection)
{
    static struct SColumnData
    {
        PCTSTR pszTableName;
        PCTSTR pszColumnName;
        PCTSTR pszIndexName;
    }
    s_ColumnData[] =
    {
        { _T("DistributedAction"), _T("ServerName"),   _T("PrimaryKey") },
        { _T("PasswordAge"),       _T("DomainName"),   _T("Domain")     },
        { _T("SourceAccounts"),    _T("Domain"),       _T("PrimaryKey") },
        { _T("TargetAccounts"),    _T("Domain"),       _T("PrimaryKey") },
        { _T("UserProps"),         _T("SourceDomain"), _T("PrimaryKey") },
    };
    const int cColumnData = sizeof(s_ColumnData) / sizeof(s_ColumnData[0]);
    const _TCHAR TEMPORARY_COLUMN_NAME[] = _T("TemporaryColumn");
    const long MAX_COLUMN_SIZE = 255l;

    try
    {
        //
        // For each specified column verify column size and increase size
        // if size is less than the maximum.
        //

        ADOX::_CatalogPtr spCatalog(__uuidof(ADOX::Catalog));
        spCatalog->PutRefActiveConnection(IDispatchPtr(spConnection));
        ADOX::TablesPtr spTables = spCatalog->Tables;

        bool bColumnsUpdated = false;

        for (int iColumnData = 0; iColumnData < cColumnData; iColumnData++)
        {
            //
            // If the current column's defined size is less than the
            // maximum column size then the column width must be increased.
            //

            SColumnData& data = s_ColumnData[iColumnData];

            PCTSTR pszTableName = data.pszTableName;
            PCTSTR pszColumnName = data.pszColumnName;
            PCTSTR pszIndexName = data.pszIndexName;

            ADOX::_TablePtr spTable = spTables->Item[pszTableName];
            ADOX::ColumnsPtr spColumns = spTable->Columns;
            ADOX::_ColumnPtr spOldColumn = spColumns->Item[pszColumnName];

            if (spOldColumn->DefinedSize < MAX_COLUMN_SIZE)
            {
                //
                // Create a new column with a temporary name. Assign the old column's type and attributes
                // values to the new column. Set the new column's defined size equal to the maximum. Add
                // the new column to the table.
                //
                // Note that a new column must be created in order to increase the column width.
                //

                ADOX::_ColumnPtr spNewColumn(__uuidof(ADOX::Column));
                spNewColumn->Name = TEMPORARY_COLUMN_NAME;
                spNewColumn->Type = spOldColumn->Type;
                spNewColumn->Attributes = spOldColumn->Attributes;
                spNewColumn->DefinedSize = MAX_COLUMN_SIZE;
                spColumns->Append(_variant_t(IDispatchPtr(spNewColumn).GetInterfacePtr()), adVarWChar, 0);

                //
                // Set the new column's values equal to the old column's values.
                //

                _TCHAR szCommandText[256];
                const size_t cchCommandText = sizeof(szCommandText) / sizeof(szCommandText[0]);
                szCommandText[cchCommandText - 1] = _T('\0');
                int cchStored = _sntprintf(
                    szCommandText,
                    cchCommandText,
                    _T("UPDATE [%s] SET [%s] = [%s]"),
                    pszTableName,
                    TEMPORARY_COLUMN_NAME,
                    pszColumnName
                );

                if ((cchStored < 0) || (szCommandText[cchCommandText - 1] != _T('\0')))
                {
                    _ASSERT(FALSE);
                    _com_issue_error(E_FAIL);
                }

                szCommandText[cchCommandText - 1] = _T('\0');

                m_cn->Execute(szCommandText, &_variant_t(), adExecuteNoRecords);

                //
                // Create new index. Assign old index's property values
                // to new index including column names. Delete old index.
                //
                // Note that the old index must be deleted before deleting the old column.
                //

                ADOX::IndexesPtr spIndexes = spTable->Indexes;
                ADOX::_IndexPtr spOldIndex = spIndexes->Item[pszIndexName];
                ADOX::_IndexPtr spNewIndex(__uuidof(ADOX::Index));
                spNewIndex->Name = spOldIndex->Name;
                spNewIndex->Unique = spOldIndex->Unique;
                spNewIndex->PrimaryKey = spOldIndex->PrimaryKey;
                spNewIndex->IndexNulls = spOldIndex->IndexNulls;
                spNewIndex->Clustered = spOldIndex->Clustered;

                ADOX::ColumnsPtr spOldIndexColumns = spOldIndex->Columns;
                ADOX::ColumnsPtr spNewIndexColumns = spNewIndex->Columns;
                long cColumn = spOldIndexColumns->Count;

                for (long iColumn = 0; iColumn < cColumn; iColumn++)
                {
                    ADOX::_ColumnPtr spOldColumn = spOldIndexColumns->Item[iColumn];
                    spNewIndexColumns->Append(spOldColumn->Name, adVarWChar, 0);
                }

                spIndexes->Delete(pszIndexName);

                //
                // Delete old column and rename new column.
                //

                spOldColumn.Release();
                spColumns->Delete(_variant_t(pszColumnName));
                spNewColumn->Name = pszColumnName;

                //
                // Add the new index to the table.
                //
                // Note that the index must be added after renaming new column.
                //

                spIndexes->Append(_variant_t(IDispatchPtr(spNewIndex).GetInterfacePtr()));

                //
                // Set columns updated to true so that domain names will also be updated.
                //

                bColumnsUpdated = true;
            }
        }

        spTables.Release();
        spCatalog.Release();

        //
        // If columns have been updated then update domain names.
        //

        if (bColumnsUpdated)
        {
            UpdateDomainNames();
        }
    }
    catch (_com_error& ce)
    {
        AdmtThrowError(ce, _Module.GetResourceInstance(), IDS_E_UNABLE_TO_UPDATE_COLUMNS);
    }
    catch (...)
    {
        AdmtThrowError(E_FAIL, _Module.GetResourceInstance(), IDS_E_UNABLE_TO_UPDATE_COLUMNS);
    }
}


//---------------------------------------------------------------------------
// UpdateDomainNames
//
// Synopsis
// Updates domain names from NetBIOS name to DNS name.
//
// Arguments
// None
//
// Return Value
// None - if an error occurs an exception is thrown.
//
// 2002-09-15 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::UpdateDomainNames()
{
    //
    // AccountRefs     - account references report is sorted on domain name
    //                   therefore must update to keep old and new records
    //                   together
    // Conflict        - table not used
    // MigratedObjects - domain name is used to query for previously migrated
    //                   objects therefore must update
    // PasswordAge     - domain name is used to update records therefore must
    //                   update
    // SourceAccounts  - generation of name conflicts report clears table
    //                   therefore not necessary to update
    // TargetAccounts  - generation of name conflicts report clears table
    //                   therefore not necessary to update
    // UserProps       - domain name used to delete records therefore must
    //                   update
    //

    static struct STableColumnData
    {
        PCTSTR pszTableName;
        PCTSTR pszColumnName;
    }
    s_TableColumnData[] =
    {
        { _T("AccountRefs"),     _T("DomainName")   },
    //  { _T("Conflict"),        _T("Domain")       },
        { _T("MigratedObjects"), _T("SourceDomain") },
        { _T("MigratedObjects"), _T("TargetDomain") },
        { _T("PasswordAge"),     _T("DomainName")   },
    //  { _T("SourceAccounts"),  _T("Domain")       },
    //  { _T("TargetAccounts"),  _T("Domain")       },
        { _T("UserProps"),       _T("SourceDomain") },
    };
    const int cTableColumnData = sizeof(s_TableColumnData) / sizeof(s_TableColumnData[0]);

    //
    // For each domain name column...
    //

    for (int iTableColumnData = 0; iTableColumnData < cTableColumnData; iTableColumnData++)
    {
        STableColumnData& data = s_TableColumnData[iTableColumnData];

        PCTSTR pszTableName = data.pszTableName;
        PCTSTR pszColumnName = data.pszColumnName;

        //
        // Retrieve unique domain names from column.
        //

        _RecordsetPtr spRecords = QueryUniqueColumnValues(pszTableName, pszColumnName);

        FieldPtr spField = spRecords->Fields->Item[0L];

        while (spRecords->EndOfFile == VARIANT_FALSE)
        {
            _bstr_t strDomain = spField->Value;

            //
            // If domain name is not a DNS name...
            //

            if ((PCTSTR)strDomain && (_tcschr(strDomain, _T('.')) == NULL))
            {
                //
                // Attempt to retrieve DNS name of domain. First attempt to retrieve domain
                // names using DC locator APIs. If this fails then attempt to retrieve
                // domain names from ActionHistory table.
                //

                _bstr_t strDnsName;
                _bstr_t strFlatName;

                DWORD dwError = GetDomainNames5(strDomain, strFlatName, strDnsName);

                if (dwError != ERROR_SUCCESS)
                {
                    IUnknownPtr spunk;

                    HRESULT hr = GetSourceDomainInfo(strDomain, &spunk);

                    if (SUCCEEDED(hr))
                    {
                        IVarSetPtr spVarSet = spunk;

                        if (spVarSet)
                        {
                            strDnsName = spVarSet->get(_T("Options.SourceDomainDns"));
                        }
                    }
                }

                //
                // If a DNS name has been retrieved...
                //

                if ((PCTSTR)strDnsName)
                {
                    //
                    // Replace NetBIOS name with DNS name for all records in table.
                    //

                    UpdateColumnValues(pszTableName, pszColumnName, 255, strDomain, strDnsName);
                }
            }

            spRecords->MoveNext();
        }
    }
}


//---------------------------------------------------------------------------
// QueryUniqueColumnValues
//
// Synopsis
// Retrieves a set of values which are unique in the specified column in the
// specified table.
//
// Note that a forward only, read only recordset is returned.
//
// Arguments
// IN pszTable  - table name
// IN pszColumn - column name
//
// Return Value
// _RecordsetPtr - a forward only, read only recordset
//
// 2002-09-15 Mark Oluper - initial
//---------------------------------------------------------------------------

_RecordsetPtr CIManageDB::QueryUniqueColumnValues(PCTSTR pszTable, PCTSTR pszColumn)
{
    //
    // Generate select query.
    //
    // Note that the GROUP BY clause generates a result set containing only unique values.
    //

    _TCHAR szCommandText[256];

    szCommandText[DIM(szCommandText) - 1] = _T('\0');

    int cchStored = _sntprintf(
        szCommandText, DIM(szCommandText),
        _T("SELECT [%s] FROM [%s] GROUP BY [%s];"),
        pszColumn, pszTable, pszColumn
    );

    if ((cchStored < 0) || (szCommandText[DIM(szCommandText) - 1] != _T('\0')))
    {
        _ASSERT(FALSE);
        _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    szCommandText[DIM(szCommandText) - 1] = _T('\0');

    //
    // Retrieve unique values from column.
    //

    _RecordsetPtr spRecords(__uuidof(Recordset));

    spRecords->Open(_variant_t(szCommandText), m_vtConn, adOpenForwardOnly, adLockReadOnly, adCmdText);

    return spRecords;
}


//---------------------------------------------------------------------------
// UpdateColumnValues
//
// Synopsis
// Updates values in specified column in specified table. Sets the value to
// specified value B where value equals specified value A. Note that the only
// data type supported are strings.
//
// Arguments
// IN pszTable  - table name
// IN pszColumn - column name
// IN nWidth    - column width
// IN pszValueA - string value A
// IN pszValueB - string value B
//
// Return Value
// None - if an error occurs an exception is thrown.
//
// 2002-09-15 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::UpdateColumnValues
    (
        PCTSTR pszTable, PCTSTR pszColumn, int nWidth, PCTSTR pszValueA, PCTSTR pszValueB
    )
{
    //
    // Generate parameterized update query.
    //

    _TCHAR szCommandText[256];

    szCommandText[DIM(szCommandText) - 1] = _T('\0');

    int cchStored = _sntprintf(
        szCommandText, DIM(szCommandText),
        _T("PARAMETERS A Text ( %d ), B Text ( %d ); ")
        _T("UPDATE [%s] SET [%s]=[B] WHERE [%s]=[A];"),
        nWidth, nWidth,
        pszTable, pszColumn, pszColumn
    );

    if ((cchStored < 0) || (szCommandText[DIM(szCommandText) - 1] != _T('\0')))
    {
        _ASSERT(FALSE);
        _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    szCommandText[DIM(szCommandText) - 1] = _T('\0');

    //
    // Update values.
    //

    _CommandPtr spCommand(__uuidof(Command));

    spCommand->ActiveConnection = m_cn;
    spCommand->CommandType = adCmdText;
    spCommand->CommandText = szCommandText;

    ParametersPtr spParameters = spCommand->Parameters;
    spParameters->Append(spCommand->CreateParameter(L"A", adBSTR, adParamInput, nWidth, _variant_t(pszValueA)));
    spParameters->Append(spCommand->CreateParameter(L"B", adBSTR, adParamInput, nWidth, _variant_t(pszValueB)));

    spCommand->Execute(NULL, NULL, adExecuteNoRecords);
}


//---------------------------------------------------------------------------------------------
// GetMigratedObjectByType : Given the type of object this function retrieves info about
//                           all previously migrated objects of this type.  The scope of the 
//							 search can be limited by optional ActionID (not -1) or optional
//							 source domain (not empty).
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjectByType(long lActionID, BSTR sSrcDomain, BSTR sType, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
	  _bstr_t					   sTypeQuery;
      
      // If the type parameter is not correct then we need to return an error
      if (wcslen((WCHAR*)sType) == 0)
         _com_issue_error(E_INVALIDARG);

	     //we now store the group type as "ggroup", "lgroup", "ugroup" and we need to allow
	     //for lookup based on any of these three and also "group", which will be any of them
	  if (_wcsicmp((WCHAR*)sType, L"group") == 0)
		 sTypeQuery = L"Type = 'group' OR Type = 'ggroup' OR Type = 'lgroup' OR Type = 'ugroup'";
	  else if (_wcsicmp((WCHAR*)sType, L"ggroup") == 0)
		 sTypeQuery = L"Type = 'ggroup'";
	  else if (_wcsicmp((WCHAR*)sType, L"lgroup") == 0)
		 sTypeQuery = L"Type = 'lgroup'";
	  else if (_wcsicmp((WCHAR*)sType, L"ugroup") == 0)
		 sTypeQuery = L"Type = 'ugroup'";
	  else
	  {
		 sTypeQuery = L"Type = '";
		 sTypeQuery += sType;
		 sTypeQuery += L"'";
	  }

         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects of the specified type.
      if ( lActionID != -1 )
      {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where ActionID = %d AND (%s) Order by Time", lActionID, (WCHAR*)sTypeQuery);
      }
	     //else if source domain specified, get objects of the specified type from that domain
	  else if (wcslen((WCHAR*)sSrcDomain) != 0)
	  {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND (%s) Order by Time", sSrcDomain, (WCHAR*)sTypeQuery);
	  }
	  else  //else get all objects of the specified type
	  {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where %s Order by Time", (WCHAR*)sTypeQuery);
	  }

      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetAMigratedObjectBySidAndRid : Given a source domain Sid and account Rid this function 
//                           retrieves info about that migrated object, if any.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObjectBySidAndRid(BSTR sSrcDomainSid, BSTR sRid, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      
      // If the type parameter is not correct then we need to return an error
      if ((wcslen((WCHAR*)sSrcDomainSid) == 0) || (wcslen((WCHAR*)sRid) == 0))
         _com_issue_error(E_INVALIDARG);

	  int nRid = _wtoi(sRid);

      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomainSid=\"%s\" AND SourceRid=%d Order by Time", sSrcDomainSid, nRid);
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
			 //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			 //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			 //code still expects "group" returned (only GetMigratedObjectByType will return this new
			 //delineation
	      _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
		  if (wcsstr((WCHAR*)sType, L"group"))
		     sType = L"group";
	      pVs->put(sActionInfo, sType);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 MAR 2001                                                 *
 *                                                                   *
 *     This private member function of the CIManageDB checks to see  *
 * if the "Description" column in the Source Accounts table has been *
 * changed to "RDN".  If so, then we have modified both the Source   *
 * and Target Accounts tables for the new form of the "Name Conflict"*
 * report.                                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN NCTablesColumnsChanged
BOOL CIManageDB::NCTablesColumnsChanged(BOOL bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;
	BOOL bFound = FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
	  long						   numColumns;
	  long						   ndx = 0;

	  if (bSource)
	     vtSource = L"SourceAccounts";
	  else
	     vtSource = L"TargetAccounts";
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (bFound == FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, L"RDN"))
             bFound = TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return bFound;
}
//END NCTablesColumnsChanged


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 MAR 2001                                                 *
 *                                                                   *
 *     This private member function of the CIManageDB modifies       *
 * several of the columns in the Source and Target Accounts tables.  *
 * It changes several column names and one column type to support new*
 * changes to the "Name Conflict" report.                            *
 *                                                                   *
 *********************************************************************/

//BEGIN ChangeNCTableColumns
HRESULT CIManageDB::ChangeNCTableColumns(BOOL bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	try
	{
	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's Source or Target Accounts Table
	  if (bSource)
         m_pTable = m_pCatalog->Tables->Item[L"SourceAccounts"];
	  else
         m_pTable = m_pCatalog->Tables->Item[L"TargetAccounts"];

	  if (m_pTable)
	  {
	        //remove the old Description column
         m_pTable->Columns->Delete(L"Description");
	        //remove the old FullName column
         m_pTable->Columns->Delete(L"FullName");
            //append the RDN column to the end of the Table
         m_pTable->Columns->Append(L"RDN", adVarWChar, COLUMN_MAX_CHARS);
            //append the Canonical Name column to the end of the Table
         m_pTable->Columns->Append(L"Canonical Name", adLongVarWChar, COLUMN_MAX_CHARS);
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END ChangeNCTableColumns


//---------------------------------------------------------------------------------------------
// GetMigratedObjectsByTarget : Retrieves information about previously migrated objects with
//                      a given target domain and SAM name.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjectsByTarget(BSTR sTargetDomain, BSTR sTargetSAM, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a particular target domain and SAM name . This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      wsprintf(sActionInfo, L"Select * from MigratedObjects where TargetDomain=\"%s\" AND TargetSamName=\"%s\"", sTargetDomain, sTargetSAM); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			    //ADMT V2.0 now stores a group's type, in the migrated objects table, not all as 
			    //"group", as in ADMT V1.0, but now as "ggroup", "lgroup", or ""ugroup".  But most the
			    //code still expects "group" returned (only GetMigratedObjectByType will return this new
			    //delineation
	         _bstr_t sType = pRs->Fields->GetItem(L"Type")->Value;
		     if (wcsstr((WCHAR*)sType, L"group"))
		        sType = L"group";
	         pVs->put(sActionInfo, sType);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//---------------------------------------------------------------------------
// GetSourceDomainInfo Method
//
// Method attempts to retrieve source domain information from the action
// history table. The action history table contains values for the source
// domain's flat (NetBIOS) name, DNS name and SID.
//---------------------------------------------------------------------------

STDMETHODIMP CIManageDB::GetSourceDomainInfo(BSTR sSourceDomainName, IUnknown** ppunkVarSet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		*ppunkVarSet = NULL;

		_bstr_t strName(sSourceDomainName);

		if (strName.length())
		{
			bool bFound = false;

			//
			// retrieve current action ID from the System table because records
			// in the ActionHistory table having this value represent the latest
			// information in the action history table
			//

			_RecordsetPtr spSystem(__uuidof(Recordset));

			spSystem->Open(_variant_t(_T("System")), m_vtConn, adOpenStatic, adLockReadOnly, adCmdTable);

			long lCurrentActionId = spSystem->Fields->GetItem(_T("CurrentActionID"))->Value;

			spSystem->Close();

			//
			// retrieve source domain information from action history table
			//

			// the following query statement joins the ActionHistory table with
			// itself in order to create a set of records of the following form
			//
			//		ActionID, DnsName, FlatName, Sid
			//
			// this makes it easier and more efficient to find a record
			// containing the source domain information of interest

			static _TCHAR c_szSource[] =
				_T("SELECT A.ActionID AS ActionID, A.Value AS DnsName, B.Value AS FlatName, C.Value AS Sid ")
				_T("FROM (ActionHistory AS A ")
				_T("INNER JOIN ActionHistory AS B ON A.ActionID = B.ActionID) ")
				_T("INNER JOIN ActionHistory AS C ON B.ActionID = C.ActionID ")
				_T("WHERE A.Property='Options.SourceDomainDns' ")
				_T("AND B.Property='Options.SourceDomain' ")
				_T("AND C.Property='Options.SourceDomainSid' ")
				_T("ORDER BY A.ActionID");

			// open read only snapshot of records

			_RecordsetPtr spActionId(__uuidof(Recordset));

			spActionId->Open(_variant_t(c_szSource), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

			// if records found...

			if ((spActionId->BOF == VARIANT_FALSE) && (spActionId->EndOfFile == VARIANT_FALSE))
			{
				IVarSetPtr spVarSet(__uuidof(VarSet));

				FieldsPtr spFields = spActionId->Fields;
				FieldPtr spActionIdField = spFields->Item[_T("ActionID")];
				FieldPtr spDnsNameField = spFields->Item[_T("DnsName")];
				FieldPtr spFlatNameField = spFields->Item[_T("FlatName")];
				FieldPtr spSidField = spFields->Item[_T("Sid")];

				// find record with current action ID
				// this will contain the latest information

				spActionId->MoveLast();

				while ((spActionId->BOF == VARIANT_FALSE) && (long(spActionIdField->Value) != lCurrentActionId))
				{
					spActionId->MovePrevious();
				}

				// if action ID found...

				if (spActionId->BOF == VARIANT_FALSE)
				{
					bool bCheckingLessOrEqual = true;
					_bstr_t str;

					// starting with record with current action ID
					// first check records with action IDs less than or equal to the current action ID
					// then check records with action IDs greater than the current action ID
					// this logic checks records in order from the newest to the oldest
					// and accounts for the fact that action IDs will wrap back to 1 after
					// the maximum action ID has been used

					for (;;)
					{
						// if given name matches DNS name then found

						str = spDnsNameField->Value;

						if (str.length())
						{
							if (_tcsicmp(str, strName) == 0)
							{
								bFound = true;
								break;
							}
						}

						// if given name matches flat name then found

						str = spFlatNameField->Value;

						if (str.length())
						{
							if (_tcsicmp(str, strName) == 0)
							{
								bFound = true;
								break;
							}
						}

						// move to previous record

						spActionId->MovePrevious();

						// if beginning of records is reached...

						if (spActionId->BOF == VARIANT_TRUE)
						{
							// if checking action IDs less than current action ID...

							if (bCheckingLessOrEqual)
							{
								// move to last record and begin checking
								// records with action IDs greater than current
								spActionId->MoveLast();
								bCheckingLessOrEqual = false;
							}
							else
							{
								// otherwise break out of loop as the action ID
								// comparison has failed to stop the loop before
								// reaching the beginning again
								break;
							}
						}

						// check action ID

						long lActionId = spActionIdField->Value;

						// if checking action IDs less than or equal to current

						if (bCheckingLessOrEqual)
						{
							// if action ID is less than or equal to zero

							if (lActionId <= 0)
							{
								// do not process records with action IDs less than or equal
								// to zero as these records are now obsolete and will be deleted

								// move to last record and begin checking records with
								// action IDs greater than current action ID
								spActionId->MoveLast();
								bCheckingLessOrEqual = false;
							}
						}
						else
						{
							// stop checking once current action ID is reached

							if (lActionId <= lCurrentActionId)
							{
								break;
							}
						}
					}

					// if matching record found...

					if (bFound)
					{
						// put information into varset and set output data

						spVarSet->put(_T("Options.SourceDomain"), spFlatNameField->Value);
						spVarSet->put(_T("Options.SourceDomainDns"), spDnsNameField->Value);
						spVarSet->put(_T("Options.SourceDomainSid"), spSidField->Value);

						*ppunkVarSet = IUnknownPtr(spVarSet).Detach();
					}
				}
			}

            //
            // if source domain was not found in the action history table it is very likely
            // that the information has been replaced with subsequent migration task information
            // therefore will try to obtain this information from the migrated objects table
            //

            if (bFound == false)
            {
                //
			    // query for migrated objects from specified source domain and sort by time
                //

			    _RecordsetPtr spObjects(__uuidof(Recordset));

                _bstr_t strSource = _T("SELECT SourceDomain, SourceDomainSid FROM MigratedObjects WHERE SourceDomain='");
                strSource += strName;
                strSource += _T("' ORDER BY Time");

			    spObjects->Open(_variant_t(strSource), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

                //
			    // if migrated objects found...
                //

			    if ((spObjects->BOF == VARIANT_FALSE) && (spObjects->EndOfFile == VARIANT_FALSE))
			    {
				    //
				    // the last record contains the most recent information
                    //

				    spObjects->MoveLast();

                    //
					// set source domain information
                    //
                    // note that the migrated objects table does not have the DNS name
                    // and so the DNS field is set to the flat or NetBIOS name
                    //

				    FieldsPtr spFields = spObjects->Fields;
				    FieldPtr spDomainField = spFields->Item[_T("SourceDomain")];
				    FieldPtr spSidField = spFields->Item[_T("SourceDomainSid")];

                    IVarSetPtr spVarSet(__uuidof(VarSet));

					spVarSet->put(_T("Options.SourceDomain"), spDomainField->Value);
					spVarSet->put(_T("Options.SourceDomainDns"), spDomainField->Value);
					spVarSet->put(_T("Options.SourceDomainSid"), spSidField->Value);

					*ppunkVarSet = IUnknownPtr(spVarSet).Detach();
                }
            }
		}
		else
		{
			hr = E_INVALIDARG;
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//---------------------------------------------------------------------------
// UpdateMigratedTargetObject Method
//
// Method updates target name information based on GUID of target object.
//---------------------------------------------------------------------------

STDMETHODIMP CIManageDB::UpdateMigratedTargetObject(IUnknown* punkVarSet)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        IVarSetPtr spVarSet(punkVarSet);

        _bstr_t strADsPath = spVarSet->get(_T("MigratedObjects.TargetAdsPath"));
        _bstr_t strSamName = spVarSet->get(_T("MigratedObjects.TargetSamName"));
        _bstr_t strGuid = spVarSet->get(_T("MigratedObjects.GUID"));

        _bstr_t strCommandText =
            _T("SELECT TargetAdsPath, TargetSamName FROM MigratedObjects WHERE GUID = '") + strGuid + _T("'");

        _RecordsetPtr spRecordset(__uuidof(Recordset));

        spRecordset->Open(_variant_t(strCommandText), m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

        FieldsPtr spFields = spRecordset->Fields;

        while (spRecordset->EndOfFile == VARIANT_FALSE)
        {
            spFields->Item[_T("TargetAdsPath")]->Value = strADsPath;
            spFields->Item[_T("TargetSamName")]->Value = strSamName;
            spRecordset->Update();
            spRecordset->MoveNext();
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//---------------------------------------------------------------------------
// UpdateMigratedObjectStatus Method
//
// Method updates status of migrated object.
//---------------------------------------------------------------------------

STDMETHODIMP CIManageDB::UpdateMigratedObjectStatus(BSTR bstrGuid, long lStatus)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    USES_CONVERSION;

    HRESULT hr = S_OK;

    try
    {
        _TCHAR szSQL[256];

        _stprintf(
            szSQL,
            _T("UPDATE MigratedObjects SET status = %ld WHERE GUID = '%s'"),
            lStatus,
            OLE2CT(bstrGuid)
        );

        m_cn->Execute(_bstr_t(szSQL), &_variant_t(), adExecuteNoRecords);
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//------------------------------------------------------------------------------
// GetMigratedObjectsForSecurityTranslation Method
//
// Synopsis
// Given the source and target domain's NetBIOS names retrieve the users and
// groups that have been migrated between the given domains. Only data required
// for security translation is retrieved.
//
// Arguments
// IN bstrSourceDomain - source domain's NetBIOS name
// IN bstrTargetDomain - target domain's NetBIOS name
// IN punkVarSet       - the VarSet data structure to be filled in with the
//                       migrated objects data
//
// Return
// HRESULT - S_OK if successful otherwise an error result
//------------------------------------------------------------------------------

STDMETHODIMP CIManageDB::GetMigratedObjectsForSecurityTranslation(BSTR bstrSourceDomain, BSTR bstrTargetDomain, IUnknown* punkVarSet)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    try
    {
        //
        // Validate arguments. A source and target domain must be specified.
        //

        if ((SysStringLen(bstrSourceDomain) == 0) || (SysStringLen(bstrTargetDomain) == 0) || (punkVarSet == NULL))
        {
            _com_issue_error(E_INVALIDARG);
        }

        //
        // Generate SQL query string. Query for user or group objects that
        // have been migrated from the source domain to the target domain.
        //

        _bstr_t strQuery =
            L"SELECT SourceSamName, TargetSamName, Type, SourceRid, TargetRid FROM MigratedObjects "
            L"WHERE SourceDomain = '" + _bstr_t(bstrSourceDomain) +
            L"' AND TargetDomain = '" + _bstr_t(bstrTargetDomain) +
            L"' AND (Type = 'user' OR Type = 'group' OR Type = 'ggroup' OR Type = 'lgroup' OR Type = 'ugroup')";

        //
        // Retrieve data from database and fill in VarSet data structure.
        //

        _RecordsetPtr rs(__uuidof(Recordset));

        rs->Open(_variant_t(strQuery), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

        int nIndex;
        WCHAR szKey[256];
        IVarSetPtr spVarSet(punkVarSet);
        FieldsPtr spFields = rs->Fields;
        FieldPtr spSourceSamField = spFields->Item[L"SourceSamName"];
        FieldPtr spTargetSamField = spFields->Item[L"TargetSamName"];
        FieldPtr spTypeField = spFields->Item[L"Type"];
        FieldPtr spSourceRidField = spFields->Item[L"SourceRid"];
        FieldPtr spTargetRidField = spFields->Item[L"TargetRid"];

        for (nIndex = 0; rs->EndOfFile == VARIANT_FALSE; nIndex++)
        {
            // source object's SAM account name
            wsprintf(szKey, L"MigratedObjects.%d.SourceSamName", nIndex);
            spVarSet->put(szKey, spSourceSamField->Value);

            // target object's SAM account name
            wsprintf(szKey, L"MigratedObjects.%d.TargetSamName", nIndex);      
            spVarSet->put(szKey, spTargetSamField->Value);

            // object type - note that specific group type is translated to generic group type
            wsprintf(szKey, L"MigratedObjects.%d.Type", nIndex);      
            _bstr_t strType = spTypeField->Value;
            spVarSet->put(szKey, ((LPCTSTR)strType && wcsstr(strType, L"group")) ? L"group" : strType);

            // source object's RID
            wsprintf(szKey, L"MigratedObjects.%d.SourceRid", nIndex);      
            spVarSet->put(szKey, spSourceRidField->Value);

            // target object's RID
            wsprintf(szKey, L"MigratedObjects.%d.TargetRid", nIndex);      
            spVarSet->put(szKey, spTargetRidField->Value);

            rs->MoveNext();
        }

        // count of objects returned
        spVarSet->put(L"MigratedObjects", static_cast<long>(nIndex));
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}

//---------------------------------------------------------------------------------------------
// GetDistributedActionStatus Method
//
// Synopsis
// Given the migration task action identifier and the server name return the status of the
// agent dispatch to this server during the specified migration task.
//
// Arguments
// IN  lActionId      - action identifier of the migration task
// IN  bstrServerName - server's NetBIOS name
// OUT plStatus       - the agent status from the migration
//
// Return
// HRESULT - S_OK if successful otherwise an error result
//---------------------------------------------------------------------------------------------

STDMETHODIMP CIManageDB::GetDistributedActionStatus(long lActionId, BSTR bstrServerName, long* plStatus)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    USES_CONVERSION;

    try
    {
        //
        // Validate arguments. A valid action identifier and a server name must be specified.
        //

        if ((lActionId <= 0) || (SysStringLen(bstrServerName) == 0) || (plStatus == NULL))
        {
            _com_issue_error(E_INVALIDARG);
        }

        //
        // Retrieve status for specified action identifier and server.
        //

        _TCHAR szSQL[256];

        int cch = _sntprintf(
            szSQL,
            sizeof(szSQL) / sizeof(szSQL[0]),
            _T("SELECT Status FROM DistributedAction WHERE ActionID=%ld AND ServerName='%s'"),
            lActionId,
            OLE2CT(bstrServerName)
        );
        szSQL[DIM(szSQL) - 1] = L'\0';

        if (cch < 0)
        {
            _com_issue_error(E_FAIL);
        }

        _RecordsetPtr rs(__uuidof(Recordset));

        rs->Open(_variant_t(szSQL), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

        if (rs->EndOfFile == VARIANT_FALSE)
        {
            *plStatus = rs->Fields->Item[0L]->Value;
        }
        else
        {
            *plStatus = 0;
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//---------------------------------------------------------------------------------------------
// GetServerNamesFromActionHistory Method
//
// Synopsis
// Given a server name retrieve the flat and DNS names from the Action History table.
//
// Arguments
// IN  lActionId      - action identifier of the migration task
// IN  bstrServerName - server name (either NetBIOS or DNS)
// OUT pbstrFlatName  - the flat (NetBIOS) name of server
// OUT pbstrDnsName   - the DNS name of server
//
// Return
// HRESULT - S_OK if successful otherwise an error result
//---------------------------------------------------------------------------------------------

STDMETHODIMP CIManageDB::GetServerNamesFromActionHistory(long lActionId, BSTR bstrServerName, BSTR* pbstrFlatName, BSTR* pbstrDnsName)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    HRESULT hr = S_OK;

    USES_CONVERSION;

    try
    {
        //
        // Validate arguments. A valid action identifier and a server name must be specified.
        //

        if ((lActionId <= 0) || (SysStringLen(bstrServerName) == 0) || (pbstrFlatName == NULL) || (pbstrDnsName == NULL))
        {
            _com_issue_error(E_INVALIDARG);
        }

        //
        // Retrieve record from action history table having ActionID field equal to specified
        // action identifier, Property field equal to Servers.# or Servers.#.DnsName where #
        // is an index number and Value field equal to specified server name.
        //

        _TCHAR szCommandText[512];

        int cch = _sntprintf(
            szCommandText,
            DIM(szCommandText),
            _T("SELECT Property, Value FROM ActionHistory ")
            _T("WHERE ActionID = %ld AND Property LIKE 'Servers.%%' AND Value = '%s'"),
            lActionId,
            OLE2CT(bstrServerName)
        );
        szCommandText[DIM(szCommandText) - 1] = L'\0';

        if (cch < 0)
        {
            _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }

        _RecordsetPtr rs(__uuidof(Recordset));

        rs->Open(_variant_t(szCommandText), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

        if (rs->EndOfFile == VARIANT_FALSE)
        {
            _bstr_t strPropertyA = rs->Fields->Item[0L]->Value;
            _bstr_t strValueA = rs->Fields->Item[1L]->Value;

            rs->Close();

            PCWSTR pszPropertyA = strPropertyA;

            if (pszPropertyA)
            {
                //
                // If retrieved Property equals Servers.#.DnsName then query for record
                // having Property equal to Servers.# and retrieve value of Value field
                // which will contain the flat (NetBIOS) name.
                //
                // If retrieved Property equals Servers.# then query for record having
                // Property equal to Servers.#.DnsName and retrieve value of Value field
                // which will contain the DNS name. Note that a record with Property
                // equal to Servers.#.DnsName will not exist for NT4 servers.
                //

                PCWSTR pszDnsName = wcsstr(pszPropertyA, L".DnsName");

                WCHAR szPropertyB[64];

                if (pszDnsName)
                {
                    size_t cch = pszDnsName - pszPropertyA;

                    if (cch >= DIM(szPropertyB))
                    {
                        _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
                    }

                    wcsncpy(szPropertyB, pszPropertyA, cch);
                    szPropertyB[cch] = L'\0';
                }
                else
                {
                    wcscpy(szPropertyB, pszPropertyA);
                    wcscat(szPropertyB, L".DnsName");
                }

                cch = _sntprintf(
                    szCommandText,
                    DIM(szCommandText),
                    _T("SELECT Value FROM ActionHistory ")
                    _T("WHERE ActionID = %ld AND Property = '%s'"),
                    lActionId,
                    szPropertyB
                );
                szCommandText[DIM(szCommandText) - 1] = L'\0';

                if (cch < 0)
                {
                    _com_issue_error(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
                }

                rs->Open(_variant_t(szCommandText), m_vtConn, adOpenStatic, adLockReadOnly, adCmdText);

                if (rs->EndOfFile == VARIANT_FALSE)
                {
                    _bstr_t strValueB = rs->Fields->Item[0L]->Value;

                    if (pszDnsName)
                    {
                        *pbstrFlatName = strValueB.copy();
                        *pbstrDnsName = strValueA.copy();
                    }
                    else
                    {
                        *pbstrFlatName = strValueA.copy();
                        *pbstrDnsName = strValueB.copy();
                    }
                }
                else
                {
                    if (pszDnsName == NULL)
                    {
                        *pbstrFlatName = strValueA.copy();
                        *pbstrDnsName = NULL;
                    }
                    else
                    {
                        _com_issue_error(E_FAIL);
                    }
                }
            }
            else
            {
                _com_issue_error(E_FAIL);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//---------------------------------------------------------------------------
// CreateSettings2Table
//
// Synopsis
// Creates Settings2 table if it doesn't already exist.
//
// The Settings2 table has an identical structure to the Settings table
// except that the Value column is a Memo data type which may hold up to
// 65535 characters instead of the maximum of 255 characters that a Text
// column may hold. Note as well that the data in this table will not be
// deleted and refreshed each migration task unlike the Settings table.
//
// Arguments
// IN spConnection - connection interface to Protar.mdb database
//
// Return Value
// None - generates an exception if a failure occurs.
//
// 2002-10-17 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::CreateSettings2Table(_ConnectionPtr spConnection)
{
    static const _TCHAR s_szTableName[] = _T("Settings2");
    static struct SColumnData
    {
        PCTSTR pszName;
        enum DataTypeEnum dteType;
        enum ADOX::ColumnAttributesEnum caeAttributes;
        long lDefinedSize;
    }
    s_ColumnData[] =
    {
        { _T("Property"), adVarWChar,     ADOX::adColNullable,   255L },
        { _T("VarType"),  adInteger,      ADOX::adColNullable,     0L },
        { _T("Value"),    adLongVarWChar, ADOX::adColNullable, 65535L },
    };
    const size_t cColumnData = sizeof(s_ColumnData) / sizeof(s_ColumnData[0]);

    //
    // Connect to database catalog and verify whether Settings2 table exists.
    //

    ADOX::_CatalogPtr spCatalog(__uuidof(ADOX::Catalog));

    spCatalog->PutRefActiveConnection(IDispatchPtr(spConnection));

    ADOX::TablesPtr spTables = spCatalog->Tables;

    ADOX::_TablePtr spTable;

    HRESULT hr = spTables->get_Item(_variant_t(s_szTableName), &spTable);

    //
    // If table not found then create table.
    //

    if (FAILED(hr))
    {
        if (hr == 0x800A0CC1)	// adErrItemNotFound
        {
            //
            // Create table object, set name and associate with catalog.
            //

            CheckError(spTable.CreateInstance(__uuidof(ADOX::Table)));

            spTable->Name = s_szTableName;
            spTable->ParentCatalog = spCatalog;

            //
            // Create and add columns to table.
            //

            ADOX::ColumnsPtr spColumns = spTable->Columns;

            for (size_t iColumnData = 0; iColumnData < cColumnData; iColumnData++)
            {
                ADOX::_ColumnPtr spColumn(__uuidof(ADOX::Column));

                spColumn->Name = s_ColumnData[iColumnData].pszName;
                spColumn->Type = s_ColumnData[iColumnData].dteType;
                spColumn->Attributes = s_ColumnData[iColumnData].caeAttributes;
                spColumn->DefinedSize = s_ColumnData[iColumnData].lDefinedSize;
                spColumn->ParentCatalog = spCatalog;

                spColumns->Append(_variant_t(IDispatchPtr(spColumn).GetInterfacePtr()), adEmpty, 0);
            }

            //
            // Add table to database.
            //

            spTables->Append(_variant_t(IDispatchPtr(spTable).GetInterfacePtr()));

            //
            // Create primary key index. Note that the table must be added to database
            // before the columns in the table may be added to the index.
            //

            ADOX::_IndexPtr spIndex(__uuidof(ADOX::Index));

            spIndex->Name = _T("PrimaryKey");

            spIndex->Unique = VARIANT_TRUE;
            spIndex->PrimaryKey = VARIANT_TRUE;
            spIndex->IndexNulls = ADOX::adIndexNullsAllow;

            ADOX::ColumnsPtr spIndexColumns = spIndex->Columns;

            spIndexColumns->Append(_variant_t(s_ColumnData[0].pszName), adVarWChar, 0);

            ADOX::IndexesPtr spIndexes = spTable->Indexes;

            spIndexes->Append(_variant_t(IDispatchPtr(spIndex).GetInterfacePtr()));

            //
            // Add excluded system properties set and excluded system properties records.
            //
            // The excluded system properties set value is initialized to false so that
            // list of excluded system properties will be generated.
            //

            spConnection->Execute(
                _T("INSERT INTO Settings2 (Property, VarType, [Value]) ")
                _T("VALUES ('AccountOptions.ExcludedSystemPropsSet', 3, '0');"),
                NULL,
                adCmdText|adExecuteNoRecords
            );

            _CommandPtr spCommand(__uuidof(Command));

            spCommand->ActiveConnection = spConnection;
            spCommand->CommandType = adCmdText;
            spCommand->CommandText =
                _T("INSERT INTO Settings2 (Property, VarType, [Value]) ")
                _T("VALUES ('AccountOptions.ExcludedSystemProps', 8, '');");

            spCommand->Execute(NULL, NULL, adExecuteNoRecords);
        }
        else
        {
            AdmtThrowError(hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\mgedb.h ===
// IManageDB.h : Declaration of the CIManageDB

#ifndef __IMANAGEDB_H_
#define __IMANAGEDB_H_

#include "resource.h"       // main symbols
#include "EaLen.hpp"
#include "TReg.hpp"
#include "Err.hpp"
#include "ResStr.h"
#include "folders.h"

using namespace nsFolders;

//#import "\bin\mcsvarsetmin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "msado21.tlb" no_namespace no_implementation rename("EOF", "EndOfFile")
#import "msadox.dll" no_implementation exclude("DataTypeEnum")
//#import <msjro.dll> no_namespace no_implementation

const _bstr_t                sKeyBase      = REGKEY_ADMT;

/////////////////////////////////////////////////////////////////////////////
// CIManageDB

typedef struct x
{
   _bstr_t                   sReportName;
   _bstr_t                   arReportFields[10];
   int                       arReportSize[10];
   int                       colsFilled;
} reportStruct;


class ATL_NO_VTABLE CIManageDB : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CIManageDB, &CLSID_IManageDB>,
    public ISupportErrorInfoImpl<&IID_IIManageDB>,
    public IDispatchImpl<IIManageDB, &IID_IIManageDB, &LIBID_DBMANAGERLib>
{
public:
    CIManageDB();
    ~CIManageDB();

    HRESULT FinalConstruct();
    void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_IMANAGEDB)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIManageDB)
    COM_INTERFACE_ENTRY(IIManageDB)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// IIManageDB
public:
    STDMETHOD(GetUserProps)(/*[in]*/ BSTR sDom, /*[in]*/ BSTR sSam, /*[in,out]*/ IUnknown ** ppVs);
    STDMETHOD(SaveUserProps)(IUnknown * pVs);
    STDMETHOD(GetMigratedObjectBySourceDN)(/*[in]*/ BSTR sSourceDN, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetActionHistoryKey)(/*[in]*/ long lActionID, /*[in]*/ BSTR sKeyName, /*[in,out]*/ VARIANT * pVar);
    STDMETHOD(AreThereAnyMigratedObjects)(/*[out]*/ long * count);
    STDMETHOD(CloseAccountsTable)();
    STDMETHOD(OpenAccountsTable)(/*[in]*/ LONG bSource);
    STDMETHOD(AddSourceObject)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sSAMName, /*[in]*/ BSTR sType, /*[in]*/ BSTR sRDN, /*[in]*/ BSTR sCanonicalName, /*[in]*/ LONG bSource);
    STDMETHOD(AddAcctRef)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sAcct, /*[in]*/ BSTR sAcctSid, /*[in]*/ BSTR sComp, /*[in]*/ long lCount, /*[in]*/ BSTR sType);
    STDMETHOD(CancelDistributedAction)(/*[in]*/ long lActionID, /*[in]*/ BSTR sComp);
    STDMETHOD(SetDistActionStatus)(/*[in]*/ long lActionID, /*[in]*/ BSTR sComp, /*[in]*/ long lStatus, BSTR sText);
    STDMETHOD(SetServiceAcctEntryStatus)(/*[in]*/ BSTR sComp, /*[in]*/ BSTR sSvc, /*[in]*/ BSTR sAcct, /*[in]*/ long Status);
    STDMETHOD(GetPasswordAge)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sComp, /*[out]*/ BSTR * sDesc, /*[out]*/ long * lAge, /*[out]*/ long *lTime);
    STDMETHOD(SavePasswordAge)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sComp, /*[in]*/ BSTR sDesc, /*[in]*/ long lAge);
    STDMETHOD(GetServiceAccount)(/*[in]*/ BSTR Account, /*[in,out]*/ IUnknown ** pUnk);
    STDMETHOD(SetServiceAccount)(/*[in]*/ BSTR System, /*[in]*/ BSTR Service, /*[in]*/ BSTR ServiceDisplayName,/*[in]*/ BSTR Account);
    STDMETHOD(GetFailedDistributedActions)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** pUnk);
    STDMETHOD(AddDistributedAction)(/*[in]*/ BSTR sServerName, /*[in]*/ BSTR sResultFile, /*[in]*/ long lStatus, BSTR sText);
    STDMETHOD(GenerateReport)(/*[in]*/ BSTR sReportName, /*[in]*/ BSTR sFileName, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sTgtDomain, /*[in]*/ LONG bSourceNT4);
    STDMETHOD(GetAMigratedObject)(/*[in]*/ BSTR sSrcSamName, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sTgtDomain, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetCurrentActionID)(/*[out]*/ long * pActionID);
    STDMETHOD(ClearSCMPasswords)();
    STDMETHOD(GetSCMPasswords)(/*[out]*/ IUnknown ** ppUnk);
    STDMETHOD(SaveSCMPasswords)(/*[in]*/ IUnknown * pUnk);
    STDMETHOD(GetRSForReport)(/*[in]*/ BSTR sReport, /*[out,retval]*/ IUnknown ** pprsData);
    STDMETHOD(GetMigratedObjects)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(SaveMigratedObject)(/*[in]*/ long lActionID, /*[in]*/ IUnknown * pUnk);
    STDMETHOD(GetNextActionID)(/*[out]*/ long * pActionID);
    STDMETHOD(GetActionHistory)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(SetActionHistory)(/*[in]*/ long lActionID, /*[in]*/ IUnknown * pUnk);
    STDMETHOD(GetSettings)(/*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetVarsetFromDB)(/*[in]*/ BSTR sTable, /*[in,out]*/ IUnknown ** ppVarset, /*[in,optional]*/ VARIANT ActionID = _variant_t(-1L));
    STDMETHOD(SaveSettings)(/*[in]*/ IUnknown * pUnk );
    STDMETHOD(ClearTable)(/*[in]*/ BSTR sTableName, /*[in,optional]*/ VARIANT Filter = _variant_t(L""));
    STDMETHOD(SetVarsetToDB)(/*[in]*/ IUnknown * pUnk, /*[in]*/ BSTR sTableName, /*[in,optional]*/ VARIANT ActionID = _variant_t(-1L));
    STDMETHOD(GetAMigratedObjectToAnyDomain)(/*[in]*/ BSTR sSrcSamName, /*[in]*/ BSTR sSrcDomain, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(SrcSidColumnInMigratedObjectsTable)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
    STDMETHOD(GetMigratedObjectsFromOldMOT)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(CreateSrcSidColumnInMOT)(/*[out, retval]*/ VARIANT_BOOL * pbCreated);
    STDMETHOD(PopulateSrcSidColumnByDomain)(/*[in]*/ BSTR sDomainName, /*[in]*/ BSTR sSid, /*[out, retval]*/ VARIANT_BOOL * pbPopulated);
    STDMETHOD(DeleteSrcSidColumnInMOT)(/*[out, retval]*/ VARIANT_BOOL * pbDeleted);
    STDMETHOD(GetMigratedObjectsWithSSid)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(CreateSidColumnInAR)();
    STDMETHOD(SidColumnInARTable)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
    STDMETHOD(GetMigratedObjectByType)(/*[in]*/ long lActionID, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sType, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetAMigratedObjectBySidAndRid)(/*[in]*/ BSTR sSrcDomainSid, /*[in]*/ BSTR sRid, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetMigratedObjectsByTarget)(/*[in]*/ BSTR sTargetDomain, /*[in]*/ BSTR sTargetSAM, /*[in,out]*/ IUnknown ** ppUnk);
    STDMETHOD(GetSourceDomainInfo)(/*[in]*/ BSTR sSourceDomainName, /*[out,retval]*/ IUnknown** ppunkVarSet);
    STDMETHOD(UpdateMigratedTargetObject)(/*[in]*/ IUnknown* punkVarSet);
    STDMETHOD(UpdateMigratedObjectStatus)(BSTR bstrGuid, long lStatus);
    STDMETHOD(GetMigratedObjectsForSecurityTranslation)(BSTR bstrSourceDomain, BSTR bstrTargetDomain, IUnknown* punkVarSet);
    STDMETHOD(GetDistributedActionStatus)(long lActionId, BSTR bstrServerName, long* plStatus);
    STDMETHOD(GetServerNamesFromActionHistory)(long lActionId, BSTR bstrServerName, BSTR* pbstrFlatName, BSTR* pbstrDnsName);
protected:
    HRESULT PutVariantInDB( _RecordsetPtr pRs, _variant_t val );
    HRESULT GetVarFromDB(_RecordsetPtr pRec, _variant_t& val);
    void UpgradeDatabase(LPCTSTR pszFolder);
    void UpdateDomainAndServerColumnWidths(_ConnectionPtr spConnection);
    void UpdateDomainNames();
    _RecordsetPtr QueryUniqueColumnValues(PCTSTR pszTable, PCTSTR pszColumn);
    void UpdateColumnValues(PCTSTR pszTable, PCTSTR pszColumn, int nWidth, PCTSTR pszValueA, PCTSTR pszValueB);
    void CreateSettings2Table(_ConnectionPtr spConnection);
private:
    void RestoreVarset(IVarSetPtr pVS);
    void ClipVarset(IVarSetPtr pVS);
    HRESULT ChangeNCTableColumns(BOOL bSource);
    BOOL NCTablesColumnsChanged(BOOL bSource);
   _ConnectionPtr            m_cn;
   _variant_t                m_vtConn;
   void SetActionIDInMigratedObjects(_bstr_t sFilter);
   IVarSetPtr                m_pQueryMapping;
   _RecordsetPtr             m_rsAccounts;
};

#endif //__IMANAGEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4146 )

#ifdef _DEBUG
//#define _ATL_DEBUG_INTERFACES
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dbmgr\stringconversion.h ===
#pragma once

#include <comutil.h>

//----------------------------------------------------------------------------
// Function:   EscapeSpecialChars
//
// Synopsis:   This function escapes special characters '<' and '>' in HTML.
//             It replaces '<' with "&#60" and '>' with "&#62".  The purpose
//             is to prevent embedded active content.
//
// Arguments:
//
// pszOrig     the original unicode string which could contain '<' and '>'.
//
// Returns:    returns an escaped sequence; if out of memory, an empty string
//             will be returned.
//
// Modifies:
//
//----------------------------------------------------------------------------

_bstr_t EscapeSpecialChars(LPCWSTR pszOrig)
{
    _bstr_t result = L"";
    if (pszOrig != NULL)
    {
        static WCHAR specialChars[] = L"<>";
        static WCHAR* replacements[] = { L"&#60", L"&#62" };
        const int increments = 3;
        const int copyLen = increments + 1;       

        int origLen = wcslen(pszOrig);
        const WCHAR* pWChar = pszOrig;
        int numOfSpecialChars = 0;

        // find out how many special characters we have
        while (*pWChar)
        {
            if (wcschr(specialChars, *pWChar))
                numOfSpecialChars++;
            pWChar++;
        }

        // replace each angle bracket with the corresponding special sequence
        WCHAR* outputBuffer = new WCHAR[origLen + increments * numOfSpecialChars + 1];
        WCHAR* outputString = outputBuffer;
        if (outputString)
        {
            pWChar = pszOrig;
            WCHAR* pMatch;
            while (*pWChar)
            {
                if (pMatch = wcschr(specialChars, *pWChar))
                {
                    wcscpy(outputString, replacements[pMatch-specialChars]);
                    outputString += copyLen;
                }
                else
                {
                    *outputString = *pWChar;
                    outputString++;
                }
                pWChar++;
            }

            *outputString = L'\0';
            result = outputBuffer;
            delete[] outputBuffer;
        }
    }

    return result;
}

    

    

//---------------------------------------------------------------------------
// CStringUTF8
//---------------------------------------------------------------------------

class CStringUTF8
{
public:

	CStringUTF8(LPCWSTR pszOld) :
		m_pchNew(NULL)
	{
		if (pszOld)
		{
			int cchNew = WideCharToMultiByte(CP_UTF8, 0, pszOld, -1, NULL, 0, NULL, NULL);

			m_pchNew = new CHAR[cchNew];

			if (m_pchNew)
			{
				WideCharToMultiByte(CP_UTF8, 0, pszOld, -1, m_pchNew, cchNew, NULL, NULL);
			}
		}
	}

	~CStringUTF8()
	{
		delete [] m_pchNew;
	}

	operator LPCSTR()
	{
		return m_pchNew;
	}

protected:

	LPSTR m_pchNew;
};


#define WTUTF8(s) static_cast<LPCSTR>(CStringUTF8(s))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\dctagent.cpp ===
/*---------------------------------------------------------------------------
  File: DCTAgent.cpp

  Comments: Implementation of EADCTAgent aka "the Engine"

  The DCTAgent COM object acts as a workflow engine to drive the migration
  process.  It is used both for local migration, and also in the remote agent.
  
  A new thread is created for each migration job.  The engine looks at the varset
  which defines the job to see which tasks need to be performed.  
  It then calls the needed helper objects (defined in WorkerObjects) to perform these tasks.

  The DCTAgent interface allows jobs to be submitted, and also allows the client to 
  query the status of, or cancel a running job.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/
 // DCTAgent.cpp : Implementation of CDCTAgent
#include "stdafx.h"
//#include "McsEaDctAgent.h"
#include "Engine.h"


//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
//#import "WorkObj.tlb" no_namespace, named_guids //#imported by DCTAgent.h below

#include "DCTAgent.h"

#if (_WIN32_WINNT < 0x0500)
#define LOGON32_LOGON_NEW_CREDENTIALS 9
#define LOGON32_PROVIDER_WINNT50 3
#endif

/////////////////////////////////////////////////////////////////////////////
// CDCTAgent
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "LSAUtils.h"
#include "TxtSid.h"
#include "CommaLog.hpp"
#include "EaLen.hpp"
#include "TReg.hpp"
#include "ResStr.h"
#include "sd.hpp"
#include "SecObj.hpp"
#include "bkuprstr.hpp"
#include <lm.h>
#include <locale.h>
#include "TaskChk.h"  // routines to determine which tasks to perform
//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"
#include "McsPI_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// these defines are for calling GetWellKnownSid
#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define USERS              6
#define SYSTEM             7

TErrorDct                    err;
TError                     & errCommon = err;
BOOL                         m_bRegisteredActive = FALSE;
ULONG                        m_ulRegistrationHandle = 0; 

TErrorDct                    errTrace;
StringLoader                 gString;

HANDLE                  ghOKToShutDown;     // used to signal agent to shut down
BOOL                    gbAutoShutDownSet;  // indicates whether auto shut down timeout has been set
                                              // if not, use the default timeout (6 minutes)
ULARGE_INTEGER          guliStart;           // starting time
ULARGE_INTEGER          guliTimeout;         // the timeout value

bool __stdcall StartNetLogonService();
bool __stdcall StopNetLogonService();

HRESULT                                      // ret- HRESULT
   ChangeDomainAffiliation(
      IVarSet              * pVarSet,      // in - varset
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetDomain, // in - name of target domain
      BSTR                   targetName   // in - new name of computer, if being renamed also
   );

HRESULT                                      // ret- HRESULT
   RenameComputer(
      BOOL                   bNoChange,      // in - flag, whether to write changes
      BSTR                   targetName      // in - new name for local computer
   );

HRESULT                                      // ret- HRESULT
   RebootTheComputer(
      BOOL                   bNoChange,      // in - flag, whether to actually do it
      LONG                   delay           // in - delay in seconds before rebooting
   );

HRESULT                                      // ret- HRESULT
   DoPlugInTask(
      IVarSet              * pVarSet,        // in - varset describing migration job
      int                    task            // in - 0=premigration, 1=postmigration
   );



DWORD __stdcall                            // ret- OS return code
   ExecuteDCTJob( 
      void                 * arg           // in - pointer to DCTAgentJob object containing information about job to do
   );

void 
   GetTempLogFile(
      WCHAR                * path          // out- path name (must be buffer that can hold at least MAX_PATH characters)
   )
{
   DWORD                     rc = 0;
   TRegKey                   rKey;
   WCHAR                     temp[MAX_PATH] = L"";
   DWORD                     type;
   DWORD                     len = DIM(temp);
   DWORD                     dwFileLength = 0;

   // get the temp path from the registry, since 
   // the GetTempPath API looks for the environment variables not defined when running as LocalSystem
   // When it doesn't find these environment variables, it uses %systemroot%
#ifndef OFA
   // first, look in "System\\CurrentControlSet\\Control\\Session Manager\\Environment", 
   // since this is where Win2K keeps the system TEMP environment variable
   rc = rKey.OpenRead(L"System\\CurrentControlSet\\Control\\Session Manager\\Environment",HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = rKey.ValueGet(L"TEMP",(void*)temp,&len,&type);
      if ( rc )
      {
         len = DIM(temp);
         rc = rKey.ValueGet(L"TMP",(void*)temp,&len,&type);
      }
      rKey.Close();
   }
#endif
   // if the HKLM key didn't work, use the default user's temp directory
   if ( temp[0] == 0 ) // for OFA, this will always be TRUE
   {
      rc = rKey.OpenRead(L".DEFAULT\\Environment",HKEY_USERS);
      if ( ! rc )
      {
         rc = rKey.ValueGet(L"TEMP",(void*)temp,&len,&type);
         if ( rc )
         {
            len = DIM(temp);
            rc = rKey.ValueGet(L"TMP",(void*)temp,&len,&type);
         }
      }
   }

   if ( ! rc )
   {
      // substitute for other environment variables in the path      
      dwFileLength = ExpandEnvironmentStrings(temp,path,MAX_PATH);
      if ( ! dwFileLength)
      {
         rc = GetLastError();
      }
      else if(dwFileLength > MAX_PATH)
      {
          rc = ERROR_INSUFFICIENT_BUFFER;
      }

   }
   if ( rc )
   {
      if ( ! GetTempPath(MAX_PATH,path) )
      {
         // if can't get temp dir, use root of c drive as as last resort
         UStrCpy(path,"C:\\");
      }
   }

   // append a fixed filename to the path
   if ( path[UStrLen(path)-1] != L'\\' )
   {
      len = UStrLen(path);
      path[len] = L'\\';
      path[len+1] = 0;
   }
   UStrCpy(path+UStrLen(path),GET_STRING(IDS_LOG_FILENAME));
   errTrace.DbgMsgWrite(0,L"Found temp directory log file path: %ls",path);

}

BOOL                                       // ret- whether debug information should be written
   DumpDebugInfo(
      WCHAR                * filename      // out- filename to write debug info to
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"DumpVarSet",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   return bFound;
}

BOOL                                       // ret- whether to perform trace logging to a file
   AgentTraceLogging(   
      WCHAR               * filename       // out- filename to use for trace logging
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   WCHAR                     fnW[MAX_PATH];

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"AgentTraceLog",fnW,MAX_PATH);
      if ( ! rc )
      {
         if ( *fnW ) 
         {
            bFound = TRUE;
            UStrCpy(filename,fnW);
         }
         else
         {
            filename[0] = 0;
         }
      }
   }
   return bFound;
}

// ExecuteDCTJob is the entry point for a thread that performs a migration task
// Each job is run in its own thread
// It instantiates helper objects as needed to perform the migration job
DWORD __stdcall 
   ExecuteDCTJob( 
      void                 * arg           // in - pointer to DCTAgentJob object containing information about job to do
   )
{

   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   
   _wsetlocale( LC_ALL, L".ACP" );
   
   _bstr_t        domain;
   _bstr_t        username;
   _bstr_t        password;
   _bstr_t        server;
   _bstr_t        share;

   //Sleep(15000);
   hr = CoInitialize(NULL);
   if(!SUCCEEDED(hr)) return rc;
   DCTAgentJob             * pJob = (DCTAgentJob *)arg;
   IVarSetPtr                pVarSet = pJob->GetVarSet();

   HANDLE hToken = NULL;
   BOOL bImpersonating = FALSE;
   BOOL bNeedToReboot = FALSE;
   BOOL bNeedToWriteJobStatusToFile = FALSE;
   BOOL bContinue = TRUE;

   try {

      errTrace.DbgMsgWrite(0,L"ExecuteDCTJob:  Started");
      if ( SUCCEEDED(hr) )
      {
         errTrace.DbgMsgWrite(0,L"ExecuteDCTJob:  CoInitialize succeeded.");
         
         {
            
            _bstr_t                   logFile;
            BOOL                      bSessEstablished = FALSE;
            BOOL                      bNoChange;
            LONG                      delay; // reboot delay
            int                       bAppend = 0;
            _bstr_t                   outputfile = pVarSet->get(GET_WSTR(DCTVS_Options_ResultFile));
            
            try 
            {
               pJob->SetStatus(DCT_STATUS_IN_PROGRESS);
               pJob->SetStartTime(time(NULL));   

               _bstr_t        logtotemp = pVarSet->get(GET_WSTR(DCTVS_Options_LogToTemp));
               _bstr_t        nc = pVarSet->get(GET_WSTR(DCTVS_Options_NoChange));
               _bstr_t        appendLog = pVarSet->get(GET_WSTR(DCTVS_Options_AppendToLogs));
               if ((!outputfile) || (!logtotemp) || (!nc) || (!appendLog))
				   return ERROR_NOT_ENOUGH_MEMORY;

               bNoChange = (UStrICmp(nc,GET_STRING(IDS_YES)) == 0);
            
               bAppend = ( UStrICmp(appendLog,GET_STRING(IDS_YES)) == 0) ? 1 : 0;

               //
               // indicates whether we need to explicitly acl the file
               // usually we don't
               // but in case of remote agent, it uses dctlog.txt in a temp directory and we need to acl it
               // 
               BOOL bNeedExplicitACLing = FALSE;
               if  ( UStrICmp(logtotemp,GET_STRING(IDS_YES)) )
               {
                  logFile = pVarSet->get(GET_WSTR(DCTVS_Options_Logfile));
				  if (!logFile)
				     return ERROR_NOT_ENOUGH_MEMORY;
               }
               else
               {
                  WCHAR            log[MAX_PATH];

                  GetTempLogFile(log);
                  logFile = log;
                  pVarSet->put(GET_WSTR(DCTVS_Options_Logfile),logFile);
                  bNeedExplicitACLing = TRUE;  // we're going to explicitly ACL this temp log file "dctlog.txt"
               }
               if ( ! err.LogOpen((WCHAR*)logFile,bAppend) )
               {
                  err.MsgWrite(ErrE,DCT_MSG_CANNOT_OPEN_LOGFILE_S,(WCHAR*)logFile);
                  errTrace.MsgWrite(ErrE,DCT_MSG_CANNOT_OPEN_LOGFILE_S,(WCHAR*)logFile);

                  // skip the real work if temp error log file cannot be opened on the remote machine
                  if (!UStrICmp(logtotemp,GET_STRING(IDS_YES)))
                  {
                    pVarSet->put(GET_WSTR(DCTVS_Results_LogFileIsInvalid),GET_BSTR(IDS_YES));
                    bContinue = FALSE;
                  }
               }
               else
               {
                    // in case of using temp log file, ACL it explicitly
                    // note we only need to do this if we are able to open it
                    // as dctlog.txt does not contain extremely sensitive information, when we cannot acl
                    // it, we will keep writing to it
                    if (bNeedExplicitACLing)
                    {
                        // turn on the backup/restore privilege
                        if ( GetBkupRstrPriv(NULL, TRUE) )
                        {
                            // Set the SD for the file to Administrators Full Control only.
                            TFileSD                tempLogFileSD(logFile);

                            if ( tempLogFileSD.GetSecurity() != NULL )
                            {
                                // allow administrators and system full control
                                PSID adminSid = GetWellKnownSid(ADMINISTRATORS);
                                PSID systemSid = GetWellKnownSid(SYSTEM);
                                if (adminSid && systemSid)
                                {
                                    // we have to copy the sid and allocate using malloc
                                    // since tempLogFileSD destructor frees sid using free instead of FreeSid
                                    DWORD sidLen = GetLengthSid(adminSid);
                                    PSID copiedAdminSid = (PSID) malloc(sidLen);
                                    if (copiedAdminSid && CopySid(sidLen, copiedAdminSid, adminSid))
                                    {
                                        TACE adminAce(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,adminSid);
                                        TACE systemAce(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,systemSid);
                                        PACL acl = NULL;  // start with an empty ACL
                                        PACL tempAcl;

                                        tempLogFileSD.GetSecurity()->ACLAddAce(&acl,&adminAce,-1);
                                        if (acl != NULL)
                                        {
                                            tempAcl = acl;
                                            tempLogFileSD.GetSecurity()->ACLAddAce(&acl,&systemAce,-1);
                                            if (acl != tempAcl)
                                                free(tempAcl);
                                        }
                                        if (acl != NULL)
                                        {
                                            // need to set the owner
                                            tempLogFileSD.GetSecurity()->SetOwner(copiedAdminSid);
                                            copiedAdminSid = NULL;  // memory is taken care of by tempLogFileSD destructor
                                        
                                            // set the DACL part                                            
                                            tempLogFileSD.GetSecurity()->SetDacl(acl,TRUE);  // tempLogFileSD destructor will take care of acl

                                            // set the security descriptor
                                            tempLogFileSD.WriteSD();
                                        }

                                    }

                                    // do some cleaning up
                                    if (copiedAdminSid)
                                        free(copiedAdminSid);
                                    
                                }

                                // do some cleaning up
                                if (adminSid)
                                    FreeSid(adminSid);

                                if (systemSid)
                                    FreeSid(systemSid);
                            }

                            // turn off the backup/restore privilege
                            GetBkupRstrPriv(NULL, FALSE);
                        }                    
                    }
               }
               
               pVarSet->put(GET_WSTR(DCTVS_Results_LogFile),logFile);
               err.DbgMsgWrite(0,L"");
               err.MsgWrite(0,DCT_MSG_EDA_STARTING);

               // ExecuteDCTJob will instantiate and call any worker objects we need.
               // Later, we could replace this function with a more flexible workflow 
            
               if ( pJob->GetStatusObject() != NULL )
               {
                  pVarSet->putObject(GET_WSTR(DCTVS_StatusObject),pJob->GetStatusObject());
               }
               else
               {
                  errTrace.DbgMsgWrite(0,L"Status object is NULL!");
               }

               // Do premigration task for any plug-ins
               DoPlugInTask(pVarSet,0);
               
               // Run account replicator
               if ( bContinue && NeedToUseAR(pVarSet) )
               {
                  try { 
                     IAcctReplPtr ar;

                     err.MsgWrite(0,DCT_MSG_STARTING_AR);
                     hr = ar.CreateInstance(CLSID_AcctRepl);
                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Started account replicator");
                        err.LogClose();
                        pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),GET_WSTR(IDS_ACCT_REPL_OPERATION_TEXT));
                        hr = ar->raw_Process(pVarSet);
                        errTrace.DbgMsgWrite(0,L"Finished account replicator");
                        pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),"");
                        err.LogOpen((WCHAR*)logFile,1);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_AR_FAILED_D,hr);
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Account Replicator threw an exception.");
                  }
               }
               
               if ( bContinue && NeedToUseST(pVarSet) )
               {
                  try { 
                     ISecTranslatorPtr fst;
                     err.MsgWrite(0,DCT_MSG_STARTING_ST);
                     hr = fst.CreateInstance(CLSID_SecTranslator);
                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Started FST");
                        err.LogClose();
                        try {
                           hr = fst->raw_Process(pVarSet);
                        }
                        catch (...){ 
                           err.LogOpen((WCHAR*)logFile,1);
                           err.MsgWrite(ErrS,DCT_MSG_ST_FAILED_D,E_FAIL);
                        }
                        errTrace.DbgMsgWrite(0,L"Finished FST!");
                        err.LogOpen((WCHAR*)logFile,1);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_ST_FAILED_D,hr);
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Security Translator threw an exception.");
                  }
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 1");

               if (bContinue)
                pVarSet->put(GET_WSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),L"");

               // Need to call PwdAge?
               _bstr_t                   filename = pVarSet->get(GET_WSTR(DCTVS_GatherInformation_ComputerPasswordAge));
            
               if ( bContinue && filename.length() )
               {
                  try { 
                     _bstr_t                domain = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomain));
                     IComputerPwdAgePtr pwdage;

                     err.MsgWrite(0,DCT_MSG_STARTING_COMPPWDAGE);
                     hr = pwdage.CreateInstance(CLSID_ComputerPwdAge);
                     if (SUCCEEDED(hr) && ((WCHAR*)domain))
                     {
                        errTrace.DbgMsgWrite(0,L"Started comp pwd age");
                  
                        _bstr_t             statString;

                        statString += GET_WSTR(IDS_EXTRACTING_COMP_PWD_AGE);
                        statString += domain;

                        pVarSet->put(GET_WSTR(DCTVS_CurrentPath),statString);
                        hr = pwdage->raw_ExportPasswordAge(domain,filename);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_COMPPWDAGE_FAILED_D, hr);
                     }
                     pVarSet->put(GET_WSTR(DCTVS_CurrentPath),L"");
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Password Age Gatherer threw an exception.");
                  }
        
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 2");
               filename = pVarSet->get(GET_WSTR(DCTVS_GatherInformation_UserRights));
               // Gather user rights information
               if ( bContinue && filename.length() )
               {
               
                  try { 
                     IUserRightsPtr userRights;
                     errTrace.DbgMsgWrite(0,L"Gathering user rights, filename = %ls",(WCHAR*)filename);
                     err.MsgWrite(0,DCT_MSG_STARTING_USERRIGHTS);
                     hr = userRights.CreateInstance(CLSID_UserRights);

                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Created User Rights object");
                        // Enumerate through server list
                        int                 i = 0;
                        WCHAR               key[200];
                        _bstr_t             server;
                        _bstr_t             statString;

                        do { 
                           swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),i);
                           server = pVarSet->get(key);

                           if (server.length() == 0)
                           {
                                swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);
                                server = pVarSet->get(key);
                           }

                           if ( ! server.length() )
                              break;
            
                           err.MsgWrite(0,DCT_MSG_EXPORTING_RIGHTS_SS,(WCHAR*)server,(WCHAR*)filename);
                           hr = userRights->raw_ExportUserRights(server,filename,(i!=0));
                           if ( FAILED(hr) )
                           {
                              err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_RIGHTS_EXPORT_FAILED_SD,(WCHAR*)server,hr);   
                           }
                           i++;
                        } while ( server.length() );
                     }
                     else
                     {
                        err.MsgWrite(ErrS,DCT_MSG_RIGHTS_NOT_STARTED_D,hr);
                     }
                     pVarSet->put(GET_WSTR(DCTVS_CurrentPath),L"");
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The User Rights Gatherer threw an exception.");
                  }
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 3");

               // OFA needs the StatusObject during the post-migration task.  I don't see any reason to blow
               // away the StatusObject here, so I'm commenting out the following line.
               // pVarSet->put(GET_WSTR(DCTVS_StatusObject),L"");
               // The reason for blowing away the status object is that the code that loads the varset result 
               // file from disk cannot load the status object
               // I'll move the commented out line to after the plug-ins have been called

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 4");
            
               // Change domain and/or rename and optionally reboot?
               hr = S_OK;
               if ( bContinue && outputfile.length() )
               {
                
                  try {

                     // check whether it is a computer migration on a DC
                     // if so, we will log an error and not do anything
                     BOOL bContinueComputerMigration = TRUE;
                     _bstr_t sWizard = pVarSet->get(GET_BSTR(DCTVS_Options_Wizard)); 
                     if (!UStrICmp(sWizard, L"computer"))
                     {
                      LPSERVER_INFO_102 serverInfo = NULL;
                      NET_API_STATUS nasStatus = NetServerGetInfo(NULL,102,(LPBYTE*)&serverInfo);
                      if (nasStatus == NERR_Success)
                      {
                          if (serverInfo->sv102_type & SV_TYPE_DOMAIN_CTRL
                              || serverInfo->sv102_type & SV_TYPE_DOMAIN_BAKCTRL)
                          {
                              bContinueComputerMigration = FALSE;
                              err.MsgWrite(ErrE,DCT_MSG_COMP_MIGRATION_NOT_ALLOWED_ON_DC);
                              errTrace.MsgWrite(ErrE,DCT_MSG_COMP_MIGRATION_NOT_ALLOWED_ON_DC);
                          }
                          NetApiBufferFree(serverInfo);
                      }
                     }

                     if (bContinueComputerMigration)
                     {
                         _bstr_t                TargetName = pVarSet->get(GET_WSTR(DCTVS_LocalServer_RenameTo));
                         WCHAR                  sSourceName[LEN_Path];
                         DWORD                  lenName = LEN_Path;

                         GetComputerName(sSourceName, &lenName);
                         if ( TargetName.length() )
                         {
                            // Rename the local computer
                            hr = RenameComputer(bNoChange,TargetName);
                         }

                         _bstr_t                 TargetDomain = pVarSet->get(GET_WSTR(DCTVS_LocalServer_ChangeDomain));

                         if (SUCCEEDED(hr) && (((WCHAR*)TargetDomain) && (!UStrICmp(TargetDomain,GET_STRING(IDS_YES)))))  // don't try to change domain if the rename failed!
                         {
                            // if change mode, stop Net Logon service so that scavenger thread does not reset
                            // the default computer password before the computer is re-booted
                            // Note: this is only required for Windows NT 4.0 or earlier
                            bool bStopLogonService = false;
                            bool bIsNT4 = false;
                            OSVERSIONINFO vi;
                            vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                            if (GetVersionEx(&vi))
                            {
                                if ((vi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (vi.dwMajorVersion < 5))
                                {
                                    bIsNT4 = true;
                                }
                            }
                            
                            if (!bNoChange)
                            {

                                if (bIsNT4)
                                {
                                    bStopLogonService = true;
                                    StopNetLogonService();
                                }
                            }//end if change mode

                            // Change domain affiliation
                            TargetDomain = bIsNT4 ? pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomainFlat))
                                            : pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomain));
                            if ((WCHAR*)TargetDomain)
                            {
                                // if we're joining domain with renaming option, we need to set the flag
                                // so that we will write the status to a file
                                if (TargetName.length())
                                {
                                    bNeedToWriteJobStatusToFile = TRUE;
                                }
                                hr = ChangeDomainAffiliation(pVarSet,bNoChange,TargetDomain,TargetName);
                                if (FAILED(hr))
                                {
                                    if (bStopLogonService)
                                    {
                                        StartNetLogonService();
                                    }
                                }
                            }
                         }

                         if ( SUCCEEDED(hr) )
                         {
                            TargetName = pVarSet->get(GET_WSTR(DCTVS_LocalServer_Reboot));

                            if (((WCHAR*)TargetName) && (!UStrICmp(TargetName,GET_STRING(IDS_YES))))
                            {
                               LONG          rebootDelay = pVarSet->get(GET_WSTR(DCTVS_LocalServer_RebootDelay));
                            
                               delay = rebootDelay;
                               // Reboot
                               bNeedToReboot = TRUE;
                               // log the reboot delay, in minutes
                               err.MsgWrite(0,DCT_MSG_REBOOT_DELAY_D,rebootDelay / 60 );
                            }
                         }
                         else if ( TargetName.length() )
                         {
                            // since we could not change the domain affiliation we should go ahead and
                            // rename it back.
                            hr = RenameComputer(bNoChange, _bstr_t(sSourceName));
                         }
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Computer Rename/Change Domain operation threw an exception.");
                  }

               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 5");
            
               // Do postmigration task for any plug-ins
               if (bContinue)
               {
                   try { 
                      DoPlugInTask(pVarSet,1);
                   }
                   catch ( ... )
                   {
                      err.LogOpen((WCHAR*)logFile,1);
                      err.DbgMsgWrite(ErrS,L"A Plug-In task threw an exception.");
                   }
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 6");
               
            
               WCHAR            dbgFile[MAX_PATH];
            
               pVarSet->put(GET_WSTR(DCTVS_StatusObject),L"");
            
               
               long level = pVarSet->get(GET_WSTR(DCTVS_Results_ErrorLevel));
               if ( level < err.GetMaxSeverityLevel() )
               {
                  pVarSet->put(GET_WSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
               }
               
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 7");
               if ( DumpDebugInfo(dbgFile) )
               {
                  pVarSet->DumpToFile(dbgFile);
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 8");
             
               // Finished - write results file
               if ( outputfile.length() )
               {
                  IPersistStorage*       ps = NULL;
                  IStoragePtr            store = NULL;
                  
                  errTrace.DbgMsgWrite(0,L"Writing results file, filename =%ls",(WCHAR*)outputfile);

                  hr = pVarSet->QueryInterface(IID_IPersistStorage,(void**)&ps);  
                  if ( SUCCEEDED(hr) )
                  {   
                     for(int i=0; i < 5; ++i)
                     {
                        hr = StgCreateDocfile((WCHAR*)outputfile,STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE ,0,&store);
                        if(SUCCEEDED(hr)) break;
                        Sleep(5000);
                        errTrace.DbgMsgWrite(0,L"Retrying StgCreateDocfile... %d", (i + 1));
                     }

                     if ( SUCCEEDED(hr) )
                     {
                        hr = OleSave(ps,store,FALSE);  
                        if ( FAILED(hr))                 
                        {
                           err.SysMsgWrite(ErrE,hr,DCT_MSG_OLESAVE_FAILED_SD,(WCHAR*)outputfile,hr);   
                        }
                        else
                        {
                           err.MsgWrite(0,DCT_MSG_WROTE_RESULTS_S,(WCHAR*)outputfile);
                        }
                     }
                     else
                     {
                        err.SysMsgWrite(ErrE,hr,DCT_MSG_STG_CREATE_FAILED_SD,(WCHAR*)outputfile,hr);
                     }
                     ps->Release();
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_NO_IPERSIST_SD,(WCHAR*)outputfile,hr);
                  }
                  if ( FAILED(hr) )
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_RESULT_FILE_FAILED_S,(WCHAR*)outputfile);
                     pVarSet->DumpToFile(outputfile);
                  }
               }

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 10");
            
               pJob->SetEndTime(time(NULL));

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 12");
            
            }
            catch ( ... ) 
            {
               err.DbgMsgWrite(ErrS,L"An Exception occurred during processing.  The agent task has been aborted.");
               errTrace.DbgMsgWrite(ErrE,L"An Exception occurred in ExecuteDCTJob(Before CoUninitialize).  Aborting.");
            }

            // We're finished with the processing, now do some cleanup tasks
            // we want the things below to always happen, even if an exception occurred above.

            // set the job status to "Completed" or "Completed with Errors" base on the result error level
            try { 
               long                     level = pVarSet->get(GET_WSTR(DCTVS_Results_ErrorLevel));
               long maxLevel = (long) err.GetMaxSeverityLevel();
               if ( level < maxLevel)
               {
                  pVarSet->put(GET_WSTR(DCTVS_Results_ErrorLevel),(LONG)maxLevel);
                  level = maxLevel;
               }
               if (level > 1)
                    pJob->SetStatus(DCT_STATUS_COMPLETED_WITH_ERRORS);
               else
                    pJob->SetStatus(DCT_STATUS_COMPLETED);
            
               err.MsgWrite(0,DCT_MSG_EDA_FINISHED);
               err.LogClose();
            }
            catch (... )
            {
               err.DbgMsgWrite(ErrE,L"An exception occurred while setting job status to completed.");
            }

            if (bNeedToWriteJobStatusToFile)
            {
                //
                // write the status to the file
                // the status file is named the string form of the job ID
                //

                // figure out the status file name
                int outputFilenameLen = outputfile.length();
                WCHAR* newFilename = new WCHAR[outputFilenameLen + 1];
                _bstr_t statusFilename = (WCHAR*) NULL;
                HRESULT hrWriteStatus = S_OK;
                DWORD moveFileRc = ERROR_SUCCESS;
                if (newFilename != NULL)
                {
                    wcscpy(newFilename, !outputfile ? L"" : (WCHAR*)outputfile);
                    WCHAR* lastSlash = wcsrchr(newFilename,L'\\');
                    if (lastSlash)
                        *(lastSlash + 1) = L'\0';

                    // convert GUID to string
                    WCHAR* szGUID = NULL;
                    hrWriteStatus = StringFromCLSID(pJob->GetJobID(), &szGUID);
                    if (SUCCEEDED(hrWriteStatus))
                    {
                        try
                        {
                            statusFilename = _bstr_t(lastSlash ? newFilename : L"") + _bstr_t(szGUID);
                        }
                        catch (_com_error& ce)
                        {
                            statusFilename = (WCHAR*) NULL;
                            hrWriteStatus = ce.Error();
                        }

                        CoTaskMemFree(szGUID);
                    }
                    delete[] newFilename;
                }
                else
                    hrWriteStatus = E_OUTOFMEMORY;

                if (SUCCEEDED(hrWriteStatus))
                {
                    DeleteFile(statusFilename);
                    IVarSet * pStatus = NULL;
                    hrWriteStatus = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_SERVER ,IID_IVarSet,(void**)&pStatus);

                    if (SUCCEEDED(hrWriteStatus))
                        hrWriteStatus = pJob->WriteStatusToVarset(pStatus);
                    
                    if (SUCCEEDED(hrWriteStatus))
                    {
                        IPersistStoragePtr ps;
                        IStoragePtr      store;
                        
                        hrWriteStatus = pStatus->QueryInterface(IID_IPersistStorage,(void**)&ps);  
                        if (SUCCEEDED(hrWriteStatus))
                        {
                            hrWriteStatus = StgCreateDocfile((WCHAR*)statusFilename,
                                                             STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                                                             0,
                                                             &store);
                            if (SUCCEEDED(hrWriteStatus))
                            {
                                hrWriteStatus = OleSave(ps,store,FALSE);

                                // delete the file upon reboot
                                if (!MoveFileEx(statusFilename, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
                                {
                                    moveFileRc = GetLastError();
                                }
                            }
                        }
                    }

                    if (pStatus != NULL)
                        pStatus->Release();

                }

                if (SUCCEEDED(hrWriteStatus))
                {
                    errTrace.DbgMsgWrite(0,L"Wrote status file %ls", (WCHAR*)statusFilename);
                    err.MsgWrite(0,
                                  DCT_MSG_WROTE_STATUS_FILE_S,
                                  (WCHAR*) statusFilename);
                    if (moveFileRc != ERROR_SUCCESS)
                        err.SysMsgWrite(ErrW,
                                         moveFileRc,
                                         DCT_MSG_CANNOT_DELETE_STATUS_FILE_UPON_REBOOT_SD,
                                         (WCHAR*) statusFilename,
                                         moveFileRc);
                }
                else
                {
                    errTrace.DbgMsgWrite(0, L"Unable to write status file %ls, hr=%lx", (WCHAR*)statusFilename, hrWriteStatus);
                    err.SysMsgWrite(0,
                                     hrWriteStatus,
                                     DCT_MSG_CANNOT_WRITE_STATUS_FILE_SD,
                                     (WCHAR*) statusFilename,
                                     hrWriteStatus);
                }                    
            }

            // block on ghOKToShutDown event for either 6 minutes or whatever timeout is set to
            GetSystemTimeAsFileTime((FILETIME*)&guliStart);  // we need to set a starting point
            while (TRUE)
            {
                // wait on shut down event for one minute
                if (WaitForSingleObject(ghOKToShutDown, 60000) == WAIT_OBJECT_0)
                {
                    break;
                }

                ULARGE_INTEGER uliCurrent;
                ULARGE_INTEGER timeout;
                timeout.QuadPart = (gbAutoShutDownSet) ? guliTimeout.QuadPart
                                            : ((ULONGLONG) 360000) * 10000;  // default 6 mintues
                GetSystemTimeAsFileTime((FILETIME*)&uliCurrent);
                
                if (guliStart.QuadPart >= uliCurrent.QuadPart)
                {
                    // the time has been reset, time out starting now
                    guliStart = uliCurrent;
                    continue;
                }
                else if (guliStart.QuadPart + timeout.QuadPart <= uliCurrent.QuadPart)
                {
                    // the timeout is up, let's shut down
                    break;
                }
            }
            
            if ( bNeedToReboot )
            {
                RebootTheComputer(bNoChange,delay);         
            }

            // now let the agent service know that we will shut down so it can shut down as well
            DWORD jobStatus = pJob->GetStatus();
            pJob->SetStatus(jobStatus | DCT_STATUS_SHUTDOWN);
                
            errTrace.DbgMsgWrite(0,L"Passed Checkpoint 15");

            // Release our pointer to the agent COM object
            try { 
               pJob->ReleaseUnknown();
            }
            catch (... )
            {
               err.DbgMsgWrite(ErrE,L"An exception occurred in pJob->ReleaseUnknown");
            }

            
         }
      }
   
   }
   catch ( ... ) 
   {
      err.DbgMsgWrite(ErrE,L"An Exception occurred.  Aborting.");
      errTrace.DbgMsgWrite(ErrE,L"An Exception occurred in ExecuteDCTJob.  Aborting.");
   }
   
   err.LogClose();

   errTrace.DbgMsgWrite(0,L"ExecuteDCTJob returning %ld",rc);
   
   CoUninitialize();
   
   return rc;

}

HRESULT
DCTAgentJob::WriteStatusToVarset(IVarSet* pVarSet)
{
    HRESULT hr = S_OK;

    try
    {
        _variant_t val;
        DWORD jobStatus = GetStatus();
        // we handle shutdown status separate from the original status
        // so that the admt monitoring side will not be confused
        BOOL bShutdown = jobStatus & DCT_STATUS_SHUTDOWN;
        switch ( jobStatus & ~DCT_STATUS_SHUTDOWN)
        {
            case DCT_STATUS_NOT_STARTED:
                val = GET_STRING(IDS_DCT_Status_NotStarted);
                break;
            case DCT_STATUS_IN_PROGRESS:
                val = GET_STRING(IDS_DCT_Status_InProgress);
                break;
            case DCT_STATUS_ABORTING:
                val = GET_STRING(IDS_DCT_Status_Aborting);
                break;
            case DCT_STATUS_ABORTED:
                val = GET_STRING(IDS_DCT_Status_Aborted);
                break;
            case DCT_STATUS_COMPLETED:
                val = GET_STRING(IDS_DCT_Status_Completed);
                break;
            case DCT_STATUS_COMPLETED_WITH_ERRORS:
                val = GET_STRING(IDS_DCT_Status_Completed_With_Errors);
                break;
            default:
                val = GET_STRING(IDS_DCT_Status_Unknown);
                break;
        }
        
        pVarSet->put(GET_WSTR(DCTVS_JobStatus),val);
        pVarSet->put(GET_WSTR(DCTVS_CurrentPath),GetVarSet()->get(GET_WSTR(DCTVS_CurrentPath)));
        pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),GetVarSet()->get(GET_WSTR(DCTVS_CurrentOperation)));
        val = (bShutdown) ? GET_STRING(IDS_DCT_Status_Shutdown) : GET_STRING(IDS_DCT_Status_Wait_For_Shutdown_Signal);
        pVarSet->put(GET_WSTR(DCTVS_ShutdownStatus),val);

        errTrace.DbgMsgWrite(0,L"Added status info to varset");

        IVarSet        * pStats = NULL;
        HRESULT          hr2  = GetVarSet()->raw_getReference(GET_WSTR(DCTVS_Stats),&pStats);

        if ( SUCCEEDED(hr2) )
        {
            errTrace.DbgMsgWrite(0,L"Adding stats to varset");
            pVarSet->ImportSubTree(GET_WSTR(DCTVS_Stats),pStats);
            pStats->Release();
        }
        else
        {
            errTrace.DbgMsgWrite(0,L"There are not stats to add to the varset");
            pVarSet->put(GET_WSTR(DCTVS_Stats),GET_WSTR(IDS_DCT_NoStatsAvailable));
        }

    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
    }

    return hr;   
}

STDMETHODIMP 
   CDCTAgent::SubmitJob(
      IUnknown             * pWorkItemIn,  // in - varset containing information about job to do
      BSTR                 * pJobID        // out- GUID uniquely identifying this job
   )
{
   HRESULT                   hr = S_OK;
   try {
   
   errTrace.DbgMsgWrite(0,L"Entered SubmitJob");
   IVarSetPtr                pVarSet = pWorkItemIn;
   GUID                      jobID;
   _bstr_t                   text;
   
   // SubmitJob is asynchronous, so launch a thread to do the job.
   
   // Create a GUID to identify the job
   hr = ::CoCreateGuid(&jobID);
   if ( SUCCEEDED(hr) )
   {
      WCHAR                * strJobID = NULL;
      StringFromCLSID(jobID,&strJobID);
      _bstr_t              bStrJobId = strJobID;

      errTrace.DbgMsgWrite(0,L"Created GUID for job '%ls'",(WCHAR*)strJobID);
      
      (*pJobID) = bStrJobId.copy();

      errTrace.DbgMsgWrite(0,L"Copied GUID to output variable");

      CoTaskMemFree(strJobID);
      

      IUnknown             * pUnk = NULL;

      errTrace.DbgMsgWrite(0,L"Calling QueryInterface");

      hr = QueryInterface(IID_IUnknown,(void**)&pUnk);

      errTrace.DbgMsgWrite(0,L"QueryInterface returned %lx",hr);
      
      if ( SUCCEEDED(hr) )
      {
         DCTAgentJob          * job = new DCTAgentJob(&jobID,pVarSet,pUnk);
         DWORD                  threadID = 0;
         HANDLE                 threadHandle;

         errTrace.DbgMsgWrite(0,L"Created job structure");
         pUnk->Release();
         threadHandle = CreateThread(NULL,0,&ExecuteDCTJob,job,CREATE_SUSPENDED,&threadID);

         if ( threadHandle != INVALID_HANDLE_VALUE )
         {
            job->SetThreadInfo(threadID,threadHandle);  
            m_JobList.Insert(job);
            errTrace.DbgMsgWrite(0,L"Inserted job into job list.");
#ifndef OFA
            SetThreadPriority(threadHandle,THREAD_PRIORITY_BELOW_NORMAL);
#endif
            ResumeThread(threadHandle);
            errTrace.DbgMsgWrite(0,L"Started job thread.");
            
         }
         else
         {
            DWORD            rc = GetLastError();

            errTrace.DbgMsgWrite(0,L"Failed to create thread for job.");
            hr = HRESULT_FROM_WIN32(rc);
         }
      }
      
   }
    
   }
   catch (_com_error& ce)
   {
      errTrace.DbgMsgWrite(0, L"Exception!!");
      hr = ce.Error();
   }
   catch (...)
   {
      // TODO:  log an error message!
      errTrace.DbgMsgWrite(0,L"Exception!!");
      hr = E_FAIL;
   }
   
	return hr;
}

STDMETHODIMP 
   CDCTAgent::CancelJob(
      BSTR                   strJobID        // in - ID of job to cancel
   )
{
	// Find the job
   GUID                      jobID;
   HRESULT                   hr = S_OK;
   DCTAgentJob             * job = NULL;
   
   errTrace.DbgMsgWrite(0,L"Entered CancelJob");

   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      errTrace.DbgMsgWrite(0,L"Job ID is %ls",(WCHAR*)strJobID);

      job = m_JobList.Find(jobID);
      if ( job )
      {
         errTrace.DbgMsgWrite(0,L"Found job, status = %ld", job->GetStatus() );
         if ( job->GetStatus() == DCT_STATUS_IN_PROGRESS )
         {
            job->SetStatus(DCT_STATUS_ABORTING);
         }
      }
   }
   errTrace.DbgMsgWrite(0,L"Leaving CancelJob");
   return hr;
}

// The varset returned from QueryJobStatus will contain the following information, assuming that the job exists.
// 
// The following VarSet keys will be copied from the varset that the migration job is using
// Job Status, Current Path, Current Operation, Stats (subtree)
STDMETHODIMP 
   CDCTAgent::QueryJobStatus(
      BSTR                   strJobID,     // in - job ID of job to query
      IUnknown            ** statusInfoOut  // out- varset containing information about the job, if it is running
   )
{
	GUID                      jobID;
   HRESULT                   hr = S_OK;
   DCTAgentJob             * job = NULL;
   
   try { 
      errTrace.DbgMsgWrite(0,L"Entering QueryJobStatus");
   (*statusInfoOut) = NULL;
   
   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      errTrace.DbgMsgWrite(0,L"Job id is %ls",(WCHAR*)strJobID);

      job = m_JobList.Find(jobID);
      if ( job )
      {
         errTrace.DbgMsgWrite(0,L"Found job, status=%ld",job->GetStatus());
         IVarSet * pVarSet = NULL;
         hr = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_SERVER ,IID_IVarSet,(void**)&pVarSet);
         errTrace.DbgMsgWrite(0,L"QueryJobStatus:  VarSet CreateInstance returned %lx",hr);
         if ( SUCCEEDED(hr) )
         {
            errTrace.DbgMsgWrite(0,L"VarSet created");
            hr = job->WriteStatusToVarset(pVarSet);
            if (SUCCEEDED(hr))
                hr = pVarSet->QueryInterface(IID_IUnknown,(void**)statusInfoOut);
            pVarSet->Release();
         }
      }
      else
      {
         hr = DISP_E_UNKNOWNNAME;
      }
   }
   } 
   catch (_com_error& ce)
   {
      errTrace.DbgMsgWrite(0,L"An exception occurred in QueryJobStatus");
      hr = ce.Error();
   }
   catch (...)
   {
      errTrace.DbgMsgWrite(0,L"An exception occurred in QueryJobStatus");
      hr = E_FAIL;
   }

   errTrace.DbgMsgWrite(0,L"QueryJobStatus returning %lx",hr);
   return hr;
}

STDMETHODIMP 
   CDCTAgent::RetrieveJobResults(
      BSTR                   strJobID,     // in - guid of job 
      IUnknown            ** pWorkItemOut  // out- varset containing stats
   )
{
	HRESULT                   hr = S_OK;
	GUID                      jobID;
   DCTAgentJob             * job = NULL;
   
   errTrace.DbgMsgWrite(0,L"Entering RetrieveJobResults");
   // initialize output parameter
   (*pWorkItemOut) = NULL;
   
   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      job = m_JobList.Find(jobID);
      if ( job )
      {
         IVarSet * pVarSet = NULL;
         hr = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_ALL,IID_IVarSet,(void**)&pVarSet);
         if ( SUCCEEDED(hr) )
         {
            pVarSet->ImportSubTree(L"",job->GetVarSet());
            hr = pVarSet->QueryInterface(IID_IUnknown,(void**)pWorkItemOut);
            pVarSet->Release();
         }
         job->ReleaseUnknown();
      }
   }

	errTrace.DbgMsgWrite(0,L"RetrieveJobResults, returning %lx",hr);
   return hr;
}

// VarSet output:
// Job.x - BSTR job guid
// Job.x.Status - BSTR status of job
// Job.x.StartTime - time_t Starting time of job
// Job.x.EndTime - time_t ending time of job (if finished)
STDMETHODIMP 
   CDCTAgent::GetJobList(
      IUnknown             ** pUnkOut      // out- varset containing list of jobs
   )
{
	HRESULT                   hr = S_OK;
   TNodeListEnum             e;
   DCTAgentJob             * pJob;
   WCHAR                     key[100];
   IVarSetPtr                pVarSet(CLSID_VarSet);
   _bstr_t                   val;
   int                       ndx;

   try { 

       errTrace.DbgMsgWrite(0,L"Entering GetJobList");
       (*pUnkOut) = NULL;
       for ( pJob = (DCTAgentJob *)e.OpenFirst(&m_JobList) , ndx = 0; pJob ; pJob = (DCTAgentJob*)e.Next(), ndx++ )
       {
          swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_D),ndx);
          GUID                   id = pJob->GetJobID();
          
          WCHAR                * strJobID = NULL;

          StringFromCLSID(id,&strJobID);
          pVarSet->put(key,strJobID);
          SysFreeString(strJobID);

          swprintf(key,GET_STRING(IDS_DCTVSFmt_JobStatus_D),ndx);
          switch ( pJob->GetStatus() )
          {
          case DCT_STATUS_NOT_STARTED:
             val = GET_STRING(IDS_DCT_Status_NotStarted);
             break;
          case DCT_STATUS_IN_PROGRESS:
             val = GET_STRING(IDS_DCT_Status_InProgress);
             break;
          case DCT_STATUS_ABORTING:
             val = GET_STRING(IDS_DCT_Status_Aborting);
             break;
          case DCT_STATUS_ABORTED:
             val = GET_STRING(IDS_DCT_Status_Aborted);
             break;
          case DCT_STATUS_COMPLETED:
             val = GET_STRING(IDS_DCT_Status_Completed);
             break;
          case DCT_STATUS_COMPLETED_WITH_ERRORS:
             val = GET_STRING(IDS_DCT_Status_Completed_With_Errors);
             break;
          default:
             val = GET_STRING(IDS_DCT_Status_Unknown);
             break;
          }
          pVarSet->put(key,val);
          swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_StartTime_D),ndx);
          pVarSet->put(key,(LONG)pJob->GetStartTime());
          swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_EndTime_D),ndx);
          pVarSet->put(key,(LONG)pJob->GetEndTime());
          errTrace.DbgMsgWrite(0,L"Job %ls",(WCHAR*)key);
       }
       hr = pVarSet->QueryInterface(IID_IUnknown,(void**)pUnkOut);
   }
   catch (_com_error& ce)
   {
      errTrace.DbgMsgWrite(0,L"An exception occurred in GetJobList");
      hr = ce.Error();
   }
   catch (...)
   {
      errTrace.DbgMsgWrite(0,L"An exception occurred in GetJobList");
      hr = E_FAIL;
   }
      
   return hr;
   errTrace.DbgMsgWrite(0,L"RetrieveJobResults returning %lx",hr);
}

STDMETHODIMP 
   CDCTAgent::SignalOKToShutDown()
{
    if (!SetEvent(ghOKToShutDown))
        return HRESULT_FROM_WIN32(GetLastError());
    return S_OK;
}

STDMETHODIMP 
   CDCTAgent::SetAutoShutDown(unsigned long dwTimeout)
{
    gbAutoShutDownSet = TRUE;
    GetSystemTimeAsFileTime((FILETIME*)&guliStart);
    guliTimeout.QuadPart = UInt32x32To64(dwTimeout, 10000);
    return S_OK;
}

HRESULT
   DoPlugInTask(IVarSet * pVarSet,int task)
{
   HRESULT                   hr = S_OK;
   WCHAR                     key[300];
   CLSID                     clsid;
   long                      nPlugIns = 0;

   if ( task == 0 )
   {
      // create the COM object for each plug-in
      _bstr_t                   bStrGuid, bStrRegisterFile;
      for ( int i = 0 ; ; i++ )
      {
         swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_D),i);
         bStrGuid = pVarSet->get(key);
         swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_RegisterFiles_D),i);            
         bStrRegisterFile = pVarSet->get(key);
      
         if ( bStrGuid.length() == 0 )
            break;
         if(!_wcsicmp(bStrGuid, L"None"))
            continue;

         IMcsDomPlugIn        * pPlugIn = NULL;
      
         hr = CLSIDFromString(bStrGuid,&clsid);
         if ( SUCCEEDED(hr) )
         {
            hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
            if ( SUCCEEDED(hr) )
            {
               swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_D),nPlugIns);
               pVarSet->putObject(key,pPlugIn);
               swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_GUID_D),nPlugIns);
               pVarSet->put(key,bStrGuid);
               swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_File_D),nPlugIns);
               pVarSet->put(key,bStrRegisterFile);
               nPlugIns++;
            }
			else
			   err.SysMsgWrite(ErrE,hr,DCT_MSG_FAIL_TO_RUN_PLUGIN_SSD,(WCHAR*)bStrGuid,(WCHAR*)bStrRegisterFile,hr);
         }
         else
            err.SysMsgWrite(ErrE,hr,DCT_MSG_FAIL_TO_RUN_PLUGIN_SSD,(WCHAR*)bStrGuid,(WCHAR*)bStrRegisterFile,hr);
      }
      pVarSet->put(GET_WSTR(DCTVS_PlugIn_Interface_Count),nPlugIns);
   }

   // Enumerate the plug-in interfaces
   IMcsDomPlugIn           * pPlugIn = NULL;
   
   nPlugIns = pVarSet->get(GET_WSTR(DCTVS_PlugIn_Interface_Count));

   for ( int i = 0 ; i < nPlugIns ; i++ )
   {
      swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_D),i);
      IUnknown * pUnk = pVarSet->get(key);
      hr = pUnk->QueryInterface(IID_IMcsDomPlugIn,(void**)&pPlugIn);
      if ( SUCCEEDED(hr) )
      {
         switch ( task )
         {
         case 0: // pre-migration
            hr = pPlugIn->PreMigrationTask(pVarSet);
            break;
         case 1: // post-migration
            hr = pPlugIn->PostMigrationTask(pVarSet);
            // release the interface and remove it from the varset
            pPlugIn->Release();
            pVarSet->put(key,L"");
            break;
         }
      }
      else
      {
         swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_GUID_D), i);
         _bstr_t bStrGuid = pVarSet->get(key);
         swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_File_D),i);
         _bstr_t bRegisterFile = pVarSet->get(key);
         err.SysMsgWrite(ErrE,hr,DCT_MSG_FAIL_TO_RUN_PLUGIN_SSD,(WCHAR*)bStrGuid,(WCHAR*)bRegisterFile,hr);
      }

   }
   return S_OK;
}

// renames the local computer 
HRESULT 
   RenameComputer(
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetName    // in - new name for computer
   )
{
   HRESULT                   hr = S_OK;
   IRenameComputerPtr        pRename;

   errTrace.DbgMsgWrite(0,L"Renaming local computer to %ls",(WCHAR*)targetName);
   hr = pRename.CreateInstance(CLSID_RenameComputer);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_RENAME_COMPUTER_COM_FAILED_D,hr);
   }
   else
   {
      pRename->NoChange = bNoChange;
      hr = pRename->raw_RenameLocalComputer(targetName);
      if ( FAILED(hr) )
      {
         err.SysMsgWrite(ErrS,hr,DCT_MSG_RENAME_COMPUTER_FAILED_SD,(WCHAR*)targetName,hr);
      }
      else
      {
         err.MsgWrite(0,DCT_MSG_COMPUTER_RENAMED_S,(WCHAR*)targetName);
      }
   }
   errTrace.DbgMsgWrite(0,L"RenameComputer, returning %lx",hr);
   
   return hr;
}

// reboots the local computer
HRESULT 
   RebootTheComputer(
      BOOL                   bNoChange,    // in - flag, nochange mode
      LONG                   delay         // in - seconds to delay before rebooting
   )
{
   HRESULT                   hr = S_OK;
   IRebootComputerPtr        pReboot;

   errTrace.DbgMsgWrite(0,L"Rebooting local computer, delay = %ld",delay);
   // Create the Reboot computer object
   hr = pReboot.CreateInstance(CLSID_RebootComputer);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_REBOOT_COM_FAILED_D,hr);
   }
   else
   {
      pReboot->NoChange = bNoChange;
      err.MsgWrite(0,DCT_MSG_REBOOTING);
      hr = pReboot->raw_Reboot(L"",delay);
      if ( FAILED(hr) )
      {
         err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_REBOOT_FAILED_D,hr);
      }
   }
   errTrace.DbgMsgWrite(0,L"RebootTheComputer, returning %lx",hr);
   return hr;   
}


// joins the local computer to the target domain 
// (assumes the computer account already exists)
HRESULT 
   ChangeDomainAffiliation(
      IVarSet              * pVarSet,      // in - varset
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetDomain, // in - name of target domain
      BSTR                   targetName   // in - new name of computer, if being renamed also
   )
{
   DWORD                     rc = 0;
   IChangeDomainPtr          pChange;
   BSTR                      errStatus = NULL;
   HRESULT                   hr;
   _bstr_t                   logfile = pVarSet->get(GET_WSTR(DCTVS_Options_Logfile));
   _bstr_t                   targetDomainSid = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomainSid));
   _bstr_t                   srcPath = pVarSet->get(GET_WSTR(DCTVS_CopiedAccount_SourcePath));

   if ((!logfile) || (!targetDomainSid) || (!srcPath))
	   return E_OUTOFMEMORY;
   // retrieve preferred target domain controller to avoid replication latency

   _bstr_t                   targetServer = pVarSet->get(GET_WSTR(DCTVS_Options_TargetServer));

   if (targetServer.length() > 2)
   {
      LPCWSTR pszTargetServer = targetServer;

      if (pszTargetServer && (pszTargetServer[0] == L'\\') && (pszTargetServer[1] == L'\\'))
      {
         targetServer = _bstr_t(&pszTargetServer[2]);
      }
   }

   errTrace.DbgMsgWrite(0,L"Changing domain to %ls",(WCHAR*)targetDomain);
   hr = pChange.CreateInstance(CLSID_ChangeDomain);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_CHANGE_DOMAIN_COM_FAILED_D,hr);

   }
   else
   {
      pChange->NoChange = bNoChange;

      err.LogClose();
      hr = pChange->raw_ChangeToDomainWithSid(
         NULL,
         targetDomain,
         targetDomainSid,
         targetServer,
         targetName,
         srcPath,
         &errStatus
      );
      err.LogOpen(logfile,1);

      if ( SUCCEEDED(hr) )
      {
         // Update the membership of the Administrators group
         _bstr_t           src = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomainSid));
         _bstr_t           tgt = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomainSid));
         _bstr_t           sourceDomain = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomain));
         if ((!src) || (!tgt) || (!sourceDomain))
	        return E_OUTOFMEMORY;

         PSID              srcSid = SidFromString((WCHAR*)src);
         PSID              tgtSid = SidFromString((WCHAR*)tgt);
         PSID              localAdmins = GetWellKnownSid(1/*ADMINISTRATORS*/);
         UCHAR             srcCount;
         UCHAR             tgtCount;
         LPDWORD           pLastSub;
   
         if ( srcSid && tgtSid )
         {
            srcSid = DomainizeSid(srcSid,TRUE);
            tgtSid = DomainizeSid(tgtSid,TRUE);
            if ((!srcSid) || (!tgtSid))
                return E_OUTOFMEMORY;

            // Create the Domain Admin's SID from the Domain SID
            srcCount = *GetSidSubAuthorityCount(srcSid);
            tgtCount = *GetSidSubAuthorityCount(tgtSid);

            pLastSub = GetSidSubAuthority(srcSid,(DWORD)srcCount-1);
            *pLastSub = DOMAIN_GROUP_RID_ADMINS;

            pLastSub = GetSidSubAuthority(tgtSid,(DWORD)tgtCount-1);
            *pLastSub = DOMAIN_GROUP_RID_ADMINS;
            
            WCHAR            name[LEN_Account];
            WCHAR            domain[LEN_Domain];
            DWORD            lenName = DIM(name);
            DWORD            lenDomain = DIM(name);
            SID_NAME_USE     snu;
            
            
            // Get the name of the local administrators group
            if ( LookupAccountSid(NULL,localAdmins,name,&lenName,domain,&lenDomain,&snu) )
            {
               DWORD                   rc = 0;
               
               // add to the local administrator's group
               if ( ! bNoChange )
               {
                  rc = NetLocalGroupAddMember(NULL,name,tgtSid);
               }
               else 
               {
                  rc = 0;
               }
               
               if ( rc && rc != ERROR_MEMBER_IN_ALIAS )
               {
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_ADD_DOMAIN_ADMINS_SSD,(WCHAR*)targetDomain,name,rc);
               }
               else
               {
                  if ( ! bNoChange )
                  {
                     // Only add if source != target
                     if ( UStrICmp((WCHAR*)sourceDomain,(WCHAR*)targetDomain) )
                     {
                        rc = NetLocalGroupDelMember(NULL,name,srcSid);
                     }
                  }
                  else
                  {
                     rc = 0;
                  }
                  if ( rc && rc != ERROR_MEMBER_NOT_IN_ALIAS )
                  {
                     err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_REMOVE_DOMAIN_ADMINS_SSD,(WCHAR*)sourceDomain,name,rc);
                  }
               }

            }
            else
            {
               rc = GetLastError();
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CANNOT_FIND_ADMIN_ACCOUNT_D,rc);
            }

            // Add domain users to users
            pLastSub = GetSidSubAuthority(srcSid,(DWORD)srcCount-1);
            *pLastSub = DOMAIN_GROUP_RID_USERS;

            pLastSub = GetSidSubAuthority(tgtSid,(DWORD)tgtCount-1);
            *pLastSub = DOMAIN_GROUP_RID_USERS;
            
            
            lenName = DIM(name);
            lenDomain = DIM(domain);

            FreeSid(localAdmins);
            localAdmins = GetWellKnownSid(6/*USERS*/);

            // Get the name of the local users group
            if ( LookupAccountSid(NULL,localAdmins,name,&lenName,domain,&lenDomain,&snu) )
            {
               DWORD                   rc = 0;
               
               // add to the local user's group
               if ( ! bNoChange )
               {
                  rc = NetLocalGroupAddMember(NULL,name,tgtSid);
               }
               else 
               {
                  rc = 0;
               }
               
               if ( rc && rc != ERROR_MEMBER_IN_ALIAS )
               {
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_ADD_DOMAIN_USERS_SSD,(WCHAR*)targetDomain,name,rc);
               }
               else
               {
                  if ( ! bNoChange )
                  {
                     // Only add if source != target
                     if ( UStrICmp((WCHAR*)sourceDomain,(WCHAR*)targetDomain) )
                     {
                        rc = NetLocalGroupDelMember(NULL,name,srcSid);
                     }
                  }
                  else
                  {
                     rc = 0;
                  }
                  if ( rc && rc != ERROR_MEMBER_NOT_IN_ALIAS )
                  {
                     err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_REMOVE_DOMAIN_USERS_SSD,(WCHAR*)sourceDomain,name,rc);
                  }
               }

            }
            else
            {
               rc = GetLastError();
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CANNOT_FIND_USERS_ACCOUNT_D,rc);
            }


         }              
         if ( hr == S_OK )
         {
            err.MsgWrite(0,DCT_MSG_DOMAIN_CHANGED_S,(WCHAR*)targetDomain);
         }
         else 
         {
            if ( errStatus && *errStatus )
            {
               err.MsgWrite(ErrS,DCT_MSG_CHANGE_DOMAIN_FAILED_S,(WCHAR*)errStatus);
               SysFreeString(errStatus);
            }
         }
      }
      else
      {
         err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_CHANGE_DOMAIN_FAILED_D,hr);
      }
   }
   errTrace.DbgMsgWrite(0,L"ChangeDomain, returning %lx",hr);
   return hr;
}


// StartNetLogonService Function

bool __stdcall StartNetLogonService()
{
	bool bSuccess = false;

	SC_HANDLE hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (hManager)
	{
		SC_HANDLE hService = OpenService(hManager, _T("Netlogon"), SERVICE_START);

		if (hService)
		{
			if (StartService(hService, 0, NULL))
			{
				bSuccess = true;
			}
			else
			{
				if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
				{
					bSuccess = true;
				}
			}

			CloseServiceHandle(hService);
		}

		CloseServiceHandle(hManager);
	}

	return bSuccess;
}


// StopNetLogonService Function

bool __stdcall StopNetLogonService()
{
	bool bSuccess = false;

	SC_HANDLE hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (hManager)
	{
		SC_HANDLE hService = OpenService(hManager, _T("Netlogon"), SERVICE_STOP);

		if (hService)
		{
			SERVICE_STATUS ss;

			if (ControlService(hService, SERVICE_CONTROL_STOP, &ss))
			{
				bSuccess = true;
			}
			else
			{
				switch (GetLastError())
				{
					case ERROR_SERVICE_NOT_ACTIVE:
					{
						bSuccess = true;
						break;
					}
					case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
					{
						if (ss.dwCurrentState == SERVICE_STOP_PENDING)
						{
							bSuccess = true;
						}
						break;
					}
				}
			}

			CloseServiceHandle(hService);
		}

		CloseServiceHandle(hManager);
	}

	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Engine.rc
//
#define IDS_SERVICENAME                 100
#define IDR_EADCTAgent                  100
#define IDR_DCTAGENT                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#ifdef OFA
#define _WIN32_WINNT 0x0400
#else
#define _WIN32_WINNT 0x0351
#endif
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\engine.cpp ===
/*---------------------------------------------------------------------------
  File: EADCTAgent.cpp

  Comments: Implementation of DCT Agent COM server, mostly generated by ATL.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f EADCTAgentps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <objidl.h>
//#include "McsEaDctAgent.h"
#include "Engine.h"

//#include "McsEaDctAgent_i.c"
#include "Engine_i.c"


#include <stdio.h>
#include "DCTAgent.h"
#include <objbase.h>
#include <LM.h>
#include <MigrationMutex.h>
#include "sdhelper.h"

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DCTAgent, CDCTAgent)
END_OBJECT_MAP()


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// function prototypes for DCOM initialization functions we'll try to load dynamically

/*#ifndef OFA
// here are some definitions we need, but that are only defined when _WIN32_WINNT is 0x400 and up
typedef struct  tagSOLE_AUTHENTICATION_SERVICE
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR __RPC_FAR *pPrincipalName;
    HRESULT hr;
    }	SOLE_AUTHENTICATION_SERVICE;

typedef SOLE_AUTHENTICATION_SERVICE __RPC_FAR *PSOLE_AUTHENTICATION_SERVICE;
typedef 
enum tagEOLE_AUTHENTICATION_CAPABILITIES
    {	EOAC_NONE	= 0,
	EOAC_MUTUAL_AUTH	= 0x1,
	EOAC_CLOAKING	= 0x10,
	EOAC_SECURE_REFS	= 0x2,
	EOAC_ACCESS_CONTROL	= 0x4,
	EOAC_APPID	= 0x8
    }	EOLE_AUTHENTICATION_CAPABILITIES;



#endif*/
typedef HRESULT STDAPICALLTYPE  COINITIALIZEEX (LPVOID,DWORD);
typedef HRESULT STDAPICALLTYPE  COINITIALIZESECURITY (PSECURITY_DESCRIPTOR,LONG,SOLE_AUTHENTICATION_SERVICE *,
                        void*,DWORD,DWORD,void*,DWORD,void*);

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
	bool bCreated = false;
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if (h != NULL)
	   bCreated = true;
    CloseHandle(h);
	return bCreated;
}

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    ATLTRACE(_T("E {ADMTAgnt.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);

    // obtain agent mutex
    // the migration driver uses this mutex to determine
    // if the agent process is currently running
    //
    // Note that named kernel objects with namespace prefixes are only supported
    // on Windows 2000 or later and therefore must check OS version before
    // specifying mutex name and only use Global\ prefix on Windows 2000 or later.

    bool bW2KOrLater = false;

    PWKSTA_INFO_100 pInfo;

    DWORD dwError = NetWkstaGetInfo(NULL, 100, (LPBYTE*)&pInfo);

    if (dwError == ERROR_SUCCESS)
    {
        if (pInfo->wki100_ver_major >= 5)
        {
            bW2KOrLater = true;
        }

        NetApiBufferFree(pInfo);
    }  

    CMigrationMutex mutex(bW2KOrLater ? AGENT_MUTEX : AGENT_MUTEX_NT4, true);

    // set debug flags to check memory allocations and leaks
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    HRESULT hRes;

#if defined(_ATL_FREE_THREADED)
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    hRes = CoInitialize(NULL);
#endif

    BOOL bSecurityInitialized = FALSE;

    _ASSERTE(SUCCEEDED(hRes));

    if ( SUCCEEDED(hRes) )
    {
        TSD*  adminsAndSystemSD = BuildAdminsAndSystemSDForCOM();
        if (adminsAndSystemSD)
        {
            hRes = CoInitializeSecurity(
                const_cast<SECURITY_DESCRIPTOR*>(adminsAndSystemSD->GetSD()), //Points to security descriptor
                -1,                          //Count of entries in asAuthSvc
                NULL,                        //Array of names to register
                NULL,                        //Reserved for future use
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,      //The default authentication
                //level for proxies
                RPC_C_IMP_LEVEL_IMPERSONATE, //The default impersonation
                //level for proxies
                NULL,                        //Reserved; must be set to NULL
                EOAC_NONE,                   //Additional client or
                //server-side capabilities
                NULL                         //Reserved for future use
                );
            if (SUCCEEDED(hRes))
                bSecurityInitialized = TRUE;
            if (adminsAndSystemSD)
                delete adminsAndSystemSD;
        }
    }
    else
    {
        // if CoInitialize fails, returns an error
        return 1;
    }

    if (!bSecurityInitialized)
    {
        // if CoInitializeSecurity fails, returns an error
        CoUninitialize();
        return 1;
    }

    _Module.Init(ObjectMap, hInstance, &LIBID_MCSEADCTAGENTLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_EADCTAgent, FALSE);
            nRet = _Module.UnregisterServer(TRUE);            
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_EADCTAgent, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

    ATLTRACE(_T("L {ADMTAgnt.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);
    //	_CrtDbgBreak();
    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\ckplugin.cpp ===
#include "stdafx.h"
#include "SecPI.h"
#include "cipher.hpp"
//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"


BOOL IsValidPlugIn(IMcsDomPlugIn * pPlugIn)
{
   BOOL                      bGood = FALSE;
   ISecPlugIn              * pSec = NULL;
   HRESULT                   hr = S_OK;

   hr = pPlugIn->QueryInterface(IID_ISecPlugIn,(void**)&pSec);

   if ( SUCCEEDED(hr) )
   {
      McsChallenge           ch;
      
      LONG                   one, two;
      LONG                   time1;
      ULONG                  size = sizeof(ch);

      srand(GetTickCount());
      one = (LONG)rand();
      ch.lRand1 = one;
      two = (LONG)rand();
      ch.lRand2 = two;
      time1 = GetTickCount();
      ch.lTime = time1;
      
      SimpleCipher((LPBYTE)&ch,size);
      
      hr = pSec->Verify((ULONG*)&ch,size);
      if ( SUCCEEDED(hr) )
      {

         SimpleCipher((LPBYTE)&ch,size);
         // verify that the plug-in did the right thing!
         if (  ch.MCS[0] == 'M'
            && ch.MCS[1] == 'C'
            && ch.MCS[2] == 'S'
            && ch.MCS[3] == 0 
         )
         {
            if ( ch.lRand1 == (one + two)
               && ch.lRand2 == (two - one) )
            {
               if ( ch.lTime == time1+100 )
               {
                  bGood = TRUE;
               }
            }
         }

      }

      pSec->Release();
   }
   return bGood;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dctagent\dctagent.h ===
/*---------------------------------------------------------------------------
  File: DCTAgent.h

  Comments: DCT Agent COM object

  The DCT agent can either be launched directly by a client, or 
  started by the DCTAgentService, under the LocalSystem context.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/	
// DCTAgent.h : Declaration of the CDCTAgent

#ifndef __DCTAGENT_H_
#define __DCTAGENT_H_

#include "resource.h"       // main symbols

#define DCT_STATUS_NOT_STARTED         (0x00000001)
#define DCT_STATUS_IN_PROGRESS         (0x00000002)
#define DCT_STATUS_ABORTING            (0x00000004)
#define DCT_STATUS_ABORTED             (0x00000008)
#define DCT_STATUS_COMPLETED           (0x00000010)
#define DCT_STATUS_UNKNOWN             (0x00000020)
#define DCT_STATUS_COMPLETED_WITH_ERRORS  (0x00000040)
#define DCT_STATUS_SHUTDOWN           (0x00000080)


#include "TNode.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace , named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "WorkObj.tlb" no_namespace , named_guids
#include <atlcom.h>

#include "Err.hpp"
#include "ErrDct.hpp"

extern TErrorDct                    errTrace;
extern HANDLE                       ghOKToShutDown;
extern BOOL                         gbAutoShutDownSet;


BOOL 
   AgentTraceLogging(
      WCHAR               * filename     
   );


class DCTAgentJob : public TNode
{
   GUID                      m_jobID;
   DWORD                     m_threadID;
   IVarSetPtr                m_pVarSet;
   IStatusObjPtr             m_pStatus;
   IUnknown                * m_pUnknown;
   HANDLE                    m_threadHandle;
   time_t                    m_startTime;
   time_t                    m_completionTime;
   
public:
   DCTAgentJob(GUID * pjobID, IVarSet * pVS, IUnknown * pUnk) 
   {
      HRESULT hr = m_pStatus.CreateInstance(CLSID_StatusObj);
      errTrace.DbgMsgWrite(0,L"StatusObject: CreateInstance returned %lx",hr);

      pVS->AddRef();
      memcpy(&m_jobID,pjobID,(sizeof GUID));
      m_pVarSet = pVS;
      if ( m_pStatus != NULL )
      {
         m_pStatus->Status = DCT_STATUS_NOT_STARTED;
      }
      m_threadID = 0;
      m_threadHandle = INVALID_HANDLE_VALUE;
      m_pUnknown = pUnk;
      if ( m_pUnknown )
         m_pUnknown->AddRef();
   }
   ~DCTAgentJob()
   {
      if ( m_threadHandle != INVALID_HANDLE_VALUE )
         CloseHandle(m_threadHandle);
      if ( m_pUnknown )
         m_pUnknown->Release();
      m_pVarSet->Release();
   }
   void     SetThreadInfo(DWORD id, HANDLE handle)   { m_threadID = id; m_threadHandle = handle;}
   void     SetStatus(DWORD status) { if ( m_pStatus!=NULL ) m_pStatus->Status = status; }
   void     ReleaseUnknown() { if ( m_pUnknown ) 
                               { 
                                 IUnknown * pUnk = m_pUnknown;
                                 m_pUnknown = NULL;
                                 pUnk->Release(); 
                               } 
                             }
   void     SetStartTime(time_t t){ m_startTime = t; }
   void     SetEndTime(time_t t){ m_completionTime = t; }

   GUID       GetJobID()               { return m_jobID;}
   DWORD      GetThreadID()            { return m_threadID; }
   HANDLE     GetThreadHandle()        { return m_threadHandle; }
   DWORD      GetStatus()              { if ( m_pStatus != NULL ) return m_pStatus->Status; else return DCT_STATUS_UNKNOWN; }
   IVarSet  * GetVarSet()              { return m_pVarSet; }
   IUnknown * GetUnknown()             { return m_pUnknown; }
   IStatusObj * GetStatusObject()      { return m_pStatus; }
   time_t     GetStartTime()           { return m_startTime; }
   time_t     GetEndTime()             { return m_completionTime; }
   HRESULT    WriteStatusToVarset(IVarSet *pVarset);
};

class DCTJobList : public TNodeList
{
public:
   ~DCTJobList() { DeleteAllListItems(DCTAgentJob); }
   DCTAgentJob * Find(REFGUID pID)
   {
      TNodeListEnum        e;
      DCTAgentJob        * p;
      BOOL                 bFound = FALSE;

      for ( p = (DCTAgentJob*)e.OpenFirst(this) ; p ; p = (DCTAgentJob *)e.Next() )
      {
         if ( IsEqualGUID(pID,p->GetJobID()) )
         {
            bFound = TRUE;
            break;
         }
      }
      e.Close();
      if ( ! bFound )
      {
         p = NULL;
      }
      return p;
   }
   void Insert(DCTAgentJob * p) { InsertBottom(p); }
};



/////////////////////////////////////////////////////////////////////////////
// CDCTAgent
class ATL_NO_VTABLE CDCTAgent : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTAgent, &CLSID_DCTAgent>,
	public IDispatchImpl<IDCTAgent,&IID_IDCTAgent,&LIBID_MCSEADCTAGENTLib>
{
public:
	CDCTAgent() :
		m_ulRegister(0)
	{
          WCHAR                  filename[MAX_PATH];

          if ( AgentTraceLogging(filename) )
          {
             errTrace.LogOpen(filename,1);
          }
          ghOKToShutDown = NULL;
          gbAutoShutDownSet = FALSE;
	}
            
   ~CDCTAgent()
   {
      errTrace.LogClose();
      if (ghOKToShutDown)
      {
        CloseHandle(ghOKToShutDown);
        ghOKToShutDown = NULL;
      }
   }

DECLARE_REGISTRY_RESOURCEID(IDR_DCTAGENT)
DECLARE_NOT_AGGREGATABLE(CDCTAgent)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTAgent)
	COM_INTERFACE_ENTRY(IDCTAgent)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        // register agent in running object table

        HRESULT hr = RegisterActiveObject(this, CLSID_DCTAgent, ACTIVEOBJECT_WEAK, &m_ulRegister);
        DWORD rc;

        if (hr == MK_S_MONIKERALREADYREGISTERED)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            ghOKToShutDown = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (ghOKToShutDown == NULL)
            {
                rc = GetLastError();
                hr = HRESULT_FROM_WIN32(rc);
            }
        }

        if (FAILED(hr))
        {
            if (m_ulRegister)
            {
                RevokeActiveObject(m_ulRegister, NULL);
                m_ulRegister = NULL;
            }

            if (ghOKToShutDown)
            {
                CloseHandle(ghOKToShutDown);
                ghOKToShutDown = NULL;
            }
        }

        return hr;
    }

	void FinalRelease()
	{
		// unregister agent from the running object table

		if (m_ulRegister)
		{
			RevokeActiveObject(m_ulRegister, NULL);
		}
	}

// IDCTAgent
public:
	STDMETHOD(GetJobList)(/*[out]*/ IUnknown ** pVarSet);
	STDMETHOD(SubmitJob)(IUnknown * pWorkItemIn, /*[out]*/ BSTR * pJobID);
       STDMETHOD(QueryJobStatus)(BSTR jobID, IUnknown ** statusInfoOut);
	STDMETHOD(CancelJob)(BSTR JobID);
	STDMETHOD(RetrieveJobResults)(BSTR jobID, IUnknown ** pWorkItemOut);
	STDMETHOD(SignalOKToShutDown)();
	STDMETHOD(SetAutoShutDown)(unsigned long dwTimeout);
	
protected:
	ULONG m_ulRegister;
       DCTJobList                m_JobList;
};

#endif //__DCTAGENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\ddisp.cpp ===
/*---------------------------------------------------------------------------
  File: DCTDispatcher.cpp

  Comments: Implementation of dispatcher COM object.  Remotely installs and
  launches the DCT Agent on remote computers.

  The CDCTDispatcher class implements the COM interface for the dispatcher.
  It takes a varset, containing a list of machines, and dispatches agents to 
  each specified machine.

  A job file (varset persisted to a file) is created for each agent, and 
  necessary initialization configuration (such as building an account mapping file for 
  security translation) is done.  The DCDTDispatcher class instantiates a 
  thread pool (CPooledDispatch), and uses the CDCTInstaller class to remotely
  install and start the agent service on each machine.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/// DCTDispatcher.cpp : Implementation of CDCTDispatcher
#include "stdafx.h"
#include "resource.h"
#include <locale.h>

//#include "..\Common\Include\McsDispatcher.h"
#include "Dispatch.h"
#include "DDisp.h"
#include "DInst.h"

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "Cipher.hpp"
#include "TNode.hpp"

#include "TPool.h"     // Thread pool for dispatching jobs
#include "LSAUtils.h"

#include "TxtSid.h"
#include "sd.hpp"
#include "SecObj.hpp"
#include "BkupRstr.hpp"
#include "TReg.hpp"

#include "ResStr.h"

#include "TaskChk.h"
#include "CommaLog.hpp"
#include "TInst.h"

#include <lm.h>
#include "GetDcName.h"

/////////////////////////////////////////////////////////////////////////////
// CDCTDispatcher

//#import "\bin\McsEADCTAgent.tlb" named_guids
//#include "..\AgtSvc\AgSvc.h"
#import "Engine.tlb" named_guids
#include "AgSvc.h"
#include "AgSvc_c.c"
#include "AgRpcUtl.h"

//#import "\bin\McsDctWorkerObjects.tlb" 
//#include "..\Common\Include\McsPI.h"
#import "WorkObj.tlb" 
#include "McsPI.h"
#include "McsPI_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TErrorDct                    errLog; // used to write dispatch log that is read by the agent monitor
TErrorDct                    errTrace;
TCriticalSection             gCS;
// TServerNodes make up an internally used list of machines to install to
class TServerNode : public TNode
{
   WCHAR                     sourceName[LEN_Computer];
   WCHAR                     targetName[LEN_Computer];
   BOOL                      bTranslate;
   BOOL                      bChangeDomain;
   BOOL                      bReboot;
   DWORD                     dwRebootDelay;
public:
   TServerNode() { sourceName[0] = 0; targetName[0] = 0; bTranslate = FALSE; bChangeDomain = FALSE; bReboot= FALSE; dwRebootDelay = 0; }
   WCHAR             const * SourceName() { return sourceName; }
   WCHAR             const * TargetName() { return targetName; }
   BOOL                      Translate() { return bTranslate; }
   BOOL                      Reboot() { return bReboot; }
   BOOL                      ChangeDomain() { return bChangeDomain; }
   DWORD                     RebootDelay() { return dwRebootDelay; }

   void SourceName(WCHAR const * src) { safecopy(sourceName,src); }
   void TargetName(WCHAR const * tgt) { safecopy(targetName,tgt); }
   void Translate(BOOL v) { bTranslate = v; }
   void ChangeDomain(BOOL v) { bChangeDomain = v; }
   void Reboot(BOOL v) { bReboot = v; }
   void RebootDelay(DWORD d) { dwRebootDelay = d; }
};


extern 
   TErrorDct               err;

// defined in CkPlugIn.cpp
BOOL IsValidPlugIn(IMcsDomPlugIn * pPlugIn);


BOOL                                       // ret - TRUE if need to dump debug information
   DumpDebugInfo(
      WCHAR                * filename      // out - where to dump debug information 
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"DispatchVarSet",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   return bFound;
}

HRESULT 
   BuildPlugInFileList(
      TNodeList            * pList,        // i/o- list that files needed by plug-ins wil be added to
      IVarSet              * pVarSet       // in - varset containing list of plug-ins to query
   )
{
   // for now, build a list of all plug-ins, and add it to the varset
   MCSDCTWORKEROBJECTSLib::IPlugInInfoPtr            pPtr;
   SAFEARRAY               * pArray = NULL;
   HRESULT                   hr = S_OK;
   LONG                      bound;
   LONG                      ndx[1];
   WCHAR                     key[LEN_Path];

   hr = pPtr.CreateInstance(__uuidof(MCSDCTWORKEROBJECTSLib::PlugInInfo));
   
   _bstr_t                   bStrGuid;
   
   swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),0);
   bStrGuid = pVarSet->get(key);
   
   if (! bStrGuid.length() )
   {
      // if no plug-ins are specified, use the ones in the plug-ins directory
      if ( SUCCEEDED(hr) )
      {
         hr = pPtr->raw_EnumeratePlugIns(&pArray);
      }
      if ( SUCCEEDED(hr) )
      {
         SafeArrayGetUBound(pArray,1,&bound);
         for ( ndx[0] = 0 ; ndx[0] <= bound ; ndx[0]++ )
         {
            BSTR           val = NULL;

            SafeArrayGetElement(pArray,ndx,&val);
            swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),ndx[0]);
            pVarSet->put(key,val);
            SysFreeString(val);
         }
         SafeArrayDestroy(pArray);
         pArray = NULL;
      }
   }
   // enumerate the plug-ins specified in the varset, and make a list of their needed files
   int                    nRegFiles = 0;

   for ( int i = 0 ; ; i++ )
   {
      swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),i);
      bStrGuid = pVarSet->get(key);
      
      if ( bStrGuid.length() == 0 )
         break;

      if(!_wcsicmp(bStrGuid, L"None"))
         continue;
      
	   IMcsDomPlugIn        * pPlugIn = NULL;
      SAFEARRAY            * pFileArray = NULL;
      TFileNode            * pNode;
      CLSID                  clsid;

      hr = CLSIDFromString(bStrGuid,&clsid);
      if ( SUCCEEDED(hr) )
      {
         hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( IsValidPlugIn(pPlugIn) )
         {
            hr = pPlugIn->GetRequiredFiles(&pFileArray);
            if ( SUCCEEDED(hr) )
            {
               SafeArrayGetUBound(pFileArray,1,&bound);
               for ( ndx[0] = 0 ; ndx[0] <= bound ; ndx[0]++ )
               {
                  BSTR           val = NULL;

                  SafeArrayGetElement(pFileArray,ndx,&val);
                  pNode = new TFileNode(val);
                  pList->InsertBottom(pNode);
                  SysFreeString(val);
               }
               SafeArrayDestroy(pFileArray);
               pFileArray = NULL;
            }
            hr = pPlugIn->GetRegisterableFiles(&pFileArray);
            if ( SUCCEEDED(hr) )
            {
               SafeArrayGetUBound(pFileArray,1,&bound);
               for (ndx[0] = 0; ndx[0] <= bound ; ndx[0]++ )
               {
                  BSTR          val = NULL;

                  SafeArrayGetElement(pFileArray,ndx,&val);
                  swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_RegisterFiles_D),nRegFiles);
                  pVarSet->put(key,val);
                  SysFreeString(val);
                  nRegFiles++;
               }
               SafeArrayDestroy(pFileArray);
               pFileArray = NULL;
            }
         }
         pPlugIn->Release();
      }

      // we should bail out immediately if error occurs
      if(FAILED(hr))
      {
          return hr;
      }
   }   

   return hr;
   
}

// InstallJobInfo defines a Domain Migration 'job' to be installed and launched
struct InstallJobInfo
{
   IVarSetPtr                pVarSetList; // varset defining the server list
   IVarSetPtr                pVarSet;     // VarSet defining the job to run
   _bstr_t                   serverName;  // computer to install and run on
   _bstr_t                   serverNameDns;  // computer to install and run on
   long                      ndx;         // index of this server in the server list
   TNodeList               * pPlugInFileList; // list of files to install for plug-ins
   std::vector<CComBSTR>*    pStartFailedVector;
   std::vector<CComBSTR>*    pFailureDescVector;
   std::vector<CComBSTR>*    pStartedVector;
   std::vector<CComBSTR>*    pJobidVector;
   HANDLE                    hMutex;
   _bstr_t                   jobfile;     // uses the specified job file instead of creating one 
   int                       nErrCount;

   PCTSTR GetServerName()
   {
       return serverNameDns.length() ? serverNameDns : serverName;
   }

   PCTSTR GetServerNameDns()
   {
       return serverNameDns;
   }

   PCTSTR GetServerNameFlat()
   {
       return serverName;
   }
};

// WaitInfo is used to pass information to a thread that waits and does cleanup
// after all the Dispatcher's work is done
struct WaitInfo
{
   IUnknown                * pUnknown;          // IUnknown interface to the DCTDisptacher object
   TJobDispatcher          **ppPool;             // pointer to thread pool performing the tasks (installations)
   TNodeList               * pPlugInFileList;   // pointer to plug-in files list that will need to be freed
};     

WCHAR          gComputerName[LEN_Computer] = L"";  // name of local computer

// Calls DCTAgentService to start the Domain Migration Job on a remote computer
DWORD                                      // ret- OS return code
   StartJob(
      WCHAR          const * serverName,   // in - computer to start job on
      WCHAR          const * fullname,     // in - full path (including filename) to file containing the job's VarSet
      WCHAR          const * filename,      // in - filename of file containing the varset for the job
      _bstr_t&               strJobid
   )
{
   DWORD                     rc = 0;
   handle_t                  hBinding = NULL;
   WCHAR                   * sBinding = NULL;
   WCHAR                     jobGUID[LEN_Guid];
   WCHAR                     passwordW[1] = { 0 };
   
   rc = EaxBindCreate(serverName,&hBinding,&sBinding,TRUE);
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_BIND_FAILED_SD, serverName,rc);
   }
   if( ! rc )
   {
      RpcTryExcept
      {
         // the job file has been copied to the remote computer 
         // during the installation
         rc = EaxcSubmitJob(hBinding,filename,passwordW,jobGUID);
         if ( ! rc )
         {
            err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,serverName,filename,jobGUID);
            strJobid = jobGUID;
         }
         else
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);
         }
      }
      RpcExcept(1)
      {
         rc = RpcExceptionCode();
         if ( rc != RPC_S_SERVER_UNAVAILABLE )
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);      
         }
      }
      RpcEndExcept
      if ( rc == RPC_S_SERVER_UNAVAILABLE )
      {
         // maybe the agent hasn't started up yet for some reason
         
         for ( int tries = 0 ; tries < 6 ; tries++ )
         {
            Sleep(5000); // wait a few seconds and try again
         
            RpcTryExcept
            {
               rc = EaxcSubmitJob(hBinding,filename,passwordW,jobGUID);
               if ( ! rc )
               {
                  err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,serverName,filename,jobGUID);
                  strJobid = jobGUID;
                  break;
               }
               else
               {
                  if ( tries == 5 )
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);
               }
            }
            RpcExcept(1)
            {
               rc = RpcExceptionCode();
               if ( tries == 5 )
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);      
            }
            RpcEndExcept
         }
      }
   }
   if ( ! rc )
   {
      // if the job was started successfully, remove the job file
      if ( ! MoveFileEx(fullname,NULL, MOVEFILE_DELAY_UNTIL_REBOOT) )
      {
//         DWORD               rc2 = GetLastError();
      }
   }
   // this indicates whether the server was started
   if ( ! rc )
   {
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld,%ls,%ls",serverName,L"Start",rc,filename,jobGUID);
   }
   else
   {
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",serverName,L"Start",rc);
   }
   return rc;
}


// Gets the domain sid for the specified domain
BOOL                                       // ret- TRUE if successful
   GetSidForDomain(
      LPWSTR                 DomainName,   // in - name of domain to get SID for
      PSID                 * pDomainSid    // out- SID for domain, free with FreeSid
   )
{
   PSID                      pSid = NULL;
   DWORD                     rc = 0;
   _bstr_t                   domctrl;
   
   if ( DomainName[0] != L'\\' )
   {
      rc = GetAnyDcName5(DomainName, domctrl);
   }
   if ( ! rc )
   {
      rc = GetDomainSid(domctrl,&pSid);
   }
   (*pDomainSid) = pSid;
   
   return ( pSid != NULL);
}

// Set parameters in the varset that are specific to this particular computer
void 
   SetupVarSetForJob(
      InstallJobInfo       * pInfo,        // structure defining job
      IVarSet              * pVarSet,      // varset describing job
      WCHAR          const * uncname,      // UNC path for results directory 
      WCHAR          const * filename,      // UNC path for results file for this job
      WCHAR          const * relativeFileName,   // relative results file name for this job
      BOOL                   bUpdate = FALSE      // whether it is just to update the varset (for retry)
   )
{
    WCHAR                     uncresult[MAX_PATH];
    WCHAR                     serverName[MAX_PATH];
    WCHAR                     relativeResultFileName[MAX_PATH];
    _bstr_t                   text;

    // Set server-specific parameters in the varset
    swprintf(uncresult,L"%s.result",filename);
    swprintf(relativeResultFileName,L"%s.result",relativeFileName);
    swprintf(serverName,L"\\\\%s",gComputerName);

    pVarSet->put(GET_BSTR(DCTVS_Options_ResultFile),uncresult);
    pVarSet->put(GET_BSTR(DCTVS_Options_RelativeResultFileName), relativeResultFileName);

    // this part is only necessary when we are not just trying to update
    // the varset
    if (!bUpdate)
    {
        pVarSet->put(GET_BSTR(DCTVS_Options_Credentials_Server),serverName);
        pVarSet->put(GET_BSTR(DCTVS_Options_DeleteFileAfterLoad),GET_BSTR(IDS_YES));
        pVarSet->put(GET_BSTR(DCTVS_Options_RemoveAgentOnCompletion),GET_BSTR(IDS_YES));
        pVarSet->put(GET_BSTR(DCTVS_Options_LogToTemp),GET_BSTR(IDS_YES));
        pVarSet->put(GET_BSTR(DCTVS_Server_Index), CComVariant((long)pInfo->ndx));

        text = pVarSet->get(GET_BSTR(DCTVS_GatherInformation_UserRights));
        if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
        {
            swprintf(uncresult,L"%s.userrights",filename);
            pVarSet->put(GET_BSTR(DCTVS_GatherInformation_UserRights),uncresult);
        }
    }
    
    text = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));
    if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        swprintf(uncresult,L"%s.secrefs",filename);
        swprintf(relativeResultFileName, L"%s.secrefs", relativeFileName);
        pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),uncresult);
        pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferencesRelativeFileName), relativeResultFileName); 
    }
    else
    {
        pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences), L"");
        pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferencesRelativeFileName), L"");
    }

    // this part is only necessary when we are not just trying to update
    // the varset
    if (!bUpdate)
        pVarSet->put(GET_BSTR(DCTVS_Options_LocalProcessingOnly),GET_BSTR(IDS_YES));
}

// Entry point for thread, waits until all agents are installed and started,
// then cleans up and exits
ULONG __stdcall                            // ret- returns 0 
   Wait(
      void                 * arg           // in - WaitInfo structure containing needed pointers
   )
{
   WaitInfo                * w = (WaitInfo*)arg;
   
   SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
   
   // wait for all jobs to finish
   (*(w->ppPool))->WaitForCompletion();

   if ( w->pUnknown )
      w->pUnknown->Release();

   // delete the plug-in file list
   TNodeListEnum             tEnum;
   TFileNode               * fNode;
   TFileNode               * fNext;
   
   for ( fNode = (TFileNode*)tEnum.OpenFirst(w->pPlugInFileList); fNode; fNode = fNext )
   {
      fNext = (TFileNode*)tEnum.Next();
      w->pPlugInFileList->Remove(fNode);
      delete fNode;
   }
   tEnum.Close();
   
   delete w->pPlugInFileList;

   delete *(w->ppPool);
   *(w->ppPool) = NULL;
   
   err.MsgWrite(0,DCT_MSG_DISPATCHER_DONE);
   errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",L"All",L"Finished",0);
   err.LogClose();
   errLog.LogClose();
   return 0;
}

// Thread entry point, installs and starts agent on a single computer
ULONG __stdcall                            // ret- HRESULT error code
   DoInstall(
      void                 * arg           // in - InstallJobInfo structure
   )
{
    SetThreadLocale(LOCALE_SYSTEM_DEFAULT);

    HRESULT                     hr = S_OK;
    InstallJobInfo            * pInfo = (InstallJobInfo*)arg;
    _bstr_t                     strJobid;
    _bstr_t                     strFailureDesc(GET_STRING(IDS_START_FAILED));
    BOOL                        bErrLogged = FALSE;  // indicates whether the error in dispatching
                                                     // has been written into the dispatcher.csv

    if(pInfo->nErrCount == 0)
        hr = CoInitializeEx(0,COINIT_MULTITHREADED );
   
    if ( SUCCEEDED(hr) )
    {
        IWorkNode              * pInstaller = NULL;
        IVarSetPtr               pVarSet(CLSID_VarSet);
        WCHAR                    filename[MAX_PATH];
        WCHAR                    relativeFileName[MAX_PATH];
        WCHAR                    tempdir[MAX_PATH];
        WCHAR                    key[MAX_PATH];

        if ( pVarSet == NULL )
        {
            if(pInfo->nErrCount == 0)
                CoUninitialize();
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {

            DWORD uniqueNumber = (LONG)pInfo->pVarSet->get(GET_BSTR(DCTVS_Options_UniqueNumberForResultsFile));
            _bstr_t  bstrResultPath = pInfo->pVarSet->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
            // Copy the common information from the source varset
            gCS.Enter();
            // pInfo->pVarSet contains all the information except the server list
            // we don't want to copy the server list each time, so we create our new varset from pInfo->pVarSet
            pVarSet->ImportSubTree("",pInfo->pVarSet);
            gCS.Leave();
            // Set the server-specific data in the varset
            swprintf(key,GET_BSTR(IDS_DCTVSFmt_Servers_RenameTo_D),pInfo->ndx);

            // pInfo->pVarSetList contains the entire varset including the server list
            _bstr_t             text = pInfo->pVarSetList->get(key);

            if ( text.length() )
            {
                pVarSet->put(GET_BSTR(DCTVS_LocalServer_RenameTo),text);
            }

            swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),pInfo->ndx);
            text = pInfo->pVarSetList->get(key);
            if ( text.length() )
            {
                pVarSet->put(GET_BSTR(DCTVS_LocalServer_ChangeDomain),text);
            }

            swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),pInfo->ndx);
            text = pInfo->pVarSetList->get(key);
            pVarSet->put(GET_BSTR(DCTVS_LocalServer_MigrateOnly),text);


            swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),pInfo->ndx);
            text = pInfo->pVarSetList->get(key);
            if ( text.length() )
            {
                pVarSet->put(GET_BSTR(DCTVS_LocalServer_Reboot),text);
                LONG delay;
                swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),pInfo->ndx);
                delay = pInfo->pVarSetList->get(key);
                if ( delay )
                {
                    pVarSet->put(GET_BSTR(DCTVS_LocalServer_RebootDelay),delay);
                }
            }
            // remove the password from the varset, so that we are not writing it
            // to a file in plain text.  Instead, it will be passed to the agent service
            // when the job is submitted
            pVarSet->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),"");

            if ( ! uniqueNumber )
            {
                uniqueNumber = GetTickCount();
            }

            MCSASSERT(bstrResultPath.length());

            safecopy(tempdir,(WCHAR*)bstrResultPath);

            pInstaller = new CComObject<CDCTInstaller>;
            if (pInstaller)
            {
                pInstaller->AddRef();
                ((CDCTInstaller*)pInstaller)->SetFileList(pInfo->pPlugInFileList);
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            
            if ( SUCCEEDED(hr) )
            {
                _bstr_t strCacheFile;
                BOOL bJobFileAlreadyExists = (pInfo->jobfile.length() == 0) ? FALSE : TRUE;

                int relFilenameLen = sizeof(relativeFileName)/sizeof(relativeFileName[0]);
                int absFilenameLen = sizeof(filename)/sizeof(filename[0]);
                
                // figure out filename and relativeFileName
                // make sure their lengths will be less than MAX_PATH
                // otherwise, the mismatch of two names will cause agents to fail later one
                if (bJobFileAlreadyExists)
                {
                    WCHAR* path = (WCHAR*) pInfo->jobfile;
                    WCHAR jobFilename[_MAX_FNAME];
                    _wsplitpath(path, NULL, NULL, jobFilename, NULL);

                    if (wcslen(jobFilename) < relFilenameLen
                        && wcslen(jobFilename) + wcslen(tempdir) < absFilenameLen)
                    {
                        wcscpy(relativeFileName, jobFilename);
                        swprintf(filename,L"%s%s",tempdir,relativeFileName);
                    }
                    else
                        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                }
                else
                {
                    WCHAR sNumber[20];
                    swprintf(sNumber,L"%ld",uniqueNumber);
                    int filenameLen = wcslen(pInfo->GetServerNameFlat() + 2) + wcslen(sNumber);
                    if (wcslen(tempdir) + filenameLen < absFilenameLen && filenameLen < relFilenameLen)
                    {
                        swprintf(filename,L"%s%s%s",tempdir,pInfo->GetServerNameFlat() + 2,sNumber);
                        swprintf(relativeFileName, L"%s%s", pInfo->GetServerNameFlat() + 2,sNumber);
                    }
                    else
                        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                }

                // obtain the cache file name and if an existing job file is in old version
                // convert it to the new version
                if (SUCCEEDED(hr) && bJobFileAlreadyExists)
                {
                    IStoragePtr spStorage;

                    hr = StgOpenStorage(filename, NULL, STGM_DIRECT|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, NULL, 0, &spStorage);

                    if (SUCCEEDED(hr))
                    {                  
                        IVarSetPtr spJobVarSet;

                        hr = OleLoad(spStorage, IID_IUnknown, NULL, (void**)&spJobVarSet);

                        if (SUCCEEDED(hr))
                        {
                            // for retry case, we need to build plugin file list using
                            // the job file
                            hr = BuildPlugInFileList(pInfo->pPlugInFileList, spJobVarSet);
                        }

                        if (SUCCEEDED(hr))
                        {
                            strCacheFile = spJobVarSet->get(GET_BSTR(DCTVS_Accounts_InputFile));

                            // this is used to indicate whether newly added varset fields in job file are
                            // present or not:  these fields include DCTVS_Options_RelatvieResultFileName,
                            // DCTVS_Security_ReportAccountReferencesRelativeFileName
                            // if not, we have to add them so that the agent code will work
                            _bstr_t storedRelativeResultFileName = 
                                spJobVarSet->get(GET_BSTR(DCTVS_Options_RelativeResultFileName));
                            if (storedRelativeResultFileName.length() == 0)
                            {
                                SetupVarSetForJob(pInfo,spJobVarSet,tempdir,filename,relativeFileName, TRUE);
                                IPersistStoragePtr ps = NULL;
                                hr = spJobVarSet->QueryInterface(IID_IPersistStorage, (void**)&ps);
                                if (SUCCEEDED(hr))
                                    hr = OleSave(ps,spStorage,FALSE);
                            }
                        }
                    }
                }
                else
                {
                    // retrieve cache file name from varset
                    strCacheFile = pVarSet->get(GET_BSTR(DCTVS_Accounts_InputFile));
                }
                
                if (SUCCEEDED(hr) && (!bJobFileAlreadyExists))
                {
                    SetupVarSetForJob(pInfo,pVarSet,tempdir,filename,relativeFileName);

                    // Save the input varset to a file
                    IPersistStoragePtr     ps = NULL;
                    IStoragePtr            store = NULL;

                    hr = pVarSet->QueryInterface(IID_IPersistStorage,(void**)&ps);  
                    if ( SUCCEEDED(hr) )
                    {
                        hr = StgCreateDocfile(filename,STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE |STGM_FAILIFTHERE,0,&store);
                        if ( SUCCEEDED(hr) )
                        {
                            hr = OleSave(ps,store,FALSE);
                        }
                    }
                }

                IUnknown        * pWorkItem = NULL;

                if ( SUCCEEDED(hr) )
                {
                    pVarSet->put(GET_BSTR(DCTVS_ConfigurationFile),filename);
                    pVarSet->put(GET_BSTR(DCTVS_InstallToServer),pInfo->GetServerName());
                    pVarSet->put(GET_BSTR(DCTVS_CacheFile), strCacheFile);

                    hr = pVarSet->QueryInterface(IID_IUnknown,(void**)&pWorkItem);
                }
                if ( SUCCEEDED(hr) )
                {
                    // Do the installation to the server
                    hr = pInstaller->Process(pWorkItem);
                    if(hr == 0x88070040)
                        strFailureDesc = GET_STRING(IDS_AGENT_RUNNING);

                    pWorkItem->Release();

                    if ( SUCCEEDED(hr) )
                    {
                        err.MsgWrite(0,DCT_MSG_AGENT_INSTALLED_S,pInfo->GetServerName());
                        // try to start the job
                        DWORD rc = StartJob(pInfo->GetServerName(),filename,filename + UStrLen(tempdir), strJobid );
                        if ( rc )
                        {
                            hr = HRESULT_FROM_WIN32(rc);
                            // if we couldn't start the job, then try to stop the service
                            TDCTInstall               x( pInfo->GetServerName(), NULL );
                            x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),L"EXE",NULL);
                            DWORD                     rcOs = x.ScmOpen();

                            if ( ! rcOs )
                            {
                                x.ServiceStop();
                            }
                        }
                    }

                    // by now, we know for sure that the error will be logged into dispatcher.csv
                    // if there is any
                    bErrLogged = TRUE;
                    
                }
                pInstaller->Release();
            }
        }
    }

    if(pInfo->nErrCount == 0)
        CoUninitialize();

    if ( hr )
    {
        if ( hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) )
        {
            err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_NOT_STARTED_SS,pInfo->GetServerName(),pInfo->GetServerName());
        }
        else
        {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_LAUNCH_FAILED_SD,pInfo->GetServerName(),hr);
        }

        if(hr == 0x80070040 && pInfo->nErrCount < 10)
        {
            Sleep(1000);
            pInfo->nErrCount++;
            err.DbgMsgWrite(0,L"Retrying install...");
            hr = DoInstall((LPVOID)pInfo);
        }
        else if (hr == CO_E_NOT_SUPPORTED)
        {
            err.MsgWrite(ErrI,DCT_MSG_AGENT_ALPHA_NOTSUPPORTED,pInfo->GetServerName());
            strFailureDesc = GET_STRING(IDS_UNSOUPPORTED_OS);
            ::WaitForSingleObject(pInfo->hMutex, 30000);
            pInfo->pStartFailedVector->push_back(pInfo->GetServerName());
            pInfo->pFailureDescVector->push_back((BSTR)strFailureDesc);
            ::ReleaseMutex(pInfo->hMutex);
        }
        else
        {
            ::WaitForSingleObject(pInfo->hMutex, 30000);
            pInfo->pStartFailedVector->push_back(pInfo->GetServerName());
            pInfo->pFailureDescVector->push_back((BSTR)strFailureDesc);
            ::ReleaseMutex(pInfo->hMutex);
        }

        // if the error has been logged yet, log the error into dispatcher.csv
        if (hr && !bErrLogged)
            errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",pInfo->GetServerName(),L"Install",HRESULT_CODE(hr));
    }
    else
    {
        //      DWORD res = ::WaitForSingleObject(pInfo->hMutex, 30000);
        ::WaitForSingleObject(pInfo->hMutex, 30000);
        pInfo->pStartedVector->push_back(pInfo->GetServerName());
        _ASSERTE(strJobid != _bstr_t(L""));
        pInfo->pJobidVector->push_back((BSTR)strJobid);
        ::ReleaseMutex(pInfo->hMutex);
    }

    if(pInfo->nErrCount == 0)
        delete pInfo;
    return hr;
}

// DispatchToServers
// VarSet input:
// 
STDMETHODIMP                               // ret- HRESULT
   CDCTDispatcher::DispatchToServers(
      IUnknown            ** ppData        // i/o- pointer to varset
   )
{
   HRESULT                   hr;
   SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
   
//Sleep(60000); //delay for debugging
   (*ppData)->AddRef();
   hr = Process(*ppData,NULL,NULL);
   return hr;
}

// BuildInputFile constructs a cache file to be used for security translation
// VarSet input:
// Options.UniqueNumberForResultsFile  -unique number to append 
// Dispatcher.ResultPath               -directory to write file to
//
HRESULT                                    // ret- HRESULT
   CDCTDispatcher::BuildInputFile(
      IVarSet              * pVarSet       // in - varset containing data
   )
{
   IVarSetPtr                pVarSetST(CLSID_VarSet); // varset to use to run security translator
   IVarSetPtr                pVarSetTemp;       
   HRESULT                   hr = S_OK;
   _bstr_t                   key = GET_BSTR(DCTVS_Options);
   WCHAR                     tempdir[MAX_PATH];
   WCHAR                     resultPath[MAX_PATH];
   WCHAR                     logfile[MAX_PATH];
   
   DWORD                     uniqueNumber = (LONG)pVarSet->get(GET_BSTR(DCTVS_Options_UniqueNumberForResultsFile));
   _bstr_t                   bstrResultDir = pVarSet->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
   long                      lActionId = pVarSet->get(L"ActionID");
   
   if ( pVarSetST == NULL )
   {
      return E_FAIL;
   }

   if (! NeedToUseST(pVarSet,TRUE) )
   {
      return S_OK;
   }
   // construct a filename for the cache
   if ( ! uniqueNumber )
   {
      uniqueNumber = GetTickCount();
   }
   
   if ( bstrResultDir.length() )
   {
      safecopy(tempdir,(WCHAR*)bstrResultDir);
   }
   else
   {
      // if no result path specified, use temp directory
      hr = GetTempPath(DIM(tempdir),tempdir);
   }

   //
   // Generate cache file name based on the action id
   // so that account mapping information is persisted
   // for each security related migration task.
   // The cache file name is persisted in the job file
   // for each server.
   //

   WCHAR szActionId[32];
   swprintf(szActionId, L".%03ld", lActionId);

   _bstr_t strCacheFile = GET_BSTR(IDS_CACHE_FILE_NAME) + szActionId;
   _bstr_t strCachePath = tempdir + strCacheFile;

   // copy 'Options' settings to ST varset
   hr = pVarSet->raw_getReference(key,&pVarSetTemp);
   if ( SUCCEEDED(hr) )
   {
      pVarSetST->ImportSubTree(key,pVarSetTemp);
   }

   // copy 'Accounts' settings to ST varset
   key = GET_BSTR(DCTVS_Accounts);
   hr = pVarSet->raw_getReference(key,&pVarSetTemp);
   if ( SUCCEEDED(hr) )
   {
      pVarSetST->ImportSubTree(key,pVarSetTemp);
   }

   pVarSetST->put(GET_BSTR(DCTVS_Security_TranslationMode),
	              pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode)));
   pVarSetST->put(GET_BSTR(DCTVS_Options_NoChange),GET_BSTR(IDS_YES));
   
   pVarSetST->put(GET_BSTR(DCTVS_Options_LogLevel),(LONG)0);
   pVarSetST->put(GET_BSTR(DCTVS_Security_BuildCacheFile),strCachePath);

   // change the log file - the building of the cache file happens behind the scenes
   // so we won't put it in the regular log file because it would cause confusion
   swprintf(logfile,L"%s%s",tempdir,L"BuildCacheFileLog.txt");
   pVarSetST->put(GET_BSTR(DCTVS_Options_Logfile),logfile);

      //are we using a sID mapping file to perform security translation
   pVarSetST->put(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT),
	              pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT)));
   pVarSetST->put(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile),
	              pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile)));

   MCSEADCTAGENTLib::IDCTAgentPtr              pAgent(MCSEADCTAGENTLib::CLSID_DCTAgent);

   try {
      if ( pAgent == NULL )
         return E_FAIL;

      _bstr_t                   jobID;
      BSTR                      b = NULL;

      // turn on the alternative log file
       swprintf(logfile, GetMigrationLogPath());
       pVarSetST->put(GET_BSTR(DCTVS_Options_AlternativeLogfile), logfile);
       
      hr = pAgent->raw_SubmitJob(pVarSetST,&b);

      // turn off the alternative log file
      pVarSetST->put(GET_BSTR(DCTVS_Options_AlternativeLogfile),_bstr_t(L""));
      
      if ( SUCCEEDED(hr) )
      {
         // since this is a local agent, we should go ahead to signal Ok to shut down
         // the reason HRESULT is not checked is that when there is no reference to 
         // agent COM server, it will be shut down anyway
         pAgent->raw_SignalOKToShutDown();

         jobID = b;
      
         IVarSetPtr                pVarSetStatus;     // used to retrieve status of running job
         _bstr_t                   jobStatus;
         IUnknown                * pUnk;

         // loop until the agent is finished
         do {
   
            Sleep(1000);

            hr = pAgent->QueryJobStatus(jobID,&pUnk);
            if ( SUCCEEDED(hr) )
            {
               pVarSetStatus = pUnk;
               jobStatus = pVarSetStatus->get(GET_BSTR(DCTVS_JobStatus));      
               pUnk->Release();
            }
            else
            {
               break;
            }
         } while ( UStrICmp(jobStatus,GET_STRING(IDS_DCT_Status_Completed)) 
                        && UStrICmp(jobStatus,GET_STRING(IDS_DCT_Status_Completed_With_Errors)));
      }
   }
   catch(...)
   {
      hr = E_FAIL;
   }
   if ( SUCCEEDED(hr) )
   {
      pVarSet->put(GET_BSTR(DCTVS_Accounts_InputFile),strCacheFile);
      pVarSet->put(GET_BSTR(DCTVS_Accounts_WildcardSpec),"");
      err.MsgWrite(0,DCT_MSG_CACHE_FILE_BUILT_S,(WCHAR*)strCacheFile);
   }
   return hr;
}

// These are TNodeListSortable sorting functions

int ServerNodeCompare(TNode const * t1,TNode const * t2)
{
   TServerNode             * n1 = (TServerNode *)t1;
   TServerNode             * n2 = (TServerNode *)t2;

   return UStrICmp(n1->SourceName(),n2->SourceName());
}

int ServerValueCompare(TNode const * t1, void const * val)
{
   TServerNode             * n1 = (TServerNode *)t1;
   WCHAR             const * name = (WCHAR const *) val;

   return UStrICmp(n1->SourceName(),name); 
}

// MergeServerList combines the security translation server list in Servers.* with the computer migration
// server list in MigrateServers.* 
// The combined list is stored in the varset under Servers.* with subkeys specifying which actions to take for 
// each computer
void 
   CDCTDispatcher::MergeServerList(
      IVarSet              * pVarSet       // in - varset containing list of servers to migrate and translate on
   )
{
    int                       ndx = 0;
    WCHAR                     key[1000];
    _bstr_t                   text;
    _bstr_t                   serverName;
    BOOL                      bNoChange;
    int						  lastndx = -1;
    long					  totalsrvs;

    // if it is in test mode, there is no skipping
    text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
    bNoChange = (!UStrICmp(text, GET_STRING(IDS_YES))) ? TRUE : FALSE;
        

    //get the number of servers in the varset
    totalsrvs = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));

    // if there are computers being migrated
    if (totalsrvs > 0)
    {
        //add code to move varset server entries, with SkipDispatch set, to the bottom
        //of the server list and decrease the number of server items by each server
        //to be skipped
        //check each server in the list moving all to be skipped to the end of the list and
        //decreasing the server count for each to be skipped
        for (ndx = 0; ndx < totalsrvs; ndx++)
        {
            swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),ndx);
            text = pVarSet->get(key);
            swprintf(key,GET_STRING(DCTVSFmt_Servers_D),ndx);
            serverName = pVarSet->get(key);
            
            //if the server is not to be skipped, we may have to move it above
            //a server that is being skipped
            if (serverName.length()
                && (bNoChange || !text || !UStrICmp(text,GET_STRING(IDS_No))))
            {
                //if the last server looked at is not being skipped then we don't
                //need to swap any servers in the list and we can increment the
                //last server not being skipped
                if (lastndx == (ndx - 1))
                {
                    lastndx = ndx;
                }
                else //else swap servers in the varset so skipped server comes after
                {    //the one not being skipped
                    _bstr_t  tempName, tempDnsName, tempNewName, tempChngDom, tempReboot, tempMigOnly;
                    long tempRebootDelay;
                    _bstr_t  skipName, skipDnsName, skipNewName, skipChngDom, skipReboot, skipMigOnly;
                    long skipRebootDelay;
                    lastndx++; //move to the skipped server that we will swap with

                    //copy skipped server's values to temp
                    swprintf(key,GET_STRING(DCTVSFmt_Servers_D),lastndx);
                    skipName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),lastndx);
                    skipDnsName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),lastndx);
                    skipNewName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),lastndx);
                    skipChngDom = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),lastndx);
                    skipReboot = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),lastndx);
                    skipMigOnly = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),lastndx);
                    skipRebootDelay = pVarSet->get(key);

                    //copy current, non-skipped, server valuesto second temp
                    swprintf(key,GET_STRING(DCTVSFmt_Servers_D),ndx);
                    tempName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),ndx);
                    tempDnsName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
                    tempNewName = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
                    tempChngDom = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),ndx);
                    tempReboot = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
                    tempMigOnly = pVarSet->get(key); 
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),ndx);
                    tempRebootDelay = pVarSet->get(key);

                    //place current server's values in place of values for the one
                    //being skipped
                    swprintf(key,GET_STRING(DCTVSFmt_Servers_D),lastndx);
                    pVarSet->put(key,tempName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),lastndx);
                    pVarSet->put(key,tempDnsName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),lastndx);
                    pVarSet->put(key,tempNewName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),lastndx);
                    pVarSet->put(key,tempChngDom);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),lastndx);
                    pVarSet->put(key,tempReboot);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),lastndx);
                    pVarSet->put(key,tempMigOnly);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),lastndx);
                    pVarSet->put(key,tempRebootDelay);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),lastndx);
                    pVarSet->put(key,GET_BSTR(IDS_No));

                    //place skipped server's values in place of values for current server
                    swprintf(key,GET_STRING(DCTVSFmt_Servers_D),ndx);
                    pVarSet->put(key,skipName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),ndx);
                    pVarSet->put(key,skipDnsName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
                    pVarSet->put(key,skipNewName);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
                    pVarSet->put(key,skipChngDom);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),ndx);
                    pVarSet->put(key,skipReboot);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
                    pVarSet->put(key,skipMigOnly);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),ndx);
                    pVarSet->put(key,skipRebootDelay);
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),ndx);
                    pVarSet->put(key,GET_BSTR(IDS_YES));
                }//end else need to swap with skipped server
            }//end if not skipping dispatch for this server
        }//end for each server in the server list
        //exclude servers to be skipped for dispatch from being included in the server count
        pVarSet->put(GET_BSTR(DCTVS_Servers_NumItems),(long)++lastndx);
    }
}


STDMETHODIMP                               // ret- HRESULT
   CDCTDispatcher::Process(
      IUnknown             * pWorkItem,    // in - varset containing job information and list of servers  
      IUnknown            ** ppResponse,   // out- not used
      UINT                 * pDisposition  // out- not used  
   )
{
    // initialize output parameters
    if ( ppResponse )
    {
        (*ppResponse) = NULL;
    }
    HRESULT                   hr = S_OK;
    IVarSetPtr                pVarSetIn = pWorkItem;
    LONG                      nThreads;
    WCHAR                     key[100];
    _bstr_t                   serverName;
    _bstr_t                   serverNameDns;
    LONG                      nServers = 0;
    _bstr_t                   log;
    _bstr_t                   useTempCredentials;
    BOOL                      bFatalError = FALSE;
    _bstr_t                   text;
    WCHAR                     debugLog[MAX_PATH];
    long                      bAppend = 0;
    _bstr_t                   skip;
    _bstr_t					 sWizard;
    BOOL						 bSkipSourceSid;
						

    if ( DumpDebugInfo(debugLog) )
    {
        if ( pVarSetIn != NULL )
        {
            // temporarily remove the password fromthe varset, so that we don't write it to the file
            pVarSetIn->DumpToFile(debugLog);
        }
    }
    //get the wizard being run
    sWizard = pVarSetIn->get(GET_BSTR(DCTVS_Options_Wizard)); 
    if (!UStrICmp(sWizard, L"security"))
        bSkipSourceSid = TRUE;
    else
        bSkipSourceSid = FALSE;

    nThreads = pVarSetIn->get(GET_BSTR(DCTVS_Options_MaxThreads));

    text = pVarSetIn->get(GET_BSTR(DCTVS_Options_AppendToLogs));
    if (! UStrICmp(text,GET_STRING(IDS_YES)) )
    {
        bAppend = 1;
    }
    log = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchLog));
    err.LogOpen((WCHAR*)log,bAppend);

    // open the internal log "dispatcher.csv" and try to reserve enough
    // disk space for it
    // if we cannot, agent dispatching fails with an error
    DWORD rc = ERROR_SUCCESS;
    _bstr_t internalLog = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchCSV));
    BOOL bLogOpened = errLog.LogOpen((WCHAR*)internalLog,0,0,true);
    if (!bLogOpened)
        rc = GetLastError();

    if (rc == ERROR_SUCCESS)
    {
        LONG lServers = pVarSetIn->get(GET_BSTR(DCTVS_Servers_NumItems));
        DWORD dwNumOfBytes = sizeof(WCHAR) * (2 * (22 + MAX_PATH)  // the first two lines
                                               + (22 + 10)           // the third line
                                               + lServers * 2000    // 2000 WCHAR per server
                                               );
        //dwNumOfBytes = 1000000000;
        rc = errLog.ExtendSize(dwNumOfBytes);
    }
    
    if (rc != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(rc);
        errLog.LogClose();
        _bstr_t errMsg = errLog.GetMsgText(DCT_MSG_CANNOT_WRITE_INTERNAL_DISPATCH_LOG_D, hr);
        err.SysMsgWrite(ErrE, HRESULT_CODE(hr),DCT_MSG_CANNOT_WRITE_INTERNAL_DISPATCH_LOG_D, hr);
        return Error((WCHAR*) errMsg, GUID_NULL, hr);
    }

    // make sure this dispatcher.csv file is written starting from the current file pointer
    errLog.SetWriteOnCurrentPosition(TRUE);
   
    // write the log file into dispatcher.csv
    errLog.DbgMsgWrite(0,L"%ls",(WCHAR*)log);
    
    // default to 20 threads if the client doesn't specify
    if ( ! nThreads )
    {
        nThreads = 20;
    }

    // Get the name of the local computer
    DWORD                     dim = DIM(gComputerName);

    GetComputerName(gComputerName,&dim);

    m_pThreadPool = new TJobDispatcher(nThreads);
    if (!m_pThreadPool)
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    // write the common result path into dispatcher.csv
    _bstr_t bstrResultDir = pVarSetIn->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
    errLog.DbgMsgWrite(0,L"%ls",(WCHAR*)bstrResultDir);

    // check whether it is account reference report
    BOOL bAccountReferenceReport = FALSE;
    _bstr_t bstrGenerateReport = pVarSetIn->get(GET_BSTR(DCTVS_Reports_Generate));
    _bstr_t bstrAccountRefReport = pVarSetIn->get(GET_BSTR(DCTVS_Reports_AccountReferences));
    if (!UStrICmp(bstrGenerateReport, GET_STRING(IDS_YES))
        && !UStrICmp(bstrAccountRefReport,GET_STRING(IDS_YES)))
        bAccountReferenceReport = TRUE;

    //
    // only generate a new cache file if migration task is not the
    // retry task as the retry task uses persisted cache file(s)
    // a cache file is not necessary if it is account reference report
    //
    if (UStrICmp(sWizard, L"retry") != 0 && !bAccountReferenceReport)
    {
        // Build an input file for the ST cache, to send to each server
        hr = BuildInputFile(pVarSetIn);

        if ( FAILED(hr) )
        {
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_CACHE_CONSTRUCTION_FAILED);
            bFatalError = TRUE;
        }
    }

    // Split out the remotable tasks for each server
    // Get the sids for the source and target domains
    // note: if a sid mapping file is used, we do not need to get sids for source and target domains
    //
    // In case of account reference report, we need to set up the dctcache on the client machine
    // as if we're using migrated object table because the account reference report relies on
    // TRidCache::Lookup (called when MOT is used) which requires valid source and target sids.
    // This logic is added because with a fresh install of database, DCTVS_AccountOptions_SecurityInputMOT
    // is not set for account reference report.
    _bstr_t bstrUseMOT = pVarSetIn->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
    if (bAccountReferenceReport || !UStrICmp(bstrUseMOT,GET_STRING(IDS_YES)))
    {
        PSID                      pSidSrc = NULL;
        PSID                      pSidTgt = NULL;

        _bstr_t                   source = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomain));
        _bstr_t                   target = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomain));

        //if security translation, retrieve source sid and convert so
        //that it can be convert back below
        if (bSkipSourceSid)
        {
            _bstr_t sSid = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomainSid));
            pSidSrc = SidFromString((WCHAR*)sSid);
        }
        else  //else get the sid now
            GetSidForDomain((WCHAR*)source,&pSidSrc);
        GetSidForDomain((WCHAR*)target,&pSidTgt);

        if ( pSidSrc && pSidTgt )
        {
            WCHAR            txtSid[200];
            DWORD            lenTxt = DIM(txtSid);

            if ( GetTextualSid(pSidSrc,txtSid,&lenTxt) )
            {
                pVarSetIn->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
            }
            lenTxt = DIM(txtSid);
            if ( GetTextualSid(pSidTgt,txtSid,&lenTxt) )
            {
                pVarSetIn->put(GET_BSTR(DCTVS_Options_TargetDomainSid),txtSid);
            }
            FreeSid(pSidSrc);
            FreeSid(pSidTgt);
        }
        else
        {
            if ( source.length() && ! pSidSrc )
            {
                err.MsgWrite(ErrE,DCT_MSG_DOMAIN_SID_NOT_FOUND_S,(WCHAR*)source);
                bFatalError = TRUE;
            }
            else if ( target.length() && ! pSidTgt )
            {
                err.MsgWrite(ErrE,DCT_MSG_DOMAIN_SID_NOT_FOUND_S,(WCHAR*)target);
                bFatalError = TRUE;
            }
        }
    }
    MergeServerList(pVarSetIn);

    TNodeList               * fileList = new TNodeList;
    if (!fileList)
    {
        delete m_pThreadPool;
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Build list of files to install for plug-ins (if any)
    // but for retry case, we should not build the plugin file list now
    if (UStrICmp(sWizard, L"retry") != 0)
        hr = BuildPlugInFileList(fileList,pVarSetIn);

    if(!SUCCEEDED(hr))
    {

        delete m_pThreadPool;
        delete fileList;
        return hr;
    }

    // Make a copy of the varset with the server lists removed,
    // so we don't have to copy the entire server list for each agent
    gCS.Enter();
    IVarSet                 * pTemp = NULL;
    IVarSetPtr                pVarSetTemp(CLSID_VarSet);

    hr = pVarSetTemp->ImportSubTree(_bstr_t(L""),pVarSetIn);
    if ( SUCCEEDED(hr) )
    {
        hr = pVarSetTemp->raw_getReference(SysAllocString(L"MigrateServers"),&pTemp);
        if ( SUCCEEDED(hr) )
        {
            pTemp->Clear();
            pTemp->Release();
            pTemp = NULL;
        }
        hr = pVarSetTemp->raw_getReference(SysAllocString(L"Servers"),&pTemp);
        if ( SUCCEEDED(hr) )
        {
            pTemp->Clear();
            pTemp->Release();
            pTemp = NULL;
        }
    }
    else
    {
        bFatalError = TRUE;
    }
    gCS.Leave();

    m_startFailedVector.clear();

    // log the number of agents to be dispatched into dispatcher.csv
    LONG nServerCount = pVarSetIn->get(GET_BSTR(DCTVS_Servers_NumItems));
    if ( nServerCount && ! bFatalError )
    {
        err.MsgWrite(0,DCT_MSG_DISPATCH_SERVER_COUNT_D,nServerCount);
        errLog.DbgMsgWrite(0,L"%ld",nServerCount);
    }
    else
    {
        // no agent will be dispatched
        err.MsgWrite(0,DCT_MSG_DISPATCH_SERVER_COUNT_D,0);
        errLog.DbgMsgWrite(0,L"%ld",0);
    }

    // if it is in test mode, there is no skipping
    text = pVarSetIn->get(GET_BSTR(DCTVS_Options_NoChange));
    BOOL bNoChange = (!UStrICmp(text, GET_STRING(IDS_YES))) ? TRUE : FALSE;

    // reset the index for servers
    nServers = 0;
    
    while (nServers < nServerCount)
    {
        if ( bFatalError )
        {
            break;
        }
        swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),nServers);
        skip = pVarSetIn->get(key);

        swprintf(key,GET_STRING(DCTVSFmt_Servers_D),nServers);
        serverName = pVarSetIn->get(key);

        swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_DnsName_D),nServers);
        serverNameDns = pVarSetIn->get(key);

        // to test whether to skip, use the same logic as in mergeserverlist
        if ((serverName.length()) 
             && (bNoChange || !skip || !UStrICmp(skip,GET_STRING(IDS_No))))
        {
            IVarSetPtr          pVS(CLSID_VarSet);

            InstallJobInfo    * pInfo = new InstallJobInfo;
            if (!pInfo)
            {
                delete fileList;
                delete m_pThreadPool;
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }

            if ( pVS == NULL )
            { 
                return E_FAIL;
            }

            swprintf(key, L"Servers.%ld.JobFile", nServers);
            _bstr_t     file = pVarSetIn->get(key);

            // Set up job structure
            pInfo->pVarSetList = pVarSetIn;
            pInfo->pVarSet = pVarSetTemp;
            pInfo->serverName = serverName;
            pInfo->serverNameDns = serverNameDns;
            pInfo->ndx = nServers;
            pInfo->pPlugInFileList = fileList;
            pInfo->pStartFailedVector = &m_startFailedVector;
            pInfo->pFailureDescVector = &m_failureDescVector;
            pInfo->pStartedVector = &m_startedVector;
            pInfo->pJobidVector = &m_jobidVector;
            pInfo->hMutex = m_hMutex;
            pInfo->nErrCount = 0;
            if ( file.length() )
            {
                pInfo->jobfile = file;
            }
            err.MsgWrite(0,DCT_MSG_DISPATCHING_TO_SERVER_S,pInfo->GetServerName());
            errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",(WCHAR*)pInfo->GetServerName(),L"WillInstall",0);
            m_pThreadPool->SubmitJob(&DoInstall,(void *)pInfo);
            nServers++;
        }
    }
   
    // launch a thread to wait for all jobs to finish, then clean up and exit
    WaitInfo* wInfo = new WaitInfo;
    if (!wInfo)
    {
        delete fileList;
        delete m_pThreadPool;
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    wInfo->ppPool = &m_pThreadPool;
    wInfo->pUnknown = NULL;
    wInfo->pPlugInFileList = fileList;

    QueryInterface(IID_IUnknown,(LPVOID*)&(wInfo->pUnknown));

    DWORD                     id = 0;
    HANDLE                     waitHandle = CreateThread(NULL,0,&Wait,(void *)wInfo,0,&id);

    if(waitHandle)
    {
        CloseHandle(waitHandle);   
    }

    return hr;
}
  

STDMETHODIMP CDCTDispatcher::AllAgentsStarted(long *bAllAgentsStarted)
{
   *bAllAgentsStarted = m_pThreadPool == NULL;
	return S_OK;
}

SAFEARRAY* MakeSafeArray(std::vector<CComBSTR>& stVector)
{
    SAFEARRAYBOUND rgsabound[1];    
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = stVector.size();

    SAFEARRAY FAR* psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    if (psa)
    {
        std::vector<CComBSTR>::iterator iter = stVector.begin();
        for(long i=0; iter != stVector.end(); ++iter, ++i)
        {
            _ASSERTE(*iter && *iter != L"");
            BSTR insert = (*iter).Copy();
            if (insert == NULL || FAILED(SafeArrayPutElement(psa, &i, (void*)insert)))
            {
                if (insert)
                    SysFreeString(insert);
                SafeArrayDestroy(psa);
                psa = NULL;
                break;
            }
        }
        stVector.clear();
    }
    return psa;
}

STDMETHODIMP CDCTDispatcher::GetStartedAgentsInfo(long* bAllAgentsStarted, SAFEARRAY** ppbstrStartedAgents, SAFEARRAY** ppbstrJobid, SAFEARRAY** ppbstrFailedAgents, SAFEARRAY** ppbstrFailureDesc)
{
   *bAllAgentsStarted = m_pThreadPool == NULL;

//   DWORD res = ::WaitForSingleObject(m_hMutex, 30000);
   ::WaitForSingleObject(m_hMutex, 30000);
   *ppbstrFailedAgents = MakeSafeArray(m_startFailedVector);
   *ppbstrFailureDesc = MakeSafeArray(m_failureDescVector);

   _ASSERTE(m_startedVector.size() == m_jobidVector.size());
   *ppbstrStartedAgents = MakeSafeArray(m_startedVector);
   *ppbstrJobid = MakeSafeArray(m_jobidVector);
   ::ReleaseMutex(m_hMutex);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\ddisp.h ===
/*---------------------------------------------------------------------------
  File: DCTDispatcher.h

  Comments: COM object that remotely installs and starts the EDA agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
	
// DCTDispatcher.h : Declaration of the CDCTDispatcher

#ifndef __DCTDISPATCHER_H_
#define __DCTDISPATCHER_H_

#include "resource.h"       // main symbols
#include <mtx.h>
#include <vector>
class TJobDispatcher;

//#import "\bin\McsVarSetMin.tlb" no_namespace , named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CDCTDispatcher
class ATL_NO_VTABLE CDCTDispatcher : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTDispatcher, &CLSID_DCTDispatcher>,
   public IDispatchImpl<IDCTDispatcher, &IID_IDCTDispatcher, &LIBID_MCSDISPATCHERLib>
{
public:
	CDCTDispatcher()
	{
		m_pUnkMarshaler = NULL;
      m_hMutex = CreateMutex(0, 0, 0);
	}

   ~CDCTDispatcher() { ::CloseHandle(m_hMutex); }

DECLARE_REGISTRY_RESOURCEID(IDR_DCTDISPATCHER)
DECLARE_NOT_AGGREGATABLE(CDCTDispatcher)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTDispatcher)
   COM_INTERFACE_ENTRY(IDCTDispatcher)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IDCTDispatcher
public:
	STDMETHOD(GetStartedAgentsInfo)(long* nNumStartedAgents, SAFEARRAY** ppbstrStartedAgents, SAFEARRAY** ppbstrJobid, SAFEARRAY** ppbstrFailedAgents, SAFEARRAY** ppbstrFailureDesc);
	STDMETHOD(AllAgentsStarted)(long* bAllAgentsStarted);
   STDMETHOD(DispatchToServers)(IUnknown ** ppWorkItem);
protected:
   std::vector<CComBSTR> m_startFailedVector;
   std::vector<CComBSTR> m_failureDescVector;
   std::vector<CComBSTR> m_startedVector;
   std::vector<CComBSTR> m_jobidVector;
   TJobDispatcher* m_pThreadPool;
   HANDLE m_hMutex;

   HRESULT BuildInputFile(IVarSet * pVarSet);
   void MergeServerList(IVarSet * pVarSet);
   
STDMETHOD(Process)(
      IUnknown             * pWorkItem,    // in - varset containing job information and list of servers  
      IUnknown            ** ppResponse,   // out- not used
      UINT                 * pDisposition  // out- not used  
   );
   
   };

#endif //__DCTDISPATCHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\dinst.cpp ===
/*---------------------------------------------------------------------------
  File: DCTInstaller.cpp

  Comments: implementation of COM object that installs the DCT agent service.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

// DCTInstaller.cpp : Implementation of CDCTInstaller
#include "stdafx.h"
//#include "McsDispatcher.h"
#include "Dispatch.h"
#include "DInst.h"

#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "QProcess.hpp"
#include "IsAdmin.hpp"
#include "TSync.hpp"
#include "TReg.hpp"
#include "TInst.h"
#include "TFile.hpp"
#include "ResStr.h"
#include "sd.hpp"
#include "CommaLog.hpp"
#include "folders.h"

using namespace nsFolders;

#include <lm.h>

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

TErrorDct                      err;
TError                       & errCommon = err;
StringLoader                   gString;
extern TErrorDct               errLog;

#ifdef OFA
#define AGENT_EXE              L"OFAAgent.exe"
#define SERVICE_EXE            L"OFAAgentService.exe"
#else
#define AGENT_EXE              GET_STRING(IDS_AGENT_EXE)
#define SERVICE_EXE            GET_STRING(IDS_SERVICE_EXE)
#endif
#define MSVCP60_DLL			GET_STRING(IDS_MSVCP60_DLL)
#define WORKER_DLL             GET_STRING(IDS_WORKER_DLL)
#define VARSET_DLL             GET_STRING(IDS_VARSET_DLL)
#define DATA_FILE              GET_STRING(IDS_DATA_FILE)
#define RESOURCE_DLL           L"McsDmRes.dll"
#define MESSAGE_DLL            L"McsDmMsg.dll"
#define CACHE_FILE             L"DCTCache"

#define AGENT_INTEL_DIR        GET_STRING(IDS_AGENT_INTEL_DIR)
#define AGENT_ALPHA_DIR        GET_STRING(IDS_AGENT_ALPHA_DIR)

/////////////////////////////////////////////////////////////////////////////
// CDCTInstaller

namespace {
   class workerDeleteFile {
      _bstr_t m_strFile;
   public:
      workerDeleteFile(_bstr_t strFile):m_strFile(strFile)
      {}
      ~workerDeleteFile()
      { ::DeleteFile(m_strFile); }
   };

   union Time {
   FILETIME m_stFileTime;
   LONGLONG m_llTime;
   };

   bool IsServiceInstalling(_bstr_t sDirSysTgt, _bstr_t strTemp1, _bstr_t strTemp2)
   {
      bool bRes = false;
      HANDLE hFind;
      WIN32_FIND_DATA findData1;
      if((hFind = FindFirstFile(strTemp1, &findData1)) != INVALID_HANDLE_VALUE)
      {
         WIN32_FIND_DATA findData2;
         ::FindClose(hFind);
         hFind = CreateFile(
            strTemp2,          // pointer to name of the file
            GENERIC_WRITE,       // access (read-write) mode
            0,           // share mode
            0,
            // pointer to security attributes
            CREATE_ALWAYS,  // how to create
            FILE_ATTRIBUTE_NORMAL,   // file attributes
            0          // handle to file with attributes to 
            );
         if(hFind != INVALID_HANDLE_VALUE)
         {
            CloseHandle(hFind);
            hFind = FindFirstFile(strTemp2, &findData2);
            ::DeleteFile(strTemp2);
            if(hFind != INVALID_HANDLE_VALUE)
            {
               ::FindClose(hFind);
               // look at difference in file creation times
               Time t1, t2;
               t1.m_stFileTime = findData1.ftCreationTime;
               t2.m_stFileTime = findData2.ftCreationTime;
               LONGLONG lldiff = t2.m_llTime - t1.m_llTime;
               if((lldiff/10000000) <= 600)
                  bRes = true;
            }
         }
      }
      
      if(!bRes)
      {
         hFind = CreateFile(
            strTemp1,          // pointer to name of the file
            GENERIC_WRITE,       // access (read-write) mode
            0,           // share mode
            0,
            // pointer to security attributes
            CREATE_ALWAYS,  // how to create
            FILE_ATTRIBUTE_NORMAL,   // file attributes
            0          // handle to file with attributes to 
            );
         if(hFind != INVALID_HANDLE_VALUE)
            ::CloseHandle(hFind);
      }

      return bRes;
   }

   bool IsServiceRunning(_bstr_t strServer)
   {
      SC_HANDLE hScm = OpenSCManager(strServer, NULL, GENERIC_READ);
      if(!hScm)
      {
         err.DbgMsgWrite(ErrW,L"Could not open SCManager on %s : GetLastError() returned %d", 
            (WCHAR*)strServer, GetLastError());
         return false;
      }

      CComBSTR bstrServiceName(L"OnePointFileAdminService");
      SC_HANDLE hSvc = OpenService(hScm, GET_STRING(IDS_SERVICE_NAME), GENERIC_READ);
      
      if(!hSvc)
      {
         if ( GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST )
            err.DbgMsgWrite(ErrW,L"Could not open service on %s : GetLastError() returned %d", 
               (WCHAR*)strServer, GetLastError());
         CloseServiceHandle(hScm);
         return false;
      }
      CloseServiceHandle(hScm);

      SERVICE_STATUS status;
      BOOL bRes = QueryServiceStatus(hSvc, &status);
      
      if(!bRes)
      {
         err.DbgMsgWrite(ErrW,L"Could not get service status on %s : GetLastError() returned %d", 
            (WCHAR*)strServer, GetLastError());
         CloseServiceHandle(hSvc);
         return false;
      }
      CloseServiceHandle(hSvc);
      if(status.dwCurrentState != SERVICE_STOPPED)
         return true;
      else
         return false;
   }
}


typedef struct {
	int majorVersion;
	int minorVersion;
} OSVersion;

OSVersion GetTargetOSVersion(LPWSTR sServerName)
{
   DWORD rc = NERR_Success;
   SERVER_INFO_101 * servInfo = NULL;
   OSVersion osVersion = { 4, 0 };
   
      // Check version info
   rc = NetServerGetInfo(sServerName, 101, (LPBYTE *)&servInfo);
   if (rc == NERR_Success)
   {
   	osVersion.majorVersion = servInfo->sv101_version_major;
   	osVersion.minorVersion = servInfo->sv101_version_minor;
      	NetApiBufferFree(servInfo);
   }

   return osVersion;
}

DWORD                                      // ret- OS return code
   CDCTInstaller::GetLocalMachineName()
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * buf = NULL;

   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&buf);
   if ( ! rc )
   {
      safecopy(m_LocalComputer,L"\\\\");
      UStrCpy(m_LocalComputer+2,buf->wki100_computername);
      NetApiBufferFree(buf);
   }
   return rc;
}

DWORD                                      // ret- OS return code
   GetPlugInDirectory(
      WCHAR                * directory     // out- directory where plug-in files are
   )
{
   TRegKey                   key;
   DWORD                     rc;
   
   // Get the plug-ins directory from the registry
   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"PlugInDirectory",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

DWORD                                     // ret- OS return code
   GetInstallationDirectory(
      WCHAR                * directory    // out- directory we were installed to
   )
{
   TRegKey                   key;
   DWORD                     rc;
   
   // Get the plug-ins directory from the registry
   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"Directory",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

DWORD                                      // ret- OS return code
   GetProgramFilesDirectory(
      WCHAR                * directory,    // out- location of program files directory
      WCHAR          const * computer      // in - computer to find PF directory on
   )
{
   TRegKey                   hklm;
   TRegKey                   key;
   DWORD                     rc;

   rc = hklm.Connect(HKEY_LOCAL_MACHINE,computer);
   if ( ! rc )
   {
      rc = key.Open(REGKEY_CURRENT_VERSION,&hklm);
   }
   if ( !rc )
   {
      rc = key.ValueGetStr(REGVAL_PROGRAM_FILES_DIRECTORY,directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

STDMETHODIMP                                    // ret- HRESULT
   CDCTInstaller::InstallToServer(
      BSTR                   serverName,        // in - computer name to install to
      BSTR                   configurationFile, // in - full path to job file (varset file, copied as part of install)
      BSTR                   bstrCacheFile      // in - cache file name
   )
{
   DWORD                     rcOs=0;       // OS return code

   if ( ! *m_LocalComputer )
   {
      rcOs = GetLocalMachineName();
      if ( rcOs )
      {
         err.SysMsgWrite(ErrE,rcOs,DCT_MSG_NO_LOCAL_MACHINE_NAME_D,rcOs);
         return HRESULT_FROM_WIN32(rcOs);
      }
   }
   
   // Check for admin privileges on the server
   rcOs = IsAdminRemote((WCHAR*)serverName);

   if ( rcOs == ERROR_ACCESS_DENIED )
   {
      err.MsgWrite(ErrE,DCT_MSG_NOT_ADMIN_ON_SERVER_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs == ERROR_BAD_NET_NAME )
   {
      err.MsgWrite(ErrE,DCT_MSG_NO_ADMIN_SHARES_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs == ERROR_BAD_NETPATH )
   {
      err.MsgWrite(ErrE,DCT_MSG_COMPUTER_NOT_FOUND_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if( rcOs == RPC_S_SERVER_UNAVAILABLE)
   {
      err.SysMsgWrite(ErrE, rcOs, DCT_MSG_AGENT_INSTALL_RPC_SERVER_UNAVAILABLE,(WCHAR*)serverName, rcOs);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs )
   {
      err.SysMsgWrite(ErrE,rcOs,DCT_MSG_NO_ADMIN_SHARE_SD,(WCHAR*)serverName,rcOs);
      return HRESULT_FROM_WIN32(rcOs);
   }
      
   TDCTInstall               x( serverName, m_LocalComputer );
   DWORD                     typeThis = 0;
   DWORD                     typeTarg = 0;
   BOOL						     bNoProgramFiles = FALSE;  
   BOOL                      bShareCreated = FALSE;
   SHARE_INFO_502            shareInfo;
            

   errCommon = err;
   do // once or until break
   {
      typeThis = QProcessor( m_LocalComputer );
      typeTarg = QProcessor( serverName );

	     //do not install to ALPHAs, atleast for Whistler Beta 2
	  if (typeTarg == PROCESSOR_IS_ALPHA)
         return CO_E_NOT_SUPPORTED;
   
      // Set installation directories for source and target

      WCHAR                sDirInstall[MAX_PATH];
      WCHAR                sDirPlugIn[MAX_PATH];
      WCHAR                sDirSrc[MAX_PATH];
      
      WCHAR                sDirTgt[MAX_PATH];
      WCHAR                sDirSysTgt[MAX_PATH];
      WCHAR                sDirTgtProgramFiles[MAX_PATH];
      WCHAR                sDirTgtProgramFilesLocal[MAX_PATH];
      WCHAR                sDestination[MAX_PATH];
      WCHAR                sSvc[MAX_PATH];
      SHARE_INFO_1       * shInfo1 = NULL;
      
      rcOs = GetInstallationDirectory(sDirInstall);
      if ( rcOs ) break;

      rcOs = GetPlugInDirectory(sDirPlugIn);
      if ( rcOs ) break;

      rcOs = GetProgramFilesDirectory(sDirTgtProgramFiles,serverName);
      if ( rcOs ) 
	   {
		   if ( rcOs != ERROR_FILE_NOT_FOUND )
         {
            break;
         }
         // this doesn't work on NT 3.51, so if we can't get the program files directory, we'll 
         // create a directory off the system root.
         safecopy(sDirTgtProgramFiles,"\\ADMIN$");
		   bNoProgramFiles = TRUE;
         rcOs = 0;
      }
      safecopy(sDirTgtProgramFilesLocal,sDirTgtProgramFiles);
      // See if the admin$ shares exist already
      if ( sDirTgtProgramFiles[1] == L':' && sDirTgtProgramFiles[2] == L'\\' )
      {
         BOOL                bNeedToCreateShare = FALSE;

         sDirTgtProgramFiles[1] = L'$';
         sDirTgtProgramFiles[2] = 0;
         rcOs = NetShareGetInfo(serverName,sDirTgtProgramFiles,1,(LPBYTE*)&shInfo1);
         if ( rcOs )
         {
            if ( rcOs == NERR_NetNameNotFound ) 
            {
               bNeedToCreateShare = TRUE;                           
            }
            else
            {
               bNeedToCreateShare = FALSE;
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_ADMIN_SHARE_GETINFO_FAILED_SSD,serverName,sDirTgtProgramFiles,rcOs);
               // put the program files path name back like it was
               sDirTgtProgramFiles[1] = L':';
               sDirTgtProgramFiles[2] = L'\\';

            }
         }
         else
         {
            if ( shInfo1->shi1_type & STYPE_SPECIAL )
            {
               // the admin share exists -- we'll just use it
               bNeedToCreateShare = FALSE;
               // put the program files path name back like it was
               sDirTgtProgramFiles[1] = L':';
               sDirTgtProgramFiles[2] = L'\\';
            }
            else
            {
               err.MsgWrite(0,DCT_MSG_SHARE_IS_NOT_ADMIN_SHARE_SS,serverName,shInfo1->shi1_netname);
               bNeedToCreateShare = TRUE;
            }
            NetApiBufferFree(shInfo1);
         }
         if ( bNeedToCreateShare )
         {
            SECURITY_DESCRIPTOR emptySD;
            WCHAR            shareName[LEN_Path];
            WCHAR            remark[LEN_Path];
            BYTE             emptyRelSD[LEN_Path];
            DWORD            lenEmptyRelSD = DIM(emptyRelSD);
            
            sDirTgtProgramFiles[1] = L':';
            sDirTgtProgramFiles[2] = L'\\';

            memset(&emptySD,0,(sizeof SECURITY_DESCRIPTOR));
            InitializeSecurityDescriptor(&emptySD,SECURITY_DESCRIPTOR_REVISION);
            MakeSelfRelativeSD(&emptySD,emptyRelSD,&lenEmptyRelSD);
            
            TSD              pSD((SECURITY_DESCRIPTOR*)emptyRelSD,McsShareSD,FALSE);
            PACL             dacl = NULL;
            TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,GetWellKnownSid(1/*ADMINISTRATORS*/));
            DWORD            lenInfo = (sizeof shareInfo);
            pSD.ACLAddAce(&dacl,&ace,0);
            pSD.SetDacl(dacl);

            UStrCpy(shareName,GET_STRING(IDS_HiddenShare));
            UStrCpy(remark,GET_STRING(IDS_HiddenShareRemark));
            
            memset(&shareInfo,0,(sizeof shareInfo));
            shareInfo.shi502_netname = shareName;
            shareInfo.shi502_type = STYPE_DISKTREE;
            shareInfo.shi502_remark = remark;
            shareInfo.shi502_max_uses = 1;
            shareInfo.shi502_path = sDirTgtProgramFiles;
            shareInfo.shi502_security_descriptor = pSD.MakeRelSD();

            rcOs = NetShareAdd(serverName,502,(LPBYTE)&shareInfo,&lenInfo);
            if ( rcOs )
            {
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_TEMP_SHARE_CREATE_FAILED_SSD,serverName,shareName,rcOs);
               break;
            }
            else
            {
               safecopy(sDirTgtProgramFiles,shareName);
               bShareCreated = TRUE;
            }
            free(shareInfo.shi502_security_descriptor);
            shareInfo.shi502_security_descriptor = NULL;
         }
      
      }
      else
      {
         // something went wrong...the program files directory is not in drive:\path format
         err.MsgWrite(ErrW,DCT_MSG_INVALID_PROGRAM_FILES_DIR_SS,serverName,sDirTgtProgramFiles);
      }
      
      // setup source directory name for install
      UStrCpy( sDirSrc, sDirInstall );
      switch ( typeTarg )
      {
      case PROCESSOR_IS_INTEL:
         if ( typeTarg != typeThis )
         {
            UStrCpy(sDirSrc + UStrLen(sDirSrc),AGENT_INTEL_DIR);
            UStrCpy(sDirPlugIn + UStrLen(sDirPlugIn),AGENT_INTEL_DIR);
         }
         break;
      case PROCESSOR_IS_ALPHA:
         if ( typeTarg != typeThis )
         {
            UStrCpy(sDirSrc + UStrLen(sDirSrc),AGENT_ALPHA_DIR);
            UStrCpy(sDirPlugIn + UStrLen(sDirPlugIn),AGENT_ALPHA_DIR);
         }
         break;
      default:
         rcOs = ERROR_CAN_NOT_COMPLETE;
         break;
      }
      if ( rcOs ) break;

	  //if the target machine is downlevel (NT4), dispatch NT4, non-robust, agent files
	  OSVersion osVersion = GetTargetOSVersion(serverName);
	  if (osVersion.majorVersion == 4)
	  {
		 _bstr_t sAgentDir = GET_STRING(IDS_AGENT_NT4_DIR);
		 if (UStrLen(sDirSrc) + sAgentDir.length() < MAX_PATH)
            wcscat(sDirSrc, (WCHAR*)sAgentDir);
		 if (UStrLen(sDirPlugIn) + sAgentDir.length() < MAX_PATH)
            wcscat(sDirPlugIn, (WCHAR*)sAgentDir);
	  }

      // setup target directory name for install
      UStrCpy( sDirTgt, serverName );
      UStrCpy( sDirTgt+UStrLen(sDirTgt), L"\\" );
      if ( sDirTgtProgramFiles[1] == L':' )
      {
         sDirTgtProgramFiles[1] = L'$';
      }
      UStrCpy(sDirTgt + UStrLen(sDirTgt),sDirTgtProgramFiles);
      
#ifdef OFA
      UStrCpy(sDirTgt + UStrLen(sDirTgt),L"\\OnePointFileAdminAgent\\");
#else
      UStrCpy(sDirTgt + UStrLen(sDirTgt),GET_STRING(IDS_AgentDirectoryName));
#endif

      // record the result path (on the remote machine) into the dispatcher.csv so that migration driver
      // knows where to look for results remotely
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ls",(WCHAR*)serverName,L"RemoteResultPath",sDirTgt);
      
      UStrCpy( sDirSysTgt, serverName );
      UStrCpy( sDirSysTgt+UStrLen(sDirSysTgt), L"\\ADMIN$\\System32\\" );
   
      _bstr_t strTemp1(sDirSysTgt), strTemp2(sDirSysTgt);
      strTemp1 += (BSTR)GET_STRING(IDS_TEMP_FILE_1);
      strTemp2 += (BSTR)GET_STRING(IDS_TEMP_FILE_2);
      if(IsServiceInstalling(sDirSysTgt, strTemp1, strTemp2))
      {
         err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_ALREADY_RUNNING,(WCHAR*)serverName);
#ifdef OFA
         return 0x88070040;
#else
         return HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING);
#endif
      }

      workerDeleteFile wrk(strTemp1);
 
      if(IsServiceRunning(serverName))
      {
         err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_ALREADY_RUNNING,(WCHAR*)serverName);
#ifdef OFA
         return 0x88070040;
#else 
         return HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING);
#endif
      }
      
      if ( bNoProgramFiles )
      {
#ifdef OFA
         UStrCpy(sSvc,"%systemroot%\\OnePointFileAdminAgent\\");
#else
         UStrCpy(sSvc,"%systemroot%\\OnePointDomainAgent\\");
#endif
         UStrCpy( sSvc + UStrLen(sSvc),SERVICE_EXE );
      }
      else
      {
         UStrCpy( sSvc, sDirTgtProgramFilesLocal );
#ifdef OFA
         UStrCpy( sSvc + UStrLen(sSvc),L"\\OnePointFileAdminAgent\\");
#else
         UStrCpy( sSvc + UStrLen(sSvc),L"\\OnePointDomainAgent\\");
#endif         
         UStrCpy( sSvc + UStrLen(sSvc),SERVICE_EXE );
         sSvc[1] = L':';
      }
      
      
      if ( UStrICmp(m_LocalComputer,serverName) )
      {
         x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),sSvc,NULL);
      }
      else
      {
         safecopy(sSvc,sDirSrc);
         UStrCpy(sSvc + UStrLen(sSvc),GET_STRING(IDS_SERVICE_EXE)); 
         x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),sSvc,NULL);
      }


      rcOs = x.ScmOpen();
      
      if ( rcOs ) break;
      
      x.ServiceStop();
      
      if ( UStrICmp( m_LocalComputer, serverName ) )
      {
         // Create the target directory, if it does not exist
         if ( ! CreateDirectory(sDirTgt,NULL) )
         {
            rcOs = GetLastError();
            if ( rcOs && rcOs != ERROR_ALREADY_EXISTS )
            {
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_CREATE_DIR_FAILED_SD,sDirTgt,rcOs);
               break;
            }
            else
                rcOs = 0;
         }
         // shared MCS files
            // source files
         TInstallFile         varset(VARSET_DLL,sDirSrc);
            // target\system32 files 
         TInstallFile         varsettargetsys(VARSET_DLL,sDirSysTgt,TRUE);
            // target\OnePoint files
         TInstallFile         varsettarget(VARSET_DLL,sDirTgt,TRUE);
         
         // agent specific files
         TInstallFile         worker(WORKER_DLL,sDirSrc);
         TInstallFile         agent(AGENT_EXE,sDirSrc);
         TInstallFile         service(SERVICE_EXE,sDirSrc);
         TInstallFile         resourceMsg(RESOURCE_DLL,sDirSrc);
         TInstallFile         eventMsg(MESSAGE_DLL,sDirSrc);
         
         TInstallFile         workertarget(WORKER_DLL,sDirTgt,TRUE);
         TInstallFile         agenttarget(AGENT_EXE,sDirTgt,TRUE);
         TInstallFile         servicetarget(SERVICE_EXE,sDirTgt,TRUE);
         TInstallFile         resourceMsgtarget(RESOURCE_DLL,sDirTgt,TRUE);
         TInstallFile         eventMsgtarget(MESSAGE_DLL,sDirTgt,TRUE);

         // copy msvcp60.dll from SystemFolder to the target if the server machine is win2k
         // the target folder is the same as the rest of files
         // Note: for IA64, they are bound to have Whistler on it so we don't need to copy msvcp60.dll over
         //         for NT4, we're using static linking so no dependency on msvcp60.dll
         if (osVersion.majorVersion == 5 && osVersion.minorVersion == 0)
        {
            WCHAR* lpwSystemFolder = new WCHAR[MAX_PATH];
            if (lpwSystemFolder != NULL)
            {
                int requiredSize = GetSystemDirectory(lpwSystemFolder, MAX_PATH);
                if (requiredSize != 0)
                {
                    if (requiredSize > MAX_PATH) 
                    {
                        delete[] lpwSystemFolder;
                        lpwSystemFolder = new WCHAR[requiredSize];
                        if (lpwSystemFolder != NULL)
                        {
                            GetSystemDirectory(lpwSystemFolder, requiredSize);
                        }
                    }
                    if (lpwSystemFolder != NULL)
                    {
                        TInstallFile msvcp60Src(MSVCP60_DLL, lpwSystemFolder);
                        TInstallFile msvcp60Trgt(MSVCP60_DLL, sDirTgt, TRUE);
#ifdef OFA
                        if (msvcp60Src.CompareFile(&msvcp60Trgt) > 0)
#endif
                        {
                            swprintf(sDestination, L"%s%s", sDirTgt, MSVCP60_DLL);
                            rcOs = msvcp60Src.CopyTo(sDestination);
                        }
                    }
                }
            }
            if (lpwSystemFolder != NULL)
                delete[] lpwSystemFolder;
            if (rcOs)
                break;
        }
         
#ifdef OFA
         if ( varset.CompareFile(&varsettargetsys) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,VARSET_DLL);
            rcOs = varset.CopyTo(sDestination);
            if (rcOs)
                break;
         }
         
#ifdef OFA
         if ( worker.CompareFile(&workertarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,WORKER_DLL);
            rcOs = worker.CopyTo(sDestination);
            if (rcOs)
                break;
         }

#ifdef OFA
         if ( agent.CompareFile(&agenttarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,AGENT_EXE);
            rcOs = agent.CopyTo(sDestination);
            if (rcOs)
                break;
         }

#ifdef OFA
         if ( service.CompareFile(&servicetarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,SERVICE_EXE);
            rcOs = service.CopyTo(sDestination);
            if (rcOs)
                break;
         }
#ifdef OFA
         if ( resourceMsg.CompareFile(&resourceMsgtarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,RESOURCE_DLL);
            rcOs = resourceMsg.CopyTo(sDestination);
            if (rcOs)
                break;
         }

#ifdef OFA
         if ( eventMsg.CompareFile(&eventMsgtarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,MESSAGE_DLL);
            rcOs = eventMsg.CopyTo(sDestination);
            if (rcOs)
                break;
         }

         // Copy files needed for plug-ins
         if ( m_PlugInFileList )
         {
            TNodeListEnum    e;
            TFileNode      * pNode;

            for ( pNode = (TFileNode*)e.OpenFirst(m_PlugInFileList) ; pNode ; pNode = (TFileNode*)e.Next() )
            {
               TInstallFile  plugInSource(pNode->FileName(),sDirPlugIn);
               TInstallFile  plugInTarget(pNode->FileName(),sDirTgt,TRUE);

               swprintf(sDestination,L"%s%s",sDirTgt,pNode->FileName());
               rcOs = plugInSource.CopyTo(sDestination);
               if (rcOs)
                break;
            }
            e.Close();
            if (rcOs)
                break;
         }
      }
      else
      {
         safecopy(sDirTgt,sDirSrc);
      }
         
         
      // Copy the job file
      // separate the directory and filename
      WCHAR         sConfigPath[MAX_PATH];
      
      safecopy(sConfigPath,(WCHAR*)configurationFile);
      
      WCHAR       * lastslash = wcsrchr(sConfigPath,L'\\');
      if ( lastslash )
      {
         *lastslash = 0;
      }

      WCHAR const * sConfigFile = lastslash + 1;
      
      TInstallFile         config(sConfigFile,sConfigPath);

      swprintf(sDestination,L"%s%s",sDirTgt,sConfigFile);
      rcOs = config.CopyTo(sDestination);
      if (rcOs)
        break; 

      //
      // copy cache file if one is specified
      //

      if (SysStringLen(bstrCacheFile) > 0)
      {
         TInstallFile cache(bstrCacheFile, sConfigPath);
         swprintf(sDestination, L"%s%s", sDirTgt, bstrCacheFile);
         rcOs = cache.CopyTo(sDestination);
         if (rcOs)
            break;
      }
      // start the service
      rcOs = x.ServiceStart();
   }  while ( FALSE );

   if ( bShareCreated )
   {
      DWORD rcDeleteShare = NetShareDel(serverName,GET_STRING(IDS_HiddenShare),0);
      if ( rcDeleteShare )
      {
         err.SysMsgWrite(ErrW,rcDeleteShare,DCT_MSG_SHARE_DEL_FAILED_SSD,serverName,GET_STRING(IDS_HiddenShare),rcDeleteShare);
      }
   }
   if ( rcOs && rcOs != E_ABORT )
   {
      if(rcOs == ERROR_BAD_NETPATH)
      {
          err.SysMsgWrite(
               ErrE,
               rcOs,
               DCT_MSG_AGENT_INSTALL_NETWORPATH_NOT_FOUND,
               (WCHAR*)serverName,
               rcOs);
      }
      else
      {
         err.SysMsgWrite(
               ErrE,
               rcOs,
               DCT_MSG_AGENT_INSTALL_FAILED_SD,
               (WCHAR*)serverName,
               rcOs);
      }
   }

   // always return an HRESULT   
   return HRESULT_FROM_WIN32(rcOs);
}

// Installs the agent to a computer
// VarSet input:
//    InstallToServer      - computer to install agent on
//    ConfigurationFile    - file containing varset for job, installed with agent
// 
STDMETHODIMP                               // ret- HRESULT
   CDCTInstaller::Process(
      IUnknown             * pWorkItem     // in - varset containing data
   )
{
    HRESULT                   hr = S_OK;
    IVarSetPtr                pVarSet = pWorkItem;
    _bstr_t                   serverName;
    _bstr_t                   dataFile;
    _bstr_t                   strCacheFile;

    // Read the server name
    serverName = pVarSet->get(GET_BSTR(DCTVS_InstallToServer));
    dataFile = pVarSet->get(GET_BSTR(DCTVS_ConfigurationFile));
    strCacheFile = pVarSet->get(GET_BSTR(DCTVS_CacheFile));
    if ( serverName.length() )
    {
        int accountReference = 0;  // indicates whether we have account reference report
        int joinDomainWithRename = 0;  // indicates wether we are trying to join domain with rename
        _bstr_t text = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));
        if (text.length())
            accountReference = 1;

        // the following test used to set joinDomainWithRename should be
        // parallel to what is being tested in ExecuteDCTJob function in dctagent.cpp
        text = pVarSet->get(GET_WSTR(DCTVS_LocalServer_RenameTo));
        if (text.length())
        {
            text = pVarSet->get(GET_WSTR(DCTVS_LocalServer_ChangeDomain));
            if ((WCHAR*)text && !UStrICmp(text, GET_STRING(IDS_YES)))
            {
                text = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomain));
                if ((WCHAR*)text)
                    joinDomainWithRename = 1;
            }
        }
        
        errLog.DbgMsgWrite(0,L"%ls\t%ls\t%d,%d,%ls",(WCHAR*)serverName,L"JobFile",accountReference,joinDomainWithRename,(WCHAR*)dataFile);
        hr = InstallToServer(serverName,dataFile,strCacheFile);
        _bstr_t strChoice = pVarSet->get(GET_BSTR(DCTVS_Options_DeleteJobFile));
        if(strChoice == _bstr_t(GET_STRING(IDS_YES)))
            ::DeleteFile(dataFile);
        errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",(WCHAR*)serverName,L"Install",HRESULT_CODE(hr));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\dinst.h ===
/*---------------------------------------------------------------------------
  File: DCTInstaller.h

  Comments: COM object that installs the DCT Agent Service on a remote machine.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
	
// DCTInstaller.h : Declaration of the CDCTInstaller

#ifndef __DCTINSTALLER_H_
#define __DCTINSTALLER_H_

#include "resource.h"       // main symbols

#include "EaLen.hpp"

//#include <mstask.h>
#include <comdef.h>
#include <mtx.h>
#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"

/////////////////////////////////////////////////////////////////////////////
// CDCTInstaller
class ATL_NO_VTABLE CDCTInstaller : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTInstaller, &CLSID_DCTInstaller>,
   public IWorkNode
   {
   _bstr_t                   m_SourcePath;
   _bstr_t                   m_TargetPath;
   WCHAR                     m_LocalComputer[LEN_Computer];
   TNodeList               * m_PlugInFileList;
public:
	CDCTInstaller()
	{
		m_LocalComputer[0] = L'\0';
      m_pUnkMarshaler = NULL;
      m_PlugInFileList = NULL;
	}
   void SetFileList(TNodeList *pList) { m_PlugInFileList = pList; }
DECLARE_REGISTRY_RESOURCEID(IDR_DCTINSTALLER)
DECLARE_NOT_AGGREGATABLE(CDCTInstaller)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTInstaller)
	COM_INTERFACE_ENTRY(IWorkNode)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IDCTInstaller
public:
	STDMETHOD(InstallToServer)(BSTR serverName, BSTR configurationFile, BSTR bstrCacheFile);

protected:
   // helper functions
   DWORD GetLocalMachineName();
   
public:
   
// IWorkNode
	STDMETHOD(Process)(IUnknown * pUnknown);

};

class TFileNode: public TNode
{
   WCHAR                     filename[LEN_Path];
public:
   TFileNode(WCHAR const * f) { safecopy(filename,f); }

   WCHAR const * FileName() { return filename; }
};


#endif //__DCTINSTALLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\qprocess.hpp ===
//#pragma title( "QProcess.hpp - Query type of processor on machine" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  QProcess.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-21
Description -  Query type of processor on machine
Updates     -
===============================================================================
*/

#ifndef  MCSINC_QProcess_hpp
#define  MCSINC_QProcess_hpp

// Returned value from QProcessor.
enum ProcessorType
      { PROCESSOR_IS_UNKNOWN, PROCESSOR_IS_INTEL, PROCESSOR_IS_ALPHA };

// Determine processor of machine
ProcessorType                              // ret-processor type
   QProcessor(
      TCHAR          const * machineName   // in -Machine name
   );

#endif  // MCSINC_QProcess_hpp

// QProcess.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\qprocess.cpp ===
//#pragma title( "QProcess.cpp - Query type of processor on machine" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  QProcess.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-21
Description -  Query type of processor on machine
Updates     -
===============================================================================
*/

#include <stdio.h>

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "TReg.hpp"
#include "QProcess.hpp"

extern TErrorDct err;

#define  REGKEY_ARCHITECTURE  TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define  REGVAL_ARCHITECTURE  TEXT("PROCESSOR_ARCHITECTURE")

// Determine processor of machine
ProcessorType                              // ret-processor type
   QProcessor(
      TCHAR          const * machineName   // in -Machine name
   )
{
   ProcessorType             processor=PROCESSOR_IS_UNKNOWN;
   DWORD                     rcOs;         // OS return code
   TRegKey                   regMachine;   // Registry object for target machine
   TRegKey                   regEnviron;   // Registry object for selected key
   TCHAR                     strEnviron[32];  // Selected value
   
   rcOs = regMachine.Connect( HKEY_LOCAL_MACHINE, machineName );
   if ( rcOs )
   {
      err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REG_CONNECT_FAILED_SD,
            machineName, rcOs );
   }
   else
   {
      rcOs = regEnviron.Open( REGKEY_ARCHITECTURE, &regMachine );
      if ( rcOs )
      {
         err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REGKEY_OPEN_FAILED_SSD,
               machineName, REGKEY_ARCHITECTURE, rcOs );
      }
      else
      {
         rcOs = regEnviron.ValueGetStr( REGVAL_ARCHITECTURE, strEnviron, sizeof strEnviron );
         if ( rcOs )
         {
            err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REGKEY_OPEN_FAILED_SSD,
                  machineName, REGKEY_ARCHITECTURE, REGVAL_ARCHITECTURE, rcOs );
         }
         else
         {
            if ( !UStrICmp( strEnviron, TEXT("x86") ) )
            {
               processor = PROCESSOR_IS_INTEL;
            }
            else if ( !UStrICmp( strEnviron, TEXT("ALPHA") ) )
            {
               processor = PROCESSOR_IS_ALPHA;
            }
            else
            {
               err.MsgWrite( ErrW,DCT_MSG_QPROCESSOR_UNRECOGNIZED_VALUE_SSSS,
                     machineName, REGKEY_ARCHITECTURE, REGVAL_ARCHITECTURE, strEnviron );
            }
         }
         regEnviron.Close();
      }
      regMachine.Close();
   }
   return processor;
}

// QProcess.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\dispatch.cpp ===
/*---------------------------------------------------------------------------
  File: Dispatcher.cpp

  Comments: COM server implementation for dispatcher, generated by ATL.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/// Dispatcher.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Dispatcherps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
//#include "..\Common\Include\McsDispatcher.h"
#include "Dispatch.h"

//#include "McsDispatcher_i.c"
#include "Dispatch_i.c"
#include "DDisp.h"
#include "DInst.h"
#include <MigrationMutex.h>
#include "sdhelper.h"


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
	bool bCreated = false;
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if (h != NULL)
	   bCreated = true;
    CloseHandle(h);
	return bCreated;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DCTDispatcher, CDCTDispatcher)
OBJECT_ENTRY(CLSID_DCTInstaller, CDCTInstaller)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	ATLTRACE(_T("{McsDispatcher.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);

	// obtain dispatcher mutex
	// the migration driver uses this mutex to determine
	// if the dispatcher process is currently running

	CMigrationMutex mutex(DISPATCHER_MUTEX, true);

	// set debug flags to check memory allocations and leaks
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif

    BOOL bSecurityInitialized = FALSE;

    _ASSERTE(SUCCEEDED(hRes));

    if ( SUCCEEDED(hRes) )
    {
        TSD*  adminsAndSystemSD = BuildAdminsAndSystemSDForCOM();
        if (adminsAndSystemSD)
        {
            hRes = CoInitializeSecurity(
                const_cast<SECURITY_DESCRIPTOR*>(adminsAndSystemSD->GetSD()), //Points to security descriptor
                -1,                          //Count of entries in asAuthSvc
                NULL,                        //Array of names to register
                NULL,                        //Reserved for future use
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,      //The default authentication
                                            //level for proxies
                RPC_C_IMP_LEVEL_IMPERSONATE, //The default impersonation
                                            //level for proxies
                NULL,                        //Reserved; must be set to NULL
                EOAC_NONE,                   //Additional client or
                                            //server-side capabilities
                NULL                         //Reserved for future use
            );
            if (SUCCEEDED(hRes))
                bSecurityInitialized = TRUE;
            if (adminsAndSystemSD)
                delete adminsAndSystemSD;
        }
    }
    else
    {
        // if CoInitialize fails, returns an error
        return 1;
    }

    // if CoInitializeSecurity fails, returns an error
    if (!bSecurityInitialized)
    {
        CoUninitialize();
        return 1;
    }

    _Module.Init(ObjectMap, hInstance, &LIBID_MCSDISPATCHERLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Dispatcher, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Dispatcher, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

	ATLTRACE(_T("{McsDispatcher.exe}_tWinMain() : hInstance=0x%08lX\n"), hInstance);
    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dispatch.rc
//
#define IDS_PROJNAME                    100
#define IDR_Dispatcher                  100
#define IDR_DCTDISPATCHER               101
#define IDS_FAILED_TO_BIND_TO_AGENT     101
#define IDR_DCTINSTALLER                102
#define IDR_WORKNODEPOOLEDDISPATCH      103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tinst.cpp ===
/*---------------------------------------------------------------------------
  File: TDCTInsall.cpp

  Comments: Utility class used by the dispatcher to install the DCT agent service.
  The TDCTInstall class encapsulates the service control management required
  to remotely install the agent service, configure it, and start it.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:33:17

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "TInst.h"

#include "ErrDct.hpp"

extern TErrorDct        err;

//-----------------------------------------------------------------------------
// Open service control manager
//-----------------------------------------------------------------------------

DWORD                                      // ret-OS return code
   TDCTInstall::ScmOpen(BOOL bSilent)
{
   DWORD                     rcOs=0;       // OS return code

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open SCM",
            m_sDisplayName,m_sComputer );
   }
   
   m_hScm = OpenSCManager(m_sComputer,NULL, SC_MANAGER_ALL_ACCESS );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install  on %ls End   - Open SCM",
            m_sDisplayName,m_sComputer );
   }
   
   if ( !m_hScm )
   {
      rcOs = GetLastError();
      if ( ! bSilent )
         err.SysMsgWrite(
            ErrW,
            rcOs,
            DCT_MSG_SCM_OPEN_FAILED_SD,
            m_sComputer,
            rcOs );
   }
   return rcOs;
}

//-----------------------------------------------------------------------------
// Close service control manager
//-----------------------------------------------------------------------------

void
   TDCTInstall::ScmClose()
{
   if ( m_hScm )
   {
      CloseServiceHandle( m_hScm );
      m_hScm = NULL;
   }
}

//-----------------------------------------------------------------------------
// Create and start the service
//-----------------------------------------------------------------------------

DWORD                                      // ret-OS return code
   TDCTInstall::ServiceStart()
{
   DWORD                     rcOs=0;       // OS return code
   WCHAR                     sFile[LEN_Path];
   SC_HANDLE                 hSvc;         // Service handle
   BOOL                      bRc;          // boolean return code

   
   MCSASSERT(*m_sExeName);
   MCSASSERT(*m_sDisplayName);
   MCSASSERT(*m_sServiceName);

   
   swprintf(sFile,L"%s",m_sExeName);
   
   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open %ls service",
            m_sDisplayName,
            m_sComputer,
            m_sServiceName
            );
   }
   hSvc = OpenService( m_hScm, m_sServiceName, SERVICE_ALL_ACCESS );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls End   - Open %ls service",
            m_sDisplayName, m_sComputer, m_sServiceName );
   }
   
   if ( !hSvc )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case ERROR_SERVICE_DOES_NOT_EXIST:
            break; // no message for this case
         default:
            err.SysMsgWrite(
                  ErrW,
                  rcOs,
                  DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                  m_sComputer,
                  m_sServiceName,
                  rcOs );
            break;
      }
      rcOs = 0;
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Create %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }

      hSvc = CreateService( m_hScm,     // SCM database handle
            m_sServiceName,             // Name of service
            m_sDisplayName,             // Display name
            SERVICE_ALL_ACCESS,         // Type of access to service
            SERVICE_WIN32_OWN_PROCESS,  // Type of service
            m_StartType,                // When to start service
            SERVICE_ERROR_NORMAL,       // Severity if service fails to start
            sFile,                      // Name of binary file
            NULL,                       // Name of load ordering group
            NULL,                       // Variable to get tag identifier
 //           m_sDependencies,            // Array of dependency names
            NULL,
            *m_sServiceAccount ? m_sServiceAccount : NULL,          // Account name of service
            *m_sServiceAccountPassword ? m_sServiceAccountPassword : NULL); // Password for service account

      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Create %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      if ( !hSvc )
      {
         rcOs = GetLastError();
         
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_CREATE_SERVICE_FAILED_SSSSD,
               m_sServiceName,
               m_sDisplayName,
               sFile,
               m_sDependencies,
               rcOs );
      }
   }
   else
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Configure %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      
      bRc = ChangeServiceConfig(
            hSvc,                       // service handle
            SERVICE_WIN32_OWN_PROCESS,  // Type of service
            m_StartType,                // When to start service
            SERVICE_ERROR_NORMAL,       // Severity if service fails to start
            sFile,                      // Name of binary file
            NULL,                       // Name of load ordering group
            NULL,                       // Variable to get tag identifier
            m_sDependencies,            // Array of dependency names
            *m_sServiceAccount ? m_sServiceAccount : NULL,          // Account name of service
            *m_sServiceAccountPassword ? m_sServiceAccountPassword : NULL,  // Password for service account
            m_sDisplayName );           // Display name
      
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Configure %ls service",
               m_sDisplayName,m_sComputer, m_sServiceName );
      }
      if ( !bRc )
      {
         rcOs = GetLastError();
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_CHANGE_SERVICE_CONFIG_FAILED_SSSSD,
               m_sServiceName,
               m_sDisplayName,
               sFile,
               m_sDependencies,
               rcOs );
      }

   }

   if ( hSvc )
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Start %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      int nCnt = 0;
      do
      {
         bRc = StartService( hSvc, 0, NULL );
         if ( !bRc )
         {
            Sleep(5000);
            nCnt++;
            err.DbgMsgWrite(0, L"Start service failed.");
         }
      } while ( !bRc && nCnt < 5 );
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Start %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      if ( !bRc ) 
      {
         rcOs = GetLastError();
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_START_SERVICE_FAILED_SD,
               m_sServiceName,
               rcOs );
      }
      else
      {
         Sleep( 2000 ); // give the service two seconds to get going
      }
      CloseServiceHandle( hSvc );
   }

   return rcOs;
}

//-----------------------------------------------------------------------------
// Stop the service if it is running
//-----------------------------------------------------------------------------

void
   TDCTInstall::ServiceStop()
{
   DWORD                     rcOs=0;       // OS return code
   SC_HANDLE                 hSvc;         // Service handle
   SERVICE_STATUS            SvcStat;      // Service status
   DWORD                     i;
   BOOL                      bRc;

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open %ls service",
            m_sDisplayName, m_sComputer,m_sServiceName );
   }

   hSvc = OpenService(
         m_hScm,
         m_sServiceName,
         SERVICE_STOP | SERVICE_INTERROGATE );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls End   - Open %ls service",
            m_sDisplayName, m_sComputer, m_sServiceName );
   }
   if ( !hSvc )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case ERROR_SERVICE_DOES_NOT_EXIST:
            break; // no message for this case
         default:
            err.SysMsgWrite(
                  ErrW,
                  rcOs,
                  DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                  m_sComputer,
                  m_sServiceName,
                  rcOs );
            break;
      }
   }
   else
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Interrogate %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      bRc = ControlService( hSvc, SERVICE_CONTROL_INTERROGATE, &SvcStat );
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End - Interrogate %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      if ( bRc )
      {
         if ( SvcStat.dwCurrentState != SERVICE_STOPPED )
         {  // Service is running
            if ( DebugLogging() )
            {
               err.DbgMsgWrite(
                     ErrI,
                     L"%ls install on %ls Start - Stop %ls service",
                     m_sDisplayName,m_sComputer,m_sServiceName);
            }
            bRc = ControlService( hSvc, SERVICE_CONTROL_STOP, &SvcStat );
            if ( DebugLogging() )
            {
               err.DbgMsgWrite(
                     ErrI,
                     L"%ls on %ls End   - Stop %ls service",
                     m_sDisplayName,m_sComputer,m_sServiceName);
            }
            if ( bRc )
            {  // Service accepted the stop request
               for ( i = 0;  i < 10;  i++ ) // 30 seconds total
               {
                  Sleep( 3000 ); // three seconds
                  if ( DebugLogging() )
                  {
                     err.DbgMsgWrite(
                           ErrI,
                           L"%ls install on %ls Start - Interrogate %ls service",
                           m_sDisplayName,m_sComputer,m_sServiceName);
                  }
                  bRc = ControlService(
                        hSvc,
                        SERVICE_CONTROL_INTERROGATE,
                        &SvcStat );
                  if ( DebugLogging() )
                  {
                     err.DbgMsgWrite(
                           ErrI,
                           L"%ls install on %ls End   - Interrogate %ls service",
                           m_sDisplayName,m_sComputer,m_sServiceName);
                  }
                  if ( !bRc )
                     break;
                  if ( SvcStat.dwCurrentState == SERVICE_STOPPED )
                     break;
               }
               if ( SvcStat.dwCurrentState != SERVICE_STOPPED )
               {
                  rcOs = GetLastError();
                  switch ( rcOs )
                  {
                     case 0:
                     case ERROR_SERVICE_NOT_ACTIVE: // Service is not running
                        break;
                     default:
                        err.SysMsgWrite(
                              ErrW,
                              rcOs,
                              DCT_MSG_SERVICE_STOP_FAILED_SSD,
                              m_sComputer,
                              m_sServiceName,
                              rcOs );
                        break;
                  }
               }
            }
         }
      }
      else
      {
         rcOs = GetLastError();
         rcOs = 0;
      }
      CloseServiceHandle( hSvc );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tfile.cpp ===
//#pragma title("TFile - Install File class")

/*---------------------------------------------------------------------------
  File: TFile.CPP

  Comments: This file contains file installation functions.

  (c) Copyright 1995-1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Author:  Juan Medrano                                                                            l
  Revision By: Christy Boles
  Revised on 7/9/97

 ---------------------------------------------------------------------------*/

#ifdef USE_STDAFX
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include <tchar.h>
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "TFile.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct     err;


//----------------------------------------------------------------------------
// TInstallFile::TInstallFile - constructor initializes variables and if 
// pszFileDir is specified, it will get file information for the file located
// in that directory.
//----------------------------------------------------------------------------
   TInstallFile::TInstallFile(
      TCHAR const * pszFileName,             // in  -file name (not a full path)
      TCHAR const * pszFileDir,              // in  -directory path (without file name)
      BOOL          silent
   )
{
   m_bCopyNeeded = FALSE;
   m_VersionInfo = NULL;
   m_dwLanguageCode = 0;
   m_szFileName[0] = 0;
   m_szFilePath[0] = 0;
   m_szTargetPath[0] = 0;
   m_szFileVersion[0] = 0;
   m_szFileSize[0] = 0;
   m_szFileDateTime[0] = 0;
   m_bSilent = silent;

   ZeroMemory( &m_FixedFileInfo, sizeof m_FixedFileInfo );
   ZeroMemory( &m_FileData, sizeof m_FileData );

   if ( pszFileName )
   {
      safecopy(m_szFileName,pszFileName);
   }

   if ( pszFileDir )
   {
      OpenFileInfo( pszFileDir );
   }
}

//----------------------------------------------------------------------------
// TInstallFile::OpenFileInfo - gathers file information (file size, mod time,
// version info) and stores it in member variables for later use.
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TInstallFile::OpenFileInfo(
      TCHAR const * pszFileDir               // in  -directory path (without filename)
   )
{
   DWORD                rc = 0;              // OS return code
   DWORD                dwBytes;             // version info structure size
   DWORD                dwHandle;            // version info handle
   DWORD              * dwVerPointer;        // pointer to version language code
   UINT                 uBytes;              // version info size
   HANDLE               hFile;               // file handle
   VS_FIXEDFILEINFO   * lpBuffer;            // pointer to version info structure

   // construct a full path for the file
   safecopy(m_szFilePath,pszFileDir);
   UStrCpy(m_szFilePath + UStrLen(m_szFilePath),TEXT("\\"));
   UStrCpy(m_szFilePath + UStrLen(m_szFilePath),m_szFileName);

   // get file size, mod time info
   hFile = FindFirstFile( m_szFilePath, &m_FileData );
   if ( hFile == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( ! m_bSilent )
      {
         err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_OPEN_FILE_INFO_FAILED_SD,
                       m_szFilePath,
                       rc );
      }
   }
   else
   {
      FindClose( hFile );
      dwBytes = GetFileVersionInfoSize( m_szFilePath, &dwHandle );
      if ( dwBytes <= 0 )
      {
         //err.MsgWrite( 0,
         //             "No version resource: %ls",
         //             m_szFilePath );
      }
      else
      {
         delete [] m_VersionInfo;
         m_VersionInfo = new WCHAR[dwBytes + 1];

         // get version resource info
         if ( ! GetFileVersionInfo( m_szFilePath, 
                                    0, 
                                    dwBytes, 
                                    m_VersionInfo ) )
         {
            rc = GetLastError();
            if ( ! m_bSilent )
            {

               err.SysMsgWrite( 0,
                             rc,
                             DCT_MSG_GET_VERSION_INFO_FAILED_SD,
                             m_szFilePath,
                             rc );
            }
         }
         else
         {
            // get fixed file info
            if ( ! VerQueryValue( m_VersionInfo,
                                  TEXT("\\"),
                                  (void **) &lpBuffer,
                                  &uBytes) )
            {
               if ( ! m_bSilent )
               {
                  err.MsgWrite( 0,
                             DCT_MSG_VER_QUERY_VALUE_FAILED_SS,           
                             m_szFilePath,
                             L"\\");
               }
            }
            else
            {
               m_FixedFileInfo = *lpBuffer;

               // get variable file info language code
               if ( ! VerQueryValue( m_VersionInfo,  
                                     TEXT("\\VarFileInfo\\Translation"), 
                                     (void **) &dwVerPointer, 
                                     &uBytes) )
               {
                  if ( ! m_bSilent )
                  {
                     err.MsgWrite( 0,
                                DCT_MSG_VER_QUERY_VALUE_FAILED_SS,
                                m_szFilePath,
                                L"\\VarFileInfo\\Translation");
                  }
               }
               else
               {
                  m_dwLanguageCode = *dwVerPointer;
               }
            }
         }
      }
   }

   return rc;
}

//----------------------------------------------------------------------------
// TInstallFile::CopyTo - copies the file to a destination path. if it is busy,
// renames the file and tries to copy again.
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TInstallFile::CopyTo(
      TCHAR const * pszDestinationPath       // in  -destination path (full path)
   )
{
   DWORD    rc = 0;                          // OS return code
   DWORD    dwFileAttributes;                // file attribute mask

   // make sure read-only flag of destination is turned off
   dwFileAttributes = ::GetFileAttributes( pszDestinationPath );
   if ( dwFileAttributes != 0xFFFFFFFF )
   {
      // Turn off read-only file attribute
      if ( dwFileAttributes & FILE_ATTRIBUTE_READONLY )
      {
         ::SetFileAttributes( pszDestinationPath, 
                              dwFileAttributes & ~FILE_ATTRIBUTE_READONLY );
      }
   }

   // copy file to destination path
   if ( ! ::CopyFile( m_szFilePath, pszDestinationPath, FALSE ) )
   {
      rc = GetLastError();
      err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_COPY_FILE_FAILED_SSD,
                       m_szFilePath,
                       pszDestinationPath,
                       rc );
   }

   return rc;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFile - compares the version, date, and size of the 
// file object to the given target file object
//----------------------------------------------------------------------------
int                                          // ret -(-1) if source < target
   TInstallFile::CompareFile(                //      ( 0) if source = target
                                             //      ( 1) if source > target
      TInstallFile * pFileTrg                // in  -target file object
   )
{
   int      nComp;                           // comparison result

   nComp = CompareFileVersion( pFileTrg );
   if ( nComp == 0 )
   {
      // versions are the same, compare dates
      nComp = CompareFileDateTime( pFileTrg );
      if ( nComp <= 0 )
      {
         // source date is less than or equal to target date
         // compare file size
         nComp = CompareFileSize( pFileTrg );
         if ( nComp != 0 )
         {
            // file sizes are not equal, return (source > target)
            nComp = 1;
         }
      }
   }

   return nComp;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFileSize - compares the file size of the this file 
// object with the size of the target file object
//----------------------------------------------------------------------------
int                                       // ret -(-1) if source < target
   TInstallFile::CompareFileSize(         //      ( 0) if source = target
                                          //      ( 1) if source > target
      TInstallFile * pFileTrg             // in  -target file object
   )
{
   int      nCompResult = 0;              // comparison result  
   DWORD    dwSrcFileSize = 0;            // source file size
   DWORD    dwTrgFileSize = 0;            // target file size

   dwSrcFileSize = m_FileData.nFileSizeLow;
   dwTrgFileSize = pFileTrg->m_FileData.nFileSizeLow;

   if ( dwSrcFileSize && dwTrgFileSize )
   {
      if ( dwSrcFileSize < dwTrgFileSize )
      {
         nCompResult = -1;
      }
      else if ( dwSrcFileSize > dwTrgFileSize )
      {
         nCompResult = 1;
      }
   }

   return nCompResult;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFileDateTime - compares the file modification time of
// this file object with the time of the target file object
//----------------------------------------------------------------------------
int                                       // ret -(-1) if source < target
   TInstallFile::CompareFileDateTime(     //      ( 0) if source = target
                                          //      ( 1) if source > target
      TInstallFile * pFileTrg             // in  -target file object
   )
{
   int   nCompResult = 0;                 // comparison result

   __int64 cmp = *(__int64*)&m_FileData.ftLastWriteTime - 
                 *(__int64*)&pFileTrg->m_FileData.ftLastWriteTime;
   if ( cmp )
   {
      // The following lines do a "fuzzy" compare so that file systems that
      // store timestamps with different precision levels can be compared for
      // equivalence.  20,000,000 represents the number of 100ns intervals in
      // a FAT/HPFS twosec file timestamp.
      if ( cmp < 0 )
      {
         cmp = -cmp;
      }
      
      if ( cmp >= 20000000 )
      {
         // the timestamps differ by more than 2 seconds, so we need to
         // compare the filetime structures
        nCompResult = CompareFileTime( &m_FileData.ftLastWriteTime, 
                                       &pFileTrg->m_FileData.ftLastWriteTime );
      }
   }

   return nCompResult;
}

//---------------------------------------------------------------
// TInstallFile::CompareFileVersion - compares the version of this
// file object with the version of the target file object
//---------------------------------------------------------------
int                                    // ret -(-1) if source version < target version 
   TInstallFile::CompareFileVersion(   //      ( 0) if source version = target version
                                       //      ( 1) if source version > target version
      TInstallFile * pFileTrg          // in  -target file object
   )
{
   int         nCompResult = 0;        // comparison result
   DWORDLONG   dwlSrcVersion = 0;      // source version
   DWORDLONG   dwlTrgVersion = 0;      // target version

   dwlSrcVersion = ((DWORDLONG)m_FixedFileInfo.dwFileVersionMS << 32) |
                    (DWORDLONG)m_FixedFileInfo.dwFileVersionLS;

   dwlTrgVersion = ((DWORDLONG)pFileTrg->m_FixedFileInfo.dwFileVersionMS << 32) |
                    (DWORDLONG)pFileTrg->m_FixedFileInfo.dwFileVersionLS;

   if ( dwlTrgVersion )
   {
      if ( dwlSrcVersion < dwlTrgVersion )
      {
         nCompResult = -1;
      }
      else if ( dwlSrcVersion > dwlTrgVersion )
      {
         nCompResult = 1;
      }
   }
   else
   {
      nCompResult = 1;
   }

   return nCompResult;
}

//---------------------------------------------------------------
// TInstallFile::GetFileVersion - retrieves the version as separate
// components:  Major, Minor, Release, Modification
//---------------------------------------------------------------
void                                   
   TInstallFile::GetFileVersion(   
      UINT           * uVerMaj,              // out -major version
      UINT           * uVerMin,              // out -minor version
      UINT           * uVerRel,              // out -release version
      UINT           * uVerMod               // out -modification version
   )
{
   *uVerMaj = HIWORD(m_FixedFileInfo.dwFileVersionMS);
   *uVerMin = LOWORD(m_FixedFileInfo.dwFileVersionMS);
   *uVerRel = HIWORD(m_FixedFileInfo.dwFileVersionLS);
   *uVerMod = LOWORD(m_FixedFileInfo.dwFileVersionLS);
}

//---------------------------------------------------------------
// TInstallFile::GetFileVersionString - retrieves the FileVersion 
// string of the version resource
//---------------------------------------------------------------
TCHAR *                                      // ret -version string
   TInstallFile::GetFileVersionString()
{
   UINT     uBytes;                          // size of version info
   TCHAR  * szBuffer;                        // version info buffer

   if ( m_VersionInfo && m_szFileVersion[0] == 0 )
   {
      TCHAR  szStrFileInfo[MAX_PATH];
      _stprintf(szStrFileInfo,TEXT( "\\StringFileInfo\\%04X%04X\\FileVersion"), 
                            LOWORD(m_dwLanguageCode), HIWORD(m_dwLanguageCode) );

      if ( ! VerQueryValue( m_VersionInfo,
                            szStrFileInfo,
                            (void **) &szBuffer,
                            &uBytes) )
      {
         err.MsgWrite( 0,
                       DCT_MSG_VER_QUERY_VALUE_FAILED_SS,
                       m_szFilePath,
                       szStrFileInfo );
      }
      else
      {
         safecopy(m_szFileVersion,szBuffer);
      }
   }

   return m_szFileVersion;
}

//---------------------------------------------------------------
// TInstallFile::GetFileSizeString - retrieves the file size as a string
//---------------------------------------------------------------
TCHAR *                                      // ret -file size string
   TInstallFile::GetFileSizeString()
{
   _stprintf(m_szFileSize,TEXT("%ld"), m_FileData.nFileSizeLow );
   return m_szFileSize;
}

//---------------------------------------------------------------
// TInstallFile::GetFileDateTimeString - retrieves the file modification
// time as a string
//---------------------------------------------------------------
TCHAR *                                      // ret -file mod string             
   TInstallFile::GetFileDateTimeString(
      TCHAR const * szFormatString           // in  -date/time format string
   )
{
   //safecopy(m_szFileDateTime,ctime(m_FileData.ftLastWriteTime));
   return m_szFileDateTime;
}

//----------------------------------------------------------------------------
// TInstallFile::IsBusy - determines if the file is busy by trying to open it
// for reading and writing.
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if the file is busy
   TInstallFile::IsBusy()                    //     -FALSE otherwise
{
   BOOL     bIsBusy = FALSE;                 // is the file busy?
   HANDLE   hFile;                           // file handle
   DWORD    rc;                              // OS return code

   // try to open file for read and write
   hFile = CreateFile( m_szFilePath,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
   if ( hFile == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_ACCESS_DENIED || rc == ERROR_SHARING_VIOLATION )
      {
         err.MsgWrite( 0,
                       DCT_MSG_FILE_IN_USE_S,           
                       m_szFilePath );
         bIsBusy = TRUE;
      }
      else
      {
         if ( ! m_bSilent )
            err.SysMsgWrite( 0,
                          rc,
                          DCT_MSG_CREATE_FILE_FAILED_SD,
                          m_szFilePath,
                          rc );
      }
   }
   else
   {
      CloseHandle( hFile );
   }

   return bIsBusy;
}

//----------------------------------------------------------------------------
// TDllFile::TDllFile - constructor for DLL file objects.
//----------------------------------------------------------------------------
   TDllFile::TDllFile(
      TCHAR const * pszFileName,             // in  -file name (not a full path)
      TCHAR const * pszFileDir,              // in  -directory (without file name)
      TCHAR const * pszProgId,               // in  -Prog ID (for OCX's)
      BOOL          bSystemFile              // in  -TRUE if file is a system file
   ) : TInstallFile( pszFileName, pszFileDir )
{
   m_bSystemFile = bSystemFile;
   m_bRegistrationNeeded = FALSE;
   m_bRegisterTarget = FALSE;
   m_szProgId[0] = 0;
   m_szRegPath[0] = 0;

   if ( pszProgId )
   {
      safecopy(m_szProgId,pszProgId);
   }
}

//----------------------------------------------------------------------------
// TDllFile::SupportsSelfReg - determines whether the file supports self-registration
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if file supports self-reg
   TDllFile::SupportsSelfReg()               //     -FALSE otherwise
{
   BOOL        bSelfReg = FALSE;             // supports self-reg?
   UINT        uBytes;                       // size of version info
   TCHAR     * szBuffer;                     // version info buffer

   if ( m_VersionInfo )
   {
      TCHAR szStrFileInfo[MAX_PATH];
      _stprintf(szStrFileInfo,TEXT("\\StringFileInfo\\%04X%04X\\OLESelfRegister"), 
                            LOWORD(m_dwLanguageCode), HIWORD(m_dwLanguageCode) );

      if ( ! VerQueryValue( m_VersionInfo,
                            szStrFileInfo,
                            (void **) &szBuffer,
                            &uBytes) )
      {
         if ( *m_szProgId )
         {
            bSelfReg = TRUE;
         }
         else
         {
            err.MsgWrite( 0,
                          DCT_MSG_FILE_NO_SELF_REGISTRATION_S,
                          m_szFilePath );
         }
      }
      else
      {
         bSelfReg = TRUE;
      }
   }

   return bSelfReg;
}

//----------------------------------------------------------------------------
// TDllFile::IsRegistered - determines whether a file is registered
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if file is registered
   TDllFile::IsRegistered()                  //     -FALSE otherwise
{
   BOOL              bIsRegistered = FALSE;  // is the file registered?
   DWORD             rc;                     // OS return code
   HRESULT           hr;                     // OLE return code
   CLSID             clsid;                  // CLSID for registered class
   IClassFactory   * pICFGetClassObject;     // ClassFactory interface
   TCHAR             szBuffer[MAX_PATH];     // registry key buffer

   // initialize OLE
   CoInitialize( NULL );
   hr = CLSIDFromProgID( SysAllocString(m_szProgId), &clsid );
   if ( SUCCEEDED( hr ) )
   {
      hr = CoGetClassObject( clsid, 
                             CLSCTX_ALL, 
                             NULL, 
                             IID_IClassFactory, 
                             (void **)&pICFGetClassObject );
      if ( SUCCEEDED( hr ) )
      {
         bIsRegistered = TRUE;
         pICFGetClassObject->Release();
      }
   }
   CoUninitialize();

   if ( bIsRegistered )
   {
      WCHAR                  szKeyName[MAX_PATH];

      safecopy(szKeyName,m_szProgId);

      UStrCpy(szKeyName + UStrLen(szKeyName),"\\CLSID");
      
      TRegKey regKey;

      rc = regKey.OpenRead( szKeyName, HKEY_CLASSES_ROOT );
      if ( ! rc )
      {
         rc = regKey.ValueGetStr( _T(""), szBuffer, sizeof szBuffer );
         if ( ! rc )
         {
            regKey.Close();
            UStrCpy(szKeyName,"CLSID\\");
            UStrCpy(szKeyName + UStrLen(szKeyName),szBuffer);
            UStrCpy(szKeyName + UStrLen(szKeyName),"\\InProcServer32");
            
            rc = regKey.OpenRead( szKeyName, HKEY_CLASSES_ROOT );
            if ( ! rc )
            {
               rc = regKey.ValueGetStr( _T(""), szBuffer, sizeof szBuffer );
               if ( ! rc )
               {
                  regKey.Close();
                  safecopy(m_szRegPath,szBuffer);
                  bIsRegistered = TRUE;
               }
            }
         }
      }
   }

   return bIsRegistered;
}

//----------------------------------------------------------------------------
// TDllFile::CallDllFunction - call an exported function of a dll
//----------------------------------------------------------------------------
DWORD                                        // ret -TRUE if function call success
   TDllFile::CallDllFunction(                //      FALSE if function call failure
      TCHAR const * pszFunctionName,         // in  -Exported function name
      TCHAR const * pszDllName               // in  -name of dll file
   )
{
   DWORD       rc = 0;                       // OS return code
   HINSTANCE   hLib;                         // handle
   
   WCHAR                     szDllNameUsed[MAX_PATH];
   char                      pszFunctionNameA[MAX_PATH];

   safecopy(pszFunctionNameA,pszFunctionName);

   if ( pszDllName )
   {
      safecopy(szDllNameUsed,pszDllName);
   }
   else
   {
      safecopy(szDllNameUsed,m_szFilePath);
   }

   // load the dll into memory
   hLib = LoadLibrary( szDllNameUsed );
   if ( ! hLib )
   {
      rc = GetLastError();
      err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_LOAD_LIBRARY_FAILED_SD,
                       szDllNameUsed,
                       rc );
   }
   else
   {
      // Find the entry point.
      FARPROC lpDllEntryPoint = GetProcAddress( hLib, pszFunctionNameA );
      if ( lpDllEntryPoint == NULL )
      {
         rc = GetLastError();
         err.SysMsgWrite( 0,
                          rc,
                          DCT_MSG_GET_PROC_ADDRESS_FAILED_SSD,
                          szDllNameUsed,
                          pszFunctionName,
                          rc );
      }
      else
      {
         // call the dll function
         rc = (DWORD)(*lpDllEntryPoint)();
      }

      FreeLibrary( hLib );
   }

   return rc;
}

//----------------------------------------------------------------------------
// TDllFile::Register - registers the file
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TDllFile::Register()
{
   DWORD rc = 0;                             // OS return code
   TCHAR const szFunctionName[MAX_PATH] = _T("DllRegisterServer");

   if ( m_bRegisterTarget )
   {
      rc = CallDllFunction( szFunctionName, m_szTargetPath );
   }
   else
   {
      rc = CallDllFunction( szFunctionName );
   }

  
   if ( rc )
   {
      err.MsgWrite( 0,
                    DCT_MSG_DLL_CALL_FAILED_SDS,
                    szFunctionName,
                    rc,
                    "failed to register object classes" );
   }

   return rc;
}

//----------------------------------------------------------------------------
// TDllFile::Unregister - unregisters the file
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TDllFile::Unregister()
{
   DWORD rc = 0;                             // OS return code
   TCHAR const szFunctionName[MAX_PATH] = _T("DllUnregisterServer");

   if ( m_bRegisterTarget )
   {
      rc = CallDllFunction( szFunctionName, m_szTargetPath );
   }
   else
   {
      rc = CallDllFunction( szFunctionName );
   }

   if ( rc )
   {
      err.MsgWrite( 0,
                    DCT_MSG_DLL_CALL_FAILED_SDS,
                    szFunctionName,
                    rc,
                    "failed to unregister object classes" );
   }
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tfile.hpp ===
//#pragma title("TFile.hpp - Install File class")

/*---------------------------------------------------------------------------
  File: TFile.hpp

  Comments: This file contains file installation functions.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical SOftware, Inc.

  REVISION LOG ENTRY
  Author:  Juan Medrano
  Revision By: ...
  Revised on 7/9/97

  Revision By: Christy Boles
  Converted to UNICODE, removed dependency on CString
  
 ---------------------------------------------------------------------------*/

#ifndef MCSINC_TFile_hpp
#define MCSINC_TFile_hpp

class TInstallFile
{
protected:

   TCHAR                m_szFileName[MAX_PATH];        // file name (not a full path)
   TCHAR                m_szFilePath[MAX_PATH];        // full path (including file name)
   TCHAR                m_szTargetPath[MAX_PATH];      // target path (full path)
   TCHAR                m_szFileVersion[MAX_PATH];     // file version string from version resource
   TCHAR                m_szFileSize[MAX_PATH];        // file size
   TCHAR                m_szFileDateTime[MAX_PATH];    // modification date/time
   TCHAR              * m_VersionInfo;       // version info
   DWORD                m_dwLanguageCode;    // language code for version info strings
   VS_FIXEDFILEINFO     m_FixedFileInfo;     // file info structure from version resource
   WIN32_FIND_DATA      m_FileData;          // structure for FindFirstFile()
   BOOL                 m_bCopyNeeded;       // does this file need to be copied?
   BOOL                 m_bSilent;           

public:

   TInstallFile( TCHAR const * pszFileName = NULL,
                 TCHAR const * pszFileDir = NULL, 
                 BOOL silent = FALSE);
   ~TInstallFile() { delete [] m_VersionInfo; }

   DWORD    OpenFileInfo( TCHAR const * pszFileDir );
   TCHAR  * GetFileName() { return m_szFileName; }
   TCHAR  * GetFilePath() { return m_szFilePath; }
   TCHAR  * GetTargetPath() { return m_szTargetPath; }
   void     SetFileName( TCHAR const * pszFileName ) { safecopy(m_szFileName,pszFileName); }
   void     SetFilePath( TCHAR const * pszFilePath ) { safecopy(m_szFilePath,pszFilePath); }
   void     SetTargetPath( TCHAR const * pszTargetPath ) { safecopy(m_szTargetPath,pszTargetPath); }
   void     SetCopyNeeded( BOOL bCopyNeeded ) { m_bCopyNeeded = bCopyNeeded; }
   BOOL     IsCopyNeeded() { return m_bCopyNeeded; }
   DWORD    CopyTo( TCHAR const * pszDestinationPath );
   DWORD    CopyToTarget() { return CopyTo( m_szTargetPath ); }
   int      CompareFile( TInstallFile * pFileTrg );
   int      CompareFileSize( TInstallFile * pFileTrg );
   int      CompareFileDateTime( TInstallFile * pFileTrg );
   int      CompareFileVersion( TInstallFile * pFileTrg );
   void     GetFileVersion( UINT * uVerMaj, UINT * uVerMin, UINT * uVerRel, UINT * uVerMod );
   DWORD    GetFileSize() { return m_FileData.nFileSizeLow; }
   FILETIME GetFileDateTime() { return m_FileData.ftLastWriteTime; }
   TCHAR  * GetFileVersionString();
   TCHAR  * GetFileSizeString();
   TCHAR  * GetFileDateTimeString( TCHAR const * szFormatString = TEXT("%#c") );
   BOOL     IsBusy();
};

class TDllFile : public TInstallFile
{
protected:

   TCHAR       m_szProgId[MAX_PATH];                  // Prog ID (OCX's only)
   TCHAR       m_szRegPath[MAX_PATH];                 // full path where file is currently registered
   BOOL        m_bSystemFile;                         // should this file be located in system32?
   BOOL        m_bRegistrationNeeded;                 // do we need to register this file?
   BOOL        m_bRegisterTarget;                     // do we need to register this file on the target path?

public:

   TDllFile( TCHAR const * pszFileName = NULL,
             TCHAR const * pszFileDir = NULL,
             TCHAR const * pszProgId = NULL, 
             BOOL bSystemFile = FALSE ); 
   ~TDllFile() {};

   BOOL     SupportsSelfReg();
   BOOL     IsRegistered();
   BOOL     IsRegistrationNeeded() { return m_bRegistrationNeeded; }
   BOOL     DoRegisterTarget() { return m_bRegisterTarget; }
   BOOL     IsSystemFile() { return m_bSystemFile; }
   DWORD    CallDllFunction( TCHAR const * pszFunctionName, TCHAR const * pszDllName = NULL );
   DWORD    Register();
   DWORD    Unregister();
   TCHAR  * GetProgId() { return m_szProgId; }
   TCHAR  * GetRegPath() { return m_szRegPath; }
   void     SetRegistrationNeeded( BOOL bRegistrationNeeded ) { m_bRegistrationNeeded = bRegistrationNeeded; }
   void     SetRegisterTarget( BOOL bRegisterTarget ) { m_bRegisterTarget = bRegisterTarget; }
   void     SetProgId( TCHAR const * pszProgId ) { safecopy(m_szProgId,pszProgId); }
};

#endif // MCSINC_TFile_hpp

// TFile.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tinst.h ===
#ifndef __TDCTINSTALL_H__
#define __TDCTINSTALL_H__
/*---------------------------------------------------------------------------
  File: TDCTInstall.h

  Comments: Utility class to install a service.
  Current implementation is specific to the DCT service.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:32:21

 ---------------------------------------------------------------------------
*/

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"


class TDCTInstall
{
   BOOL                      m_bDebugLogging;
   WCHAR                     m_sComputer[LEN_Computer];
   WCHAR                     m_sComputerSource[LEN_Computer];
   
   // Service-specific information
   WCHAR                     m_sDisplayName[200];
   WCHAR                     m_sServiceName[200];
   WCHAR                     m_sServiceAccount[LEN_Account];
   WCHAR                     m_sServiceAccountPassword[LEN_Password];
   WCHAR                     m_sDependencies[500];

   SC_HANDLE                 m_hScm;         // SCM handle
   WCHAR                     m_sDirThis[32];
   WCHAR                     m_sExeName[200];
   DWORD                     m_StartType;
   
public:

   TDCTInstall(
      WCHAR          const * asComputer,    // in -target computer name
      WCHAR          const * srcComputer    // in -source computer name
      
   )
   {
      m_bDebugLogging = FALSE;
      safecopy( m_sComputer, asComputer );
      safecopy( m_sComputerSource, srcComputer );
      m_sDisplayName[0] = L'\0';
      m_sServiceName[0] = L'\0';
      m_sServiceAccount[0] = L'\0';
      m_sServiceAccountPassword[0] = L'\0';
      m_sDependencies[0] = L'\0';

      m_hScm = NULL;
      m_sDirThis[0] = L'\0';
      m_sExeName[0] = L'\0';
      m_StartType = SERVICE_DEMAND_START;

   }
   ~TDCTInstall()
   {
      ScmClose();
   }
   
   BOOL        DebugLogging() { return m_bDebugLogging; }
   void        DebugLogging(BOOL val) { m_bDebugLogging = val; }
   
   void        SetServiceInformation(WCHAR const * displayName, 
                                     WCHAR const * serviceName, 
                                     WCHAR const * exeName,
                                     WCHAR const * dependencies,
                                     DWORD         startType = SERVICE_DEMAND_START )
   {
      MCSASSERT(displayName && *displayName);
      MCSASSERT(serviceName && *serviceName);
      MCSASSERT(exeName && *exeName);

      safecopy(m_sDisplayName, displayName);
      safecopy(m_sServiceName, serviceName);
      safecopy(m_sExeName,exeName);
      safecopy(m_sDependencies, dependencies ? dependencies : L"");
      m_StartType = startType;
   }


   void        SetServiceAccount(WCHAR const * account, WCHAR const * password)
   {
      safecopy(m_sServiceAccount, account ? account : L"" );
      safecopy(m_sServiceAccountPassword, password ? password : L"" );
   }

   void        SourceDir(WCHAR const * dir) { safecopy(m_sDirThis,dir); }
   DWORD       ScmOpen(BOOL bSilent = FALSE);
   void        ScmClose();
   DWORD       ServiceStart();
   void        ServiceStop();

};



#endif //__TDCTINSTALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tpool.h ===
#ifndef __TPOOLEDDISPATCH_H__
#define __TPOOLEDDISPATCH_H__
/*---------------------------------------------------------------------------
  File: TPooledDispatch.h

  Comments: TJobDispatcher implements a thread pool to execute jobs.  Jobs are
  executed on a FIFO basis.  This dispatcher does not provide any support for 
  job scheduling, only multithreaded dispatch of jobs.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 16:35:54

 ---------------------------------------------------------------------------
*/


#include "Common.hpp"
#include "TNode.hpp"
#include "TSync.hpp"


class Job : public TNode
{
public:
   enum JobStatus { JobStatusUninitialized, JobStatusWaiting, JobStatusRunning, JobStatusFinished };
private:
   LPTHREAD_START_ROUTINE    m_pStartRoutine;
   LPVOID                    m_pArgs;
   JobStatus                 m_Status;
   DWORD                     m_ThreadID;
   time_t                    m_timeStarted;
   time_t                    m_timeEnded;
   int                       m_result;
public:
   
   Job() 
   {
      m_pStartRoutine = NULL;
      m_pArgs = NULL;
      m_Status = JobStatusUninitialized;
      m_ThreadID = 0;
      m_timeStarted = 0;
      m_timeEnded = 0;
      m_result = 0;
   }
   ~Job() {};
   void SetEntryPoint(LPTHREAD_START_ROUTINE pStart, LPVOID pArg)
   {
      MCSASSERT(m_Status == JobStatusUninitialized || m_Status == JobStatusFinished );
      MCSASSERT(pStart);
      
      m_pStartRoutine = pStart;
      m_pArgs = pArg;
      m_Status = JobStatusWaiting;
   }

   int Run();
   
//   int GetElapsedTime() { return m_timeEnded - m_timeStarted; }
   time_t GetElapsedTime() { return m_timeEnded - m_timeStarted; }
   int GetResult() { return m_result; }
   JobStatus GetStatus() { return m_Status; }
};


class JobList : public TNodeList
{
   TCriticalSection          m_cs;

public:
   ~JobList() { DeleteAllListItems(Job); }
   Job *  AddJob(LPTHREAD_START_ROUTINE pfnStart, void * arg) { Job * pJob = new Job; pJob->SetEntryPoint(pfnStart,arg);
                                                               m_cs.Enter(); InsertBottom(pJob); m_cs.Leave(); return pJob; }
   void   RemoveJob(Job * pJob) { m_cs.Enter(); Remove(pJob); m_cs.Leave(); }
   Job *  GetFirstJob() { m_cs.Enter(); Job * pJob = (Job *)Head(); if ( pJob ) Remove(pJob); m_cs.Leave(); return pJob; }
};


class TJobDispatcher 
{
   DWORD                     m_numThreads;
   JobList                   m_JobsWaiting;
   JobList                   m_JobsInProgress;
   TSemaphoreNamed           m_sem;
   TCriticalSection          m_cs;
   DWORD                     m_numActiveThreads;
   BOOL                      m_Aborting;
public:
   TJobDispatcher(DWORD maxThreads = 10) { InitThreadPool(maxThreads); m_Aborting = FALSE;}
   ~TJobDispatcher() { WaitForCompletion(); ShutdownThreads(); }
   
   // These are called by the client
   Job * SubmitJob(LPTHREAD_START_ROUTINE pStart,LPVOID pArg)
   {
//      Job * pJob = m_JobsWaiting.AddJob(pStart,pArg);
      m_JobsWaiting.AddJob(pStart,pArg);
      m_sem.Release(1);     
      return 0;
   }

   void    WaitForCompletion();
   int     UnfinishedJobs();

   // These functions are called by the threads - clients should not call these functions!
   DWORD   SignalForJob();
   Job   * GetAvailableJob();
   void    ThreadFinished() { m_cs.Enter(); m_numActiveThreads--; m_cs.Leave(); }
protected:
   void  InitThreadPool(DWORD nThreads);
   void  ShutdownThreads();
};



#endif //__TPOOLEDDISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help-ms\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_DOMAIN_SELECTION_GROUP=WindowDomainSelectGroup.htm
IDH_WINDOW_DOMAIN_SELECTION_GROUPMAP=WindowDomainSelectGroupMap.htm
IDH_WINDOW_DOMAIN_SELECTION_REPORT=WindowDomainSelectReport.htm
IDH_WINDOW_DOMAIN_SELECTION_SECURITY=WindowDomainSelectSecurity.htm
IDH_WINDOW_DOMAIN_SELECTION_SERVICE=WindowDomainSelectService.htm
IDH_WINDOW_DOMAIN_SELECTION_TRUST=WindowDomainSelectTrust.htm
IDH_WINDOW_DOMAIN_SELECTION_USER=WindowDomainSelectUser.htm
IDH_WINDOW_DOMAIN_SELECTION_EXCHANGE=WindowDomainSelectExchange.htm

IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_GROUP_SELECTION_GROUPMAP=WindowGroupSelectGroupMap.htm


IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_COMPUTER_SELECTION_REPORT=WindowComputerSelectReport.htm
IDH_WINDOW_COMPUTER_SELECTION_SECURITY=WindowComputerSelectSecurity.htm

IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OU_SELECTION_GROUP=WindowOUSelectGroup.htm
IDH_WINDOW_OU_SELECTION_GROUPMAP=WindowOUSelectGroupMap.htm
IDH_WINDOW_OU_SELECTION_USER=WindowOUSelectUser.htm

IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION_SECURITY=WindowObjectTypeSelectSecurity.htm


IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_OPTION_GROUPMAP=WindowGroupOptionGroupMap.htm

IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_SECURITY_OPTION_SECURITY=WindowSecurityOptionSecurity.htm
IDH_WINDOW_SECURITY_OPTION_EXCHANGE=WindowSecurityOptionExchange.htm

IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_NAME_CONFLICT_GROUP=WindowNameConflictGroup.htm
IDH_WINDOW_NAME_CONFLICT_USER=WindowNameConflictUser.htm


IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_USER=WindowSIDHistoryCredentialUser.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_GROUPMAP=WindowSIDHistoryCredentialGroupMap.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS_UNDO=WindowSIDHistoryCredentialUndo.htm

IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_CONFIRMATION_GROUP=WindowConfirmationGroup.htm
IDH_WINDOW_CONFIRMATION_GROUPMAP=WindowConfirmationGroupMap.htm
IDH_WINDOW_CONFIRMATION_REPORT=WindowConfirmationReport.htm
IDH_WINDOW_CONFIRMATION_RETRY=WindowConfirmationRetry.htm
IDH_WINDOW_CONFIRMATION_SECURITY=WindowConfirmationSecurity.htm
IDH_WINDOW_CONFIRMATION_SERVICE=WindowConfirmationService.htm
IDH_WINDOW_CONFIRMATION_UNDO=WindowConfirmationUndo.htm
IDH_WINDOW_CONFIRMATION_USER=WindowConfirmationUser.htm
IDH_WINDOW_CONFIRMATION_EXCHANGE=WindowConfirmationExchange.htm


IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_COMMIT_EXCHANGE=WindowCommitChangesExchange.htm
IDH_WINDOW_COMMIT_GROUP=WindowCommitChangesGroup.htm
IDH_WINDOW_COMMIT_GROUPMAP=WindowCommitChangesGroupMap.htm
IDH_WINDOW_COMMIT_SECURITY=WindowCommitChangesSecurity.htm
IDH_WINDOW_COMMIT_USER=WindowCommitChangesUser.htm

IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_USER_SERVICE_ACCOUNT_GROUP=WindowUserServiceAccountGroup.htm
IDH_WINDOW_USER_SERVICE_ACCOUNT_INFO=WindowUserServiceAccountInfo.htm


IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm

IDH_WINDOW_GROUP_MEM_TRANS_OPTION=WindowGroupMemTransOption.htm
IDH_WINDOW_REPORT_COMP_SELECT=WindowReportCompSelect.htm
IDH_WINDOW_REPORT_WIZ=WindowReportWiz.htm
IDH_WINDOW_SERV_ACC_WIZ=WindowServAccWiz.htm
IDH_WINDOW_COMP_WIZ=WindowCompWiz.htm
IDH_WINDOW_UNDO_WIZ=WindowUndoWiz.htm
IDH_WINDOW_TRUST_WIZ=WindowTrustWiz.htm
IDH_WINDOW_EXCHANGE_WIZ=WindowExchangeWiz.htm
IDH_WINDOW_GROUP_MAP_MERGE_WIZ=WindowGroupMapMergeWiz.htm
IDH_WINDOW_GROUP_WIZ=WindowGroupWiz.htm
IDH_WINDOW_RETRY_WIZ=WindowRetryWiz.htm
IDH_WINDOW_SEC_TRANS_WIZ=WindowSecTransWiz.htm
IDH_WINDOW_USER_WIZ=WindowUserWiz.htm

IDH_WINDOW_TRANSLATION_OPTION=WindowTranslationOption.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION=WindowObjectPropertyExclusion.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_GROUP=WindowObjectPropertyExclusionGroup.htm
IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_USER=WindowObjectPropertyExclusionUser.htm
IDH_WINDOW_USER_ACC_PASS=WindowUserAccPass.htm
IDH_WINDOW_CONFIRMATION_TRUST=WindowConfirmationTrust.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help-ms\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300

#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
#define IDH_WINDOW_TRANSLATION_OPTION             5060
#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION      5070
#define IDH_WINDOW_USER_SERVICE_ACCOUNT_GROUP     5080
#define IDH_WINDOW_USER_SERVICE_ACCOUNT_INFO      5090

#define IDH_WINDOW_GROUP_MEM_TRANS_OPTION         6000
#define IDH_WINDOW_REPORT_COMP_SELECT			  6010
#define IDH_WINDOW_REPORT_WIZ					  6020
#define IDH_WINDOW_SERV_ACC_WIZ					  6030
#define IDH_WINDOW_COMP_WIZ						  6040
#define IDH_WINDOW_UNDO_WIZ						  6050
#define IDH_WINDOW_TRUST_WIZ					  6060
#define IDH_WINDOW_EXCHANGE_WIZ					  6070
#define IDH_WINDOW_GROUP_MAP_MERGE_WIZ			  6080
#define IDH_WINDOW_GROUP_WIZ					  6090
#define IDH_WINDOW_RETRY_WIZ					  6100
#define IDH_WINDOW_SEC_TRANS_WIZ				  6110
#define IDH_WINDOW_USER_WIZ						  6120

#define IDH_WINDOW_COMMIT_EXCHANGE                7000
#define IDH_WINDOW_COMMIT_GROUP                   7010
#define IDH_WINDOW_COMMIT_GROUPMAP                7020
#define IDH_WINDOW_COMMIT_SECURITY                7030
#define IDH_WINDOW_COMMIT_USER					  7040
#define IDH_WINDOW_DOMAIN_SELECTION_GROUP         7050
#define IDH_WINDOW_DOMAIN_SELECTION_GROUPMAP      7060
#define IDH_WINDOW_DOMAIN_SELECTION_REPORT        7070
#define IDH_WINDOW_DOMAIN_SELECTION_SECURITY      7080
#define IDH_WINDOW_DOMAIN_SELECTION_SERVICE       7090
#define IDH_WINDOW_DOMAIN_SELECTION_TRUST         7100
#define IDH_WINDOW_DOMAIN_SELECTION_USER          7110
#define IDH_WINDOW_DOMAIN_SELECTION_EXCHANGE      7120

#define IDH_WINDOW_COMPUTER_SELECTION_REPORT      7130
#define IDH_WINDOW_COMPUTER_SELECTION_SECURITY    7140
#define IDH_WINDOW_OU_SELECTION_GROUP		      7150
#define IDH_WINDOW_OU_SELECTION_GROUPMAP          7160
#define IDH_WINDOW_OU_SELECTION_USER              7170

#define IDH_WINDOW_OBJECTTYPE_SELECTION_SECURITY  7180

#define IDH_WINDOW_SECURITY_OPTION_SECURITY       7190
#define IDH_WINDOW_SECURITY_OPTION_EXCHANGE       7200

#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_GROUP   7210
#define IDH_WINDOW_OBJECT_PROPERTY_EXCLUSION_USER    7220

#define IDH_WINDOW_NAME_CONFLICT_GROUP             7230
#define IDH_WINDOW_NAME_CONFLICT_USER              7240

#define IDH_WINDOW_CONFIRMATION_GROUP              7250
#define IDH_WINDOW_CONFIRMATION_GROUPMAP           7260
#define IDH_WINDOW_CONFIRMATION_REPORT             7270
#define IDH_WINDOW_CONFIRMATION_RETRY              7280
#define IDH_WINDOW_CONFIRMATION_SECURITY           7290
#define IDH_WINDOW_CONFIRMATION_SERVICE            7300
#define IDH_WINDOW_CONFIRMATION_UNDO               7310
#define IDH_WINDOW_CONFIRMATION_USER               7320
#define IDH_WINDOW_CONFIRMATION_EXCHANGE           7330

#define IDH_WINDOW_GROUP_OPTION_GROUPMAP           7340
#define IDH_WINDOW_GROUP_SELECTION_GROUPMAP        7350

#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_USER     7360
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_UNDO     7370
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS_GROUPMAP 7380
#define IDH_WINDOW_USER_ACC_PASS		   7390
#define IDH_WINDOW_CONFIRMATION_TRUST      	   7400
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_START_DM=TasksStartDM.htm
IDH_HOWTO_MIGRATE_TRUSTS=TasksManageTrusts.htm
IDH_HOWTO_MERGE_GROUPS=TasksMergeGroups.htm
IDH_HOWTO_MIGRATE_USERS=TasksMigrateAccounts.htm
IDH_HOWTO_MIGRATE_GROUPS=TasksMigrateGroups.htm
IDH_HOWTO_MIGRATE_COMPUTERS=TasksMigrateComputers.htm
IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS=TasksMigrateServAccts.htm
IDH_HOWTO_RESOLVE_SECURITY=TasksTranslateSecurity.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_REQUIREMENT=ConceptDomMigRequirements.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_ACCOUNT_MIGRATION=ConceptAccountMigration.htm
IDH_CONCEPT_COMPUTER_MIGRATION=ConceptComputerMigration.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm
IDH_CONCEPT_EXCHANGE_TRANSLATION=ConceptExchangeTranslationIssues.htm
IDH_CONCEPT_TRUST_MIGRATION=ConceptTrustMigration.htm
IDH_CONCEPT_UNDERSTAND_UI=ConceptUnderstandingIntro.htm
IDH_CONCEPT_UI_CONSOLE_WINDOW=ConceptUnderstandingConsole.htm
IDH_CONCEPT_UI_MENUS=ConceptUnderstandingMenus.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_EXCHANGE_OPTION=WindowExchangeOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_SECURITY_CREDENTIALS=WindowSecurityCredential.htm
IDH_WINDOW_REPORT_CREDENTIALS=WindowReportCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300
#define IDH_WINDOW_SECURITY_CREDENTIALS           4310
#define IDH_WINDOW_REPORT_CREDENTIALS             4320
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\disp\tpool.cpp ===
/*---------------------------------------------------------------------------
  File: TPooledDispatch.cpp

  Comments: Implementation of thread pool.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/22/99 11:48:28

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "StdAfx.h"
#else 
   #include <windows.h>
#endif
#include "Common.hpp"
#include "UString.hpp"
#include "Tnode.hpp"

#include "TPool.h"

// maximum number of jobs allowed
#define  MAX_COUNT   5000000

// executes a job from the thread pool
int 
   Job::Run()
{
   MCSASSERT(m_pStartRoutine);
   
   m_Status = JobStatusRunning;
   m_ThreadID = GetCurrentThreadId();
   m_timeStarted = GetTickCount();
   m_result = (m_pStartRoutine)(m_pArgs);
   m_timeEnded = GetTickCount();
   
   m_Status = JobStatusFinished;

   return m_result;
}

// Thread entry point function used by all threads in the job pool
// waits for a job and then executes it
DWORD __stdcall 
   ThreadEntryPoint(
      void                 * arg           // in - pointer to job pool
   )
{
   MCSASSERT(arg);

   TJobDispatcher          * pPool = (TJobDispatcher *)arg;
   DWORD                     result = 0;
   BOOL                      bAbort = FALSE;

   do 
   {
      if (  ! pPool->SignalForJob() )
      {

         // Now there should be a job waiting for us!
         Job                     * pJob = pPool->GetAvailableJob();

         if ( pJob )
         {
            result = pJob->Run();
         }
         else
         {
            bAbort = TRUE;
         }
      }
      else
      {
         result = (int)GetLastError();
         bAbort = TRUE;
      }
   }
   while ( ! bAbort );
   pPool->ThreadFinished();
   return result;
}

void 
   TJobDispatcher::InitThreadPool(
      DWORD                  nThreads     // in - number of threads to use
   )
{
   BOOL                      bExisted;
   DWORD                     rc;
   DWORD                     ThreadID;
   HANDLE                    hThread;

   rc = m_sem.Create(NULL,0,MAX_COUNT, &bExisted);
   if ( ! rc && ! bExisted )
   {
      m_numThreads = nThreads;
      m_numActiveThreads = m_numThreads;
      // Construct the threads
      for ( UINT i = 0 ; i < nThreads ; i++ )
      {
         hThread = CreateThread(NULL,0,&ThreadEntryPoint,this,0,&ThreadID);
         if(hThread)
         {
            CloseHandle(hThread);
         }
      }
   }
}

DWORD                                      // ret- OS return code
   TJobDispatcher::SignalForJob()
{
   return m_sem.WaitSingle();
}

Job * 
   TJobDispatcher::GetAvailableJob()
{
   Job                     * pJob = NULL;

   if ( ! m_Aborting ) 
   { 
      // get the first job from the 'waiting' list
      pJob = m_JobsWaiting.GetFirstJob(); 
      // and put it in the 'in progress' list
      if ( pJob )
      {
         m_JobsInProgress.InsertBottom(pJob);
      }
      else
      {
         MCSASSERT(m_JobsWaiting.Count() == 0);
      }
   }
   return pJob;
}

// Causes threads to stop when they finish their current job
// any jobs that are waiting will not be executed.
void 
   TJobDispatcher::ShutdownThreads()
{
   m_Aborting = TRUE;
   
   m_sem.Release(m_numThreads);
   // wait until all of our threads have exited, so we don't delete the thread pool out from under them.
   while ( m_numActiveThreads > 0 )
   {
      Sleep(100);
   }
}


// This function returns when all jobs are completed
void TJobDispatcher::WaitForCompletion()
{
   while ( UnfinishedJobs() )
   {
      Sleep(1000);
   }
}

// This functions returns the number of jobs that have not yet completed
int 
   TJobDispatcher::UnfinishedJobs()
{
   int                       nUnfinished = 0;
   TNodeListEnum             e;
   Job                     * j;
   
   nUnfinished += m_JobsWaiting.Count();

   
   for ( j = (Job*)e.OpenFirst(&m_JobsInProgress) ; j ; j = (Job*)e.Next() )
   {
      if ( j->GetStatus() != Job::JobStatusFinished )
         nUnfinished++;
   }
   return nUnfinished;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\dommigsi.cpp ===
// DomMigSI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DomMigSIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <locale.h>

#include "DomMigSI.h"

#include "DomMigSI_i.c"
#include "DomMigr.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DomMigrator, CDomMigrator)
OBJECT_ENTRY(CLSID_DomMigratorAbout, CDomMigratorAbout)
END_OBJECT_MAP()

class CDomMigSIApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomMigSIApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CDomMigSIApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDomMigSIApp, CWinApp)
	//{{AFX_MSG_MAP(CDomMigSIApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDomMigSIApp theApp;

BOOL CDomMigSIApp::InitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CDomMigSIApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _wsetlocale( LC_ALL, L".ACP" );
    _Module.Init(ObjectMap, m_hInstance, &LIBID_DOMMIGSILib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CDomMigSIApp::ExitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CDomMigSIApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\dommigr.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "MultiSel.h"
#include <windows.h>
#include "TReg.hpp"
#include "ResStr.h"

HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString                   strPath, strName;
   TRegKey                   key;
   TCHAR                     szModule[2*_MAX_PATH];
   DWORD                     dwReturn = 0;
   LPOLESTR					 lpHelpFile;

	  //mmc requires we use CoTaskMemAlloc to allocate memory returned from 
      //this function
   lpHelpFile = (LPOLESTR) CoTaskMemAlloc( 2 * MAX_PATH * sizeof(WCHAR) );
   if ( !lpHelpFile )
   {
       return E_OUTOFMEMORY;
   }

   dwReturn = key.Open(GET_STRING(IDS_DOMAIN_ADMIN_REGKEY),HKEY_LOCAL_MACHINE);
   if ( ! dwReturn )
   {
      dwReturn = key.ValueGetStr(L"Directory",szModule,DIM(szModule));
      if (! dwReturn )
      {
         strPath = szModule;
         strPath += L"\\";
         strName.LoadString(IDS_HELPFILE);
         strPath += strName;
      }
   }
   wcscpy(lpHelpFile, strPath);
   *bstrHelp = lpHelpFile;

   return HRESULT_FROM_WIN32(dwReturn);
}

/////////////////////////////////////////////////////////////////////////////
// CDomMigratorComponentData
static const GUID CDomMigratorGUID_NODETYPE = 
{ 0xe1975d72, 0x3f8e, 0x11d3, { 0x99, 0xee, 0x0, 0xc0, 0x4f, 0x39, 0xbd, 0x92 } };

HRESULT CDomMigrator::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CDomMigrator, CDomMigratorComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_32));
	if (hBitmap32 == NULL)
	{
	    DeleteObject(hBitmap16);
		return S_OK;
	}

//	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
//		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, 
		(LONG_PTR*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
	    DeleteObject(hBitmap16);
	    DeleteObject(hBitmap32);
		return E_UNEXPECTED;
	}
	DeleteObject(hBitmap16);
	DeleteObject(hBitmap32);

	// setting root node handle to main window
	// so that the root node may disable the main
	// window when a wizard is active

	HWND hwndMainWindow = 0;
	m_spConsole->GetMainWindow(&hwndMainWindow);

	if (m_pNode)
	{
		((CRootNode*)m_pNode)->SetMainWindow(hwndMainWindow);
	}

	return S_OK;
}


STDMETHODIMP 
   CDomMigratorComponent::AddMenuItems(
      LPDATAOBJECT           pDataObject,
      LPCONTEXTMENUCALLBACK  piCallback,
      long                 * pInsertionAllowed
   )
{
   ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   
   if (pDataObject == NULL)
   {
      ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
   }
   else
   {
      CSnapInItem          * pItem;
      DATA_OBJECT_TYPES      type;

      hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
      {
         hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->AddMenuItems(piCallback, pInsertionAllowed, type);
            }
         }
      }
   }
   return hr;
}


STDMETHODIMP CDomMigratorComponent::Command(long lCommandID,
  LPDATAOBJECT pDataObject)
{
	ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		CSnapInItem          * pItem;
		DATA_OBJECT_TYPES      type;

		hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
      {
         hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            HRESULT hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
            }
         }
      }

	}
	return hr;
}

CDomMigrator::CDomMigrator()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   m_pNode = new CRootNode;
	_ASSERTE(m_pNode != NULL);
	m_pComponentData = this;
   m_lpszSnapinHelpFile.LoadString(IDS_HELPFILE);
}

CDomMigrator::~CDomMigrator()
{
	if (m_pNode)
	   delete m_pNode;
	m_pNode = NULL;
}

   /*
   On the Help menu, there should be 1 Help Topics option that displays a Contents list with both our Help and the MMC Help.
*/
STDMETHODIMP CDomMigrator::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  if (m_lpszSnapinHelpFile.IsEmpty() )
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

  return GetHelpFileFullPath(lpCompiledHelpFile);
}

STDMETHODIMP CDomMigrator::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
   if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  return GetHelpFileFullPath(lpCompiledHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\domsel.cpp ===
// DomSel.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DomSel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg dialog


CDomainSelDlg::CDomainSelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDomainSelDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDomainSelDlg)
	m_Domain = _T("");
	//}}AFX_DATA_INIT
}


void CDomainSelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDomainSelDlg)
	DDX_Text(pDX, IDC_DOMAIN, m_Domain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDomainSelDlg, CDialog)
	//{{AFX_MSG_MAP(CDomainSelDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg message handlers

void CDomainSelDlg::OnOK() 
{
	
   UpdateData(TRUE);

	CDialog::OnOK();
}

void CDomainSelDlg::OnCancel() 
{
	UpdateData(TRUE);

	CDialog::OnCancel();
}

BOOL CDomainSelDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\dommigr.h ===
#ifndef __DOMMIGRATOR_H_
#define __DOMMIGRATOR_H_
#include "resource.h"
#include <atlsnap.h>
#include "MyNodes.h"
#include <ntverp.h>

class CDomMigrator;

class CDomMigratorComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CDomMigrator >,
	public IExtendContextMenuImpl<CDomMigratorComponent>,
   public IExtendControlbarImpl<CDomMigratorComponent>,
	public IComponentImpl<CDomMigratorComponent>
{
public:
BEGIN_COM_MAP(CDomMigratorComponent)
	COM_INTERFACE_ENTRY(IComponent)
   COM_INTERFACE_ENTRY(IExtendContextMenu)
   COM_INTERFACE_ENTRY(IExtendControlbar)
END_COM_MAP()

public:
	CDomMigratorComponent()
	{
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
	{
		if (lpDataObject != NULL)
			return IComponentImpl<CDomMigratorComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}


   // IExtendContextMenu methods
   STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
      LPCONTEXTMENUCALLBACK piCallback,
      long *pInsertionAllowed);
   STDMETHOD(Command)(long lCommandID,
      LPDATAOBJECT pDataObject);

};

class CDomMigrator : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<1, CDomMigrator>,
	public IComponentDataImpl<CDomMigrator, CDomMigratorComponent>,
   public IExtendContextMenuImpl<CDomMigrator>,
   public IPersistStreamInit,
   public ISnapinHelp2,
	public CComCoClass<CDomMigrator, &CLSID_DomMigrator>
{

   CString m_lpszSnapinHelpFile;
public:
	CDomMigrator();
	~CDomMigrator();
	
BEGIN_COM_MAP(CDomMigrator)
	 COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
 	COM_INTERFACE_ENTRY(IPersistStreamInit)
   COM_INTERFACE_ENTRY(ISnapinHelp)
   COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_DOMMIGRATOR)
static HRESULT WINAPI UpdateRegistry( BOOL bUpdateRegistry )
{
   WCHAR szBuf[MAX_PATH] = L"";
		
   ::LoadString(_Module.GetResourceInstance(), IDS_Title, szBuf, MAX_PATH);
   _ATL_REGMAP_ENTRY         regMap[] = 
   {
      { OLESTR("TOOLNAME"),  SysAllocString(szBuf) },
      { 0, 0 }
   };
   return _Module.UpdateRegistryFromResourceD( IDR_DOMMIGRATOR, bUpdateRegistry, regMap );
}


DECLARE_NOT_AGGREGATABLE(CDomMigrator)

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
      return S_OK;
      ATLTRACENOTIMPL(_T("CDomMigrator::GetClassID"));
   }

	STDMETHOD(IsDirty)()
	{
      return S_FALSE;
   	ATLTRACENOTIMPL(_T("CDomMigrator::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::GetSizeMax"));
	}

	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CDomMigrator::InitNew\n"));
		return S_OK;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

      // ISnapinHelp2 methods
   STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);
   STDMETHOD(GetLinkedTopics)(LPOLESTR *lpCompiledHelpFiles);

};

class ATL_NO_VTABLE CDomMigratorAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CDomMigratorAbout, &CLSID_DomMigratorAbout>
{
public:
	DECLARE_REGISTRY(CDomMigratorAbout, _T("DomMigratorAbout.1"), _T("DomMigratorAbout.1"), IDS_DOMMIGRATOR_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CDomMigratorAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[MAX_PATH];

		if ( lpDescription == NULL )
			return E_POINTER;

		if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_DESC, szBuf, MAX_PATH) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[MAX_PATH];

		if ( lpName == NULL )
			return E_POINTER;

		if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_PROVIDER, szBuf, MAX_PATH) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        USES_CONVERSION;
        TCHAR szFormat[MAX_PATH];
        TCHAR szVersion[MAX_PATH];

        if ( lpVersion == NULL )
            return E_POINTER;

        if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_VERSION, szFormat, MAX_PATH) == 0)
            return E_FAIL;

        szVersion[MAX_PATH - 1] = _T('\0');

        int cch = _sntprintf(szVersion, MAX_PATH, szFormat, LVER_PRODUCTVERSION_STR);

        if ((cch < 0) || (szVersion[MAX_PATH - 1] != _T('\0')))
        {
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        szVersion[MAX_PATH - 1] = _T('\0');

        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szVersion) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szVersion));

        return S_OK;
    }

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		if ( hAppIcon == NULL )
			return E_POINTER;

		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		if (( hSmallImage == NULL ) || ( hSmallImageOpen == NULL ) || ( hLargeImage == NULL ))
			return E_POINTER;

		*hSmallImageOpen = *hSmallImage = *hLargeImage = 0;
		return S_OK;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\domsel.h ===
#if !defined(AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_)
#define AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DomSel.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg dialog

class CDomainSelDlg : public CDialog
{
// Construction
public:
	CDomainSelDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDomainSelDlg)
	enum { IDD = IDD_DOMAIN };
	CString	m_Domain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainSelDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDomainSelDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\globals.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "globals.h"

HRESULT 
   InsertNodeToScopepane( 
      IConsoleNameSpace    * pConsoleNameSpace, 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID 
   )
{
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   pDataItem;

   hr = pNewNode->GetScopeData(&pDataItem);
   if (FAILED(hr))
      return hr;

   if ( pDataItem->ID )
      return hr;

   if ( nextSiblingID )
   {
      pDataItem->relativeID = nextSiblingID;
      pDataItem->mask |= SDI_NEXT;
   }
   else
   {
      pDataItem->relativeID = parentID;
      pDataItem->mask &= ~SDI_NEXT;
      pDataItem->mask |= SDI_PARENT;
   }

   hr = pConsoleNameSpace->InsertItem(pDataItem);
   if (FAILED(hr))
      return hr;

   return hr;

}

HRESULT 
   InsertNodeToScopepane2( 
      IConsole             * pConsole     , 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID
   )
{
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   pDataItem;
   CComQIPtr<IConsoleNameSpace>  pNewSpace(pConsole);

   hr = pNewNode->GetScopeData(&pDataItem);
   if (FAILED(hr))
      return hr;

   if ( pDataItem->ID )
      return hr;

   if ( nextSiblingID )
   {
      pDataItem->relativeID = nextSiblingID;
      pDataItem->mask |= SDI_NEXT;
   }
   else
   {
      pDataItem->relativeID = parentID;
      pDataItem->mask &= ~SDI_NEXT;
      pDataItem->mask |= SDI_PARENT;
   }

   hr = pNewSpace->InsertItem(pDataItem);
   if (FAILED(hr))
      return hr;

   return hr;

}

HRESULT 
   GetSnapInItemGuid( 
      CSnapInItem          * pItem        , 
      GUID                 * pOutGuid
   )
{
   HRESULT  hr = S_OK;
   CComPtr<IDataObject> pDataObject;

   if ( NULL == pItem )
      return E_POINTER;

   hr = pItem->GetDataObject( &pDataObject, CCT_RESULT );
   if ( FAILED(hr) )
      return hr;

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, 
      NULL, 
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   //
   // Allocate memory to received the GUID.
   //
   stgmedium.hGlobal = GlobalAlloc( 0, sizeof( GUID ) );
   if ( stgmedium.hGlobal == NULL )
      return( E_OUTOFMEMORY );

   //
   // Retrieve the GUID of the paste object.
   //
   hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
   if( FAILED( hr ) )
   {
      GlobalFree(stgmedium.hGlobal);
      return( hr );
   }

   //
   // Make a local copy of the GUID.
   //
   memcpy( pOutGuid, stgmedium.hGlobal, sizeof( GUID ) );
   GlobalFree( stgmedium.hGlobal );

   return hr;
}



HRESULT 
   GetConsoleFromCSnapInObjectRootBase( 
      CSnapInObjectRootBase* pObj, 
      IConsole             **ppConsole
   )
{
   HRESULT              hr = E_FAIL;

   switch (pObj->m_nType)
   {
   case 1:
      {
         *ppConsole = ((CDomMigrator*)pObj)->m_spConsole;
         (*ppConsole)->AddRef();
         hr = S_OK;
      }
      break;
   case 2:
      {
         *ppConsole = ((CDomMigratorComponent *)pObj)->m_spConsole;
         (*ppConsole)->AddRef();
         hr = S_OK;
      }
      break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\helputils.h ===
//--------------------------------------------------------------------------
// HelpUtils.h: interface for the HelpUtils class.
// 
// (c) Copyright 1999, Mission Critical Software, Inc. All Rights Reserved.
// 
// Proprietary and confidential to Mission Critical Software, Inc. 
//--------------------------------------------------------------------------

#if !defined(AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_)
#define AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//--------------------------------------------------------------------------
// Included Files
//--------------------------------------------------------------------------
#include "EemGuiDll.h"

//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
namespace HelpUtils  
{
   HRESULT ShowHelpTopic(HWND hWnd, UINT nHelpTopicID);
};

#endif // !defined(AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\globals.h ===
#ifndef GLOBALS_H
#define GLOBALS_H


#define  IMAGE_INDEX_TOOL              0  
#define  IMAGE_INDEX_TOOL_OPEN         1  

#define  IMAGE_INDEX_DOMAIN            2
#define  IMAGE_INDEX_DOMAIN_OPEN       3

#define  IMAGE_INDEX_VIEW              27//4
#define  IMAGE_INDEX_VIEW_OPEN         28//5
                                       
#define  IMAGE_INDEX_AD                6  
#define  IMAGE_INDEX_AD_OPEN           7  

#define  IMAGE_INDEX_OU                8  
#define  IMAGE_INDEX_OU_OPEN           9  

#define  IMAGE_INDEX_USERSCTN          10  
#define  IMAGE_INDEX_USERSCTN_OPEN     11  

#define  IMAGE_INDEX_USER              12
#define  IMAGE_INDEX_USER_OPEN         12

#define  IMAGE_INDEX_GROUP             13
#define  IMAGE_INDEX_GROUP_OPEN        13

#define  IMAGE_INDEX_TRTYFLTSCTN       14  
#define  IMAGE_INDEX_TRTYFLTSCTN_OPEN  15

#define  IMAGE_INDEX_TRTYFILTER        16
#define  IMAGE_INDEX_TRTYFILTER_OPEN   17

#define  IMAGE_INDEX_TERRITORY         18
#define  IMAGE_INDEX_TERRITORY_OPEN    18

#define  IMAGE_INDEX_TERRSECTOR        19
#define  IMAGE_INDEX_TERRSECTOR_OPEN   19

#define  IMAGE_INDEX_GRPFLTSCTN        20
#define  IMAGE_INDEX_GRPFLTSCTN_OPEN   21

#define  IMAGE_INDEX_GRPFILTER         22
#define  IMAGE_INDEX_GRPFILTER_OPEN    23

#define  IMAGE_INDEX_LOG               24
#define  IMAGE_INDEX_LOG_OPEN          24

#define  IMAGE_INDEX_ACTIVITY          25
#define  IMAGE_INDEX_ACTIVITY_OPEN     25

#define  IMAGE_INDEX_OBJECTS           26
#define  IMAGE_INDEX_OBJECTS_OPEN      26

#define  IMAGE_INDEX_COMPUTER_WS       29
#define  IMAGE_INDEX_COMPUTER_WS_OPEN  30

#define  IMAGE_INDEX_COMPUTER_DC       41
#define  IMAGE_INDEX_COMPUTER_DC_OPEN  41

#define  IMAGE_INDEX_COMPFILTER        31
#define  IMAGE_INDEX_COMPFILTER_OPEN   32

#define  IMAGE_INDEX_AD_BUSY           33
#define  IMAGE_INDEX_AD_BUSY_OPEN      34
#define  IMAGE_INDEX_OU_BUSY           35
#define  IMAGE_INDEX_OU_BUSY_OPEN      36
#define  IMAGE_INDEX_USERSCTN_BUSY     37
#define  IMAGE_INDEX_USERSCTN_BUSY_OPEN 38

#define  IMAGE_INDEX_PRINTER           39
#define  IMAGE_INDEX_PRINTER_OPEN      39

#define  IMAGE_INDEX_SHARE             40
#define  IMAGE_INDEX_SHARE_OPEN        40

HRESULT 
   InsertNodeToScopepane( 
      IConsoleNameSpace    * pConsoleNameSpace, 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID = 0
   );

HRESULT 
   InsertNodeToScopepane2( 
      IConsole             * pConsole     , 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID = 0
   );


HRESULT 
   GetSnapInItemGuid( 
      CSnapInItem          * pItem        , 
      GUID                 * pOutGuid
   );


HRESULT 
   GetConsoleFromCSnapInObjectRootBase( 
      CSnapInObjectRootBase* pObj, 
      IConsole             **ppConsole
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\multisel.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "Globals.h"
#include "MultiSel.h"

UINT CMultiSelectItemDataObject::s_cfMsObjTypes  = 0;       // MultiSelect clipformat
UINT CMultiSelectItemDataObject::s_cfMsDataObjs  = 0;       // MultiSelect clipformat

CMultiSelectItemDataObject::CMultiSelectItemDataObject()
{
   m_objectDataArray.RemoveAll();
   m_ddStatusArray.RemoveAll();
   m_pParentItem = NULL;
   s_cfMsObjTypes  = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
   s_cfMsDataObjs  = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
   m_bHasGroup = false;
}


CMultiSelectItemDataObject::~CMultiSelectItemDataObject()
{
   for ( int i = 0; i < m_objectDataArray.GetSize(); i++ )
   {
      delete (CObjectData *)(m_objectDataArray[i]);
   }
}


DWORD  CMultiSelectItemDataObject::GetItemCount()
{
   return (DWORD)m_objectDataArray.GetSize();
}

HRESULT  CMultiSelectItemDataObject::AddMultiSelectItem( CObjectData *pDataObject )
{
   m_objectDataArray.Add(pDataObject);
   m_ddStatusArray.Add(DD_NONE);

   return S_OK;
}

void  CMultiSelectItemDataObject::SetParentItem( CSnapInItem *pParentItem )
{
   m_pParentItem = pParentItem;
}

CSnapInItem *CMultiSelectItemDataObject::GetParentItem()
{
   return m_pParentItem;
}

void CMultiSelectItemDataObject::GetParentGuid(GUID *guid)
{
   memcpy( guid, &m_parentGuid, sizeof( GUID ) );
}

void CMultiSelectItemDataObject::SetParentGuid(GUID *guid)
{
   memcpy( &m_parentGuid, guid, sizeof( GUID ) );
}

CSnapInItem *CMultiSelectItemDataObject::GetSnapInItem(DWORD index)
{
   if ( GetItemCount() <= index )
      return NULL;
   return ((CObjectData *)m_objectDataArray[index])->m_pItem;
}

BYTE CMultiSelectItemDataObject::GetDDStatus(DWORD index)
{
   if ( GetItemCount() <= index )
      return DD_NONE;
   return m_ddStatusArray[index];
}

void CMultiSelectItemDataObject::SetDDStatus(DWORD index, BYTE status)
{
   if ( GetItemCount() <= index )
      return;
   m_ddStatusArray[index] = status;
}


STDMETHODIMP CMultiSelectItemDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{

   if (( pmedium == NULL ) || ( pformatetc == NULL ))
      return E_POINTER;
   
   pmedium->pUnkForRelease = NULL;   // by OLE spec

   HRESULT hr = DV_E_TYMED;

   // Make sure the type medium is HGLOBAL
   if (pmedium->tymed == TYMED_HGLOBAL )
   {
      if ( s_cfMsObjTypes == pformatetc->cfFormat )
      {
         // Create the stream on the hGlobal passed in
         CComPtr<IStream> spStream;
         hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
         if (SUCCEEDED(hr))
         {
            hr = DV_E_CLIPFORMAT;
            if (pformatetc->cfFormat == s_cfMsObjTypes)
            {
               DWORD  objCount = (DWORD)m_objectDataArray.GetSize();
               spStream->Write( &objCount, sizeof(DWORD), NULL );
               for ( DWORD i = 0; i < objCount; i++ )
               {
                  CSnapInItem* pItem;
                  pItem = (CSnapInItem*)((CObjectData*)m_objectDataArray[i])->m_pItem;
                  pItem->FillData( pItem->m_CCF_NODETYPE, spStream);
               }
            }
         }
      }
   }

   return hr;

}


STDMETHODIMP CMultiSelectItemDataObject::GetData
(
   FORMATETC *pformatetc,     // [in]  Pointer to the FORMATETC structure 
   STGMEDIUM *pmedium          // [out] Pointer to the STGMEDIUM structure  
)
{
   HRESULT hr = DATA_E_FORMATETC;

   if (( pmedium == NULL ) || ( pformatetc == NULL ))
      return E_POINTER;

   if( s_cfMsObjTypes == pformatetc->cfFormat )
   {
      HGLOBAL  hMem    = NULL;
      DWORD  objCount = GetItemCount();

      ATLTRACE( L"CMultiSelectItemDataObject::GetData - asked for MultiSelect Object \n" );
      hMem = ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(GUID)*objCount + sizeof(DWORD));
      if( NULL == hMem )
         hr = STG_E_MEDIUMFULL;               
      else
      {                                        
         CComPtr<IStream> spStream;
         hr = CreateStreamOnHGlobal(hMem, FALSE, &spStream);
         if (SUCCEEDED(hr))
         {
            spStream->Write( &objCount, sizeof(DWORD), NULL );
            for ( DWORD i = 0; i < objCount; i++ )
            {
               CSnapInItem* pItem;
               pItem = (CSnapInItem*)((CObjectData*)m_objectDataArray[i])->m_pItem;
               pItem->FillData( pItem->m_CCF_NODETYPE, spStream);
            }
            pmedium->hGlobal = hMem;               // StgMedium variables 
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;
         }
      }
   }  

   ATLTRACE( L"CMultiSelectItemDataObject::GetData returned 0x%X \n", hr );
   return hr;

} // end GetData()


STDMETHODIMP CMultiSelectItemDataObject::QueryGetData(FORMATETC *pformatetc)
{
   HRESULT hr = S_FALSE;

   if ( pformatetc == NULL )
      return E_POINTER;

   if( (0 != s_cfMsObjTypes) && (s_cfMsObjTypes == pformatetc->cfFormat) )
   {
      hr = S_OK;            
   }    
  
   ATLTRACE( L"CMultiSelectItemDataObject::QueryGetData() called with ClipFormat 0x%X \n", pformatetc->cfFormat );
   return hr;
}


HRESULT  CMultiSelectItemDataObject::OnNotify(CDomMigratorComponent *pComponent, MMC_NOTIFY_TYPE event, long arg, long param )
{
   HRESULT hr = E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   CComPtr<IConsole> spConsole;

   if ( 0 == objCount )
      return hr;

   if ( pComponent == NULL )
      return E_POINTER;

   spConsole = ((CDomMigratorComponent*)pComponent)->m_spConsole;

   switch (event)
   {
   case MMCN_SELECT:
      {   
         bool  bSelect = (HIWORD(arg) != 0 );
         if ( bSelect )
         {
            hr = OnSelect(spConsole);
         }
         break;
      }
   case MMCN_DELETE:
      //hr = OnDelete(spConsole);
      break;

   case MMCN_CUTORMOVE:               
      hr = OnCutOrMove(spConsole);
      break;
   default:
      break;
   }
   
   return hr;

}


HRESULT CMultiSelectItemDataObject::OnCutOrMove( IConsole* pConsole )
{
   HRESULT  hr = S_OK;//E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   
   if ( 0 == objCount )
      goto ret_exit;

   if ( pConsole == NULL )
      return E_POINTER;

   GUID           itemParentGuid;
   GetParentGuid( &itemParentGuid );
   
ret_exit:
   return hr;
}




HRESULT CMultiSelectItemDataObject::OnSelect(IConsole *pConsole)
{
   HRESULT  hr = S_OK;//E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   
   if ( 0 == objCount )
      goto ret_exit;

   if ( pConsole == NULL )
      return E_POINTER;

   GUID           itemParentGuid;
   GetParentGuid( &itemParentGuid );
   
   hr = OnSelectAllowDragDrop( pConsole );
   
ret_exit:
   return hr;
}


HRESULT CMultiSelectItemDataObject::OnSelectAllowDragDrop(IConsole *pConsole)
{
   HRESULT        hr = S_OK;
   CComPtr<IConsoleVerb> pConsoleVerb;

   if ( pConsole == NULL )
      return E_POINTER;

   hr = pConsole->QueryConsoleVerb( &pConsoleVerb );
   if ( FAILED( hr ) )
      goto ret_exit;

   //
   // Enable the delete verb.
   //
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;

   //
   // Enable the copy verb.
   //
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, HIDDEN, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;

ret_exit:
   return hr;
}

SMMCDataObjects *CMultiSelectItemDataObject::ExtractMSDataObjects( LPDATAOBJECT lpDataObject )
{
   HRESULT        hr = S_OK;
   SMMCDataObjects *p = NULL;
   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = { (CLIPFORMAT)s_cfMsDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                           };


   hr = lpDataObject->GetData(&formatetc, &stgmedium);
   if (FAILED(hr))
      goto ret_exit;

   p = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);

   //ReleaseStgMedium(&stgmedium);

ret_exit:
   return p;
}

HRESULT CMultiSelectItemDataObject::Command(long lCommandID,
   CSnapInObjectRootBase* pObj,
   DATA_OBJECT_TYPES type)
{
   bool bHandled = false;
   
   return ProcessCommand(lCommandID, bHandled, pObj, type);
}


HRESULT CMultiSelectItemDataObject::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback,
   long *pInsertionAllowed,
   DATA_OBJECT_TYPES type)
{
   if ( m_bHasGroup )
      return S_OK;

   if ( piCallback == NULL )
      return E_POINTER;

   //ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::AddMenuItems\n"));
   //T* pT = static_cast<T*>(this);
   bool bIsExtension = false;

   if (!bIsExtension)
      /*pT->*/SetMenuInsertionFlags(true, pInsertionAllowed);

   UINT menuID = /*pT->*/GetMenuID();
   if (menuID == 0)
      return S_OK;

   HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
   long insertionID;
   if (hMenu)
   {
      for (int i = 0; 1; i++)
      {
         HMENU hSubMenu = GetSubMenu(hMenu, i);
         if (hSubMenu == NULL)
            break;
         
         MENUITEMINFO menuItemInfo;
         memset(&menuItemInfo, 0, sizeof(menuItemInfo));
         menuItemInfo.cbSize = sizeof(menuItemInfo);

         switch (i)
         {
         case 0:
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
               continue;
            insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            break;

         case 1:
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
               continue;
            if (bIsExtension)
               insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
            else
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
            break;

         case 2:;
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
               continue;
            if (bIsExtension)
               insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
            else
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            break;
         case 3:;
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
               continue;
            insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            break;
         default:
            {
               insertionID = 0;
               continue;
            }
            break;
         }

         menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
         menuItemInfo.fType = MFT_STRING;
         TCHAR szMenuText[128];

         for (int j = 0; 1; j++)
         {
            menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            menuItemInfo.fType = MFT_STRING;
            menuItemInfo.cch = 128;
            menuItemInfo.dwTypeData = szMenuText;
            TCHAR szStatusBar[256];

            if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
               break;
            if (menuItemInfo.fType != MFT_STRING)
               continue;

            /*pT->*/UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
            LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

            OLECHAR wszStatusBar[256];
            OLECHAR wszMenuText[128];
            USES_CONVERSION;
            ocscpy(wszMenuText, T2OLE(szMenuText));
            ocscpy(wszStatusBar, T2OLE(szStatusBar));

            CONTEXTMENUITEM contextMenuItem;
            contextMenuItem.strName = wszMenuText;
            contextMenuItem.strStatusBarText = wszStatusBar;
            contextMenuItem.lCommandID = menuItemInfo.wID;
            contextMenuItem.lInsertionPointID = insertionID;
            contextMenuItem.fFlags = menuItemInfo.fState;
            contextMenuItem.fSpecialFlags = 0;
            
            HRESULT hr = piCallback->AddItem(&contextMenuItem);
            ATLASSERT(SUCCEEDED(hr));
         }
      }
      DestroyMenu(hMenu);
   }

   if (!bIsExtension)
      /*pT->*/SetMenuInsertionFlags(true, pInsertionAllowed);

   return S_OK;
}


HRESULT  CMultiSelectItemDataObject::OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   HRESULT           hr=S_OK;
/*   CVersionInfoDlg   dlg;

   dlg.DoModal();

  */ hr = S_OK;

   return hr;
}


HRESULT CMultiSelectItemDataObject::OnMoveMultipleObjs(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   HRESULT           hr = S_OK;
   CComPtr<IConsole> pConsole;

   hr = GetConsoleFromCSnapInObjectRootBase(pObj, &pConsole);
   if (FAILED(hr))
      return hr;

  
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\multisel.h ===
#include <atlsnap.h>
#include <wtypes.h>

// multiselection dragdrop status
enum 
{ 
   DD_NONE = 0,
   DD_SUCCEEDED,
   DD_FAILED
};


class CMultiSelectItemDataObject: 
   public CComObjectRootEx<CComSingleThreadModel>,
   public IDataObject
{
public:
   CMultiSelectItemDataObject();
   ~CMultiSelectItemDataObject();

public:
   BEGIN_COM_MAP(CMultiSelectItemDataObject)
      COM_INTERFACE_ENTRY(IDataObject)
   END_COM_MAP()

   BEGIN_SNAPINCOMMAND_MAP(CMultiSelectItemDataObject, FALSE)
      SNAPINCOMMAND_ENTRY(ID_TOP_MOVE, OnMoveMultipleObjs )
      SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_MULTISEL_MENU)

   // interface member functions
public:
   STDMETHOD(GetDataHere)(FORMATETC *pformatetc, STGMEDIUM *pmedium);
   STDMETHOD(GetData)(FORMATETC *pformatetc, STGMEDIUM *pmedium);
   STDMETHOD(QueryGetData)(FORMATETC *pformatetc);
   
   STDMETHOD(GetClassID)(CLSID *pCLSID)
   {
      return S_FALSE;
   }
   
   STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
   }
   STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
   }
   STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
      DWORD *pdwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(DUnadvise)(DWORD dwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
   }
   STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }

   // non-interface member functions
public:
   HRESULT  AddMultiSelectItem( CObjectData *pDataObject );
   HRESULT  OnNotify(CDomMigratorComponent *pComponent, MMC_NOTIFY_TYPE event, long arg, long param );

   HRESULT  AddMenuItems(LPCONTEXTMENUCALLBACK piCallback,
      long *pInsertionAllowed, DATA_OBJECT_TYPES type);
   void UpdateMenuState( UINT id, LPTSTR pBuf, UINT *flags){}
   void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed){}
   HRESULT Command(long lCommandID, CSnapInObjectRootBase* pObj, DATA_OBJECT_TYPES type);

   HRESULT  OnSelect(IConsole *spConsole);
   HRESULT  OnSelectAllowDragDrop(IConsole *spConsole);

   HRESULT  OnCutOrMove( IConsole* pConsole );
   
   void     SetParentGuid( GUID *guid );
   void     GetParentGuid( GUID *guid );
   DWORD    GetItemCount();
   void     SetParentItem( CSnapInItem *pParentItem );
   CSnapInItem *GetParentItem();
   CSnapInItem *GetSnapInItem(DWORD index);

   BYTE GetDDStatus(DWORD index);
   void SetDDStatus(DWORD index, BYTE status);

   static SMMCDataObjects *ExtractMSDataObjects( LPDATAOBJECT lpDataObject );

/*   CNetNode *GetDomainPtr()
   {
      return m_pDomain;
   }

   void SetDomainPtr( CNetNode *ptr )
   {
      m_pDomain = ptr;
   }
*/
   HRESULT OnMoveMultipleObjs(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj);

private:
   CPtrArray      m_objectDataArray;
   CByteArray     m_ddStatusArray;
   CSnapInItem    *m_pParentItem;
   GUID           m_parentGuid;
//   CNetNode       *m_pDomain;

public:
   bool           m_bHasGroup;

public:
   static UINT    s_cfMsObjTypes;          // MultiSelect clipformats
   static UINT    s_cfMsDataObjs;          // MultiSelect snapin

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\helputils.cpp ===
//--------------------------------------------------------------------------
// HelpUtils.cpp: implementation of the HelpUtils class.
// 
// (c) Copyright 1999, Mission Critical Software, Inc. All Rights Reserved.
// 
// Proprietary and confidential to Mission Critical Software, Inc. 
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <McString.h>
#include <GuiUtils.h>
#include "HelpUtils.h"
#include <HtmlHelp.h>
#include "HtmlHelpUtil.h"

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
HRESULT
   HelpUtils::ShowHelpTopic(HWND hWnd, UINT nHelpTopicID)
{
   McString::String mcstrHelpPathName = GuiUtils::GetHelpPathName();
   HWND h = ::HtmlHelp(hWnd, mcstrHelpPathName.getWide(), HH_HELP_CONTEXT, nHelpTopicID);
   if (!IsInWorkArea(h))
        PlaceInWorkArea(h);
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\mynodes.h ===
#ifndef MYNODES_H
#define MYNODES_H
#include "NetNode.h"
#include "resource.h"
#include <comdef.h>
//#include "..\\Common\\Common.hpp"
//#include "..\\Common\\UString.hpp"
#include "Common.hpp"
#include "UString.hpp"

class CRootNode : public CNetNode<CRootNode>
{
public:
   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;

   BEGIN_SNAPINCOMMAND_MAP(CRootNode, FALSE)
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEUSERSANDGROUPS, OnMigrateUsers )
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEGROUPS, OnMigrateGroups )
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATECOMPUTERS, OnMigrateComputers )
      SNAPINCOMMAND_ENTRY(ID_TOP_TRANSLATESECURITY, OnTranslateSecurity )
	  SNAPINCOMMAND_ENTRY(ID_TOP_UNDO, OnUndo )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEEXCHANGESERVER, OnMigrateExchangeServer )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEEXCHANGEDIRECTORY, OnMigrateExchangeDirectory )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATESERVICEACCOUNTS, OnMigrateServiceAccounts )
	  SNAPINCOMMAND_ENTRY(ID_TOP_REPORTING, OnReporting )
	  SNAPINCOMMAND_ENTRY(ID_TOP_RETRY, OnRetry )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATETRUSTS, OnMigrateTrusts )
	  SNAPINCOMMAND_ENTRY(ID_TOP_GROUPMAPPING, OnGroupMapping )
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_ROOT_MENU)
   
   
   
   CRootNode();
   ~CRootNode();

   void SetMainWindow(HWND hwndMainWindow)
   {
      m_hwndMainWindow = hwndMainWindow;
   }

   void CheckForFailedActions(BOOL bPrompt = TRUE);
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
   
   HRESULT OnGroupMapping(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateUsers(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnUndo(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateGroups(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateComputers(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnTranslateSecurity(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateExchangeServer(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateExchangeDirectory(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateServiceAccounts(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnReporting(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnRetry(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateTrusts(bool &bHandled, CSnapInObjectRootBase* pObj);
 
private:

   HWND m_hwndMainWindow;

   bool IsUndoable;
   bool CanUseST;
   bool CanRetry;

  void CheckUndoable();
  void CheckForST();
  void UpdateMigratedObjectsTable();
  void UpdateAccountReferenceTable();
  
};

class CReportingNode : public CNetNode<CReportingNode>
{
   UINT           m_idHTML;
   WCHAR          m_htmlPath[MAX_PATH];
   CReportingNode * m_Reports[5];

public:

   BEGIN_SNAPINCOMMAND_MAP(CReportingNode, FALSE)
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
  END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_REPORTS)
   

   CReportingNode();

   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;

   void SetHtmlPath(WCHAR const * title, WCHAR const * path) { m_bstrDisplayName = SysAllocString(title); safecopy(m_htmlPath,path); }

   STDMETHODIMP GetResultViewType(LPOLESTR * ppViewType, long *pViewOptions);
   HRESULT UpdateChildren(IConsole * pConsole);   
   // action handlers
};

class CPruneGraftNode : public CNetNode<CPruneGraftNode>
{
   BOOL              m_bLoaded;
   _bstr_t           m_Domain;
   _bstr_t           m_LDAPPath;
   _bstr_t           m_objectClass;
   CStringArray      m_Data;

  
public:

   BEGIN_SNAPINCOMMAND_MAP(CPruneGraftNode, FALSE)
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
      SNAPINCOMMAND_ENTRY(ID_TOP_ADDDOMAIN,OnAddDomain)
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_PRUNE_GRAFT_MENU)
   

   CPruneGraftNode();

   // initialization
   void Init( WCHAR const * domain, WCHAR const *  path, WCHAR const * objClass, WCHAR const * displayName);

   BOOL ShowInScopePane();

   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;


   // Action handlers
   HRESULT OnAddDomain(bool &bHandled, CSnapInObjectRootBase * pObj);
   virtual HRESULT OnExpand( IConsole *spConsole );
   virtual HRESULT OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData);
   virtual LPOLESTR GetResultPaneColInfo(int nCol);
   void AddColumnValue(int col,WCHAR const * value);

protected:
   // helper functions
   HRESULT EnumerateChildren( IConsole * spConsole);
   SAFEARRAY * GetAvailableColumns(WCHAR const * objectClass);
   HRESULT LoadChildren(IEnumVARIANT * pValues);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\netnode.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "NetNode.h"
#include "Globals.h"


template <class T> HRESULT  CNetNode<T>::IsDirty()
{
   return m_bIsDirty;
}



template <class T> HRESULT  CNetNode<T>::Load(IStream *pStm)
{
   HRESULT           hr = S_OK;
   
   return hr;
}

template <class T> HRESULT  CNetNode<T>::Save(IStream *pStm, BOOL fClearDirty )
{
   HRESULT           hr = S_OK;

   return hr;
}

template <class T> HRESULT  CNetNode<T>::GetSaveSizeMax(ULARGE_INTEGER *pcbSize)
{
   HRESULT  hr = S_OK;
   int      size = 0, i, numDomain;

   numDomain = m_ChildArray.GetSize();
   // number of domains
   size += sizeof(numDomain);
   // domainNames
   for ( i = 0; i < numDomain; i++ )
   {  
      T  * pDomain;
      
      pDomain = (T *)m_ChildArray[i];
   }
   pcbSize->QuadPart = size;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\netnode.h ===
#ifndef NETNODE_H
#define NETNODE_H

#include <atlsnap.h>
#include "resource.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "Globals.h"
#include "HtmlHelp.h"
#include "HelpID.h"
#define MAX_COLUMNS              6

extern CSnapInToolbarInfo   m_toolBar;
template <class T>
class ATL_NO_VTABLE CNetNode : public CSnapInItemImpl<T>
{
public:
// 
   bool           m_bExpanded;
   int            m_iColumnWidth[MAX_COLUMNS];

   bool           m_bIsDirty;
   bool           m_bLoaded;
//
   CPtrArray      m_ChildArray;

   CComPtr<IControlbar>        m_spControlBar;
   
   
   CNetNode()
   {
      // Image indexes may need to be modified depending on the images specific to 
      // the snapin.
      memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
      m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
      m_scopeDataItem.displayname = MMC_CALLBACK;
      m_scopeDataItem.nImage = 0;      // May need modification
      m_scopeDataItem.nOpenImage = 0;   // May need modification
      m_scopeDataItem.lParam = (LPARAM) this;
      memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
      m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
      m_resultDataItem.str = MMC_CALLBACK;
      m_resultDataItem.nImage = 0;     // May need modification
      m_resultDataItem.lParam = (LPARAM) this;

      // 
      CoInitialize( NULL );
      m_bLoaded = false;
      m_bExpanded = false;
   
      m_iColumnWidth[0] = 400;
      m_iColumnWidth[1] = 0;
      m_iColumnWidth[2] = 0;
      SetClean();
   }
   ~CNetNode()
   {
         
      for ( int i = 0; i < m_ChildArray.GetSize(); i++ )
      {
         delete (T *)(m_ChildArray[i]);
      }
      CoUninitialize();
   }

  STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
  {
	  if ( pScopeDataItem == NULL )
	     return E_POINTER;

      if (pScopeDataItem->mask & SDI_STR)
         pScopeDataItem->displayname = m_bstrDisplayName;
      if (pScopeDataItem->mask & SDI_IMAGE)
         pScopeDataItem->nImage = m_scopeDataItem.nImage;
      if (pScopeDataItem->mask & SDI_OPENIMAGE)
         pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
      if (pScopeDataItem->mask & SDI_PARAM)
         pScopeDataItem->lParam = m_scopeDataItem.lParam;
      if (pScopeDataItem->mask & SDI_STATE )
         pScopeDataItem->nState = m_scopeDataItem.nState;
      pScopeDataItem->cChildren = (int)m_ChildArray.GetSize();
      
      return S_OK;
  }

   STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
   {
	  if ( pResultDataItem == NULL )
	     return E_POINTER;

      if (pResultDataItem->bScopeItem)
      {
         if (pResultDataItem->mask & RDI_STR)
         {
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
         }
         if (pResultDataItem->mask & RDI_IMAGE)
         {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
         }
         if (pResultDataItem->mask & RDI_PARAM)
         {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
         }

         return S_OK;
      }

      if (pResultDataItem->mask & RDI_STR)
      {
         pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
      }
      if (pResultDataItem->mask & RDI_IMAGE)
      {
         pResultDataItem->nImage = m_resultDataItem.nImage;
      }
      if (pResultDataItem->mask & RDI_PARAM)
      {
         pResultDataItem->lParam = m_resultDataItem.lParam;
      }
      if (pResultDataItem->mask & RDI_INDEX)
      {
         pResultDataItem->nIndex = m_resultDataItem.nIndex;
      }

      return S_OK;
   }


   HRESULT __stdcall Notify( MMC_NOTIFY_TYPE event,
      long arg,
      long param,
      IComponentData* pComponentData,
      IComponent* pComponent,
      DATA_OBJECT_TYPES type)
   {
      // Add code to handle the different notifications.
      // Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
      // In response to MMCN_SHOW you have to enumerate both the scope
      // and result pane items.
      // For MMCN_EXPAND you only need to enumerate the scope items
      // Use IConsoleNameSpace::InsertItem to insert scope pane items
      // Use IResultData::InsertItem to insert result pane item.
      HRESULT hr = E_NOTIMPL;

   
      _ASSERTE(pComponentData != NULL || pComponent != NULL);
	  if (( pComponent == NULL ) && ( pComponentData == NULL ))
	     return E_POINTER;

      CComPtr<IConsole> spConsole;
      CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
      if (pComponentData != NULL)
         spConsole = ((CDomMigrator*)pComponentData)->m_spConsole;
      else
      {
         spConsole = ((CDomMigratorComponent*)pComponent)->m_spConsole;
         spHeader = spConsole;
      }

      switch (event)
      {
      case MMCN_REMOVE_CHILDREN:
         hr = S_OK;
         break;

      case MMCN_SHOW:
         {
            CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);

            bool bShow = (arg != 0);
            hr = OnShow( bShow, spHeader, spResultData );
            break;
         }
   /*   case MMCN_EXPANDSYNC:
         {
            MMC_EXPANDSYNC_STRUCT  *pExpandStruct = ( MMC_EXPANDSYNC_STRUCT *)param;
            break;
         }
   */
      case MMCN_EXPAND:
         {
            m_bExpanded = true;
            m_scopeDataItem.ID = param;
            hr = OnExpand( spConsole );
            hr = S_OK;
            break;
         }
		case MMCN_ADD_IMAGES:
			{
				// Add Images
				IImageList* pImageList = (IImageList*) arg;
				hr = E_FAIL;
				// Load bitmaps associated with the scope pane
				// and add them to the image list
				// Loads the default bitmaps generated by the wizard
				// Change as required
				HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_16));
				if (hBitmap16 != NULL)
				{
					HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_32));
					if (hBitmap32 != NULL)
					{
						hr = pImageList->ImageListSetStrip((long*)hBitmap16, 
						(long*)hBitmap32, 0, RGB(0, 128, 128));
						if (FAILED(hr))
							ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
	                    DeleteObject(hBitmap16);
	                    DeleteObject(hBitmap32);
					}
					else
   	                    DeleteObject(hBitmap16);
				}
				break;
			}
      case MMCN_DBLCLICK:
         {
            hr = S_FALSE;
            break;
         }
      case MMCN_REFRESH:
         {
            hr = OnRefresh(spConsole);
   //         ShowErrorMsg( spConsole, hr, _T("Refresh All Domains") );
            break;
         }
      case MMCN_SELECT:
         {
            //
            // Call our select handler.
            //
            bool  bScope = (LOWORD(arg) != 0 );
            bool  bSelect = (HIWORD(arg) != 0 );
            hr = OnSelect( bScope, bSelect, spConsole );
            break;
         }
	  case MMCN_SNAPINHELP:
	  case MMCN_HELP :
	  case MMCN_CONTEXTHELP:       
		  {	
			  AFX_MANAGE_STATE(AfxGetStaticModuleState());
           HWND            mainHwnd;
			  CComBSTR        bstrTopic;
			  HRESULT         hr;
			  IDisplayHelp *  pHelp = NULL;

			  ATLTRACE(_T("MMCN_SNAPINHELP\n"));
			  
           spConsole->GetMainWindow( &mainHwnd );
         
           hr = spConsole->QueryInterface(IID_IDisplayHelp,(void**)&pHelp);
           if ( SUCCEEDED(hr) )
           {
			     CString      strTopic;

              strTopic.FormatMessage(IDS_HelpFileIntroTopic);

              if ( SUCCEEDED(hr) )
			     {
				     hr = pHelp->ShowTopic(strTopic.AllocSysString());
                 if ( FAILED(hr) )
                 {
                    CString s;
				        s.LoadString(IDS_FAILED);
				        MessageBox(NULL,s,L"",MB_OK);
                 }
			     }
			     else
			     {
				     CString s;
				     s.LoadString(IDS_FAILED);
				     MessageBox(NULL,s,L"",MB_OK);
			     }
              pHelp->Release();
           }
		  }
		  return S_OK;
		  
	  default:
         break;

      }
      return hr;
   }

   virtual LPOLESTR GetResultPaneColInfo(int nCol)
   {
      if (nCol == 0)
         return m_bstrDisplayName;
      // TODO : Return the text for other columns
      return OLESTR("Override GetResultPaneColInfo");
   }
   // Message handler helpers
   HRESULT OnSelect( bool bScope, bool bSelect, IConsole* pConsole )
   {
      HRESULT hr=S_OK;

      if ( bSelect )
      {
		 if ( pConsole == NULL )
			return E_POINTER;

         CComPtr<IConsoleVerb> spConsoleVerb;
         hr = pConsole->QueryConsoleVerb( &spConsoleVerb );
         if ( FAILED( hr ) )
            return hr;
         //
         // Enable the refresh verb.
         //
         hr = spConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
         if ( FAILED( hr ) )
            return hr;
      }

      return( hr );
   }
   
   virtual BOOL ShowInScopePane() { return TRUE; }
   virtual HRESULT OnExpand( IConsole *spConsole )
   {
      HRESULT hr=S_OK;
      CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
         
      //
      // Enumerate scope pane items
      //
      for (int i = 0; i < m_ChildArray.GetSize(); ++i)
      {
         if ( ((CNetNode*)m_ChildArray[i])->ShowInScopePane() )
         {
            hr = InsertNodeToScopepane(spConsoleNameSpace, (CNetNode*)m_ChildArray[i], m_scopeDataItem.ID );
            if (FAILED(hr))
               break;
         }
      }
      return hr;
   }

   virtual HRESULT OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData)
   {
      HRESULT hr=S_OK;

      if (bShow)       
      {  // show
	         {
            CString  cstr;
            CComBSTR text;

			if ( spResultData == NULL )
				return E_POINTER;

            cstr.Format(_T("%d subitem(s)"), m_ChildArray.GetSize() );
            text = (LPCTSTR)cstr;
            spResultData->SetDescBarText( BSTR(text) ); 
         }
      }
      else
      {  // hide
         // save the column widths
		 if ( spHeader == NULL )
		    return E_POINTER;

         spHeader->GetColumnWidth(0, m_iColumnWidth);
         spHeader->GetColumnWidth(1, m_iColumnWidth + 1);
         spHeader->GetColumnWidth(2, m_iColumnWidth + 2);
      }
      hr = S_OK;

      return hr;
   }
   HRESULT OnRefresh(IConsole *spConsole)
   {
      HRESULT  hr=S_OK;

      if ( m_bExpanded )
      {   
         // Refresh the children
         for ( int i = 0; i < m_ChildArray.GetSize(); i++ )
         {
            hr = ((T *)m_ChildArray[i])->OnRefresh(spConsole);
            if ( FAILED(hr) )
               break;
         }
      }
      if ( FAILED(hr) )
      {
         ATLTRACE("CNetNode::OnRefresh failed, hr = %lx\n", hr );
      }
      return hr;
   }
   HRESULT OnGroupDDSetup(bool &bHandled, CSnapInObjectRootBase* pObj) { return S_OK; }
   HRESULT OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj) { return S_OK; }
   
   void UpdateMenuState( UINT id, LPTSTR pBuf, UINT *flags)
   {
      if ( id == ID_TASK_UNDO )
      {
         //if ( CanUndo(pBuf) )
         //   *flags = MF_ENABLED;
        // else
            *flags = MF_GRAYED;
      }
      if ( id == ID_TASK_REDO )
      {
        // if ( CanRedo(pBuf) )
        //    *flags = MF_ENABLED;
        // else
            *flags = MF_GRAYED;
      }
   }
   // IPersistStreamImpl
   HRESULT Load(IStream *pStm);
   HRESULT Save(IStream *pStm, BOOL fClearDirty);
   HRESULT GetSaveSizeMax(ULARGE_INTEGER *pcbSize);
   
   
   HRESULT Loaded()
   {
      if ( m_bLoaded )
         return S_OK;
      else
         return S_FALSE;
   }

   HRESULT IsDirty();

   void SetDirty()
   {
      m_bIsDirty = S_OK;
   }

   void SetClean()
   {
      m_bIsDirty = S_FALSE;
   }
   static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return (CSnapInToolbarInfo*)&m_toolBar;
	}
	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\reptnode.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "MyNodes.h"
#include "TReg.hpp"
#include "ResStr.h"
#include "Err.hpp"

TError         err;
TError      &  errCommon = err;
StringLoader   gString;

//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids

// {F521FE00-3FA1-11d3-8AED-00A0C9AFE114}
static const GUID CReportingGUID_NODETYPE = 
{ 0xf521fe00, 0x3fa1, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };
const GUID*  CReportingNode::m_NODETYPE = &CReportingGUID_NODETYPE;
const OLECHAR* CReportingNode::m_SZNODETYPE = OLESTR("F521FE00-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CReportingNode::m_SZDISPLAY_NAME = GET_BSTR(IDS_Reporting);
const CLSID* CReportingNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;

CReportingNode::CReportingNode()
{
//   m_idHTML = IDR_REPT_HTML;
   m_htmlPath[0] = 0;
   m_bstrDisplayName = SysAllocString(GET_STRING(IDS_ReportsMMCNode));
   m_scopeDataItem.nImage = IMAGE_INDEX_AD;
   m_scopeDataItem.nOpenImage = IMAGE_INDEX_AD_OPEN;
   m_resultDataItem.nImage = 0;
   
   m_Reports[0] = NULL;
   m_Reports[1] = NULL;
   m_Reports[2] = NULL;
   m_Reports[3] = NULL;
   m_Reports[4] = NULL;

         
};

STDMETHODIMP CReportingNode::GetResultViewType(LPOLESTR * ppViewType, long *pViewOptions)
{
   USES_CONVERSION;
   TCHAR                     szPath[MAX_PATH];

   if (( ppViewType == NULL ) || ( pViewOptions == NULL ))
      return E_POINTER;

      // append decorations                                    RT_HTML       IDR_HTML1
   
   if ( m_htmlPath[0] )
   {
      _stprintf(szPath,_T("file://%s"),m_htmlPath);  
   }
   else
   {
      TCHAR   szModulePath[MAX_PATH];
         // set the result view to an HTML page
      GetModuleFileName(_Module.GetModuleInstance(),szModulePath, MAX_PATH);
      szModulePath[MAX_PATH - 1] = _T('\0');
      _stprintf(szPath,_T("res://%s/rept.htm"),szModulePath);
   }
   
   
   (*ppViewType) = (LPOLESTR) CoTaskMemAlloc( (_tcslen(szPath)+1) * (sizeof OLECHAR));
   if (!(*ppViewType))
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   ocscpy(*ppViewType,T2OLE(szPath));
   (*pViewOptions) = MMC_VIEW_OPTIONS_NOLISTVIEWS;
   return S_OK;
}

HRESULT CReportingNode::UpdateChildren(IConsole * pConsole)
{
   HRESULT                   hr = S_OK;

   m_ChildArray.RemoveAll();

   // check the registry entries to see if which reports have been generated
   TRegKey                   rKey;
   WCHAR                     filename[MAX_PATH];
   CReportingNode          * pNode = NULL;

   hr = rKey.Open(GET_STRING(IDS_REGKEY_REPORTS));
   if ( ! hr )
   {
      // check each report
      // Migrated users & groups
      hr = rKey.ValueGetStr(L"MigratedAccounts",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[0] )
         {
            pNode = new CReportingNode();
		    if (pNode == NULL)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedAccounts),filename);
            m_Reports[0] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            pNode = m_Reports[0];
            m_Reports[0]->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedAccounts),filename);
         }
         m_ChildArray.Add(pNode);
      }
      // Migrated computers
      hr = rKey.ValueGetStr(L"MigratedComputers",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[1] )
         {
            pNode = new CReportingNode();
		    if (pNode == NULL)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedComputers),filename);
            m_Reports[1] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            pNode = m_Reports[1];
            m_Reports[1]->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedComputers),filename);
         }
         m_ChildArray.Add(pNode);
      }
      
      // expired computers
      hr = rKey.ValueGetStr(L"ExpiredComputers",filename,MAX_PATH);
      if (! hr )
      {
      
         if ( ! m_Reports[2] ) 
         {
            pNode = new CReportingNode();
		    if (pNode == NULL)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_ExpiredComputers),filename);
            m_Reports[2] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            pNode = m_Reports[2];
            m_Reports[2]->SetHtmlPath(GET_STRING(IDS_REPORT_ExpiredComputers),filename);
         }
         m_ChildArray.Add(pNode);
      }
      
      // account references
      hr = rKey.ValueGetStr(L"AccountReferences",filename,MAX_PATH);
      if (! hr )
      {
         if (! m_Reports[3] )
         {
            pNode = new CReportingNode();
		    if (pNode == NULL)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_AccountReferences),filename);
            m_Reports[3] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            pNode = m_Reports[3];
            m_Reports[3]->SetHtmlPath(GET_STRING(IDS_REPORT_AccountReferences),filename);
         }
         m_ChildArray.Add(pNode);
      }

      // name conflicts
      hr = rKey.ValueGetStr(L"NameConflicts",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[4] )
         {
            pNode = new CReportingNode();
		    if (pNode == NULL)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_NameConflicts),filename);
            m_Reports[4] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }   
         else
         {
            pNode = m_Reports[4];
            m_Reports[4]->SetHtmlPath(GET_STRING(IDS_REPORT_NameConflicts),filename);   
         }
         m_ChildArray.Add(pNode);

      }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\prgrnode.cpp ===
// This node class ...
#include "stdafx.h"
#include "MyNodes.h"
#include "DomSel.h"
#include "..\Common\UString.hpp"
#include "..\Common\Common.hpp"

#import "\bin\NetEnum.tlb" no_namespace, named_guids

// {162A41A3-405C-11d3-8AED-00A0C9AFE114}
static const GUID CPruneGraftGUID_NODETYPE = 
{ 0x162a41a3, 0x405c, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };

const GUID*  CPruneGraftNode::m_NODETYPE = &CPruneGraftGUID_NODETYPE;
const OLECHAR* CPruneGraftNode::m_SZNODETYPE = OLESTR("C8C24622-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CPruneGraftNode::m_SZDISPLAY_NAME = OLESTR("Domain Migrator");
const CLSID* CPruneGraftNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;

//                               0            1                    2          3         4
WCHAR    * gLDAPColumns[] = { L"", L"", L"",  L"", L"" };
WCHAR    * gColumnHeaders[] =  { L"", L"",L"",L"" };

// these define the index in gLDAPColumns to use for each column
int        gDomainMapping[] = { 0,1,2,4 };
int        gOuMapping[] = { 3,1,2,4 };
int        gContainerMapping[] = { 0,1,2,4 };
int        gGroupMapping[] = { 0, 1,2,4 };
int        gUserMapping[] = { 0, 1,2,4 };

CPruneGraftNode::CPruneGraftNode()
{
   // Initialize the array of children
   // TODO:  load the domain hierarchy for the current forest
   m_bLoaded = FALSE;
   m_bstrDisplayName = SysAllocString(L"Prune & Graft");
   m_scopeDataItem.nImage = IMAGE_INDEX_AD;      // May need modification
   m_scopeDataItem.nOpenImage = IMAGE_INDEX_AD_OPEN;   // May need modification
   m_resultDataItem.nImage = IMAGE_INDEX_AD;     // May need modification
   m_Data.SetSize(MAX_COLUMNS);
}

void 
   CPruneGraftNode::Init(
      WCHAR          const * domain,
      WCHAR          const * path, 
      WCHAR          const * objClass,
      WCHAR          const * displayName
   ) 
{ 
   m_Domain = domain;
   m_LDAPPath = path; 
   m_objectClass = objClass; 

   m_bstrDisplayName = displayName;
   // set the icons
   if ( ! UStrICmp(objClass,L"user") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_USER;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_USER_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_USER;     
   }
   else if ( ! UStrICmp(objClass,L"group") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_GROUP;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_GROUP_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_GROUP;     
   }
   else if ( ! UStrICmp(objClass,L"organizationalUnit") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_OU;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_OU_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_OU;     
   }
   else if ( ! UStrICmp(objClass,L"domain") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_DOMAIN;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_DOMAIN_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_DOMAIN;     
   }
   else if ( ! UStrICmp(objClass,L"container") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_VIEW;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_VIEW_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_VIEW;     
   }
}

BOOL
   CPruneGraftNode::ShowInScopePane()
{
   return ( UStrICmp(m_objectClass,L"user") );
}


HRESULT CPruneGraftNode::OnAddDomain(bool &bHandled, CSnapInObjectRootBase * pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   HRESULT                   hr = S_OK;
   CDomainSelDlg             dlg;
   CComPtr<IConsole>         pConsole;
  
   hr = GetConsoleFromCSnapInObjectRootBase(pObj, &pConsole );
   if (FAILED(hr))
      return hr;
   
   if ( IDOK == dlg.DoModal() )
   {
      // insert the domain in the scope pane
      CPruneGraftNode         * pNode = new CPruneGraftNode();

      pNode->Init(dlg.m_Domain.AllocSysString(),L"",L"domain",dlg.m_Domain.AllocSysString());
      
      hr = InsertNodeToScopepane2((IConsole*)pConsole, pNode, m_scopeDataItem.ID );

      m_ChildArray.Add(pNode);

   }
   return hr;
}


HRESULT CPruneGraftNode::OnExpand( IConsole *spConsole )
{
   // TODO:  if we haven't already, enumerate our contents
   if ( ! m_bLoaded )
   {
      EnumerateChildren(spConsole);
      m_bLoaded = TRUE;
   }
   
   return CNetNode<CPruneGraftNode>::OnExpand(spConsole);
}

SAFEARRAY * CPruneGraftNode::GetAvailableColumns(WCHAR const * objectClass)
{
   long                      nItems = 0;
   WCHAR                  ** columns = NULL;

   columns = gLDAPColumns;
   nItems = DIM(gLDAPColumns);

   
   // Build a safearray containing the data
   SAFEARRAYBOUND      bound[1] = { { 0, 0 } };
   long ndx[1];
   
   bound[0].cElements = nItems;

   SAFEARRAY         * pArray = SafeArrayCreate(VT_BSTR,1,bound);
   
   for ( long i = 0 ; i < nItems ; i++ )
   {
      ndx[0] = i;
      SafeArrayPutElement(pArray,ndx,SysAllocString(columns[i]));
   }
   return pArray;
}

HRESULT CPruneGraftNode::EnumerateChildren(IConsole * spConsole)
{
   HRESULT                   hr = S_OK;
   WCHAR                     path[MAX_PATH];
   INetObjEnumeratorPtr      pEnum;
   IEnumVARIANT            * pValues = NULL;
   
   hr = pEnum.CreateInstance(CLSID_NetObjEnumerator);

   if ( SUCCEEDED(hr) )
   {
      if ( m_LDAPPath.length() )
      {
         swprintf(path,L"LDAP://%ls/%ls",(WCHAR*)m_Domain,(WCHAR*)m_LDAPPath);
      }
      else
      {
         safecopy(path,(WCHAR*)m_LDAPPath);
      }
      hr = pEnum->raw_SetQuery(path,m_Domain,L"(objectClass=*)",1,FALSE);
   }
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_SetColumns(GetAvailableColumns(m_objectClass));
   }
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_Execute(&pValues);
   }
   if ( SUCCEEDED(hr) )
   {
      hr = LoadChildren(pValues);
      pValues->Release();
   }

   return hr;
}

HRESULT CPruneGraftNode::LoadChildren(IEnumVARIANT * pEnumerator)
{
   HRESULT                   hr = 0;
   VARIANT                   var;
   long                      count = 0;
   ULONG                     nReturned = 0;
   CPruneGraftNode         * pNode = NULL;
   VariantInit(&var);

   while (  hr != S_FALSE )
   {
      hr = pEnumerator->Next(1,&var,&nReturned);
   
      // break if there was an error, or Next returned S_FALSE
      if ( hr != S_OK )
         break;
      // see if this is an array ( it should be!)
      if ( var.vt == ( VT_ARRAY | VT_VARIANT ) )
      {
         VARIANT              * pData;
         SAFEARRAY            * pArray;

         pArray = var.parray;
         
         pNode = new CPruneGraftNode;

         SafeArrayGetUBound(pArray,1,&count);
         SafeArrayAccessData(pArray,(void**)&pData);
         // make sure we at least have an LDAP path and an objectClass
         if ( count )
         {
            // get the object class and distinguishedName
            pNode->Init(m_Domain,pData[1].bstrVal,pData[2].bstrVal,pData[0].bstrVal);

            m_ChildArray.Add(pNode);
            for ( long i = 0 ; i <= count ; i++ )
            {
               // convert each value to a string, and store it in the node
               if ( SUCCEEDED(VariantChangeType(&pData[i],&pData[i],0,VT_BSTR)) )
               {
                 pNode->AddColumnValue(i,pData[i].bstrVal);
               }
            }
         }
         else
         {
            delete pNode;
         }
         
      }  
   }
   return hr;
}

HRESULT CPruneGraftNode::OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData)
{
   HRESULT hr=S_OK;

   if (bShow)       
   {  // show
      for ( int i = 0 ; i < DIM(gColumnHeaders) ; i++ )
      {
         spHeader->InsertColumn(i, gColumnHeaders[i], LVCFMT_LEFT, m_iColumnWidth[i]);
      }
      {
         CString  cstr;
         CComBSTR text;

         cstr.Format(_T("%d subitem(s)"), m_ChildArray.GetSize() );
         text = (LPCTSTR)cstr;
         spResultData->SetDescBarText( BSTR(text) ); 
      }
   }
   else
   {  // hide
      // save the column widths
      for ( int i = 0 ; i < DIM(gColumnHeaders) ; i++ )
      {
         spHeader->GetColumnWidth(i, m_iColumnWidth + i);
      }
   }
   hr = S_OK;

   return hr;
}
 

LPOLESTR CPruneGraftNode::GetResultPaneColInfo(int nCol)
{
   CString                 value;
   int                     ndx = nCol;
   int                   * mapping = NULL;

   if ( m_objectClass.length() && UStrICmp(m_objectClass,L"domain") )
   {
      
      if ( ! UStrICmp(m_objectClass,L"user") )
      {
         mapping = gUserMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"group") )
      {
         mapping = gGroupMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"organizationalUnit") )
      {
         mapping = gOuMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"domain") )
      {
         mapping = gDomainMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"container") )
      {
         mapping = gContainerMapping;
      }
      else 
      {
         mapping = gContainerMapping;
      }
      if ( mapping ) 
         ndx = mapping[nCol];

      if ( ndx <= m_Data.GetUpperBound() )
      {
         value = m_Data.GetAt(ndx);
         return value.AllocSysString();
      }
      else
         return OLESTR("Override GetResultPaneColInfo");
   }
   else
   {
      return CNetNode<CPruneGraftNode>::GetResultPaneColInfo(nCol);
   }
   return NULL;
}


void CPruneGraftNode::AddColumnValue(int col,WCHAR const * value) 
{ 
   m_Data.SetAtGrow(col,value);
   
   // see if we need to update the display name
   // get the pointer for the columns
   int * mapping = NULL;

   if ( ! UStrICmp(m_objectClass,L"user") )
   {
      mapping = gUserMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"group") )
   {
      mapping = gGroupMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"organizationalUnit") )
   {
      mapping = gOuMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"domain") )
   {
      mapping = gDomainMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"container") )
   {
      mapping = gContainerMapping;
   }
   else 
   {
      mapping = gContainerMapping;
   }
   if ( mapping && col == mapping[0] )  // display name
   {
      m_bstrDisplayName = value;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DomMigSI.rc
//
#define ID_DIALOG_FONTSIZE              8
#define IDS_PROJNAME                    100
#define IDS_DOMMIGRATOR_DESC            104
#define IDS_DOMMIGRATOR_PROVIDER        105
#define IDS_DOMMIGRATOR_VERSION         106
#define IDR_DOMMIGRATOR                 107
#define IDS_WizardAlreadyRunning        107
#define IDS_Title                       108
#define IDS_HELPFILE                    109
#define IDS_FailedActions               110
#define IDS_FAILED                      111
#define IDS_NAME                        112
#define IDS_TYPE                        113
#define IDS_DESC                        114
#define IDS_HelpFileIntroTopic          115
#define IDS_NoDatabase                  116
#define IDS_ERR_RUN_WIZARD              117
#define IDS_ERR_CHECK_FAILED_ACTIONS    118
#define IDS_NOSRCSIDCLM_TITLE           119
#define IDR_MULTISEL_MENU               120
#define IDS_NOSRCSIDCLM_MSG             120
#define IDS_ERR_NOSRCSIDCLM_MSG         120
#define IDS_QUERYCLM_TITLE              121
#define IDS_ERR_QUERYCLM_MSG            122
#define IDR_NET_MENU                    201
#define IDC_DOMAIN                      201
#define IDR_ROOT_MENU                   202
#define IDR_REPORTS                     203
#define IDR_PRUNE_GRAFT_MENU            204
#define IDD_DOMAIN                      206
#define IDB_TOOL_32                     213
#define IDB_TOOL_16                     214
#define IDS_ERR_LOCALADMINCHECK_MSG    215
#define IDS_ERR_UPDATEREGISTRY_MSG      216

// defined for localizing rept.htm
#define IDS_HEADING_REPORT_TOP      217
#define IDS_P_REPORT_ABOUT              218
#define IDS_P_REPORT_NOTE                 219
#define IDS_P_REPORT_NONE                  220
#define IDS_HEADING_REPORT_MIGRATED_USERSANDGROUPS      221
#define IDS_P_REPORT_MIGRATED_USERSANDGROUPS        222
#define IDS_HEADING_REPORT_MIGRATED_COMPUTERS       223
#define IDS_P_REPORT_MIGRATED_COMPUTERS                     224
#define IDS_HEADING_REPORT_EXPIRED_COMPUTERS            225
#define IDS_P_REPORT_EXPIRED_COMPUTERS                          226
#define IDS_HEADING_REPORT_IMPACT_ANALYSIS                  227
#define IDS_P_REPORT_IMPACT_ANALYSIS                                228
#define IDS_HEADING_REPORT_NAME_CONFLICTS                   229
#define IDS_P_REPORT_NAME_CONFLICTS                             230

#define ID_TOP_MIGRATEUSERSANDGROUPS    32768
#define ID_TOP_MIGRATECOMPUTERS         32769
#define ID_TASK_UNDO                    32770
#define ID_TASK_REDO                    32771
#define ID_TOP_TRANSLATESECURITY        32774
#define ID_TOP_REPORTING                32775
#define ID_TASK_MIGRATEDACCOUNTSREPORT  32776
#define ID_TOP_MOVE                     32777
#define ID_TASK_MIGRATEDCOMPUTERSREPORT 32777
#define ID_TASK_EXPIREDCOMPUTERSREPORT  32778
#define ID_TASK_IMPORTDATA              32779
#define ID_VIEW_VERSION                 32780
#define ID_TOP_IMPORTDATA               32783
#define ID_TOP_GENERATE_REPORTS         32783
#define ID_TOP_ADDDOMAIN                32784
#define ID_TOP_REPORT1                  32785
#define ID_TOP_REPORT2                  32786
#define ID_TOP_REPORT3                  32787
#define ID_TOP_REPORT4                  32788
#define ID_TOP_MIGRATEGROUPS            32789
#define ID_TOP_MIGRATESERVICEACCOUNTS   32790
#define ID_TOP_MIGRATEEXCHANGESERVER    32791
#define ID_TOP_UNDO                     32792
#define ID_TOP_RETRY                    32794
#define ID_TOP_MIGRATETRUSTS            32795
#define ID_TOP_MIGRATEEXCHANGEDIRECTORY 32796
#define ID_TOP_GROUPMAPPING             32797

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        213
#define _APS_NEXT_COMMAND_VALUE         32798
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\rootnode.cpp ===
// This node class represents the root node of our snap-in
#include "stdafx.h"
#include "MyNodes.h"
#include "DomSel.h"
#include "TSync.hpp"
#include "ResStr.h"
#include "HrMsg.h"
#include "RegistryHelper.h"
#include "IsAdmin.hpp"

//#import "\bin\DBManager.tlb" no_namespace,named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace,named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "UpdateMOT.tlb" no_namespace,named_guids

// {C8C24622-3FA1-11d3-8AED-00A0C9AFE114}
static const GUID CRootGUID_NODETYPE = 
{ 0xc8c24622, 0x3fa1, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };

const GUID*  CRootNode::m_NODETYPE = &CRootGUID_NODETYPE;
const OLECHAR* CRootNode::m_SZNODETYPE = OLESTR("C8C24622-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CRootNode::m_SZDISPLAY_NAME = NULL;
const CLSID* CRootNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;
static LONG SnapInCount = -1;

extern "C" int runWizard(int whichWizard, HWND hParentWindow);
#define  WIZARD_SEMNAME  L"McsDomMigrAgent.990000.Sem"

CSnapInToolbarInfo   m_toolBar;


namespace
{




//---------------------------------------------------------------------------
// DisplayError Helper Function
//---------------------------------------------------------------------------

void DisplayError(HRESULT hr, UINT uFormatId)
{
   _com_error ce = GetError(hr);

   if (FAILED(ce.Error()))
   {
      CString strTitle;
      strTitle.LoadString(IDS_Title);

      CString strMessage;
      strMessage.Format(uFormatId);

      _bstr_t bstrSource = ce.Source();

      if (bstrSource.length() > 0)
      {
         strMessage += _T(" : ");
         strMessage += bstrSource;
      }

      _bstr_t bstrDescription = ce.Description();

      if (bstrDescription.length() > 0)
      {
         strMessage += _T(" : ");
         strMessage += bstrDescription;
      }
      else
      {
         CString strError;
         strError.Format(_T(" : %s (%08lX)"), ce.ErrorMessage(), ce.Error());

         strMessage += strError;
      }

      MessageBox(NULL, strMessage, strTitle, MB_OK|MB_ICONERROR);
   }
}


}


CRootNode::CRootNode() :
   m_hwndMainWindow(0)
{
   // Initialize the array of children
   CReportingNode * pNode = new CReportingNode;

   if (pNode)
   {
      pNode->UpdateChildren(NULL);
      m_ChildArray.Add(pNode);
   }

   HRESULT hr;
   CString title, sFormat, msg;
   
   DWORD rc = IsAdminLocal();
   if (rc != ERROR_SUCCESS)
   {
      hr = HRESULT_FROM_WIN32(rc);
      title.LoadString(IDS_Title);
      sFormat.LoadString(IDS_ERR_LOCALADMINCHECK_MSG);
      msg.Format(sFormat, rc);

      MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
      _com_issue_error(hr);
   }

   rc = MoveRegistry();
   if (rc != ERROR_SUCCESS)
   {
      hr = HRESULT_FROM_WIN32(rc);
      title.LoadString(IDS_Title);
      sFormat.LoadString(IDS_ERR_UPDATEREGISTRY_MSG);
      msg.Format(sFormat, rc);

      MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
      _com_issue_error(hr);
   }
   
   UpdateMigratedObjectsTable();
   UpdateAccountReferenceTable();
   CheckForFailedActions(FALSE);
   //m_ChildArray.Add(new CPruneGraftNode);
   if (InterlockedIncrement(&SnapInCount) == 0)
      m_SZDISPLAY_NAME = GET_BSTR(IDS_ActiveDirectoryMigrationTool).copy();
}

CRootNode::~CRootNode()
{
   if ((m_SZDISPLAY_NAME) && (InterlockedDecrement(&SnapInCount) < 0))
   {
      SysFreeString(const_cast<OLECHAR*>(m_SZDISPLAY_NAME));
      m_SZDISPLAY_NAME = NULL;
   }
}

class CWizardRunner
{
public:
   int RunTheWizard(int wizardNdx, HWND hwndParent)
   {
      int                    result = 0;
      TSemaphoreNamed        cSem;         // named semaphore
      BOOL                   bExisted = FALSE;
      CString                message;
      CString                title;
     
      DWORD                  rcOs = cSem.Create( WIZARD_SEMNAME, 0, 1, &bExisted );
      
      if ( rcOs || bExisted )
      {
         message.LoadString(IDS_WizardAlreadyRunning);
         title.LoadString(IDS_Title);
         MessageBox(NULL,message,title,MB_OK | MB_ICONERROR);
         
      }
      else
      {
         result = runWizard(wizardNdx, hwndParent);

         // if user cancels wizard or an error occurs

         if (result == 0)
         {
            // if able to retrieve error information
            // then an error occurred, notify user

            // Note: It is currently possible for errors
            // to occur without the error information being set

            DisplayError(S_OK, IDS_ERR_RUN_WIZARD);
         }
      }

      return result;
   }

};


void CRootNode::CheckUndoable()
{
   IIManageDBPtr             pDB;
   HRESULT                   hr;
   _bstr_t                   sWizard = L"Options.Wizard";
   long                      lAction = -2;
   VARIANT                   var;
   _variant_t                vnt;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )  
      hr = pDB->raw_GetCurrentActionID(&lAction);
   if ( SUCCEEDED(hr) )
   {
      VariantInit(&var);
      hr = pDB->raw_GetActionHistoryKey(lAction, sWizard, &var);
      vnt.Attach(var);
   }
   if ( SUCCEEDED(hr) && (V_VT(&vnt) == VT_BSTR) )
   {
      sWizard = vnt;
      if (sWizard.length() > 0)
      {
         IsUndoable = ( !_wcsicmp(sWizard, L"user") || !_wcsicmp(sWizard, L"group") || !_wcsicmp(sWizard, L"computer") );
         if ( IsUndoable )
         {
            sWizard = GET_BSTR(DCTVS_Options_NoChange);
            VariantInit(&var);
            hr = pDB->raw_GetActionHistoryKey(lAction, sWizard, &var);
            vnt.Attach(var);
            if ( SUCCEEDED(hr) && (V_VT(&vnt) == VT_BSTR) )
            {
               sWizard = vnt;
               if (!sWizard || !UStrICmp(sWizard,GET_STRING(IDS_YES)) )
               {
                  IsUndoable = false; // can't undo a no-change mode operation
               }
            }
         }
      }
      else
      {
         IsUndoable = false;
      }
   }
   else
   {
      IsUndoable = false;
   }
   if ( hr == 0x800a0bb9 )
   {
      // the database is missing or corrupt
      CString           msg;
      CString           title;
      
      msg.LoadString(IDS_NoDatabase);
      title.LoadString(IDS_Title);
      MessageBox(NULL,msg,title,MB_ICONERROR | MB_OK);
      throw new _com_error(hr);
   }
}

void CRootNode::CheckForST()
{
   IIManageDBPtr              pDB;

   HRESULT                   hr = S_OK;
   long                      cnt = 0;

   CanUseST = false;
   if ( SUCCEEDED(hr) )
   {
      hr = pDB.CreateInstance(CLSID_IManageDB);
   }
   if ( SUCCEEDED(hr) )  
   {
      hr = pDB->raw_AreThereAnyMigratedObjects(&cnt);
   }
   if ( SUCCEEDED(hr) )
   {
      if ( cnt > 0 )
      {
         // there are some migrated objects
         CanUseST = true;
      }
   }
}

void CRootNode::CheckForFailedActions(BOOL bPrompt)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT                   hr = S_OK;
   IIManageDBPtr             pDB;
   IVarSetPtr                pVarSet(CLSID_VarSet);
   IUnknown                * pUnk = NULL;
   long                      lAction = -2;

   CanRetry = false;
   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSet.QueryInterface(IID_IUnknown,&pUnk);
      if ( SUCCEEDED(hr) )
      {
         // we will also check the last action type and set the IsUndoable flag.
         CheckUndoable();
         CheckForST();
         hr = pDB->raw_GetFailedDistributedActions(-1,&pUnk);
         pUnk->Release();
         if ( SUCCEEDED(hr) )
         {
            _bstr_t          numItemsText = pVarSet->get(L"DA");
            long             nItems = _wtoi(numItemsText);

            if ( nItems )
            {
               CString        str;
               CString        title;

               title.LoadString(IDS_Title);
               str.FormatMessage(IDS_FailedActions,nItems);
               
               CanRetry = true;
               
               if ( bPrompt && IDYES == MessageBox(NULL,str,title,MB_YESNO) )
               {
                  bool bHandled;

                  OnRetry(bHandled,NULL);
               }
            }
         }
      }
   }
   if (FAILED(hr))
   {
      DisplayError(hr, IDS_ERR_CHECK_FAILED_ACTIONS);

      _com_issue_error(hr);
   }
}


HRESULT CRootNode::OnMigrateUsers(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(1, m_hwndMainWindow);

   if (result)
   {
      CheckUndoable();
      CheckForST();
   }
   return hr;  
}

HRESULT CRootNode::OnMigrateGroups(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(2, m_hwndMainWindow);
   

   if (result)
   {
      CheckUndoable();
      CheckForST();
   }
   return hr;
}

HRESULT CRootNode::OnMigrateComputers(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;

   int                       result = r.RunTheWizard(3, m_hwndMainWindow);

   if (result)
   {
      CheckUndoable();
      CheckForFailedActions(FALSE);
   }
   return hr;
}

HRESULT CRootNode::OnTranslateSecurity(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(4, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnMigrateExchangeServer(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(11, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   return hr;
}
HRESULT CRootNode::OnMigrateExchangeDirectory(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(7, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   return hr;
}

HRESULT CRootNode::OnMigrateServiceAccounts(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(5, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}
HRESULT CRootNode::OnReporting(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(8, m_hwndMainWindow);
   IConsole                * pConsole = NULL;

   // Reload the Child-Nodes for the reporting node
   CReportingNode          * pRept = (CReportingNode*)m_ChildArray[0];
   
   if ( pRept )
   {
      hr = GetConsoleFromCSnapInObjectRootBase(pObj,&pConsole);
      if ( SUCCEEDED(hr) )
      {   
         pRept->UpdateChildren(pConsole);
      }
   }
   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnUndo(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(6, m_hwndMainWindow);

   if (result)
   {
      IsUndoable = false;
      CheckForST();
   }
   return hr;
}

HRESULT CRootNode::OnRetry(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(9, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnMigrateTrusts(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(10, m_hwndMainWindow);
   
   if (result)
      IsUndoable = false;
   return hr;
}

HRESULT CRootNode::OnGroupMapping(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(12, m_hwndMainWindow);
   
   if (result)
      IsUndoable = false;
   return hr;
}


void CRootNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   switch (id)
   {
   case ID_TOP_UNDO:
      if ( !IsUndoable )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   
   case ID_TOP_MIGRATEEXCHANGEDIRECTORY:  
      if ( ! CanUseST )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   case ID_TOP_TRANSLATESECURITY:
         //always allow the Security Translation wizards now 
	     //that we can reACL using a sid mapping file
      *flags = MF_ENABLED;
      break;
   case ID_TOP_RETRY:
      if ( ! CanRetry )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   };
}

void CRootNode::UpdateMigratedObjectsTable()
{
   ISrcSidUpdatePtr			 pSrcUpdate(CLSID_SrcSidUpdate);
   HRESULT					 hr;
   VARIANT_BOOL              bvar;
   VARIANT_BOOL              bHide = VARIANT_FALSE;
   CString					 title;
   CString                   sFormat;
   CString					 msg;
   
      //see if the new Source domain Sid column is in this migrated object's table
   hr = pSrcUpdate->raw_QueryForSrcSidColumn(&bvar);
   if ( FAILED(hr) )
   {
	  _bstr_t sDescription = HResultToText(hr);
      title.LoadString(IDS_QUERYCLM_TITLE);
      sFormat.LoadString(IDS_ERR_QUERYCLM_MSG);
      msg.Format(sFormat, (WCHAR*)sDescription);

      MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
      _com_issue_error(hr);
	  return;
   }
      //if not then run the code to add it
   if ( bvar == VARIANT_FALSE )
   {
	     //add and populate the new source Sid column
      hr = pSrcUpdate->raw_CreateSrcSidColumn(bHide, &bvar);
      if ( FAILED(hr) )
	  {
	     _bstr_t sDescription = HResultToText(hr);
         title.LoadString(IDS_NOSRCSIDCLM_TITLE);
         sFormat.LoadString(IDS_ERR_NOSRCSIDCLM_MSG);
         msg.Format(sFormat, (WCHAR*)sDescription);

         MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
         _com_issue_error(hr);
	  }
      if ( bvar == VARIANT_FALSE )
	  {
//         title.LoadString(IDS_NOSRCSIDCLM_TITLE);
//         msg.LoadString(IDS_ERR_NOSRCSIDCLM_MSG);

//         MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
         _com_issue_error(hr);
	  }
   }
}

void CRootNode::UpdateAccountReferenceTable()
{
   IIManageDBPtr   pDB(CLSID_IManageDB);
   VARIANT_BOOL	   bFound = VARIANT_FALSE;     
   
      //see if the new AccountSid column has already been added to
      //the AccountRefs table
   bFound = pDB->SidColumnInARTable();

      //if not there, create it
   if (!bFound)
      pDB->CreateSidColumnInAR();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\dommigsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\detdlg.h ===
#if !defined(AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AgentDetail.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAgentDetail dialog
#include "resource.h"
#include "ServList.hpp"
#include "Globals.h"

class CAgentDetailDlg : public CDialog
{
// Construction
public:
	CAgentDetailDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAgentDetailDlg)
	enum { IDD = IDD_DETAILS };
	CButton	m_StopAgentButton;
	CButton	m_RefreshButton;
	CButton	m_ViewLogButton;
	CButton	m_PlugInButton;
	CButton	m_OKButton;
	CStatic	m_UnchangedLabelStatic;
	CStatic	m_SharesStatic;
	CStatic	m_FilesStatic;
	CStatic	m_ExaminedStatic;
	CStatic	m_DirStatic;
	CStatic	m_ChangedStatic;
	CString	m_Current;
	CString	m_Stats;
	CString	m_Status;
   CString  m_FilesChanged;
   CString  m_FilesExamined;
   CString  m_FilesUnchanged;
   CString  m_DirectoriesChanged;
   CString  m_DirectoriesExamined;
   CString  m_DirectoriesUnchanged;
   CString  m_SharesChanged;
   CString  m_SharesExamined;
   CString  m_SharesUnchanged;
	CString	m_DirectoryLabelText;
	CString	m_FilesLabelText;
	CString	m_Operation;
	CString	m_SharesLabelText;
	CString	m_ChangedLabel;
	CString	m_ExaminedLabel;
	CString	m_UnchangedLabel;
	CString	m_RefreshRate;
	//}}AFX_DATA
   CString  m_ServerName;
   CString  m_LogFile;
   BOOL     m_LogFileIsValid;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAgentDetailDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

   public:
      void SetNode(TServerNode * p) { m_pNode = p; }
      void SetJobID(WCHAR const * job) { m_JobGuid = job; }
      BOOL IsAgentAlive() { return m_AgentAlive; }
      BOOL IsStatusUnknown() { return m_StatusUnknown; }
      void SetStats(DetailStats * pStats) { m_pStats = pStats; }
      void SetPlugInText(CString pText) { m_PlugInText = pText; }
      void SetFormat(int format) { m_format = format;    }
      void SetRefreshInterval(int  interval) { m_RefreshRate.Format(L"%ld",interval); }
      void SetLogFile(CString file) { m_LogFile = file; }
      void SetLogFileValid(BOOL bValid) { m_LogFileIsValid = bValid; }
      void SetGatheringInfo(BOOL bValue) { m_bGatheringInfo = bValue;}
      void SetAutoCloseHide(int nValue)
      {
         switch (nValue)
         {
            case 2:
               m_bAutoHide = TRUE;
               m_bAutoClose = TRUE;
               break;
            case 1:
               m_bAutoHide = FALSE;
               m_bAutoClose = TRUE;
               break;
            default:
               m_bAutoHide = FALSE;
               m_bAutoClose = FALSE;
               break;
         }
      }
// Implementation
protected:
   IDCTAgentPtr        m_pAgent;
   TServerNode       * m_pNode;
	HANDLE              m_hBinding;
   _bstr_t             m_JobGuid;
   BOOL                m_bCoInitialized;
   int                 m_format;
   BOOL                m_AgentAlive;
   DetailStats       * m_pStats;
   CString             m_PlugInText;
   BOOL                m_StatusUnknown;
   BOOL                m_bGatheringInfo;
   BOOL                m_bAutoHide;
   BOOL                m_bAutoClose;
   BOOL				   m_bAlwaysEnableClose;
   // Generated message map functions
	//{{AFX_MSG(CAgentDetailDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefresh();
	virtual void OnOK();
	afx_msg void OnChangeEdit2();
	afx_msg void OnStopAgent();
	afx_msg void OnViewLog();
	afx_msg void OnPlugInResults();
	afx_msg void OnClose();
	afx_msg void OnNcPaint();
	//}}AFX_MSG
	
   LRESULT DoRefresh(UINT nID, long x);
   
   void SetupAcctReplFormat();
   void SetupFSTFormat();
   void SetupESTFormat();
   void SetupOtherFormat();
  DECLARE_MESSAGE_MAP()
};

DWORD DoRpcQuery(HANDLE hBinding,LPUNKNOWN * ppUnk);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\detdlg.cpp ===
/*---------------------------------------------------------------------------
  File: AgentDetailDlg.cpp 

  Comments: This dialog shows the status of the agent on a single machine:
  It can work in one of 3 ways:
  1)  COM connection to the running agent on the local machine
  2)  DCOM connection to a running agent on another machine (this is done 
      with help from the agent service)
  3)  For a remote agent that has finished, it can show the final stats,
      as recorded in the agent's result file.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// AgentDetail.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DetDlg.h"

#include "Common.hpp"
#include "AgRpcUtl.h"
#include "Monitor.h"
#include "ResStr.h"

//#include "..\AgtSvc\AgSvc.h"
#include "AgSvc.h"
#include "AgSvc_c.c"

//#import "\bin\McsEADCTAgent.tlb" no_namespace , named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace

//#import "Engine.tlb" no_namespace, named_guids //already #imported via DetDlg.h
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


HWND        gSubWnd = NULL;
BOOL        bDetailDone = FALSE;
int         detailInterval = 0;
extern BOOL gbCancelled;

TCHAR* GetSystemDirectoryHelper()
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;    

    if(iSize == 0)
    {        
        return NULL;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\"))];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        return NULL;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        if(buffer)
        {
            delete [] buffer;
            return NULL;
        }
    }   

    _tcscat(buffer, __TEXT("\\"));
    
    return buffer;
}



/////////////////////////////////////////////////////////////////////////////
// CAgentDetailDlg dialog


CAgentDetailDlg::CAgentDetailDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAgentDetailDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAgentDetailDlg)
	m_Current = _T("");
	m_Status = _T("");
 	m_FilesChanged = _T("0");
	m_FilesExamined = _T("0");
	m_FilesUnchanged = _T("0");
   m_DirectoriesChanged = _T("0");
	m_DirectoriesExamined = _T("0");
	m_DirectoriesUnchanged = _T("0");
   m_SharesChanged = _T("0");
	m_SharesExamined = _T("0");
	m_SharesUnchanged = _T("0");
	m_Operation = _T("");
	m_RefreshRate = _T("5");
	//}}AFX_DATA_INIT
   m_DirectoryLabelText.LoadString(IDS_DirectoriesLabel);
	m_FilesLabelText.LoadString(IDS_FilesLabel);
	m_SharesLabelText.LoadString(IDS_SharesLabel);
	m_ChangedLabel.LoadString(IDS_ChangedLabel);
	m_ExaminedLabel.LoadString(IDS_ExaminedLabel);
	m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
	m_pNode = NULL;
   detailInterval = _wtoi(m_RefreshRate);
   m_bCoInitialized = FALSE;
   m_format = 0;
   m_AgentAlive = FALSE;
   m_StatusUnknown = FALSE;
   m_hBinding = 0;
   m_pStats = NULL;
   m_bGatheringInfo = FALSE;
   m_bAutoHide = FALSE;
   m_bAutoClose = FALSE;
   m_bAlwaysEnableClose = TRUE;
   m_LogFileIsValid = TRUE;
}

ULONG __stdcall RefreshThread(void * arg)
{
   do { 
      PostMessage(gSubWnd,DCT_DETAIL_REFRESH,NULL,NULL);
      Sleep(detailInterval*1000);
   }
   while (! bDetailDone);
   return 0;
}
void CAgentDetailDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAgentDetailDlg)
	DDX_Control(pDX, IDC_STOPAGENT, m_StopAgentButton);
	DDX_Control(pDX, IDC_BTNREFRESH, m_RefreshButton);
	DDX_Control(pDX, IDC_VIEW_LOG, m_ViewLogButton);
	DDX_Control(pDX, IDC_PLUG_IN_RESULTS, m_PlugInButton);
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_UnchangedLabel, m_UnchangedLabelStatic);
	DDX_Control(pDX, IDC_SharesLabel, m_SharesStatic);
	DDX_Control(pDX, IDC_FilesLabel, m_FilesStatic);
	DDX_Control(pDX, IDC_ExaminedLabel, m_ExaminedStatic);
	DDX_Control(pDX, IDC_DirectoriesLabel, m_DirStatic);
	DDX_Control(pDX, IDC_ChangedLabel, m_ChangedStatic);
	DDX_Text(pDX, IDC_CURRENT, m_Current);
	DDX_Text(pDX, IDC_STATUS, m_Status);
 	DDX_Text(pDX, IDC_FilesChanged, m_FilesChanged);
	DDX_Text(pDX, IDC_FilesExamined, m_FilesExamined);
	DDX_Text(pDX, IDC_FilesU, m_FilesUnchanged);
	DDX_Text(pDX, IDC_DirsChanged, m_DirectoriesChanged);
	DDX_Text(pDX, IDC_DirsExamined, m_DirectoriesExamined);
   DDX_Text(pDX, IDC_DirsU, m_DirectoriesUnchanged);
   DDX_Text(pDX, IDC_SharesChanged, m_SharesChanged);
	DDX_Text(pDX, IDC_SharesExamined, m_SharesExamined);
	DDX_Text(pDX, IDC_SharesU, m_SharesUnchanged);
	DDX_Text(pDX, IDC_DirectoriesLabel, m_DirectoryLabelText);
	DDX_Text(pDX, IDC_FilesLabel, m_FilesLabelText);
	DDX_Text(pDX, IDC_OPERATION, m_Operation);
	DDX_Text(pDX, IDC_SharesLabel, m_SharesLabelText);
	DDX_Text(pDX, IDC_ChangedLabel, m_ChangedLabel);
	DDX_Text(pDX, IDC_ExaminedLabel, m_ExaminedLabel);
	DDX_Text(pDX, IDC_UnchangedLabel, m_UnchangedLabel);
	DDX_Text(pDX, IDC_EDIT2, m_RefreshRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAgentDetailDlg, CDialog)
	//{{AFX_MSG_MAP(CAgentDetailDlg)
	ON_WM_NCPAINT()
	ON_BN_CLICKED(IDC_BTNREFRESH, OnRefresh)
	ON_EN_CHANGE(IDC_EDIT2, OnChangeEdit2)
	ON_BN_CLICKED(IDC_STOPAGENT, OnStopAgent)
	ON_BN_CLICKED(IDC_VIEW_LOG, OnViewLog)
	ON_BN_CLICKED(IDC_PLUG_IN_RESULTS, OnPlugInResults)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
   ON_MESSAGE(DCT_DETAIL_REFRESH, DoRefresh)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAgentDetailDlg message handlers

BOOL CAgentDetailDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
        m_bCoInitialized = TRUE;
	
    CString title;
    if ( m_JobGuid.length() )
    {
        // connect to local agent
        title.LoadString(IDS_PROGRESS_TITLE);
    }
    else
    {
        // connect to agent service on remote machine

        if ( ! m_pNode )
        {
            // if not auto closing display message box

            if (!m_bAutoClose)
            {
                CString message;
                message.LoadString(IDS_ServerNotFound);
                MessageBox(message);
            }
            OnOK();
        }
        m_ServerName = m_pNode->GetServer();
        title.FormatMessage(IDS_ServerAgentProgressTitle,m_ServerName);
    }
   
    SetWindowText(title);
    UpdateData(FALSE);

    //If not AR operation, set the flag to enable the close button
    if (m_format != 1)
        m_bAlwaysEnableClose = TRUE;
    else
        m_bAlwaysEnableClose = FALSE;

    switch (m_format)
    {
    // set the format to -1 to force a change
    case -1: m_format = -2; SetupOtherFormat(); break;
    case 0: m_format = -2; SetupFSTFormat();break;
    case 1: m_format = -2; SetupAcctReplFormat(); break;
    case 2: m_format = -2; SetupESTFormat(); break;
    };

    gSubWnd = m_hWnd;
    if ( m_pStats && (m_format>0) )
    {
        bDetailDone = TRUE;
        GetDlgItem(IDC_BTNREFRESH)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_REFRESH_LABEL)->EnableWindow(FALSE);
        GetDlgItem(IDC_STOPAGENT)->EnableWindow(FALSE);
        m_OKButton.EnableWindow(TRUE);
        // the agent has finished, show files, directories, and shares
        m_FilesExamined.Format(L"%ld",m_pStats->filesExamined);
        m_FilesChanged.Format(L"%ld",m_pStats->filesChanged);
        m_FilesUnchanged.Format(L"%ld",m_pStats->filesUnchanged);

        m_DirectoriesExamined.Format(L"%ld",m_pStats->directoriesExamined);
        m_DirectoriesChanged.Format(L"%ld",m_pStats->directoriesChanged);
        m_DirectoriesUnchanged.Format(L"%ld",m_pStats->directoriesUnchanged);

        m_SharesExamined.Format(L"%ld",m_pStats->sharesExamined);
        m_SharesChanged.Format(L"%ld",m_pStats->sharesChanged);
        m_SharesUnchanged.Format(L"%ld",m_pStats->sharesUnchanged);

        m_Status.LoadString(IDS_StatusCompleted);

        if ( m_PlugInText.GetLength() )
        {
            //Permanently hide the plug-in button, since our plug-ins
            // don't show any useful text
            // m_PlugInButton.ShowWindow(SW_SHOW);
        }
        UpdateData(FALSE);

        // if auto closing dialog

        if (m_bAutoClose)
        {
            OnOK();
        }
    }
    else
    {

        bDetailDone = FALSE;
        m_hBinding = NULL;

        DWORD                     threadID;
        HANDLE                    h = CreateThread(NULL,0,&RefreshThread,NULL,0,&threadID);

        CloseHandle(h);

        //hide the close button until the agent is done or stopped unless the flag is set
        //due to running this dialog for account replication
        if (m_bAlwaysEnableClose)
            m_OKButton.EnableWindow(TRUE);
        else
            m_OKButton.EnableWindow(FALSE);
    }
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD 
   DoRpcQuery(
      HANDLE                 hBinding,    // in - handle to RPC binding
      LPUNKNOWN            * ppUnk        // out- pointer to remote agent COM object
   )
{
   DWORD                     rc = 0;
   
   RpcTryExcept
   {
      rc = EaxcQueryInterface(hBinding,ppUnk);
   }
   RpcExcept(1)
   {
      rc = RpcExceptionCode();
   }
   RpcEndExcept
   
   if ( rc )
   {
      (*ppUnk ) = NULL;
   }
   return rc;
}

void CAgentDetailDlg::SetupAcctReplFormat()
{
   // Changes the labels to reflect pertinent information when copying accounts
   UpdateData(TRUE);
   if ( m_format != 1 )
   {
      m_ChangedLabel.LoadString(IDS_AccountCopiedLabel);
      m_UnchangedLabel.LoadString(IDS_AccountErrorsLabel);

      m_FilesLabelText.LoadString(IDS_AccountUsersLabel);
      m_DirectoryLabelText.LoadString(IDS_AccountGroupsLabel);
      m_SharesLabelText.LoadString(IDS_AccountComputersLabel);

      m_format = 1;
   }

   UpdateData(FALSE);
}

void CAgentDetailDlg::SetupFSTFormat()
{
   // Changes the labels to reflect pertinent information when translating security
   UpdateData(TRUE);
   if ( m_format != 0 )
   {
      if ( m_bGatheringInfo )
      {
         m_ChangedLabel.LoadString(IDS_Affected);
         m_UnchangedLabel.LoadString(IDS_Unaffected);
      }
      else
      {
         m_ChangedLabel.LoadString(IDS_ChangedLabel);
         m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
      }
      m_FilesLabelText.LoadString(IDS_FilesLabel);
      m_DirectoryLabelText.LoadString(IDS_DirectoriesLabel);
      m_SharesLabelText.LoadString(IDS_SharesLabel);
      m_format = 0;
   }
   UpdateData(FALSE);
}

void CAgentDetailDlg::SetupESTFormat()
{
   // Changes the labels to reflect pertinent information when translating exchange security
   UpdateData(TRUE);
   if ( m_format != 2 )
   {
      m_ChangedLabel.LoadString(IDS_ChangedLabel);
      m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
      m_FilesLabelText.LoadString(IDS_MailboxesLabel);
      m_DirectoryLabelText.Empty();
      m_SharesLabelText.Empty();

      m_format = 2;
   }
   UpdateData(FALSE);

}

void CAgentDetailDlg::SetupOtherFormat()
{
  // Changes the labels to reflect pertinent information when translating exchange security
   UpdateData(TRUE);
   if ( m_format != -1 )
   {
      m_ExaminedLabel.Empty();
      m_ChangedLabel.Empty();
      m_UnchangedLabel.Empty();
      m_FilesLabelText.Empty();
      m_DirectoryLabelText.Empty();
      m_SharesLabelText.Empty();

      m_FilesExamined.Empty();
      m_DirectoriesExamined.Empty();
      m_SharesExamined.Empty();
      m_FilesChanged.Empty();
      m_DirectoriesChanged.Empty();
      m_SharesChanged.Empty();
      m_FilesUnchanged.Empty();
      m_DirectoriesUnchanged.Empty();
      m_SharesUnchanged.Empty();

      m_format = -1;
   }
   UpdateData(FALSE);
}


void CAgentDetailDlg::OnRefresh() 
{
    DWORD                     rc = 0;
    HRESULT                   hr = S_OK;
    WCHAR                   * sBinding = NULL;
    IUnknown                * pUnk = NULL;
    IVarSetPtr                pVarSet;
    _bstr_t                   jobID;

    if (m_bCoInitialized)
    {

        try {
            if ( m_pNode )
            {
                jobID = m_pNode->GetJobID();
            }
            else
            {
                jobID = m_JobGuid; 
            }

            m_AgentAlive = FALSE;
            m_StatusUnknown = FALSE;

            UpdateData(TRUE);

            if ( m_pAgent == NULL )
            {
                if ( m_pNode )
                {

                    WCHAR server[MAX_PATH];
                    server[0] = L'\\';
                    server[1] = L'\\';
                    UStrCpy(server+2,m_pNode->GetServer());
                    rc = EaxBindCreate(server,&m_hBinding,&sBinding,TRUE);
                    if ( ! rc )
                    {
                        pUnk = NULL;
                        rc = DoRpcQuery(m_hBinding,&pUnk);
                        if ( (!rc) && pUnk )
                        {
                            try {
                                m_pAgent = pUnk;
                            }
                            catch(_com_error * e)
                            {
                                m_StatusUnknown = TRUE;

                                // if not auto closing display message box
                                if (!m_bAutoClose)
                                {
                                    MessageBox(e->Description());
                                }
                            }
                            catch(...)
                            {
                                pUnk = NULL;
                            }
                            if ( pUnk )
                                pUnk->Release();
                        }
                        else
                        {
                            if ( rc == RPC_S_SERVER_UNAVAILABLE )
                            {
                                m_Status.LoadString(IDS_AgentNotRunning);   
                            }
                            else if ( rc == E_NOTIMPL )
                            {
                                m_StatusUnknown = TRUE;
                                m_Status.LoadString(IDS_CantMonitorOnNt351);
                            }
                            else
                            {
                                m_StatusUnknown = TRUE;
                                m_Status.LoadString(IDS_CannotConnectToAgent);
                            }
                        }
                    }
                    else
                    {
                        m_StatusUnknown = TRUE;
                        m_Status.LoadString(IDS_RPCBindFailed);
                    }
                    if ( m_StatusUnknown || rc )
                    {
                        // if we couldn't connect to the agent, check to see if there is a result file 
                        // we can get our data from instead
                        BOOL bNoMoreRefresh = FALSE;
                        if (m_pNode->HasFailed() && !m_pNode->IsInstalled())
                        {
                           bNoMoreRefresh = TRUE;
                           m_Status.LoadString(IDS_Status_InstallFailed);
                           UpdateData(FALSE);
                        }
                        else if (m_pNode->IsInstalled() && m_pNode->HasFailed())
                        {
                           bNoMoreRefresh = TRUE;
                           m_Status.LoadString(IDS_Status_DidNotStart);
                           UpdateData(FALSE);
                        }
                        else if (m_pNode->IsFinished() && *m_pNode->GetJobFile() && m_pNode->IsResultPullingTried()
                            && m_pNode->HasResult())
                        {
                            DetailStats   detailStats;
                            WCHAR         directory[MAX_PATH];
                            WCHAR         filename[MAX_PATH];
                            CString       plugInText;

                            gData.GetResultDir(directory);

                            memset(&detailStats,0,(sizeof detailStats));

                            swprintf(filename,GET_STRING(IDS_AgentResultFileFmt),m_pNode->GetJobFile());
                            if ( ReadResults(m_pNode,directory,filename,&detailStats,plugInText,FALSE) )
                            {
                                SetStats(&detailStats);
                                SetPlugInText(plugInText);
                                SetLogFile(m_pNode->GetLogPath());
                                SetLogFileValid(m_pNode->GetLogPathValid());
                                bNoMoreRefresh = TRUE;
                                // the agent has finished, show files, directories, and shares
                                if (m_format != -1)
                                {
                                    m_FilesExamined.Format(L"%ld",m_pStats->filesExamined);
                                    m_FilesChanged.Format(L"%ld",m_pStats->filesChanged);
                                    m_FilesUnchanged.Format(L"%ld",m_pStats->filesUnchanged);

                                    m_DirectoriesExamined.Format(L"%ld",m_pStats->directoriesExamined);
                                    m_DirectoriesChanged.Format(L"%ld",m_pStats->directoriesChanged);
                                    m_DirectoriesUnchanged.Format(L"%ld",m_pStats->directoriesUnchanged);

                                    m_SharesExamined.Format(L"%ld",m_pStats->sharesExamined);
                                    m_SharesChanged.Format(L"%ld",m_pStats->sharesChanged);
                                    m_SharesUnchanged.Format(L"%ld",m_pStats->sharesUnchanged);
                                }

                                m_Status.LoadString(IDS_StatusCompleted);

                                if ( m_PlugInText.GetLength() )
                                {
                                    // Permanently hide the plug-in button, because our plug-ins don't 
                                    // show any useful text.
                                    // m_PlugInButton.ShowWindow(SW_SHOW);
                                }
                                UpdateData(FALSE);
                            }
                        }
                        else if (m_pNode->IsDoneMonitoring())  // we should let the main monitoring thread
                                                                // do the job
                        {
                            // if we have result, use the last logic
                            if (!m_pNode->HasResult())
                            {
                                bNoMoreRefresh = TRUE;

                                if (m_pNode->QueryFailed())
                                    m_Status.LoadString(IDS_Status_Unknown);
                                else
                                    m_Status = GET_WSTR(IDS_DCT_Status_Completed_With_Errors);
                                UpdateData(FALSE);
                            }
                        }

                        if (bNoMoreRefresh)
                        {
                            bDetailDone = TRUE;
                            GetDlgItem(IDC_BTNREFRESH)->EnableWindow(FALSE);
                            GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
                            GetDlgItem(IDC_REFRESH_LABEL)->EnableWindow(FALSE);
                            GetDlgItem(IDC_STOPAGENT)->EnableWindow(FALSE);
                        }
                           
                    }
                }
                else
                {
                    hr = m_pAgent.GetActiveObject(CLSID_DCTAgent);

                    if ( FAILED(hr) )
                    {
                        if ( hr == MK_E_UNAVAILABLE ) 
                        {
                            m_Status.LoadString(IDS_AgentNotRunning);
                        }
                        else
                        {
                            m_Status.FormatMessage(IDS_NoActiveAgent,hr);
                        }
                    }
                }
            }
            if ( m_pAgent != NULL )
            {
                hr = m_pAgent->raw_QueryJobStatus(jobID,&pUnk);
                if ( SUCCEEDED(hr) && pUnk )
                {
                    m_AgentAlive = TRUE;
                    pVarSet = pUnk;
                    pUnk->Release();
                    _bstr_t text = pVarSet->get(GET_BSTR(DCTVS_JobStatus));
                    m_Status = (LPCWSTR)text;
                    text = pVarSet->get(GET_BSTR(DCTVS_CurrentPath));
                    m_Current = (LPCWSTR)text;
                    text = pVarSet->get(GET_BSTR(DCTVS_CurrentOperation));
                    m_Operation = (LPCWSTR)text;
                    // Get the stats
                    LONG                num1,num2,num3,num4;
                    UpdateData(FALSE);
                    if ( !UStrICmp(m_Operation,GET_STRING(IDS_ACCT_REPL_OPERATION_TEXT)) )
                    {
                        // Set up the labels for account replication
                        SetupAcctReplFormat();
                    }
                    else if ( !UStrICmp(m_Operation,GET_STRING(IDS_FST_OPERATION_TEXT)) )
                    {
                        SetupFSTFormat();
                    }
                    else if ( ! UStrICmp(m_Operation,GET_STRING(IDS_EST_OPERATION_TEXT)) )
                    {
                        SetupESTFormat();
                    }  
                    else
                    {
                        if ( m_Current.GetLength() && 
                            ( _wtoi(m_FilesExamined) + _wtoi(m_DirectoriesExamined) + _wtoi(m_SharesExamined)) == 0 )
                        {
                            // unless some stats have already been collected, hide the stats, if the operation
                            // is not one that we have detailed stats for.
                            SetupOtherFormat();
                        }
                    }
                    switch ( m_format )
                    {


                    case 0:  // FST

                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Changed));
                        m_FilesExamined.Format(L"%ld",num1);
                        if ( ! m_bGatheringInfo )
                        {
                            m_FilesChanged.Format(L"%ld",num2);
                            m_FilesUnchanged.Format(L"%ld",num1-num2);
                        }
                        else
                        {
                            m_FilesChanged.Empty();
                            m_FilesUnchanged.Empty();
                        }

                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Changed));
                        m_DirectoriesExamined.Format(L"%ld",num1);
                        if ( ! m_bGatheringInfo )
                        {
                            m_DirectoriesChanged.Format(L"%ld",num2);
                            m_DirectoriesUnchanged.Format(L"%ld",num1-num2);  
                        }
                        else
                        {
                            m_DirectoriesChanged.Empty();
                            m_DirectoriesUnchanged.Empty();  
                        }
                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Changed));
                        m_SharesExamined.Format(L"%ld",num1);
                        if ( ! m_bGatheringInfo )
                        {
                            m_SharesChanged.Format(L"%ld",num2);
                            m_SharesUnchanged.Format(L"%ld",num1-num2);
                        }
                        else
                        {
                            m_SharesChanged.Empty();
                            m_SharesUnchanged.Empty();
                        }
                        break;
                        case 1: // AcctRepl
                        // files = user accounts
                        // dirs  = global groups + local groups
                        // shares = computer accounts
                        // examined = processed
                        // changed = created + replaced
                        // unchanged = errors
                        // User stats
                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Created));
                        num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Replaced));
                        num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Errors));

                        m_FilesExamined.Format(L"%ld",num1);
                        m_FilesChanged.Format(L"%ld",num2+num3);
                        m_FilesUnchanged.Format(L"%ld",num4);

                        // Global group stats
                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Created));
                        num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Replaced));
                        num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Errors));
                        // local group stats
                        LONG                 num5, num6,num7, num8;

                        num5 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Examined));
                        num6 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Created));
                        num7 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Replaced));
                        num8 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Errors));

                        m_DirectoriesExamined.Format(L"%ld",num1 + num5);
                        m_DirectoriesChanged.Format(L"%ld",num2+num3 + num6+num7);
                        m_DirectoriesUnchanged.Format(L"%ld",num4 + num8);

                        // computer account stats
                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Created));
                        num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Replaced));
                        num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Errors));

                        m_SharesExamined.Format(L"%ld",num1);
                        m_SharesChanged.Format(L"%ld",num2+num3);
                        m_SharesUnchanged.Format(L"%ld",num4);
                        break;         

                    case 2:  // EST
                        num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Mailboxes_Examined));
                        num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Mailboxes_Changed));

                        m_FilesExamined.Format(L"%ld",num1);
                        m_FilesChanged.Format(L"%ld",num2);
                        m_FilesUnchanged.Format(L"%ld",num1-num2);

                        // since we are not doing anything with containers
                        // we empty those field as well
                        m_DirectoriesExamined.Empty();
                        m_DirectoriesChanged.Empty();
                        m_DirectoriesUnchanged.Empty();  

                        m_SharesExamined.Empty();
                        m_SharesChanged.Empty();
                        m_SharesUnchanged.Empty();
                        break;

                    case -1:  // default (empty)
                        m_FilesExamined.Empty();
                        m_FilesChanged.Empty();
                        m_FilesUnchanged.Empty();
                        m_DirectoriesExamined.Empty();
                        m_DirectoriesChanged.Empty();
                        m_DirectoriesUnchanged.Empty();
                        m_SharesExamined.Empty();
                        m_SharesChanged.Empty();
                        m_SharesUnchanged.Empty();
                        break;

                    }
                }
                else
                {
                    if ( hr == DISP_E_UNKNOWNNAME )
                    {
                        m_StatusUnknown = TRUE;
                        m_Status.FormatMessage(IDS_AgentJobNotFound,(WCHAR*)jobID);
                    }
                    else if ( hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) )
                    {
                        if (m_pNode && m_pNode->IsJoinDomainWithRename())
                        {
                            m_pAgent = NULL;  // this way, we will use the logic for m_pAgent == NULL
                        }
                        else
                            m_Status.LoadString(IDS_AgentNoLongerRunning);
                    }
                    else
                    {
                        m_StatusUnknown = TRUE;
                        m_Status.FormatMessage(IDS_QueryJobStatusFailed,hr);
                    }
                }
            }
        }
        catch ( ... )
        {
            m_StatusUnknown = TRUE;
            m_Status.FormatMessage(IDS_ExceptionConnectingToAgent);
            //m_Current = step;
        }
    }
   
    if ( m_PlugInText.GetLength() )
    {
        // permanently hide the plug-in button, because our plug-ins 
        // don't show any useful text
        //m_PlugInButton.ShowWindow(SW_SHOW);
    }

    //get the job log file when agent is done
    if ((!m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed))
         || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
        && (m_pNode))
    {
        SetLogFile(m_pNode->GetLogPath());   
        SetLogFileValid(m_pNode->GetLogPathValid());
    }

    if ( m_LogFile.GetLength() )
    {
        m_ViewLogButton.ShowWindow(SW_SHOW);
        if ( ! m_AgentAlive || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed)) 
            || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
        {
            m_ViewLogButton.EnableWindow(TRUE);
        }
        else
        {
            m_ViewLogButton.EnableWindow(FALSE);
        }
    }
    else
    {
        m_ViewLogButton.ShowWindow(SW_HIDE);
    }
   
    if ( ! m_AgentAlive || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed)) 
        || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
    {
        // Disable the refresh button when the status changes to Completed.
        if ( !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed))
            || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
        {
            if ( GetDefID() == IDC_BTNREFRESH ) 
            {
                SetDefID(IDOK);
            }
            m_RefreshButton.EnableWindow(FALSE);
        }
        // disable the stop agent button any time the agent is not running
        m_StopAgentButton.EnableWindow(FALSE);

        //enable the close button any time the agent is not running
        m_OKButton.EnableWindow(TRUE);

        // if auto closing dialog
        if (m_bAutoClose)
        {
            OnOK();
        }
    }
    else
    {
        // enable the refresh and stop agent buttons when the agent is alive and running
        m_RefreshButton.EnableWindow(TRUE);
        m_StopAgentButton.EnableWindow(TRUE);
    }

    UpdateData(FALSE);
}

void CAgentDetailDlg::OnOK() 
{
    UpdateData(TRUE);

    if (!m_bAutoClose)
    {
        CString        str;
        CString        title;

        str = GET_STRING(IDS_DCT_Status_InProgress);
        title.LoadString(IDS_MessageTitle);

        if ( ! m_hBinding )  // only show the warning for the local agent
        {
            if ( str == m_Status )
            {
                str.LoadString(IDS_CannotCloseWhileAgentIsRunning);
                MessageBox(str,title,MB_ICONHAND | MB_OK);
                return;
            }
        }
    }

    bDetailDone = TRUE;

    if ( m_pAgent )
    {
        m_pAgent = NULL;
    }

    if (m_bCoInitialized)
    {
        CoUninitialize();
        m_bCoInitialized = FALSE;
    }

    CDialog::OnOK();
}

void CAgentDetailDlg::OnChangeEdit2() 
{
    UpdateData(TRUE);
    detailInterval = _wtoi(m_RefreshRate);
    if ( detailInterval <= 0 )
    {
        detailInterval = 1;
    }
}

LRESULT CAgentDetailDlg::DoRefresh(UINT nID, long x)
{
    OnRefresh();
    return 0;
}

void CAgentDetailDlg::OnStopAgent() 
{
    DWORD                     rc = 0;
    HRESULT                   hr = S_OK;
    CString                   message;
    CString                   title;

    if (!m_bCoInitialized)
        return;

    title.LoadString(IDS_MessageTitle);

    if ( m_hBinding )
    {
        message.LoadString(IDS_ConfirmStopAgent);
        if ( MessageBox(message,title,MB_ICONQUESTION | MB_YESNO) == IDYES )
        {
            _bstr_t             jobID = m_pNode->GetJobID();

            if ( m_pAgent )
            {
                hr = m_pAgent->raw_CancelJob(jobID);
                m_pAgent = NULL;
            }
            else
            {
                message.LoadString(IDS_AgentNotRunning);
                MessageBox(message,NULL,MB_OK);
            }
            if ( FAILED(hr) )
            {
                message.FormatMessage(IDS_CancelJobFailed,hr);
                MessageBox(message,NULL,MB_ICONERROR | MB_OK);
            }
            if ( rc )
            {
                message.FormatMessage(IDS_StopAgentFailed,rc);
                MessageBox(message,NULL,MB_ICONERROR|MB_OK);
            }
            if ( SUCCEEDED(hr) && !rc )
            {
                OnOK();
            }
        }
    }
    else
    {
        // Local agent here
        if ( m_pAgent )
        {
            message.LoadString(IDS_ConfirmCancelJob);
            if ( MessageBox(message,NULL,MB_ICONQUESTION | MB_YESNO) == IDYES )
            {
                hr = m_pAgent->raw_CancelJob(m_JobGuid);
                if  ( FAILED(hr) )
                {
                    message.FormatMessage(IDS_StopAgentFailedHexResult,hr);
                    MessageBox(message,NULL,MB_ICONERROR | MB_OK);
                }
                else
                {
                    gbCancelled = TRUE;
                }
            }
        }
        else
        {
            // TODO:error message
        }
    }

}

void CAgentDetailDlg::OnViewLog() 
{
   UpdateData(TRUE);
   if ( ! m_LogFile.IsEmpty() )
   {
      if (m_LogFileIsValid)
      {
          // Launch the logfile
          CString                   cmd;
          STARTUPINFO				     startupInfo;
    	   PROCESS_INFORMATION		  processInfo;

    	   TCHAR* pszSystemDirectoryName = NULL;
    	   CString                   message;
    	   CString                   title;

    	   pszSystemDirectoryName = GetSystemDirectoryHelper();
    	   if(!pszSystemDirectoryName)
    	   {
    	       // we could not get the system directory name, we should bail out, otherwise we might launch
    	       // malicious process
    	       title.LoadString(IDS_MessageTitle);
    	       message.LoadString(IDS_LaunchNotePadFailed);
    	       
    	       MessageBox(message, title, MB_ICONERROR | MB_OK);
    	       return;
    	   }


          memset(&startupInfo,0,(sizeof startupInfo));
       
          startupInfo.cb = (sizeof startupInfo);

          cmd.FormatMessage(IDS_NotepadCommandLine,pszSystemDirectoryName,m_LogFile);
          delete [] pszSystemDirectoryName;

          CreateProcess(NULL,cmd.GetBuffer(0),NULL,NULL,TRUE,0,NULL,NULL,&startupInfo,&processInfo);
      }
      else
      {
        CString title;
        CString message;

        title.LoadString(IDS_MessageTitle);
        message.FormatMessage(IDS_LogfileIsInvalid,m_LogFile,m_ServerName);
        MessageBox(message,title,MB_ICONERROR | MB_OK);
      }
   }
}

void CAgentDetailDlg::OnPlugInResults() 
{
   UpdateData(TRUE);
   MessageBox(m_PlugInText);	
}

void CAgentDetailDlg::OnClose() 
{
    UpdateData(TRUE);
    CString        str;
    CString        title;

    str = GET_STRING(IDS_DCT_Status_InProgress);
    title.LoadString(IDS_MessageTitle);

    if ( ! m_hBinding )  // only show the warning for the local agent
    {
        if ( str == m_Status )
        {
            str.LoadString(IDS_ConfirmCloseWhileAgentIsRunning);
            if ( IDYES != MessageBox(str,title,MB_ICONQUESTION | MB_YESNO) )
                return;
        }
    }
    bDetailDone = TRUE;
    if ( m_pAgent )
    {
        m_pAgent = NULL;
    }

    if (m_bCoInitialized)
    {
        CoUninitialize();
        m_bCoInitialized = FALSE;
    }

    CDialog::OnClose();
}

BOOL CAgentDetailDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    // TODO: Add your specialized code here and/or call the base class
    TRACE(L"Command(%lx,%lx)\n",wParam,lParam);
    if ( wParam == WM_DESTROY )
    {
        CString        str;
        CString        title;
        CString        str2;

        str = GET_STRING(IDS_DCT_Status_InProgress);
        str2 = GET_STRING(IDS_DCT_Status_NotStarted);
        title.LoadString(IDS_MessageTitle);

        if ( ! m_hBinding )  // only show the warning for the local agent
        {
            if ( str == m_Status )
            {
                str.LoadString(IDS_ConfirmCloseWhileAgentIsRunning);
                if ( IDYES != MessageBox(str,title,MB_ICONQUESTION | MB_YESNO) )
                    return 0;
            }
        }
        bDetailDone = TRUE;
        if ( m_pAgent )
        {
            m_pAgent = NULL;
        }

        if (m_bCoInitialized)
        {
            CoUninitialize();
            m_bCoInitialized = FALSE;
        }

        return CDialog::OnCommand(wParam, lParam);

    }
    else
    {
        return CDialog::OnCommand(wParam, lParam);
    }
}


// OnNcPaint Handler
//
// This handler is being overridden to handle hiding of the dialog.
// This prevents initial painting of the dialog which causes a flash
// if the dialog is hidden after this message. This is the first message
// where the dialog can be hidden. Trying to hide the dialog before this
// point gets overridden.

void CAgentDetailDlg::OnNcPaint() 
{
	if (m_bAutoHide)
	{
		if (IsWindowVisible())
		{
			ShowWindow(SW_HIDE);
		}
	}
	else
	{
		CDialog::OnNcPaint();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\fparse.hpp ===
#ifndef __FILEPARSER_HPP__
#define __FILEPARSER_HPP__
/*---------------------------------------------------------------------------
  File: FileParser.hpp

  Comments: Classes to parse text files generated by the Domain Admin dispatcher and agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 15:16:31

 ---------------------------------------------------------------------------
*/

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ServList.hpp"




#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


class TFileParser
{
protected:
   FILE                    * m_pFile;
   WCHAR                     m_filename[MAX_PATH];
   BOOL                      m_bValidData;        
public:
   TFileParser()
   {
      m_filename[0] = 0;
      m_pFile = NULL;
      m_bValidData = FALSE;
   }
   ~TFileParser()
   {
      if ( m_pFile )
         fclose(m_pFile);
   }

   BOOL Open(WCHAR const * filename)
   {
      safecopy(m_filename,filename);
      
      if ( *m_filename )
      {
         m_pFile = _wfopen(m_filename,L"rb");
      }
      else
      {
         m_pFile = 0;
      }
   
      return ( m_pFile != 0 );
   }

   BOOL IsOpen() { return ( m_pFile != 0 ); }
   void Close() { if ( m_pFile ) { fclose(m_pFile); m_pFile = NULL; } }
   BOOL IsEof() { return m_pFile ? feof(m_pFile) : TRUE; }
   BOOL Restart() 
   { 
      BOOL                   bRc = FALSE;
      if ( m_pFile ) 
      { 
         bRc = ( fseek(m_pFile,0,SEEK_SET) == 0 );
      }
      return bRc;
   }
   virtual BOOL ScanEntry() = 0;
};

class TErrorLogParser:public TFileParser
{
   int                       m_Severity;
   int                       m_SourceLine;         // 
   WCHAR                     m_Timestamp[100];     // the timestamp of the entry
   WCHAR                     m_Message[1000];      // the message text part of the entry
   WCHAR                     m_strBuf[1000];       // a line from the log file
public:                                         
   virtual BOOL ScanEntry() 
   { 
      MCSASSERT(m_pFile);
      m_bValidData = FALSE;
      if ( m_pFile && fgetws(m_strBuf,1000,m_pFile) )
      {
         m_bValidData = ScanFileEntry(m_strBuf,m_Timestamp,&m_Severity,&m_SourceLine,m_Message);
            
      }
      return m_bValidData;
   }
   
   int GetSeverity() { MCSASSERT(m_bValidData); return m_Severity; }
   int GetSourceLine() { MCSASSERT(m_bValidData); return m_SourceLine; }
   WCHAR const * GetTimestamp() { MCSASSERT(m_bValidData); return m_Timestamp; }
   WCHAR const * GetMessage() { MCSASSERT(m_bValidData); return m_Message; }
protected:
   BOOL 
   ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   );

};

void ParseInputFile(WCHAR const * gLogFile);

void 
   ReadResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename,
      WCHAR          const * dbName
   );


#endif //__FILEPARSER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\maindlg.h ===
#if !defined(AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MainDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog

class CMainDlg : public CPropertyPage
{
// Construction
public:
	CMainDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMainDlg)
	enum { IDD = IDD_AGENTMONITOR_MAIN };
	CProgressCtrl	m_InstallProgCtrl;
	CProgressCtrl	m_FinishProgCtrl;
	CString	m_ErrorCount;
	CString	m_FinishedCount;
	CString	m_InstalledCount;
	CString	m_RunningCount;
	CString	m_TotalString;
	CString	m_DirectoriesChanged;
	CString	m_DirectoriesExamined;
	CString	m_DirectoriesUnchanged;
	CString	m_FilesChanged;
	CString	m_FilesExamined;
	CString	m_FilesUnchanged;
	CString	m_SharesChanged;
	CString	m_SharesExamined;
	CString	m_SharesUnchanged;
	CString	m_MembersChanged;
	CString	m_MembersExamined;
	CString	m_MembersUnchanged;
	CString	m_RightsChanged;
	CString	m_RightsExamined;
	CString	m_RightsUnchanged;
	//}}AFX_DATA
   virtual BOOL OnSetActive( );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainDlg)
	public:
	virtual void OnOK();
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMainDlg)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
   
//   LRESULT OnUpdateCounts(UINT nID, long x);
   LRESULT OnUpdateCounts(UINT nID, LPARAM x);
//   LRESULT OnUpdateTotals(UINT nID, long x);
   LRESULT OnUpdateTotals(UINT nID, LPARAM x);
   
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\globals.h ===
#ifndef __GLOBALS_H__
#define __GLOBALS_H__
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:13:56

 ---------------------------------------------------------------------------
*/


#include "ServList.hpp"
#include "Monitor.h"
#include "TSync.hpp"

class GlobalData
{
   long                      m_LinesRead;          // number of lines of the dispatch log that have been processed
   WCHAR                     m_LogFile[MAX_PATH];  // full path of dispatch log
   WCHAR                     m_ReadableLogFile[MAX_PATH]; // full path of human-readable log file
   WCHAR                     m_ResultDir[MAX_PATH];// full path of results directory
   WCHAR                     m_ResultShare[MAX_PATH]; // sharename for results share
   WCHAR                     m_DatabasePath[MAX_PATH]; // full path of Access database to write resulting stats to
   WCHAR                     m_CacheFile[MAX_PATH]; // filename of FST cache file generated by dispatcher
   int                       m_IntervalSeconds;    // number of seconds for monitoring threads to wait between passes
   BOOL                      m_Done;               // monitoring threads should check this to see if they should stop
   BOOL                      m_bForcedToStopMonitoring; // monitoring is forced to stop while agents are still running
   BOOL                      m_ImportStats;        // indicates whether the monitor should write stats to a database
   BOOL                      m_bFirstPassDone;     // indicates whether we have made a first pass through the log file yet
   BOOL                      m_bTotalRead;         // indicates whether we have read the total number of agents
   HWND                      m_ListWnd;            // handle to the server list window
   HWND                      m_SummaryWnd;         // handle to the summary window
   HWND                      m_DetailWnd;          // handle to the single-server detail window
   ComputerStats             m_ComputerStats;       // stats on number of computers in progress
   DetailStats               m_DetailStats;        // stats on total objects processed (by completed agents)
   TServerList               m_ServerList;         // list containing the  servers where the agent is being dispatched
   TCriticalSection          m_cs;           
   BOOL                      m_LogDone;            // indicates whether the dispatcher has finished writing to the log file
public:
   GlobalData() 
   {
      Initialize();
   }
   void Initialize()
   {
      m_cs.Enter();
      m_LinesRead = 0;
      m_LogFile[0] = 0;
      m_ReadableLogFile[0] = 0;
      m_ResultDir[0] = 0;
      m_ResultShare[0] = 0;
      m_DatabasePath[0] = 0;
      m_CacheFile[0] = 0;
      m_IntervalSeconds = 5;
      m_Done = FALSE;
      m_bForcedToStopMonitoring = FALSE;
      m_ImportStats = FALSE;
      m_bFirstPassDone = FALSE;
      m_bTotalRead = FALSE;
      m_ListWnd = NULL;
      m_SummaryWnd = NULL;
      m_DetailWnd = NULL;
      memset(&m_ComputerStats,0,sizeof m_ComputerStats);
      memset(&m_DetailStats,0,sizeof m_DetailStats);
      m_ServerList.Clear();
      m_LogDone = FALSE;
      m_cs.Leave();
   }

   void GetLinesRead(long * lines) { m_cs.Enter(); (*lines) = m_LinesRead; m_cs.Leave(); }
   void SetLinesRead(long lines) { m_cs.Enter(); m_LinesRead = lines; m_cs.Leave(); }

   void GetLogPath(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_LogFile); m_cs.Leave(); }
   void SetLogPath(WCHAR const * path) { m_cs.Enter(); safecopy(m_LogFile,path); m_cs.Leave(); }

   void GetReadableLogFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_ReadableLogFile); m_cs.Leave(); }
   void SetReadableLogFile(WCHAR const * path) { m_cs.Enter(); safecopy(m_ReadableLogFile,path); m_cs.Leave(); }
   
   void GetResultDir(WCHAR * dir) { m_cs.Enter(); UStrCpy(dir,m_ResultDir); m_cs.Leave() ; }
   void SetResultDir(WCHAR const * dir) { m_cs.Enter(); safecopy(m_ResultDir,dir); m_cs.Leave(); }

   void GetResultShare(WCHAR * share) { m_cs.Enter(); UStrCpy(share,m_ResultShare); m_cs.Leave() ; }
   void SetResultShare(WCHAR const * share) { m_cs.Enter(); safecopy(m_ResultShare,share); m_cs.Leave(); }

   void GetWaitInterval(long * interval) { m_cs.Enter(); (*interval) = m_IntervalSeconds; m_cs.Leave(); }
   void SetWaitInterval(long interval) { m_cs.Enter(); m_IntervalSeconds = interval; m_cs.Leave(); }

   void GetDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_Done; m_cs.Leave(); }
   void SetDone(BOOL bDone) { m_cs.Enter(); m_Done = bDone; m_cs.Leave(); }

   void GetForcedToStopMonitoring(BOOL* bForcedToStop) { m_cs.Enter(); (*bForcedToStop) = m_bForcedToStopMonitoring; m_cs.Leave(); }
   void SetForcedToStopMonitoring(BOOL bForcedToStop) { m_cs.Enter(); m_bForcedToStopMonitoring = bForcedToStop; m_cs.Leave(); }

   void GetLogDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_LogDone; m_cs.Leave(); }
   void SetLogDone(BOOL bDone) { m_cs.Enter(); m_LogDone = bDone; m_cs.Leave(); }

   void GetListWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_ListWnd; m_cs.Leave(); }
   void SetListWindow(HWND hWnd) { m_cs.Enter(); m_ListWnd = hWnd; m_cs.Leave(); }

   void GetSummaryWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_SummaryWnd; m_cs.Leave(); }
   void SetSummaryWindow(HWND hWnd) { m_cs.Enter(); m_SummaryWnd = hWnd; m_cs.Leave(); }

   void GetDetailWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_DetailWnd; m_cs.Leave(); }
   void SetDetailWindow(HWND hWnd) { m_cs.Enter(); m_DetailWnd = hWnd; m_cs.Leave(); }

   void GetComputerStats(ComputerStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_ComputerStats, sizeof m_ComputerStats); m_cs.Leave(); }
   void SetComputerStats(ComputerStats const * pStats) { m_cs.Enter(); memcpy(&m_ComputerStats,pStats,sizeof m_ComputerStats); m_cs.Leave(); }

   void GetDetailStats(DetailStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_DetailStats,sizeof m_DetailStats); m_cs.Leave(); }
   
   void GetImportStats(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_ImportStats; m_cs.Leave(); }
   void SetImportStats(BOOL v) { m_cs.Enter(); m_ImportStats = v; m_cs.Leave(); }

   void GetDatabaseName(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_DatabasePath); m_cs.Leave();  }
   void SetDatabaseName(WCHAR const * path) { m_cs.Enter(); safecopy(m_DatabasePath,path); m_cs.Leave(); }

   void GetFirstPassDone(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_bFirstPassDone; m_cs.Leave(); }
   void SetFirstPassDone(BOOL val) { m_cs.Enter(); m_bFirstPassDone = val; m_cs.Leave(); }

   void GetTotalRead(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_bTotalRead; m_cs.Leave(); }
   void SetTotalRead(BOOL val) { m_cs.Enter(); m_bTotalRead = val; m_cs.Leave(); }

   void GetCacheFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_CacheFile); m_cs.Leave(); }
   void SetCacheFile(WCHAR const * path) { m_cs.Enter(); UStrCpy(m_CacheFile,path); m_cs.Leave(); }

   TServerList * GetUnsafeServerList(){ return &m_ServerList;}

   void Lock() { m_cs.Enter(); }

   void Unlock() { m_cs.Leave(); }

   void AddDetailStats(DetailStats * stats)
   {
      m_cs.Enter();
      m_DetailStats.directoriesChanged += stats->directoriesChanged;
      m_DetailStats.directoriesExamined += stats->directoriesExamined;
      m_DetailStats.directoriesUnchanged += stats->directoriesUnchanged;

      m_DetailStats.filesChanged += stats->filesChanged;
      m_DetailStats.filesExamined += stats->filesExamined;
      m_DetailStats.filesUnchanged += stats->filesUnchanged;

      m_DetailStats.sharesChanged += stats->sharesChanged;
      m_DetailStats.sharesExamined += stats->sharesExamined;
      m_DetailStats.sharesUnchanged += stats->sharesUnchanged;

      m_DetailStats.membersChanged += stats->membersChanged;
      m_DetailStats.membersExamined += stats->membersExamined;
      m_DetailStats.membersUnchanged += stats->membersUnchanged;

      m_DetailStats.rightsChanged += stats->rightsChanged;
      m_DetailStats.rightsExamined += stats->rightsExamined;
      m_DetailStats.rightsUnchanged += stats->rightsUnchanged;

      m_cs.Leave();
   }

};

extern GlobalData       gData;

void helpWrapper(HWND hwndDlg, int t);


#endif //__GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\maindlg.cpp ===
/*---------------------------------------------------------------------------
  File:  MainDlg.cpp

  Comments: This dialog shows the summary statistics, including 
  the number of agents successfully dispatched and completed, and the 
  total number of objects processed for all agents.  The number of objects
  processed is incremented to include the results for each agent when that 
  agent finishes and writes back its result file.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// MainDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MainDlg.h"
#include "Monitor.h"
#include "Globals.h"
#include "ResStr.h"
#include "TReg.hpp"
#include "HtmlHelpUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <htmlhelp.h>
#include "helpid.h"
/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog


CMainDlg::CMainDlg(CWnd* pParent /*=NULL*/)
: CPropertyPage(CMainDlg::IDD)
{
	//{{AFX_DATA_INIT(CMainDlg)
	m_ErrorCount = _T("0");
	m_FinishedCount = _T("0");
	m_InstalledCount = _T("0");
	m_RunningCount = _T("0");
	m_TotalString = _T("");
	m_DirectoriesChanged = _T("0");
	m_DirectoriesExamined = _T("0");
	m_DirectoriesUnchanged = _T("0");
	m_FilesChanged = _T("0");
	m_FilesExamined = _T("0");
	m_FilesUnchanged = _T("0");
	m_SharesChanged = _T("0");
	m_SharesExamined = _T("0");
	m_SharesUnchanged = _T("0");
	m_MembersChanged = _T("0");
	m_MembersExamined = _T("0");
	m_MembersUnchanged = _T("0");
	m_RightsChanged = _T("0");
	m_RightsExamined = _T("0");
	m_RightsUnchanged = _T("0");
	//}}AFX_DATA_INIT
}


void CMainDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMainDlg)
	DDX_Control(pDX, IDC_INSTALL_PROGRESS, m_InstallProgCtrl);
	DDX_Control(pDX, IDC_COMPLETE_PROGESS, m_FinishProgCtrl);
	DDX_Text(pDX, IDC_ERROR_COUNT, m_ErrorCount);
	DDX_Text(pDX, IDC_FINISHED_COUNT, m_FinishedCount);
	DDX_Text(pDX, IDC_INSTALLED_COUNT, m_InstalledCount);
	DDX_Text(pDX, IDC_RUNNING_COUNT, m_RunningCount);
	DDX_Text(pDX, IDC_TOTAL, m_TotalString);
	DDX_Text(pDX, IDC_DirsChanged2, m_DirectoriesChanged);
	DDX_Text(pDX, IDC_DirsExamined, m_DirectoriesExamined);
	DDX_Text(pDX, IDC_DirsU, m_DirectoriesUnchanged);
	DDX_Text(pDX, IDC_FilesChanged, m_FilesChanged);
	DDX_Text(pDX, IDC_FilesExamined, m_FilesExamined);
	DDX_Text(pDX, IDC_FilesU, m_FilesUnchanged);
	DDX_Text(pDX, IDC_SharesChanged, m_SharesChanged);
	DDX_Text(pDX, IDC_SharesExamined2, m_SharesExamined);
	DDX_Text(pDX, IDC_SharesU, m_SharesUnchanged);
	DDX_Text(pDX, IDC_MembersChanged, m_MembersChanged);
	DDX_Text(pDX, IDC_MembersExamined, m_MembersExamined);
	DDX_Text(pDX, IDC_MembersU, m_MembersUnchanged);
	DDX_Text(pDX, IDC_RightsChanged, m_RightsChanged);
	DDX_Text(pDX, IDC_RightsExamined, m_RightsExamined);
	DDX_Text(pDX, IDC_RightsU, m_RightsUnchanged);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMainDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CMainDlg)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
   ON_MESSAGE(DCT_UPDATE_COUNTS, OnUpdateCounts)
	ON_MESSAGE(DCT_UPDATE_TOTALS, OnUpdateTotals)
	
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDlg message handlers

BOOL CMainDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose( );

   return rc;
}

BOOL CMainDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	ComputerStats             gStat;
   DetailStats               dStat;
   
   gData.GetComputerStats(&gStat);
   gData.GetDetailStats(&dStat);

//   OnUpdateCounts(0,(long)&gStat);
   OnUpdateCounts(0, (LPARAM)&gStat);
//	OnUpdateTotals(0, (long)&dStat);
   OnUpdateTotals(0, (LPARAM)&dStat);
   gData.SetSummaryWindow(m_hWnd);

   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//LRESULT CMainDlg::OnUpdateCounts(UINT nID, long x)
LRESULT CMainDlg::OnUpdateCounts(UINT nID, LPARAM x)
{
   UpdateData(TRUE);
   ComputerStats               * pStat = (ComputerStats *)x;

   m_TotalString.FormatMessage(IDS_ServerCountMessage,pStat->total);

   m_InstalledCount.Format(L"%ld",pStat->numInstalled);
   m_RunningCount.Format(L"%ld",pStat->numRunning);
   m_FinishedCount.Format(L"%ld",pStat->numFinished);
   m_ErrorCount.Format(L"%ld",pStat->numError);

#if _MFC_VER >= 0x0600
   m_InstallProgCtrl.SetRange32(0,pStat->total - pStat->numError);
#else
   m_InstallProgCtrl.SetRange(0,pStat->total - pStat->numError);
#endif
//   m_InstallProgCtrl.SetRange32(0,pStat->total - pStat->numError);
   m_InstallProgCtrl.SetPos(pStat->numInstalled);

#if _MFC_VER >= 0x0600
   m_FinishProgCtrl.SetRange32(0,pStat->total - pStat->numError);
#else
   m_FinishProgCtrl.SetRange(0,pStat->total - pStat->numError);
#endif
//   m_FinishProgCtrl.SetRange32(0,pStat->total - pStat->numError);
   m_FinishProgCtrl.SetPos(pStat->numFinished);

   UpdateData(FALSE);
   return 0;
}


//LRESULT CMainDlg::OnUpdateTotals(UINT nID, long x)
LRESULT CMainDlg::OnUpdateTotals(UINT nID, LPARAM x)
{
   UpdateData(TRUE);
   
   DetailStats               temp;
   DetailStats             * pStat = &temp;


   gData.GetDetailStats(&temp);
   
   
   m_FilesChanged.Format(L"%ld",pStat->filesChanged);
   m_FilesExamined.Format(L"%ld",pStat->filesExamined);
   m_FilesUnchanged.Format(L"%ld",pStat->filesUnchanged);

   m_DirectoriesChanged.Format(L"%ld",pStat->directoriesChanged);
   m_DirectoriesExamined.Format(L"%ld",pStat->directoriesExamined);
   m_DirectoriesUnchanged.Format(L"%ld",pStat->directoriesUnchanged);

   m_SharesChanged.Format(L"%ld",pStat->sharesChanged);
   m_SharesExamined.Format(L"%ld",pStat->sharesExamined);
   m_SharesUnchanged.Format(L"%ld",pStat->sharesUnchanged);

   m_MembersChanged.Format(L"%ld",pStat->membersChanged);
   m_MembersExamined.Format(L"%ld",pStat->membersExamined);
   m_MembersUnchanged.Format(L"%ld",pStat->membersUnchanged);

   m_RightsChanged.Format(L"%ld",pStat->rightsChanged);
   m_RightsExamined.Format(L"%ld",pStat->rightsExamined);
   m_RightsUnchanged.Format(L"%ld",pStat->rightsUnchanged);

   UpdateData(FALSE);
   return 0;
}

void CMainDlg::OnOK() 
{
	CPropertyPage::OnOK();
   
}

void CMainDlg::WinHelp(DWORD dwData, UINT nCmd) 
{
	// TODO: Add your specialized code here and/or call the base class
	CPropertyPage::WinHelp(dwData, nCmd);
}

BOOL CMainDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SUMMARY);
         break;
   }
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}


HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   USES_CONVERSION;

   HRESULT hr = S_OK;

   try
   {
      TRegKey key;
      DWORD rc;

      // open ADMT registry key
      rc = key.Open(GET_STRING(IDS_DOMAIN_ADMIN_REGKEY), HKEY_LOCAL_MACHINE);
      _com_util::CheckError(HRESULT_FROM_WIN32(rc));

      // query ADMT folder path from registry value

      _TCHAR szPath[_MAX_PATH];
      rc = key.ValueGetStr(_T("Directory"), szPath, sizeof(szPath));
      _com_util::CheckError(HRESULT_FROM_WIN32(rc));

      // if no path separator concatenate

      if (szPath[_tcslen(szPath) - 1] != _T('\\'))
      {
         _tcscat(szPath, _T("\\"));
      }

      // concatenate help file name

      CComBSTR bstrName;
      bstrName.LoadString(IDS_HELPFILE);

      _tcscat(szPath, OLE2CT(bstrName));

      *bstrHelp = SysAllocString(T2COLE(szPath));
   }
   catch (_com_error& ce)
   {
      hr = ce.Error();
   }
   catch (...)
   {
      hr = E_FAIL;
   }

   return hr;
}

void helpWrapper(HWND hwndDlg, int t)
{
   
   CComBSTR    bstrTopic;
	HRESULT     hr = GetHelpFileFullPath( &bstrTopic);
   if ( SUCCEEDED(hr) )
   {
	    HWND h = HtmlHelp(hwndDlg,  bstrTopic,  HH_HELP_CONTEXT, t );
	    if (!IsInWorkArea(h))
	        PlaceInWorkArea(h);
   }
   else
   {
		CString r,e;
		r.LoadString(IDS_MSG_HELP);
		e.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,r,e,MB_OK|MB_ICONSTOP);
   }
}

BOOL CMainDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SUMMARY);
	return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\migdrvr.cpp ===
/*---------------------------------------------------------------------------
  File:  McsMigrationDriver.cpp

  Comments: Main program for COM object that drives the migration process.
  This file is mostly generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// McsMigrationDriver.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsMigrationDriverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <locale.h>
#include "MigDrvr.h"

#include "MigDrvr_i.c"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "Migrator.h"
#include "ErrDct.hpp"
#include "ResStr.h"

TErrorDct         errTrace;
TError          & errCommon = errTrace;
StringLoader      gString;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Migrator, CMigrator)
END_OBJECT_MAP()




class CMcsMigrationDriverApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMcsMigrationDriverApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMcsMigrationDriverApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMcsMigrationDriverApp, CWinApp)
	//{{AFX_MSG_MAP(CMcsMigrationDriverApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMcsMigrationDriverApp theApp;

BOOL CMcsMigrationDriverApp::InitInstance()
{
	ATLTRACE(_T("{McsMigrationDriver.dll}CDomMigSIApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _wsetlocale( LC_ALL, L".ACP" );
    _Module.Init(ObjectMap, m_hInstance, &LIBID_MCSMIGRATIONDRIVERLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CMcsMigrationDriverApp::ExitInstance()
{
	ATLTRACE(_T("{McsMigrationDriver.dll}CDomMigSIApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\migrator.cpp ===
/*---------------------------------------------------------------------------
  File:  Migrator.cpp

  Comments: Implementation of McsMigrationDriver COM object.
  This object encapsulates the knowledge of when to call the local engine, 
  and when to call the dispatcher.  

  It will also provide a description of the tasks to be performed, for display 
  on the last page of each migration wizard, and will be responsible for calculating
  the actions required to undo an operation (this is not yet implemented).

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// Migrator.cpp : Implementation of CMcsMigrationDriverApp and DLL registration.

#include "stdafx.h"
#include "MigDrvr.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsEADCTAgent.tlb" no_namespace, named_guids
//#import "\bin\McsDispatcher.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb"
//#import "\bin\NetEnum.tlb" no_namespace 
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
//#import "Engine.tlb" no_namespace, named_guids //#imported via DetDlg.h below
#import "Dispatch.tlb" no_namespace, named_guids
#import "WorkObj.tlb"
#import "NetEnum.tlb" no_namespace 
#include <iads.h>
#include <adshlp.h>
#include <dsgetdc.h>
#include <Ntdsapi.h>
#include <lm.h>
#include <Psapi.h>
#include <map>
#pragma comment(lib, "Psapi.lib")

#include "Migrator.h"
#include "TaskChk.h"
#include "ResStr.h"
// dialogs used
#include "DetDlg.h"
#include "MonDlg.h"
#include "SetDlg.h"
#include "MainDlg.h"
#include "Working.h"

#include "ErrDct.hpp"
#include "TReg.hpp"
#include "EaLen.hpp"
#include <MigrationMutex.h>
#include <AdsiHelpers.h>
#include <NtLdap.h>
#include "GetDcName.h"

//#define MAX_DB_FIELD 255

// Opertation flags to be performed on the Account
#define OPS_Create_Account          (0x00000001)
#define OPS_Copy_Properties         (0x00000002)
#define OPS_Process_Members         (0x00000004)
#define OPS_Process_MemberOf        (0x00000008)
#define OPS_Call_Extensions         (0x00000010)
#define OPS_All                     OPS_Create_Account | OPS_Copy_Properties | OPS_Process_Members | OPS_Process_MemberOf | OPS_Call_Extensions
#define OPS_Copy                    OPS_Create_Account | OPS_Copy_Properties

BOOL        gbCancelled = FALSE;


bool __stdcall IsAgentOrDispatcherProcessRunning();
DWORD __stdcall SetDomainControllers(IVarSetPtr& spVarSet);

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif


/////////////////////////////////////////////////////////////////////////////
//

BOOL                                       // ret - TRUE if found program directory in the registry
   GetProgramDirectory(
      WCHAR                * filename      // out - buffer that will contain path to program directory
   )
{
    DWORD                     rc = 0;
    BOOL                      bFound = FALSE;
    TRegKey                   key;

    rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
    if ( ! rc )
    {
        rc = key.ValueGetStr(L"Directory",filename,MAX_PATH*sizeof(WCHAR));
        if ( ! rc )
        {
            if ( *filename ) 
                bFound = TRUE;
        }
    }
    return bFound;
}

BOOL                                       // ret - TRUE if found program directory in the registry
   GetLogLevel(
      DWORD                * level         // out - value that should be used for log level
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetDWORD(L"TranslationLogLevel",level);
      if ( ! rc )
      {
         bFound = TRUE;
      }
   }
   return bFound;
}

//----------------------------------------------------------------------------
// Function:   GetAllowSwitching
//
// Synopsis:   Read REG_DWORD value of HKLM\Software\Microsoft\ADMT
//             \DisallowFallbackToAddInProfileTranslation.  If the value is
//             set to 1, *bAllowed is set to FALSE.  Otherwise, *bAllow is
//             set to TRUE.  If there is any error (except for ERROR_FILE_NOT_FOUND) 
//             when reading this key, the rc value will be returned.
//
// Arguments:
//
// bAllowed    Pointer to BOOL
//
// Returns:    ERROR_SUCCESS if successful; otherwise an error code
//
// Modifies:   None
//
//----------------------------------------------------------------------------

DWORD
   GetAllowSwitching(
      BOOL  *bAllowed
   )
{
    DWORD rc = ERROR_SUCCESS;
    DWORD value;
    TRegKey key;

    *bAllowed = TRUE;
    
    rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
    if (rc == ERROR_SUCCESS)
    {
        rc = key.ValueGetDWORD(L"DisallowFallbackToAddInProfileTranslation", &value);
        if (rc == ERROR_SUCCESS)
        {
            if (value == 1)
                *bAllowed = FALSE;
        }
        else if (rc == ERROR_FILE_NOT_FOUND)
            rc = ERROR_SUCCESS;
    }
    return rc;
}

HRESULT CMigrator::ViewPreviousDispatchResults()
{  
    _bstr_t          logFile;
    if ( logFile.length() == 0 )
    {
        WCHAR                   path[MAX_PATH];

        if (!GetProgramDirectory(path))
        {
            DWORD rc = GetLastError();
            return HRESULT_FROM_WIN32(rc);
        }

        logFile = path;
        logFile += L"Logs\\Dispatcher.csv";
    }

    // reset the stats, so that we don't see anything left over from the previous run
    gData.Initialize();

    CPropertySheet   mdlg;
    CAgentMonitorDlg listDlg;
    CMainDlg         summaryDlg;
    CLogSettingsDlg  settingsDlg;


    listDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
    summaryDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
    settingsDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;

    mdlg.AddPage(&summaryDlg);
    mdlg.AddPage(&listDlg);
    mdlg.AddPage(&settingsDlg);

    settingsDlg.SetImmediateStart(TRUE);
    settingsDlg.SetDispatchLog(logFile);

    mdlg.SetActivePage(&listDlg);

    //   UINT nResponse = mdlg.DoModal();
    UINT_PTR nResponse = mdlg.DoModal();

    return S_OK;
}


// WaitForAgentsToFinish Method
//
// Waits for dispatcher and all dispatched agents to complete
// their tasks.
// Used when ADMT is run from script or command line.

static void WaitForAgentsToFinish(_bstr_t strLogPath)
{
    gData.SetLogPath(strLogPath);

    CloseHandle(CreateThread(NULL, 0, &ResultMonitorFn,      NULL, 0, NULL));
    CloseHandle(CreateThread(NULL, 0, &LogReaderFn,          NULL, 0, NULL));

    LARGE_INTEGER liDueTime;
    liDueTime.QuadPart = -50000000; // 5 sec

    HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

    for (int nState = 0; nState < 3;)
    {
        SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, FALSE);

        if (WaitForSingleObject(hTimer, INFINITE) == WAIT_OBJECT_0)
        {
            BOOL bDone = FALSE;

            switch (nState)
            {
                case 0: // first pass of dispatcher log
                {
                    gData.GetFirstPassDone(&bDone);
                    break;
                }
                case 1: // dispatcher finished
                {
                    gData.GetLogDone(&bDone);
                    break;
                }
                case 2: // agents finished
                {
                    gData.GetDone(&bDone);
                    break;
                }
            }

            if (bDone)
            {
                ++nState;
            }
        }
        else
        {
            break;
        }
    }

    CloseHandle(hTimer);

}

//----------------------------------------------------------------------------
// Function:   LogAgentStatus
//
// Synopsis:   Create an agent status summary section which looks like the
//             following:
//
//             ***** start of agent completion status summary *****
//             Monitoring was stopped early so some agents might still be running ...
//             Machine Name     Completion Status   Error Message   Log File Path
//             .....
//             ***** end of agent completion status summary *****
//
//             The line "Monitoring was stopped early ..." is added only when
//             the user stops the monitoring before all agents have completed.
//
// Arguments:
//   teErrLog:                  the error log pointer to write status summary to
//   tslServerList:             the list of server nodes
//   bForcedToStopMonitoring:   the monitoring was forced to stop by the user
//
// Returns:
//
// Modifies:   It updates the bstrStatusForLogging, bstrErrorMessageForLogging
//             and dwStatusForLogging member variables.
//
//----------------------------------------------------------------------------

void LogAgentStatus(TError& teErrLog, TServerList* tslServerList, BOOL bForcedToStopMonitoring)
{
    CString cstrPrelog;
    CString cstrForcedToStopMonitoring;
    CString cstrEpilog;
    CString cstrMachineNameTitle;
    CString cstrCompletionStatusTitle;
    CString cstrErrorMessageTitle;
    CString cstrLogFilePathTitle;

    cstrPrelog.LoadString(IDS_CompletionStatusLoggingPrelog);
    cstrForcedToStopMonitoring.LoadString(IDS_CompletionStatusLoggingForcedToStopMonitoring);
    cstrEpilog.LoadString(IDS_CompletionStatusLoggingEpilog);
    cstrMachineNameTitle.LoadString(IDS_CompletionStatusLoggingMachineNameTitle);
    cstrCompletionStatusTitle.LoadString(IDS_CompletionStatusLoggingCompletionStatusTitle);
    cstrErrorMessageTitle.LoadString(IDS_CompletionStatusLoggingErrorMessageTitle);
    cstrLogFilePathTitle.LoadString(IDS_CompletionStatusLoggingLogFilePathTitle);
    int maxServerNameLen = wcslen((LPCWSTR)cstrMachineNameTitle);
    int maxCompletionStatusLen = wcslen((LPCWSTR)cstrCompletionStatusTitle);
    int maxErrorMessageLen = wcslen((LPCWSTR)cstrErrorMessageTitle);
    int maxLogFilePathLen = wcslen((LPCWSTR)cstrLogFilePathTitle);
    int maxStatus = 0;

    // print prelog
    teErrLog.MsgWrite(0, (LPCWSTR)cstrPrelog);
    if (bForcedToStopMonitoring)
        teErrLog.MsgWrite(0, (LPCWSTR)cstrForcedToStopMonitoring);

    TNodeListEnum e;
    TServerNode* pNode;

    typedef std::multimap<DWORD, TServerNode*> CStatusToServerNode;
    CStatusToServerNode aMap;

    // calculate the maximum length for each column and sort nodes based on the completion status
    for (pNode = (TServerNode*)e.OpenFirst(tslServerList); pNode; pNode = (TServerNode*)e.Next())
    {
        pNode->PrepareForLogging();
        int len;

        len = wcslen(pNode->GetServer());
        if (maxServerNameLen < len)
            maxServerNameLen = len;

        len = wcslen(pNode->GetStatusForLogging());
        if (maxCompletionStatusLen < len)
            maxCompletionStatusLen = len;
        
        len = wcslen(pNode->GetErrorMessageForLogging());
        if (maxErrorMessageLen < len)
            maxErrorMessageLen = len;

        len = wcslen(pNode->GetLogPath());
        if (maxLogFilePathLen < len)
            maxLogFilePathLen = len;

        aMap.insert(CStatusToServerNode::value_type(pNode->GetStatusNumberForLogging(), pNode));
    }

    // determine the table format
    WCHAR format[100];
    int bufSize = sizeof(format)/sizeof(format[0]);
    if (_snwprintf(format,
                   bufSize,
                   L"%%-%ds\t%%-%ds\t%%-%ds\t%%-%ds",
                   maxServerNameLen,
                   maxCompletionStatusLen,
                   maxErrorMessageLen,
                   maxLogFilePathLen) < 0)
        format[bufSize - 1] = L'\0';

    // print out the column names
    teErrLog.MsgWrite(0,
                       format,
                       (LPCWSTR)cstrMachineNameTitle,
                       (LPCWSTR)cstrCompletionStatusTitle,
                       (LPCWSTR)cstrErrorMessageTitle,
                       (LPCWSTR)cstrLogFilePathTitle);

    // print out the agent completion status information, sorted by completion status
    for (CStatusToServerNode::const_iterator it = aMap.begin(); it != aMap.end(); it++)
    {
        pNode = it->second;
        teErrLog.MsgWrite(0,
                          format,
                          pNode->GetServer(),
                          pNode->GetStatusForLogging(),
                          pNode->GetErrorMessageForLogging(),
                          pNode->GetLogPath());
    }
    // print epilog
    teErrLog.MsgWrite(0, (LPCWSTR)cstrEpilog);
    
}

STDMETHODIMP CMigrator::PerformMigrationTask(IUnknown* punkVarSet, LONG_PTR hWnd)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVS = punkVarSet;
   BSTR                      jobID = NULL;
   CWnd                      wnd;
   long                      lActionID = -2;
   IIManageDBPtr             pDb;
   _bstr_t                   wizard = pVS->get(L"Options.Wizard");
   _bstr_t                   undo;
   _bstr_t                   viewPreviousResults = pVS->get(L"MigrationDriver.ViewPreviousResults");
   bool                      bAnyToDispatch = true;
   long                      lAutoCloseHideDialogs = pVS->get(GET_BSTR(DCTVS_Options_AutoCloseHideDialogs));

   // if agent or dispatcher process still running...

   if (IsAgentOrDispatcherProcessRunning())
   {
      // return error result
      return MIGRATOR_E_PROCESSES_STILL_RUNNING;
   }

   hr = pDb.CreateInstance(__uuidof(IManageDB));

   if (FAILED(hr))
   {
      return hr;
   }

   gbCancelled = FALSE;
   // This provides an easy way to view the previous dispatch results
   if ( !UStrICmp(viewPreviousResults,GET_STRING(IDS_YES)) )
   {
      return ViewPreviousDispatchResults();
   }

   if (_bstr_t(pVS->get(GET_BSTR(DCTVS_Options_DontBeginNewLog))) != GET_BSTR(IDS_YES))
   {
      // begin a new log
      TError err;
      err.LogOpen(_bstr_t(pVS->get(GET_BSTR(DCTVS_Options_Logfile))), 0, 0, true);
      err.LogClose();
   }

   // get the setting for whether to allow switching from REPLACE to ADD for profile translation
   BOOL bAllowed = TRUE;
   GetAllowSwitching(&bAllowed);
   pVS->put(GET_BSTR(DCTVS_Options_AllowSwitchingFromReplaceToAddInProfileTranslation),
            bAllowed ? GET_BSTR(IDS_YES) : GET_BSTR(IDS_No));
   
   // update the log level, if needed
   DWORD                level = 0;

   if( GetLogLevel(&level) )
   {
      pVS->put(GET_BSTR(DCTVS_Options_LogLevel),(long)level);
   }

   undo = pVS->get(GET_BSTR(DCTVS_Options_Undo));
   if ( !_wcsicmp((WCHAR*) undo, GET_STRING(IDS_YES)) )
   {
      hr = pDb->raw_GetCurrentActionID(&lActionID);
      if ( SUCCEEDED(hr) )
         pVS->put(L"UndoAction", lActionID);
      hr = pDb->raw_GetNextActionID(&lActionID);
      hr = 0;
   }
   else
   {
      hr = pDb->raw_GetNextActionID(&lActionID);
      if ( SUCCEEDED(hr) )
      {
         pVS->put(L"ActionID",lActionID);
         _bstr_t password2 = pVS->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
      
         pVS->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),L"");

         hr = pDb->raw_SetActionHistory(lActionID, punkVarSet);
      
         pVS->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),password2);
         if ( FAILED(hr) ) 
         {
            // log a message, but don't abort the whole operation
            hr = S_OK;
         }
      }
   }
   // This sets up any varset keys needed internally for reports to be generated
   PreProcessForReporting(pVS);
   wnd.Attach((HWND)hWnd);

   // set preferred domain controllers to be used
   // by the account replicator and dispatched agents

   DWORD dwError = SetDomainControllers(pVS);

   if (dwError != ERROR_SUCCESS)
   {
       return HRESULT_FROM_WIN32(dwError);
   }

   // Run the local agent first, if needed to copy any accounts
   if ( NeedToRunLocalAgent(pVS) )
   {
      IDCTAgentPtr pAgent;

      hr = pAgent.CreateInstance(__uuidof(DCTAgent));

      if (SUCCEEDED(hr))
      {
         hr = pAgent->raw_SubmitJob(punkVarSet,&jobID);

         if ( SUCCEEDED(hr) )
         {
            // since this is a local agent, we should go ahead and signal Ok to shut down
            // the reason HRESULT is not checked is that when there is no reference to 
            // agent COM server, it will be shut down anyway
            pAgent->raw_SignalOKToShutDown();
                
            CAgentDetailDlg  detailDlg(&wnd);
            
            detailDlg.SetJobID(jobID);

            // based on the type of migration, set the format correspondingly
            // it used to be set to acct repl always
            // since Exchange migration uses local agent as well, we need to single out
            // Exchange migration case
            _bstr_t text = pVS->get(GET_BSTR(DCTVS_Security_TranslateContainers));
            if (text.length())
                detailDlg.SetFormat(2);
            else
                detailDlg.SetFormat(1); // acct repl stats
            
            
            // if we're only copying a few accounts, default the refresh rate to a lower value, since the 
            // process may finish before the refresh can happen
            long             nAccounts = pVS->get(GET_BSTR(DCTVS_Accounts_NumItems));
            
            if ( nAccounts <= 20 )
            {
               detailDlg.SetRefreshInterval(1);
            }
            else
            {
               detailDlg.SetRefreshInterval(5);
            }

            _bstr_t        logfile = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
            
            detailDlg.SetLogFile((WCHAR*)logfile);
            detailDlg.SetAutoCloseHide(lAutoCloseHideDialogs);

            UINT_PTR  nResponse = detailDlg.DoModal();
         }
      }
   } 
   if ( gbCancelled )
   {
      // if the local operation was cancelled, don't dispatch the agents
      wnd.Detach();
      return S_OK;
   }

   // now run the dispatcher
   if ( SUCCEEDED(hr) )
   {
      // there's no need to dispatch agents to do translation or migration 
      // if we were not able to copy the accounts
      if ( NeedToDispatch(pVS) )
      {
         IDCTDispatcherPtr   pDispatcher;

         hr = pDispatcher.CreateInstance(CLSID_DCTDispatcher);
         if ( SUCCEEDED(hr) )
         {
            // Call the dispatch preprocessor.
            PreProcessDispatcher(pVS);

            // make sure we're not going to lock out any computers by migrating them to a domain where they
            // don't have a good computer account
            hr = TrimMigratingComputerList(pVS, &bAnyToDispatch);
            if (SUCCEEDED(hr) && bAnyToDispatch)
            {
                CWorking          tempDlg(IDS_DISPATCHING);

                if (lAutoCloseHideDialogs == 0)
                {
                    tempDlg.Create(IDD_PLEASEWAIT);
                    tempDlg.ShowWindow(SW_SHOW);
                }
                // give the dialog a change to process messages
                CWnd                    * wnd = AfxGetMainWnd();
                MSG                       msg;

                while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
                { 
                   if ( ! AfxGetApp()->PumpMessage() ) 
                   {
                      break;
                   } 
                }
                AfxGetApp()->DoWaitCursor(0);
                  
                _bstr_t          logFile = pVS->get(GET_BSTR(DCTVS_Options_DispatchCSV));
                WCHAR            path[MAX_PATH] = L"";
                DWORD rc;
            
                if (!GetProgramDirectory(path))
                {
                    rc = GetLastError();
                    hr = HRESULT_FROM_WIN32(rc);
                }

                if (SUCCEEDED(hr))
                {
                    if ( logFile.length() == 0 )
                    {
                        logFile = path;
                        logFile += L"Logs\\Dispatcher.csv";
                        pVS->put(GET_BSTR(DCTVS_Options_DispatchCSV),logFile);
                    }

                    // clear the CSV log file if it exists, so we will not get old information in it
                    if ( ! DeleteFile(logFile) )
                    {
                        rc = GetLastError();
                        // it is OK if the file is not there
                        if (rc == ERROR_FILE_NOT_FOUND || rc == ERROR_PATH_NOT_FOUND)
                            rc = ERROR_SUCCESS;
                        hr = HRESULT_FROM_WIN32(rc);
                        if (FAILED(hr))
                        {
                            TErrorDct errLog;
                            WCHAR errText[LEN_Path];
                            _bstr_t errMsg = errLog.GetMsgText(DCT_MSG_CANNOT_REMOVE_OLD_INTERNAL_DISPATCH_LOG_S,
                                                                errLog.ErrorCodeToText(rc, DIM(errText), errText));
                            WCHAR* message = (WCHAR*) errMsg;
                            message[wcslen(message)-1] = L'\0';  // there is a trailing CR
                            Error(message, GUID_NULL, hr);
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // set up the location for the agents to write back their results
                    logFile = path;
                    logFile += L"Logs\\Agents\\";
                    _bstr_t logsPath = path;
                    logsPath += L"Logs";
                    if (!CreateDirectory(logsPath,NULL))
                    {
                        rc = GetLastError();
                        // it is OK if the directory already exists
                        if (rc == ERROR_ALREADY_EXISTS)
                            rc = ERROR_SUCCESS;
                        hr = HRESULT_FROM_WIN32(rc);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // logFile is "...\\Logs\\Agents\\"
                    if ( ! CreateDirectory(logFile,NULL) )
                    {
                        rc = GetLastError();
                        // it is OK if the directory already exists
                        if (rc == ERROR_ALREADY_EXISTS)
                            rc = ERROR_SUCCESS;
                        hr = HRESULT_FROM_WIN32(rc);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    pVS->put(GET_BSTR(DCTVS_Dispatcher_ResultPath),logFile);
                    punkVarSet->AddRef();
                    hr = pDispatcher->raw_DispatchToServers(&punkVarSet);
                }

                if (lAutoCloseHideDialogs == 0)
                {
                    tempDlg.ShowWindow(SW_HIDE);
                }
                if ( SUCCEEDED(hr) )
                {
                    // reset the stats, so that we don't see anything left over from the previous run
                    gData.Initialize();

                    logFile = pVS->get(GET_BSTR(DCTVS_Options_DispatchCSV));

                    if (lAutoCloseHideDialogs == 0)
                    {
                        CPropertySheet   mdlg;
                        CAgentMonitorDlg listDlg;
                        CMainDlg         summaryDlg;
                        CLogSettingsDlg  settingsDlg;
                        CString          title;

                        title.LoadString(IDS_MainWindowTitle);

                        listDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
                        summaryDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
                        settingsDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;

                        mdlg.AddPage(&summaryDlg);
                        mdlg.AddPage(&listDlg);
                        mdlg.AddPage(&settingsDlg);

                        settingsDlg.SetImmediateStart(TRUE);
                        settingsDlg.SetDispatchLog(logFile);

                        // this determines whether the stats for security translation will be displayed in the agent detail
                        if ( NeedToUseST(pVS,TRUE) ) 
                        {
                          listDlg.SetSecurityTranslationFlag(TRUE);
                        }
                        else
                        {
                          listDlg.SetSecurityTranslationFlag(FALSE);
                        }

                        if( !UStrICmp(wizard,L"reporting") )
                        {
                          listDlg.SetReportingFlag(TRUE);
                        }
                        mdlg.SetActivePage(&listDlg);

                        mdlg.SetTitle(title);

                        UINT_PTR nResponse = mdlg.DoModal();
                    }
                    else
                    {
                        WaitForAgentsToFinish(logFile);
                    }

                   //
                   // log the agent completion status into migration log
                   //

                   TError err;

                   // open the migration log
                   err.LogOpen(_bstr_t(pVS->get(GET_BSTR(DCTVS_Options_Logfile))), 1);

                   // log the completion status information
                   gData.Lock();
                   BOOL bForcedToStopMonitoring = FALSE;
                   gData.GetForcedToStopMonitoring(&bForcedToStopMonitoring);
                   LogAgentStatus(err, gData.GetUnsafeServerList(), bForcedToStopMonitoring);
                   gData.Unlock();

                   // close the migration log
                   err.LogClose();
                   
                   // store results to database
                   TNodeListEnum        e;
                   TServerNode        * pNode;

                   // if we are retrying an operation, don't save it to the database again!
                   for ( pNode = (TServerNode*)e.OpenFirst(gData.GetUnsafeServerList()) ; pNode ; pNode = (TServerNode*)e.Next() )
                   {
                      if ( UStrICmp(wizard,L"retry") ) 
                      {
               
                         hr = pDb->raw_AddDistributedAction(SysAllocString(pNode->GetServer()),SysAllocString(pNode->GetJobPath()),pNode->GetStatus(),pNode->GetMessageText());
                         if ( FAILED(hr) )
                         {
                            hr = S_OK;
                         }
                      }
                      else
                      {
                         hr = pDb->raw_SetDistActionStatus(-1,pNode->GetJobPath(),pNode->GetStatus(),pNode->GetMessageText());
                         if ( FAILED(hr) )
                         {
                            hr = S_OK;
                         }
                      }
                   }

                }
            }
            // Call the Dispatcher post processor
            PostProcessDispatcher(pVS);
         }
      }
      if ( NeedToRunReports(pVS) )
      {
         RunReports(pVS);
      }
   }
   wnd.Detach();
   // Reset the undo flag so that next wizard does not have to deal with it.
//*   pVS->put(GET_BSTR(DCTVS_Options_Undo), L"No");
   pVS->put(GET_BSTR(DCTVS_Options_Undo), GET_BSTR(IDS_No));
   return hr;
}

STDMETHODIMP CMigrator::GetTaskDescription(IUnknown *pVarSet,/*[out]*/BSTR * pDescription)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   IVarSetPtr                pVS = pVarSet;
   CString                   str;
   _bstr_t                   wizard = pVS->get(L"Options.Wizard");
   _bstr_t                   undo   = pVS->get(GET_BSTR(DCTVS_Options_Undo));
//*   if ( !_wcsicmp((WCHAR*) undo, L"Yes") )
   if ( !_wcsicmp((WCHAR*) undo, GET_STRING(IDS_YES)) )
   {
      str.FormatMessage(IDS_Undo);
      BuildGeneralDesc(pVS, str);
      BuildUndoDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"user") )
   {
      str.FormatMessage(IDS_UserMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"group") )
   {
      str.FormatMessage(IDS_GroupMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      str.FormatMessage(IDS_ComputerMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
      BuildSecTransDesc(pVS,str,TRUE);
      BuildDispatchDesc(pVS,str);
  
   }
   else if ( !UStrICmp(wizard,L"security") )
   {
      str.FormatMessage(IDS_SecurityTranslation);
      BuildSecTransDesc(pVS,str,TRUE);
      BuildDispatchDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"reporting") )
   {
      str.FormatMessage(IDS_ReportGeneration);
      BuildReportDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"retry") )
   {
      str.FormatMessage(IDS_RetryTasks);
   }
   else if ( ! UStrICmp(wizard,L"service") )
   {
      str.FormatMessage(IDS_Service);
   }
   else if ( ! UStrICmp(wizard,L"trust") )
   {
      str.FormatMessage(IDS_TrustManagement);
   }
   else if ( !UStrICmp(wizard,L"exchangeDir") )
   {
      BuildSecTransDesc(pVS,str,TRUE);
   }
   else if ( !UStrICmp(wizard,L"groupmapping") )
   {
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
      BuildGroupMappingDesc(pVS,str);
   }
   (*pDescription) = str.AllocSysString();
   return S_OK;
}



STDMETHODIMP CMigrator::GetUndoTask(IUnknown * pVarSet,/*[out]*/ IUnknown ** ppVarSetOut)
{
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSetIn = pVarSet;
   IVarSetPtr                pVarSetOut;
   
   (*ppVarSetOut) = NULL;
   
   hr = pVarSetOut.CreateInstance(CLSID_VarSet);
   if ( SUCCEEDED(hr) )
   {
      hr = ConstructUndoVarSet(pVarSetIn,pVarSetOut);
      
      pVarSetOut->AddRef();
      (*ppVarSetOut) = pVarSetOut;
   }
    
   return hr;
}

HRESULT CMigrator::ProcessServerListForUndo(IVarSet * pVarSet)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   srcName;
   _bstr_t                   tgtName;
   WCHAR                     keySrc[100];
   WCHAR                     keyTgt[100];
   WCHAR                     keyTmp[100];
   long                      ndx,numItems;

   numItems = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));

   for ( ndx = 0 ; ndx < numItems ; ndx++ )
   {
      // if the computer was renamed, swap the source and target names
      swprintf(keySrc,GET_STRING(DCTVSFmt_Servers_D),ndx);
      swprintf(keyTgt,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
      srcName = pVarSet->get(keySrc);
      tgtName = pVarSet->get(keyTgt);

      if ( tgtName.length() )
      {
         if ( ((WCHAR*)tgtName)[0] != L'\\' )
           { 
            // ensure that tgtName has \\ prefix
            tgtName = L"\\\\" + tgtName;
         }
         if ( ((WCHAR*)srcName)[0] == L'\\' )
         {
            // remove the \\ prefix from the new name
            srcName = ((WCHAR*)srcName)+2;
         }
           pVarSet->put(keySrc,tgtName);
         pVarSet->put(keyTgt,srcName);
      }
      swprintf(keyTmp,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
      pVarSet->put(keyTmp,GET_BSTR(IDS_YES));
      swprintf(keyTmp,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
      pVarSet->put(keyTmp,GET_BSTR(IDS_YES));
   }

   return hr;
}
HRESULT CMigrator::BuildAccountListForUndo(IVarSet * pVarSet,long actionID)
{
   HRESULT                   hr = S_OK;
   WCHAR                     key[200];
   long                      ndx;
   _bstr_t                   srcPath;
   IIManageDBPtr             pDB;
   IVarSetPtr                pVarSetTemp(CLSID_VarSet);
   IUnknown                * pUnk = NULL;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetTemp.QueryInterface(IID_IUnknown,&pUnk);
      if ( SUCCEEDED(hr) )
      {
         hr = pDB->raw_GetMigratedObjects(actionID,&pUnk);
      }
      if ( SUCCEEDED(hr) )
      {
         pUnk->Release();
         srcPath = L"Test";
         swprintf(key,L"MigratedObjects");
         long numMigrated = pVarSetTemp->get(key);
         for ( ndx = 0 ; srcPath.length() ; ndx++ )
         {
            swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_SourceAdsPath));
            srcPath = pVarSetTemp->get(key);

            if ( srcPath.length() )
            {
               // get the object type 
               swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_Type));
               _bstr_t text = pVarSetTemp->get(key);
               swprintf(key,L"Accounts.%ld.Type",ndx);

                  //work-around a fix that places the sourcepath for an
                  //NT 4.0 computer migration
               if ((text != _bstr_t(L"computer")) || (wcsncmp(L"WinNT://", (WCHAR*)srcPath, 8)))
               {
                  // set the object type in the account list
                  pVarSet->put(key,text);
                  // copy the source path to the account list
                  swprintf(key,L"Accounts.%ld",ndx);
                  pVarSet->put(key,srcPath);
                  // set the target path in the account list
                  swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_TargetAdsPath));
                  text = pVarSetTemp->get(key);
                  swprintf(key,L"Accounts.%ld.TargetName",ndx);
                  pVarSet->put(key,text);
               }
            }
         }
         swprintf(key,GET_STRING(DCTVS_Accounts_NumItems));
         pVarSet->put(key,numMigrated);
      }
   }
   return hr;
}
HRESULT CMigrator::ConstructUndoVarSet(IVarSet * pVarSetIn,IVarSet * pVarSetOut)
{
   HRESULT                hr = S_OK;
   IVarSet              * pTemp = NULL;
   _bstr_t                origSource;
   _bstr_t                origTarget;
   _bstr_t                origSourceDns;
   _bstr_t                origTargetDns;
   _bstr_t                origSourceFlat;
   _bstr_t                origTargetFlat;
   _bstr_t                temp;
   _bstr_t                temp2;
   long                   actionID = pVarSetIn->get(L"ActionID");

   // general options
   // mark the varset as an undo operation
   pVarSetOut->put(GET_BSTR(DCTVS_Options_Undo),GET_BSTR(IDS_YES));
   
   temp = pVarSetIn->get(GET_BSTR(DCTVS_Options_NoChange));
   if ( !UStrICmp(temp,GET_STRING(IDS_YES)) )
   {
      // for a no-change mode operation, there's nothing to undo!
      return hr;
   }

   // swap the source and target domains
   origSource = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomain));
   origTarget = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomain));
   origSourceDns = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   origTargetDns = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
   origSourceFlat = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomainFlat));
   origTargetFlat = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomainFlat));

   temp = pVarSetIn->get(GET_BSTR(DCTVS_Options_Logfile));
   temp2 = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchLog));
   
   pVarSetOut->put(GET_BSTR(DCTVS_Options_Logfile),temp);
   // For inter-forest, leave the domain names as they were
   pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origSource);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origTarget);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origSourceDns);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origTargetDns);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainFlat),origSourceFlat);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainFlat),origTargetFlat);

   // copy the account list
   hr = pVarSetIn->raw_getReference(GET_BSTR(DCTVS_Accounts),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(GET_BSTR(DCTVS_Accounts),pTemp);
      if ( SUCCEEDED(hr) )
      {
         BuildAccountListForUndo(pVarSetOut,actionID);
      }
      pTemp->Release();
   }

   hr = pVarSetIn->raw_getReference(SysAllocString(L"AccountOptions"),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(SysAllocString(L"AccountOptions"),pTemp);
      pTemp->Release();
   }

   // and the server list
   hr = pVarSetIn->raw_getReference(GET_BSTR(DCTVS_Servers),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(GET_BSTR(DCTVS_Servers),pTemp);
      if ( SUCCEEDED(hr) )
      {
         ProcessServerListForUndo(pVarSetOut);
         pTemp->Release();
      }
   }

   LONG                       bSameForest = FALSE;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr          pAccess;
   
   hr = pAccess.CreateInstance(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));

   if ( SUCCEEDED(hr) )
   {
      hr = pAccess->raw_IsInSameForest(origSourceDns,origTargetDns,&bSameForest);
      if ( hr == 8250 )
      {
         hr = 0;
         bSameForest = FALSE;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      // for account migration, need to check whether we're cloning, or moving accounts
      if ( ! bSameForest ) // cloning accounts
      {
         // Since we cloned the accounts we need to delete the target accounts.
         // We will call the account replicator to do this. We will also call 
         // the undo function on all the registered extensions. This way the extensions
         // will have a chance to cleanup after themselves in cases of UNDO.
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origSource);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origTarget);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origSourceDns);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origTargetDns);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainFlat),origSourceFlat);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainFlat),origTargetFlat);
      }
      else     // moving, using moveObject
      {
         // swap the source and target, and move them back, using the same options as before
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origTarget);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origSource);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origTargetDns);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origSourceDns);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainFlat),origTargetFlat);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainFlat),origSourceFlat);


      }
   }
   // if migrating computers, swap the source and target domains, and call the dispatcher again to move them back to the source domain
   _bstr_t           comp = pVarSetIn->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(comp,GET_STRING(IDS_YES)) )
   {
      pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origTarget);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origSource);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origTargetDns);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origSourceDns);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainFlat),origTargetFlat);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainFlat),origSourceFlat);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_DispatchLog),temp2);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_Wizard),L"computer");
   }
   
   // security translation - don't undo


   return S_OK;
}

HRESULT CMigrator::SetReportDataInRegistry(WCHAR const * reportName,WCHAR const * filename)
{
   TRegKey                   hKeyReports;
   DWORD                     rc;

   rc = hKeyReports.Open(GET_STRING(IDS_REGKEY_REPORTS));
 
   // if the "Reports" registry key does not already exist, create it
   if ( rc == ERROR_FILE_NOT_FOUND )
   {
      rc = hKeyReports.Create(GET_STRING(IDS_REGKEY_REPORTS));   
   }
   if ( ! rc )
   {
      rc =  hKeyReports.ValueSetStr(reportName,filename);
   }
   return HRESULT_FROM_WIN32(rc);
}   

HRESULT CMigrator::RunReports(IVarSet * pVarSet)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   directory = pVarSet->get(GET_BSTR(DCTVS_Reports_Directory));
   _bstr_t                   srcdm = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                   tgtdm = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   long                      lAutoCloseHideDialogs = pVarSet->get(GET_BSTR(DCTVS_Options_AutoCloseHideDialogs));
   IIManageDBPtr             pDB;
   int                       ver;
   BOOL                      bNT4Dom = FALSE;
   CWorking                  tempDlg(IDS_NAMECONFLICTS);
   CWnd                    * wnd = NULL;
   MSG                       msg;

   if (lAutoCloseHideDialogs == 0)
   {
      tempDlg.Create(IDD_PLEASEWAIT);

      tempDlg.ShowWindow(SW_SHOW);
      tempDlg.m_strMessage.LoadString(IDS_STATUS_GeneratingReports);
      tempDlg.UpdateData(FALSE);

      wnd = AfxGetMainWnd();

      while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
      { 
         if ( ! AfxGetApp()->PumpMessage() ) 
         {
            break;
         } 
      }
      AfxGetApp()->DoWaitCursor(0);
   }


      //get the source domain OS version
   ver = GetOSVersionForDomain(srcdm);
   if (ver < 5)
      bNT4Dom = TRUE;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {

      // Migrated users and groups report
      _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedAccounts));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the migrated users and groups report
         CString           filename;

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"MigrAcct.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"MigratedAccounts"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"MigratedAccounts",filename);
         }

      }
      
      // migrated computers report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the migrated computers report
         CString           filename;

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"MigrComp.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"MigratedComputers"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"MigratedComputers",filename);
         }

      }

      // expired computers report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the expired computers report
         CString           filename;

         // clear the extra settings from the varset 
         pVarSet->put(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge),SysAllocString(L""));

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"ExpComp.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"ExpiredComputers"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"ExpiredComputers",filename);
         }

      }

          // account references report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the account references report
         CString           filename;
         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"AcctRefs.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"AccountReferences"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"AccountReferences",filename);
         }
         // clear the extra settings from the varset
         pVarSet->put(GET_BSTR(DCTVS_Security_GatherInformation),GET_BSTR(IDS_No));
         pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),GET_BSTR(IDS_No));
      }

      // name conflict report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_NameConflicts));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         if (lAutoCloseHideDialogs == 0)
         {
            AfxGetApp()->DoWaitCursor(1);
            // run the name conflicts report
            tempDlg.m_strMessage.LoadString(IDS_STATUS_Gathering_NameConf);
            tempDlg.UpdateData(FALSE);

            while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) )
            {
               if ( ! AfxGetApp()->PumpMessage() )
               {
                  break;
               }
            }
         }

         //fill the account table in the database
         PopulateDomainDBs(pVarSet, pDB);

         if (lAutoCloseHideDialogs == 0)
         {
            tempDlg.m_strMessage.LoadString(IDS_STATUS_GeneratingReports);
            tempDlg.UpdateData(FALSE);

            while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
            { 
               if ( ! AfxGetApp()->PumpMessage() ) 
               {
                  break;
               } 
            }
            AfxGetApp()->DoWaitCursor(0);
         }

         CString filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"NameConf.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"NameConflicts"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"NameConflicts",filename);
         }
      }

      if (lAutoCloseHideDialogs == 0)
      {
         tempDlg.ShowWindow(SW_HIDE);
      }
   }

   if (lAutoCloseHideDialogs == 0)
   {
      AfxGetApp()->DoWaitCursor(-1);
   }

   return hr;
}

//--------------------------------------------------------------------------
// PreProcessDispatcher : Pre processor swaps the source and target domains
//                        in case of UNDO so that the computers can be 
//                        joined back to the source domain.
//--------------------------------------------------------------------------
void CMigrator::PreProcessDispatcher(IVarSet * pVarSet)
{
   _bstr_t  sUndo = pVarSet->get(L"Options.Wizard");
   
   // In the service account migration wizard, turn off any security translation tasks
   if ( !_wcsicmp(sUndo,L"service") )
   {
      IVarSet * pVS2 = NULL;
      
      HRESULT hr = pVarSet->raw_getReference(L"Security",&pVS2);
      if ( SUCCEEDED(hr) )
      {
         pVS2->Clear();
         pVS2->Release();
      }
   }
}

//--------------------------------------------------------------------------
// PostProcessDispatcher : Swaps the source and target domains back. Also sets
//                         the Undo option to no.
//--------------------------------------------------------------------------
void CMigrator::PostProcessDispatcher(IVarSet * pVarSet)
{
   _bstr_t  sUndo = pVarSet->get(L"Options.Wizard");
   _bstr_t  origSource = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t  origTarget = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   if ( !_wcsicmp(sUndo, L"undo") )
   {
      pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomain), origTarget);
      pVarSet->put(GET_BSTR(DCTVS_Options_TargetDomain), origSource);
   }
}

void CMigrator::PreProcessForReporting(IVarSet * pVarSet)
{
   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));

   IVarSet * pVs = NULL;

   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      // we are generating reports
      // some reports require additional information gathering.  We will set up the necessary varset
      // keys to gather the information
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)))
      {
         // we need to gather the computer password age from the computers in the domain
         pVarSet->put(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge),GET_BSTR(IDS_YES));
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)))
      {
         // clean up all the Security translation flags so that we dont end up doing 
         // something that we were not supposed to.
         HRESULT hr = pVarSet->raw_getReference(GET_BSTR(DCTVS_Security), &pVs);
         if ( pVs )
         {
            pVs->Clear();
            pVs->Release();
         }
         // for this one, we need to gather information from the selected computers
         pVarSet->put(GET_BSTR(DCTVS_Security_GatherInformation),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateFiles),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateShares),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslatePrinters),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateLocalGroups),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateRegistry),GET_BSTR(IDS_YES));
      }
   }
}

HRESULT CMigrator::TrimMigratingComputerList(IVarSet * pVarSet, bool* bAnyToDispatch)
{
    // this functions checks each computer to be migrated, and does not migrate it if the account was not successfully copied
    HRESULT                   hr = S_OK;
    _bstr_t                   text;
    WCHAR                     key[100];
    long                      val,i;
    IIManageDBPtr             pDB;
    _bstr_t                   srcDomain;
    _bstr_t                   tgtDomain;
    _bstr_t                   computer;
    long                      actionID = pVarSet->get(L"ActionID");
    CString                   temp;

    _bstr_t                   origSource = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
    _bstr_t                   origTarget = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

    hr = pDB.CreateInstance(CLSID_IManageDB);
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // If task is undo then mark computers that were successfully migrated for dispatch.
    //

    *bAnyToDispatch = false;
    text = pVarSet->get(GET_BSTR(DCTVS_Options_Undo));
    if (! UStrICmp(text,GET_STRING(IDS_YES)))
    {
        _bstr_t strYes = GET_BSTR(IDS_YES);
        _bstr_t strNo = GET_BSTR(IDS_No);
        _bstr_t strServersFormat = GET_BSTR(DCTVSFmt_Servers_D);
        _bstr_t strServersDnsFormat = GET_BSTR(IDS_DCTVSFmt_Servers_DnsName_D);
        _bstr_t strServersRenameToFormat = GET_BSTR(IDS_DCTVSFmt_Servers_RenameTo_D);
        _bstr_t strServersSkipDispatchFormat = GET_BSTR(IDS_DCTVSFmt_Servers_SkipDispatch_D);

        //
        // For each server that was acted upon during migration task.
        //

        long cServer = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
        long lActionId = pVarSet->get(L"UndoAction");

        for (long iServer = 0; iServer < cServer; iServer++)
        {
            bool bSucceeded = false;

            //
            // Retrieve original source computer name without leading UNC prefix.
            // If the computer was re-named during the migration the original
            // name is stored in 'Servers.#.TargetName' without a UNC prefix
            // otherwise the name is stored in 'Servers.#' with a UNC prefix.
            //

            _bstr_t strServerName;

            if (_snwprintf(key, sizeof(key) / sizeof(key[0]), strServersRenameToFormat, iServer) < 0)
            {
                return E_FAIL;
            }

            key[sizeof(key) / sizeof(key[0]) - 1] = L'\0';

            strServerName = pVarSet->get(key);

            if (strServerName.length() == 0)
            {
                _snwprintf(key, sizeof(key) / sizeof(key[0]), strServersFormat, iServer);
                key[sizeof(key) / sizeof(key[0]) - 1] = L'\0';
                _bstr_t strServerNamePrefixed = pVarSet->get(key);

                if (strServerNamePrefixed.length() > 2)
                {
                    strServerName = (PCWSTR)strServerNamePrefixed + 2;
                }
            }

            //
            // If computer previously had a DNS name then bind to computer object to
            // retrieve current DNS name. This will be used to connec to the computer.
            //

            if (_snwprintf(key, sizeof(key) / sizeof(key[0]), strServersDnsFormat, iServer) < 0)
            {
                return E_FAIL;
            }
            key[sizeof(key) / sizeof(key[0]) - 1] = L'\0';

            _bstr_t strOldServerNameDns = pVarSet->get(key);

            if (strOldServerNameDns.length())
            {
                IVarSetPtr spVarSet(CLSID_VarSet);
                IUnknownPtr spUnknown(spVarSet);
                IUnknown* punk = spUnknown;

                hr = pDB->raw_GetAMigratedObject(strServerName + L"$", origTarget, origSource, &punk);

                if (SUCCEEDED(hr))
                {
                    _bstr_t strComputerTargetPath = spVarSet->get(L"MigratedObjects.TargetAdsPath");

                    IADsPtr spComputer;

                    hr = ADsGetObject(strComputerTargetPath, __uuidof(IADs), (VOID**)&spComputer);

                    if (SUCCEEDED(hr))
                    {
                        VARIANT var;
                        VariantInit(&var);
                        hr = spComputer->Get(_bstr_t(L"dNSHostName"), &var);

                        if (SUCCEEDED(hr))
                        {
                            _bstr_t strNewServerNameDns = (_variant_t(var, false));

                            if (_snwprintf(key, sizeof(key) / sizeof(key[0]), strServersDnsFormat, iServer) < 0)
                            {
                                return E_FAIL;
                            }
                            key[sizeof(key) / sizeof(key[0]) - 1] = L'\0';

                            pVarSet->put(key, L"\\\\" + strNewServerNameDns);

                            strServerName = (LPCTSTR)strOldServerNameDns + 2;
                        }
                    }
                }
            }

            //
            // If agent successfully completed task on server then mark succeeded.
            //

            long lStatus = pDB->GetDistributedActionStatus(lActionId, strServerName);

            if ((lStatus & Agent_Status_Finished) && !(lStatus & Agent_Status_Failed))
            {
                bSucceeded = true;
            }

            //
            // If the agent succeeded on this computer then mark not to skip dispatch
            // and also indicate that there are computers to dispatch to. If the agent
            // failed on this computer then mark to skip dispatch.
            //

            _snwprintf(key, sizeof(key) / sizeof(key[0]), strServersSkipDispatchFormat, iServer);
            key[sizeof(key) / sizeof(key[0]) - 1] = L'\0';

            if (bSucceeded)
            {
                pVarSet->put(key, strNo);
                *bAnyToDispatch = true;
            }
            else
            {
                pVarSet->put(key, strYes);
            }
        }

        return S_OK;
    }
    text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
    if (! UStrICmp(text,GET_STRING(IDS_YES)))
    {
        // don't need to trim in nochange mode
        *bAnyToDispatch = true; //say yes run dispatcher if Nochange
        return S_OK;
    }
    srcDomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
    tgtDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
    *bAnyToDispatch = false; //indicate that so far no accounts to dispatch

    val = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
       
    for ( i = 0 ; i < val ; i++ )
    {
        //init the skipDispath flag to "No"
        swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
        pVarSet->put(key,GET_BSTR(IDS_No));

        swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);
        computer = pVarSet->get(key);

        swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),i);
        text = pVarSet->get(key);
        if (! UStrICmp(text,GET_STRING(IDS_YES)) )
        {
            // we are migrating this computer to a different domain
            // check our database to verify that the computer account has been
            // successfully migrated
            computer += L"$";
             
            IVarSetPtr          pVS(CLSID_VarSet);
            IUnknown          * pUnk = NULL;

            hr = pVS->QueryInterface(IID_IUnknown,(void**)&pUnk);
            if ( SUCCEEDED(hr) )
            {
                if ( ((WCHAR*)computer)[0] == L'\\' )
                {
                // leave off the leading \\'s 
                hr = pDB->raw_GetAMigratedObject(SysAllocString(((WCHAR*)computer) + 2),srcDomain,tgtDomain,&pUnk);  
                }
                else
                {
                hr = pDB->raw_GetAMigratedObject(computer,srcDomain,tgtDomain,&pUnk);
                }
                if ( hr == S_OK )
                {
                // the computer was found in the migrated objects table
                // make sure we are using its correct target name, if it has been renamed
                swprintf(key,L"MigratedObjects.TargetSamName");
                _bstr_t targetName = pVS->get(key);
                swprintf(key,L"MigratedObjects.SourceSamName");
                _bstr_t sourceName = pVS->get(key);
                long id = pVS->get(L"MigratedObjects.ActionID");

                if ( UStrICmp((WCHAR*)sourceName,(WCHAR*)targetName) )
                {
                    // the computer is being renamed
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),i);
                    // strip off the $ from the end of the target name, if specified
                    WCHAR             target[LEN_Account];

                    safecopy(target,(WCHAR*)targetName);

                    if ( target[UStrLen(target)-1] == L'$' )
                    {
                        target[UStrLen(target)-1] = 0;
                    }
                    pVarSet->put(key,target);
                }
                      
                if ( id != actionID )
                {
                    // the migration failed, but this computer had been migrated before
                    // don't migrate the computer because it's account in the target domain, won't be reset
                    // and it will therefore be locked out of the domain
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),i);
                    pVarSet->put(key,GET_BSTR(IDS_No));
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),i);
                    pVarSet->put(key,GET_BSTR(IDS_No));
                    swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
                    pVarSet->put(key,GET_BSTR(IDS_YES));
                }
                else
                    *bAnyToDispatch = true; //atleast one server for dispatcher

                }
                else
                {
                // the computer migration failed!
                // don't migrate the computer because it won't have it's account in the target domain,
                // and will therefore be locked out of the domain
                pVarSet->put(key,GET_BSTR(IDS_No));
                swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),i);
                pVarSet->put(key,GET_BSTR(IDS_No));
                swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
                pVarSet->put(key,GET_BSTR(IDS_YES));
            }
                pUnk->Release();
            }
        }
        else
            *bAnyToDispatch = true; //atleast one server for dispatcher
    }
       
    return hr;
}

HRESULT CMigrator::PopulateAccounts(IVarSetPtr pVs)
{
   _bstr_t  origSource = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t  origTarget = pVs->get(GET_BSTR(DCTVS_Options_TargetDomain));

   // Check if the source domain is NT4 or win2k
   // if NT4 then call the NetObjEnum to enumerate the domain. 
   return S_OK;
}

//----------------------------------------------------------------------------
// PopulateDomainDBs : This function coordinates the populating of the Access
//                     DBs for both the source and target domains with the
//                     necessary fields from the AD. 
//----------------------------------------------------------------------------
bool CMigrator::PopulateDomainDBs(
                              IVarSet * pVarSet,      //in- varset with domain names.
                              IIManageDBPtr pDb        //in- an instance of DBManager
                            )
{
/* local variables */
    _bstr_t srcdomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
    _bstr_t tgtdomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

/* function body */
    //populate the DB for the source domain
   PopulateADomainDB(srcdomain, TRUE, pDb);
    //populate the DB for the target domain
   PopulateADomainDB(tgtdomain, FALSE, pDb);

   return true;
}

//----------------------------------------------------------------------------
// PopulateADomainDB : This function looks up the necessary fields from the AD, 
//                    using an MCSNetObjectEnum object, for the given domain 
//                    and populates the corresponding Access DB with that info. 
//----------------------------------------------------------------------------
bool CMigrator::PopulateADomainDB(
                                       WCHAR const *domain,       // in- name of domain to enumerate
                                       BOOL bSource,              // in- whether the domain is the source domain
                                       IIManageDBPtr pDb           // in- an instance of DBManager
                                 )
{
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   WCHAR                     sPath[MAX_PATH];
   WCHAR                     sQuery[MAX_PATH];
   LPWSTR                    sData[] = { L"sAMAccountName", L"ADsPath", L"distinguishedName", L"canonicalName", L"objectSid" };
   HRESULT                   hr;
   long                      nElt = DIM(sData);
   BSTR  HUGEP             * pData = NULL;
   SAFEARRAY               * pszColNames;
   IEnumVARIANT            * pEnum = NULL;
   _variant_t                var;
   bool                      bSuccess = false;
   PCWSTR                    sType[] = { L"USER", L"GROUP", L"COMPUTER" };
   bool                      bW2KDom = false;
   CADsPathName              apnPathName;

   if ( bSource )
      pDb->raw_ClearTable(L"SourceAccounts");
   else
      pDb->raw_ClearTable(L"TargetAccounts");

   pDb->raw_OpenAccountsTable(bSource);

   if (GetOSVersionForDomain(domain) > 4)
   {
      bW2KDom = true;
   }

   // iterate three times once to get USERS, GROUPS, COMPUTERS (mainly for WinNT)
   for (int i = 0; i < 3; i++)
   {
      //
      // If W2K or later setup for an LDAP query otherwise setup to use Net APIs.
      //

      if (bW2KDom)
      {
          //
          // Generate ADsPath in order to query the entire domain.
          //

          wcscpy(sPath, L"LDAP://");
          wcscat(sPath, domain);

          //
          // Generate LDAP query string for the type of object to query.
          //

          switch (i)
          {
          case 0:
              // Query for user objects.
              // Query only for normal account types which filters out trust accounts for example.
              // Note that SAM_NORMAL_USER_ACCOUNT equals 0x30000000 hexadecimal or 805306368 decimal.
              wcscpy(sQuery,
                  L"(&"
                  L"(objectCategory=Person)"
                  L"(|(objectClass=user)(objectClass=inetOrgPerson))"
                  L"(sAMAccountType=805306368)"
                  L")"
              );
              break;
          case 1:
              // Query for group objects.
              wcscpy(sQuery, L"(objectCategory=Group)");
              break;
          case 2:
              // Query for computer objects.
              if (bSource)
              {
                 // only query workstations and member servers as
                 // source domain controllers cannot be migrated
                 swprintf(
                     sQuery,
                     L"(&(objectCategory=Computer)(userAccountControl:%s:=%u))",
                     LDAP_MATCHING_RULE_BIT_AND_W,
                     static_cast<unsigned>(UF_WORKSTATION_TRUST_ACCOUNT)
                 );
              }
              else
              {
                 // query workstations, member servers and domain controllers as source
                 // computer name may conflict with target domain controller name
                 swprintf(sQuery,
                     L"(&"
                     L"(objectCategory=Computer)"
                     L"(|(userAccountControl:%s:=%u)(userAccountControl:%s:=%u))"
                     L")",
                     LDAP_MATCHING_RULE_BIT_AND_W,
                     static_cast<unsigned>(UF_WORKSTATION_TRUST_ACCOUNT),
                     LDAP_MATCHING_RULE_BIT_AND_W,
                     static_cast<unsigned>(UF_SERVER_TRUST_ACCOUNT)
                 );
              }
              break;
          default:
              wcscpy(sQuery, L"");
              break;
          }
      }
      else
      {
          //
          // specify type of object to query for when using net object enumerator on NT4 or earlier domains
          //

          wcscpy(sPath, L"CN=");
          wcscat(sPath, sType[i]);
          wcscat(sPath, L"S");

          wcscpy(sQuery, L"(objectClass=*)");
      }

      // Set the enumerator query
      hr = pQuery->raw_SetQuery(sPath, _bstr_t(domain), sQuery, ADS_SCOPE_SUBTREE, FALSE);

      if (SUCCEEDED(hr))
      {
         // Create a safearray of columns we need from the enumerator.
         SAFEARRAYBOUND bd = { nElt, 0 };
   
         pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
         HRESULT hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
         if ( SUCCEEDED(hr) )
         {
            for( long i = 0; i < nElt; i++)
            {
               pData[i] = SysAllocString(sData[i]);
            }
   
            hr = ::SafeArrayUnaccessData(pszColNames);
         }

         if (SUCCEEDED(hr))
         {
            // Set the columns on the enumerator object.
            hr = pQuery->raw_SetColumns(pszColNames);
         }
      }

      if (SUCCEEDED(hr))
      {
         // Now execute.
         hr = pQuery->raw_Execute(&pEnum);
      }

         //while we have more enumerated objects, get the enumerated fields
         //for that object, save them in local variables, and add them to
         //the appropriate DB
      HRESULT  hrEnum = S_OK;
      DWORD    dwFetch = 1;
      while (hrEnum == S_OK && dwFetch > 0)
      {
          //get the enumerated fields for this current object
         hrEnum = pEnum->Next(1, &var, &dwFetch);

         if ( dwFetch > 0 && hrEnum == S_OK && ( var.vt & VT_ARRAY) )
         {
            BOOL bSave = TRUE;

            // We now have a Variant containing an array of variants so we access the data
            VARIANT* pVar;
            pszColNames = V_ARRAY(&var);
            SafeArrayAccessData(pszColNames, (void**)&pVar);

            //get the sAMAccountName field
            _bstr_t sSAMName = pVar[0].bstrVal;

            _bstr_t sRDN = L"";
            _bstr_t sCanonicalName = L"";

            if (bW2KDom)
            {
                //
                // Include only user defined objects from the source domain.
                //

                if ((bSource == FALSE) || IsUserRid(_variant_t(pVar[4])))
                {
                    // get the relative distinguished name
                    _bstr_t sDN = pVar[2].bstrVal;
                    apnPathName.Set(sDN, ADS_SETTYPE_DN);
                    sRDN = apnPathName.GetElement(0L);

                    // get the canonical name
                    sCanonicalName = pVar[3].bstrVal;
                }
                else
                {
                    bSave = FALSE;
                }
            }
            else
            {
                //create an RDN from the SAM name
                sRDN = L"CN=" + sSAMName;

                //
                // Include only user defined objects from source domain.
                //
                // Retrieve object id and compare against non reserved rids.
                //

                long lRid = _variant_t(pVar[2]);

                if (lRid < MIN_NON_RESERVED_RID)
                {
                    bSave = FALSE;
                }

                //
                // Only include workstations and member servers and not domain controllers.
                //

                if (i == 2)
                {
                    // retrieve object flags and check for domain controller bit

                    long lFlags = _variant_t(pVar[3]);

                    if (lFlags & UF_SERVER_TRUST_ACCOUNT)
                    {
                        bSave = FALSE;
                    }
                }
            }

            SafeArrayUnaccessData(pszColNames);

             //use the  DBManager Interface to store this object's fields
             //in the appropriate database
            if (bSave)
            {
                pDb->raw_AddSourceObject(_bstr_t(domain), sSAMName, _bstr_t(sType[i]), sRDN, sCanonicalName, bSource);
            }
            var.Clear();
         }
      }
   
      if ( pEnum ) pEnum->Release();
   }  // while

   pDb->raw_CloseAccountsTable();
   return SUCCEEDED(hr);
}
                         
DWORD CMigrator::GetOSVersionForDomain(WCHAR const * domain)
{
    _bstr_t           strDc;
    WKSTA_INFO_100  * pInfo = NULL;
    DWORD             retVal = 0;

    DWORD rc = GetAnyDcName5(domain, strDc);

    if ( !rc ) 
    {
        rc = NetWkstaGetInfo(strDc,100,(LPBYTE*)&pInfo);
        if ( ! rc )
        {
            retVal = pInfo->wki100_ver_major;
            NetApiBufferFree(pInfo);
        }
    }

    return retVal;
}

BOOL CMigrator::DeleteItemFromList(WCHAR const * aName)
{
    DATABASE_ENTRY aListItem;
    CString itemName;
    POSITION pos, lastpos;
    BOOL bFound = FALSE;

    pos = mUserList.GetHeadPosition();
    while ((pos != NULL) && (!bFound))
    {
        lastpos = pos;
        aListItem = mUserList.GetNext(pos);
        itemName = (WCHAR*)(aListItem.m_sSAMName);
        if (itemName == aName)
        {
            mUserList.RemoveAt(lastpos);
            bFound = TRUE;
        }
    }
    return bFound;
}


// IsAgentOrDispatcherProcessRunning

bool __stdcall IsAgentOrDispatcherProcessRunning()
{
    bool bIsRunning = true;

    CMigrationMutex mutexAgent(AGENT_MUTEX);
    CMigrationMutex mutexDispatcher(DISPATCHER_MUTEX);

    if (mutexAgent.ObtainOwnership(30000) && mutexDispatcher.ObtainOwnership(30000))
    {
        bIsRunning = false;
    }

    return bIsRunning;
}


// SetDomainControllers
//
// Sets preferred domain controllers to be used
// by the account replicator and dispatched agents

DWORD __stdcall SetDomainControllers(IVarSetPtr& spVarSet)
{
    DWORD dwError = ERROR_SUCCESS;

    // set source domain controller

    _bstr_t strSourceServer = spVarSet->get(GET_BSTR(DCTVS_Options_SourceServerOverride));
    _bstr_t strSourceServerDns = spVarSet->get(GET_BSTR(DCTVS_Options_SourceServerOverrideDns));

    if ((strSourceServer.length() == 0) && (strSourceServerDns.length() == 0))
    {
        bool bSourceDns = false;
        _bstr_t strSourceDomain = spVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));

        if (strSourceDomain.length() > 0)
        {
            bSourceDns = true;
        }
        else
        {
            strSourceDomain = spVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
        }

        ULONG ulFlags = (bSourceDns ? DS_IS_DNS_NAME : DS_IS_FLAT_NAME) | DS_DIRECTORY_SERVICE_PREFERRED;
        dwError = GetDcName5(strSourceDomain, ulFlags, strSourceServerDns, strSourceServer);
    }

    if (dwError == ERROR_SUCCESS)
    {
        spVarSet->put(
            GET_BSTR(DCTVS_Options_SourceServer),
            strSourceServerDns.length() ? strSourceServerDns : strSourceServer
        );
        spVarSet->put(GET_BSTR(DCTVS_Options_SourceServerDns), strSourceServerDns);
        spVarSet->put(GET_BSTR(DCTVS_Options_SourceServerFlat), strSourceServer);
    }

    if (dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    // set target domain controller

    _bstr_t strTargetServer = spVarSet->get(GET_BSTR(DCTVS_Options_TargetServerOverride));
    _bstr_t strTargetServerDns = spVarSet->get(GET_BSTR(DCTVS_Options_TargetServerOverrideDns));

    if ((strTargetServer.length() == 0) && (strTargetServerDns.length() == 0))
    {
        bool bTargetDns = false;
        _bstr_t strTargetDomain = spVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainDns));

        if (strTargetDomain.length() > 0)
        {
            bTargetDns = true;
        }
        else
        {
            strTargetDomain = spVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
        }

        ULONG ulFlags = (bTargetDns ? DS_IS_DNS_NAME : DS_IS_FLAT_NAME) | DS_DIRECTORY_SERVICE_PREFERRED;
        dwError = GetDcName5(strTargetDomain, ulFlags, strTargetServerDns, strTargetServer);
    }

    if (dwError == ERROR_SUCCESS)
    {
        spVarSet->put(
            GET_BSTR(DCTVS_Options_TargetServer),
            strTargetServerDns.length() ? strTargetServerDns : strTargetServer
        );
        spVarSet->put(GET_BSTR(DCTVS_Options_TargetServerDns), strTargetServerDns);
        spVarSet->put(GET_BSTR(DCTVS_Options_TargetServerFlat), strTargetServer);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\migrator.h ===
// Migrator.h: Definition of the CMigrator class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_)
#define AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#import "DBMgr.tlb" no_namespace, named_guids

#define MAX_DB_FIELD 255

/////////////////////////////////////////////////////////////////////////////
// CMigrator

class CMigrator : 
	public IDispatchImpl<IPerformMigrationTask, &IID_IPerformMigrationTask, &LIBID_MCSMIGRATIONDRIVERLib>, 
	public ISupportErrorInfoImpl<&IID_IPerformMigrationTask>,
	public CComObjectRoot,
	public CComCoClass<CMigrator,&CLSID_Migrator>
{
public:
	CMigrator() {}
BEGIN_COM_MAP(CMigrator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPerformMigrationTask)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CMigrator) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Migrator)

protected:
   // these helper functions are implemented in StrDesc.cpp
   void BuildGeneralDesc(IVarSet * pVarSet,CString & str);
   void BuildAcctReplDesc(IVarSet * pVarSet,CString & str);
   void BuildSecTransDesc(IVarSet * pVarSet,CString & str, BOOL bLocal);
   void BuildDispatchDesc(IVarSet * pVarSet,CString & str);
   void BuildReportDesc(IVarSet * pVarSet, CString & str);
   void BuildUndoDesc(IVarSet * pVarSet, CString & str);
   void BuildGroupMappingDesc(IVarSet * pVarSet, CString & str);
  
   void PreProcessForReporting(IVarSet * pVarSet);
   void PreProcessDispatcher(IVarSet * pVarSet);
   void PostProcessDispatcher(IVarSet * pVarSet);
   HRESULT BuildAccountListForUndo(IVarSet * pVarSet,long actionID);
   HRESULT ProcessServerListForUndo(IVarSet * pVarSet);
   HRESULT ConstructUndoVarSet(IVarSet * pVarSetIn,IVarSet * pVarSetOut);
   HRESULT TrimMigratingComputerList(IVarSet * pVarSetIn, bool* bAnyToDispatch);
   HRESULT RunReports(IVarSet * pVarSet);
   HRESULT SetReportDataInRegistry(WCHAR const * reportName,WCHAR const * filename);
   HRESULT ViewPreviousDispatchResults();


// IPerformMigrationTask
public:
	STDMETHOD(GetTaskDescription)(IUnknown * pVarSet,/*[out]*/BSTR * pDescription);
	STDMETHOD(PerformMigrationTask)(IUnknown * pVarSet,LONG_PTR HWND);
   STDMETHOD(GetUndoTask)(IUnknown * pVarSet,/*[out]*/ IUnknown ** ppVarSetOut);
private:
   typedef struct _DATABASE_ENTRY {
		_bstr_t	m_domain;
        _bstr_t	m_sSAMName;
        _bstr_t	m_sRDN;
        _bstr_t	m_sCanonicalName;
        _bstr_t	m_sObjectClass;
		BOOL	m_bSource;
   }DATABASE_ENTRY, *PDATABASE_ENTRY;
   CList<DATABASE_ENTRY,DATABASE_ENTRY&> mUserList;

   HRESULT PopulateAccounts(IVarSetPtr pVs);
   bool PopulateDomainDBs(IVarSet * pVarSet, IIManageDBPtr pDB);
   bool PopulateADomainDB(WCHAR const *domain, BOOL bSource, IIManageDBPtr pDB);
   DWORD GetOSVersionForDomain(WCHAR const * domain);
   BOOL DeleteItemFromList(WCHAR const * aName);
};

#endif // !defined(AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\mondlg.h ===
// AgentMonitorDlg.h : header file
//

#if !defined(AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg dialog

class CAgentMonitorDlg : public CPropertyPage
{
// Construction
public:
	CAgentMonitorDlg(CWnd* pParent = NULL);	// standard constructor
   virtual BOOL OnSetActive( );
// Dialog Data
	//{{AFX_DATA(CAgentMonitorDlg)
	enum { IDD = IDD_AGENTMONITOR_DIALOG };
	CButton	m_DetailsButton;
	CListCtrl	m_ServerList;
	CString	m_DispatchLog;
	int		m_Interval;
	CString	m_ServerCount;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAgentMonitorDlg)
	public:
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL
   public:
      void SetSecurityTranslationFlag(BOOL bIsIt){ m_bSecTrans = bIsIt; }
      void SetReportingFlag(BOOL bIsIt){ m_bReporting = bIsIt; }
// Implementation
protected:
	HICON m_hIcon;
   int   m_SortColumn;
   BOOL  m_bReverseSort;
   BOOL  m_bSecTrans;
   BOOL  m_bReporting;
   // Generated message map functions
	//{{AFX_MSG(CAgentMonitorDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDblclkServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnViewDispatch();
	afx_msg void OnDetails();
	afx_msg void OnColumnclickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHeaderItemClickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
//	LRESULT OnUpdateServerEntry(UINT nID, long x);
	LRESULT OnUpdateServerEntry(UINT nID, LPARAM x);
//	LRESULT OnServerError(UINT nID, long x);
	LRESULT OnServerError(UINT nID, LPARAM x);
   
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\monitor.cpp ===
/*---------------------------------------------------------------------------
  File: Monitor.cpp  

  Comments: Functions to monitor the status of the DCT Agents.

  This involves spawning a thread which periodically reads the dispatch log,
  and scans the result directory for result files.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/15/99 15:43:35

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Resource.h"
#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "TNode.hpp"
#include "ServList.hpp"
#include "Globals.h"
#include "Monitor.h"
#include "ResStr.h"
#include <lm.h>  // to remove result share


//#import "\bin\McsVarSetMin.tlb" no_namespace , named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids

//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"
#include "McsPI_i.c"

#include "afxdao.h"

void LookForResults(WCHAR * dir = NULL);
void WaitForMoreResults(WCHAR * dir);
void ProcessResults(TServerNode * pServer, WCHAR const * directory, WCHAR const * filename);

GlobalData        gData;

DWORD __stdcall ResultMonitorFn(void * arg)
{
    WCHAR            logdir[MAX_PATH] = L"";
    BOOL             bFirstPassDone;

    CoInitialize(NULL);

    gData.GetFirstPassDone(&bFirstPassDone);

    // wait until the other monitoring thread has  a chance to build the server list,
    // so we can check for pre-existing input files before using the changenotify mechanism

    while ( ! bFirstPassDone || !*logdir )
    {
        Sleep(500);
        gData.GetFirstPassDone(&bFirstPassDone);
        gData.GetResultDir(logdir);
    }
    LookForResults(logdir);
    WaitForMoreResults(logdir);

    CoUninitialize();

    return 0;
}

void WaitForMoreResults(WCHAR * logdir)
{
    WCHAR                     resultWC[MAX_PATH];
    HANDLE                    hFind = INVALID_HANDLE_VALUE;
    BOOL                      bDone;
    long                      nIntervalSeconds;

    safecopy(resultWC,logdir);

    gData.GetDone(&bDone);
    gData.GetWaitInterval(&nIntervalSeconds);
    while (! bDone)
    {
        if (hFind == INVALID_HANDLE_VALUE)
        {
            hFind = FindFirstChangeNotification(resultWC, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME);
        }

        if (hFind != INVALID_HANDLE_VALUE)
            WaitForSingleObject(hFind,nIntervalSeconds * 1000 );
        else
            Sleep(nIntervalSeconds * 1000);
        
        LookForResults(logdir);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            if (! FindNextChangeNotification(hFind))
            {
                FindCloseChangeNotification(hFind);
                hFind = INVALID_HANDLE_VALUE;
            }
        }
        gData.GetDone(&bDone);  // we still listen to global done 
                                // in case that we use it to force a stop
        gData.GetWaitInterval(&nIntervalSeconds);

        ComputerStats stats;
        gData.GetComputerStats(&stats);

        // if all agents either finished or failed, we consider it done
        if (stats.numFinished + stats.numError >= stats.total)
            break;
    }

    if (hFind != INVALID_HANDLE_VALUE)
        FindCloseChangeNotification(hFind);
    
    gData.SetDone(TRUE);
}


void LookForResults(WCHAR * arglogdir)
{
    TNodeListEnum             e;
    TServerNode             * s;
    DWORD                     nInstalled = 0;
    DWORD                     nRunning = 0;
    DWORD                     nFinished = 0;
    DWORD                     nError = 0;
    HWND                      gListWnd;
    HWND                      gSummaryWnd;
    WCHAR                     logdir[MAX_PATH];

    if ( ! (arglogdir && *arglogdir) )
    {
        gData.GetResultDir(logdir);
    }
    else
    {
        safecopy(logdir,arglogdir);
    }

    for ( s = (TServerNode*)e.OpenFirst(gData.GetUnsafeServerList()) ; s ; gData.Lock(),s = (TServerNode*)e.Next(),gData.Unlock() )
    {
        if ( s->IsInstalled() )
            nInstalled++;
        if (s->HasFailed())
            nError++;
        // only when result has been processed do we consider it finished
        else if (s->IsFinished() && s->IsResultPullingTried() && (!s->HasResult() || s->IsResultProcessed()))
            nFinished++;
        else
            nRunning++;

        // Check jobs that finished, got result pulled but not yet processed
        if ( *s->GetJobFile() && s->IsFinished() && s->IsResultPullingTried()
            && s->HasResult() && !s->IsResultProcessed() )
        {
            // Look for results 
            WCHAR               resultWC[MAX_PATH];
            HANDLE              hFind;
            WIN32_FIND_DATA     fdata;
            WCHAR               sTime[32];

            if ( logdir[UStrLen(logdir)-1] == L'\\' )
            {
                swprintf(resultWC,L"%s%s.result",logdir,s->GetJobFile());
            }
            else
            {
                swprintf(resultWC,L"%s\\%s.result",logdir,s->GetJobFile());
            }
            hFind = FindFirstFile(resultWC,&fdata);

            s->SetTimeStamp(gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ));

            if ( hFind != INVALID_HANDLE_VALUE )
            {
                ProcessResults(s,logdir,fdata.cFileName);
                s->SetResultProcessed(TRUE);
                nRunning--;
                nFinished++;
                FindClose(hFind);
            }
            gData.GetListWindow(&gListWnd);
            SendMessage(gListWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)s);
        }
    }
    e.Close();
    
    // Update the summary window
    ComputerStats        stat;

    // get the total servers number
    gData.GetComputerStats(&stat);
    stat.numError = nError;
    stat.numFinished = nFinished;
    stat.numRunning = nRunning;
    stat.numInstalled = nInstalled;

    gData.SetComputerStats(&stat);

    gData.GetSummaryWindow(&gSummaryWnd);
    SendMessage(gSummaryWnd,DCT_UPDATE_COUNTS,0,(LPARAM)&stat);
}

BOOL                                       // ret- TRUE if successful
   ReadResults(
      TServerNode          * pServer,      // in - pointer to server node containing server name 
      WCHAR          const * directory,    // in - directory where results files are stored
      WCHAR          const * filename,     // in - filename for this agent's job
      DetailStats          * pStats,       // out- counts of items processed by the agent
      CString              & plugInText,   // out- text results from plug-ins
      BOOL                   bStore        // in - bool, whether to store plug-in text
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   WCHAR                     path[MAX_PATH];
   HRESULT                   hr = S_OK;
   BOOL                      bSuccess = FALSE;

   if ( directory[UStrLen(directory)-1] == '\\' )
   {
      swprintf(path,L"%ls%ls",directory,filename);
   }
   else
   {
      swprintf(path,L"%ls\\%ls",directory,filename);
   }

   // Read the varset data from the file
   IVarSetPtr             pVarSet;
   IStoragePtr            store;

   // attempt to open result file

   for (int nTries = 0; nTries < 6; nTries++)
   {
      hr = StgOpenStorage(path, NULL, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, &store);

      // if sharing or lock violation then...

      if ((hr == STG_E_SHAREVIOLATION) || (hr == STG_E_LOCKVIOLATION))
      {
         // wait one second before trying again
         Sleep(1000);
      }
      else
      {
         // otherwise stop trying
         break;
      }
   }

   if (SUCCEEDED(hr))
   {
      // load VarSet from file
      hr = OleLoad(store, IID_IVarSet, NULL, (void**)&pVarSet);
   }

   if ( SUCCEEDED(hr) )
   {
      pStats->directoriesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Changed));
      pStats->directoriesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Examined));
      pStats->directoriesUnchanged = (pStats->directoriesExamined - pStats->directoriesChanged);

      pStats->filesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Changed));
      pStats->filesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Examined));
      pStats->filesUnchanged = (pStats->filesExamined - pStats->filesChanged );

      pStats->sharesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Changed));
      pStats->sharesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Examined));
      pStats->sharesUnchanged = (pStats->sharesExamined - pStats->sharesChanged );

      pStats->membersChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Members_Changed));
      pStats->membersExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Members_Examined));
      pStats->membersUnchanged = (pStats->membersExamined - pStats->membersChanged );

      pStats->rightsChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_UserRights_Changed));
      pStats->rightsExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_UserRights_Examined));
      pStats->rightsUnchanged = (pStats->rightsExamined - pStats->rightsChanged );

      
      long           level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
      _bstr_t        logfile = pVarSet->get(GET_BSTR(DCTVS_Results_LogFile));
      _bstr_t        logfileIsInvalid = pVarSet->get(GET_BSTR(DCTVS_Results_LogFileIsInvalid));
      BOOL bLogfileIsInvalid = 
        (!logfileIsInvalid == false && !UStrICmp(logfileIsInvalid, GET_STRING(IDS_YES))) ? TRUE : FALSE;

      if ( level > 2 )
      {
         CString message;

         message.FormatMessage(IDS_SeeLogForAgentErrors_S,(WCHAR*)logfile);

         pServer->SetMessageText(message.GetBuffer(0));
      }
      pServer->SetSeverity(level);
         
      // build the UNC path for the log file
      WCHAR             logPath[MAX_PATH];
      
      swprintf(logPath,L"\\\\%s\\%c$\\%s",pServer->GetServer(),((WCHAR*)logfile)[0],((WCHAR*)logfile) + 3);

      if (bLogfileIsInvalid)
      {
        pServer->SetLogPath(logfile);
        pServer->SetLogPathValid(FALSE);
      }
      else
      {
        pServer->SetLogPath(logPath);
        pServer->SetLogPathValid(TRUE);
      }
      bSuccess = TRUE;
      
      // Try to get information from any plug-ins that ran
      // create the COM object for each plug-in
      _bstr_t                   bStrGuid;
      WCHAR                     key[300];
      CLSID                     clsid;

      for ( int i = 0 ; ; i++ )
      {
         swprintf(key,L"Plugin.%ld",i);
         bStrGuid = pVarSet->get(key);
      
         if ( bStrGuid.length() == 0 )
            break;

         IMcsDomPlugIn        * pPlugIn = NULL;
      
         hr = CLSIDFromString(bStrGuid,&clsid);
         if ( SUCCEEDED(hr) )
         {
            hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
            if ( SUCCEEDED(hr) )
            {
               BSTR           name = NULL;
               BSTR           result = NULL;
               
               hr = pPlugIn->GetName(&name);
               if ( SUCCEEDED(hr) )
               {
                  hr = pPlugIn->GetResultString(pVarSet,&result);
                  if ( SUCCEEDED(hr) )
                  {
                     plugInText += (WCHAR*)name;
                     plugInText += L"\n";
                     plugInText += (WCHAR*)result;
                     plugInText += L"\n\n";
                     SysFreeString(result);
                  }
                  SysFreeString(name);
                  if ( bStore )
                  {
                     pVarSet->put(L"LocalServer",pServer->GetServer());
                     pPlugIn->StoreResults(pVarSet);
                  }
               }
               pPlugIn->Release();
            }
         }
      }

   }
   else
   {
      CString  message;
      CString  title;

      if ( hr != STG_E_SHAREVIOLATION && hr != STG_E_LOCKVIOLATION )
      {
         message.FormatMessage(IDS_FailedToLoadResults,filename,hr);
         title.LoadString(IDS_MessageTitle);   
         if ( hr != STG_E_FILENOTFOUND )
            MessageBox(NULL,message,title,MB_OK | MB_ICONERROR);
      }
      else
      {
         // the agent has still not finished writing its results file, for some reason
         // we'll check it again later
         pServer->SetStatus(pServer->GetStatus() & ~Agent_Status_Finished);
      }
   }
   return bSuccess;
}

void 
   ProcessSecRefs(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   const DWORD				 NOREF = 0;

   WCHAR                     path[MAX_PATH];
   DWORD                     rc = 0;
   BOOL                      bSuccess = FALSE;
   FILE                    * pFile;
   WCHAR                   * pDot;

   if ( directory[UStrLen(directory)-1] == '\\' )
   {
      swprintf(path,L"%ls%ls",directory,filename);
   }
   else
   {
      swprintf(path,L"%ls\\%ls",directory,filename);
   }
   // check to see if a secrefs file was written
   pDot = wcsrchr(path,L'.');
   if ( pDot )
   {
      UStrCpy(pDot,L".secrefs");
      pFile = _wfopen(path,L"rb");
      if ( pFile )
      {
         IIManageDBPtr        pDB;

         rc = pDB.CreateInstance(CLSID_IManageDB);
         if ( SUCCEEDED(rc) )
         {
            // there are some secrefs here, load them into the database
            WCHAR                account[300] = L"";
            WCHAR                type[100] = L"";
            DWORD                nOwner = 0;
            DWORD                nGroup = 0;
            DWORD                nDacl = 0;
            DWORD                nSacl = 0;
            WCHAR                domPart[300];
            WCHAR                acctPart[300];
            WCHAR                acctSid[300] = L"";
            WCHAR              * slash;
            CString              typeString;

		       //remove any old references for this machine in the table
	        _variant_t   var;
	        WCHAR        sFilter[MAX_PATH];
	        wsprintf(sFilter, L"Server = \"%s\"", pServer->GetServer());
	        var = sFilter;
	        rc = pDB->raw_ClearTable(L"AccountRefs", var);

			   //move past the UNICODE Byte Order Mark
			fgetwc(pFile);

			   //get entries
            while ( 7 == fwscanf(pFile,L"%[^,],%[^,],%[^,],%ld,%ld,%ld,%ld\r\n",account,acctSid,type,&nOwner,&nGroup,&nDacl,&nSacl) )
            {
         
               safecopy(domPart,account);
               slash = wcschr(domPart,L'\\');
               if ( slash )
               {
                  *slash = 0;
                  UStrCpy(acctPart,slash+1);
               }
               else
               {
                  domPart[0] = 0;
                  safecopy(acctPart,account);
               }

			      //for sIDs with no resolvable account, change domain and account to (Unknown)
			   if ((wcsstr(account, L"S-") == account) && (domPart[0] == 0))
			   {
				  wcscpy(acctPart, GET_STRING(IDS_UnknownSid));
				  wcscpy(domPart, GET_STRING(IDS_UnknownSid));
			   }

			   if (nOwner != NOREF)
			   {
                  typeString.FormatMessage(IDS_OwnerRef_S,type);
                  rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nOwner,typeString.AllocSysString());
			   }
               
			   if (nGroup != NOREF)
			   {
                  typeString.FormatMessage(IDS_GroupRef_S,type);
                  rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nGroup,typeString.AllocSysString());
			   }

			   if (nDacl != NOREF)
			   {
                     //since local group members are not referenced in DACL, but we use that
			         //field to keep track of reference, use a different type string
			      if (!UStrCmp(type, GET_STRING(IDS_STReference_Member)))
			         typeString.FormatMessage(IDS_MemberRef_S);
			      else
			         typeString.FormatMessage(IDS_DACLRef_S,type);
                  rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nDacl,typeString.AllocSysString());
			   }

			   if (nSacl != NOREF)
			   {
                  typeString.FormatMessage(IDS_SACLRef_S,type);
                  rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nSacl,typeString.AllocSysString());
			   }

               // make sure there's not any data left over in these
               account[0] = 0;
               type[0] = 0;
			   acctSid[0] = 0;
               nOwner = 0;
               nGroup = 0;
               nDacl = 0;
               nSacl = 0;
            }
         }
         fclose(pFile);
      }
   }

}

void 
   ProcessResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   )
{
    HRESULT                   hr = S_OK;
    DetailStats               stats;
    HWND                      hWnd;
    CString                   PLText;
    memset(&stats,0,(sizeof stats));

    if ( ReadResults(pServer,directory,filename,&stats,PLText,TRUE) )
    {
        if ( ! pServer->HasFailed() && ! pServer->GetSeverity() )
        {
            pServer->SetMessageText(L"");
        }
        gData.AddDetailStats(&stats);
        gData.GetSummaryWindow(&hWnd);
        // get the stats for this job, and send them to the summary window
        //      SendMessage(hWnd, DCT_UPDATE_TOTALS, 0, (long)&stats);
        SendMessage(hWnd, DCT_UPDATE_TOTALS, 0, (LPARAM)&stats);
    }

    // also get import the security references
    if (pServer->IsAccountReferenceResultExpected())
        ProcessSecRefs(pServer,directory,filename);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\monitor.h ===
#ifndef __MONITOR_H__
#define __MONITOR_H__
/*---------------------------------------------------------------------------
  File: Monitor.h

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:12:36

 ---------------------------------------------------------------------------
*/

DWORD __stdcall ResultMonitorFn(void * arg);
DWORD __stdcall LogReaderFn(void * arg);




#define DCT_UPDATE_ENTRY   (WM_APP+2)
#define DCT_ERROR_ENTRY    (WM_APP+3)
#define DCT_SERVER_COUNT   (WM_APP+4)
#define DCT_DETAIL_REFRESH (WM_APP+5)
#define DCT_UPDATE_COUNTS  (WM_APP+6)
#define DCT_UPDATE_TOTALS  (WM_APP+7)

struct ComputerStats
{
   DWORD                     total;
   DWORD                     numInstalled;
   DWORD                     numRunning;
   DWORD                     numFinished;
   DWORD                     numError;
};

struct DetailStats
{
   ULONGLONG                 filesExamined;
   ULONGLONG                 filesChanged;
   ULONGLONG                 filesUnchanged;
   ULONGLONG                 directoriesExamined;
   ULONGLONG                 directoriesChanged;
   ULONGLONG                 directoriesUnchanged;
   ULONGLONG                 sharesExamined;
   ULONGLONG                 sharesChanged;
   ULONGLONG                 sharesUnchanged;
   ULONGLONG                 membersExamined;
   ULONGLONG                 membersChanged;
   ULONGLONG                 membersUnchanged;
   ULONGLONG                 rightsExamined;
   ULONGLONG                 rightsChanged;
   ULONGLONG                 rightsUnchanged;
};

class TServerNode;

BOOL                                       // ret- TRUE if successful
   ReadResults(
      TServerNode          * pServer,      // in - pointer to server node containing server name 
      WCHAR          const * directory,    // in - directory where results files are stored
      WCHAR          const * filename,     // in - filename for this agent's job
      DetailStats          * pStats,       // out- counts of items processed by the agent
      CString              & plugInString, // out- description of results from plug-ins
      BOOL                   bSaveResults  // in - flag, whether to call store results for plugins
   );

void 
   ProcessResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   );


#endif //__MONITOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\mondlg.cpp ===
/*---------------------------------------------------------------------------
  File: AgentMonitorDlg.cpp 

  Comments: This dialog shows a list of the computers the agent is being dispatched to
  along with their status.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// AgentMonitorDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MonDlg.h"
#include "DetDlg.h"
#include "scanlog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "Common.hpp"
#include "UString.hpp"                    
#include "TNode.hpp"
#include "ServList.hpp"
#include "Monitor.h"
#include "Globals.h"
#include "ResStr.h"

#include <htmlhelp.h>
#include "helpid.h"


#define COLUMN_COMPUTER             0
#define COLUMN_TIMESTAMP            1
#define COLUMN_STATUS               2
#define COLUMN_MESSAGE              3

#define SORT_COLUMN_BITS            0x03
#define SORT_REVERSE                0x80000000

BOOL              bWaiting = FALSE;

TCHAR* 
GetSystemDirectoryHelper();

// This is the sort function for the CListView
int CALLBACK SortFunction(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
   int                       result = 0;
   TServerNode             * n1 = (TServerNode*)lParam1;
   TServerNode             * n2 = (TServerNode*)lParam2;

   if ( n1 && n2 )
   {
      switch ( lParamSort & SORT_COLUMN_BITS )
      {
      case COLUMN_COMPUTER:
         // Sort by names
         result = UStrICmp(n1->GetServer(),n2->GetServer());
         break;
      case COLUMN_TIMESTAMP:
         result = UStrICmp(n1->GetTimeStamp(),n2->GetTimeStamp());
         break;
      case COLUMN_STATUS:
         if ( n1->GetStatus() == n2->GetStatus() )
            result = 0;
         else if ( n1->GetStatus() < n2->GetStatus() )
            result = -1;
         else 
            result = 1;
         break;
      case COLUMN_MESSAGE:
         result = UStrICmp(n1->GetMessageText(),n2->GetMessageText());
         break;
      default:
         MCSVERIFY(FALSE);
         break;
      }
   }
   if ( lParamSort & SORT_REVERSE )
   {
      result *= -1;
   }
   return result;
}




/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg dialog

CAgentMonitorDlg::CAgentMonitorDlg(CWnd* pParent /*=NULL*/)
: CPropertyPage(CAgentMonitorDlg::IDD) 
{
	//{{AFX_DATA_INIT(CAgentMonitorDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
   m_SortColumn = 0;
   m_bReverseSort = FALSE;
   m_bSecTrans = TRUE;
   m_bReporting = FALSE;
}

void CAgentMonitorDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAgentMonitorDlg)
	DDX_Control(pDX, IDC_DETAILS, m_DetailsButton);
	DDX_Control(pDX, IDC_SERVERLIST, m_ServerList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAgentMonitorDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CAgentMonitorDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_SERVERLIST, OnDblclkServerlist)
	ON_BN_CLICKED(IDC_VIEW_DISPATCH, OnViewDispatch)
	ON_BN_CLICKED(IDC_DETAILS, OnDetails)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERLIST, OnColumnclickServerlist)
	ON_NOTIFY(NM_CLICK, IDC_SERVERLIST, OnClickServerlist)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_SERVERLIST, OnGetdispinfoServerlist)
	ON_NOTIFY(LVN_SETDISPINFO, IDC_SERVERLIST, OnSetdispinfoServerlist)
	ON_NOTIFY(HDN_ITEMCLICK, IDC_SERVERLIST, OnHeaderItemClickServerlist)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
    ON_MESSAGE(DCT_UPDATE_ENTRY, OnUpdateServerEntry)
	ON_MESSAGE(DCT_ERROR_ENTRY, OnServerError)
   
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg message handlers

BOOL CAgentMonitorDlg::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	// Setup the columns for the server list
   CString heading;
   
   heading.LoadString(IDS_ComputerColumnHeading);
   m_ServerList.InsertColumn(COLUMN_COMPUTER,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_TimestampColumnHeading);
   m_ServerList.InsertColumn(COLUMN_TIMESTAMP,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_StatusColumnHeading);
   m_ServerList.InsertColumn(COLUMN_STATUS,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_MessageColumnHeading);
   m_ServerList.InsertColumn(COLUMN_MESSAGE,heading,LVCFMT_LEFT,200);
   
   // Read the server list to get any information we may have missed so far
   TNodeListEnum           e;
   TServerList           * pServerList = gData.GetUnsafeServerList();
   TServerNode           * pServer;

   gData.Lock();
   
   for ( pServer = (TServerNode *)e.OpenFirst(pServerList) ; pServer ; pServer = (TServerNode *)e.Next() )
   {
      if ( pServer->Include() )
      {
//         OnUpdateServerEntry(0,(long)pServer);
         OnUpdateServerEntry(0,(LPARAM)pServer);
      }
   }
   e.Close();
   gData.Unlock();

   gData.SetListWindow(m_hWnd);
	
   m_DetailsButton.EnableWindow(m_ServerList.GetSelectedCount());

   CString str;
   str.LoadString(IDS_WaitingMessage);
   m_ServerList.InsertItem(0,str);
   bWaiting = TRUE;

   return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAgentMonitorDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
   CPropertyPage::OnSysCommand(nID, lParam);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CAgentMonitorDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertyPage::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CAgentMonitorDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

//LRESULT CAgentMonitorDlg::OnUpdateServerEntry(UINT nID, long x)
LRESULT CAgentMonitorDlg::OnUpdateServerEntry(UINT nID, LPARAM x)
{
   TServerNode             * pNode = (TServerNode *)x;
   LVFINDINFO                findInfo;
   CString                   timestamp;
   CWaitCursor               w;
   memset(&findInfo,0,(sizeof findInfo));

      // This turns off the initial hourglass in the dispatch monitor
   if ( bWaiting )
   {
      if ( pNode )
      {
         AfxGetApp()->DoWaitCursor(-1);
         if ( m_ServerList.GetItemCount() == 1 )
         {
            m_ServerList.DeleteItem(0);
         }
         
      }
      else
      {
         BOOL                 bLDone;

         gData.GetLogDone(&bLDone);

         if ( bLDone )
         {
            AfxGetApp()->DoWaitCursor(-1);
            if ( m_ServerList.GetItemCount() == 1 )
            {
               m_ServerList.DeleteItem(0);
               CString str;
               str.LoadString(IDS_NoServersMessage);
               m_ServerList.InsertItem(0,str);
            }
         }
      }
   }
   bWaiting = FALSE;

   if ( pNode )
   {
      findInfo.flags = LVFI_STRING;
      findInfo.psz = pNode->GetServer();
  
      int ndx = m_ServerList.FindItem(&findInfo);
      if ( ndx == -1 )
      {
         // add the server to the list
         ndx = m_ServerList.GetItemCount();
//         m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(long)pNode);
         m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(LPARAM)pNode);
         if ( m_bReverseSort )
         {
            m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
         }
         else
         {
            m_ServerList.SortItems(&SortFunction,m_SortColumn);
         }

      }
      m_ServerList.RedrawItems(ndx,ndx);
   }   
   return 0;
}
	
//LRESULT CAgentMonitorDlg::OnServerError(UINT nID, long x)
LRESULT CAgentMonitorDlg::OnServerError(UINT nID, LPARAM x)
{
   TServerNode             * pNode = (TServerNode *)x;
   LVFINDINFO                findInfo;
   CString                   timestamp;
   CWaitCursor               w;

   memset(&findInfo,0,(sizeof findInfo));

      // This turns off the initial hourglass in the dispatch monitor
   if ( bWaiting )
   {
      if ( pNode )
      {
         AfxGetApp()->DoWaitCursor(-1);
         if ( m_ServerList.GetItemCount() == 1 )
         {
            m_ServerList.DeleteItem(0);
         }
         
      }
      else
      {
         BOOL                 bLDone;

         gData.GetLogDone(&bLDone);

         if ( bLDone )
         {
            AfxGetApp()->DoWaitCursor(-1);
            if ( m_ServerList.GetItemCount() == 1 )
            {
               m_ServerList.DeleteItem(0);
               CString str;
               str.LoadString(IDS_NoServersMessage);
               m_ServerList.InsertItem(0,str);
            }
         }
      }
   }
   bWaiting = FALSE;
   
   findInfo.flags = LVFI_STRING;
   findInfo.psz = pNode->GetServer();

   int ndx = m_ServerList.FindItem(&findInfo);
   if ( ndx == -1 )
   {
      // add the server to the list
      ndx = m_ServerList.GetItemCount();
//      m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(long)pNode);
      m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(LPARAM)pNode);
      if ( m_bReverseSort )
      {
         m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
      }
      else
      {
         m_ServerList.SortItems(&SortFunction,m_SortColumn);
      }

   }

   // the subitems will be callbacks
   m_ServerList.RedrawItems(ndx,ndx);
   return 0;
}

void CAgentMonitorDlg::OnDblclkServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnDetails();
   *pResult = 0;
}

void CAgentMonitorDlg::OnViewDispatch() 
{
   WCHAR                     filename[MAX_PATH];
   CString                   cmd;
   STARTUPINFO				     startupInfo;
	PROCESS_INFORMATION		  processInfo;
   TCHAR* pszSystemDirectoryName = NULL;
   CString                   message;
   CString                   title;

	   
   memset(&startupInfo,0,(sizeof startupInfo));
   
   startupInfo.cb = (sizeof startupInfo);

   gData.GetReadableLogFile(filename);

   pszSystemDirectoryName = GetSystemDirectoryHelper();
   if(!pszSystemDirectoryName)
   {
      // we could not get the system directory name, we should bail out, otherwise we might launch
      // malicious process
      title.LoadString(IDS_MessageTitle);
      message.LoadString(IDS_LaunchNotePadFailed);

      MessageBox(message,title, MB_ICONERROR | MB_OK);
      return;
   }
   
   cmd.FormatMessage(IDS_NotepadCommandLine, pszSystemDirectoryName, filename);
   delete [] pszSystemDirectoryName;

   CreateProcess(NULL,cmd.GetBuffer(0),NULL,NULL,TRUE,0,NULL,NULL,&startupInfo,&processInfo);
}

void CAgentMonitorDlg::OnDetails() 
{
   const int NOT_FOUND = -1;  //indicates no match in search - PRT
   const int WHOLE_LIST = -1; //index to start search of whole list - PRT

   UpdateData(TRUE);

//   POSITION p = m_ServerList.GetFirstSelectedItemPosition();
//   if ( p )
//   {
//      int ndx = m_ServerList.GetNextSelectedItem(p);

	  //search whole list control for first (and only) selected item
   int ndx = m_ServerList.GetNextItem(WHOLE_LIST, LVNI_SELECTED); //PRT
	  //if found selected item, disply it's details
   if (ndx != NOT_FOUND)  //PRT
   {   //PRT
      CString serverName;
      serverName = m_ServerList.GetItemText(ndx,0);
      if ( serverName.GetLength() )
      {
         // Launch the details dialog
         CAgentDetailDlg      det;
         
         gData.Lock();

         TServerNode     * s = gData.GetUnsafeServerList()->FindServer((LPCTSTR)serverName);
         
         gData.Unlock();

         if ( s )
         {
            det.SetNode(s);
            if ( ! m_bSecTrans )
            {
               det.SetFormat(-1);
            }
            if ( m_bReporting )
            {
               det.SetGatheringInfo(TRUE);
            }
            if ( s->IsFinished() && *s->GetJobFile() )
            {
               DetailStats   detailStats;
               WCHAR         directory[MAX_PATH];
               WCHAR         filename[MAX_PATH];
               CString       plugInText;

               gData.GetResultDir(directory);
               
               memset(&detailStats,0,(sizeof detailStats));

               swprintf(filename,GET_STRING(IDS_AgentResultFileFmt),s->GetJobFile());

               if ( SUCCEEDED(CoInitialize(NULL)) )
               {
                  if ( ReadResults(s,directory,filename,&detailStats,plugInText,FALSE) )
                  {
                     det.SetStats(&detailStats);
                     det.SetPlugInText(plugInText);
                     det.SetLogFile(s->GetLogPath());
                     det.SetLogFileValid(s->GetLogPathValid());
                  }

                  CoUninitialize();
               }
            }
            det.DoModal();
         }
      }
   }

   UpdateData(FALSE);
}


void CAgentMonitorDlg::OnColumnclickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CWaitCursor               w;
   NM_LISTVIEW             * pNMListView = (NM_LISTVIEW*)pNMHDR;

	// sort by pNMListView->iSubItem
   if ( m_SortColumn == pNMListView->iSubItem )
   {
      m_bReverseSort = ! m_bReverseSort;
   }
   else
   {
      m_bReverseSort = FALSE;
   }
   m_SortColumn = pNMListView->iSubItem;
   if ( m_bReverseSort )
   {
      m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
   }
   else
   {
      m_ServerList.SortItems(&SortFunction,m_SortColumn);
   }
   
	*pResult = 0;
}

void CAgentMonitorDlg::OnClickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
   const int NOT_FOUND = -1;  //indicates no match in search - PRT
   const int WHOLE_LIST = -1; //index to start search of whole list - PRT

   UpdateData(TRUE);
   if ( m_ServerList.GetSelectedCount() )
   {
//      POSITION p = m_ServerList.GetFirstSelectedItemPosition();
//      if ( p )
//      {
		  //search whole list control for first (and only) selected item
	   int ndx = m_ServerList.GetNextItem(WHOLE_LIST, LVNI_SELECTED); //PRT
		  //if found selected item, disply it's details
	   if (ndx != NOT_FOUND)  //PRT
	   {   //PRT
         CString msg1;
         CString msg2;

//         int ndx = m_ServerList.GetNextSelectedItem(p);
         CString serverName;
         serverName = m_ServerList.GetItemText(ndx,0);
         msg1.LoadString(IDS_WaitingMessage);
         msg2.LoadString(IDS_NoServersMessage);
         if ( serverName.Compare(msg1) && serverName.Compare(msg2) )
         {
            m_DetailsButton.EnableWindow(TRUE);
         }
         else
         {
            m_DetailsButton.EnableWindow(FALSE);
         }
      }
   }
   else
   {
      m_DetailsButton.EnableWindow(FALSE);
   }
   UpdateData(FALSE);

	*pResult = 0;
}

WCHAR gMessage[1000];

void CAgentMonitorDlg::OnGetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	// find iItem in the serverList, and set the pszText for the iSubItem appropriately
   CString                   status;
   TServerNode             * pNode = NULL;
   CString                   timestamp;
   WCHAR                   * text = gMessage;
   CString                   serverName;
   WCHAR convertedTimestamp[MAX_PATH];
   WCHAR* originalTimestamp;
   
   status.LoadString(IDS_Status_Unknown);

   serverName = m_ServerList.GetItemText(pDispInfo->item.iItem,0);

   if ( serverName.GetLength() )
   {
      gData.Lock();
      pNode = gData.GetUnsafeServerList()->FindServer(serverName.GetBuffer(0));
      gData.Unlock();

      if ( pNode )
      {

         switch ( pDispInfo->item.iSubItem )
         {
         case COLUMN_TIMESTAMP:
            originalTimestamp = pNode->GetTimeStamp();
            timestamp = (ConvertToLocalUserDefault(originalTimestamp, convertedTimestamp, sizeof(convertedTimestamp)/sizeof(convertedTimestamp[0])))
                ? convertedTimestamp : originalTimestamp;
            if ( timestamp.Right(1) == "\n" )
            {
               timestamp = timestamp.Left(timestamp.GetLength() - 1);
            }
            //text = new char[timestamp.GetLength() + 1];
            UStrCpy(text,timestamp.GetBuffer(0));
            pDispInfo->item.pszText = text;
            break;
         case COLUMN_STATUS:
            
            if ( pNode->HasFailed() )
            {
               status.LoadString(IDS_Status_InstallFailed);
            }
            if ( pNode->IsInstalled() )
            {
               if ( ! pNode->HasFailed() )
                  status.LoadString(IDS_Status_Installed);
               else 
                  status.LoadString(IDS_Status_DidNotStart);
            }
            if ( pNode->GetStatus() & Agent_Status_Started )
            {
               if ( ! pNode->HasFailed() )
                  status.LoadString(IDS_Status_Running);
               else
                  status.LoadString(IDS_Status_Failed);
            }
            if ( pNode->IsFinished() )
            {
               if (pNode->QueryFailed())
               {
                // we show "Status Unknown" in the status field
                status.LoadString(IDS_Status_Unknown);
               }
               else if (!pNode->IsResultPullingTried() || (pNode->HasResult() && !pNode->IsResultProcessed()))
               {
                // if still pulling results or results not yet processed
                // we want to show the status of still running
                status.LoadString(IDS_Status_Running);
               }
               else
               {
                if (!pNode->HasResult())
                {
                    // if there is no result, we consider it an error
                    status.LoadString(IDS_Status_Completed_With_Errors);
                }
                else if ( ! pNode->GetSeverity() )
                {
                    // if we have the result and no error happened during agent operation
                    // we show the status of complete
                    status.LoadString(IDS_Status_Completed);
                }
                else
                {
                    // if we have the result, we set the status 
                    // based on the error/warning level
                    switch ( pNode->GetSeverity() )
                    {
                    case 1:
                         status.LoadString(IDS_Status_Completed_With_Warnings);
                         break;
                    case 2:
                         status.LoadString(IDS_Status_Completed_With_Errors);
                     break;
                    case 3:
                    default:
                         status.LoadString(IDS_Status_Completed_With_SErrors);
                     break;
                  }
                }
               }
            }
            
            UStrCpy(text,status);
            pDispInfo->item.pszText = text;
            break;
         case COLUMN_MESSAGE:
            {
                BOOL bUpdate = TRUE;
                if (pNode->IsFinished() && pNode->QueryFailed())
                {
                    // in this case, we show the error during the query
                    status = pNode->GetMessageText();
                }
                else if (pNode->IsFinished()
                    && (!pNode->IsResultPullingTried()
                          || (pNode->HasResult() && !pNode->IsResultProcessed())))
                {
                    // if agent has finished but result not yet pulled or processed,
                    // we show the status of "still processing results"
                    status.LoadString(IDS_Status_Processing_Results);
                }
                else if (pNode->IsFinished() && pNode->IsResultPullingTried() && !pNode->HasResult())
                {
                    // if agent finished but we cannot retrieve results
                    // we show the status of "cannot retrieve results"
                    status.LoadString(IDS_Status_Cannot_Retrieve_Results);
                }
                else if ( pNode->HasFailed() || pNode->QueryFailed() || pNode->GetSeverity() || pNode->IsFinished())
                {
                    // for these cases, we get the message stored on the node
                    status = pNode->GetMessageText();
                }
                else
                {
                    bUpdate = FALSE;
                }

                if (bUpdate)
                {
                    UStrCpy(text, (LPCTSTR)status);
                    pDispInfo->item.pszText = text;
                }
            }
            break;
         }
      }
   }
	*pResult = 0;
}

BOOL CAgentMonitorDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose();
   return rc;
}

void CAgentMonitorDlg::OnSetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;
}

void CAgentMonitorDlg::OnHeaderItemClickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;
}

void CAgentMonitorDlg::OnOK() 
{
	CPropertyPage::OnOK();
}

BOOL CAgentMonitorDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SERVER_LIST );
         break;
   }
   
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

BOOL CAgentMonitorDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SERVER_LIST );
   return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MigDrvr.rc
//
#define ID_DIALOG_FONTSIZE              8
#define IDS_PROJNAME                    100
#define IDS_MIGRATOR_DESC               101
#define IDR_Migrator                    102
#define IDD_AGENTMONITOR_DIALOG         102
#define IDS_ABOUTBOX                    102
#define IDS_PROGRESS_TITLE              103
#define IDS_ServerNotFound              104
#define IDS_ServerAgentProgressTitle    105
#define IDS_StatusCompleted             106
#define IDS_AccountCopiedLabel          107
#define IDS_AccountErrorsLabel          108
#define IDS_AccountUsersLabel           109
#define IDS_AccountGroupsLabel          110
#define IDS_AccountComputersLabel       111
#define IDS_ChangedLabel                112
#define IDS_UnchangedLabel              113
#define IDS_FilesLabel                  114
#define IDS_SharesLabel                 115
#define IDS_DirectoriesLabel            116
#define IDS_MailboxesLabel              117
#define IDS_ContainersLabel             118
#define IDS_AgentNotRunning             119
#define IDS_CantMonitorOnNt351          120
#define IDS_CannotConnectToAgent        121
#define IDS_RPCBindFailed               122
#define IDS_NoActiveAgent               123
#define IDS_AgentJobNotFound            124
#define IDS_AgentNoLongerRunning        125
#define IDS_QueryJobStatusFailed        126
#define IDS_ExceptionConnectingToAgent  127
#define IDS_ConfirmStopAgent            128
#define IDD_DETAILS                     129
#define IDS_CancelJobFailed             129
#define IDD_AGENTMONITOR_MAIN           130
#define IDS_StopAgentFailed             130
#define IDS_ConfirmCancelJob            131
#define IDD_STARTSTOP                   131
#define IDS_StopAgentFailedHexResult    132
#define IDS_CLIOption_Log               133
#define IDS_CLIOption_Import            134
#define IDS_CLIOption_Start             135
#define IDS_CLIOption_LocalJob          136
#define IDS_MainWindowTitle             137
#define IDS_ConfirmExitAgentsRunning    138
#define IDS_MessageTitle                139
#define IDS_ComputerColumnHeading       140
#define IDS_TimestampColumnHeading      141
#define IDS_StatusColumnHeading         142
#define IDS_MessageColumnHeading        143
#define IDS_NotepadCommandLine          144
#define IDS_ServerNotInServerList       145
#define IDS_Status_Unknown              146
#define IDS_Status_InstallFailed        147
#define IDS_Status_Installed            148
#define IDS_Status_DidNotStart          149
#define IDS_Status_Running              150
#define IDS_Status_Failed               151
#define IDS_Status_Completed            152
#define IDS_Status_NotRunning           153
#define IDS_PromptEnterDispatchLogName  154
#define IDS_ServerCountMessage          155
#define IDS_FailedToLoadResults         156
#define IDS_AgentFinishedNoResults      157
#define IDS_AgentNoResults              158
#define IDS_AccessDenied                159
#define IDS_CopyAccounts                160
#define IDS_TranslateSecurity           161
#define IDS_ExaminedLabel               162
#define IDS_DispatchToServers           163
#define IDS_DescDomains                 164
#define IDS_DescLogfile                 165
#define IDS_DescCredentials             166
#define IDS_DescCopyUsers               167
#define IDS_DescCopyGroups              168
#define IDS_DescCopyComputers           169
#define IDS_DescCopyOUs                 170
#define IDS_DescWriteChanges            171
#define IDS_DescNoChange                172
#define IDS_DescNoReplaceExisting       173
#define IDS_DescReplaceExisting         174
#define IDS_DescRenameWithPrefix        175
#define IDS_DescRenameWithSuffix        176
#define IDS_DescAccountCount            177
#define IDS_DescAccountMigration        178
#define IDS_DescGeneral                 179
#define IDS_DescMailboxTranslation      180
#define IDS_DescContainerTranslation    181
#define IDS_DescFileTrans               182
#define IDS_DescSecurityTranslationFor  183
#define IDS_DescShareTrans              184
#define IDS_DescPrinterTrans            185
#define IDS_DescLGTrans                 186
#define IDS_DescRightsTrans             187
#define IDS_DescProfileTrans            188
#define IDS_DescCopyAccountTypes        189
#define IDS_TranslationMode             190
#define IDS_GenerateMigratedAccountsReport 191
#define IDS_GenerateMigratedComputersReport 192
#define IDS_GenerateExpiredComputersReport 193
#define IDS_GenerateAccountReferencesReport 194
#define IDS_GenerateNameConflictReport  195
#define IDS_UserMigration               196
#define IDS_GroupMigration              197
#define IDS_ComputerMigration           198
#define IDS_SecurityTranslation         199
#define IDS_ReportGeneration            200
#define IDD_PLEASEWAIT                  201
#define IDS_RetryTasks                  201
#define IDC_STATIC_MESSAGE              201
#define IDS_Service                     202
#define IDC_VIEW_LOG                    202
#define IDS_TrustManagement             203
#define IDS_Exchange                    204
#define IDS_Undo                        205
#define IDS_CannotCloseWhileAgentIsRunning 206
#define IDS_DescUndo                    207
#define IDS_DescAccountCountForDelete   208
#define IDS_DescRegistryTrans           209
#define IDS_GroupsWillBeMapped          210
#define IDS_SIDHistory_Yes              211
#define IDS_SIDHistory_No               212
#define IDS_HELPFILE                    213
#define IDS_MSG_HELP                    214
#define IDS_MSG_ERROR                   215
#define IDS_SeeLogForAgentErrors_S      216
#define IDS_Status_Completed_With_Errors 217
#define IDS_Status_Completed_With_Warnings 218
#define IDS_Status_Completed_With_SErrors 219
#define IDS_JustStartingConfirmExit     220
#define IDS_AgentsStillRunningCannotExit 221
#define IDS_OwnerRef_S                  222
#define IDS_GroupRef_S                  223
#define IDS_DACLRef_S                   224
#define IDS_SACLRef_S                   225
#define IDS_WaitingMessage              226
#define IDS_NoServersMessage            227
#define IDS_ConfirmCloseWhileAgentIsRunning 228
#define IDS_STATUS_Gathering_NameConf   229
#define IDS_STATUS_GeneratingReports    230
#define IDS_Affected                    231
#define IDS_Unaffected                  232
#define IDS_DescDisableSrcAccts         233
#define IDS_DescExpireSrcAccts          234
#define IDS_DescDisableTgtAccts         235
#define IDS_DescLeaveAcctsActive        236
#define IDS_DescTranslateRoaming        238
#define IDS_DescUpdateUserRights        239
#define IDS_DescStrongPassword          240
#define IDS_DescSimplePassword          241
#define IDS_MemberRef_S                 242
#define IDS_DescTransInputFile          243
#define IDS_DescTransInputMOT           244
#define IDS_DescCopyPassword            245
#define IDS_DescExUserProps             246
#define IDS_DescExGrpProps              247
#define IDS_DescExCmpProps              248
#define IDS_DescExcludedProp            249
#define IDS_DescTgtSameAsSrc            250
#define IDS_DescRenameWithPrefixOnConf  251
#define IDS_DescRenameWithSuffixOnConf  252
#define IDS_DescExInetOrgPersonProps    253
#define IDC_LOGFILE                     1000
#define IDC_SERVERLIST                  1001
#define IDC_INTERVAL                    1002
#define IDC_STARTMONITOR                1003
#define IDC_STOPMONITOR                 1004
#define IDC_STATUS                      1006
#define IDC_CURRENT                     1007
#define IDC_FilesExamined               1008
#define IDC_DirsExamined                1009
#define IDC_OPERATION                   1010
#define IDC_BTNREFRESH                  1011
#define IDC_EDIT2                       1012
#define IDC_STOPAGENT                   1013
#define IDC_FilesChanged                1014
#define IDC_DirsChanged                 1015
#define IDC_INSTALL_PROGRESS            1015
#define IDC_COMPLETE_PROGESS            1016
#define IDC_INSTALLED_COUNT             1017
#define IDC_RUNNING_COUNT               1018
#define IDC_FINISHED_COUNT              1019
#define IDC_ERROR_COUNT                 1020
#define IDC_TOTAL                       1021
#define IDC_SharesExamined              1022
#define IDC_DirsChanged2                1022
#define IDC_SharesExamined2             1023
#define IDC_SharesChanged               1024
#define IDC_VIEW_DISPATCH               1024
#define IDC_MembersExamined             1025
#define IDC_DB                          1025
#define IDC_MembersChanged              1026
#define IDC_LOG_LABEL                   1026
#define IDC_REFRESH_LABEL               1027
#define IDC_RightsExamined              1027
#define IDC_RightsChanged               1028
#define IDC_DB_LABEL                    1028
#define IDC_IMPORT                      1029
#define IDC_FilesU                      1040
#define IDC_DirsU                       1041
#define IDC_SharesU                     1042
#define IDC_ExaminedLabel               1043
#define IDC_MembersU                    1043
#define IDC_FilesLabel                  1044
#define IDC_RightsU                     1044
#define IDC_DirectoriesLabel            1045
#define IDC_SharesLabel                 1046
#define IDC_ChangedLabel                1047
#define IDC_UnchangedLabel              1048
#define IDC_DETAILS                     1049
#define IDC_PLUG_IN_RESULTS             1051
#define IDS_Status_Processing_Results      1052
#define IDS_Status_Cannot_Retrieve_Results      1053
#define IDS_LaunchNotePadFailed         1054
#define IDS_LogfileIsInvalid            1055
#define IDS_CompletionStatusLoggingPrelog 1056
#define IDS_CompletionStatusLoggingEpilog 1057
#define IDS_CompletionStatusLoggingMachineNameTitle 1058
#define IDS_CompletionStatusLoggingCompletionStatusTitle 1059
#define IDS_CompletionStatusLoggingErrorMessageTitle 1060
#define IDS_CompletionStatusLoggingLogFilePathTitle 1061
#define IDS_Status_Installing 1062
#define IDS_CompletionStatusLoggingForcedToStopMonitoring 1063


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\scanlog.h ===
#ifndef SCANLOG_H
#define SCANLOG_H
bool ConvertToLocalUserDefault(WCHAR* originalTimestamp, WCHAR* convertedTimestamp, size_t size);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\migdrvr\monrung.cpp ===
/*---------------------------------------------------------------------------
  File:  MonitorRunning.cpp

  Comments: This is the entry point for a thread which will periodically try to connect 
  to the agents that the monitor thinks are running, to see if they are really still running. 

  This will keep the monitor from getting into a state where it thinks agents 
  are still running, when they are not.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "DetDlg.h"

#include "Common.hpp"
#include "AgRpcUtl.h"
#include "Monitor.h"
#include "ServList.hpp"

#include "ResStr.h"

//#include "..\AgtSvc\AgSvc.h"
#include "AgSvc.h"

/*#import "\bin\McsEADCTAgent.tlb" no_namespace , named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace */

//#import "Engine.tlb" no_namespace , named_guids //already #imported via DetDlg.h
#import "VarSet.tlb" no_namespace rename("property", "aproperty")


DWORD 
   TryConnectAgent(
      TServerNode          * node,
      BOOL                   bSignalToShutdown,  // indicates whether we want to signal the agent to shut down
      DWORD                  dwMilliSeconds          // indicates the auto shut down timeout
                                                                      // we should query the agent again by this time
   )
{
    DWORD                     rc;
    HRESULT                   hr;
    HANDLE                    hBinding = NULL;
    WCHAR                   * sBinding = NULL;
    WCHAR                     server[MAX_PATH];
    IUnknown                * pUnk = NULL;
    IVarSetPtr                pVarSet;
    IDCTAgentPtr              pAgent;
    _bstr_t                   jobID;
    BOOL                      bSuccess = FALSE;
    BOOL                      bQueryFailed = TRUE;
    BOOL                      bFinished = FALSE;
    CString                   status;
    BOOL                      bCoInitialized = FALSE;

    server[0] = L'\\';
    server[1] = L'\\';
    UStrCpy(server+2,node->GetServer());

    rc = EaxBindCreate(server,&hBinding,&sBinding,TRUE);
    if ( ! rc )
    {
        hr = CoInitialize(NULL);
        if ( SUCCEEDED(hr) )
        {
            bCoInitialized = TRUE;
            rc = DoRpcQuery(hBinding,&pUnk);
        }
        else
        {
            rc = hr;
        }

        if ( ! rc && pUnk )
        {
            try { 

                // we got an interface pointer to the agent:  try to query it
                pAgent = pUnk;
                pUnk->Release();
                pUnk = NULL;
                jobID = node->GetJobID();

                hr = pAgent->raw_QueryJobStatus(jobID,&pUnk);
                if ( SUCCEEDED(hr) )
                {
                    // set the auto shut down for the agent so in case we don't 
                    // lose connection to it it will shut down automatically
                    // usually, we should call this function again by that time
                    pAgent->raw_SetAutoShutDown(dwMilliSeconds);
                    bQueryFailed = FALSE;
                    pVarSet = pUnk;
                    pUnk->Release();
                    _bstr_t text = pVarSet->get(GET_BSTR(DCTVS_JobStatus));

                    if ( !UStrICmp(text,GET_STRING(IDS_DCT_Status_Completed)))
                    {
                        bFinished = TRUE;
                    }
                    else if (!UStrICmp(text,GET_STRING(IDS_DCT_Status_Completed_With_Errors)))
                    {
                        node->SetSeverity(2);
                        bFinished = TRUE;
                    }
                }
            }
            catch ( ... )
            {
                // the DCOM connection didn't work
                // This means we can't tell whether the agent is running or not
                bQueryFailed = TRUE;
            }

        }
        else
        {
            if ( rc == E_NOTIMPL )
            {
                status.LoadString(IDS_CantMonitorOnNt351);
            }
            else
            {
                status.LoadString(IDS_CannotConnectToAgent);
            }
            bQueryFailed = TRUE;
        }
        EaxBindDestroy(&hBinding,&sBinding);
    }

    // if trying to signal the agent to shut down, we will do our best
    if (bSignalToShutdown)
    {
        if (pAgent)
            pAgent->raw_SignalOKToShutDown();
        rc = 0;
    }
    else
    {    
        node->SetMessageText(status.GetBuffer(0));
        if ( bFinished )
        {
            node->SetFinished();
        }
        else if ( bQueryFailed )
        {
            node->SetQueryFailed(TRUE);
        }
        
        // update the server entry in the list window
        HWND                   listWnd;
        WCHAR                 sTime[32];
        gData.GetListWindow(&listWnd);
        node->SetTimeStamp(gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ));
        SendMessage(listWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)node);
    }

    if (bCoInitialized)
        CoUninitialize();
    
    return rc;
}

typedef TServerNode * PSERVERNODE;


//----------------------------------------------------------------------------
// Function:   IsFileReady
//
// Synopsis:   This function checks if a file exists and no other
//             process is trying to write to it
//
// Arguments:
//
// filename    the name of file to be checked
//
// Returns:    returns TRUE if the file is ready; otherwise, returns FALSE
//
// Modifies:
//----------------------------------------------------------------------------

BOOL IsFileReady(WCHAR* filename)
{
    if (filename == NULL)
        return FALSE;
    
    HANDLE hResult = CreateFile((WCHAR*)filename,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
    
    if (hResult != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hResult);
        return TRUE;
    }
    else
        return FALSE;
    
}

//----------------------------------------------------------------------------
// Function:   MonitorRunningAgent
//
// Synopsis:   This thread entry function is responsible for monitoring the agent represented
//                  by arg (will be casted into a TServerNode pointer).
//   A brief monitoring logic is as follows:
//	a.  We set up a FindFirstChangeNotification (last write) to look for results
//        on the remote machine
//	b.  Start the agent query interval to 1 minute.
//	c.  Use CreateFile to test whether results are present (using FILE_SHARE_READ to make
//        sure the writing is done)
//        This also makes sure we don't lose any last write before the notification is set up
//	d.  If result present, wait on notification for 1 minute (as we don't fully trust notification)
//	     If result not present, query agent to see if it is finished
//		if finised, go to g
//		if not finished, wait on notification for 1 minute		
//	e.  If timeout:
//		if query interval has been reached, query agent (in case results cannot be written)
//			if finished, go to g
//			if alive, double query interval (maxes out at 20 min), go to c
//	     if notification, go to c.
//	g.  pull result
//
// Arguments:
//
// arg              this is the argument for thread entry point function; will be casted into 
//                    a TServerNode pointer
//
// Returns:    always return 0 as the status will be reflected in pNode
//
// Modifies:
//
//----------------------------------------------------------------------------

DWORD __stdcall 
   MonitorRunningAgent(void * arg)
{
    DWORD rc = 0;
    BOOL bDone = FALSE;
    TServerNode* pNode = (TServerNode*) arg;

    const DWORD dwMaxTimeout = 1200000;  // 20 minutes
    const DWORD dwConversionFactor = 10000;  // 1 millisecond / 100 nanoseconds
    const DWORD dwNotificationTimeout = 60000;  // 1 minute
    const DWORD dwRetryTimeout = 60000;  // 1 minute
    DWORD dwAgentQueryTimeout = 60000;  // 1 minute
    ULARGE_INTEGER uliAgentQueryTimeout;
    uliAgentQueryTimeout.QuadPart = (ULONGLONG) dwAgentQueryTimeout * dwConversionFactor;

    // sanity check, we should not pass in NULL in the first place
    _ASSERT(pNode != NULL);
    if (pNode == NULL)
        return 0;
    
    BOOL bAccntRefExpected = pNode->IsAccountReferenceResultExpected();
    BOOL bJoinDomainWithRename = pNode->IsJoinDomainWithRename();
    HANDLE hFindChange = INVALID_HANDLE_VALUE;
    ULARGE_INTEGER uliPreviousTime;
    ULARGE_INTEGER uliCurrentTime;
    _bstr_t remoteResultPath, jobFilename;
    _bstr_t remoteResultFilename, resultFilename;
    _bstr_t remoteSecrefsFilename, secrefsFilename;
    _bstr_t statusFilename;
    WCHAR resultPath[MAX_PATH];
    gData.GetResultDir(resultPath);

    // the following variables are for retry logic in case that agent query fails
    // for "Join Domain with Rename" case, we use 5 retries to make sure joining domain could
    // finish (usually, it takes under one minute but depending on the network condition and
    // CPU usage of computers involved, it could take longer than one minute).  Allowing five
    // retries should cover it pretty well
    // for other purpose, we use 2 retries.
    const DWORD dwMaxNumOfQueryRetries = (bJoinDomainWithRename) ? 5 : 2;  // maximum number of retries
    DWORD dwNumOfQueryRetries = 0;              // number of retries so far

    BOOL bResultReady = FALSE;  // indicates whether the file is ready on the remote machine

    try 
    {
        // prepare the remote and local result file names (both .result and .secrefs files)
        remoteResultPath = pNode->GetRemoteResultPath();
        jobFilename = pNode->GetJobFile();
        remoteResultFilename = remoteResultPath + jobFilename + L".result";
        resultFilename = _bstr_t(resultPath) + jobFilename + L".result";
        if (bAccntRefExpected)
        {
            remoteSecrefsFilename = remoteResultPath + jobFilename + L".secrefs";
            secrefsFilename = _bstr_t(resultPath) + jobFilename + L".secrefs";
        }

        if (bJoinDomainWithRename)
            statusFilename = remoteResultPath + pNode->GetJobID();

        HANDLE hResult;  // file handle to result file
        
        // start monitoring
        // the following are the ways to get out of the while loop
        //   a.  results have shown up in the remote directory and either 
        //       the agent has finished or we cannot query it
        //   b.  results have not shown up and either we cannot query the agent
        //       after certain number of retries (dwMaxNumOfQueryRetries)
        //       or the agent has completed
        GetSystemTimeAsFileTime((FILETIME*)&uliPreviousTime);  // we need to get a starting time for the timeout
        do
        {
            // listen to the central control as well: if we're signaled to be done, let's do so
            gData.GetDone(&bDone);
            if (bDone)
                break;

            // if someone else (detail dialog) has detected the status of the agent, we don't need to keep monitoring
            if (!pNode->IsRunning())
            {
                // check whether we have results back
                if (IsFileReady(remoteResultFilename)
                    && (!bAccntRefExpected || IsFileReady(remoteSecrefsFilename)))
                    bResultReady = TRUE;
                break;
            }
            
            // if the notification has not been set up, we should try to set up
            if (hFindChange == INVALID_HANDLE_VALUE)
            {
                hFindChange = FindFirstChangeNoti