bsolute mouse move"));
    pMouseData->LastX = IM_MOUSEPOS_LOG_TO_OS_ABS(pMouseData->LastX,
                                                  m_desktopWidth);
    pMouseData->LastY = IM_MOUSEPOS_LOG_TO_OS_ABS(pMouseData->LastY,
                                                  m_desktopHeight);

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

/****************************************************************************/
// IMConvertFastPathKeyboardToEvent
//
// Converts the 2 or 3 byte representation of a fast-path keyboard event into
// a kernel keyboard event, taking care to save the key states. Byte 0 is
// the event code and flags byte, byte 1 is the scancode.
// In the case where this is a VK_PACKET input bytes 1 and 2 are the unicode
// character (contained in the scancode).
//
// This handles input of the form
//  TS_INPUT_FASTPATH_EVENT_KEYBOARD and
//  TS_INPUT_FASTPATH_EVENT_VKPACKET
//
/****************************************************************************/
BOOL __fastcall SHCLASS IMConvertFastPathKeyboardToEvent(
        BYTE *pData,
        KEYBOARD_INPUT_DATA *pKbdData)
{
    BOOL rc = TRUE;
    unsigned code = 0;
    BOOL fHandlingVKPacket = FALSE;

    DC_BEGIN_FN("IMConvertFastPathKeyboardToEvent");

    // Set up basic params.
    // We define the fastpath keyboard flags to be the same as the KEY_BREAK,
    // KEY_E0, and KEY_E1 to allow us to simply copy the low-order 3 bits of
    // the first byte into the KbdData.Flags field.
    pKbdData->Flags = *pData & 0x07;
    pKbdData->UnitId = 0;
    if (TS_INPUT_FASTPATH_EVENT_KEYBOARD ==
        (*pData & TS_INPUT_FASTPATH_EVENT_MASK))
    {
        code = pKbdData->MakeCode = pData[1];
    }
    else if (TS_INPUT_FASTPATH_EVENT_VKPACKET ==
        (*pData & TS_INPUT_FASTPATH_EVENT_MASK))
    {
        fHandlingVKPacket = TRUE;
        // Scancode is a 2 byte unicode char in this case
        memcpy(&code, &pData[1], 2);
        pKbdData->MakeCode = (USHORT)code;
        pKbdData->Flags |= KEY_TERMSRV_VKPACKET;
    }
    
    pKbdData->ExtraInformation = 0;

    if (m_pTSWd->StackClass == Stack_Shadow ) {
        // this event is coming from a shadow client: tell the target to sync
        pKbdData->Flags |= KEY_TERMSRV_SHADOW;
    }

    if (fHandlingVKPacket)
    {
        TRC_NRM((TB,"IH VKpkt Unicode val: 0x%x flags:0x%x\n",
                 code, pKbdData->Flags));
        //No further processing
        DC_QUIT;
    }

    // Special case control/ALT keys: distinguish L & R keys in the keystate
    // array.
    if (pData[0] & TS_INPUT_FASTPATH_KBD_EXTENDED) {
        if (pData[1] == IM_SC_LCONTROL)
            code = IM_SC_RCONTROL;
        else if (pData[1] == IM_SC_LALT)
            code = IM_SC_RALT;
    }

    // Check for the RELEASE flag, which is TRUE for a key release, FALSE
    // for keypresses and repeats.
    if (pData[0] & TS_INPUT_FASTPATH_KBD_RELEASE) {

#ifdef DELETE_UNMATCHED_KEYUPS
        // Check whether this is an unmatched key up event (rather than
        // a key event that's not been matched up!)
        if (IM_KEY_STATE_IS_UP(imKeyStates[pData[1]])) {
            // Discard unmatched key up event
            TRC_NRM((TB, "discard up event %04hX", pData[1]));
            rc = FALSE;
            DC_QUIT;
        }
#endif

        // Update the key state array.
        TRC_DBG((TB,"set sc %u state UP (%#x)", code, imKeyStates[code]));
        IM_SET_KEY_UP(imKeyStates[code]);
    }
    else {
        // Update the key state array.
        TRC_DBG((TB,"set sc %u state DOWN (%#x)", code, imKeyStates[code]));
        IM_SET_KEY_DOWN(imKeyStates[code]);
    }

    // Compile-time assertions to make sure the flags are okay.
#if (TS_INPUT_FASTPATH_KBD_RELEASE != KEY_BREAK)
#error TS RELEASE definition doesn't agree with driver flag
#endif
#if (TS_INPUT_FASTPATH_KBD_EXTENDED != KEY_E0)
#error TS EXTENDED definition doesn't agree with driver flag
#endif
#if (TS_INPUT_FASTPATH_KBD_EXTENDED1 != KEY_E1)
#error TS EXTENDED1 definition doesn't agree with driver flag
#endif

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// IMDoSync
//
// Encapsulates the actions for a sync for common use by regular and
// fastpath input.
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS IMDoSync(unsigned ToggleFlags)
{
    NTSTATUS Status;
    KEYBOARD_INPUT_DATA KbdData;

    DC_BEGIN_FN("IMDoSync");

    // We just need to reset the key state.
    IMResetKeyStateArray();

    // Send special "reset keylight state" injection to win32k.
    // The particular states to set are contained in ToggleFlags.
    KbdData.MakeCode = 0xFF;
    #ifdef _HYDRA_
    KbdData.Flags = KEY_TERMSRV_SET_LED;
    #else
    KbdData.Flags = KEY_CITRIX_SET_LED;
    #endif

    if (m_pTSWd->StackClass == Stack_Shadow ) {
        // this event is coming from a shadow client: tell the target to sync
        KbdData.Flags |= KEY_TERMSRV_SHADOW;
    }

    KbdData.ExtraInformation = ToggleFlags;

    TRC_NRM((TB, "Injecting toggle keys sync event %lx", ToggleFlags));
    Status = IcaChannelInput(m_pTSWd->pContext, Channel_Keyboard, 0, NULL,
            (unsigned char *)&KbdData, sizeof(KEYBOARD_INPUT_DATA));
    TRC_DBG((TB, "Return from toggles input injection %lu",
            Status));

    DC_END_FN();
    return Status;
}


/****************************************************************************/
/* FUNCTION: IMResetKeyStateArray                                           */
/*                                                                          */
/* Called to reset the keystate array                                       */
/****************************************************************************/
void RDPCALL SHCLASS IMResetKeyStateArray()
{
    BOOL rc = TRUE;
    unsigned i;
    NTSTATUS Status;

    DC_BEGIN_FN("IMResetKeyStateArray");

    /************************************************************************/
    /* This function is called to reset all keys to a known state           */
    /* (up) before resetting the keys with new states.                      */
    /************************************************************************/

    /************************************************************************/
    /* Loop through all keys looking for any that are not in a neutral      */
    /* state.  In this case any key that is in a KEY_DOWN state is not      */
    /* considered neutral.                                                  */
    /************************************************************************/
    for (i = 0; i < IM_KEY_STATE_SIZE; i++)
    {
        if (IM_KEY_STATE_IS_DOWN(imKeyStates[i])) {
            TRC_NRM((TB, "Key is down %u", i));

            /****************************************************************/
            /* Handle the mouse buttons first                               */
            /****************************************************************/
            if ((i == IM_SC_LBUTTON)  ||
                    (i == IM_SC_RBUTTON)  ||
                    (i == IM_SC_MBUTTON)  ||
                    (i == IM_SC_XBUTTON1) ||
                    (i == IM_SC_XBUTTON2))
            {
                MOUSE_INPUT_DATA MouseData;

                /************************************************************/
                /* Generate a mouse event with the particular button type   */
                /* and a relative mouse move of zero.                       */
                /************************************************************/
                memset(&MouseData, 0, sizeof(MOUSE_INPUT_DATA));

                if (i == IM_SC_LBUTTON)
                {
                    MouseData.ButtonFlags = MOUSE_LEFT_BUTTON_UP;
                }
                else if (i == IM_SC_RBUTTON)
                {
                    MouseData.ButtonFlags = MOUSE_RIGHT_BUTTON_UP;
                }
                else if (i == IM_SC_MBUTTON)
                {
                    MouseData.ButtonFlags = MOUSE_MIDDLE_BUTTON_UP;
                }
                else if (i == IM_SC_XBUTTON1)
                {
                    MouseData.ButtonFlags = MOUSE_BUTTON_4_UP;
                }
                else /* IM_SC_XBUTTON2 */
                {
                    MouseData.ButtonFlags = MOUSE_BUTTON_5_UP;
                }

                /************************************************************/
                /* Store the injection time for guessing at SetCursorPos    */
                /* calls.                                                   */
                /************************************************************/
                COM_GETTICKCOUNT(imLastLowLevelMouseEventTime);

                TRC_NRM((TB, "Inject mouse event: x(%ld) y(%ld) flags(%#hx)"
                                                          "buttonFlags(%#hx)",
                                                    MouseData.LastX,
                                                    MouseData.LastY,
                                                    MouseData.Flags,
                                                    MouseData.ButtonFlags));
                Status = IcaChannelInput(m_pTSWd->pContext,
                                         Channel_Mouse,
                                         0,
                                         NULL,
                                         (unsigned char *)&MouseData,
                                         sizeof(MOUSE_INPUT_DATA));
                TRC_DBG((TB, "Return from mouse input injection %lu",
                                                                    Status));
            }
            else {
                KEYBOARD_INPUT_DATA KbdData;

                /************************************************************/
                /* Generate a keyboard key up event                         */
                /************************************************************/
                KbdData.UnitId           = 0;
                if (i == IM_SC_RCONTROL)
                {
                    KbdData.Flags        = KEY_BREAK | KEY_E0;
                    KbdData.MakeCode     = IM_SC_LCONTROL;
                }
                else if (i == IM_SC_RALT)
                {
                    KbdData.Flags        = KEY_BREAK | KEY_E0;
                    KbdData.MakeCode     = IM_SC_LALT;
                }
                else
                {
                    KbdData.Flags        = KEY_BREAK;
                    KbdData.MakeCode     = (unsigned short)i;
                }

                KbdData.Reserved         = 0;
                KbdData.ExtraInformation = 0;

                TRC_NRM((TB, "Inject keybd event: make code (%u) flags(%#x)",
                         KbdData.MakeCode, KbdData.Flags));
                Status = IcaChannelInput(m_pTSWd->pContext,
                                         Channel_Keyboard,
                                         0,
                                         NULL,
                                         (unsigned char *)&KbdData,
                                         sizeof(KEYBOARD_INPUT_DATA));
                TRC_DBG((TB, "Return from keyboard input injection %lu",
                                                                    Status));
            }
        }
    }

    // Set all keys up.
    memset((PVOID)imKeyStates, 0, IM_KEY_STATE_SIZE);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\anmapi.c ===
/****************************************************************************/
// anmapi.c
//
// Network Manger
//
// Copyright(C) Microsoft Corporation 1997-1999
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "anmapi"
#define pTRCWd (pRealNMHandle->pWDHandle)

#include <adcg.h>
#include <acomapi.h>
#include <anmint.h>
#include <asmapi.h>
#include <nwdwapi.h>
#include <anmapi.h>
#include <nprcount.h>
#include <tschannl.h>


/****************************************************************************/
/* Name:      NM_GetDataSize                                                */
/*                                                                          */
/* Purpose:   Returns size of per-instance NM data required                 */
/*                                                                          */
/* Returns:   size of data required                                         */
/*                                                                          */
/* Operation: NM stores per-instance data in a piece of memory allocated    */
/*            by WDW.  This function returns the size of the data required. */
/*            A pointer to this data (the 'NM Handle') is passed into all   */
/*            subsequent NM functions.                                      */
/****************************************************************************/
unsigned RDPCALL NM_GetDataSize(void)
{
    DC_BEGIN_FN("NM_GetDataSize");

    DC_END_FN();
    return(sizeof(NM_HANDLE_DATA));
} /* NM_GetDataSize */


/****************************************************************************/
/* Name:      NM_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize NM                                                 */
/*                                                                          */
/* Returns:   TRUE -  Registered OK                                         */
/*            FALSE - Registration failed                                   */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*            pSMHandle - SM handle, stored by NM and passed on callbacks   */
/*                        to SM                                             */
/*            pWDHandle - WD handle, required for tracing                   */
/*            hDomainKernel - MCS handle stored from MCSInitialize() and    */
/*                            used to attach a user.                        */
/*                                                                          */
/* Operation: Initialize NM:                                                */
/*            - initialize per-instance data                                */
/*            - open channel for communication with PDMCS                   */
/****************************************************************************/
BOOL RDPCALL NM_Init(PVOID      pNMHandle,
                     PVOID      pSMHandle,
                     PTSHARE_WD   pWDHandle,
                     DomainHandle hDomainKernel)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    DC_BEGIN_FN("NM_Init");

    /************************************************************************/
    /* WARNING: Don't trace before storing the WD Handle                    */
    /************************************************************************/
    pRealNMHandle->pWDHandle = pWDHandle;
    pRealNMHandle->pSMHandle = pSMHandle;
    pRealNMHandle->pContext  = pWDHandle->pContext;
    pRealNMHandle->hDomain   = hDomainKernel;

    DC_END_FN();
    return(TRUE);
} /* NM_Init */


/****************************************************************************/
/* Name:      NM_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate NM                                                  */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*                                                                          */
/* Operation: Terminate NM                                                  */
/*            - close channel opened by NM_Init                             */
/****************************************************************************/
void RDPCALL NM_Term(PVOID pNMHandle)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    unsigned i;
    PNM_CHANNEL_DATA pChannelData;

    DC_BEGIN_FN("NM_Term");

    TRC_NRM((TB, "Terminate NM"));

    /************************************************************************/
    /* Free any half-received virtual channel data                          */
    /************************************************************************/
    for (i = 0, pChannelData = pRealNMHandle->channelData;
         i < pRealNMHandle->channelArrayCount;
         i++, pChannelData++)
    {
        if (pChannelData->pData != NULL)
        {
            TRC_NRM((TB, "Free %p", pChannelData->pData));
            COM_Free(pChannelData->pData);
        }
    }

    DC_END_FN();
} /* NM_Term */


/****************************************************************************/
/* Name:      NM_Connect                                                    */
/*                                                                          */
/* Purpose:   Starts the process of connecting to the Client                */
/*                                                                          */
/* Returns:   TRUE  - Connect started OK                                    */
/*            FALSE - Connect failed to start                               */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*            pUserDataIn - user data received from Client                  */
/*                                                                          */
/* Operation: Attach the user to the domain.  PDMCS knows about only 1      */
/*            domain, so that one is assumed.                               */
/*                                                                          */
/*            When the AttachUser completes, join two channels:             */
/*            - the dynamically allocated broadcast channel (ID returned on */
/*              the SM_OnConnected callback)                                */
/*            - the single-user channel for this user.                      */
/*                                                                          */
/*            Note that this function completes asynchronously.  The caller */
/*            must wait for a SM_OnConnected or SM_OnDisconnected           */
/*            callback to find out whether the Connect succeeded or failed. */
/****************************************************************************/
BOOL RDPCALL NM_Connect(PVOID pNMHandle, PRNS_UD_CS_NET pUserDataIn)
{
    BOOL            rc = FALSE;
    BOOLEAN         bCompleted;
    MCSError        MCSErr;
    ChannelHandle   hChannel;
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    unsigned        i, j;
    unsigned        userDataOutLength;
    PRNS_UD_SC_NET  pUserDataOut = NULL;
    PCHANNEL_DEF    pChannel;
    UINT16          *pMCSChannel;
    ChannelID       ChID;
    UINT32          DataLenValidate;

    // for unalignment use purpose
    UserHandle      UserHandleTemp;
    unsigned        MaxSendSizeTemp;

    DC_BEGIN_FN("NM_Connect");

    /************************************************************************/
    /* Clear the connection status                                          */
    /************************************************************************/
    pRealNMHandle->connectStatus = 0;

    /************************************************************************/
    /* Save virtual channel data                                            */
    /************************************************************************/
    if (pUserDataIn != NULL)
    {
        TRC_DATA_NRM("Net User Data",
                pUserDataIn,
                pUserDataIn->header.length);
        TRC_NRM((TB, "Protocol version %#x (%#x/%#x)",
                pRealNMHandle->pWDHandle->version,
                _RNS_MAJOR_VERSION(pRealNMHandle->pWDHandle->version),
                _RNS_MINOR_VERSION(pRealNMHandle->pWDHandle->version)));

        /********************************************************************/
        /* Protocol version 0x00080002 used 2-byte channel data lengths.    */
        /* Protocol version 0x00080003 and higher use 4-byte data lengths.  */
        /* If this is a 2-byte version, ignore its virtual channels.        */
        /********************************************************************/
        if (_RNS_MINOR_VERSION(pRealNMHandle->pWDHandle->version) >= 3)
        {
            // Validate channle count
            DataLenValidate =  pUserDataIn->channelCount * sizeof(CHANNEL_DEF);
            DataLenValidate += sizeof(RNS_UD_CS_NET);

            if (DataLenValidate > pUserDataIn->header.length) 
            {
                TRC_ERR((TB, "Error: Virtual channel data length %u too short for %u",
                         pUserDataIn->header.length, DataLenValidate));
                pRealNMHandle->channelCount = 0;
                pRealNMHandle->channelArrayCount = 0;
                WDW_LogAndDisconnect(pRealNMHandle->pWDHandle, TRUE, 
                    Log_RDP_VChannelDataTooShort, (PBYTE)pUserDataIn, pUserDataIn->header.length);
                DC_QUIT;
            }

            // we reserve channel 7 for RDPDD so we can allow only the 
            // buffer size - 1 channels.
            if (pUserDataIn->channelCount > sizeof(pRealNMHandle->channelData)
                                  / sizeof(pRealNMHandle->channelData[0]) - 1) {
                TRC_ERR((TB, "Error: Too many virtual channels to join: %u.", 
                                                    pUserDataIn->channelCount));
                pRealNMHandle->channelCount = 0;
                pRealNMHandle->channelArrayCount = 0;
                WDW_LogAndDisconnect(pRealNMHandle->pWDHandle, TRUE, 
                    Log_RDP_VChannelsTooMany, (PBYTE)pUserDataIn, 
                    pUserDataIn->header.length);
                DC_QUIT;
            }
               
                
            pRealNMHandle->channelCount = pUserDataIn->channelCount;
            pChannel = (PCHANNEL_DEF)(pUserDataIn + 1);
            for (i = 0, j = 0; i < pRealNMHandle->channelCount; i++, j++)
            {
                /************************************************************/
                /* Channel 7 is used by RDPDD, so skip it                   */
                /************************************************************/
                if (i == WD_THINWIRE_CHANNEL)
                {
                    j++;
                }

                /************************************************************/
                /* Save channel data                                        */
                /************************************************************/
                strncpy(pRealNMHandle->channelData[j].name,
                           pChannel[i].name,
                           CHANNEL_NAME_LEN);
                // make sure that the name is zero-terminated
                (pRealNMHandle->channelData[j].name)[CHANNEL_NAME_LEN] = 0;
                pRealNMHandle->channelData[j].flags = pChannel[i].options;

                TRC_NRM((TB, "Channel %d (was %d): %s",
                        j, i, pChannel[i].name));
            }
            pRealNMHandle->channelArrayCount = j;
        }
        else
        {
            TRC_ERR((TB,
              "Minor version %#x doesn't support 4-byte channel data lengths",
              _RNS_MINOR_VERSION(pRealNMHandle->pWDHandle->version)));
            pRealNMHandle->channelCount = 0;
            pRealNMHandle->channelArrayCount = 0;
        }
    }
    else
    {
        /********************************************************************/
        /* No incoming user data = no virtual channels                      */
        /********************************************************************/
        TRC_NRM((TB, "No virtual channels"));
        pRealNMHandle->channelCount = 0;
        pRealNMHandle->channelArrayCount = 0;
    }

    /************************************************************************/
    /* Allocate space for returned user data                                */
    /************************************************************************/
    userDataOutLength = (sizeof(RNS_UD_SC_NET) +
                        (sizeof(UINT16) * pRealNMHandle->channelCount));
    userDataOutLength = (unsigned)(DC_ROUND_UP_4(userDataOutLength));
    pUserDataOut = COM_Malloc(userDataOutLength);
    if (pUserDataOut != NULL) {
        memset(pUserDataOut, 0, userDataOutLength);
    }
    else {
        TRC_ERR((TB, "Failed to alloc %d bytes for user data",
                userDataOutLength));
        DC_QUIT;
    }

    /************************************************************************/
    /* Make the attach-user request call.                                   */
    /************************************************************************/
    TRC_NRM((TB, "Attach User"));
    
    UserHandleTemp = pRealNMHandle->hUser;
    MaxSendSizeTemp = pRealNMHandle->maxPDUSize;
    MCSErr = MCSAttachUserRequest(pRealNMHandle->hDomain,
                                  NM_MCSUserCallback,
                                  SM_MCSSendDataCallback,
                                  pNMHandle,
                                  &UserHandleTemp,
                                  &MaxSendSizeTemp,
                                  (BOOLEAN *)(&bCompleted));
    pRealNMHandle->hUser = UserHandleTemp;
    pRealNMHandle->maxPDUSize = MaxSendSizeTemp;
    if (MCSErr == MCS_NO_ERROR) {
        TRC_NRM((TB, "AttachUser OK, hUser %p", pRealNMHandle->hUser));

        TRC_ASSERT((bCompleted),
                (TB, "MCSAttachUser didn't complete synchronously"));

        // Extract extra information.
        pRealNMHandle->userID = MCSGetUserIDFromHandle(pRealNMHandle->hUser);
        pRealNMHandle->connectStatus |= NM_CONNECT_ATTACH;
        TRC_NRM((TB, "Attached as user %x, hUser %p",
                pRealNMHandle->userID, pRealNMHandle->hUser));
    }
    else {
        TRC_ERR((TB, "Failed AttachUserRequest, MCSErr %d", MCSErr));
        DC_QUIT;
    }

    /************************************************************************/
    /* Join the broadcast channel                                           */
    /************************************************************************/
    MCSErr = MCSChannelJoinRequest(pRealNMHandle->hUser,
                                   0,
                                   &hChannel,
                                   &bCompleted);
    if (MCSErr == MCS_NO_ERROR) {
        TRC_ASSERT((bCompleted),
                (TB, "MCSChannelJoin didn't complete synchronously"));

        // Extract information.
        ChID = MCSGetChannelIDFromHandle(hChannel);
        pRealNMHandle->channelID = ChID;
        pRealNMHandle->hChannel = hChannel;
        pRealNMHandle->connectStatus |= NM_CONNECT_JOIN_BROADCAST;
        TRC_NRM((TB, "Joined broadcast channel %x (hChannel %p) OK",
                ChID, hChannel));
    }
    else {
        TRC_ERR((TB, "Failed to send ChannelJoinRequest, MCSErr %d", MCSErr));
        DC_QUIT;
    }

    /************************************************************************/
    /* Join the user channel                                                */
    /************************************************************************/
    MCSErr = MCSChannelJoinRequest(pRealNMHandle->hUser,
                                   pRealNMHandle->userID,
                                   &hChannel,
                                   &bCompleted);
    if (MCSErr == MCS_NO_ERROR) {
        TRC_ASSERT((bCompleted),
                (TB, "MCSChannelJoin didn't complete synchronously"));

        // Extract information.
        pRealNMHandle->connectStatus |= NM_CONNECT_JOIN_USER;
        TRC_NRM((TB, "Joined user channel (hChannel %p) OK", hChannel));
    }
    else {
        TRC_ERR((TB, "Failed to send ChannelJoinRequest, MCSErr %d", MCSErr));
        DC_QUIT;
    }

    /************************************************************************/
    /* If no virtual channels, we're done.                                  */
    /************************************************************************/
    if (pRealNMHandle->channelCount == 0)
    {
        TRC_NRM((TB, "No virtual channels to join"));
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Join virtual channels                                                */
    /************************************************************************/
    for (i = 0; i < pRealNMHandle->channelArrayCount; i++)
    {
        if (i == WD_THINWIRE_CHANNEL)
        {
            TRC_NRM((TB, "Skip channel %d", WD_THINWIRE_CHANNEL));
            continue;
        }

        MCSErr = MCSChannelJoinRequest(pRealNMHandle->hUser,
                                       0,
                                       &hChannel,
                                       &bCompleted);
        if (MCSErr == MCS_NO_ERROR) {
            TRC_ASSERT((bCompleted),
                    (TB, "MCSChannelJoin didn't complete synchronously"));

            ChID = MCSGetChannelIDFromHandle(hChannel);
            pRealNMHandle->channelData[i].MCSChannelID = (UINT16)ChID;
            TRC_NRM((TB, "Joined VC %d: %d (hChannel %p)", i, ChID, hChannel));
        }
        else {
            TRC_ERR((TB, "ChannelJoinRequest failed, MCSErr %d", MCSErr));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Everything completed OK                                              */
    /************************************************************************/
    rc = TRUE;

DC_EXIT_POINT:
    if (rc)
    {
        /********************************************************************/
        /* Everything is OK - Complete the user data                        */
        /********************************************************************/
        pUserDataOut->header.type = RNS_UD_SC_NET_ID;
        pUserDataOut->header.length = (UINT16)userDataOutLength;
        pUserDataOut->MCSChannelID = (UINT16)pRealNMHandle->channelID;
        pUserDataOut->channelCount = (UINT16)pRealNMHandle->channelCount;
        pMCSChannel = (UINT16 *)(pUserDataOut + 1);
        TRC_NRM((TB, "Copy %d channels to user data out",
                pRealNMHandle->channelCount));
        for (i = 0, j = 0; i < pRealNMHandle->channelCount; i++, j++)
        {
            if (i == WD_THINWIRE_CHANNEL)
            {
                TRC_NRM((TB, "Skip channel %d", WD_THINWIRE_CHANNEL));
                j++;
            }
            pMCSChannel[i] = pRealNMHandle->channelData[j].MCSChannelID;
            TRC_NRM((TB, "Channel %d (%d) = %#x", i, j, pMCSChannel[i]));
        }

        /********************************************************************/
        /* Tell SM we're connected now                                      */
        /********************************************************************/
        TRC_NRM((TB, "Tell SM we're connecting"));
        SM_OnConnected(pRealNMHandle->pSMHandle, pRealNMHandle->userID,
                NM_CB_CONN_OK, pUserDataOut, pRealNMHandle->maxPDUSize);
    }
    else
    {
        /********************************************************************/
        /* Something failed - abort the connection                          */
        /********************************************************************/
        TRC_NRM((TB, "Something failed - abort the connection"));
        NMAbortConnect(pRealNMHandle);
    }

    /************************************************************************/
    /* Whether we succeeded or failed, we don't need the user data any      */
    /* more.                                                                */
    /************************************************************************/
    TRC_NRM((TB, "Free user data"));
    if (pUserDataOut != NULL) {
        COM_Free(pUserDataOut);
    }
            
    DC_END_FN();
    return(rc);
} /* NM_Connect */


/****************************************************************************/
/* Name:      NM_GetMCSDomainInfo                                           */
/*                                                                          */
/* Purpose:   Return the broadcast channel ID to allow shadowing of this    */
/*            share.                                                        */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/****************************************************************************/
ChannelID RDPCALL NM_GetMCSDomainInfo(PVOID pNMHandle)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;

    return pRealNMHandle->channelID;
}


/****************************************************************************/
/* Name:      NM_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect from a Client                                      */
/*                                                                          */
/* Returns:   TRUE  - Disconnect started OK                                 */
/*            FALSE - Disconnect failed                                     */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*                                                                          */
/* Operation: Detach the user from the domain.                              */
/*                                                                          */
/*            Note that this function completes asynchronously.  The caller */
/*            must wait for a SM_OnDisconnected callback to find whether    */
/*            the Disconnect succeeded or failed.                           */
/****************************************************************************/
BOOL RDPCALL NM_Disconnect(PVOID pNMHandle)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    BOOL          rc = TRUE;

    DC_BEGIN_FN("NM_Disconnect");

    /************************************************************************/
    /* Detach from MCS                                                      */
    /************************************************************************/
    if (pRealNMHandle->connectStatus & NM_CONNECT_ATTACH)
    {
        TRC_NRM((TB, "User attached, need to detach"));
        rc = NMDetachUserReq(pRealNMHandle);
    }

    DC_END_FN();
    return(rc);
} /* NM_Disconnect */


/****************************************************************************/
/* Name:      NM_AllocBuffer                                                */
/*                                                                          */
/* Purpose:   Acquire a buffer for transmission                             */
/*                                                                          */
/* Returns:   TRUE  - Buffer acquired OK                                    */
/*            FALSE - No buffer available                                   */
/*                                                                          */
/* Params:    pNMHandle  - NM handle                                        */
/*            ppBuffer   - Buffer acquired (returned)                       */
/*            bufferSize - size of buffer required                          */
/*                                                                          */
/* Operation: Get a buffer from ICA (via IcaBufferAlloc)                    */
/*            This function is synchronous.                                 */
/****************************************************************************/
NTSTATUS __fastcall NM_AllocBuffer(PVOID  pNMHandle,
                               PPVOID ppBuffer,
                               UINT32 bufferSize,
                               BOOLEAN fWait)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    NTSTATUS        status;
    POUTBUF         pOutBuf;
    int             i;
    UINT32          realBufferSize;

    DC_BEGIN_FN("NM_AllocBuffer");

    /************************************************************************/
    /* Calculate the actual size of data required. Includes a POUTBUF       */
    /* prefix to point back to the beginning of the OutBuf so we can send   */
    /* the right thing to MCS.                                              */
    /************************************************************************/
    TRC_ASSERT((bufferSize < 16384),
            (TB,"Buffer req size %u will cause MCS fragmentation, unsupported",
            bufferSize));
    realBufferSize = bufferSize + SendDataReqPrefixBytes + sizeof(POUTBUF);

    /************************************************************************/
    /* Allocate an OutBuf                                                   */
    /************************************************************************/
    status = IcaBufferAlloc(pRealNMHandle->pContext,
                            fWait,       /* wait/not wait for a buffer      */
                            FALSE,      /* not a control buffer             */
                            realBufferSize,
                            NULL,       /* no original buffer               */
                            (PVOID *)(&pOutBuf));
    if (status == STATUS_SUCCESS) {  // NT_SUCCESS() does not fail STATUS_TIMEOUT
        /********************************************************************/
        /* The OutBuf returned includes a data buffer pointer, which points */
        /* to a buffer containing                                           */
        /* - a pointer to the beginning of the OutBuf (which we set here)   */
        /* - SendDataReqPrefixBytes                                         */
        /* - user data buffer (size bufferSize)                             */
        /* Set the OutBuf pBuffer pointer to the beginning of the user data.*/
        /* MCS requires this.                                               */
        /* Return to the user a pointer to the user data buffer.            */
        /********************************************************************/
        *((POUTBUF *)pOutBuf->pBuffer) = pOutBuf;
        pOutBuf->pBuffer += SendDataReqPrefixBytes + sizeof(POUTBUF);
        *ppBuffer = pOutBuf->pBuffer;

        TRC_NRM((TB, "Alloc %d bytes OK", bufferSize));
    }
    else
    {
        TRC_ERR((TB, "Failed to alloc %d bytes, status %x",
                bufferSize, status));

        //
        // TODO - consider disconnect client here instead of SM_AllocBuffer(), 
        // keep it in SM_AllocBuffer() so that we don't introduce any regression.
        //

        //
        // IcaBufferAlloc() returns STATUS_IO_TIMEOUT, STATUS_NO_MEMORY, and
        // IcaWaitForSingleObject() which returns KeWaitForSingleObject() or 
        // STATUS_CTX_CLOSE_PENDING.  SM_AllocBuffer() need to disconnect this client only
        // when error code is STATUS_IO_TIMEOUT so we keep this return code
    }

    DC_END_FN();
    return status;
} /* NM_AllocBuffer */


/****************************************************************************/
/* Name:      NM_FreeBuffer                                                 */
/*                                                                          */
/* Purpose:   Free a transmit buffer                                        */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*            pBuffer   - Buffer to free                                    */
/*                                                                          */
/* Operation: Free a buffer (via IcaBufferFree)                             */
/*            This function assumes the buffer was allocated using          */
/*            NM_AllocBuffer.                                               */
/*                                                                          */
/*            This function is only for freeing buffers which are not sent. */
/*            It should not be called for buffers which are sent -          */
/*            NM_SendData frees the buffer whether the Send succeeds or     */
/*            not.                                                          */
/*                                                                          */
/*            This function is synchronous.                                 */
/****************************************************************************/
void __fastcall NM_FreeBuffer(PVOID pNMHandle, PVOID pBuffer)
{
    POUTBUF         pOutBuf;
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;

    DC_BEGIN_FN("NM_FreeBuffer");

    /************************************************************************/
    /* Get the OutBuf pointer stored in prefix                              */
    /************************************************************************/
    pOutBuf = *((POUTBUF *)
                ((BYTE *)pBuffer - SendDataReqPrefixBytes - sizeof(POUTBUF)));

    /************************************************************************/
    /* Free the buffer                                                      */
    /************************************************************************/
    IcaBufferFree(pRealNMHandle->pContext, pOutBuf);

    DC_END_FN();
} /* NM_FreeBuffer */


/****************************************************************************/
/* Name:      NM_SendData                                                   */
/*                                                                          */
/* Purpose:   Send data to the appropriate net or pipe destination.         */
/*                                                                          */
/* Returns:   TRUE  - data sent OK                                          */
/*            FALSE - data not sent                                         */
/*                                                                          */
/* Params:    pNMHandle - NM handle                                         */
/*            pData     - data to send                                      */
/*            dataSize  - length of data to send                            */
/*            priority  - priority to send the data on                      */
/*            userID    - user to send the data to (0 = broadcast data)     */
/*            FastPathOutputFlags - flags from higher layers. Low bit TRUE  */
/*                means send as fast-path output, using the rest of the     */
/*                
/*                                                                          */
/* Operation: Send the data.                                                */
/*            - The buffer holding the data must have been allocated using  */
/*              NM_AllocBuffer.                                             */
/*            - Return code FALSE means that a network error occurred.  The */
/*              caller need do nothing - an NM_DISCONNECTED callback will   */
/*              eventually arrive.                                          */
/*            - The buffer is ALWAYS freed.                                 */
/*                                                                          */
/*            This function is synchronous.                                 */
/****************************************************************************/
BOOL __fastcall NM_SendData(
        PVOID  pNMHandle,
        PBYTE  pData,
        UINT32 dataSize,
        UINT32 priority,
        UINT32 userID,
        UINT32 FastPathOutputFlags)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    BOOL rc = TRUE;
    POUTBUF pOutBuf;
    MCSError MCSErr;

    DC_BEGIN_FN("NM_SendData");

    /************************************************************************/
    /* Get the OutBuf pointer stored in prefix                              */
    /************************************************************************/
    pOutBuf = *((POUTBUF *)
            ((BYTE *)pData - SendDataReqPrefixBytes - sizeof(POUTBUF)));

    /************************************************************************/
    /* Complete the OutBuf. The pBuffer was already set up when the OutBuf  */
    /* was allocated. MCS needs the user data size set in the OutBuf.       */
    /************************************************************************/
    pOutBuf->ByteCount = dataSize;

    // All but shadow passthru stacks get the data sent to the network.
    if (pRealNMHandle->pWDHandle->StackClass != Stack_Passthru) {
        if (FastPathOutputFlags & NM_SEND_FASTPATH_OUTPUT) {
            NTSTATUS Status;
            SD_RAWWRITE SdWrite;

            // Fast-path output skips MCS. We rewrite the security header
            // into the fast-path format, complete the OutBuf, and send
            // directly to the transport. For header format details, see
            // at128.h. Note we need to wait for the security header
            // to be written in SM before getting here in case this
            // is a passthru stack.

            // First, the 4-byte RNS_SECURITY_HEADER disappears, if present,
            // collapsed into the high bit of the first byte.
            // Note that the 8-byte MAC signature in RNS_SECURITY_HEADER1
            // remains, if present.
            if (!(FastPathOutputFlags & NM_NO_SECURITY_HEADER)) {
                dataSize -= sizeof(RNS_SECURITY_HEADER);
                pData += sizeof(RNS_SECURITY_HEADER);
            }

            // Work backwards from where we are: First, the total packet
            // length including the header.
            if (dataSize <= 125) {
                // 1-byte form of length, high bit 0.
                dataSize += 2;
                pData -= 2;
                *(pData + 1) = (BYTE)dataSize;
            }
            else {
                // 2-byte form of length, first byte has high bit 1 and 7
                // most significant bits.
                dataSize += 3;
                pData -= 3;
                *(pData + 1) = (BYTE)(0x80 | ((dataSize & 0x7F00) >> 8));
                *(pData + 2) = (BYTE)(dataSize & 0xFF);
            }

            // The header byte. This includes TS_OUTPUT_FASTPATH_ACTION_FASTPATH
            // and TS_OUTPUT_FASTPATH_ENCRYPTED, if present in the
            // fast-path output flags.
            *pData = (BYTE)(TS_OUTPUT_FASTPATH_ACTION_FASTPATH |
                    (FastPathOutputFlags &
                    TS_OUTPUT_FASTPATH_ENCRYPTION_MASK));

            // Set up the OutBuf with its final contents.
            pOutBuf->pBuffer = pData;
            pOutBuf->ByteCount = dataSize;

            // Send downward.
            SdWrite.pBuffer = NULL;
            SdWrite.ByteCount = 0;
            SdWrite.pOutBuf = pOutBuf;

            Status = IcaCallNextDriver(pRealNMHandle->pWDHandle->pContext,
                    SD$RAWWRITE, &SdWrite);
            if (NT_SUCCESS(Status)) {
                // Increment protocol counters.
                pRealNMHandle->pWDHandle->pProtocolStatus->Output.WdFrames++;
                pRealNMHandle->pWDHandle->pProtocolStatus->Output.WdBytes +=
                        dataSize;
            }
            else {
                TRC_ERR((TB,"Failed IcaRawWrite to network, status=%X",
                        Status));
                rc = FALSE;
                // We do not free the OutBuf here, TD is supposed to do it.
            }
        }
        else {
            TRC_DBG((TB, "Send data on channel %x", userID));
            MCSErr = MCSSendDataRequest(pRealNMHandle->hUser,
                    userID == 0 ? pRealNMHandle->hChannel : NULL,
                    NORMAL_SEND_DATA,
                    (ChannelID)userID,
                    (MCSPriority)priority,
                    SEGMENTATION_BEGIN | SEGMENTATION_END,
                    pOutBuf);
            if (MCSErr == MCS_NO_ERROR) {
                TRC_DATA_NRM("Send OK", pOutBuf, dataSize);
            }
            else
            {
                TRC_ERR((TB, "Failed to send OutBuf %p, buffer %p, MCSErr %x",
                        pOutBuf, pData, MCSErr));
                rc = FALSE;
            }
        }

        #ifdef DC_COUNTERS
        if (rc) {
            PTSHARE_WD m_pTSWd = pRealNMHandle->pWDHandle;
    
            if (dataSize > CORE_IN_COUNT[IN_MAX_PKT_SIZE])
            {
                CORE_IN_COUNT[IN_MAX_PKT_SIZE] = dataSize;
            }
            CORE_IN_COUNT[IN_PKT_TOTAL_SENT]++;
            if        (dataSize <  201) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD1]++;
            } else if (dataSize <  401) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD2]++;
            } else if (dataSize <  601) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD3]++;
            } else if (dataSize <  801) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD4]++;
            } else if (dataSize < 1001) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD5]++;
            } else if (dataSize < 1201 ) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD6]++;
            } else if (dataSize <  1401) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD7]++;
            } else if (dataSize <  1601) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD8]++;
            } else if (dataSize <  2001) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD9]++;
            } else if (dataSize <  4001) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD10]++;
            } else if (dataSize <  6001) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD11]++;
            } else if (dataSize <  8001) {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD12]++;
            } else {
                CORE_IN_COUNT[IN_PKT_BYTE_SPREAD13]++;
            }
        }
        #endif
    }

    // Raw write the potentially encrypted data to the shadow stack
    else {
        SD_RAWWRITE SdWrite;
        NTSTATUS    status;

        TRC_ASSERT((!(FastPathOutputFlags & NM_SEND_FASTPATH_OUTPUT)),
                (TB,"Fast-path output requested across shadow pipe!"));

        SdWrite.pOutBuf = pOutBuf;
        SdWrite.pBuffer = NULL;
        SdWrite.ByteCount = 0;

        status = IcaCallNextDriver(pRealNMHandle->pContext, SD$RAWWRITE, &SdWrite);
        if (status == STATUS_SUCCESS) {
            TRC_DBG((TB, "RawWrite: %ld bytes", dataSize));
        }
        else {
            TRC_ERR((TB, "RawWrite failed: %lx", status));
        }
    }

    DC_END_FN();
    return rc;
} /* NM_SendData */


/****************************************************************************/
/* Name:      NM_MCSUserCallback                                            */
/*                                                                          */
/* Purpose:   Direct callback from MCS                                      */
/*                                                                          */
/* Returns:   nothing                                                       */
/*                                                                          */
/* Params:    hUser - should be our user handle                             */
/*            Message - the callback type                                   */
/*            Params - Cast to the right type of parameter depending on     */
/*                     callback                                             */
/*            UserDefined - our NM handle                                   */
/*                                                                          */
/* Operation: Called by MCS for callbacks.                                  */
/*                                                                          */
/*            Processing depends on the callback type                       */
/*            - MCS_DETACH_USER_INDICATION                                  */
/*              - call SM_OnDisconnected                                    */
/*            - all others are ignored.                                     */
/****************************************************************************/
void __stdcall NM_MCSUserCallback(UserHandle hUser,
                                  unsigned   Message,
                                  void       *Params,
                                  void       *UserDefined)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)UserDefined;

    DC_BEGIN_FN("NM_MCSUserCallback");

    /************************************************************************/
    /* First check that this is our UserHandle                              */
    /************************************************************************/
    ASSERT(hUser == pRealNMHandle->hUser);

    /************************************************************************/
    /* If the Share Core is dead, don't do any of this                      */
    /************************************************************************/
    if (pRealNMHandle->dead)
    {
        TRC_ALT((TB, "Callback %s (%d) ignored because we're dead",
        Message == MCS_ATTACH_USER_CONFIRM    ? "MCS_ATTACH_USER_CONFIRM" :
        Message == MCS_CHANNEL_JOIN_CONFIRM   ? "MCS_CHANNEL_JOIN_CONFIRM" :
        Message == MCS_DETACH_USER_INDICATION ? "MCS_DETACH_USER_INDICATION" :
        Message == MCS_SEND_DATA_INDICATION   ? "MCS_SEND_DATA_INDICATION" :
                                                "- Unknown - ",
        Message));
        DC_QUIT;
    }

    /************************************************************************/
    /* Handle callbacks we care about                                       */
    /************************************************************************/
    switch (Message)
    {
        case MCS_DETACH_USER_INDICATION:
        {
            DetachUserIndication *pDUin;

            TRC_NRM((TB, "DetachUserIndication"));

            pDUin = (DetachUserIndication *)Params;
            NMDetachUserInd(pRealNMHandle,
                            pDUin->Reason,
                            pDUin->UserID);
        }
        break;

        default:
        {
            TRC_ERR((TB, "Unhandled MCS callback type %d", Message ));
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* NM_MCSUserCallback */


/****************************************************************************/
/* Name:      NM_Dead                                                       */
/****************************************************************************/
void RDPCALL NM_Dead(PVOID pNMHandle, BOOL dead)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    DC_BEGIN_FN("NM_Dead");

    TRC_NRM((TB, "NM Dead ? %s", pRealNMHandle->dead ? "Y" : "N"));
    pRealNMHandle->dead = dead;

    DC_END_FN();
} /* NM_Dead */


/****************************************************************************/
/* Name:      NM_VirtualQueryBindings                                       */
/*                                                                          */
/* Purpose:   Return virtual channel bindings to WD                         */
/*                                                                          */
/* Params:    pNMHandle - NM Handle                                         */
/*            pVBind - pointer to virtual bindings structure to fill in     */
/*            vBindLength - size (bytes) of virtual bindings structure      */
/*            pBytesReturned - size (bytes) of data returned                */
/****************************************************************************/
NTSTATUS RDPCALL NM_VirtualQueryBindings(PVOID      pNMHandle,
                                         PSD_VCBIND pVBind,
                                         ULONG      vBindLength,
                                         PULONG     pBytesReturned)
{
    NTSTATUS status;
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    USHORT virtualClass;
    UINT i;

    DC_BEGIN_FN("NM_VirtualQueryBindings");

    /************************************************************************/
    /* First see if we have any bindings to report                          */
    /************************************************************************/
    if (pRealNMHandle->channelCount == 0)
    {
        TRC_ALT((TB, "No Virtual Channels to report"));
        *pBytesReturned = 0;
        status = STATUS_SUCCESS;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check there is enough space to report them                           */
    /************************************************************************/
    *pBytesReturned = (pRealNMHandle->channelCount * sizeof(SD_VCBIND));
    if (vBindLength < *pBytesReturned)
    {
        TRC_ERR((TB, "Not enough space for %d VCs: need/got %d/%d",
                pRealNMHandle->channelCount, *pBytesReturned, vBindLength));
        status = STATUS_BUFFER_TOO_SMALL;
        DC_QUIT;
    }

    /************************************************************************/
    /* Copy channel names and assign numbers                                */
    /************************************************************************/
    for (i = 0, virtualClass = 0;
         i < pRealNMHandle->channelCount;
         i++, virtualClass++, pVBind++)
    {
        /********************************************************************/
        /* Can't use channel 7 as it's used by RDPDD                        */
        /********************************************************************/
        if (i == WD_THINWIRE_CHANNEL)
        {
            TRC_NRM((TB, "Skip channel %d", i));
            virtualClass++;
        }

        strcpy(pVBind->VirtualName,
                pRealNMHandle->channelData[virtualClass].name);
        pVBind->VirtualClass = virtualClass;
        pVBind->Flags = 0;

        if (pRealNMHandle->channelData[virtualClass].flags & CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT) {
            pVBind->Flags |= SD_CHANNEL_FLAG_SHADOW_PERSISTENT;
        }
        TRC_NRM((TB, "Assigned channel %d to %s",
                pVBind->VirtualClass, pVBind->VirtualName));
    }

    /************************************************************************/
    /* That's all                                                           */
    /************************************************************************/
    status = STATUS_SUCCESS;

DC_EXIT_POINT:
    DC_END_FN();
    return(status);
} /* NM_VirtualQueryBindings */


/****************************************************************************/
/* Name:      NM_MCSChannelToVirtual                                        */
/*                                                                          */
/* Purpose:   Convert an MCS channel ID into a virtual channel ID           */
/*                                                                          */
/* Returns:   Virtual Channel ID                                            */
/*                                                                          */
/* Params:    pNMHandle - NM Handle                                         */
/*            channelID - MCS Channel ID                                    */
/*            ppChannelData - data stored for this channel (returned)       */
/****************************************************************************/
VIRTUALCHANNELCLASS RDPCALL NM_MCSChannelToVirtual(
        PVOID  pNMHandle,
        UINT16 channelID,
        PPNM_CHANNEL_DATA ppChannelData)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    PNM_CHANNEL_DATA pChannelData;
    unsigned i;
    VIRTUALCHANNELCLASS rc;

    DC_BEGIN_FN("NM_MCSChannelToVirtual");

    /************************************************************************/
    /* Find this MCS Channel                                                */
    /************************************************************************/
    TRC_DBG((TB, "Find MCS channel %hx", channelID));
    for (i = 0, pChannelData = pRealNMHandle->channelData;
         i < pRealNMHandle->channelArrayCount;
         i++, pChannelData++)
    {
        TRC_DBG((TB, "Compare entry %d: %hx", i, pChannelData->MCSChannelID));
        if (pChannelData->MCSChannelID == channelID)
        {
            rc = i;
            *ppChannelData = pChannelData;
            TRC_NRM((TB, "MCS channel %hx is VC %d", channelID, rc));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* If we get here, we failed to find a match                            */
    /************************************************************************/
    TRC_NRM((TB, "No match for MCS channel ID %hx", channelID));
    rc = -1;
    *ppChannelData = NULL;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* NM_MCSChannelToVirtual */


/****************************************************************************/
/* Name:      NM_VirtualChannelToMCS                                        */
/*                                                                          */
/* Purpose:   Convert a virtual channel ID into an MCS channel ID           */
/*                                                                          */
/* Returns:   MCS Channel ID                                                */
/*                                                                          */
/* Params:    pNMHandle - NM Handle                                         */
/*            channelID - virtual channel ID                                */
/*            ppChannelData - data stored for this channel (returned)       */
/****************************************************************************/
INT16 RDPCALL NM_VirtualChannelToMCS(PVOID               pNMHandle,
                                     VIRTUALCHANNELCLASS channelID,
                                     PPNM_CHANNEL_DATA   ppChannelData)
{
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    INT16 rc;

    DC_BEGIN_FN("NM_VirtualChannelToMCS");

    /************************************************************************/
    /* Check the virtual channel is in range                                */
    /************************************************************************/
    if (channelID >= (VIRTUALCHANNELCLASS)(pRealNMHandle->channelArrayCount))
    {
        TRC_ERR((TB, "Unknown virtual channel %d", channelID));
        rc = -1;
        DC_QUIT;
    }

    /************************************************************************/
    /* Find this Virtual Channel                                            */
    /************************************************************************/
    rc = pRealNMHandle->channelData[channelID].MCSChannelID;
    *ppChannelData = &(pRealNMHandle->channelData[channelID]);

    TRC_NRM((TB, "Virtual channel %d = MCS Channel %hx", channelID, rc));

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* NM_VirtualChannelToMCS */


/****************************************************************************/
/* Name:      NM_QueryChannels                                              */
/*                                                                          */
/* Purpose:   Return virtual channel data                                   */
/*                                                                          */
/* Returns:   TRUE/FALSE                                                    */
/*                                                                          */
/* Params:    pNMHandle - NM Handle                                         */
/*            pOutbuf - buffer to receive output data                       */
/*            outbufLength - size of outbuf                                 */
/*            pBytesReturned - amount of data returned                      */
/****************************************************************************/
NTSTATUS RDPCALL NM_QueryChannels(PVOID    pNMHandle,
                                  PVOID    pOutbuf,
                                  unsigned outbufLength,
                                  PULONG   pBytesReturned)
{
    NTSTATUS status;
    PCHANNEL_CONNECT_IN pChannelConnect;
    PCHANNEL_CONNECT_DEF pChannelDef;
    PNM_HANDLE_DATA pRealNMHandle = (PNM_HANDLE_DATA)pNMHandle;
    unsigned bytesNeeded;
    unsigned i;

    DC_BEGIN_FN("NM_QueryChannels");

    /************************************************************************/
    /* Check enough space has been supplied                                 */
    /************************************************************************/
    bytesNeeded = sizeof(CHANNEL_CONNECT_IN) +
             (pRealNMHandle->channelArrayCount * sizeof(CHANNEL_CONNECT_DEF));
    if (outbufLength < bytesNeeded)
    {
        TRC_ERR((TB, "Not enough space: need/got %d/%d",
                bytesNeeded, outbufLength));
        status = STATUS_BUFFER_TOO_SMALL;
        DC_QUIT;
    }

    /************************************************************************/
    /* Complete the returned data                                           */
    /************************************************************************/
    pChannelConnect = (PCHANNEL_CONNECT_IN)pOutbuf;
    pChannelConnect->channelCount = pRealNMHandle->channelArrayCount;
    pChannelDef = (PCHANNEL_CONNECT_DEF)(pChannelConnect + 1);
    for (i = 0; i < pRealNMHandle->channelArrayCount; i++)
    {
        strcpy(pChannelDef[i].name, pRealNMHandle->channelData[i].name);
        pChannelDef[i].ID = i;
    }

    /************************************************************************/
    /* Return status and bytesReturned                                      */
    /************************************************************************/
    *pBytesReturned = bytesNeeded;
    status = STATUS_SUCCESS;

DC_EXIT_POINT:
    DC_END_FN();
    return(status);
} /* NM_QueryChannels */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aimdata.c ===
/****************************************************************************/
/* aimdata.c                                                                */
/*                                                                          */
/* RDP Input manager global data                                            */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
// Key states for this WD (and therefore socket / client).
/****************************************************************************/
DC_DATA_ARRAY_NULL(BYTE, imKeyStates, IM_KEY_STATE_SIZE, NULL);

/****************************************************************************/
/* For tracking SetCursorPos                                                */
/****************************************************************************/
DC_DATA(UINT32, imLastLowLevelMouseEventTime, 0);

/****************************************************************************/
/* Store the last known mouse position.                                     */
/****************************************************************************/
DC_DATA_NULL(POINTL, imLastKnownMousePos, DC_STRUCT2(0,0));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aoadata.c ===
/****************************************************************************/
/* aoadata.c                                                                */
/*                                                                          */
/* Order Accumulation data.                                                 */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, oaSyncRequired, FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\anmint.c ===
/****************************************************************************/
// anmint.c
//
// Network Manager internal functions
//
// Copyright(C) Microsoft Corporation 1997-1998
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "anmint"
#define pTRCWd (pRealNMHandle->pWDHandle)

#include <adcg.h>
#include <acomapi.h>
#include <anmint.h>
#include <asmapi.h>
#include <nwdwapi.h>


/****************************************************************************/
/* Name:      NMDetachUserReq                                               */
/*                                                                          */
/* Purpose:   Call MCSDetachUserReq                                         */
/*                                                                          */
/* Returns:   TRUE  - DetachUser issued successfully                        */
/*            FALSE - DetachUser failed                                     */
/*                                                                          */
/* Params:    pRealNMHandle - NM Handle                                     */
/****************************************************************************/
BOOL RDPCALL NMDetachUserReq(PNM_HANDLE_DATA pRealNMHandle)
{
    BOOL   rc = FALSE;
    MCSError MCSErr;
    DetachUserIndication DUin;

    DC_BEGIN_FN("NMDetachUserReq");

    /************************************************************************/
    /* Make the call.                                                       */
    /************************************************************************/
    MCSErr = MCSDetachUserRequest(pRealNMHandle->hUser);
    
    if (MCSErr == MCS_NO_ERROR)
    {
        TRC_NRM((TB, "DetachUser OK"));

        DUin.UserID = pRealNMHandle->userID;
        DUin.bSelf = TRUE;
        DUin.Reason = REASON_USER_REQUESTED;
        NMDetachUserInd(pRealNMHandle,
                    REASON_USER_REQUESTED,
                    pRealNMHandle->userID);

        rc = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to send DetachUserRequest, MCSErr %d", MCSErr));
    }

    DC_END_FN();
    
    return rc;
} /* NMDetachUserReq */


/****************************************************************************/
/* Name:      NMAbortConnect                                                */
/*                                                                          */
/* Purpose:   Abort a half-formed connection                                */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pRealNMHandle - NM Handle                                     */
/*                                                                          */
/* Operation: This function is called at any point during the connection    */
/*            sequence to clean up resources if anything goes wrong         */
/*                                                                          */
/****************************************************************************/
void RDPCALL NMAbortConnect(PNM_HANDLE_DATA pRealNMHandle)
{
    DC_BEGIN_FN("NMAbortConnect");

    /************************************************************************/
    /* It is my belief that I don't need to leave the channels I have       */
    /* joined, but that I must call DetachUser if AttachUser has completed. */
    /************************************************************************/
    if (pRealNMHandle->connectStatus & NM_CONNECT_ATTACH)
    {
        TRC_NRM((TB, "User attached, need to detach"));
        NMDetachUserReq(pRealNMHandle);
    }

    /************************************************************************/
    /* Tell SM that the connection failed                                   */
    /************************************************************************/
    SM_OnConnected(pRealNMHandle->pSMHandle, 0, NM_CB_CONN_ERR, NULL, 0);

    DC_END_FN();
} /* NMAbortConnect */


/****************************************************************************/
/* Name:      NMDetachUserInd                                               */
/*                                                                          */
/* Purpose:   Handle DetachUserIndication from MCS                          */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pRealNMHandle - NM Handle                                     */
/*            pDUin         - MCSDetachUserIndication Ioctl                 */
/****************************************************************************/
void RDPCALL NMDetachUserInd(PNM_HANDLE_DATA pRealNMHandle,
                             MCSReason       Reason,
                             UserID          userID)
{
    UINT32 result;
    
    DC_BEGIN_FN("NMDetachUserInd");

    /************************************************************************/
    /* Tell SM                                                              */
    /************************************************************************/
    result = Reason == REASON_USER_REQUESTED      ? NM_CB_DISC_CLIENT :
             Reason == REASON_DOMAIN_DISCONNECTED ? NM_CB_DISC_SERVER :
             Reason == REASON_PROVIDER_INITIATED  ? NM_CB_DISC_LOGOFF :
                                                    NM_CB_DISC_NETWORK;
    TRC_NRM((TB, "Detach user %d, reason %d, result %d",
            userID, Reason, result));
    
    if (userID == pRealNMHandle->userID)
    {
        TRC_NRM((TB, "Local user detaching - tell SM"));
        SM_OnDisconnected(pRealNMHandle->pSMHandle, userID, result);
    }

    DC_END_FN();
} /* NMDetachUserInd */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aoeapi.cpp ===
/****************************************************************************/
/* aoeapi.c                                                                 */
/*                                                                          */
/* RDP Order Encoder API functions.                                         */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1994-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precomp.h>
#define hdrstop

#define TRC_FILE "aoeapi"
#include <as_conf.hpp>


/****************************************************************************/
/* OE_Init                                                                  */
/****************************************************************************/
void RDPCALL SHCLASS OE_Init(void)
{
    TS_ORDER_CAPABILITYSET OrdersCaps;

    DC_BEGIN_FN("OE_Init");

#define DC_INIT_DATA
#include <aoedata.c>
#undef DC_INIT_DATA

    /************************************************************************/
    /* Fill in our local capabilities structure used for order support.     */
    /************************************************************************/

    /************************************************************************/
    /* First fill in the common capabilities structure header.              */
    /************************************************************************/
    OrdersCaps.capabilitySetType = TS_CAPSETTYPE_ORDER;

    /************************************************************************/
    /* This is a purely diagnostic field in the capabilities.  It is not    */
    /* negotiated, so we can ignore it and set it to zero.                  */
    /************************************************************************/
    memset(OrdersCaps.terminalDescriptor, 0, sizeof(OrdersCaps.
            terminalDescriptor));

    /************************************************************************/
    /* Fill in the SaveBitmap capabilities.                                 */
    /************************************************************************/
    OrdersCaps.pad4octetsA = ((UINT32)SAVE_BITMAP_WIDTH) *
            ((UINT32)SAVE_BITMAP_HEIGHT);
    OrdersCaps.desktopSaveXGranularity = SAVE_BITMAP_X_GRANULARITY;
    OrdersCaps.desktopSaveYGranularity = SAVE_BITMAP_Y_GRANULARITY;
    OrdersCaps.pad2octetsA = 0;

    /************************************************************************/
    // No fonts supported on server. We use glyph caching.
    /************************************************************************/
    OrdersCaps.numberFonts = (TSUINT16) 0;

    /************************************************************************/
    /* Fill in encoding capabilities                                        */
    /************************************************************************/
    OrdersCaps.orderFlags = TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT |
                            TS_ORDERFLAGS_COLORINDEXSUPPORT;

    /************************************************************************/
    // Fill in which orders we support.
    /************************************************************************/
    OrdersCaps.maximumOrderLevel = ORD_LEVEL_1_ORDERS;
    memcpy(OrdersCaps.orderSupport, oeLocalOrdersSupported, TS_MAX_ORDERS);

    /************************************************************************/
    /* Set the text capability flags.                                       */
    /************************************************************************/
    OrdersCaps.textFlags = TS_TEXTFLAGS_CHECKFONTASPECT |
                           TS_TEXTFLAGS_USEBASELINESTART |
                           TS_TEXTFLAGS_CHECKFONTSIGNATURES |
                           TS_TEXTFLAGS_ALLOWDELTAXSIM |
                           TS_TEXTFLAGS_ALLOWCELLHEIGHT;

    /************************************************************************/
    /* Fill in the multiparty fields, using properties if they exist.       */
    /************************************************************************/
    OrdersCaps.pad2octetsB = 0;
    OrdersCaps.pad4octetsB = SAVE_BITMAP_WIDTH * SAVE_BITMAP_HEIGHT;
    OrdersCaps.desktopSaveSize = SAVE_BITMAP_WIDTH * SAVE_BITMAP_HEIGHT;
    TRC_NRM((TB, "SSI recv bitmap size %ld, send size %ld",
            OrdersCaps.desktopSaveSize, OrdersCaps.pad4octetsB));

    /************************************************************************/
    /* This 2.0 implementation supports sending desktop scroll orders.      */
    /************************************************************************/
    // TODO: Do we still need this set?
    OrdersCaps.pad2octetsC = TRUE;

    // Unused but need to be zeroed.
    OrdersCaps.pad2octetsD = 0;
    OrdersCaps.textANSICodePage = 0;
    OrdersCaps.pad2octetsE = 0;

    /************************************************************************/
    /* Register the orders capabilties structure with the CPC.              */
    /************************************************************************/
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&OrdersCaps,
            sizeof(TS_ORDER_CAPABILITYSET));

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: OE_PartyLeftShare                                              */
/*                                                                          */
/* Called when a part has left the share.                                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - local ID of person leaving share.                             */
/* newShareSize - number of people left in share excluding this one.        */
/****************************************************************************/
void RDPCALL SHCLASS OE_PartyLeftShare(LOCALPERSONID localID,
                                       unsigned          newShareSize)
{
    DC_BEGIN_FN("OE_PartyLeftShare");

    TRC_NRM((TB, "PARTY %d left", localID));

    if (newShareSize > 0) {
        OEDetermineOrderSupport();
        DCS_TriggerUpdateShmCallback();
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: OE_PartyJoiningShare                                           */
/*                                                                          */
/* Called when a party is ready to join the share.                          */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* localID - local ID of person joining share.                              */
/* oldShareSize - number of people in share excluding this one.             */
/*                                                                          */
/* RETURNS: TRUE if the party is acceptable, FALSE if not.                  */
/****************************************************************************/
BOOL RDPCALL SHCLASS OE_PartyJoiningShare(LOCALPERSONID   localID,
                                          unsigned            oldShareSize)
{
    BOOL rc;

    DC_BEGIN_FN("OE_PartyJoiningShare");

    TRC_NRM((TB, "Person %04x joining share, oldShareSize(%d)", localID,
                                                          oldShareSize));
    if (oldShareSize > 0) {
        rc = OEDetermineOrderSupport();
        DCS_TriggerUpdateShmCallback();
    }
    else {
        rc = TRUE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* OE_UpdateShm                                                             */
/****************************************************************************/
void RDPCALL SHCLASS OE_UpdateShm(void)
{
    DC_BEGIN_FN("OE_UpdateShm");

    m_pShm->oe.colorIndices   = oeColorIndexSupported;
    m_pShm->oe.sendSolidPatternBrushOnly = oeSendSolidPatternBrushOnly;
    m_pShm->oe.orderSupported = oeOrderSupported;

    m_pShm->oe.newCapsData = TRUE;

    DC_END_FN();
}


/****************************************************************************/
/* OEDetermineOrderSupport                                                  */
/*                                                                          */
/* Consider the local and remote parties, and determine the group of        */
/* common orders that are supported.                                        */
/****************************************************************************/
BOOL RDPCALL SHCLASS OEDetermineOrderSupport(void)
{
    BOOL CapsOK;

    DC_BEGIN_FN("OEDetermineOrderSupport");

    // Set the initial support to the local support.
    memcpy(oeOrderSupported, oeLocalOrdersSupported, TS_MAX_ORDERS);

    // By default we support sending colors as indices.
    oeColorIndexSupported = TRUE;

    // We normally support the client.
    CapsOK = TRUE;

    // Call the enumerate function to get the orders capabilities of the
    // remote parties.
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_ORDER, (UINT_PTR)&CapsOK,
            OEEnumOrdersCaps);

    DC_END_FN();
    return CapsOK;
}


/****************************************************************************/
/* OEEnumOrdersCaps()                                                       */
/*                                                                          */
/* The callback routine which is called for each remote person, when        */
/* building up the common order support record.                             */
/****************************************************************************/
void RDPCALL SHCLASS OEEnumOrdersCaps(
        LOCALPERSONID localID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    unsigned iOrder;
    BOOL *pCapsOK = (BOOL *)UserData;
    PTS_ORDER_CAPABILITYSET pOrdersCaps = (PTS_ORDER_CAPABILITYSET)
            pCapabilities;

    DC_BEGIN_FN("OEEnumOrdersCaps");

    // Check the orders in the orders capabilities. Note that
    // oeOrderSupported has already been initialized with what we support
    // locally, so we simply turn off what is not supported by this
    // remote node.
    for (iOrder = 0; iOrder < TS_MAX_ORDERS; iOrder++) {
        if (!pOrdersCaps->orderSupport[iOrder]) {
            /****************************************************************/
            /* The order is not supported at the level we want to send out  */
            /* (currently ORD_LEVEL_1_ORDERS) so set the combined caps to   */
            /* say not supported.                                           */
            /****************************************************************/
            oeOrderSupported[iOrder] = FALSE;
        }
    }

    /************************************************************************/
    /* Check Order encoding support                                         */
    /************************************************************************/
    TRC_NRM((TB, "Orders capabilities [%hd]: %hx", localID,
             pOrdersCaps->orderFlags));

    // OE2 negotiability should always be set by our client.
    if (!(pOrdersCaps->orderFlags & TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT)) {
        TRC_ERR((TB,"Client does not have OE2 negotiability flag set"));
        *pCapsOK = FALSE;
    }

    // We do not support non-OE2 clients.
    if (pOrdersCaps->orderFlags & TS_ORDERFLAGS_CANNOTRECEIVEORDERS) {
        TRC_ERR((TB,"Client does not support OE2"));
        *pCapsOK = FALSE;
    }

    // Use of TS_ZERO_BOUNDS_DELTAS flag must be supported, it has been
    // present for all clients from RDP 4.0 onward.
    if (!(pOrdersCaps->orderFlags & TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT)) {
        TRC_ERR((TB, "Client does not support TS_ZERO_BOUNDS_DELTAS"));
        *pCapsOK = FALSE;
    }

    if (pOrdersCaps->orderFlags & TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY) {
        oeSendSolidPatternBrushOnly = TRUE;
        TRC_ALT((TB, "Only Solid and Pattern brushes supported"));
    }

    if (!(pOrdersCaps->orderFlags & TS_ORDERFLAGS_COLORINDEXSUPPORT)) {
        TRC_ALT((TB, "Disable Color Index Support"));
        oeColorIndexSupported = FALSE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aoaapi.cpp ===
/****************************************************************************/
/* aoaapi.c                                                                 */
/*                                                                          */
/* RDP Order Accumulation API functions                                     */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "aoaapi"
#define TRC_GROUP TRC_GROUP_DCSHARE
#include <as_conf.hpp>

#include <aoacom.c>


/****************************************************************************/
/* OA_Init                                                                  */
/****************************************************************************/
void RDPCALL SHCLASS OA_Init(void)
{
    DC_BEGIN_FN("OA_Init");

#define DC_INIT_DATA
#include <aoadata.c>
#undef DC_INIT_DATA

    DC_END_FN();
}


/****************************************************************************/
/* OA_UpdateShm                                                             */
/*                                                                          */
/* Updates the OA shared memory                                             */
/****************************************************************************/
void RDPCALL SHCLASS OA_UpdateShm(void)
{
    DC_BEGIN_FN("OA_UpdateShm");

    if (oaSyncRequired) {
        OA_ResetOrderList();
        oaSyncRequired = FALSE;
    }

    DC_END_FN();
}


/****************************************************************************/
/* OA_SyncUpdatesNow                                                        */
/*                                                                          */
/* Called when a sync operation is required.                                */
/*                                                                          */
/* Discards all outstanding orders.                                         */
/****************************************************************************/
void RDPCALL SHCLASS OA_SyncUpdatesNow(void)
{
    DC_BEGIN_FN("OA_SyncUpdatesNow");

    oaSyncRequired = TRUE;
    DCS_TriggerUpdateShmCallback();

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\apmdata.c ===
/****************************************************************************/
/* apmdata.c                                                                */
/*                                                                          */
/* RDP Palette Manager Data                                                 */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, pmMustSendPalette, FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aoedata.c ===
/****************************************************************************/
/* aoedata.c                                                                */
/*                                                                          */
/* Order encoding data (generic)                                            */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
/* Are Hatched Brushes supported?                                           */
/****************************************************************************/
DC_DATA(BOOLEAN, oeSendSolidPatternBrushOnly, FALSE);

/****************************************************************************/
/* Flag that indicates support for color indices rather than RGBs           */
/****************************************************************************/
DC_DATA(BOOLEAN, oeColorIndexSupported,       FALSE);

/****************************************************************************/
// Array of supported orders after caps negotiation
/****************************************************************************/
DC_DATA_ARRAY_UNINIT(BYTE, oeOrderSupported, TS_MAX_ORDERS);

/****************************************************************************/
// The orders we support sending/receiving. These will be combined with the
// capabilities of all nodes in session to determine which orders can be sent.
/****************************************************************************/
#ifdef DRAW_NINEGRID
DC_CONST_DATA_ARRAY(BYTE, oeLocalOrdersSupported, TS_MAX_ORDERS,
    DC_STRUCT32(
      1,  // TS_NEG_DSTBLT_INDEX
      1,  // TS_NEG_PATBLT_INDEX
      1,  // TS_NEG_SCRBLT_INDEX
      1,  // TS_NEG_MEMBLT_INDEX
      1,  // TS_NEG_MEM3BLT_INDEX
      0,  // TS_NEG_ATEXTOUT_INDEX
      0,  // TS_NEG_AEXTTEXTOUT_INDEX
      1,  // TS_NEG_DRAWNINEGRID_INDEX
      1,  // TS_NEG_LINETO_INDEX
      1,  // TS_NEG_MULTI_DRAWNINEGRID_INDEX
      1,  // TS_NEG_OPAQUERECT_INDEX
      1,  // TS_NEG_SAVEBITMAP_INDEX
      0,  // TS_NEG_WTEXTOUT_INDEX
      0,  // TS_NEG_MEMBLT_R2_INDEX  *** Zero: negotiation is thru NEG_MEMBLT
      0,  // TS_NEG_MEM3BLT_R2_INDEX  *** Zero: neg. thru NEG_MEM3BLT
      1,  // TS_NEG_MULTIDSTBLT_INDEX
      1,  // TS_NEG_MULTIPATBLT_INDEX
      1,  // TS_NEG_MULTISCRBLT_INDEX
      1,  // TS_NEG_MULTIOPAQUERECT_INDEX
      1,  // TS_NEG_FAST_INDEX_INDEX
      1,  // TS_NEG_POLYGON_SC_INDEX
      1,  // TS_NEG_POLYGON_CB_INDEX
      1,  // TS_NEG_POLYLINE_INDEX
      0,  // 0x17 unused
      1,  // TS_NEG_FAST_GLYPH_INDEX
      1,  // TS_NEG_ELLIPSE_SC_INDEX
      1,  // TS_NEG_ELLIPSE_CB_INDEX
      1,  // TS_NEG_INDEX_INDEX
      0,  // TS_NEG_WEXTTEXTOUT_INDEX
      0,  // TS_NEG_WLONGTEXTOUT_INDEX
      0,  // TS_NEG_WLONGEXTTEXTOUT_INDEX
      0   // 0x1F unused
    ));
#else
DC_CONST_DATA_ARRAY(BYTE, oeLocalOrdersSupported, TS_MAX_ORDERS,
    DC_STRUCT32(
      1,  // TS_NEG_DSTBLT_INDEX
      1,  // TS_NEG_PATBLT_INDEX
      1,  // TS_NEG_SCRBLT_INDEX
      1,  // TS_NEG_MEMBLT_INDEX
      1,  // TS_NEG_MEM3BLT_INDEX
      0,  // TS_NEG_ATEXTOUT_INDEX
      0,  // TS_NEG_AEXTTEXTOUT_INDEX
      0,  // TS_NEG_RECTANGLE_INDEX
      1,  // TS_NEG_LINETO_INDEX
      0,  // TS_NEG_FASTFRAME_INDEX
      1,  // TS_NEG_OPAQUERECT_INDEX
      1,  // TS_NEG_SAVEBITMAP_INDEX
      0,  // TS_NEG_WTEXTOUT_INDEX
      0,  // TS_NEG_MEMBLT_R2_INDEX  *** Zero: negotiation is thru NEG_MEMBLT
      0,  // TS_NEG_MEM3BLT_R2_INDEX  *** Zero: neg. thru NEG_MEM3BLT
      1,  // TS_NEG_MULTIDSTBLT_INDEX
      1,  // TS_NEG_MULTIPATBLT_INDEX
      1,  // TS_NEG_MULTISCRBLT_INDEX
      1,  // TS_NEG_MULTIOPAQUERECT_INDEX
      1,  // TS_NEG_FAST_INDEX_INDEX
      1,  // TS_NEG_POLYGON_SC_INDEX
      1,  // TS_NEG_POLYGON_CB_INDEX
      1,  // TS_NEG_POLYLINE_INDEX
      0,  // 0x17 unused
      1,  // TS_NEG_FAST_GLYPH_INDEX
      1,  // TS_NEG_ELLIPSE_SC_INDEX
      1,  // TS_NEG_ELLIPSE_CB_INDEX
      1,  // TS_NEG_INDEX_INDEX
      0,  // TS_NEG_WEXTTEXTOUT_INDEX
      0,  // TS_NEG_WLONGTEXTOUT_INDEX
      0,  // TS_NEG_WLONGEXTTEXTOUT_INDEX
      0   // 0x1F unused
    ));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asbcapi.cpp ===
/****************************************************************************/
// asbcapi.cpp
//
// Send Bitmap Cache API functions.
//
// Copyright(c) Microsoft, PictureTel 1992-1997
// (C) 1997-2000 Microsoft Corp.
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "asbcapi"
#include <as_conf.hpp>

/****************************************************************************/
// SBC_Init(): Initializes the SBC.
//
// Returns: FALSE on failure to initialize.
/****************************************************************************/
void RDPCALL SHCLASS SBC_Init(void)
{
    long cachingDisabled;
    TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT HostCaps;

    DC_BEGIN_FN("SBC_Init");

    // This initializes all the global data for this component.
#define DC_INIT_DATA
#include <asbcdata.c>
#undef DC_INIT_DATA

    COM_ReadProfInt32(m_pTSWd,
                      SBC_INI_CACHING_DISABLED,
                      SBC_DEFAULT_CACHING_DISABLED,
                      &cachingDisabled);
    sbcBitmapCachingEnabled = !(cachingDisabled & SBC_DISABLE_BITMAP_CACHE);
    sbcBrushCachingEnabled = !(cachingDisabled & SBC_DISABLE_BRUSH_CACHE);
    sbcGlyphCachingEnabled = !(cachingDisabled & SBC_DISABLE_GLYPH_CACHE);
    sbcOffscreenCachingEnabled = !(cachingDisabled & SBC_DISABLE_OFFSCREEN_CACHE);
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    sbcDrawNineGridCachingEnabled = !(cachingDisabled & SBC_DISABLE_DRAWNINEGRID_CACHE);
    sbcDrawGdiplusEnabled = !(cachingDisabled & SBC_DISABLE_DRAWGDIPLUS_CACHE);

    TRC_NRM((TB, "Caches enabled: Bitmap=%u, Brush=%u, Glyph=%u, Offscreen=%u, DNG=%u, GDIP=%u",
            sbcBitmapCachingEnabled,
            sbcBrushCachingEnabled,
            sbcGlyphCachingEnabled,
            sbcOffscreenCachingEnabled,
            sbcDrawNineGridCachingEnabled,
            sbcDrawGdiplusEnabled));
#else
    sbcDrawGdiplusEnabled = !(cachingDisabled & SBC_DISABLE_DRAWGDIPLUS_CACHE);
    TRC_NRM((TB, "Caches enabled: Bitmap=%u, Brush=%u, Glyph=%u, Offscreen=%u",
            sbcBitmapCachingEnabled,
            sbcBrushCachingEnabled,
            sbcGlyphCachingEnabled,
            sbcOffscreenCachingEnabled));
#endif // DRAW_NINEGRID
#else  // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    sbcDrawNineGridCachingEnabled = !(cachingDisabled & SBC_DISABLE_DRAWNINEGRID_CACHE);

    TRC_NRM((TB, "Caches enabled: Bitmap=%u, Brush=%u, Glyph=%u, Offscreen=%u, DNG=%u",
            sbcBitmapCachingEnabled,
            sbcBrushCachingEnabled,
            sbcGlyphCachingEnabled,
            sbcOffscreenCachingEnabled,
            sbcDrawNineGridCachingEnabled));
#else
    TRC_NRM((TB, "Caches enabled: Bitmap=%u, Brush=%u, Glyph=%u, Offscreen=%u",
            sbcBitmapCachingEnabled,
            sbcBrushCachingEnabled,
            sbcGlyphCachingEnabled,
            sbcOffscreenCachingEnabled));
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS

    // The server supports rev2 bitmap caching. Indicate this support with a
    // client-to-server capability so the client can respond in kind.
    HostCaps.capabilitySetType = TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT;
    HostCaps.lengthCapability = sizeof(HostCaps);
    HostCaps.CacheVersion = TS_BITMAPCACHE_REV2;
    HostCaps.Pad1 = 0;
    HostCaps.Pad2 = 0;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&HostCaps,
            sizeof(TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT));

    TRC_NRM((TB, "SBC initialized OK"));

    DC_END_FN();
}


/****************************************************************************/
// SBC_Term(): Terminates the SBC.
/****************************************************************************/
void RDPCALL SHCLASS SBC_Term(void)
{
    DC_BEGIN_FN("SBC_Term");

    SBC_FreeBitmapKeyDatabase();

    DC_END_FN();
}


/****************************************************************************/
// SBC_SyncUpdatesNow: Called to force a sync, which clears all caches.
/****************************************************************************/
void RDPCALL SHCLASS SBC_SyncUpdatesNow(void)
{
    DC_BEGIN_FN("SBC_SyncUpdatesNow");
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled ||
            sbcBrushCachingEnabled || sbcOffscreenCachingEnabled ||
            sbcDrawNineGridCachingEnabled || sbcDrawGdiplusEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled ||
            sbcBrushCachingEnabled || sbcOffscreenCachingEnabled ||
            sbcDrawGdiplusEnabled) {
#endif // DRAW_NINEGRID
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled ||
            sbcBrushCachingEnabled || sbcOffscreenCachingEnabled ||
            sbcDrawNineGridCachingEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled ||
            sbcBrushCachingEnabled || sbcOffscreenCachingEnabled) {
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS

        sbcSyncRequired = TRUE;
        DCS_TriggerUpdateShmCallback();
    }

    DC_END_FN();
}


/****************************************************************************/
// SBC_DumpBitmapKeyDatabase
//
// Allocates a key database and fills it in with the current contents of
// the bitmap caches.
/****************************************************************************/
void RDPCALL SHCLASS SBC_DumpBitmapKeyDatabase(BOOLEAN bSaveDatabase)
{
    unsigned i, j;
    unsigned TotalEntries, CurEntry;
    CHNODE *pNode;

    DC_BEGIN_FN("SBC_DumpBitmapKeyDatabase");

    // If we have a previous database, possibly from the original client
    // persistent key upload, destroy it.
    SBC_FreeBitmapKeyDatabase();

    // Count up the total number of entries we will need if preserving the key
    // database.  For shadows, this information is always discarded.
    TotalEntries = 0;
    if (bSaveDatabase) {
        for (i = 0; i < m_pShm->sbc.NumBitmapCaches; i++)
            if (m_pShm->sbc.bitmapCacheInfo[i].cacheHandle != NULL)
                TotalEntries += CH_GetNumEntries(m_pShm->sbc.bitmapCacheInfo[i].
                        cacheHandle);
    }
    
    if (TotalEntries > 0) {
        // Allocate the database.
        sbcKeyDatabaseSize = sizeof(SBC_BITMAP_CACHE_KEY_INFO) + (TotalEntries - 1) *
                sizeof(SBC_MRU_KEY);
        sbcKeyDatabase = (SBC_BITMAP_CACHE_KEY_INFO *)COM_Malloc(sbcKeyDatabaseSize);
        if (sbcKeyDatabase != NULL) {
            sbcKeyDatabase->TotalKeys = TotalEntries;

            // Fill in the database from each cache.
            CurEntry = 0;
            for (i = 0; i < m_pShm->sbc.NumBitmapCaches; i++) {
                sbcKeyDatabase->NumKeys[i] = CH_GetNumEntries(m_pShm->sbc.
                        bitmapCacheInfo[i].cacheHandle);
                sbcKeyDatabase->KeyStart[i] = CurEntry;

                SBC_DumpMRUList(m_pShm->sbc.bitmapCacheInfo[i].cacheHandle,
                        &(sbcKeyDatabase->Keys[sbcKeyDatabase->KeyStart[i]]));
                CurEntry += sbcKeyDatabase->NumKeys[i];
            }

            // Fill in remainder of pointers and info with zeros to indicate
            // nothing there.
            for (; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++) {
                sbcKeyDatabase->NumKeys[i] = 0;
                sbcKeyDatabase->KeyStart[i] = 0;
            }
        }
        else {
            // Not allocating the database is an error, but not fatal, since
            // it just means that the caches will be cleared instead of being
            // initialized.
            TRC_ERR((TB,"Failed to allocate key database"));
            sbcKeyDatabaseSize = 0;
        }
    }
    
    DC_END_FN();
}


/****************************************************************************/
// SBC_DumpMRUList
//
// Walks a cache MRU list and dumps the keys and indices to an
// SBC_MRU_KEY array.
/****************************************************************************/
void RDPCALL SHCLASS SBC_DumpMRUList(CHCACHEHANDLE hCache, void *pList)
{
    CHNODE *pNode;
    unsigned CurEntry;
    PLIST_ENTRY pCurrentListEntry;
    SBC_MRU_KEY *pKeys = (SBC_MRU_KEY *)pList;
    PCHCACHEDATA pCacheData;

    DC_BEGIN_FN("SBC_DumpMRUList");

    pCacheData = (CHCACHEDATA *)hCache;

    CurEntry = 0;
    pCurrentListEntry = pCacheData->MRUList.Flink;
    while (pCurrentListEntry != &pCacheData->MRUList) {
        pNode = CONTAINING_RECORD(pCurrentListEntry, CHNODE, MRUList);
        pKeys[CurEntry].Key1 = pNode->Key1;
        pKeys[CurEntry].Key2 = pNode->Key2;
        pKeys[CurEntry].CacheIndex = (unsigned)(pNode - pCacheData->NodeArray);
        CurEntry++;

        pCurrentListEntry = pCurrentListEntry->Flink;
    }

    TRC_ASSERT((CurEntry == pCacheData->NumEntries),
            (TB,"NumEntries (%u) != # entries in MRU list (%u)",
            pCacheData->NumEntries, CurEntry));

    DC_END_FN();
}


/****************************************************************************/
// SBC_PartyJoiningShare: Called when a new party is joining the share.
//
// Params:
//     locPersonID - local person ID of remote person joining the share.
//     oldShareSize - the number of the parties which were in the share (ie
//         excludes the joining party).
//
// Returns: TRUE if the party can join the share, FALSE otherwise.
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBC_PartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      oldShareSize)
{
    DC_BEGIN_FN("SBC_PartyJoiningShare");

    DC_IGNORE_PARAMETER(oldShareSize);

    TRC_NRM((TB, "[%x] joining share", locPersonID));
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawNineGridCachingEnabled || sbcDrawGdiplusEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawGdiplusEnabled) {
#endif // DRAW_NINEGRID
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawNineGridCachingEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled) {
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS
        // Local server does not require new action.
        if (locPersonID != SC_LOCAL_PERSON_ID) {
            sbcCachingOn = TRUE;
            sbcNewCapsData = TRUE;

            // Redetermine the size of the bitmap cache.
            if (sbcBitmapCachingEnabled)
                SBCRedetermineBitmapCacheSize();

            // Redetermine the size of the glyph cache.
            if (sbcGlyphCachingEnabled)
                SBCRedetermineGlyphCacheSize();
    
            // Redetermine the brush support level
            if (sbcBrushCachingEnabled)
                SBCRedetermineBrushSupport();
            
            // Redetermine the offscreen support level
            if (sbcOffscreenCachingEnabled) {
                SBCRedetermineOffscreenSupport();
            }

#ifdef DRAW_NINEGRID
            // Redetermine the drawninegrid support level
            if (sbcDrawNineGridCachingEnabled) {
                SBCRedetermineDrawNineGridSupport();
            }
#endif
#ifdef DRAW_GDIPLUS
            if (sbcDrawGdiplusEnabled) {
                SBCRedetermineDrawGdiplusSupport();
            }
#endif
            // Force a callback on the WinStation context so we can update
            // the shared memory.
            DCS_TriggerUpdateShmCallback();
        }
    }

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
// SBC_PartyLeftShare(): Called when a party has left the share.
//
// Params:
//     locPersonID - local person ID of remote person leaving the share.
//     newShareSize - the number of the parties now in the call (ie excludes
//         the leaving party).
/****************************************************************************/
void RDPCALL SHCLASS SBC_PartyLeftShare(
        LOCALPERSONID locPersonID,
        unsigned        newShareSize)
{
    DC_BEGIN_FN("SBC_PartyLeftShare");

    DC_IGNORE_PARAMETER(newShareSize);

    TRC_NRM((TB, "[%x] left share", locPersonID));

    // Must have active caches
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawNineGridCachingEnabled || sbcDrawGdiplusEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawGdiplusEnabled) {
#endif // DRAW_NINEGRID
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled || sbcDrawNineGridCachingEnabled) {
#else
    if (sbcBitmapCachingEnabled || sbcGlyphCachingEnabled || sbcBrushCachingEnabled ||
            sbcOffscreenCachingEnabled) {
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS
        // If all people left the share then disable caching.
        if (locPersonID == SC_LOCAL_PERSON_ID) {
            TRC_NRM((TB, "Disable caching"));

            sbcCachingOn = FALSE;
            sbcNewCapsData = TRUE;

            // Force a callback on the WinStation context so we can update the
            // shared memory.
            DCS_TriggerUpdateShmCallback();
        }

        // Else, look thru the capabilities again to see what's possible
        else {
            sbcCachingOn = TRUE;
            sbcNewCapsData = TRUE;

            // Redetermine the size of the bitmap cache.
            if (sbcBitmapCachingEnabled)
                SBCRedetermineBitmapCacheSize();

            // Redetermine the size of the glyph cache.
            if (sbcGlyphCachingEnabled)
                SBCRedetermineGlyphCacheSize();
    
            // Redetermine the brush support level
            if (sbcBrushCachingEnabled)
                SBCRedetermineBrushSupport();
            
            // Redetermine the offscreen support level
            if (sbcOffscreenCachingEnabled) {
                SBCRedetermineOffscreenSupport();
            }

#ifdef DRAW_NINEGRID
            // Redetermine the drawninegrid support level
            if (sbcDrawNineGridCachingEnabled) {
                SBCRedetermineDrawNineGridSupport();
            }
#endif
#ifdef DRAW_GDIPLUS
            if (sbcDrawGdiplusEnabled) {
                SBCRedetermineDrawGdiplusSupport();
            }
#endif
            // TODO: Is this really necessary?
            DCS_TriggerUpdateShmCallback();
        }

    }

    DC_END_FN();
}


/****************************************************************************/
// SBC_HandlePersistentCacheList(): Handles list of persistent cache keys
// from the client.
/****************************************************************************/
void RDPCALL SHCLASS SBC_HandlePersistentCacheList(
        TS_BITMAPCACHE_PERSISTENT_LIST *pPDU,
        unsigned                       DataLength,
        LOCALPERSONID                  LocalID)
{
    unsigned i, j, CurEntry;
    INT TotalEntries;
    
    DC_BEGIN_FN("SBC_HandlePersistentCacheList");

    // Check the packet length against its internal representation, make sure
    // it is as long as it needs to be. If not, we either received a buggy
    // packet or we're being attacked.
    if (DataLength >= (sizeof(TS_BITMAPCACHE_PERSISTENT_LIST) -
            sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY))) {
        if (pPDU->bFirstPDU) {
            // Check that we have not already received persistent key info.
            // If we have and we get a new PDU, it is a protocol error.
            if (sbcPersistentKeysReceived) {
                TRC_ERR((TB,"Persistent key packet received marked FIRST "
                        "illegally"));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                        Log_RDP_PersistentKeyPDUIllegalFIRST,
                        (PBYTE)pPDU, DataLength);
                goto ExitFunc;
            }

            // Get the total number of entries from the PDU array. Check
            // against the negotiated caps and make sure the client is not
            // trying to send too many.
            TotalEntries = 0;
            for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++) {
                TotalEntries += pPDU->TotalEntries[i];

                if (pPDU->TotalEntries[i] > sbcCurrentBitmapCaps.
                        CellCacheInfo[i].NumEntries) {
                    TRC_ERR((TB,"Persistent key packet received specified "
                            "more keys (%u) than there are cache entries (%u) "
                            "for cache %u", pPDU->TotalEntries[i],
                            sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries,
                            i));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                            Log_RDP_PersistentKeyPDUTooManyCacheKeys,
                            (PBYTE)pPDU, DataLength);
                    goto ExitFunc;
                }
            }

            // Check if we receive 0 keys, in this case, we will just exit the
            // function quietly
            if (TotalEntries == 0) {
                TRC_ERR((TB, "0 persistent key"));
                goto ExitFunc;
            }

            // Check this against the max allowed by the protocol.
            if (TotalEntries > TS_BITMAPCACHE_MAX_TOTAL_PERSISTENT_KEYS) {
                TRC_ERR((TB,"Client specified %u total keys, beyond %u "
                        "protocol limit", TotalEntries,
                        TS_BITMAPCACHE_MAX_TOTAL_PERSISTENT_KEYS));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                        Log_RDP_PersistentKeyPDUTooManyTotalKeys,
                        (PBYTE)pPDU, DataLength);
                goto ExitFunc;
            }

            sbcKeyDatabaseSize = sizeof(SBC_BITMAP_CACHE_KEY_INFO) + (TotalEntries - 1) *
                    sizeof(SBC_MRU_KEY);

            sbcKeyDatabase = (SBC_BITMAP_CACHE_KEY_INFO *)COM_Malloc(sbcKeyDatabaseSize);
                    
            if (sbcKeyDatabase == NULL) {
                sbcKeyDatabaseSize = 0;
                TRC_ERR((TB,"Could not alloc persistent key info"));
                goto ExitFunc;
            }

            // Set up general data and entry pointers within the key array.
            CurEntry = 0;
            for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++) {
                sbcKeyDatabase->KeyStart[i] = CurEntry;
                CurEntry += pPDU->TotalEntries[i];
                sbcKeyDatabase->NumKeys[i] = 0;
                sbcNumKeysExpected[i] = pPDU->TotalEntries[i];
            }
            sbcTotalKeysExpected = TotalEntries;
            sbcKeyDatabase->TotalKeys = 0;

            // Mark that we have received the first-keys packet.
            sbcPersistentKeysReceived = TRUE;
        }

        // If this is not the first PDU but we failed a previous allocation,
        // too bad, no persistent keys. This could also happen if the client
        // continues sending persistent cache keys after sending the 
        // TS_BITMAPCACHE_LAST_OVERALL flag that indicates the end of the key
        // packet stream.
        if (sbcKeyDatabase == NULL)
            goto ExitFunc;

        // Total the supposed number of keys received in the PDU. Check against
        // the PDU size.
        TotalEntries = 0;
        for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++)
            TotalEntries += pPDU->NumEntries[i];
        if (DataLength < (sizeof(TS_BITMAPCACHE_PERSISTENT_LIST) +
                (TotalEntries - 1) *
                sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY))) {
            TRC_ERR((TB,"Client specified %u keys in this PersistentListPDU, "
                    "PDU data not long enough", TotalEntries));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                    Log_RDP_PersistentKeyPDUBadLength,
                    (PBYTE)pPDU, DataLength);
            goto ExitFunc;
        }
            
        // Loop across the caches to check each one.
        CurEntry = 0;
        for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++) {
            // Make sure that we don't receive more keys than were specified in
            // the original PDU.
            if ((sbcKeyDatabase->NumKeys[i] + pPDU->NumEntries[i]) <=
                    sbcNumKeysExpected[i]) {
                // Transfer keys into the key list. We set these up for the MRU
                // list in the same order received since the client does not
                // have any MRU priority info to give us.
                for (j = 0; j < pPDU->NumEntries[i]; j++) {
                    (&(sbcKeyDatabase->Keys[sbcKeyDatabase->KeyStart[i]]))
                            [sbcKeyDatabase->NumKeys[i] + j].Key1 = 
                            pPDU->Entries[CurEntry].Key1;
                    (&(sbcKeyDatabase->Keys[sbcKeyDatabase->KeyStart[i]]))
                            [sbcKeyDatabase->NumKeys[i] + j].Key2 = 
                            pPDU->Entries[CurEntry].Key2;
                    (&(sbcKeyDatabase->Keys[sbcKeyDatabase->KeyStart[i]]))
                            [sbcKeyDatabase->NumKeys[i] + j].CacheIndex = 
                            sbcKeyDatabase->NumKeys[i] + j;

                    CurEntry++;
                }
                sbcKeyDatabase->NumKeys[i] += pPDU->NumEntries[i];
                sbcKeyDatabase->TotalKeys += pPDU->NumEntries[i];
            }
            else {
                TRC_ERR((TB,"Received too many keys in cache %u", i));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                        Log_RDP_PersistentKeyPDUTooManyCacheKeys,
                        (PBYTE)pPDU, DataLength);
                goto ExitFunc;
            }
        }

        if (pPDU->bLastPDU) {
            // This is an assertion but not fatal -- we simply use what we
            // received.
            TRC_ASSERT((sbcKeyDatabase->TotalKeys == sbcTotalKeysExpected),
                    (TB,"Num expected persistent keys does not match sent keys "
                    "(rec'd=%d, expect=%d)", sbcKeyDatabase->TotalKeys,
                    sbcTotalKeysExpected));
        }
    }
    else {
        TRC_ERR((TB,"Persistent key PDU received but data is not long enough "
                "for header, LocalID=%u", LocalID));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_PersistentKeyPDUBadLength,
                (PBYTE)pPDU, DataLength);
    }

ExitFunc:

    DC_END_FN();
}

/****************************************************************************/
// Returns the persistent key database to the DD and free the local copy
/****************************************************************************/
void RDPCALL SHCLASS SBC_GetBitmapKeyDatabase(unsigned* keyDBSize, 
                                              BYTE* pKeyDB)
{
    unsigned i, CurEntry;
    SBC_BITMAP_CACHE_KEY_INFO* pKeyDatabase;

    DC_BEGIN_FN("SBC_GetBitmapKeyDatabase");

    // No persistent key database setup
    if ( sbcKeyDatabaseSize == 0 || sbcKeyDatabase == NULL) {
        TRC_NRM((TB, "Failed to get the key database: dd keysize=%d, wd keysize=%d, keydatabase=%p",
                 *keyDBSize, sbcKeyDatabaseSize, sbcKeyDatabase));
        *keyDBSize = 0;
        DC_QUIT;
    }
    
    // DD's buffer is too small
    if (*keyDBSize < sbcKeyDatabaseSize) {
        TRC_NRM((TB, "Failed to get the key database: dd keysize=%d, wd keysize=%d, keydatabase=%p",
                 *keyDBSize, sbcKeyDatabaseSize, sbcKeyDatabase));
        *keyDBSize = sbcKeyDatabaseSize;
        DC_QUIT;
    }

    TRC_NRM((TB, "get bitmapKeyDatabase: copy keys from wd to dd"));

    pKeyDatabase = (SBC_BITMAP_CACHE_KEY_INFO*)(pKeyDB);
    memcpy(pKeyDatabase, sbcKeyDatabase, sbcKeyDatabaseSize);
    *keyDBSize = sbcKeyDatabaseSize;

    SBC_FreeBitmapKeyDatabase();
    
DC_EXIT_POINT:
    return;
    
}

/****************************************************************************/
// Free the key databaes
/****************************************************************************/
void RDPCALL SHCLASS SBC_FreeBitmapKeyDatabase()
{
    if (sbcKeyDatabase != NULL) {
        COM_Free(sbcKeyDatabase);
        sbcKeyDatabase = NULL;
    }
    sbcKeyDatabaseSize = 0;
}

/****************************************************************************/
// SBC_HandleBitmapCacheErrorPDU: Handles a bitmap cache error PDU.
// Right now this function just checks the length of the PDU to make
// sure it is valid.  If not, the server close the client connection
// This function is for future support of error PDU implementation
/****************************************************************************/
void RDPCALL SHCLASS SBC_HandleBitmapCacheErrorPDU(
        TS_BITMAPCACHE_ERROR_PDU *pPDU,
        unsigned                 DataLength,
        LOCALPERSONID            LocalID)
{
    unsigned i;

    DC_BEGIN_FN("SBC_HandleBitmapCacheErrorPDU");

    if (DataLength >= (sizeof(TS_BITMAPCACHE_ERROR_PDU) - 
            sizeof(TS_BITMAPCACHE_ERROR_INFO))) {
        if ((sizeof(TS_BITMAPCACHE_ERROR_PDU) - sizeof(TS_BITMAPCACHE_ERROR_INFO)
                + pPDU->NumInfoBlocks * sizeof(TS_BITMAPCACHE_ERROR_INFO))
                == DataLength) {
            TRC_NRM((TB, "Received a bitmap cache error PDU"));

            // update the total number of error pdus received
            sbcTotalNumErrorPDUs++;

            // For the duration of a session, we will only handle maximum
            // MAX_NUM_ERROR_PDU_SEND numbers of error PDUs received.  
            // This is to avoid bad clients attack the server with error pdu
            if (sbcTotalNumErrorPDUs <= MAX_NUM_ERROR_PDU_SEND) {
                for (i = 0; i < pPDU->NumInfoBlocks; i++) {
                    if (pPDU->Info[i].CacheID < sbcCurrentBitmapCaps.NumCellCaches) {
                        // For now, the server only handles the client clear cache 
                        // request.  Server will clear the cache and then issue a screen 
                        // redraw.  The server doesn't handle if the client requests to 
                        // resize the cache.  
                        sbcClearCache[pPDU->Info[i].CacheID] = pPDU->Info[i].bFlushCache;
                     }
                }
                
                TRC_DBG((TB, "Issued clear cache to RDPDD"));

                // trigger a timer so that when DD gets it, it will clear the cache.
                DCS_TriggerUpdateShmCallback();
            }
            else {
                TRC_DBG((TB, "Received more than %d bitmap error pdus.",
                        MAX_NUM_ERROR_PDU_SEND));
            }
        }
        else {
            TRC_ERR((TB,"Bitmap Cache Error PDU received but data Length is wrong, "
                "too many or too few info blocks, LocalID=%u", LocalID));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BitmapCacheErrorPDUBadLength,
                (PBYTE)pPDU, DataLength);
        }
    }
    else {
        TRC_ERR((TB,"Bitmap Cache Error PDU received but data is not long enough "
                "for header, LocalID=%u", LocalID));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BitmapCacheErrorPDUBadLength,
                (PBYTE)pPDU, DataLength);
    }

    DC_END_FN();
}

/****************************************************************************/
// SBC_HandleOffscrCacheErrorPDU: Handles an offscr cache error PDU.
// This function checks the length of the PDU to make
// sure it is valid.  If not, the server close the client connection
// When this PDU is received, WD will pass disable offscreen rendering to
// DD and DD will disable the offscreen rendering support and refresh
// the screen
/****************************************************************************/
void RDPCALL SHCLASS SBC_HandleOffscrCacheErrorPDU(
        TS_OFFSCRCACHE_ERROR_PDU *pPDU,
        unsigned                 DataLength,
        LOCALPERSONID            LocalID)
{
    DC_BEGIN_FN("SBC_HandleOffscrCacheErrorPDU");

    if (DataLength >= sizeof(TS_OFFSCRCACHE_ERROR_PDU)) {
        TRC_NRM((TB, "Received an offscreen cache error PDU"));

        if (pPDU->flags & TS_FLUSH_AND_DISABLE_OFFSCREEN) {
            TRC_DBG((TB, "Issued clear cache to RDPDD"));
            sbcDisableOffscreenCaching = TRUE;

            // trigger a timer so that when DD gets it, it will disable
            // offscreen rendering and refresh the screen
            DCS_TriggerUpdateShmCallback();
        }
        else {
            TRC_DBG((TB, "Unsupported flag, just ignore this PDU"));
        }
    }
    else {
        TRC_ERR((TB,"Offscr Cache Error PDU received but data is not long enough "
                "for header, LocalID=%u", LocalID));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BitmapCacheErrorPDUBadLength,
                (PBYTE)pPDU, DataLength);
    }

    DC_END_FN();
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// SBC_HandleDrawNineGridErrorPDU: Handles a drawninegrid cache error PDU.
// This function checks the length of the PDU to make
// sure it is valid.  If not, the server close the client connection
// When this PDU is received, WD will pass disable drawninegrid rendering to
// DD and DD will disable the drawninegrid rendering support and refresh
// the screen
/****************************************************************************/
void RDPCALL SHCLASS SBC_HandleDrawNineGridErrorPDU(
        TS_DRAWNINEGRID_ERROR_PDU *pPDU,
        unsigned                 DataLength,
        LOCALPERSONID            LocalID)
{
    DC_BEGIN_FN("SBC_HandleDrawNineGridErrorPDU");

    if (DataLength >= sizeof(TS_DRAWNINEGRID_ERROR_PDU)) {
        TRC_NRM((TB, "Received an drawninegrid cache error PDU"));

        if (pPDU->flags & TS_FLUSH_AND_DISABLE_DRAWNINEGRID) {
            TRC_DBG((TB, "Issued clear cache to RDPDD"));
            sbcDisableDrawNineGridCaching = TRUE;

            // trigger a timer so that when DD gets it, it will disable
            // drawninegrid rendering and refresh the screen
            DCS_TriggerUpdateShmCallback();
        }
        else {
            TRC_DBG((TB, "Unsupported flag, just ignore this PDU"));
        }
    }
    else {
        TRC_ERR((TB,"DrawNineGrid Cache Error PDU received but data is not long enough "
                "for header, LocalID=%u", LocalID));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BitmapCacheErrorPDUBadLength,
                (PBYTE)pPDU, DataLength);
    }

    DC_END_FN();
}
#endif

#ifdef DRAW_GDIPLUS
void RDPCALL SHCLASS SBC_HandleDrawGdiplusErrorPDU(
        TS_DRAWGDIPLUS_ERROR_PDU *pPDU,
        unsigned                 DataLength,
        LOCALPERSONID            LocalID)
{
    DC_BEGIN_FN("SBC_HandleDrawGdiplusErrorPDU");

    if (DataLength >= sizeof(TS_DRAWGDIPLUS_ERROR_PDU)) {
        TRC_ERR((TB, "Received a drawgdiplus error PDU"));

        if (pPDU->flags & TS_FLUSH_AND_DISABLE_DRAWGDIPLUS) {
            TRC_DBG((TB, "Issued clear cache to RDPDD"));

            sbcDisableDrawGdiplus = TRUE;

            // trigger a timer so that when DD gets it, it will disable
            // drawninegrid rendering and refresh the screen
            DCS_TriggerUpdateShmCallback();
        }
        else {
            TRC_DBG((TB, "Unsupported flag, just ignore this PDU"));
        }
    }
    else {
        TRC_ERR((TB,"DrawGdiplus Error PDU received but data is not long enough "
                "for header, LocalID=%u", LocalID));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BitmapCacheErrorPDUBadLength,
                (PBYTE)pPDU, DataLength);
    }

    DC_END_FN();
}
#endif // DRAW_GDIPLUS


/****************************************************************************/
// SBC_UpdateShm: Called on WinStation context to update the SBC shared
// memory.
/****************************************************************************/
void RDPCALL SHCLASS SBC_UpdateShm(void)
{
    unsigned i;

    DC_BEGIN_FN("SBC_UpdateShm");

    TRC_NRM((TB, "Update SBC shm"));

    // Cell bitmap caches.
    m_pShm->sbc.NumBitmapCaches = sbcCurrentBitmapCaps.NumCellCaches;
    m_pShm->sbc.fClearCache = FALSE;
    for (i = 0; i < sbcCurrentBitmapCaps.NumCellCaches; i++) {
        m_pShm->sbc.bitmapCacheInfo[i].Info =
                sbcCurrentBitmapCaps.CellCacheInfo[i];

        // set the clear cache flag for all caches
        if (sbcClearCache[i] == TRUE) {
            m_pShm->sbc.fClearCache = TRUE;
        }

        m_pShm->sbc.bitmapCacheInfo[i].fClearCache = sbcClearCache[i];
        sbcClearCache[i] = FALSE;
        
        TRC_NRM((TB, "bitmap cell cache(%u) NumEntries(%u) CellSize(%u)",
                i, m_pShm->sbc.bitmapCacheInfo[i].Info.NumEntries,
                SBC_CellSizeFromCacheID(i)));
    }

    // Cache bitmap order style.
    m_pShm->sbc.bUseRev2CacheBitmapOrder =
            ((sbcCurrentBitmapCaps.capabilitySetType >=
            TS_BITMAPCACHE_REV2) ? TRUE : FALSE);

    // Glyph and glyph fragment caching.
    for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
        m_pShm->sbc.caps.glyphCacheSize[i].cEntries = sbcGlyphCacheSizes[i].cEntries;
        m_pShm->sbc.caps.glyphCacheSize[i].cbCellSize = sbcGlyphCacheSizes[i].cbCellSize;

        TRC_NRM((TB, "glyph cache(%u) entries(%u) cellSize(%u)", i,
                m_pShm->sbc.caps.glyphCacheSize[i].cEntries,
                m_pShm->sbc.caps.glyphCacheSize[i].cbCellSize));
    }

    m_pShm->sbc.caps.fragCacheSize[0].cEntries = sbcFragCacheSizes[0].cEntries;
    m_pShm->sbc.caps.fragCacheSize[0].cbCellSize = sbcFragCacheSizes[0].cbCellSize;

    m_pShm->sbc.syncRequired = (m_pShm->sbc.syncRequired || sbcSyncRequired) ?
            TRUE : FALSE;
    sbcSyncRequired = FALSE;

    m_pShm->sbc.fCachingEnabled = (sbcCachingOn ? TRUE : FALSE);

    m_pShm->sbc.caps.GlyphSupportLevel = sbcGlyphSupportLevel;
    m_pShm->sbc.caps.brushSupportLevel = sbcBrushSupportLevel;

    m_pShm->sbc.newCapsData = (m_pShm->sbc.newCapsData || sbcNewCapsData) ?
            TRUE : FALSE;
    sbcNewCapsData = FALSE;

    // Offscreen cache
    m_pShm->sbc.offscreenCacheInfo.supportLevel = sbcOffscreenCacheInfo.supportLevel;
    m_pShm->sbc.offscreenCacheInfo.cacheSize = sbcOffscreenCacheInfo.cacheSize;
    m_pShm->sbc.offscreenCacheInfo.cacheEntries = sbcOffscreenCacheInfo.cacheEntries;
    m_pShm->sbc.fDisableOffscreen = sbcDisableOffscreenCaching;

#ifdef DRAW_NINEGRID
    // DrawNineGrid cache
    m_pShm->sbc.drawNineGridCacheInfo.supportLevel = sbcDrawNineGridCacheInfo.supportLevel;
    m_pShm->sbc.drawNineGridCacheInfo.cacheSize = sbcDrawNineGridCacheInfo.cacheSize;
    m_pShm->sbc.drawNineGridCacheInfo.cacheEntries = sbcDrawNineGridCacheInfo.cacheEntries;
    m_pShm->sbc.fDisableDrawNineGrid = sbcDisableDrawNineGridCaching;
#endif

#ifdef DRAW_GDIPLUS
    m_pShm->sbc.drawGdiplusInfo.supportLevel = sbcDrawGdiplusInfo.supportLevel;
    m_pShm->sbc.drawGdiplusInfo.GdipVersion = sbcDrawGdiplusInfo.GdipVersion;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheLevel = sbcDrawGdiplusInfo.GdipCacheLevel;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries = 
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries = 
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries = sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries = 
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries = 
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize = 
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize = 
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize = 
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize;
    m_pShm->sbc.drawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize = 
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize;
    m_pShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize = 
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize;
    m_pShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize = 
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize;
    m_pShm->sbc.drawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize = 
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize;

    m_pShm->sbc.fDisableDrawGdiplus = sbcDisableDrawGdiplus;
#endif // DRAW_GDIPLUS

    m_pShm->sbc.fAllowCacheWaitingList = sbcCurrentBitmapCaps.bAllowCacheWaitingList;

#ifdef DC_HICOLOR
    m_pShm->sbc.clientBitsPerPel = sbcClientBitsPerPel;
#endif

    TRC_NRM((TB, "syncRequired(%u) fCachingEnabled(%u) newCapsData(%u)",
                 m_pShm->sbc.syncRequired,
                 m_pShm->sbc.fCachingEnabled,
                 m_pShm->sbc.newCapsData));

    DC_END_FN();
}


/****************************************************************************/
// SBCRedetermineBitmapCacheSize: Enumerates all the people in the share and
// redetermines the overall capabilities.
//
// Returns: TRUE if caching should be enabled, FALSE otherwise.
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBCRedetermineBitmapCacheSize(void)
{
    BOOLEAN rc = TRUE;
    unsigned i;

    DC_BEGIN_FN("SBCRedetermineBitmapCacheSize");

#ifdef DC_HICOLOR
    // Need to update the bpp as this affects the size of the caches
    sbcClientBitsPerPel = m_desktopBpp;
#endif

    // Set the initial local max/min caps to defaults.
    sbcCurrentBitmapCaps = sbcDefaultBitmapCaps;

    // First attempt to enumerate rev2 capabilities, if present.
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_BITMAPCACHE_REV2, NULL,
            SBCEnumBitmapCacheCaps);

    // Then enumerate rev1 caps if present.
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_BITMAPCACHE, NULL,
            SBCEnumBitmapCacheCaps);

    // Trace the results and check to see if we negotiated any of the
    // cell caches to zero, in which case bitmap caching becomes disabled.
    TRC_NRM((TB,"New caps: bPersistentLists=%s, NumCellCaches=%u",
            (sbcCurrentBitmapCaps.bPersistentKeysExpected ? "TRUE" : "FALSE"),
            sbcCurrentBitmapCaps.NumCellCaches));

    if (sbcCurrentBitmapCaps.NumCellCaches > 0) {
        for (i = 0; i < sbcCurrentBitmapCaps.NumCellCaches; i++) {
            TRC_NRM((TB, "    Cell cache %u: Persistent=%s, NumEntries=%u",
                    i, sbcCurrentBitmapCaps.CellCacheInfo[i].bSendBitmapKeys ?
                    "TRUE" : "FALSE",
                    sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries));

            if (sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries == 0) {
                // Set the number of cell caches to zero as a signal for flag-
                // setting when the DD calls to get the new caps.
                sbcCurrentBitmapCaps.NumCellCaches = 0;

                // Return FALSE so that caching is disabled.
                TRC_ERR((TB, "Zero NumEntries on cache %u, caching disabled",
                        i));
                rc = FALSE;
                break;
            }
        }
    }
    else {
        // Return FALSE to disable caching.
        TRC_ERR((TB,"Zero caches, disabling caching"));
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCEnumBitmapCaps: Callback function passed to CPC_EnumerateCapabilities.
// It will be called with a capability structure for each person in the share
// corresponding to the TS_CAPSETTYPE_BITMAPCACHE and _REV2 capability
// structures.
//
// Params:
//     personID - ID of person with these capabilities.
//     pProtCaps - pointer to capabilities structure for this person. This
//          pointer is only valid within the call to this function.
/****************************************************************************/
void RDPCALL SHCLASS SBCEnumBitmapCacheCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapHdr)
{
    unsigned i;
#ifdef DC_HICOLOR
    unsigned shadowerBpp;
    unsigned scaleNum   = 1;
    unsigned scaleDenom = 1;
#endif


    DC_BEGIN_FN("SBCEnumBitmapCacheCaps");

    DC_IGNORE_PARAMETER(UserData);

    if (pCapHdr->capabilitySetType == TS_CAPSETTYPE_BITMAPCACHE_REV2) {
        TS_BITMAPCACHE_CAPABILITYSET_REV2 *pCaps;

        // We can receive a zero size for the capability if we didn't receive
        // any rev2 caps from any client.
        if (pCapHdr->lengthCapability >=
                sizeof(TS_BITMAPCACHE_CAPABILITYSET_REV2)) {
            pCaps = (PTS_BITMAPCACHE_CAPABILITYSET_REV2)pCapHdr;

            // Cache version defaults to rev2, we don't need to change
            // sbcCurrentBitmapCaps.capabilitySetType.

            TRC_NRM((TB,"[%ld]: Rec'd REV2 caps, # caches=%d", 
                    locPersonID, pCaps->NumCellCaches));

            // Now we look at each capability parameter and take the max or min
            // of the local and remote settings, as appropriate.

            sbcCurrentBitmapCaps.bPersistentKeysExpected =
                    pCaps->bPersistentKeysExpected;

            sbcCurrentBitmapCaps.bAllowCacheWaitingList =
                    min(sbcCurrentBitmapCaps.bAllowCacheWaitingList,
                    pCaps->bAllowCacheWaitingList);

            sbcCurrentBitmapCaps.NumCellCaches =
                    min(pCaps->NumCellCaches, sbcCurrentBitmapCaps.NumCellCaches);

            for (i = 0; i < sbcCurrentBitmapCaps.NumCellCaches; i++) {
                // If all parties in a share are rev2, and any client wants keys,
                // send them.
                if (!sbcCurrentBitmapCaps.CellCacheInfo[i].bSendBitmapKeys)
                    sbcCurrentBitmapCaps.CellCacheInfo[i].bSendBitmapKeys =
                            pCaps->CellCacheInfo[i].bSendBitmapKeys;

#ifdef DC_HICOLOR
                sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries =
                        min(((pCaps->CellCacheInfo[i].NumEntries * scaleNum)
                                                                / scaleDenom),
                            sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries);
#else
                sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries =
                        min(pCaps->CellCacheInfo[i].NumEntries,
                        sbcCurrentBitmapCaps.CellCacheInfo[i].NumEntries);
#endif
            }
        }
        else {
            TRC_NRM((TB,"[%ld]: No rev2 caps received", locPersonID));

            TRC_ASSERT((pCapHdr->lengthCapability == 0),
                    (TB, "[%ld]: Rev2 capability length (%u) too small",
                    locPersonID, pCapHdr->lengthCapability));
        }
    }
    else {
        TS_BITMAPCACHE_CAPABILITYSET *pOldCaps;

        TRC_ASSERT((pCapHdr->capabilitySetType == TS_CAPSETTYPE_BITMAPCACHE),
                (TB,"Received caps that are neither rev1 nor rev2!"));

        // We can receive a zero size for the capability if we didn't receive
        // any rev1 caps from any client.
        if (pCapHdr->lengthCapability >=
                sizeof(TS_BITMAPCACHE_CAPABILITYSET)) {
            // Rev 1 (Hydra 4.0 release) bitmap caching caps. Map to the
            // rev2 caps structure, taking min of the cell sizes and numbers
            // of entries.

            TRC_NRM((TB,"[%ld]: Rec'd REV1 caps", locPersonID));

            // We now have to use rev1 protocol to all clients.
            sbcCurrentBitmapCaps.capabilitySetType = TS_BITMAPCACHE_REV1;

            pOldCaps = (TS_BITMAPCACHE_CAPABILITYSET *)pCapHdr;
            sbcCurrentBitmapCaps.bPersistentKeysExpected = FALSE;
            sbcCurrentBitmapCaps.bAllowCacheWaitingList = FALSE;
            sbcCurrentBitmapCaps.NumCellCaches =
                    min(3, sbcCurrentBitmapCaps.NumCellCaches);

            sbcCurrentBitmapCaps.CellCacheInfo[0].bSendBitmapKeys = FALSE;
            if (pOldCaps->Cache1MaximumCellSize == SBC_CellSizeFromCacheID(0)) {
                sbcCurrentBitmapCaps.CellCacheInfo[0].NumEntries =
                        min(pOldCaps->Cache1Entries,
                        sbcCurrentBitmapCaps.CellCacheInfo[0].NumEntries);
            }
            else {
                // Did not receive the required size from the client. This is
                // nonstandard behavior on RDP 4.0, so no problem to disable
                // caching. Set the NumEntries to zero to turn off caching.
                sbcCurrentBitmapCaps.CellCacheInfo[0].NumEntries = 0;
            }

            sbcCurrentBitmapCaps.CellCacheInfo[1].bSendBitmapKeys = FALSE;
            if (pOldCaps->Cache2MaximumCellSize == SBC_CellSizeFromCacheID(1)) {
                sbcCurrentBitmapCaps.CellCacheInfo[1].NumEntries =
                        min(pOldCaps->Cache2Entries,
                        sbcCurrentBitmapCaps.CellCacheInfo[1].NumEntries);
            }
            else {
                // Did not receive the required size from the client. This is
                // nonstandard behavior on RDP 4.0, so no problem to disable
                // caching. Set the NumEntries to zero to turn off caching.
                sbcCurrentBitmapCaps.CellCacheInfo[1].NumEntries = 0;
            }

            sbcCurrentBitmapCaps.CellCacheInfo[2].bSendBitmapKeys = FALSE;
            if (pOldCaps->Cache3MaximumCellSize == SBC_CellSizeFromCacheID(2)) {
                sbcCurrentBitmapCaps.CellCacheInfo[2].NumEntries =
                        min(pOldCaps->Cache3Entries,
                        sbcCurrentBitmapCaps.CellCacheInfo[2].NumEntries);
            }
            else {
                // Did not receive the required size from the client. This is
                // nonstandard behavior on RDP 4.0, so no problem to disable
                // caching. Set the NumEntries to zero to turn off caching.
                sbcCurrentBitmapCaps.CellCacheInfo[2].NumEntries = 0;
            }
        }
        else {
            TRC_NRM((TB,"No rev1 caps received"));

            TRC_ASSERT((pCapHdr->lengthCapability == 0),
                    (TB, "Rev1 capability length (%u) too small",
                    pCapHdr->lengthCapability));
        }
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SBCRedetermineBrushSupport                                     */
/*                                                                          */
/* Enumerates all the people in the share and redetermines the brush        */
/* support level depending on their and the local receive capabilities.     */
/*                                                                          */
/* RETURNS: the share brush support level                                   */
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBCRedetermineBrushSupport(void)
{
    unsigned i;
    BOOLEAN rc = TRUE;

    DC_BEGIN_FN("SBCRedetermineBrushSupport");

    /************************************************************************/
    /* Start by setting brush support to the highest supported              */
    /************************************************************************/
    sbcBrushSupportLevel = TS_BRUSH_COLOR8x8;
    TRC_NRM((TB, "Initial brush support level: %ld", sbcBrushSupportLevel));

    /************************************************************************/
    /* Enumerate all the brush support capabilities of all the parties.     */
    /* Brush support is set to the lowest common denominator.               */
    /************************************************************************/
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_BRUSH, NULL, SBCEnumBrushCaps);
    if (sbcBrushSupportLevel == TS_BRUSH_DEFAULT)
        rc = FALSE;

    TRC_NRM((TB, "Enumerated brush support level: %ld", sbcBrushSupportLevel));

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* FUNCTION: SBCEnumBrushCaps                                               */
/*                                                                          */
/* Function passed to CPC_EnumerateCapabilities.  It will be called with a  */
/* capability structure for each person in the share corresponding to the   */
/* TS_CAPSETTYPE_BRUSH capability structure.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - ID of person with these capabilities.                         */
/*                                                                          */
/* pProtCaps - pointer to capabilities structure for this person.  This     */
/* pointer is only valid within the call to this function.                  */
/****************************************************************************/
void RDPCALL SHCLASS SBCEnumBrushCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_BRUSH_CAPABILITYSET pBrushCaps;
    unsigned i;

    DC_BEGIN_FN("SBCEnumBrushCaps");
    
    DC_IGNORE_PARAMETER(UserData);

    pBrushCaps = (PTS_BRUSH_CAPABILITYSET)pCapabilities;
    
    /************************************************************************/
    /* Set the brush support level to the lowest common denominator of all  */
    /* the parties in the call.                                             */
    /************************************************************************/
    if (pCapabilities->lengthCapability >= sizeof(TS_BRUSH_CAPABILITYSET)) {
        pBrushCaps = (PTS_BRUSH_CAPABILITYSET)pCapabilities;
        TRC_NRM((TB, "Brush Support Level[ID=%u]: %ld", locPersonID, 
                pBrushCaps->brushSupportLevel));
        sbcBrushSupportLevel = min(sbcBrushSupportLevel, 
                pBrushCaps->brushSupportLevel);
    }
    else {
        sbcBrushSupportLevel = TS_BRUSH_DEFAULT;
        TRC_NRM((TB, "[%ld]: Brush Support Level Unknown", locPersonID));
    }

    TRC_NRM((TB, "[%ld]: Negotiated brush level: %ld", locPersonID,
            sbcBrushSupportLevel));

    DC_END_FN();
}

/****************************************************************************/
/* FUNCTION: SBCEnumOffscreenCaps                                           */
/*                                                                          */
/* Function passed to CPC_EnumerateCapabilities.  It will be called with a  */
/* capability structure for each person in the share corresponding to the   */
/* TS_CAPSETTYPE_OFFSCREEN capability structure.                            */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - ID of person with these capabilities.                         */
/*                                                                          */
/* pProtCaps - pointer to capabilities structure for this person.  This     */
/* pointer is only valid within the call to this function.                  */
/****************************************************************************/
void RDPCALL SHCLASS SBCEnumOffscreenCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_OFFSCREEN_CAPABILITYSET pOffscreenCaps;

    DC_BEGIN_FN("SBCEnumOffscreenCaps");
    
    DC_IGNORE_PARAMETER(UserData);

    pOffscreenCaps = (PTS_OFFSCREEN_CAPABILITYSET)pCapabilities;
    
    /************************************************************************/
    /* Set the offscr support level to the lowest common denominator of all */
    /* the parties in the call.                                             */
    /************************************************************************/
    if (pCapabilities->lengthCapability >= sizeof(TS_OFFSCREEN_CAPABILITYSET)) {
        pOffscreenCaps = (PTS_OFFSCREEN_CAPABILITYSET)pCapabilities;
        
        TRC_NRM((TB, "Offscreen Support Level[ID=%u]: %ld", locPersonID, 
                pOffscreenCaps->offscreenSupportLevel));
        
        sbcOffscreenCacheInfo.supportLevel = min(sbcOffscreenCacheInfo.supportLevel, 
                pOffscreenCaps->offscreenSupportLevel);
        sbcOffscreenCacheInfo.cacheSize = min(sbcOffscreenCacheInfo.cacheSize,
                pOffscreenCaps->offscreenCacheSize);
        sbcOffscreenCacheInfo.cacheEntries = min(sbcOffscreenCacheInfo.cacheEntries,
                pOffscreenCaps->offscreenCacheEntries);
    }
    else {
        sbcOffscreenCacheInfo.supportLevel = TS_OFFSCREEN_DEFAULT;
        TRC_NRM((TB, "[%ld]: Offscreen Support Level Unknown", locPersonID));
    }

    if (sbcOffscreenCacheInfo.cacheSize == 0 ||
            sbcOffscreenCacheInfo.cacheEntries == 0) {
        sbcOffscreenCacheInfo.supportLevel = TS_OFFSCREEN_DEFAULT;
    }

    TRC_NRM((TB, "[%ld]: Negotiated offscreen level: %ld", locPersonID,
            sbcOffscreenCacheInfo.supportLevel));

    DC_END_FN();
}

/****************************************************************************/
/* FUNCTION: SBCRedetermineOffscreenSupport                                 */
/*                                                                          */
/* Enumerates all the people in the share and redetermines the offscreen    */
/* support level depending on their and the local receive capabilities.     */
/*                                                                          */
/* RETURNS: the share offscreen support level                               */
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBCRedetermineOffscreenSupport(void)
{
    unsigned i;
    BOOLEAN rc = TRUE;

    DC_BEGIN_FN("SBCRedetermineOffscreenSupport");

    /************************************************************************/
    /* Start by setting offscreen support to the highest supported          */
    /************************************************************************/
    sbcOffscreenCacheInfo.supportLevel = TS_OFFSCREEN_SUPPORTED;
    sbcOffscreenCacheInfo.cacheSize = TS_OFFSCREEN_CACHE_SIZE_SERVER_DEFAULT;
    sbcOffscreenCacheInfo.cacheEntries = TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT;

    TRC_NRM((TB, "Initial offscreen support level: %ld", 
             sbcOffscreenCacheInfo.supportLevel));

    /************************************************************************/
    /* Enumerate all the offscr support capabilities of all the parties.    */
    /* Offscr support is set to the lowest common denominator.              */
    /************************************************************************/
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_OFFSCREENCACHE, NULL, 
            SBCEnumOffscreenCaps);

    if (sbcOffscreenCacheInfo.supportLevel == TS_OFFSCREEN_DEFAULT)
        rc = FALSE;

    TRC_NRM((TB, "Enumerated offscreen support level: %ld", 
             sbcOffscreenCacheInfo.supportLevel));

    DC_END_FN();
    return rc;
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// FUNCTION: SBCEnumDrawNineGridCaps                                           
//                                                                          
// Function passed to CPC_EnumerateCapabilities.  It will be called with a  
// capability structure for each person in the share corresponding to the   
// TS_CAPSETTYPE_DRAWNINEGRID capability structure.                            
//                                                                          
// PARAMETERS:                                                              
//                                                                          
// personID - ID of person with these capabilities.                         
//                                                                          
// pProtCaps - pointer to capabilities structure for this person.  This     
// pointer is only valid within the call to this function.                  
/****************************************************************************/
void RDPCALL SHCLASS SBCEnumDrawNineGridCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_DRAW_NINEGRID_CAPABILITYSET pDrawNineGridCaps;

    DC_BEGIN_FN("SBCEnumDrawNineGridCaps");
    
    DC_IGNORE_PARAMETER(UserData);

    pDrawNineGridCaps = (PTS_DRAW_NINEGRID_CAPABILITYSET)pCapabilities;
    
    /************************************************************************/
    // Set the drawninegrid support level to the lowest common denominator of all 
    // the parties in the call.                                             
    /************************************************************************/
    if (pCapabilities->lengthCapability >= sizeof(TS_DRAW_NINEGRID_CAPABILITYSET)) {
        pDrawNineGridCaps = (PTS_DRAW_NINEGRID_CAPABILITYSET)pCapabilities;
        
        TRC_NRM((TB, "DrawNineGrid Support Level[ID=%u]: %ld", locPersonID, 
                pDrawNineGridCaps->drawNineGridSupportLevel));
        
        sbcDrawNineGridCacheInfo.supportLevel = min(sbcDrawNineGridCacheInfo.supportLevel, 
                pDrawNineGridCaps->drawNineGridSupportLevel);
        sbcDrawNineGridCacheInfo.cacheSize = min(sbcDrawNineGridCacheInfo.cacheSize,
                pDrawNineGridCaps->drawNineGridCacheSize);
        sbcDrawNineGridCacheInfo.cacheEntries = min(sbcDrawNineGridCacheInfo.cacheEntries,
                pDrawNineGridCaps->drawNineGridCacheEntries);
    }
    else {
        sbcDrawNineGridCacheInfo.supportLevel = TS_DRAW_NINEGRID_DEFAULT;
        TRC_NRM((TB, "[%ld]: DrawNineGrid Support Level Unknown", locPersonID));
    }

    if (sbcDrawNineGridCacheInfo.cacheSize == 0 ||
            sbcDrawNineGridCacheInfo.cacheEntries == 0) {
        sbcDrawNineGridCacheInfo.supportLevel = TS_DRAW_NINEGRID_DEFAULT;
    }

    TRC_NRM((TB, "[%ld]: Negotiated drawninegrid level: %ld", locPersonID,
            sbcDrawNineGridCacheInfo.supportLevel));

    DC_END_FN();
}

/****************************************************************************/
// FUNCTION: SBCRedetermineDrawNineGridSupport
//                                                                          
// Enumerates all the people in the share and redetermines the drawninegrid
// support level depending on their and the local receive capabilities.     
//                                                                          
// RETURNS: the share drawninegrid support level                               
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBCRedetermineDrawNineGridSupport(void)
{
    unsigned i;
    BOOLEAN rc = TRUE;

    DC_BEGIN_FN("SBCRedetermineDrawNineGridSupport");

    /************************************************************************/
    // Start by setting drawninegrid support to the highest supported          
    /************************************************************************/
    sbcDrawNineGridCacheInfo.supportLevel = TS_DRAW_NINEGRID_SUPPORTED_REV2;
    sbcDrawNineGridCacheInfo.cacheSize = TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT;
    sbcDrawNineGridCacheInfo.cacheEntries = TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT;

    TRC_NRM((TB, "Initial DrawNineGrid support level: %ld", 
             sbcDrawNineGridCacheInfo.supportLevel));

    /************************************************************************/
    // Enumerate all the DrawNineGrid support capabilities of all the parties.    
    // drawninegrid support is set to the lowest common denominator.              
    /************************************************************************/
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_DRAWNINEGRIDCACHE, NULL, 
            SBCEnumDrawNineGridCaps);

    if (sbcDrawNineGridCacheInfo.supportLevel == TS_DRAW_NINEGRID_DEFAULT)
        rc = FALSE;

    TRC_NRM((TB, "Enumerated drawninegrid support level: %ld", 
             sbcDrawNineGridCacheInfo.supportLevel));

    DC_END_FN();
    return rc;
}
#endif

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// FUNCTION: SBCEnumDrawGdiplusCaps                                           
//                                                                          
// Function passed to CPC_EnumerateCapabilities.  It will be called with a  
// capability structure for each person in the share corresponding to the   
// TS_DRAW_GDIPLUS_CAPABILITYSET capability structure.                            
//                                                                          
// PARAMETERS:                                                              
//                                                                          
// personID - ID of person with these capabilities.                         
//                                                                          
// pProtCaps - pointer to capabilities structure for this person.  This     
// pointer is only valid within the call to this function.                  
/****************************************************************************/
void RDPCALL SHCLASS SBCEnumDrawGdiplusCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_DRAW_GDIPLUS_CAPABILITYSET pDrawGdiplusCaps;

    DC_BEGIN_FN("SBCEnumDrawGdiplusCaps");
    
    DC_IGNORE_PARAMETER(UserData);

    pDrawGdiplusCaps = (PTS_DRAW_GDIPLUS_CAPABILITYSET)pCapabilities;
    
    /************************************************************************/
    // Set the drawgdiplus support level to the lowest common denominator of all 
    // the parties in the call.                                             
    /************************************************************************/
    if (pCapabilities->lengthCapability >= sizeof(TS_DRAW_GDIPLUS_CAPABILITYSET)) {
        pDrawGdiplusCaps = (PTS_DRAW_GDIPLUS_CAPABILITYSET)pCapabilities;
        TRC_NRM((TB, "DrawGdiplus Support Level[ID=%u]: %ld", locPersonID, 
                pDrawGdiplusCaps->drawGdiplusSupportLevel));
        TRC_NRM((TB, "Gdip version is [ID=%u]: 0x%x, 0x%x", locPersonID, 
                pDrawGdiplusCaps->GdipVersion, sbcDrawGdiplusInfo.GdipVersion));
        
        sbcDrawGdiplusInfo.supportLevel = min(sbcDrawGdiplusInfo.supportLevel, 
                pDrawGdiplusCaps->drawGdiplusSupportLevel);
        sbcDrawGdiplusInfo.GdipVersion = min(sbcDrawGdiplusInfo.GdipVersion, 
                pDrawGdiplusCaps->GdipVersion);
        sbcDrawGdiplusInfo.GdipCacheLevel = min(sbcDrawGdiplusInfo.GdipCacheLevel, 
                pDrawGdiplusCaps->drawGdiplusCacheLevel);
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries = min(sbcDrawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries, 
                pDrawGdiplusCaps->GdipCacheEntries.GdipGraphicsCacheEntries);
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries = min(sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries, 
                pDrawGdiplusCaps->GdipCacheEntries.GdipObjectBrushCacheEntries);
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries = min(sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries, 
                pDrawGdiplusCaps->GdipCacheEntries.GdipObjectPenCacheEntries);
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries = min(sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries, 
                pDrawGdiplusCaps->GdipCacheEntries.GdipObjectImageCacheEntries);
        sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries = min(sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries, 
                pDrawGdiplusCaps->GdipCacheEntries.GdipObjectImageAttributesCacheEntries);
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize = min(sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize, 
                pDrawGdiplusCaps->GdipCacheChunkSize.GdipGraphicsCacheChunkSize);
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize = min(sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize, 
                pDrawGdiplusCaps->GdipCacheChunkSize.GdipObjectBrushCacheChunkSize);
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize = min(sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize, 
                pDrawGdiplusCaps->GdipCacheChunkSize.GdipObjectPenCacheChunkSize);
        sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize = min(sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize, 
                pDrawGdiplusCaps->GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize);
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize = min(sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize, 
                pDrawGdiplusCaps->GdipImageCacheProperties.GdipObjectImageCacheChunkSize);
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize = min(sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize, 
                pDrawGdiplusCaps->GdipImageCacheProperties.GdipObjectImageCacheTotalSize);
        sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize = min(sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize, 
                pDrawGdiplusCaps->GdipImageCacheProperties.GdipObjectImageCacheMaxSize);
    }
    else {
        sbcDrawGdiplusInfo.supportLevel = TS_DRAW_GDIPLUS_DEFAULT;
        sbcDrawGdiplusInfo.GdipVersion = TS_GDIPVERSION_DEFAULT;
        TRC_ERR((TB, "[%ld]: DrawGdiplus Support Level Unknown", locPersonID));
    }

    TRC_NRM((TB, "[%ld]: Negotiated drawgdiplus level: %ld", locPersonID,
            sbcDrawGdiplusInfo.supportLevel));

    DC_END_FN();
}




BOOLEAN RDPCALL SHCLASS SBCRedetermineDrawGdiplusSupport(void)
{
    BOOLEAN rc = TRUE;

    DC_BEGIN_FN("SBCRedetermineDrawGdiplusSupport");

    /************************************************************************/
    // Start by setting drawgdiplus support to the highest supported          
    /************************************************************************/
    sbcDrawGdiplusInfo.supportLevel = TS_DRAW_GDIPLUS_SUPPORTED;
    sbcDrawGdiplusInfo.GdipVersion = 0xFFFFFFFF;
    sbcDrawGdiplusInfo.GdipCacheLevel = TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE;
    sbcDrawGdiplusInfo.GdipCacheEntries.GdipGraphicsCacheEntries = TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectBrushCacheEntries = TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectPenCacheEntries = TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageCacheEntries = TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheEntries.GdipObjectImageAttributesCacheEntries = TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipGraphicsCacheChunkSize = TS_GDIP_GRAPHICS_CACHE_CHUNK_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize = TS_GDIP_BRUSH_CACHE_CHUNK_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectPenCacheChunkSize = TS_GDIP_PEN_CACHE_CHUNK_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize = TS_GDIP_IMAGEATTRIBUTES_CACHE_CHUNK_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheChunkSize = TS_GDIP_IMAGE_CACHE_CHUNK_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheTotalSize = TS_GDIP_IMAGE_CACHE_TOTAL_SIZE_DEFAULT;
    sbcDrawGdiplusInfo.GdipImageCacheProperties.GdipObjectImageCacheMaxSize = TS_GDIP_IMAGE_CACHE_MAX_SIZE_DEFAULT;

    CPC_EnumerateCapabilities(TS_CAPSETTYPE_DRAWGDIPLUS, NULL, 
            SBCEnumDrawGdiplusCaps);

    if (sbcDrawGdiplusInfo.supportLevel == TS_DRAW_GDIPLUS_DEFAULT)
        rc = FALSE;

    TRC_NRM((TB, "Enumerated drawgdiplus support level: %ld", 
             sbcDrawGdiplusInfo.supportLevel));

    DC_END_FN();
    return rc;
}
#endif // DRAW_GDIPLUS

/****************************************************************************/
// SBCRedetermineGlyphCacheSize: Enumerates all the people in the share and
// redetermines the size of the glyph cache depending on their and the local
// receive capabilities.
//
// Returns: TRUE if glyph caching should be enabled, FALSE otherwise.
/****************************************************************************/
BOOLEAN RDPCALL SHCLASS SBCRedetermineGlyphCacheSize(void)
{
    BOOLEAN  rc = TRUE;
    unsigned i;

    DC_BEGIN_FN("SBCRedetermineGlyphCacheSize");

    /************************************************************************/
    /* Enumerate all the glyph cache receive capabilities of all the        */
    /* parties.  The usable size of the send glyph cache is the minimum of  */
    /* all the remote receive caches and the local send cache size.         */
    /************************************************************************/

    /************************************************************************/
    /* Start by setting the size of the local send bitmap cache to the      */
    /* local default values.  We DO need to do this, or we end up           */
    /* negotiating our glyph cache down to zero!                            */
    /************************************************************************/
    for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
        sbcGlyphCacheSizes[i].cEntries = sbcMaxGlyphCacheSizes[i].cEntries;
        sbcGlyphCacheSizes[i].cbCellSize = sbcMaxGlyphCacheSizes[i].cbCellSize;
    }

    sbcFragCacheSizes[0].cEntries = sbcMaxFragCacheSizes[0].cEntries;
    sbcFragCacheSizes[0].cbCellSize = sbcMaxFragCacheSizes[0].cbCellSize;

    /************************************************************************/
    /* Now enumerate all the parties in the share and set our send glyph    */
    /* sizes appropriately.                                                 */
    /************************************************************************/
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_GLYPHCACHE, NULL,
            SBCEnumGlyphCacheCaps);

    if (sbcGlyphSupportLevel == CAPS_GLYPH_SUPPORT_NONE)
        rc = FALSE;

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SBCEnumGlyphCacheCaps: Function passed to CPC_EnumerateCapabilities. It
// will be called with a capability structure for each person in the share
// corresponding to the TS_CAPSETTYPE_BITMAPCACHE capability structure.
//
// Params:
//     personID - ID of person with these capabilities.
//     pProtCaps - pointer to capabilities structure for this person. This
//         pointer is only valid within the call to this function.
/****************************************************************************/
void CALLBACK SHCLASS SBCEnumGlyphCacheCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    unsigned i;
    PTS_GLYPHCACHE_CAPABILITYSET pGlyphCacheCaps;

    DC_BEGIN_FN("SBCEnumGlyphCacheCaps");

    DC_IGNORE_PARAMETER(UserData);

    if (pCapabilities->lengthCapability >=
            sizeof(TS_GLYPHCACHE_CAPABILITYSET)) {
        pGlyphCacheCaps = (PTS_GLYPHCACHE_CAPABILITYSET)pCapabilities;

        for (i = 0; i<SBC_NUM_GLYPH_CACHES; i++) {
            TRC_NRM((TB, "[%u]: Cache %d: MaximumCellSize(%u) Entries(%u)",
                    locPersonID,
                    i,
                    pGlyphCacheCaps->GlyphCache[i].CacheMaximumCellSize,
                    pGlyphCacheCaps->GlyphCache[i].CacheEntries));

            /************************************************************************/
            /* Set the size of the glyph cache to the minimum of its current size   */
            /* and this party's receive glyph cache size.                           */
            /************************************************************************/
            sbcGlyphCacheSizes[i].cEntries =
                    min(sbcGlyphCacheSizes[i].cEntries,
                    pGlyphCacheCaps->GlyphCache[i].CacheEntries);

            sbcGlyphCacheSizes[i].cbCellSize =
                    min(sbcGlyphCacheSizes[i].cbCellSize,
                    pGlyphCacheCaps->GlyphCache[i].CacheMaximumCellSize);

            TRC_NRM((TB, 
                    "[%u]: Negotiated glyph cache %u size: cEntries(%u) cbCellSize(%u)",
                    locPersonID,
                    i,
                    sbcGlyphCacheSizes[i].cEntries,
                    sbcGlyphCacheSizes[i].cbCellSize));
        }

        /************************************************************************/
        /* Set the size of the glyph cache to the minimum of its current size   */
        /* and this party's receive glyph cache size.                           */
        /************************************************************************/
        sbcFragCacheSizes[0].cEntries =
            min(sbcFragCacheSizes[0].cEntries,
                   pGlyphCacheCaps->FragCache.CacheEntries);

        sbcFragCacheSizes[0].cbCellSize =
            min(sbcFragCacheSizes[0].cbCellSize,
                   pGlyphCacheCaps->FragCache.CacheMaximumCellSize);

        /************************************************************************/
        /* Glyph support level                                                  */
        /************************************************************************/
        sbcGlyphSupportLevel = min(sbcGlyphSupportLevel, 
                pGlyphCacheCaps->GlyphSupportLevel);
    }
    else {
        for (i = 0; i < SBC_NUM_GLYPH_CACHES; i++) {
            sbcGlyphCacheSizes[i].cEntries = 0;
            sbcGlyphCacheSizes[i].cbCellSize = 0;
        }

        sbcFragCacheSizes[0].cEntries = 0;
        sbcFragCacheSizes[0].cbCellSize = 0;

        sbcGlyphSupportLevel = CAPS_GLYPH_SUPPORT_NONE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\apmapi.cpp ===
/****************************************************************************/
/* apmapi.cpp                                                               */
/*                                                                          */
/* Palette Manager API Functions.                                           */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright (c) Microsoft 1997 - 2000                                      */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "apmapi"
#include <as_conf.hpp>


/****************************************************************************/
/* PM_Init()                                                                */
/*                                                                          */
/* Initializes the Palette Manager.                                         */
/****************************************************************************/
void RDPCALL SHCLASS PM_Init(void)
{
    TS_COLORTABLECACHE_CAPABILITYSET ColorTableCaps;

    DC_BEGIN_FN("PM_Init");

#define DC_INIT_DATA
#include <apmdata.c>
#undef DC_INIT_DATA

    // Set up the PM capabilities.
    ColorTableCaps.capabilitySetType   = TS_CAPSETTYPE_COLORCACHE;
    ColorTableCaps.colorTableCacheSize = SBC_NUM_COLOR_TABLE_CACHE_ENTRIES;
    ColorTableCaps.pad2octets = 0;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&ColorTableCaps,
            sizeof(TS_COLORTABLECACHE_CAPABILITYSET));

    DC_END_FN();
}


/****************************************************************************/
/* PM_MaybeSendPalettePacket()                                              */
/*                                                                          */
/* Tries to broadcast a palette packet to all remote people in a share if   */
/* necessary.                                                               */
/*                                                                          */
/* PM_MaybeSendPalettePacket returns a boolean indicating whether it has    */
/* successfully sent a palette packet. We only send further updates if      */
/* the palette packet is successfully sent.                                 */
/*                                                                          */
/* RETURNS: TRUE if palette packet was successfully sent, or if no packet   */
/* needs to be sent. FALSE if a packet needs to be sent but could not be.   */
/****************************************************************************/
BOOL RDPCALL SHCLASS PM_MaybeSendPalettePacket(PPDU_PACKAGE_INFO pPkgInfo)
{
    BOOL rc = TRUE;
    unsigned i;
    unsigned cbPalettePacketSize;
    BYTE *pPackageSpace;

    DC_BEGIN_FN("PM_MaybeSendPalettePacket");

    if (m_pShm->pm.paletteChanged || pmMustSendPalette) {
        TRC_NRM((TB, "Send palette packet"));

        // Set up a palette packet. First calculate the packet size.
        cbPalettePacketSize = scUpdatePDUHeaderSpace +
                sizeof(TS_UPDATE_PALETTE_PDU_DATA) +
                ((PM_NUM_8BPP_PAL_ENTRIES - 1) * sizeof(TS_COLOR));

        // Get space in the PDU package.
        pPackageSpace = SC_GetSpaceInPackage(pPkgInfo, cbPalettePacketSize);
        if (pPackageSpace != NULL) {
            TS_UPDATE_PALETTE_PDU_DATA UNALIGNED *pData;
            BYTE *pEncode;

            // Fill in the packet header.
            if (scUseFastPathOutput) {
                pPackageSpace[0] = scCompressionUsedValue |
                        TS_UPDATETYPE_PALETTE;
                pData = (TS_UPDATE_PALETTE_PDU_DATA UNALIGNED *)
                        (pPackageSpace + scUpdatePDUHeaderSpace);
            }
            else {
                TS_UPDATE_PALETTE_PDU UNALIGNED *pPalettePDU;

                pPalettePDU = (PTS_UPDATE_PALETTE_PDU)pPackageSpace;
                pPalettePDU->shareDataHeader.pduType2 = TS_PDUTYPE2_UPDATE;
                pData = &pPalettePDU->data;
            }

            pData->updateType   = TS_UPDATETYPE_PALETTE;
            pData->numberColors = PM_NUM_8BPP_PAL_ENTRIES;

            // Convert the DCRGBQUADs in the color table to DCCOLORs as we copy
            // them into the packet.
            for (i = 0; i < PM_NUM_8BPP_PAL_ENTRIES; i++) {
                // Convert each RGBQUAD entry in the palette to a DCCOLOR entry
                // in the palette PDU. We swap the elements because the client
                // wants to treat the palette entries as DWORDs and lift them
                // straight out of the packet.
                pData->palette[i].red   = m_pShm->pm.palette[i].rgbBlue;
                pData->palette[i].green = m_pShm->pm.palette[i].rgbGreen;
                pData->palette[i].blue  = m_pShm->pm.palette[i].rgbRed;
            }

            // Now send the packet to the remote application.
            SC_AddToPackage(pPkgInfo, cbPalettePacketSize, TRUE);

            // We no longer need to send a palette packet.
            m_pShm->pm.paletteChanged = FALSE;
            pmMustSendPalette = FALSE;
        }
        else {
            TRC_ALT((TB, "Failed to allocate packet"));
            rc = FALSE;
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* API FUNCTION: PM_SyncNow                                                 */
/*                                                                          */
/* Resyncs to the remote PM by ensuring that the datastream does not refer  */
/* to any previously sent data.                                             */
/****************************************************************************/
void RDPCALL SHCLASS PM_SyncNow(void)
{
    DC_BEGIN_FN("PM_SyncNow");

    // Ensure we send a palette to the remote PM next time we are called.
    TRC_NRM((TB, "Palette sync"));
    pmMustSendPalette = TRUE;

    DC_END_FN();
}


#ifdef NotUsed
/****************************************************************************/
/* FUNCTION: PMEnumPMCaps                                                   */
/*                                                                          */
/* PM callback function for CPC capabilities enumeration.                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - ID of this person                                             */
/* pCapabilities - pointer to this person's cursor capabilites              */
/****************************************************************************/
void CALLBACK SHCLASS PMEnumPMCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_COLORTABLECACHE_CAPABILITYSET pColorCacheCaps;
    unsigned                          cTxCacheSize;

    DC_BEGIN_FN("PMEnumPMCaps");

    DC_IGNORE_PARAMETER(UserData);

    pColorCacheCaps = (PTS_COLORTABLECACHE_CAPABILITYSET)pCapabilities;

    // If the person does not have any color table caching capabilites we
    // still get called, but the sizeOfCapabilities field is zero.
    if (pColorCacheCaps->lengthCapability <
            sizeof(PTS_COLORTABLECACHE_CAPABILITYSET)) {
        TRC_NRM((TB, "[%u] No color cache caps", (unsigned)locPersonID));
        cTxCacheSize = 1;
    }
    else {
        TRC_NRM((TB, "[%u] capsID(%u) size(%u) CacheSize(%u)",
                                       (unsigned)locPersonID,
                                       pColorCacheCaps->capabilitySetType,
                                       pColorCacheCaps->lengthCapability,
                                       pColorCacheCaps->colorTableCacheSize));
        cTxCacheSize = pColorCacheCaps->colorTableCacheSize;
    }

    pmNewTxCacheSize = min(pmNewTxCacheSize, cTxCacheSize);

    DC_END_FN();
}
#endif  // NotUsed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ascint.cpp ===
/****************************************************************************/
/* ascint.c                                                                 */
/*                                                                          */
/* Share Controller Internal functions.                                     */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-2000                                         */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "ascint"
#include <as_conf.hpp>

#include <string.h>
#include <stdio.h>

extern "C"
{
#include <asmapi.h>
}


/****************************************************************************/
/* FUNCTION: SCPartyJoiningShare                                            */
/*                                                                          */
/* Called when a new party is joining the share.  This is an internal       */
/* function because it is the SC which calls all these functions.  The      */
/* processing done here relies on the capabilities - so it is in here as    */
/* this is called after CPC_PartyJoiningShare.                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - local person ID of remote person joining the share.        */
/* oldShareSize - the number of the parties which were in the share (ie     */
/*     excludes the joining party).                                         */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE if the party can join the share.                                    */
/* FALSE if the party can NOT join the share.                               */
/****************************************************************************/
BOOL RDPCALL SHCLASS SCPartyJoiningShare(LOCALPERSONID locPersonID,
                                         unsigned      oldShareSize)
{
    DC_BEGIN_FN("SCPartyJoiningShare");

    DC_IGNORE_PARAMETER(locPersonID);

    if (oldShareSize != 0) {
        SCParseGeneralCaps();

        // Initialize Flow Control.
        SCFlowInit();
    }

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
/* FUNCTION: SCPartyLeftShare()                                             */
/*                                                                          */
/* Called when a party has left the share.                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - local person ID of remote person leaving the               */
/*     share.                                                               */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/*     the leaving party).                                                  */
/****************************************************************************/
void RDPCALL SHCLASS SCPartyLeftShare(LOCALPERSONID locPersonID,
                                      unsigned      newShareSize)
{
    DC_BEGIN_FN("SCPartyLeftShare");

    DC_IGNORE_PARAMETER(locPersonID);

    if (newShareSize != 0)
        SCParseGeneralCaps();

    DC_END_FN();
}


/****************************************************************************/
// SCParseGeneralCaps
//
// Enumerates the general capabilities and sets up needed variables.
/****************************************************************************/
void RDPCALL SHCLASS SCParseGeneralCaps()
{
    DC_BEGIN_FN("SCParseGeneralCaps");

    // Set default local support for fast-path output. It must be shut down
    // during a shadow to guarantee the non-fast-path format is used
    // in the cross-server shadow pipe, even though that means a performance
    // hit on the wire to each client. Note that checking for shadowState
    // == SHADOW_NONE is not a sufficient check, there is a timing window
    // where it is likely not be be set yet, so we also force it off in
    // SC_AddPartyToShare().
    if (m_pTSWd->shadowState == SHADOW_NONE) {
        scUseFastPathOutput = TRUE;
    }
    else {
        scUseFastPathOutput = FALSE;
        TRC_ALT((TB,"Forcing fast-path output to off in shadow"));
    }

    CPC_EnumerateCapabilities(TS_CAPSETTYPE_GENERAL, NULL,
            SCEnumGeneralCaps);

    // Set the package header reservation size based on the final results of
    // the fast-path output support.
    if (scUseFastPathOutput) {
        if (m_pTSWd->bCompress) {
            TRC_ALT((TB,"Fast-path output enabled with compression"));
            scUpdatePDUHeaderSpace = 4;
            scCompressionUsedValue = TS_OUTPUT_FASTPATH_COMPRESSION_USED;
        }
        else {
            TRC_ALT((TB,"Fast-path output enabled without compression"));
            scUpdatePDUHeaderSpace = 3;
            scCompressionUsedValue = 0;
        }
    }
    else {
        TRC_ALT((TB,"Fast-path output disabled"));
        scUpdatePDUHeaderSpace = sizeof(TS_SHAREDATAHEADER);
    }

    SCUpdateVCCaps();

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SCEnumGeneralCaps                                              */
/*                                                                          */
/* Used to determine the lowest version in the share.                       */
/*                                                                          */
/* PARAMETERS: standard CPC callback parameters                             */
/****************************************************************************/
void RDPCALL SHCLASS SCEnumGeneralCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities )
{
    PTS_GENERAL_CAPABILITYSET pGeneralCaps =
            (PTS_GENERAL_CAPABILITYSET)pCapabilities;

    DC_BEGIN_FN("SCEnumGeneralCaps");

    DC_IGNORE_PARAMETER(locPersonID);
    DC_IGNORE_PARAMETER(UserData);

    // Determine if we should support No BC header or not depending on the 
    // client support level and the current support level
    scNoBitmapCompressionHdr = min(scNoBitmapCompressionHdr,
            pGeneralCaps->extraFlags & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR);
    
    // Disable fast-path output if any client does not support it.
    if (!(pGeneralCaps->extraFlags & TS_FASTPATH_OUTPUT_SUPPORTED))
        scUseFastPathOutput = FALSE;

    // Enable sending Long Credentials back to the client if it supports it
    if (pGeneralCaps->extraFlags & TS_LONG_CREDENTIALS_SUPPORTED) { 
        scUseLongCredentials = TRUE;
    } else {
        scUseLongCredentials = FALSE;
    }

    // Determine if we should enable the arc cookie
    if ((pGeneralCaps->extraFlags & TS_AUTORECONNECT_COOKIE_SUPPORTED) &&
        (FALSE == m_pTSWd->fPolicyDisablesArc)) {
        scUseAutoReconnect = TRUE;
    }
    else {
        scUseAutoReconnect = FALSE;
    }

    // Determine if we support the more secure checksum style
    if ((pGeneralCaps->extraFlags & TS_ENC_SECURE_CHECKSUM)) {
        SM_SetSafeChecksumMethod(scPSMHandle, TRUE);
    }
    else {
        SM_SetSafeChecksumMethod(scPSMHandle, FALSE);
    }
    

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SCCallPartyJoiningShare                                        */
/*                                                                          */
/* Calls other components' XX_PartyJoiningShare() functions.  Should be     */
/* called with scNumberInShare set to the old call size.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - of party joining the call.                                 */
/* sizeOfCaps - sizeof the capabilities parameter pCaps.                    */
/* pCaps - pointer to capabilities for the party.                           */
/* pAccepted - pointer to array of BOOLs which is filled in with the        */
/*     result of the respective components function.                        */
/* oldShareSize - the number to pass to the PJS functions.                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE - all components accepted the party; pAccepted will be filled with  */
/*     TRUE.                                                                */
/* FALSE - a component rejected the party.  Any components which accepted   */
/*     the party will have their pAccepted entry set to TRUE; all other     */
/*     entries will be FALSE.                                               */
/****************************************************************************/
BOOL RDPCALL SHCLASS SCCallPartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      sizeOfCaps,
        PVOID         pCaps,
        PBOOL         pAccepted,
        unsigned      oldShareSize)
{
    DC_BEGIN_FN("SCCallPartyJoiningShare");

    /************************************************************************/
    /* Set all of pAccepted to FALSE.                                       */
    /************************************************************************/
    memset(pAccepted, 0, sizeof(BOOL) * SC_NUM_PARTY_JOINING_FCTS);

    /************************************************************************/
    /* Call the functions in the correct order, giving up if any reject the */
    /* party.                                                               */
    /************************************************************************/
#define CALL_PJS(NUM, CALL)                                          \
    TRC_NRM((TB, "Call PJS # %d", NUM));                             \
    if (0 == (pAccepted[NUM] = CALL))                                \
    {                                                                \
        TRC_NRM((TB, "%d PartyJoining failed", (unsigned)NUM));        \
        return FALSE;                                                \
    }

    TRC_NRM((TB, "{%d}Call PJS functions", locPersonID));

    /************************************************************************/
    // Notes on the order of PartyJoiningShare calls:
    // 1. CPC must be called before everyone else (as everyone else needs
    //    capabilites for the new party).
    // 2. UP must be called after SC because UP relies on the caps
    //    negotiation in SC.
    /************************************************************************/
    CALL_PJS(SC_CPC, CPC_PartyJoiningShare(locPersonID, oldShareSize,
            sizeOfCaps, pCaps))
    CALL_PJS(SC_SC,  SCPartyJoiningShare(locPersonID,   oldShareSize))
    CALL_PJS(SC_IM,  IM_PartyJoiningShare (locPersonID, oldShareSize))
    CALL_PJS(SC_CA,  CA_PartyJoiningShare (locPersonID, oldShareSize))
    CALL_PJS(SC_CM,  CM_PartyJoiningShare (locPersonID, oldShareSize))
    CALL_PJS(SC_OE,  OE_PartyJoiningShare (locPersonID, oldShareSize))
    CALL_PJS(SC_SSI, SSI_PartyJoiningShare(locPersonID, oldShareSize))
    CALL_PJS(SC_USR, USR_PartyJoiningShare(locPersonID, oldShareSize))
    CALL_PJS(SC_UP,  UP_PartyJoiningShare(locPersonID, oldShareSize))
    CALL_PJS(SC_SBC, SBC_PartyJoiningShare(locPersonID, oldShareSize))

    TRC_DATA_NRM("PJS status",
                 pAccepted,
                 sizeof(BOOL) * SC_NUM_PARTY_JOINING_FCTS);
    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
/* FUNCTION: SCCallPartyLeftShare                                           */
/*                                                                          */
/* Calls other components' XX_PartyLeftShare() functions.  should be called */
/* with scNumberInShare set to the new call size.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - of party who has left the call.                            */
/* pAccepted - pointer to array of BOOLs which is used to decide which      */
/*     components' functions to call.  Any component with an entry set to   */
/*     TRUE will be called.                                                 */
/* newShareSize - the number to pass to the various PLS functions.          */
/****************************************************************************/
void RDPCALL SHCLASS SCCallPartyLeftShare(LOCALPERSONID locPersonID,
                                          PBOOL         pAccepted,
                                          unsigned      newShareSize )
{
    DC_BEGIN_FN("SCCallPartyLeftShare");

    /************************************************************************/
    /* Call any components which have their pAccepted entry to TRUE.        */
    /************************************************************************/

#define CALL_PLS(A, B)                                          \
    {                                                           \
        if (pAccepted[A])                                       \
        {                                                       \
            TRC_NRM((TB, "Call PLS # %d", A));                  \
            B(locPersonID, newShareSize);                       \
        }                                                       \
    }

    TRC_NRM((TB, "Call PLS functions"));

    /************************************************************************/
    /* Notes on order of PartyLeftShare calls                               */
    /*                                                                      */
    /* 1. CPC must be called first (so everyone else gets capabilities      */
    /*    which exclude the party which has left).                          */
    /************************************************************************/
    CALL_PLS(SC_CPC, CPC_PartyLeftShare)
    CALL_PLS(SC_SC,  SCPartyLeftShare)
    CALL_PLS(SC_CA,  CA_PartyLeftShare )
    CALL_PLS(SC_IM,  IM_PartyLeftShare )
    CALL_PLS(SC_OE,  OE_PartyLeftShare )
    CALL_PLS(SC_SBC, SBC_PartyLeftShare)
    CALL_PLS(SC_SSI, SSI_PartyLeftShare)
    CALL_PLS(SC_USR, USR_PartyLeftShare)
    CALL_PLS(SC_UP,  UP_PartyLeftShare)

    TRC_NRM((TB, "Done PLS functions"));

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SCInitiateSync                                                */
/*                                                                          */
/* Purpose:   Initiate synchronization                                      */
/*                                                                          */
/* Params:    bShadowSync - set to true of this sync is being requested for */
/*            a shadowing session.                                          */
/*                                                                          */
/* Operation: Broadcast a sync packet on all priorities                     */
/*            Call other components to synchronize, unless this is a shadow */
/*            sync in which case the DD will already have synchronized      */
/*            itself prior to initiating this action.                       */
/****************************************************************************/
void RDPCALL SHCLASS SCInitiateSync(BOOLEAN bShadowSync)
{
    PTS_SYNCHRONIZE_PDU pPkt;
    NTSTATUS          status;
    BOOL              rc;

    DC_BEGIN_FN("SCInitiateSync");

    SC_CHECK_STATE(SCE_INITIATESYNC);

    /************************************************************************/
    // Allocate a Sync PDU
    // fWait is TRUE means that we will always wait for a buffer to be avail
    /************************************************************************/
    status = SM_AllocBuffer(scPSMHandle,
                        (PPVOID)(&pPkt),
                        sizeof(TS_SYNCHRONIZE_PDU),
                        TRUE,
                        FALSE);
    if ( STATUS_SUCCESS == status ) {
        /********************************************************************/
        // Build the Sync PDU
        /********************************************************************/
        pPkt->shareDataHeader.shareControlHeader.totalLength =
                sizeof(TS_SYNCHRONIZE_PDU);
        pPkt->shareDataHeader.pduType2 = TS_PDUTYPE2_SYNCHRONIZE;
        pPkt->messageType = TS_SYNCMSGTYPE_SYNC;

        /********************************************************************/
        // Send the Sync PDU (Broadcast, all parties, all priorities)
        /********************************************************************/
        rc = SC_SendData((PTS_SHAREDATAHEADER)pPkt,
                         sizeof(TS_SYNCHRONIZE_PDU),
                         sizeof(TS_SYNCHRONIZE_PDU),
                         0, 0);
        if (rc) {
            TRC_NRM((TB, "Sent Sync OK"));

            /****************************************************************/
            // Call all the XX_SyncNow() functions.
            /****************************************************************/
            CA_SyncNow();
            PM_SyncNow();         // added for shadowing
            UP_SyncNow(bShadowSync);
        }
        else {
            TRC_ERR((TB, "Failed to send Sync PDU"));
        }
    }
    else {
        TRC_ERR((TB, "Failed to alloc syncPDU"));
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* SCInitiateSync */


/****************************************************************************/
/* Name:      SCConfirmActive                                               */
/*                                                                          */
/* Purpose:   Handle incoming ConfirmActivePDU                              */
/*                                                                          */
/* Params:    netPersonID - ID of sender of ConfirmActivePDU                */
/*            pPkt        - ConfirmActivePDU                                */
/****************************************************************************/
void RDPCALL SHCLASS SCConfirmActive(
        PTS_CONFIRM_ACTIVE_PDU pPkt,
        unsigned               DataLength,
        NETPERSONID          netPersonID)
{
    LOCALPERSONID             localPersonID = 0;
    unsigned                  localCapsSize;
    PTS_COMBINED_CAPABILITIES pLocalCaps;
    BOOL                      acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
    BOOL                      rc = FALSE;
    BOOL                      callingPJS = FALSE;
    BOOL                      kickWDW = FALSE;
    unsigned                  errDetailCode = 0;
    WCHAR                     detailData[25];
    unsigned                  len, detailDataLen;		

    DC_BEGIN_FN("SCConfirmActive");

    SC_CHECK_STATE(SCE_CONFIRM_ACTIVE);


    // First check we have enogh data for this packet.
    if (DataLength >= (sizeof(TS_CONFIRM_ACTIVE_PDU) - 1)) {
        if (DataLength >= (sizeof(TS_CONFIRM_ACTIVE_PDU) - 1 +
                pPkt->lengthSourceDescriptor +
                pPkt->lengthCombinedCapabilities)) {
            // Do some meaningful work here to predict the branches correctly.
            goto PDUOK;
        }
        else {
            TRC_ERR((TB,"Total PDU len %u too short for header and data len %u",
                    DataLength, pPkt->lengthSourceDescriptor +
                    pPkt->lengthCombinedCapabilities));
            goto ShortPDU;
        }
    }
    else {
        TRC_ERR((TB,"Data length %u too short for ConfirmActivePDU header",
                DataLength));
        goto ShortPDU;
    }

PDUOK:

    kickWDW = FALSE;

    /************************************************************************/
    /* Check it's the right ConfirmActivePDU                                */
    /************************************************************************/
    if (pPkt->shareID != scShareID)
    {
        TRC_ERR((TB, "Wrong Share ID, expect %x, got %x",
                scShareID, pPkt->shareID));
        errDetailCode = Log_RDP_ConfirmActiveWrongShareID;
        len = swprintf(detailData, L"%x %x", scShareID, pPkt->shareID);
        detailDataLen = sizeof(*detailData) * len;
        DC_QUIT;
    }

    if (pPkt->originatorID != scUserID)
    {
        TRC_ERR((TB, "Wrong originator ID, expect %d, got %hd",
                scUserID, pPkt->originatorID));
        errDetailCode = Log_RDP_ConfirmActiveWrongOriginator;
        len = swprintf(detailData, L"%x %hx", scUserID, pPkt->originatorID);
        detailDataLen = sizeof(*detailData) * len;
        DC_QUIT;
    }

    /************************************************************************/
    /* We will receive a ConfirmActivePDU on all priorities.  If we get     */
    /* here and we're already in a Share, this must be a second or          */
    /* subsequent one.  Simply ignore it.  Set rc = TRUE so that we don't   */
    /* send a DeactivateOtherPDU below.                                     */
    /************************************************************************/
    if (scState == SCS_IN_SHARE)
    {
        TRC_ALT((TB, "Superfluous ConfirmActivePDU received"));
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* If we get here, this is the first ConfirmActivePDU, and it's from    */
    /* the right Client.  Set a flag which will cause us to kick WDW back   */
    /* into life at the end of this function                                */
    /************************************************************************/
    kickWDW = TRUE;

    /************************************************************************/
    /* Reject this party if it will exceed the maximum number of parties    */
    /* allowed in a share.  (Not required for RNS V1.0, but left in as it   */
    /* doesn't do any harm).                                                */
    /************************************************************************/
    if (scNumberInShare == SC_DEF_MAX_PARTIES)
    {
        TRC_ERR((TB, "Reached max parties in share %d",
               SC_DEF_MAX_PARTIES));
        DC_QUIT;
    }

    /************************************************************************/
    /* If this is the first remote party in the share, call the             */
    /* XX_PartyJoiningShare() functions for the local party first.          */
    /************************************************************************/
    callingPJS = TRUE;
    if (scNumberInShare == 0)
    {
        CPC_GetCombinedCapabilities(SC_LOCAL_PERSON_ID,
                                    &localCapsSize,
                                    &pLocalCaps);

        if (!SCCallPartyJoiningShare(SC_LOCAL_PERSON_ID,
                                     localCapsSize,
                                     pLocalCaps,
                                     acceptedArray,
                                     0))
        {
            /****************************************************************/
            /* Some component rejected the local party                      */
            /****************************************************************/
            TRC_ERR((TB, "The local party should never be rejected"));
            DC_QUIT;
        }

        /********************************************************************/
        /* There is now one party in the share (the local one).             */
        /********************************************************************/
        scNumberInShare = 1;
        TRC_NRM((TB, "Added local person"));
    }

    /************************************************************************/
    /* Calculate a localPersonID for the remote party and store their       */
    /* details in the party array.                                          */
    /************************************************************************/
    for ( localPersonID = 1;
          localPersonID < SC_DEF_MAX_PARTIES;
          localPersonID++ )
    {
        if (scPartyArray[localPersonID].netPersonID == 0)
        {
            /****************************************************************/
            /* Found an empty slot.                                         */
            /****************************************************************/
            TRC_NRM((TB, "Allocated local person ID %d", localPersonID));
            break;
        }
    }

    /************************************************************************/
    /* Even though scNumberInShare is checked against SC_DEF_MAX_PARTIES    */
    /* above, the loop above might still not find an empty slot.            */
    /************************************************************************/ 
    if (SC_DEF_MAX_PARTIES <= localPersonID)
    {
        TRC_ABORT((TB, "Couldn't find room to store local person"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Store the new person's details                                       */
    /************************************************************************/
    scPartyArray[localPersonID].netPersonID = netPersonID;
    //    we know that we have at least lengthSourceDescriptor bytes in the buffer
    //    we should copy not more than lengthSourceDescriptor or the destination 
    //    buffer size.
    strncpy(scPartyArray[localPersonID].name,
            (char *)(&(pPkt->data[0])),
            min(sizeof(scPartyArray[0].name)-sizeof(scPartyArray[0].name[0]),
                pPkt->lengthSourceDescriptor));
    
    // zero terminate to make sure we don't overflow on subsequent processing.
    scPartyArray[localPersonID].name[sizeof(scPartyArray[0].name)/
                                     sizeof(scPartyArray[0].name[0]) - 1] = 0;
    
    memset(scPartyArray[localPersonID].sync,
            0,
            sizeof(scPartyArray[localPersonID].sync));

    TRC_NRM((TB, "{%d} person name %s",
            (unsigned)localPersonID, scPartyArray[localPersonID].name));

    /************************************************************************/
    /* Call the XX_PartyJoiningShare() functions for the remote party.      */
    /************************************************************************/
    if (!SCCallPartyJoiningShare(localPersonID,
                                 pPkt->lengthCombinedCapabilities,
                       (PVOID)(&(pPkt->data[pPkt->lengthSourceDescriptor])),
                                 acceptedArray,
                                 scNumberInShare))
    {
        /********************************************************************/
        // Some component rejected the remote party. Force a disconnect
        // and log an event.
        /********************************************************************/
        TRC_ERR((TB, "Remote party rejected"));
        errDetailCode = Log_RDP_BadCapabilities;
        detailDataLen = 0;
        DC_QUIT;
    }

    /************************************************************************/
    /* The remote party is now in the share.                                */
    /************************************************************************/
    callingPJS = FALSE;
    rc = TRUE;
    scNumberInShare++;
    TRC_NRM((TB, "Number in share %d", (unsigned)scNumberInShare));

    /************************************************************************/
    /* Move onto the next state.                                            */
    /************************************************************************/
    SC_SET_STATE(SCS_IN_SHARE);

    /************************************************************************/
    /* Synchronise only for primary stacks.  Shadow stacks will be sync'd   */
    /* by the DD right before output starts.                                */
    /************************************************************************/
    SCInitiateSync(m_pTSWd->StackClass == Stack_Shadow);

DC_EXIT_POINT:

    if (!rc)
    {
        /********************************************************************/
        /* Something went wrong.  Tidy up                                   */
        /********************************************************************/
        TRC_NRM((TB, "Something went wrong - %d people in Share",
                scNumberInShare));


        /********************************************************************/
        /* If we fail, tell WDW now, so it can clean up.  If we succeed, FH */
        /* tells WDW when font negotiation is complete.                     */
        /********************************************************************/
        if (kickWDW)
        {
            TRC_NRM((TB, "Kick WDW"));
            WDW_ShareCreated(m_pTSWd, FALSE);
        }

        if (callingPJS)
        {
            TRC_NRM((TB, "Failed in PJS functions"));

            /****************************************************************/
            /* Notify components that remote party has left Share.  Note    */
            /* that scNumberInShare is not updated if PJS functions fail.   */
            /****************************************************************/
            if (scNumberInShare > 0)
            {
                /************************************************************/
                /* We failed to add a remote party                          */
                /************************************************************/
                TRC_NRM((TB, "Failed to add remote party"));
                SCCallPartyLeftShare(localPersonID,
                                     acceptedArray,
                                     scNumberInShare );

                /************************************************************/
                /* Set acceptedArray ready to call PJS for local person     */
                /************************************************************/
                memset(acceptedArray,
                          TRUE,
                          sizeof(BOOL) * SC_NUM_PARTY_JOINING_FCTS );
            }

            if (scNumberInShare <= 1)
            {
                /************************************************************/
                /* We failed to add one of                                  */
                /* - the local person (scNumberInShare == 0)                */
                /* - the first remote person (scNumberInShare == 1)         */
                /* Either way, we now need to remove the local person.      */
                /************************************************************/
                TRC_NRM((TB, "Clean up local person"));
                SCCallPartyLeftShare(SC_LOCAL_PERSON_ID,
                                     acceptedArray, 0);

                scNumberInShare = 0;
            }
        }

        /********************************************************************/
        /* Now we need to terminate the Client, via one of two means:       */
        /* - if it's a protocol error, simply disconnect the Client         */
        /* - if it's a resource error, try to end the Share.                */
        /********************************************************************/
        if (errDetailCode != 0)
        {
            WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                 errDetailCode,
                                 (BYTE *)detailData,
                                 detailDataLen);
        }
        TRC_NRM((TB, "Reject the new person"));
        SCDeactivateOther(netPersonID);

        /********************************************************************/
        /* Finally, free the local person ID, if one was allocated          */
        /********************************************************************/
        if ((localPersonID != 0) && (localPersonID != SC_DEF_MAX_PARTIES))
        {
            TRC_NRM((TB, "Free local person ID"));
            scPartyArray[localPersonID].netPersonID = 0;
        }
    }

    DC_END_FN();
    return;

// Error handling
ShortPDU:
    WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ConfirmActivePDUTooShort,
            (BYTE *)pPkt, DataLength);

    DC_END_FN();
} /* SC_ConfirmActivePDU */


/****************************************************************************/
/* Name:      SCDeactivateOther                                             */
/*                                                                          */
/* Purpose:   Deactivate another person                                     */
/*                                                                          */
/* Params:    netPersonID - ID of person to be deactivated                  */
/****************************************************************************/
void RDPCALL SHCLASS SCDeactivateOther(NETPERSONID netPersonID)
{
    unsigned                 pktLen;
    unsigned                 nameLen;
    PTS_DEACTIVATE_OTHER_PDU pPkt;
    NTSTATUS                 status;
    BOOL                     rc;

    DC_BEGIN_FN("SCDeactivateOther");

    /************************************************************************/
    /* Allocate a buffer                                                    */
    /************************************************************************/
    pktLen = sizeof(TS_DEACTIVATE_OTHER_PDU) - 1;
    nameLen = strlen(scPartyArray[0].name);
    nameLen = (unsigned)DC_ROUND_UP_4(nameLen);
    pktLen += nameLen;

    // fWait is TRUE means that we will always wait for a buffer to be avail
    status = SM_AllocBuffer(scPSMHandle, (PPVOID)(&pPkt), pktLen, TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        /********************************************************************/
        // Fill in the packet fields.
        /********************************************************************/
        pPkt->shareControlHeader.totalLength = (UINT16)pktLen;
        pPkt->shareControlHeader.pduType = TS_PDUTYPE_DEACTIVATEOTHERPDU |
                                          TS_PROTOCOL_VERSION;
        pPkt->shareControlHeader.pduSource = (UINT16)scUserID;
        pPkt->shareID = scShareID;
        pPkt->deactivateID = (UINT16)netPersonID;
        memcpy(&(pPkt->sourceDescriptor[0]), scPartyArray[0].name, nameLen);

        // Send it.
        rc = SM_SendData(scPSMHandle, pPkt, pktLen, TS_HIGHPRIORITY, 0,
                FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (!rc) {
            TRC_ERR((TB, "Failed to send TS_DEACTIVATE_OTHER_PDU"));
        }
    }
    else {
        /********************************************************************/
        /* Failed to allocate a buffer.  This Bad News.  Give up.           */
        /********************************************************************/
        TRC_ERR((TB, "Failed to alloc %d bytes for TS_DEACTIVATE_OTHER_PDU",
                pktLen));
    }

    DC_END_FN();
} /* SCDeactivateOther */


/****************************************************************************/
/* Name:      SCEndShare                                                    */
/*                                                                          */
/* Purpose:   Clean up the local side of the share                          */
/*                                                                          */
/* Operation: Call all PartyLeftShare functions for each party.             */
/****************************************************************************/
void RDPCALL SHCLASS SCEndShare(void)
{
    BOOL acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
    int  i;

    DC_BEGIN_FN("SCEndShare");

    /************************************************************************/
    /* If no-one has joined the Share yet, there's nothing to do            */
    /************************************************************************/
    if (scNumberInShare == 0)
    {
        TRC_ALT((TB, "Ending Share before it was started"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Call PLS for all remote people.                                      */
    /************************************************************************/
    memset(acceptedArray, TRUE, sizeof(acceptedArray));

    for (i = SC_DEF_MAX_PARTIES - 1; i > 0; i--)
    {
        if (scPartyArray[i].netPersonID != 0)
        {
            TRC_NRM((TB, "Party %d left Share", i));
            scNumberInShare--;
            SCCallPartyLeftShare(i, acceptedArray, scNumberInShare);
            memset(&(scPartyArray[i]), 0, sizeof(*scPartyArray));
        }
    }

    /************************************************************************/
    /* Now call PLS functions for the local person.  Don't clear            */
    /* scPartyArray for the local person, as the info is still valid.       */
    /************************************************************************/
    scNumberInShare--;
    TRC_ASSERT((scNumberInShare == 0),
                (TB, "Still %d people in the Share", scNumberInShare));
    TRC_NRM((TB, "Local party left Share"));
    SCCallPartyLeftShare(0, acceptedArray, scNumberInShare);

DC_EXIT_POINT:
    /************************************************************************/
    /* Return to the inititalized state                                     */
    /************************************************************************/
    SC_SET_STATE(SCS_INITED);

    DC_END_FN();
} /* SCEndShare */


/****************************************************************************/
/* Name:      SCSynchronizePDU                                              */
/*                                                                          */
/* Purpose:   Handle incoming Synchronize PDUs                              */
/*                                                                          */
/* Params:    netPersonID - user ID of the sender                           */
/*            pPkt        - SynchronizePDU                                  */
/****************************************************************************/
void RDPCALL SHCLASS SCSynchronizePDU(NETPERSONID       netPersonID,
                                      UINT32            priority,
                                      PTS_SYNCHRONIZE_PDU pPkt)
{
    LOCALPERSONID localID;
    DC_BEGIN_FN("SCSynchronizePDU");

    localID = SC_NetworkIDToLocalID(netPersonID);
    TRC_NRM((TB, "SynchronizePDU person [%d] {%d}, priority %d",
            netPersonID, localID, priority));

    scPartyArray[localID].sync[priority] = TRUE;

    DC_END_FN();
} /* SCSynchronizePDU */


/****************************************************************************/
/* Name:      SCReceivedControlPacket                                       */
/*                                                                          */
/* Purpose:   Handle incoming control packets                               */
/*                                                                          */
/* Params:    netPersonID - ID of the sender                                */
/*            priority    - priority on which the packet was sent           */
/*            pPkt        - the packet                                      */
/****************************************************************************/
void RDPCALL SHCLASS SCReceivedControlPacket(
        NETPERSONID netPersonID,
        UINT32      priority,
        void        *pPkt,
        unsigned    DataLength)
{
    unsigned      pduType;
    LOCALPERSONID locPersonID;
    BOOL          pduOK = FALSE;
    BOOL          status;

    DC_BEGIN_FN("SCReceivedControlPacket");

    // We have enough data to read the flow control marker since the marker
    // is overlaid over the SHARECONTROLHEADER.totalLength. We checked earlier
    // for having enough data to read the share ctrl hdr.

    /************************************************************************/
    /* First, check for Flow Control packets                                */
    /************************************************************************/
    if (((PTS_FLOW_PDU)pPkt)->flowMarker != TS_FLOW_MARKER)
    {
        /********************************************************************/
        /* Check for control packets                                        */
        /********************************************************************/
//      SC_CHECK_STATE(SCE_CONTROLPACKET);
        pduOK = TRUE;

        pduType = ((PTS_SHARECONTROLHEADER)pPkt)->pduType & TS_MASK_PDUTYPE;
        switch (pduType) {
            case TS_PDUTYPE_CONFIRMACTIVEPDU:
                TRC_ALT((TB, "%s Stack: ConfirmActivePDU", 
                         m_pTSWd->StackClass == Stack_Primary ? "Primary" :
                        (m_pTSWd->StackClass == Stack_Passthru ? "Passthru" :
                        "Shadow")));
                SCConfirmActive((PTS_CONFIRM_ACTIVE_PDU)pPkt, DataLength,
                        netPersonID);
            break;

            case TS_PDUTYPE_CLIENTRANDOMPDU:
                TRC_ALT((TB, "ClientRandomPDU"));
                status = SC_SaveClientRandom((PTS_CLIENT_RANDOM_PDU) pPkt, DataLength);

                if (status != TRUE) 
                {
                    TRC_ERR((TB, "Error in SC_SaveClientRandom, data length = %u", DataLength));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                        Log_RDP_InputPDUBadLength,
                                        (BYTE *) pPkt,
                                        DataLength);
                }
                break;

            default:
            {
                /************************************************************/
                /* At the moment, we don't expect or process any other      */
                /* control packets                                          */
                /************************************************************/
                TRC_ERR((TB, "Unexpected packet type %d", pduType));
                TRC_DATA_NRM("Packet", pPkt,
                            ((PTS_SHARECONTROLHEADER)&pPkt)->totalLength);
                WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                     Log_RDP_UnknownPDUType,
                                     (BYTE *) &pduType,
                                     sizeof(pduType));
            }
            break;
        }
    }
    else
    {
        /********************************************************************/
        /* For the purposes of state checking, treat Flow Control packets   */
        /* as data packets.                                                 */
        /********************************************************************/
        SC_CHECK_STATE(SCE_DATAPACKET);
        pduOK = TRUE;

        // Make sure we have enough data to access the TS_FLOW_PDU fields.
        if (DataLength >= sizeof(TS_FLOW_PDU)) {
            pduType = ((PTS_FLOW_PDU)pPkt)->pduType;
            locPersonID = SC_NetworkIDToLocalID(netPersonID);
        }
        else {
            TRC_ERR((TB,"Data length %u too short for FlowPDU", DataLength));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_FlowPDUTooShort,
                    (BYTE *)pPkt, DataLength);
            DC_QUIT;
        }

        switch (pduType)
        {
            case TS_PDUTYPE_FLOWTESTPDU:
            {
                TRC_NRM((TB, "[%d] {%d} Flow Test PDU on priority %d",
                        netPersonID, locPersonID, priority));
                SCFlowTestPDU(locPersonID, (PTS_FLOW_PDU)pPkt, priority);
            }
            break;

            default:
            {
                TRC_ERR((TB, "[%d] {%d} Unknown Flow PDU %d on priority %d",
                        netPersonID, locPersonID, pduType, priority));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                     Log_RDP_UnknownFlowPDU,
                                     (BYTE *) &pduType,
                                     sizeof(pduType));
            }
            break;
        }

    }

DC_EXIT_POINT:
    if (!pduOK)
    {
        /********************************************************************/
        /* Out-of-sequence control PDU - log and disconnect                 */
        /********************************************************************/
        WCHAR detailData[(sizeof(pduType)*2) + (sizeof(scState)*2) + 2];
        TRC_ERR((TB, "Out-of-sequence control PDU %hx, state %d",
                pduType, scState));
        swprintf(detailData, L"%hx %x", pduType, scState);
        WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                             Log_RDP_ControlPDUSequence,
                             (BYTE *)detailData,
                             sizeof(detailData));
    }

    DC_END_FN();
} /* SCReceivedControlPacket */


/****************************************************************************/
/* Name:      SCFlowTestPDU                                                 */
/*                                                                          */
/* Purpose:   Handle incoming Flow Test PDUs                                */
/*                                                                          */
/* Params:    locPersonID - id of the sender                                */
/*            pPkt        - the Flow Test PDU                               */
/****************************************************************************/
void RDPCALL SHCLASS SCFlowTestPDU(
        LOCALPERSONID locPersonID,
        PTS_FLOW_PDU  pPkt,
        UINT32        priority)
{
    PTS_FLOW_PDU pRsp;
    NTSTATUS     status;
    BOOL rc;

    DC_BEGIN_FN("SCFlowTestPDU");

    // Build and send a flow response PDU.
    // fWait is TRUE means that we will always wait for a buffer to be avail
    status = SM_AllocBuffer(scPSMHandle, (PPVOID)(&pRsp), sizeof(*pRsp), TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        pRsp->flowMarker = TS_FLOW_MARKER;
        pRsp->pduType = TS_PDUTYPE_FLOWRESPONSEPDU;
        pRsp->flowIdentifier = pPkt->flowIdentifier;
        pRsp->flowNumber = pPkt->flowNumber;
        pRsp->pduSource = pPkt->pduSource;

        rc = SM_SendData(scPSMHandle, pRsp, sizeof(*pRsp), priority,
                scPartyArray[locPersonID].netPersonID, FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (!rc) {
            TRC_ERR((TB, "Failed to send Flow Response PDU"));
        }
    }
    else {
        TRC_ERR((TB, "Failed to alloc Flow Response PDU"));
    }

    DC_END_FN();
} /* SCFlowTestPDU */


//
// SCUpdateVCCaps update VirtualChannel capabilities based on
// remote person's caps.
//
void RDPCALL SHCLASS SCUpdateVCCaps()
{
    DC_BEGIN_FN("SCUpdateVCCaps");

    PTS_VIRTUALCHANNEL_CAPABILITYSET pVcCaps = NULL;

    //
    //Determine if the client supports VC compression
    //What we're determining here is that the client supports
    //the server sending it compressed VC data. The capability in the
    //other direction, i.e can the server send the client VC data
    //is a capability the server exposes to the client and it may choose
    //to then send compressed VC data to the server
    //
    pVcCaps = (PTS_VIRTUALCHANNEL_CAPABILITYSET)CPCGetCapabilities(
                            SC_REMOTE_PERSON_ID, TS_CAPSETTYPE_VIRTUALCHANNEL);
    if(pVcCaps && (pVcCaps->vccaps1 & TS_VCCAPS_COMPRESSION_64K))
    {
        m_pTSWd->bClientSupportsVCCompression = TRUE;
        TRC_NRM((TB, "Client supports VC compression"));
    }
    else
    {
        m_pTSWd->bClientSupportsVCCompression = FALSE;
        TRC_NRM((TB, "Client doesn't support VC compression"));
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asdgapi.cpp ===
/****************************************************************************/
// asdgapi.cpp
//
// RDP Screen Data Grabber API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "asdgapi"
#include <as_conf.hpp>
#include <nprcount.h>


/****************************************************************************/
// SDG_Init
/****************************************************************************/
void RDPCALL SHCLASS SDG_Init(void)
{
    DC_BEGIN_FN("SDG_Init");

#define DC_INIT_DATA
#include <asdgdata.c>
#undef DC_INIT_DATA

#ifdef DC_HICOLOR
#else
    TRC_ASSERT((m_desktopBpp == 8), (TB, "Unexpected bpp: %u", m_desktopBpp));
#endif

    DC_END_FN();
}


/****************************************************************************/
// SDG_SendScreenDataArea
//
// Sends the accumulated Screen Data Area.
/****************************************************************************/
void RDPCALL SHCLASS SDG_SendScreenDataArea(
        BYTE *pFrameBuf,
        UINT32 frameBufWidth,
        PPDU_PACKAGE_INFO pPkgInfo)
{
    unsigned i;
    RECTL sdaRect[BA_MAX_ACCUMULATED_RECTS];
    unsigned cRects;
    BOOLEAN mustSendPDU;
    BOOL fBltOK = TRUE;
    SDG_ENCODE_CONTEXT Context;

    DC_BEGIN_FN("SDG_SendScreenDataArea");

    INC_INCOUNTER(IN_SND_SDA_ALL);
    ADD_INCOUNTER(IN_SND_SDA_AREA, m_pShm->ba.totalArea);

    // Get the bounds of the screen data area. At entry this is always
    // our primary transmission area. Even if we had already flushed
    // the primary region and were in the middle of the secondary region
    // we will switch back to the primary region if any more SD
    // accumulates. In this way we keep our spoiling of the secondary
    // screendata maximized.
    BA_GetBounds(sdaRect, &cRects);

    // Initialize the context.
    Context.BitmapPDUSize = 0;
    Context.pPackageSpace = NULL;
    Context.pBitmapPDU = NULL;
    Context.pSDARect = NULL;

    // Process each of the accumulated rectangles in turn.
    TRC_DBG((TB, "%d SDA rectangles", cRects));
    for (i = 0; i < cRects; i++) {
        TRC_DBG((TB, "(%d): (%d,%d)(%d,%d)", i, sdaRect[i].left,
                sdaRect[i].top, sdaRect[i].right, sdaRect[i].bottom ));

        // If all of the previous rectangles have been successfully sent
        // then try to send this rectangle.
        // If a previous rectangle failed to be sent then we don't bother
        // trying to send the rest of the rectangles in the same batch -
        // they are added back into the SDA so that they will be sent later.
        if (fBltOK) {
            // Set the 'last' flag to force sending of the PDU for the last
            // rectangle.
            mustSendPDU = (i + 1 == cRects) ? TRUE : FALSE;
            fBltOK = SDGSendSDARect(pFrameBuf, frameBufWidth, &(sdaRect[i]),
                    mustSendPDU, pPkgInfo, &Context);
        }

        if (!fBltOK) {
            // The blt to network failed - probably because a network
            // packet could not be allocated.
            // We add the rectangle back into the SDA so that we will try
            // to retransmit the area later.
            if (m_pTSWd->shadowState == SHADOW_NONE) {
                TRC_ALT((TB, "Blt failed - add back rect (%d,%d)(%d,%d)",
                        sdaRect[i].left, sdaRect[i].top,
                        sdaRect[i].right, sdaRect[i].bottom));
            }

            // Add the rectangle into the bounds.
            BA_AddRect(&(sdaRect[i]));
        }
    }

    // We counted all the data available as sent, decrement by any still
    // unsent!
    SUB_INCOUNTER(IN_SND_SDA_AREA, m_pShm->ba.totalArea);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asbcdata.c ===
/****************************************************************************/
/* asbcdata.c                                                               */
/*                                                                          */
/* Send Bitmap Cache data.                                                  */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-2000 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, sbcBitmapCachingEnabled, FALSE);

DC_DATA(BOOLEAN, sbcGlyphCachingEnabled, FALSE);
DC_DATA(UINT16, sbcGlyphSupportLevel, CAPS_GLYPH_SUPPORT_ENCODE);

DC_DATA(BOOLEAN, sbcNewCapsData, FALSE);
DC_DATA(BOOLEAN, sbcCachingOn, FALSE);
DC_DATA(BOOLEAN, sbcSyncRequired, FALSE);

DC_DATA(BOOLEAN, sbcPersistentKeysReceived, FALSE);

DC_DATA(BOOLEAN, sbcBrushCachingEnabled, FALSE);

DC_DATA_ARRAY_NULL(BOOLEAN, sbcClearCache, TS_BITMAPCACHE_MAX_CELL_CACHES, FALSE);

DC_DATA(UINT32,  sbcBrushSupportLevel, 0);

DC_DATA_ARRAY_NULL(SBC_CACHE_SIZE, 
                   sbcGlyphCacheSizes, SBC_NUM_GLYPH_CACHES, 0);

DC_DATA_ARRAY_NULL(SBC_CACHE_SIZE, 
                   sbcFragCacheSizes, SBC_NUM_FRAG_CACHES, 0);

DC_DATA(unsigned, sbcTotalKeysExpected, 0);
DC_DATA_ARRAY_NULL(unsigned, sbcNumKeysExpected,
        TS_BITMAPCACHE_MAX_CELL_CACHES, 0);

DC_DATA(unsigned, sbcTotalNumErrorPDUs, 0);

DC_DATA(PSBC_BITMAP_CACHE_KEY_INFO, sbcKeyDatabase, NULL);
DC_DATA(unsigned, sbcKeyDatabaseSize, 0);

DC_DATA_NULL(TS_BITMAPCACHE_CAPABILITYSET_REV2, sbcCurrentBitmapCaps, 0);

DC_DATA_NULL(SBC_OFFSCREEN_BITMAP_CACHE_INFO, sbcOffscreenCacheInfo, 0);
DC_DATA(BOOLEAN, sbcOffscreenCachingEnabled, FALSE);
DC_DATA(BOOLEAN, sbcDisableOffscreenCaching, FALSE);

#ifdef DRAW_NINEGRID
DC_DATA_NULL(SBC_DRAWNINEGRID_BITMAP_CACHE_INFO, sbcDrawNineGridCacheInfo, 0);
DC_DATA(BOOLEAN, sbcDrawNineGridCachingEnabled, FALSE);
DC_DATA(BOOLEAN, sbcDisableDrawNineGridCaching, FALSE);
#endif

#ifdef DRAW_GDIPLUS
DC_DATA(BOOLEAN, sbcDrawGdiplusEnabled, FALSE);
DC_DATA_NULL(SBC_DRAWGDIPLUS_INFO, sbcDrawGdiplusInfo, 0);
DC_DATA(BOOLEAN, sbcDisableDrawGdiplus, FALSE);
#endif

// Default caps which are the basic of sbcCurrentCaps.
DC_CONST_DATA(TS_BITMAPCACHE_CAPABILITYSET_REV2, sbcDefaultBitmapCaps,
    DC_STRUCT8(
      TS_BITMAPCACHE_REV2,  // capabilitySetType is used to store the protocol version in use.
      0,  // Don't care about length.
      TRUE,  // We can handle persistent key lists.
      TRUE,  // We can handle bitmap cache waiting list.
      0,     // Zeroed Pad1.
      0,     // Zeroed Pad2.
      TS_BITMAPCACHE_SERVER_CELL_CACHES,  // We can handle up to the server's current 
                                           // limitation.

      // Maximum values for each of the bitmap cell caches.
      // First value is the number of entries, second is persistence.
      // Persistence is set to FALSE because it will become TRUE if any
      // client in session sends TRUE in its caps.
      DC_STRUCT5(
        DC_STRUCT2(600, FALSE),
        DC_STRUCT2(600, FALSE),
        DC_STRUCT2(65536, FALSE),
        DC_STRUCT2(4096, FALSE),
        DC_STRUCT2(2048, FALSE))));

DC_CONST_DATA_ARRAY(SBC_CACHE_SIZE,
                    sbcMaxGlyphCacheSizes, SBC_NUM_GLYPH_CACHES,
    DC_STRUCT10(
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE1_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE2_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE3_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE4_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE5_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE6_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE7_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE8_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE9_MAX_CELL_SIZE),
     DC_STRUCT2(SBC_GL_MAX_CACHE_ENTRIES, SBC_GL_CACHE10_MAX_CELL_SIZE)
    )
);

DC_CONST_DATA_ARRAY(SBC_CACHE_SIZE,
                    sbcMaxFragCacheSizes, SBC_NUM_FRAG_CACHES,
    DC_STRUCT1(
     DC_STRUCT2(SBC_FG_CACHE_MAX_ENTRIES, SBC_FG_CACHE_MAX_CELL_SIZE)
    )
);
#ifdef DC_HICOLOR
DC_DATA(unsigned, sbcClientBitsPerPel, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asdgdata.c ===
/****************************************************************************/
/* asdgdata.c                                                               */
/*                                                                          */
/* Screen Data Grabber data.                                                */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright (c) Microsoft 1997 - 1999                                      */
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
// Running compression ratio tallies for session.
/****************************************************************************/
DC_DATA(UINT32, sdgCompTotal, 0);
DC_DATA(UINT32, sdgUncompTotal, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ascapi.cpp ===
/****************************************************************************/
// ascapi.c
//
// Share Controller API Functions.
//
// Copyright (C) Microsoft Corp., PictureTel 1992-1997
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "ascapi"
#include <as_conf.hpp>

extern "C"
{
#include <acomapi.h>
#include <asmapi.h>
#include <asmint.h>
}

#include <string.h>


/****************************************************************************/
// SC_Init
// Initializes the Share Controller.
//
// PARAMETERS:
// pSMHandle     - Handle to pass to SM calls
//
// RETURNS: FALSE on failure.
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_Init(PVOID pSMHandle)
{
    BOOL rc;
    unsigned MaxPDUSize;

    DC_BEGIN_FN("SC_Init");

    // Don't check the state - there's no static data init in the C++ App
    // Serving build so this will see complete garbage in scState and fail.

#define DC_INIT_DATA
#include <ascdata.c>
#undef DC_INIT_DATA

    // Register with SM.
    rc = SM_Register(pSMHandle, &MaxPDUSize, &scUserID);
    if (rc) {
        // Save the User ID.
        scPartyArray[0].netPersonID = scUserID;
        scPSMHandle = pSMHandle;
        TRC_NRM((TB, "Local user id [%d]", scUserID));

        // Set the user name.
        strcpy(scPartyArray[0].name, "RDP");

        // Get the usable space (and hence the allocation request size) for
        // our 8K and 16K OutBufs.
        sc8KOutBufUsableSpace = IcaBufferGetUsableSpace(OUTBUF_8K_ALLOC_SIZE) 
                - OUTBUF_HEADER_OVERHEAD;
        sc16KOutBufUsableSpace = IcaBufferGetUsableSpace(
                OUTBUF_16K_ALLOC_SIZE) - OUTBUF_HEADER_OVERHEAD;

        // Move onto the next state.
        SC_SET_STATE(SCS_INITED)
    }
    else {
        TRC_ERR((TB, "Failed to register with SM"));
    }

    DC_END_FN();
    return rc;
}

/****************************************************************************/
// SC_Update
// Update the Share Controller after shadow.
//
/****************************************************************************/
void RDPCALL SHCLASS SC_Update()
{
    DC_BEGIN_FN("SC_Update");

    scNoBitmapCompressionHdr = TS_EXTRA_NO_BITMAP_COMPRESSION_HDR;

    DC_END_FN();
}


/****************************************************************************/
/* SC_Term()                                                                */
/*                                                                          */
/* Terminates the Share Controller.                                         */
/****************************************************************************/
void RDPCALL SHCLASS SC_Term(void)
{
    DC_BEGIN_FN("SC_Term");

    SC_CHECK_STATE(SCE_TERM);

    // Reset state.
    SC_SET_STATE(SCS_STARTED);

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* SC_CreateShare()                                                         */
/*                                                                          */
/* Creates a share for the current session.                                 */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_CreateShare(void)
{
    BOOL                      rc = FALSE;
    unsigned                  pktLen;
    unsigned                  nameLen;
    unsigned                  capsSize;
    UINT32                    sessionId;
    PTS_COMBINED_CAPABILITIES caps;
    PTS_DEMAND_ACTIVE_PDU     pPkt = NULL;
    PTS_BITMAP_CAPABILITYSET  pBitmapCaps;
    NTSTATUS status;

    DC_BEGIN_FN("SC_CreateShare");

    SC_CHECK_STATE(SCE_CREATE_SHARE);

    /************************************************************************/
    /* For console sessions, there's no client, so not much point in        */
    /* sending a demand active PDU. We also have to set up caps ourselves.  */
    /************************************************************************/
    if (m_pTSWd->StackClass == Stack_Console)
    {
        LOCALPERSONID              localPersonID = 0;
        unsigned                   localCapsSize;
        PTS_COMBINED_CAPABILITIES  pLocalCaps;
        BOOL                       acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
        BOOL                       callingPJS = FALSE;

        TRC_NRM((TB, "SC_CreateShare called for console stack"));
        /********************************************************************/
        /* Move onto the next state.                                        */
        /********************************************************************/
        SC_SET_STATE(SCS_IN_SHARE);

        /********************************************************************/
        /* carry on as if a confirm active has been received                */
        /********************************************************************/
        callingPJS = TRUE;
        if (scNumberInShare == 0)
        {
            CPC_GetCombinedCapabilities(SC_LOCAL_PERSON_ID,
                                        &localCapsSize,
                                        &pLocalCaps);

            if (!SCCallPartyJoiningShare(SC_LOCAL_PERSON_ID,
                                         localCapsSize,
                                         pLocalCaps,
                                         acceptedArray,
                                         0))
            {
                /************************************************************/
                /* Some component rejected the local party                  */
                /************************************************************/
                TRC_ERR((TB, "The local party should never be rejected"));
                DC_QUIT;
            }

            /****************************************************************/
            /* There is now one party in the share (the local one).         */
            /****************************************************************/
            scNumberInShare = 1;
            TRC_NRM((TB, "Added local person"));
        }

        /********************************************************************/
        /* Calculate a localPersonID for the remote party and store their   */
        /* details in the party array.                                      */
        /********************************************************************/
        for ( localPersonID = 1;
              localPersonID < SC_DEF_MAX_PARTIES;
              localPersonID++ )
        {
            if (scPartyArray[localPersonID].netPersonID == 0)
            {
                /************************************************************/
                /* Found an empty slot.                                     */
                /************************************************************/
                TRC_NRM((TB, "Allocated local person ID %d", localPersonID));
                break;
            }
        }

        /********************************************************************/
        /* If we don't find an empty slot, we can't keep running because    */
        /* we write past the end of the scPartyArray below.                 */
        /********************************************************************/
        if (SC_DEF_MAX_PARTIES <= localPersonID)
        {
            TRC_ABORT((TB, "Couldn't find room to store local person"));
            DC_QUIT;
        }

        /********************************************************************/
        /* Store the new person's details                                   */
        /********************************************************************/
        scPartyArray[localPersonID].netPersonID = 42;
        strncpy(scPartyArray[localPersonID].name,
                   "Console",
                   sizeof(scPartyArray[0].name) );
        memset(scPartyArray[localPersonID].sync,
                  0,
                  sizeof(scPartyArray[localPersonID].sync));

        TRC_NRM((TB, "{%d} person name %s",
                (unsigned)localPersonID, scPartyArray[localPersonID].name));


        /********************************************************************/
        /* We need to set up client caps ourselves, since there's no actual */
        /* client to do it.  We set up a maximal set that will get          */
        /* negotiated down when someone shadows us.                         */
        /********************************************************************/
        typedef struct tagCC_COMBINED_CAPABILITIES
        {
            UINT16                             numberCapabilities;
#ifdef DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
        #define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 18
#else
        #define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 17
#endif
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
        #define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 17
#else
        #define CC_COMBINED_CAPS_NUMBER_CAPABILITIES 16
#endif
#endif // DRAW_GDIPLUS
            UINT16                             pad2octets;
            TS_GENERAL_CAPABILITYSET           generalCapabilitySet;
            TS_BITMAP_CAPABILITYSET            bitmapCapabilitySet;
            TS_ORDER_CAPABILITYSET             orderCapabilitySet;
            TS_BITMAPCACHE_CAPABILITYSET       bitmapCacheCaps;
            TS_COLORTABLECACHE_CAPABILITYSET   colorTableCacheCapabilitySet;
            TS_WINDOWACTIVATION_CAPABILITYSET  windowActivationCapabilitySet;
            TS_CONTROL_CAPABILITYSET           controlCapabilitySet;
            TS_POINTER_CAPABILITYSET           pointerCapabilitySet;
            TS_SHARE_CAPABILITYSET             shareCapabilitySet;
            TS_INPUT_CAPABILITYSET             inputCapabilitySet;
            TS_SOUND_CAPABILITYSET             soundCapabilitySet;
            TS_FONT_CAPABILITYSET              fontCapabilitySet;
            TS_GLYPHCACHE_CAPABILITYSET        glyphCacheCapabilitySet;
            TS_BRUSH_CAPABILITYSET             brushCapabilitySet;
            TS_OFFSCREEN_CAPABILITYSET         offscreenCapabilitySet;
            TS_VIRTUALCHANNEL_CAPABILITYSET    virtualchannelCapabilitySet;         

#ifdef DRAW_NINEGRID
            TS_DRAW_NINEGRID_CAPABILITYSET     drawNineGridCapabilitySet;
#endif   
#ifdef DRAW_GDIPLUS  
            TS_DRAW_GDIPLUS_CAPABILITYSET       drawGdiplusCapabilitySet;
#endif
        } CC_COMBINED_CAPABILITIES;

        // ARG!  Why isn't this const!!!
        CC_COMBINED_CAPABILITIES caps =
        {
            CC_COMBINED_CAPS_NUMBER_CAPABILITIES, /* Number of capabilities */
            0,                                    /* padding                */

            /****************************************************************/
            /* General caps                                                 */
            /****************************************************************/
            {
                TS_CAPSETTYPE_GENERAL,         /* capabilitySetType         */
                sizeof(TS_GENERAL_CAPABILITYSET), /* lengthCapability       */
                TS_OSMAJORTYPE_WINDOWS,        /* OSMajorType               */
                TS_OSMINORTYPE_WINDOWS_NT,     /* OSMinorType               */
                TS_CAPS_PROTOCOLVERSION,       /* protocolVersion           */
                0,                             /* pad1                      */
                0,                             /* generalCompressionTypes   */
                TS_EXTRA_NO_BITMAP_COMPRESSION_HDR |
                    TS_FASTPATH_OUTPUT_SUPPORTED   |
                    TS_LONG_CREDENTIALS_SUPPORTED  |
                    TS_AUTORECONNECT_COOKIE_SUPPORTED |
                    TS_ENC_SECURE_CHECKSUM,/*recv safer checksums    */
                FALSE,                         /* updateCapabilityFlag      */
                FALSE,                         /* remoteUnshareFlag         */
                0,                             /* generalCompressionLevel   */
                0,                             /* refreshRectSupport        */
                0                              /* suppressOutputSupport     */
            },

            /****************************************************************/
            /* Bitmap caps                                                  */
            /****************************************************************/
            {
                TS_CAPSETTYPE_BITMAP,            /* capabilitySetType       */
                sizeof(TS_BITMAP_CAPABILITYSET), /* lengthCapability        */
                8,          /* Set in CC */      /* preferredBitsPerPixel   */
                TRUE,                            /* receive1BitPerPixel     */
                TRUE,                            /* receive4BitsPerPixel    */
                TRUE,                            /* receive8BitsPerPixel    */
                1024,       /* Set in CC */      /* desktopWidth            */
                768,        /* Set in CC */      /* desktopHeight           */
                0,                               /* pad2                    */
                FALSE,                           /* desktopResizeFlag       */
                1,                               /* bitmapCompressionFlag   */
                0,                               /* highColorFlags          */
                0,                               /* pad1                    */
                TRUE,                            /* multipleRectangleSupport*/
                0                                /* pad2                    */
            },

            /****************************************************************/
            /* Order Caps                                                   */
            /****************************************************************/
            {
                TS_CAPSETTYPE_ORDER,                       /* capabilitySetType    */
                sizeof(TS_ORDER_CAPABILITYSET),            /* lengthCapability     */
                {'\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0'}, /* terminalDescriptor   */
                0,                                         /* pad1                 */
                1,                                         /* desktopSaveXGranularity */
                20,                                        /* desktopSaveYGranularity */
                0,                                         /* pad2                 */
                1,                                         /* maximumOrderLevel    */
                0,                                         /* numberFonts          */
                TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT   |  /* orderFlags           */
                TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT     |
                TS_ORDERFLAGS_COLORINDEXSUPPORT,

                {
                    /********************************************************/
                    /* Order Support flags.                                 */
                    /*                                                      */
                    /* The array index corresponds to the TS_NEG_xxx_INDEX  */
                    /* value indicated (from at128.h) The values marked     */
                    /* with an x in the first column are overwritten at run */
                    /* time by UH before CC sends the combined              */
                    /* capabilities.                                        */
                    /********************************************************/

                    1, /*   0 TS_NEG_DSTBLT_INDEX          destinationBltSupport    */
                    1, /*   1 TS_NEG_PATBLT_INDEX          patternBltSupport        */
                    1, /* x 2 TS_NEG_SCRBLT_INDEX          screenBltSupport         */
                    1, /*   3 TS_NEG_MEMBLT_INDEX          memoryBltSupport         */
                    1, /*   4 TS_NEG_MEM3BLT_INDEX         memoryThreeWayBltSupport */
                    0, /* x 5 TS_NEG_ATEXTOUT_INDEX        textASupport             */
                    0, /* x 6 TS_NEG_AEXTTEXTOUT_INDEX     extendedTextASupport     */
#ifdef DRAW_NINEGRID
                    1, /*   7 TS_NEG_RECTANGLE_INDEX       rectangleSupport         */
#else
                    0,
#endif
                    1, /*   8 TS_NEG_LINETO_INDEX          lineSupport              */
#ifdef DRAW_NINEGRID
                    1, /*   9 TS_NEG_FASTFRAME_INDEX       frameSupport             */
#else
                    0,
#endif
                    0, /*  10 TS_NEG_OPAQUERECT_INDEX      opaqueRectangleSupport   */
                    1, /* x11 TS_NEG_SAVEBITMAP_INDEX      desktopSaveSupport       */
                    0, /* x12 TS_NEG_WTEXTOUT_INDEX        textWSupport             */
                    1, /*  13 TS_NEG_MEMBLT_R2_INDEX       Reserved entry           */
                    1, /*  14 TS_NEG_MEM3BLT_R2_INDEX      Reserved entry           */
                    1, /*  15 TS_NEG_MULTIDSTBLT_INDEX     multi DstBlt support     */
                    1, /*  16 TS_NEG_MULTIPATBLT_INDEX     multi PatBlt support     */
                    1, /*  17 TS_NEG_MULTISCRBLT_INDEX     multi ScrBlt support     */
                    1, /*  18 TS_NEG_MULTIOPAQUERECT_INDEX multi OpaqueRect support */
                    1, /*  19 TS_NEG_FAST_INDEX                                     */
                    1, /*  20 TS_NEG_POLYGON_SC_INDEX                               */
                    1, /*  21 TS_NEG_POLYGON_CB_INDEX                               */
                    1, /*  22 TS_NEG_POLYLINE_INDEX        polyLineSupport          */
                    0, /*  23                              MS reserved entry 2      */
                    1, /*  24 TS_NEG_FAST_GLYPH_INDEX                               */
                    1, /*  25 TS_NEG_ELLIPSE_SC_INDEX                               */
                    1, /*  26 TS_NEG_ELLIPSE_CB_INDEX                               */
                    0, /*  27                              MS reserved entry 6      */
                    0, /* x28 TS_NEG_WEXTTEXTOUT_INDEX     extendedTextWSupport     */
                    0, /* x29 TS_NEG_WLONGTEXTOUT_INDEX    longTextWSupport         */
                    0, /* x30 TS_NEG_WLONGEXTTEXTOUT_INDEX longExtendedTextWSupport */
                    0, /*  31                              DCL reserved entry 3     */
                },
                (TS_TEXT_AND_MASK)|(TS_TEXT_OR_MASK), /* textFlags          */
                0,                                    /* pad2               */
                0,                                    /* pad4               */
                480 * 480,                            /* desktopSaveSize    */
                0,                                    /* pad2               */
                0,                                    /* pad2               */
                0,                                    /* textANSICodePage   */
                0                                     /* pad2               */
            },

            /****************************************************************/
            /* BitmapCache Caps Note that this same space is used for rev1  */
            /* and rev2, we declare as rev1 because it is the larger of the */
            /* two.  We will cast to rev2 if we get a server advertisement  */
            /* that it supports rev2 (via                                   */
            /* TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT).                   */
            /****************************************************************/
            {
                TS_CAPSETTYPE_BITMAPCACHE_REV2,        /* capabilitySetType */
                sizeof(TS_BITMAPCACHE_CAPABILITYSET),  /* lengthCapability  */
                0,                                     /* pad DWORDs 1      */
                0,                                     /* pad DWORDs 2      */
                0,                                     /* pad DWORDs 3      */
                0,                                     /* pad DWORDs 4      */
                0,                                     /* pad DWORDs 5      */
                0,                                     /* pad DWORDs 6      */
                0, 0,                                  /* Cache1            */
                0, 0,                                  /* Cache2            */
                0, 0,                                  /* Cache3            */
            },

            /****************************************************************/
            /* ColorTableCache Caps                                         */
            /****************************************************************/
            {
                TS_CAPSETTYPE_COLORCACHE,                 /* capabilitySetType   */
                sizeof(TS_COLORTABLECACHE_CAPABILITYSET), /* lengthCapability    */
                6,                                        /* colortableCacheSize */
                0                                         /* notpartOfTSharePad  */
            },

            /****************************************************************/
            /* WindowActivation Caps                                        */
            /****************************************************************/
            {
                TS_CAPSETTYPE_ACTIVATION,                   /* capabilitySetType    */
                sizeof(TS_WINDOWACTIVATION_CAPABILITYSET),  /* lengthCapability     */
                FALSE,                                      /* helpKeyFlag          */
                FALSE,                                      /* helpKeyIndexFlag     */
                FALSE,                                      /* helpExtendedKeyFlag  */
                FALSE                                       /* windowManagerKeyFlag */
            },

            /****************************************************************/
            /* Control Caps                                                 */
            /****************************************************************/
            {
                TS_CAPSETTYPE_CONTROL,                 /* capabilitySetType */
                sizeof(TS_CONTROL_CAPABILITYSET),      /* lengthCapability  */
                0,                                     /* controlFlags      */
                FALSE,                                 /* remoteDetachFlag  */
                TS_CONTROLPRIORITY_NEVER,              /* controlInterest   */
                TS_CONTROLPRIORITY_NEVER               /* detachInterest    */
            },

            /****************************************************************/
            /* Pointer Caps                                                 */
            /****************************************************************/
            {
                TS_CAPSETTYPE_POINTER,             /* capabilitySetType     */
                sizeof(TS_POINTER_CAPABILITYSET),  /* lengthCapability      */
                TRUE,                              /* colorPointerFlag      */
                20,                                /* colorPointerCacheSize */
                21                                 /* pointerCacheSize      */
            },

            /****************************************************************/
            /* Share Caps                                                   */
            /****************************************************************/
            {
                TS_CAPSETTYPE_SHARE,                   /* capabilitySetType */
                sizeof(TS_SHARE_CAPABILITYSET),        /* lengthCapability  */
                0,                                     /* nodeId            */
                0                                      /* padding           */
            },

            /****************************************************************/
            /* Input Caps                                                   */
            /****************************************************************/
            {
                TS_CAPSETTYPE_INPUT,
                sizeof(TS_INPUT_CAPABILITYSET),         /* lengthCapability */
                TS_INPUT_FLAG_SCANCODES
                    | TS_INPUT_FLAG_MOUSEX,             /* inputFlags       */
                TS_INPUT_FLAG_FASTPATH_INPUT2,          /* padding          */
                0                                       /* keyboard layout  */
            },

            /****************************************************************/
            /* Sound                                                        */
            /****************************************************************/
            {
                TS_CAPSETTYPE_SOUND,
                sizeof(TS_SOUND_CAPABILITYSET),         /* lengthCapability */
                TS_SOUND_FLAG_BEEPS,                    /* soundFlags       */
                0,                                      /* padding          */
            },

            /****************************************************************/
            /* Font                                                         */
            /****************************************************************/
            {
                TS_CAPSETTYPE_FONT,
                sizeof(TS_FONT_CAPABILITYSET),          /* lengthCapability */
                TS_FONTSUPPORT_FONTLIST,                /* fontSupportFlags */
                0,                                      /* padding          */
            },

            /****************************************************************/
            /* GlyphCache Caps                                              */
            /****************************************************************/
            {
                TS_CAPSETTYPE_GLYPHCACHE,              /* capabilitySetType */
                sizeof(TS_GLYPHCACHE_CAPABILITYSET),   /* lengthCapability  */
                {                                      /* GlyphCache        */
                    { 254,    4 },
                    { 254,    4 },
                    { 254,    8 },
                    { 254,    8 },
                    { 254,   16 },
                    { 254,   32 },
                    { 254,   64 },
                    { 254,  128 },
                    { 254,  256 },
                    { 254, 2048 }
                },
                { 256, 256 },                          /* FragCache         */
                2,                                     /* GlyphSupportLevel */
            },

            /****************************************************************/
            /* Brush Caps                                                   */
            /****************************************************************/
            {
                TS_CAPSETTYPE_BRUSH,                   /* capabilitySetType */
                sizeof(TS_BRUSH_CAPABILITYSET),        /* lengthCapability  */
                1,  /* TS_BRUSH_COLOR8x8 */            /* brushSupportLevel */
            },

            // Enable this capability when GDI supports Device Bitmaps in mirroring
            // display drivers.

            /************************************************************************/
            /* Offscreen Caps                                                       */
            /************************************************************************/
            {
                TS_CAPSETTYPE_OFFSCREENCACHE,             /* capabilitySetType      */
                sizeof(TS_OFFSCREEN_CAPABILITYSET),       /* lengthCapability       */
                TS_OFFSCREEN_SUPPORTED,                   /* offscreenSupportLevel  */
                TS_OFFSCREEN_CACHE_SIZE_SERVER_DEFAULT,   /* offscreenCacheSize     */
                TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT,       /* offscreenCacheEntries  */
            },

            /************************************************************************/
            /* Virtual Channel Caps                                                 */
            /************************************************************************/
            {
                TS_CAPSETTYPE_VIRTUALCHANNEL,             /* capabilitySetType      */
                sizeof(TS_VIRTUALCHANNEL_CAPABILITYSET),  /* lengthCapability       */
                //
                // What this particular cap means is that the client understands
                // virtual channels compressed from the server at 64K.
                //
                // The client recevies what compression cap the server supports
                // from the client and compresses appropriately
                //
                TS_VCCAPS_COMPRESSION_64K,//TS_VCCAPS_DEFAULT?/* vc support flags       */

#ifdef DRAW_NINEGRID
            },

            {
                TS_CAPSETTYPE_DRAWNINEGRIDCACHE,          // capabilitySetType      
                sizeof(TS_DRAW_NINEGRID_CAPABILITYSET),   // lengthCapability       
                TS_DRAW_NINEGRID_SUPPORTED_REV2,          // drawNineGridSupportLevel  
                TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT,      // drawNineGridCacheSize     
                TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT,   // drawNineGridCacheEntries  
#endif
#ifdef DRAW_GDIPLUS            
            },
            {
                TS_CAPSETTYPE_DRAWGDIPLUS,                          // capabilitySetType      
                sizeof(TS_DRAW_GDIPLUS_CAPABILITYSET),              // lengthCapability       
                TS_DRAW_GDIPLUS_SUPPORTED,                          // drawEscapeSupportLevel  
                0xFFFFFFFF,                                         // TSGdiplusVersion
                TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE,                    // drawGdiplusCacheLevel
                TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT,
                TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT,
                TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT,
                TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT,
                TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT,
                TS_GDIP_GRAPHICS_CACHE_CHUNK_SIZE_DEFAULT,
                TS_GDIP_BRUSH_CACHE_CHUNK_SIZE_DEFAULT,
                TS_GDIP_PEN_CACHE_CHUNK_SIZE_DEFAULT,
                TS_GDIP_IMAGEATTRIBUTES_CACHE_CHUNK_SIZE_DEFAULT,
                TS_GDIP_IMAGE_CACHE_CHUNK_SIZE_DEFAULT,             // Chunk size to store image cache
                TS_GDIP_IMAGE_CACHE_TOTAL_SIZE_DEFAULT,             // Total size of image cache in number of chunks
                TS_GDIP_IMAGE_CACHE_MAX_SIZE_DEFAULT,               // Maximun size of image to cache, in number of chunks
#endif
            }
        };

        /********************************************************************/
        /* set up bitmap cache caps                                         */
        /********************************************************************/
        {
            TS_BITMAPCACHE_CAPABILITYSET_REV2 *pRev2Caps;

            // Rev2 caps.
            pRev2Caps = (TS_BITMAPCACHE_CAPABILITYSET_REV2 *)&caps.bitmapCacheCaps;

            TRC_ALT((TB,"Preparing REV2 caps for server\n"));

            pRev2Caps->capabilitySetType = TS_CAPSETTYPE_BITMAPCACHE_REV2;
            pRev2Caps->NumCellCaches     = 3;
            pRev2Caps->bPersistentKeysExpected = FALSE;
            pRev2Caps->bAllowCacheWaitingList = FALSE;

            pRev2Caps->CellCacheInfo[0].bSendBitmapKeys = FALSE;
            pRev2Caps->CellCacheInfo[0].NumEntries      = 600;
            pRev2Caps->CellCacheInfo[1].bSendBitmapKeys = FALSE;
            pRev2Caps->CellCacheInfo[1].NumEntries      = 300;
            pRev2Caps->CellCacheInfo[2].bSendBitmapKeys = FALSE;
            pRev2Caps->CellCacheInfo[2].NumEntries      = 300;
            pRev2Caps->CellCacheInfo[3].bSendBitmapKeys = 0;
            pRev2Caps->CellCacheInfo[3].NumEntries      = 0;
            pRev2Caps->CellCacheInfo[4].bSendBitmapKeys = 0;
            pRev2Caps->CellCacheInfo[4].NumEntries      = 0;
        }

        /********************************************************************/
        /* and screen size                                                  */
        /********************************************************************/
        {
            PTS_BITMAP_CAPABILITYSET pBmpCaps;

            pBmpCaps = (TS_BITMAP_CAPABILITYSET *)&caps.bitmapCapabilitySet;

            pBmpCaps->desktopWidth  = (TSUINT16)(m_pTSWd->desktopWidth);
            pBmpCaps->desktopHeight = (TSUINT16)(m_pTSWd->desktopHeight);

#ifdef DC_HICOLOR
            pBmpCaps->preferredBitsPerPixel = (TSUINT16)(m_pTSWd->desktopBpp);
#endif
        }

        if (!SCCallPartyJoiningShare(localPersonID,
                                     sizeof(caps),
                                     &caps,
                                     acceptedArray,
                                     scNumberInShare))
        {
            /****************************************************************/
            /* Some component rejected the remote party                     */
            /****************************************************************/
            TRC_ERR((TB, "Remote party rejected"));
            DC_QUIT;
        }

        /********************************************************************/
        /* The remote party is now in the share.                            */
        /********************************************************************/
        callingPJS = FALSE;
        rc = TRUE;
        scNumberInShare++;
        TRC_NRM((TB, "Number in share %d", (unsigned)scNumberInShare));

        /********************************************************************/
        /* Synchronise only for primary stacks.  Shadow stacks will be      */
        /* sync'd by the DD right before output starts.                     */
        /********************************************************************/
        SCInitiateSync(m_pTSWd->StackClass == Stack_Shadow);

        /********************************************************************/
        /* don't wait for a response - there isn't a client out there.      */
        /* Just wake up the WD now                                          */
        /********************************************************************/
        TRC_NRM((TB, "Wake up WDW"));
        WDW_ShareCreated(m_pTSWd, TRUE);

        DC_QUIT;

    }

    /************************************************************************/
    /* Get the combined capabilities                                        */
    /************************************************************************/
    CPC_GetCombinedCapabilities(SC_LOCAL_PERSON_ID, &capsSize, &caps);

    /************************************************************************/
    /* If we support dynamic client resizing, then we need to update the    */
    /* desktop width and height in the caps passed out on the demand active */
    /* PDU to notify the client of the change                               */
    /************************************************************************/
    pBitmapCaps = (PTS_BITMAP_CAPABILITYSET) WDW_GetCapSet(
                  m_pTSWd, TS_CAPSETTYPE_BITMAP, caps, capsSize);
    if (pBitmapCaps)
    {
        if (pBitmapCaps->desktopResizeFlag == TS_CAPSFLAG_SUPPORTED)
        {
            TRC_ALT((TB, "Update client desktop size"));
            pBitmapCaps->desktopHeight = (TSUINT16)(m_pTSWd->desktopHeight);
            pBitmapCaps->desktopWidth  = (TSUINT16)(m_pTSWd->desktopWidth);
        }
#ifdef DC_HICOLOR
        /********************************************************************/
        /* For high color, update the color depth too                       */
        /********************************************************************/
        pBitmapCaps->preferredBitsPerPixel = (TSUINT16)(m_pTSWd->desktopBpp);
#endif
    }

    /************************************************************************/
    /* Get the sessionId from the WD structure                              */
    /************************************************************************/
    sessionId = m_pTSWd->sessionId;

    /************************************************************************/
    /* Calculate the size of the various bits of the TS_DEMAND_ACTIVE_PDU   */
    /************************************************************************/
    pktLen = sizeof(TS_DEMAND_ACTIVE_PDU) - 1 + sizeof(UINT32);
    nameLen = strlen(scPartyArray[0].name);
    nameLen = (unsigned)DC_ROUND_UP_4(nameLen);
    pktLen += nameLen;
    pktLen += capsSize;

    /************************************************************************/
    // Get a buffer - this should not fail, so abort if it does
    // fWait is TRUE means that we will always wait for a buffer to be avail
    /************************************************************************/
    status = SM_AllocBuffer(scPSMHandle, (PPVOID)(&pPkt), pktLen, TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        // Calculate a new shareID.
        scGeneration++;
        scShareID = scUserID | (((UINT32)(scGeneration & 0xFFFF)) << 16);

        // Fill in the packet fields.
        pPkt->shareControlHeader.totalLength = (UINT16)pktLen;
        pPkt->shareControlHeader.pduType = TS_PDUTYPE_DEMANDACTIVEPDU |
                                          TS_PROTOCOL_VERSION;
        pPkt->shareControlHeader.pduSource = (UINT16)scUserID;
        pPkt->shareID = scShareID;
        pPkt->lengthSourceDescriptor = (UINT16)nameLen;
        pPkt->lengthCombinedCapabilities = (UINT16)capsSize;
        memcpy(&(pPkt->data[0]), scPartyArray[0].name, nameLen);
        memcpy(&(pPkt->data[nameLen]), caps, capsSize);
        memcpy(&(pPkt->data[nameLen+capsSize]),
               &sessionId,
               sizeof(sessionId));

        // Send it.
        rc = SM_SendData(scPSMHandle, pPkt, pktLen, TS_HIGHPRIORITY, 0,
                FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (rc) {
            TRC_ALT((TB, "%s Stack sent TS_DEMAND_ACTIVE_PDU",
                     m_pTSWd->StackClass == Stack_Primary ? "Primary" :
                    (m_pTSWd->StackClass == Stack_Shadow  ? "Shadow" :
                    "PassThru")));
        }
        else {
            TRC_ERR((TB, "Failed to send TS_DEMAND_ACTIVE_PDU"));
        }

    }
    else {
        TRC_ERR((TB, "Failed to alloc %d bytes for TS_DEMAND_ACTIVE_PDU",
                pktLen));
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Change SC state.                                                     */
    /************************************************************************/
    SC_SET_STATE(SCS_SHARE_STARTING)

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* SC_SendServerCert                                                        */
/*                                                                          */
/* Sends the target server's random + certificate to a client server for    */
/* use in shadowing.                                                        */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS SC_SendServerCert(PSHADOWCERT pCert, ULONG ulLength)
{
    PTS_SERVER_CERTIFICATE_PDU pPkt;
    ULONG                      ulPktSize;
    NTSTATUS                   status;
    BOOL                       rc;

    DC_BEGIN_FN("SC_SendServerCert");

    ulPktSize = sizeof(TS_SERVER_CERTIFICATE_PDU) - 1 +
                       pCert->shadowRandomLen + pCert->shadowCertLen;

    TRC_ERR((TB, "handle: %p, &pPkt: %p, size: %ld",
             m_pTSWd->pSmInfo, &pPkt, ulPktSize));

    status = SM_AllocBuffer(m_pTSWd->pSmInfo, (PPVOID) &pPkt, ulPktSize, TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        // Fill in the packet fields.
        pPkt->shareControlHeader.totalLength = (UINT16) ulPktSize;
        pPkt->shareControlHeader.pduType = TS_PDUTYPE_SERVERCERTIFICATEPDU |
                                           TS_PROTOCOL_VERSION;
        pPkt->shareControlHeader.pduSource = (UINT16) scUserID;

        pPkt->encryptionMethod = pCert->encryptionMethod;
        pPkt->encryptionLevel = pCert->encryptionLevel;
        pPkt->shadowRandomLen = pCert->shadowRandomLen;
        pPkt->shadowCertLen = pCert->shadowCertLen;

        // Copy over the random + cert
        if (pPkt->encryptionLevel != 0) {
            memcpy(pPkt->data, pCert->data,
                   pCert->shadowRandomLen + pCert->shadowCertLen);
        }

        // Send ServerCertificatePDU
        rc = SM_SendData(m_pTSWd->pSmInfo, pPkt, ulPktSize, TS_HIGHPRIORITY,
                0, FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (rc) {
            status = STATUS_SUCCESS;
            TRC_ALT((TB, "Sent TS_SERVER_CERTIFICATE_PDU: %ld", ulPktSize));
        }
        else {
            status = STATUS_UNEXPECTED_IO_ERROR;
            TRC_ERR((TB, "Failed to send TS_SERVER_CERTIFICATE_PDU"));
        }
    }
    else {
        status = STATUS_NO_MEMORY;
        TRC_ERR((TB, "Failed to alloc %d bytes for TS_SERVER_CERTIFICATE_PDU",
                ulPktSize));
    }

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* SC_SaveServerCert                                                        */
/*                                                                          */
/* Save the server certificate + random for subsequent validation by rdpwsx.*/
/* A NULL pPkt indicates we should save an empty certificate.               */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_SaveServerCert(PTS_SERVER_CERTIFICATE_PDU pPkt,
                                       ULONG                      ulLength)
{
    PSHADOWCERT pCert;
    ULONG       ulCertLen;

    DC_BEGIN_FN("SC_SaveServerCert");

    // Save off the data and signal rdpwsx that we got it.  We will actually
    // perform the validation in user mode.
    if (pPkt != NULL) {
  
        ulCertLen = pPkt->shadowRandomLen + pPkt->shadowCertLen;
        pCert = (PSHADOWCERT) COM_Malloc(sizeof(SHADOWCERT) + ulCertLen - 1);

        if (pCert != NULL) {
            pCert->encryptionMethod = pPkt->encryptionMethod;
            pCert->encryptionLevel = pPkt->encryptionLevel;
            pCert->shadowRandomLen = pPkt->shadowRandomLen;
            pCert->shadowCertLen = pPkt->shadowCertLen;

            // If the encryption level is non-zero, then we should have a server random
            // and certificate following the initial header
            if (pCert->encryptionLevel != 0) {
                memcpy(pCert->data, pPkt->data, ulCertLen);
            }

            TRC_ALT((TB, "Received certificate[%ld], level=%ld, method=%lx, random[%ld]",
                     pCert->shadowCertLen,
                     pCert->encryptionLevel,
                     pCert->encryptionMethod,
                     pCert->shadowRandomLen));

            // Update SM parameters with negotiated values
            SM_SetEncryptionParams(m_pTSWd->pSmInfo, pCert->encryptionLevel,
                                   pCert->encryptionMethod);
        }
        else {
            TRC_ERR((TB, "Could not allocate space for server cert: %ld!",
                     ulCertLen));
        }
    }

    // Else, the target server did not send back a certificate (B3)
    else {
        pCert = (PSHADOWCERT) COM_Malloc(sizeof(SHADOWCERT));

        if (pCert != NULL) {
            memset(pCert, 0, sizeof(SHADOWCERT));
        }
        else {
            TRC_ERR((TB, "Could not allocate space for server cert: %ld!",
                     sizeof(SHADOWCERT)));
        }
    }

    // wake up the rdpwsx thread which is waiting on this information
    m_pTSWd->pShadowCert = pCert;
    KeSetEvent(m_pTSWd->pSecEvent, 0, FALSE);

    DC_END_FN();
    return TRUE;
} /* SC_SaveServerCert */


/****************************************************************************/
/* SC_SendClientRandom                                                      */
/*                                                                          */
/* Send the encrypted client random to the shadow target server.            */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS SC_SendClientRandom(PBYTE pClientRandom,
                                             ULONG ulLength)
{
    PTS_CLIENT_RANDOM_PDU pPkt;
    ULONG                 ulPktSize;
    NTSTATUS              status;
    BOOL                  rc;

    DC_BEGIN_FN("SC_SendClientRandom");

    ulPktSize = sizeof(TS_CLIENT_RANDOM_PDU) - 1 + ulLength;

    status =  NM_AllocBuffer(m_pTSWd->pNMInfo,
                         (PPVOID) &pPkt, ulPktSize, TRUE);
    if (STATUS_SUCCESS == status) {
        // Fill in the packet fields.
        pPkt->shareControlHeader.totalLength = (UINT16) ulPktSize;
        pPkt->shareControlHeader.pduType = TS_PDUTYPE_CLIENTRANDOMPDU |
                                           TS_PROTOCOL_VERSION;
        pPkt->shareControlHeader.pduSource = (UINT16)scUserID;
        pPkt->clientRandomLen = ulLength;

        // Copy over the random
        TRC_ALT((TB, "PDUType: %lx, random length: %ld, pktSize: %ld",
                 pPkt->shareControlHeader.pduType, ulLength, ulPktSize));
        memcpy(pPkt->data, pClientRandom, ulLength);

        TRC_DATA_DBG("snd random: ", pClientRandom, ulLength);

        rc = NM_SendData(m_pTSWd->pNMInfo, 
                         (PBYTE) pPkt, ulPktSize, TS_HIGHPRIORITY, 0, FALSE);
        
        if (rc) {
            status = STATUS_SUCCESS;
            TRC_ALT((TB, "Sent TS_CLIENT_RANDOM_PDU: %ld", ulPktSize));
        }
        else {
            status = STATUS_UNEXPECTED_IO_ERROR;
            TRC_ERR((TB, "Failed to send TS_CLIENT_RANDOM_PDU"));
        }
    }
    else {
        status = STATUS_NO_MEMORY;
        TRC_ERR((TB, "Failed to alloc %d bytes for TS_CLIENT_RANDOM_PDU",
                ulPktSize));
    }

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* SC_SaveClientRandom                                                      */
/*                                                                          */
/* Save the encrypted client random for subsequent use by rdpwsx.           */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_SaveClientRandom(PTS_CLIENT_RANDOM_PDU pPkt,
                                         ULONG                 ulLength)
{
    PCLIENTRANDOM pClientRandom;
    BOOL          rc = FALSE;


    DC_BEGIN_FN("SC_SaveClientRandom");

    //Validate data length
    if ((ulLength < sizeof(TS_CLIENT_RANDOM_PDU)) ||
         (ulLength + sizeof(TSUINT8) - sizeof(TS_CLIENT_RANDOM_PDU)) < pPkt->clientRandomLen) {
        TRC_ERR((TB, "Bad client random length: %ld", pPkt->clientRandomLen));
        return FALSE;
    }

    // The largest possible client random size is 512, 
    // defined in SendClientRandom() in tsrvsec.c
    if (pPkt->clientRandomLen > CLIENT_RANDOM_MAX_SIZE) {
        TRC_ERR((TB, "Client random length is too large: %ld", pPkt->clientRandomLen));
        return FALSE;
    }
    
    // Save off the data and signal rdpwsx that we got it.  We will actually
    // perform the decryption in user mode.
    pClientRandom = (PCLIENTRANDOM) COM_Malloc(sizeof(CLIENTRANDOM) - 1 +
                                               pPkt->clientRandomLen);

    if (pClientRandom != NULL) {
        pClientRandom->clientRandomLen = pPkt->clientRandomLen;
        memcpy(pClientRandom->data, pPkt->data, pPkt->clientRandomLen);

        TRC_ALT((TB, "Received encrypted client random: @%p, len=%ld",
                 pClientRandom, pPkt->clientRandomLen));
        TRC_DATA_DBG("sav random: ", pClientRandom->data,
                     pClientRandom->clientRandomLen);
    }
    else {
        TRC_ERR((TB, "Could not allocate space for client random: %ld!",
                 pPkt->clientRandomLen));
    }

    // Free pShadowRandom in case it was allocated before
    if (NULL != m_pTSWd->pShadowRandom) {
        COM_Free(m_pTSWd->pShadowRandom);
        m_pTSWd->pShadowRandom = NULL;
    }

    // wake up the termsrv thread which is waiting on this information
    m_pTSWd->pShadowRandom = pClientRandom;
    KeSetEvent (m_pTSWd->pSecEvent, 0, FALSE);

    DC_END_FN();
    return TRUE;
}


/****************************************************************************/
/* SC_GetSecurityData                                                       */
/*                                                                          */
/* Wait for either a server certificate or a client random and return the   */
/* data to rdpwsx.                                                          */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS SC_GetSecurityData(PSD_IOCTL pSdIoctl)
{
    PSECURITYTIMEOUT pSecurityTimeout = (PSECURITYTIMEOUT) pSdIoctl->InputBuffer;
    ULONG            ulBytesNeeded = 0;
    NTSTATUS         status;

    DC_BEGIN_FN("SC_GetSecurityData");

    // Wait for the connected indication from SC (if necessary)
    if (((pSdIoctl->IoControlCode == IOCTL_TSHARE_GET_CERT_DATA) &&
         (pSdIoctl->OutputBufferLength == 0)) ||
        (pSdIoctl->IoControlCode == IOCTL_TSHARE_GET_CLIENT_RANDOM)) {

        TRC_ALT((TB, "About to wait for %s data",
                 pSdIoctl->IoControlCode == IOCTL_TSHARE_GET_CERT_DATA ?
                 "Server Certificate" : "Client Random"));

        if (pSdIoctl->InputBufferLength == sizeof(SECURITYTIMEOUT)) {
            status = WDW_WaitForConnectionEvent(m_pTSWd, m_pTSWd->pSecEvent,
                    pSecurityTimeout->ulTimeout);
        }
        else {
            status = STATUS_INVALID_PARAMETER;
            TRC_ERR((TB, "Bogus timeout value structure: Length [%ld] != Expected [%ld]", 
                     pSdIoctl->InputBufferLength, sizeof(SECURITYTIMEOUT)));
            DC_QUIT;
        }

        TRC_ALT((TB, "Back from wait for security data"));

        if (status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Error waiting for security data: %lx, msec=%ld",
                     status, pSecurityTimeout->ulTimeout));

            if (!NT_ERROR(status)) {
                status = STATUS_IO_TIMEOUT;
            }
            DC_QUIT;
        }
    }

    // Server certificate + random
    if (pSdIoctl->IoControlCode == IOCTL_TSHARE_GET_CERT_DATA) {
        if (m_pTSWd->pShadowCert != NULL) {
            ULONG ulCertLength = m_pTSWd->pShadowCert->shadowCertLen +
                                 m_pTSWd->pShadowCert->shadowRandomLen;

            ulBytesNeeded = sizeof(SHADOWCERT) - 1 + ulCertLength;

            // Return the length so rdpwsx can alloc the right amount of memory.
            if ((pSdIoctl->OutputBuffer == NULL) ||
                (pSdIoctl->OutputBufferLength < ulBytesNeeded)) {

                TRC_ALT((TB, "Cert[%ld] + Rand[%ld] buffer too small: %ld < %ld",
                         m_pTSWd->pShadowCert->shadowCertLen,
                         m_pTSWd->pShadowCert->shadowRandomLen,
                         pSdIoctl->OutputBufferLength, ulBytesNeeded));
                status = STATUS_BUFFER_TOO_SMALL;
            }
            // else, return the data to rdpwsx
            else {
                PSHADOWCERT  pShadowCertOut = (PSHADOWCERT) pSdIoctl->OutputBuffer;
                PSHADOWCERT  pShadowCertIn  = m_pTSWd->pShadowCert;

                pShadowCertOut->encryptionMethod = pShadowCertIn->encryptionMethod;
                pShadowCertOut->encryptionLevel = pShadowCertIn->encryptionLevel;
                pShadowCertOut->shadowRandomLen = pShadowCertIn->shadowRandomLen;
                pShadowCertOut->shadowCertLen = pShadowCertIn->shadowCertLen;
                memcpy(pShadowCertOut->data, pShadowCertIn->data, ulCertLength);

                // Free up the temporary buffer
                COM_Free(m_pTSWd->pShadowCert);
                m_pTSWd->pShadowCert = NULL;
                status = STATUS_SUCCESS;
            }
        }

        // We were unable to save the certificate!
        else {
            TRC_ERR((TB, "Saved certificate not found!"));
            status = STATUS_NO_MEMORY;
        }
    }

    // Encrypted client random
    else if (pSdIoctl->IoControlCode == IOCTL_TSHARE_GET_CLIENT_RANDOM) {
        if (m_pTSWd->pShadowRandom != NULL) {
            ulBytesNeeded = m_pTSWd->pShadowRandom->clientRandomLen;

            // Return the length so rdpwsx can alloc the right amount of memory.
            if ((pSdIoctl->OutputBuffer == NULL) ||
                (pSdIoctl->OutputBufferLength < ulBytesNeeded)) {
                status = STATUS_BUFFER_TOO_SMALL;
                TRC_ALT((TB, "Client random buffer too small: %ld < %ld",
                         pSdIoctl->OutputBufferLength, ulBytesNeeded));
            }
            // else, return the data to rdpwsx
            else {
                PCLIENTRANDOM pRandomIn  = m_pTSWd->pShadowRandom;
                PBYTE         pRandomOut = (PBYTE) pSdIoctl->OutputBuffer;

                TRC_ALT((TB, "Received client random: @%p, len=%ld",
                         pRandomIn, ulBytesNeeded));

                memcpy(pRandomOut, pRandomIn->data, ulBytesNeeded);

                TRC_DATA_DBG("rcv random: ", pRandomOut, ulBytesNeeded);

                // Free up the temporary buffer
                COM_Free(m_pTSWd->pShadowRandom);
                m_pTSWd->pShadowRandom = NULL;
                status = STATUS_SUCCESS;
            }
        }

        // We were unable to save the encrypted random!
        else {
            TRC_ERR((TB, "Saved encrypted random not found!"));
            status = STATUS_NO_MEMORY;
        }
    }

    else {
        TRC_ERR((TB, "Unrecognized ioctl: %lx", pSdIoctl->IoControlCode));
        status = STATUS_INVALID_PARAMETER;
    }

DC_EXIT_POINT:

    pSdIoctl->BytesReturned = ulBytesNeeded;
    DC_END_FN();

    return status;
}


/****************************************************************************/
/* Name:      SC_ShadowSyncShares                                           */
/*                                                                          */
/* See ascapi.h                                                             */
/****************************************************************************/
#ifdef DC_HICOLOR
BOOL RDPCALL SHCLASS SC_ShadowSyncShares(PTS_COMBINED_CAPABILITIES pCaps,
                                         ULONG capsLen)
#else
BOOL RDPCALL SHCLASS SC_ShadowSyncShares(void)
#endif
{
    BOOL       rc = TRUE;
    ShareClass *dcShare = (ShareClass *)m_pTSWd->dcShare;

    DC_BEGIN_FN("SC_SyncShare");

    TRC_ASSERT((dcShare != NULL), (TB, "NULL Share Class"));

#ifdef DC_HICOLOR
    /************************************************************************/
    /* if we're the primary or console, update the caps with those supplied */
    /* for the shadower.  It can only "lower" the capabilities, so there's  */
    /* no problem with setting up caps the target can't cope with           */
    /************************************************************************/
    if ((m_pTSWd->StackClass == Stack_Primary) ||
        (m_pTSWd->StackClass == Stack_Console))
    {
        BOOL acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
        TRC_ALT((TB, "Update caps for shadower"));

        // Free the memory
        if (cpcRemoteCombinedCaps[SC_SHADOW_PERSON_ID - 1] != NULL) {
            COM_Free((PVOID)cpcRemoteCombinedCaps[SC_SHADOW_PERSON_ID - 1]);
            cpcRemoteCombinedCaps[SC_SHADOW_PERSON_ID - 1] = NULL;
        }

        SCCallPartyJoiningShare(SC_SHADOW_PERSON_ID,
                                capsLen,
                                pCaps,
                                acceptedArray,
                                scNumberInShare);

        /********************************************************************/
        /* Now update the DD caps via the shared mem                        */
        /********************************************************************/
        DCS_TriggerUpdateShmCallback();
    }
#endif

    SCInitiateSync(TRUE);
    TRC_ALT((TB, "Synchronized Shares"));

    DC_END_FN();
    return(rc);
} /* SC_ShadowSyncShares */


/****************************************************************************/
/* Name:      SC_EndShare                                                   */
/*                                                                          */
/* Ends a share                                                             */
/****************************************************************************/
void RDPCALL SHCLASS SC_EndShare(BOOLEAN bForce)
{
    PTS_DEACTIVATE_ALL_PDU pPkt;
    NTSTATUS               status;
    BOOL                   rc;

    DC_BEGIN_FN("SC_EndShare");

    // Due to the way a shadow hotkey terminates a session, we sometimes need
    // to force sending of a deactivate all PDU.  This is done explicitly
    // instead of changing the state table so we don't effect normal connect
    // processing.
    if (!bForce) {
        SC_CHECK_STATE(SCE_END_SHARE);
    }
    else {
        TRC_ALT((TB, "Forcing deactivate all PDU"));
    }

    /************************************************************************/
    // Get a buffer - this should not fail, so abort if it does
    // fWait is TRUE means that we will always wait for a buffer to be avail
    /************************************************************************/
    status = SM_AllocBuffer(scPSMHandle, (PPVOID)(&pPkt),
            sizeof(TS_DEACTIVATE_ALL_PDU), TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        // Fill in the packet fields.
        pPkt->shareControlHeader.totalLength = sizeof(TS_DEACTIVATE_ALL_PDU);
        pPkt->shareControlHeader.pduType = TS_PDUTYPE_DEACTIVATEALLPDU |
                                           TS_PROTOCOL_VERSION;
        pPkt->shareControlHeader.pduSource = (UINT16)scUserID;
        pPkt->shareID = scShareID;
        pPkt->lengthSourceDescriptor = 1;
        pPkt->sourceDescriptor[0] = 0;

        // Send DeactivateAllPDU.
        rc = SM_SendData(scPSMHandle, pPkt, sizeof(TS_DEACTIVATE_ALL_PDU),
                TS_HIGHPRIORITY, 0, FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (rc) {
            TRC_ALT((TB, "Sent DeactivateAllPDU"));
            SCEndShare();
        }
        else {
            TRC_ERR((TB, "Failed to send TS_DEACTIVATE_ALL_PDU"));
        }
    }
    else {
        TRC_ERR((TB, "Failed to alloc %d bytes for TS_DEACTIVATE_ALL_PDU",
                sizeof(PTS_DEACTIVATE_ALL_PDU)));
    }

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
// SC_OnDisconnected
//
// Handles disconnection notification.
/****************************************************************************/
void RDPCALL SHCLASS SC_OnDisconnected(UINT32 userID)
{
    DC_BEGIN_FN("SC_OnDisconnected");

    if (scNumberInShare != 0) {
        SC_CHECK_STATE(SCE_DETACH_USER);
        TRC_NRM((TB, "User %u detached", userID));

        // Do the real work...
        SCEndShare();
    }
    else {
        TRC_NRM((TB, "Share already ended: nothing more to do"));
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* SC_OnDisconnected */


/****************************************************************************/
/* Name:      SC_OnDataReceived                                             */
/*                                                                          */
/* Purpose:   Callback from SM for data receive path.                       */
/*                                                                          */
/* Params:    netPersonID - MCS UserID of the data sender                   */
/*            priority    - MCS data priority the data was sent on          */
/*            pPkt        - pointer to start of packet                      */
/****************************************************************************/
void RDPCALL ShareClass::SC_OnDataReceived(
        PBYTE       pPkt,
        NETPERSONID netPersonID,
        unsigned    DataLength,
        UINT32      priority)
{
    UINT16        pduType, pduType2;
    LOCALPERSONID localID;
    BOOL          pduOK = FALSE;

    DC_BEGIN_FN("SC_OnDataReceived");

    TRC_NRM((TB, "Data Received"));

    if (DataLength >= sizeof(TS_SHARECONTROLHEADER)) {
        pduType = (((PTS_SHARECONTROLHEADER)pPkt)->pduType) & TS_MASK_PDUTYPE;
        TRC_NRM((TB, "[%u]SC packet type %u", netPersonID, pduType));
    }
    else {
        TRC_ERR((TB,"Data len %u too small for share ctrl header",
                DataLength));
        goto ShortPDU;
    }

    if (pduType == TS_PDUTYPE_DATAPDU)
    {
        /********************************************************************/
        /* Data PDU. This is critical path so decode inline.                */
        /********************************************************************/
        if (DataLength >= sizeof(TS_SHAREDATAHEADER)) {
            pduType2 = ((PTS_SHAREDATAHEADER)pPkt)->pduType2;
            SC_CHECK_STATE(SCE_DATAPACKET);
            pduOK = TRUE;
        }
        else {
            TRC_ERR((TB,"Data len %u too small for share data header",
                    DataLength));
            goto ShortPDU;
        }

#ifdef DC_DEBUG
        {
            /****************************************************************/
            /* Ok, this is ugly.  I'm trying to trace the PDU name without  */
            /* - searching a table                                          */
            /* - implementing a sparse table                                */
            /* - a huge if ... else if switch.                              */
            /* If you don't like it or don't understand it, ask MF.  Before */
            /* you get too het up, bear in mind the #ifdef DC_DEBUG above.  */
            /****************************************************************/
            unsigned pduIndex =
                    (pduType2 == TS_PDUTYPE2_UPDATE)              ? 1 :
                    (pduType2 == TS_PDUTYPE2_FONT)                ? 2 :
                    (pduType2 == TS_PDUTYPE2_CONTROL)             ? 3 :
                    ((pduType2 >= TS_PDUTYPE2_WINDOWACTIVATION) &&
                     (pduType2 <= TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU)) ?
                         pduType2 - 19 : 0;
            TRC_NRM((TB, "DataPDU type %s (%u)", scPktName[pduIndex],
                    pduType2));
        }
#endif

        /********************************************************************/
        /* First check for synchronize packets                              */
        /********************************************************************/
        if (pduType2 != TS_PDUTYPE2_SYNCHRONIZE) {
            /****************************************************************/
            /* Now check that this priority has been synchronized           */
            /****************************************************************/
            localID = SC_NetworkIDToLocalID(netPersonID);
            if (!scPartyArray[localID].sync[priority])
            {
                TRC_ALT((TB,
                       "[%d] {%d} Discarding packet on unsynched priority %d",
                       netPersonID, localID, priority));
                DC_QUIT;
            }

            /****************************************************************/
            /* All is well - pass the packet to its destination             */
            /****************************************************************/
            switch (pduType2) {
                case TS_PDUTYPE2_INPUT:
                    // Note that changes to this path should be examined
                    // in light of fast-path input (IM_DecodeFastPathInput).
                    IM_PlaybackEvents((PTS_INPUT_PDU)pPkt, DataLength);
                    break;

                case TS_PDUTYPE2_CONTROL:
                    CA_ReceivedPacket((PTS_CONTROL_PDU)pPkt, DataLength,
                            localID);
                    break;

                case TS_PDUTYPE2_FONTLIST:
                    USR_ProcessRemoteFonts((PTS_FONT_LIST_PDU)pPkt,
                            DataLength, localID);
                    break;

                case TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST:
                    // Persistent bitmap cache key list PDU.
                    SBC_HandlePersistentCacheList(
                            (TS_BITMAPCACHE_PERSISTENT_LIST *)pPkt, DataLength,
                            localID);
                    break;

                case TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU:
                    // For future support of bitmap error PDU
                    SBC_HandleBitmapCacheErrorPDU(
                            (TS_BITMAPCACHE_ERROR_PDU *)pPkt, DataLength,
                            localID);
                    break;

                case TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU:
                    // offscreen cache error PDU
                    SBC_HandleOffscrCacheErrorPDU(
                            (TS_OFFSCRCACHE_ERROR_PDU *)pPkt, DataLength,
                            localID);
                    break;

#ifdef DRAW_NINEGRID
                case TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU:
                    // drawninegrid error PDU
                    SBC_HandleDrawNineGridErrorPDU(
                            (TS_DRAWNINEGRID_ERROR_PDU *)pPkt, DataLength,
                            localID);
                    break;
#endif
#ifdef DRAW_GDIPLUS                
                case TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU:
                    SBC_HandleDrawGdiplusErrorPDU(
                            (TS_DRAWGDIPLUS_ERROR_PDU *)pPkt, DataLength,
                            localID);
                    break;
#endif

                case TS_PDUTYPE2_REFRESH_RECT:
                    WDW_InvalidateRect(m_pTSWd, (PTS_REFRESH_RECT_PDU)pPkt,
                            DataLength);
                    break;

                case TS_PDUTYPE2_SUPPRESS_OUTPUT:
                    UP_ReceivedPacket((PTS_SUPPRESS_OUTPUT_PDU)pPkt,
                            DataLength, localID);
                    break;

                case TS_PDUTYPE2_SHUTDOWN_REQUEST:
                    DCS_ReceivedShutdownRequestPDU((PTS_SHAREDATAHEADER)pPkt,
                            DataLength, localID);
                    break;

                default:
                    /********************************************************/
                    /* Unknown pduType2                                     */
                    /********************************************************/
                    TRC_ERR((TB, "Unknown data packet %d", pduType2));
                    WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                         Log_RDP_UnknownPDUType2,
                                         (BYTE *)&pduType2,
                                         sizeof(pduType2));
                    break;
            }
        }
        else
        {
            TRC_NRM((TB, "Synchronize PDU"));
            SCSynchronizePDU(netPersonID, priority,(PTS_SYNCHRONIZE_PDU)pPkt);
        }
    }
    else
    {
        /********************************************************************/
        /* Control PDU. Not critical so throw to handler.                   */
        /********************************************************************/
        TRC_DBG((TB, "Control PDU"));
        SCReceivedControlPacket(netPersonID, priority, (PVOID)pPkt,
                DataLength);
        pduOK = TRUE;
    }

DC_EXIT_POINT:
    if (!pduOK)
    {
        /********************************************************************/
        /* An out-of-sequence packet has been received.  It's possible we   */
        /* might receive an input PDU just after we brought the share down, */
        /* so don't kick off the client for that.                           */
        /********************************************************************/
        TRC_ERR((TB, "Out-of-sequence packet %hx/%hd received in state %d",
                pduType, pduType2, scState));

        if ((pduType == TS_PDUTYPE_DATAPDU) &&
            (pduType2 == TS_PDUTYPE2_INPUT))
        {
            TRC_ERR((TB, "Not kicking client off: it was only an input PDU"));
        }
        else
        {
            /****************************************************************/
            /* Disconnect the client.                                       */
            /****************************************************************/
            wchar_t detailData[(sizeof(pduType) * 2) +
                               (sizeof(pduType2) * 2) +
                               (sizeof(scState) * 2) + 3];
            TRC_ERR((TB, "Kicking client off"));
            swprintf(detailData,
                        L"%hx %hx %x",
                        pduType,
                        pduType2,
                        scState);
            WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                                 Log_RDP_DataPDUSequence,
                                 (BYTE *)&detailData,
                                 sizeof(detailData));
        }
    }

    DC_END_FN();
    return;

// Error handling.
ShortPDU:
    WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShareDataTooShort, pPkt, DataLength);

    DC_END_FN();
} /* SC_OnDataReceived */


/****************************************************************************/
/* Name:      SC_OnShadowDataReceived                                       */
/*                                                                          */
/* Purpose:   Callback from SM for shadow data receive path.  Main purpose  */
/*            is to scan for the shadow hotkey being pressed.               */
/*                                                                          */
/* Params:    netPersonID - MCS UserID of the data sender                   */
/*            priority    - MCS data priority the data was sent on          */
/*            pPkt        - pointer to start of packet                      */
/****************************************************************************/
void RDPCALL ShareClass::SC_OnShadowDataReceived(
        PBYTE       pPkt,
        NETPERSONID netPersonID,
        unsigned    DataLength,
        UINT32      priority)
{
    UINT16        pduType, pduType2;
    LOCALPERSONID localID;
    BOOLEAN       bShadowData = TRUE;
    NTSTATUS      status;

    DC_BEGIN_FN("SC_OnShadowDataReceived");

    TRC_NRM((TB, "Shadow data Received"));

    // If this is the primary client stack, then process the data and figure out
    // whether or not the PDU should be passed on to the target. Else this is
    // a passthru stack and we should forward PDUs regardless.
    // Note IM_DecodeFastPathInput() performs this logic for fast-path input.
    if (m_pTSWd->StackClass == Stack_Primary) {

        //   check that we have enough data before we deref the pduType.
        if (sizeof(TS_SHARECONTROLHEADER) > DataLength) {
            TRC_ERR((TB,"The PDU is not long enough to contain the TS_SHARECONTROLHEADER %d",
                                                                   DataLength));
            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
            DC_QUIT;
        }

        pduType = (((PTS_SHARECONTROLHEADER)pPkt)->pduType) & TS_MASK_PDUTYPE;
        TRC_NRM((TB, "[%u]SC packet type %u", netPersonID, pduType));

        if (pduType == TS_PDUTYPE_DATAPDU)
        {
            /********************************************************************/
            /* Data PDU. This is critical path so decode inline.                */
            /********************************************************************/
            if (sizeof(TS_SHAREDATAHEADER) > DataLength) {
                TRC_ERR((TB,"The PDU is not long enough to contain the TS_SHAREDATAHEADER %d",
                                                                   DataLength));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
                DC_QUIT;
            }
        
           pduType2 = ((PTS_SHAREDATAHEADER)pPkt)->pduType2;

        #ifdef DC_DEBUG
            {
                /****************************************************************/
                /* Ok, this is ugly.  I'm trying to trace the PDU name without  */
                /* - searching a table                                          */
                /* - implementing a sparse table                                */
                /* - a huge if ... else if switch.                              */
                /* If you don't like it or don't understand it, ask MF.  Before */
                /* you get too het up, bear in mind the #ifdef DC_DEBUG above.  */
                /****************************************************************/
                unsigned pduIndex =
                    (pduType2 == TS_PDUTYPE2_UPDATE)              ? 1 :
                    (pduType2 == TS_PDUTYPE2_FONT)                ? 2 :
                    (pduType2 == TS_PDUTYPE2_CONTROL)             ? 3 :
                    ((pduType2 >= TS_PDUTYPE2_WINDOWACTIVATION) &&
                     (pduType2 <= TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU)) ?
                      pduType2 - 19 : 0;
                if (pduIndex != (TS_PDUTYPE2_INPUT - 19)) {
                    TRC_NRM((TB, "Shadow DataPDU type %s (%d)",
                            scPktName[pduIndex], pduType2));
                }
            }
        #endif

            /********************************************************************/
            /* First check for synchronize packets                              */
            /********************************************************************/
            if (pduType2 != TS_PDUTYPE2_SYNCHRONIZE)
            {
                /****************************************************************/
                /* Now check that this priority has been synchronized           */
                /****************************************************************/
                localID = SC_NetworkIDToLocalID(netPersonID);
                if (!scPartyArray[localID].sync[priority])
                {
                    TRC_ALT((TB,
                           "[%d] {%d} Discarding packet on unsynched priority %d",
                           netPersonID, localID, priority));
                    DC_QUIT;
                }

                /****************************************************************/
                /* All is well - pass the packet to its destination             */
                /****************************************************************/
                switch (pduType2)
                {
                    case TS_PDUTYPE2_INPUT:
                    {
                        // Note that changes to this path should be examined
                        // in light of fast-path input (IM_DecodeFastPathInput).
                        IM_PlaybackEvents((PTS_INPUT_PDU)pPkt, DataLength);
                    }
                    break;


                    case TS_PDUTYPE2_SUPPRESS_OUTPUT:
                    {
                        /********************************************************/
                        /* A SuppressOutputPDU.  Don't process it as it would   */
                        /* disable output for the shadow target as well!        */
                        /********************************************************/
                        TRC_ALT((TB, "Not forwarding TS_PDUTYPE2_SUPPRESS_OUTPUT"));
                        bShadowData = FALSE;
                    }
                    break;

                    case TS_PDUTYPE2_SHUTDOWN_REQUEST:
                    {
                        /********************************************************/
                        /* A ShutdownRequestPDU.  Process locally only.  It     */
                        /* should apply to the shadow client and not the target.*/
                        /********************************************************/
                        //    this does not actually use the pPkt member and we 
                        //    have at lest TS_SHAREDATAHEADER left
                        DCS_ReceivedShutdownRequestPDU((PTS_SHAREDATAHEADER)pPkt,
                                DataLength, localID);
                        TRC_ALT((TB, "Not forwarding TS_PDUTYPE2_SHUTDOWN_REQUEST"));
                        bShadowData = FALSE;
                    }
                    break;

                    case TS_PDUTYPE2_FONTLIST:
                    {

                        if (sizeof(TS_FONT_LIST_PDU) - sizeof(TS_FONT_ATTRIBUTE)
                                                                > DataLength) {
                            TRC_ERR((TB,"The PDU is not long enough to contain the TS_FONT_LIST_PDU %d",
                                                                   DataLength));
                            WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
                            DC_QUIT;
                        }

                        PTS_FONT_LIST_PDU pFontListPDU = (PTS_FONT_LIST_PDU) pPkt;

                        /********************************************************/
                        /* NT5 server doesn't do anything with a font packet so */
                        /* send the smallest possible packet accross the pipe.  */
                        /********************************************************/
                        DataLength = sizeof(TS_FONT_LIST_PDU) -
                                     sizeof(TS_FONT_ATTRIBUTE);

                        pFontListPDU->shareDataHeader.shareControlHeader.totalLength =
                                (UINT16)DataLength;
                        pFontListPDU->shareDataHeader.generalCompressedType = 0;
                        pFontListPDU->shareDataHeader.generalCompressedLength = 0;
                        pFontListPDU->numberFonts = 0;
                        pFontListPDU->totalNumFonts = 0;
                        pFontListPDU->entrySize = sizeof(TS_FONT_ATTRIBUTE);
                    }
                    break;

                    // Forward all other PDUs until we learn otherwise!
                    default:
                        break;
                }
            }
            else
            {
                // TODO:  Why are we processing this?
                TRC_ALT((TB, "Shadow Synchronize PDU"));
                SCSynchronizePDU(netPersonID, priority,(PTS_SYNCHRONIZE_PDU)pPkt);
            }
        }

        else {
            /********************************************************************/
            /* Need to watch for confirm actives so we can determine how to     */
            /* terminate the shadow session.                                    */
            /********************************************************************/
            if (sizeof(TS_FLOW_PDU) > DataLength) {
                TRC_ERR((TB,"The PDU is not long enough to contain the TS_SHAREDATAHEADER %d",
                                                                   DataLength));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
                DC_QUIT;
            }
                
            if (((PTS_FLOW_PDU)pPkt)->flowMarker != TS_FLOW_MARKER)
            {
                //   here we already checked that we have enough buffer 
                //   for a TS_SHARECONTROLHEADER
                pduType = ((PTS_SHARECONTROLHEADER)pPkt)->pduType & TS_MASK_PDUTYPE;
                switch (pduType)
                {
                    case TS_PDUTYPE_CONFIRMACTIVEPDU:
                        TRC_ALT((TB, "Shadow Client ConfirmActivePDU - shadow active!"));
                        m_pTSWd->bInShadowShare = TRUE;
                        break;


                    default:
                        break;
                }
            }
        }
    }
    else if (m_pTSWd->StackClass == Stack_Passthru) {
        // If we see a demand active and no server certificate has been received
        // then wake up rdpwsx.

            //    check that we have enough data before we deref the flow marker
            if (sizeof(TS_FLOW_PDU) > DataLength) {
                TRC_ERR((TB,"The PDU is not long enough to contain the TS_FLOW_PDU %d",
                                                                   DataLength));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
                DC_QUIT;
            }
            
            if (((PTS_FLOW_PDU)pPkt)->flowMarker != TS_FLOW_MARKER) {

            //    Check that we have enough data before we deref the 
            //    TS_SHARECONTROLHEADER marker.
            //    As of today we know exaclty that we have enough buffer 
            //    size sizeof(TS_FLOW_PDU) is grater then sizeof TS_SHARECONTROLHEADER.
            if (sizeof(TS_SHARECONTROLHEADER) > DataLength) {
                TRC_ERR((TB,"The PDU is not long enough to contain the TS_SHARECONTROLHEADER %d",
                                                                   DataLength));
                WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShadowDataTooShort,
                                                       (PBYTE)pPkt, DataLength);
                DC_QUIT;
            }
        
            pduType = ((PTS_SHARECONTROLHEADER)pPkt)->pduType & TS_MASK_PDUTYPE;
            switch (pduType)
            {
                case TS_PDUTYPE_DEMANDACTIVEPDU:
                    TRC_ALT((TB, "Passthru stack - demand active!"));
                    SC_SaveServerCert(NULL, 0);
                    m_pTSWd->bInShadowShare = TRUE;
                    break;

                case TS_PDUTYPE_SERVERCERTIFICATEPDU:
                    //    check that we have enough data before we pass the 
                    //    TS_SERVER_CERTIFICATE_PDU marker.
                    if (sizeof(TS_SERVER_CERTIFICATE_PDU) > DataLength) {
                        TRC_ERR((TB,
                        "The PDU is not long enough to contain the TS_SERVER_CERTIFICATE_PDU %d",
                                                                   DataLength));
                        WDW_LogAndDisconnect(m_pTSWd, TRUE, 
                            Log_RDP_BadServerCertificateData,
                            (PBYTE)pPkt, DataLength);
                        DC_QUIT;
                    }
                    
                    TRC_ALT((TB, "ServerCertificatePDU"));
                    SC_SaveServerCert((PTS_SERVER_CERTIFICATE_PDU) pPkt, DataLength);
                    bShadowData = FALSE;
                    break;

                default:
                    break;
            }
        }
    }

    // Forward PDU to shadow if it's OK.
    // Note IM_DecodeFastPathInput() performs this logic for fast-path input.
    if (bShadowData) {
        TRC_NRM((TB, "Forwarding shadow data: %ld", DataLength));
        status = IcaRawInput(m_pTSWd->pContext,
                             NULL,
                             pPkt,
                             DataLength);

        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "Failed shadow input data [%ld]: %x",
                    DataLength, status));
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* SC_OnShadowDataReceived */


/****************************************************************************/
/* Name:      SC_AllocBuffer                                                */
/*                                                                          */
/* Purpose:   Allocate a send buffer                                        */
/*                                                                          */
/* Returns:   TRUE  - buffer allocated OK                                   */
/*            FALSE - failed to allocate buffer                             */
/*                                                                          */
/* Params:    ppPkt    - (returned) pointer to allocated packet             */
/*            pktLen   - length of packet required                          */
/*            priority - priority on which buffer will be used              */
/****************************************************************************/
NTSTATUS __fastcall SHCLASS SC_AllocBuffer(PPVOID ppPkt, UINT32 pktLen)
{
    NTSTATUS status;
    DC_BEGIN_FN("SC_AllocBuffer");

    // fWait is TRUE means that we will always wait for a buffer to be avail
    status = SM_AllocBuffer(scPSMHandle, ppPkt, pktLen, TRUE, FALSE);

    DC_END_FN();
    return(status);
} /* SC_AllocBuffer */


/****************************************************************************/
/* Name:      SC_FreeBuffer                                                 */
/*                                                                          */
/* Purpose:   Free an unused send buffer                                    */
/*                                                                          */
/* Params:    pPkt     - pointer to buffer to free                          */
/*            pktLen   - size of the packet                                 */
/*            priority - priority buffer was allocated on                   */
/****************************************************************************/
void __fastcall SHCLASS SC_FreeBuffer(PVOID pPkt)
{
    SM_FreeBuffer(scPSMHandle, pPkt, FALSE);
} /* SC_FreeBuffer  */


/****************************************************************************/
/* Name:      SC_SendData                                                   */
/*                                                                          */
/* Purpose:   Send a packet                                                 */
/*                                                                          */
/* Returns:   TRUE  - packet sent OK                                        */
/*            FALSE - failed to send packet                                 */
/*                                                                          */
/* Params:    pPkt     - packet to send                                     */
/*            dataLen  - length of packet                                   */
/*            pduLen   - length of PDU : this will be used as the length    */
/*                       of the packet if it is non-zero                    */
/*            priority - priority (0 = all priorities)                      */
/*            personID - person to send packet to (0 = all persons)         */
/****************************************************************************/
BOOL RDPCALL ShareClass::SC_SendData(
        PTS_SHAREDATAHEADER pPkt,
        UINT32              dataLen,
        UINT32              pduLen,
        UINT32              priority,
        NETPERSONID         personID)
{
    BOOL rc;

    DC_BEGIN_FN("SC_SendData");

    /************************************************************************/
    /* Fill in the Share control and data header(s) if this is a single PDU */
    /*                                                                      */
    /* Since we can send multiple PDUs per packet, the total length of data */
    /* to send and the PDU length are not always the same.  Where they are  */
    /* not, each PDU will have had its length (and compression) set up as   */
    /* it was assembled and we should not interfere here!                   */
    /************************************************************************/
    pPkt->shareControlHeader.pduType   = TS_PDUTYPE_DATAPDU |
                                         TS_PROTOCOL_VERSION;
    pPkt->shareControlHeader.pduSource = (UINT16)scUserID;
    if (pduLen != 0)
    {
        pPkt->shareControlHeader.totalLength = (UINT16)pduLen;

        // Fill in the Share data header.
        pPkt->shareID               = scShareID;
        pPkt->streamID              = (BYTE)priority;
        pPkt->uncompressedLength    = (UINT16)pduLen;
        pPkt->generalCompressedType = 0;
        pPkt->generalCompressedLength = 0;
        m_pTSWd->pProtocolStatus->Output.CompressedBytes += pduLen;
    }

    // Send with false for fast-path flag.
    rc = SM_SendData(scPSMHandle, (PVOID)pPkt, dataLen, TS_HIGHPRIORITY, 0,
            FALSE, RNS_SEC_ENCRYPT, FALSE);
    if (!rc)
    {
        TRC_ERR((TB, "Failed to send %d bytes", dataLen));
    }

    DC_END_FN();
    return(rc);
} /* SC_SendData */


/****************************************************************************/
/* SC_GetMyNetworkPersonID                                                  */
/*                                                                          */
/* Returns the network person ID for this machine.                          */
/****************************************************************************/
NETPERSONID RDPCALL SHCLASS SC_GetMyNetworkPersonID(void)
{
    NETPERSONID rc = 0;

    DC_BEGIN_FN("SC_GetMyNetworkPersonID");

    SC_CHECK_STATE(SCE_GETMYNETWORKPERSONID);

    rc = scPartyArray[0].netPersonID;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      SC_KeepAlive                                                  */
/*                                                                          */
/* Purpose:   KeepAlive packet send processing                              */
/*                                                                          */
/* Returns:   TRUE/FALSE                                                    */
/*                                                                          */
/* Operation: Send a KeepAlive PDU if required                              */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_KeepAlive(void)
{
    BOOL rc = FALSE;
    PTS_FLOW_PDU pFlowTestPDU;

    DC_BEGIN_FN("SC_KeepAlive");

    TRC_NRM((TB, "Time for a KeepAlive PDU"));

    if (scState == SCS_IN_SHARE) {
        // only send the FlowTestPDU if we are in the share
        // fWait is FALSE means that we will not wait for a buffer to be available
        // If the buffer is full, that means there are packets waiting to be send out,
        // so there is no need to send out keep alive packet anyway.
        if ( STATUS_SUCCESS == SM_AllocBuffer(scPSMHandle, (PPVOID) (&pFlowTestPDU), sizeof(*pFlowTestPDU), FALSE, FALSE) ) {
            pFlowTestPDU->flowMarker = TS_FLOW_MARKER;
            pFlowTestPDU->pduType = TS_PDUTYPE_FLOWTESTPDU;
            pFlowTestPDU->flowIdentifier = 0;
            pFlowTestPDU->flowNumber = 0;
            pFlowTestPDU->pduSource = (TSUINT16) scUserID;

            if (SM_SendData(scPSMHandle, pFlowTestPDU, sizeof(*pFlowTestPDU),
                    0, 0, FALSE, RNS_SEC_ENCRYPT, FALSE)) {
                TRC_NRM((TB, "Sent a KeepAlive PDU to the client"));

                rc = TRUE;
            }
            else {
                TRC_ERR((TB, "Failed to send KeepAlive PDU"));
            }
        }
        else {
            TRC_ERR((TB, "Failed to alloc buffer for KeepAlive PDU"));
        }
    }
    else {
        TRC_ERR((TB, "In the wrong state: scState=%d, no KeepAlive PDU sent", scState));
    }

    DC_END_FN();
    return rc;
} /* SC_KeepAlive */


/****************************************************************************/
/* Name:      SC_RedrawScreen                                               */
/*                                                                          */
/* Purpose:   Redraw the desktop upon request                               */
/****************************************************************************/
void RDPCALL SHCLASS SC_RedrawScreen(void)
{
    NTSTATUS Status;
    ICA_CHANNEL_COMMAND Cmd;

    DC_BEGIN_FN("SC_RedrawScreen");

    TRC_NRM((TB, "Call IcaChannelInput for screen redraw"));

    // redraw the whole desktop
    Cmd.Header.Command = ICA_COMMAND_REDRAW_RECTANGLE;
    Cmd.RedrawRectangle.Rect.Left = 0;
    Cmd.RedrawRectangle.Rect.Top = 0;
    Cmd.RedrawRectangle.Rect.Right = (short) m_desktopWidth;
    Cmd.RedrawRectangle.Rect.Bottom = (short) m_desktopHeight;

    /************************************************************/
    // Pass the filled in structure to ICADD.
    /************************************************************/
    Status = IcaChannelInput(m_pTSWd->pContext, Channel_Command, 0, NULL,
            (unsigned char *) &Cmd, sizeof(ICA_CHANNEL_COMMAND));

    if (Status == STATUS_SUCCESS) {
        TRC_NRM((TB, "Issued IcaChannelInput for Screen Redraw"));
    }
    else {
        TRC_ERR((TB, "Error issuing an IcaChannelInput, status=%lu", Status));
    }

    DC_END_FN();
}

/****************************************************************************/
/* SC_LocalIDToNetworkID()                                                  */
/*                                                                          */
/* Converts a local person ID to the corresponding network person ID.       */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* localPersonID - a local person ID.  This must be a valid local person    */
/* ID.                                                                      */
/*                                                                          */
/* RETURNS: a network person ID.                                            */
/****************************************************************************/
NETPERSONID RDPCALL SHCLASS SC_LocalIDToNetworkID(
        LOCALPERSONID localPersonID)
{
    DC_BEGIN_FN("SC_LocalIDToNetworkID");

    SC_CHECK_STATE(SCE_LOCALIDTONETWORKID);

    /************************************************************************/
    /* Validate the localPersonID.                                          */
    /************************************************************************/
    TRC_ASSERT( (SC_IsLocalPersonID(localPersonID)),
                                         (TB,"Invalid {%d}", localPersonID) );

    /************************************************************************/
    /* Return this party's personID.                                        */
    /************************************************************************/
    TRC_DBG((TB, "localID %u is network %hu", (unsigned)localPersonID,
                                    scPartyArray[localPersonID].netPersonID));

DC_EXIT_POINT:
    DC_END_FN();
    return(scPartyArray[localPersonID].netPersonID);
}

/****************************************************************************/
/* SC_IsLocalPersonID()                                                     */
/*                                                                          */
/* Validates a local person ID                                              */
/*                                                                          */
/* PARAMETERS                                                               */
/*                                                                          */
/* localPersonID - the local person ID to validate                          */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_IsLocalPersonID(LOCALPERSONID   localPersonID)
{
    BOOL  rc = FALSE;

    DC_BEGIN_FN("SC_IsLocalPersonID");

    SC_CHECK_STATE(SCE_ISLOCALPERSONID);

    /************************************************************************/
    /* Return TRUE if the localPersonID is valid, FALSE otherwise.          */
    /************************************************************************/
    rc = ((localPersonID < SC_DEF_MAX_PARTIES) &&
            (scPartyArray[localPersonID].netPersonID)) ? TRUE : FALSE;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
}

/****************************************************************************/
/* SC_IsNetworkPersonID()                                                   */
/*                                                                          */
/* Validates a network person ID                                            */
/*                                                                          */
/* PARAMETERS                                                               */
/*                                                                          */
/* personID - the network person ID to validate                             */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_IsNetworkPersonID(NETPERSONID netPersonID)
{
    LOCALPERSONID localPersonID;
    BOOL          rc = FALSE;

    DC_BEGIN_FN("SC_IsNetworkPersonID");

    SC_CHECK_STATE(SCE_ISNETWORKPERSONID);

    /************************************************************************/
    /* Check for a zero personID.                                           */
    /************************************************************************/
    if (netPersonID == 0)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Search for the personID.                                             */
    /************************************************************************/
    for ( localPersonID = 0;
          localPersonID < SC_DEF_MAX_PARTIES;
          localPersonID++ )
    {
        if (netPersonID == scPartyArray[localPersonID].netPersonID)
        {
            rc = TRUE;
            DC_QUIT;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
}


/****************************************************************************/
/* SC_SetCapabilities()                                                     */
/*                                                                          */
/* Sets the SC's capabilities at start of day.                              */
/* This function is required because the SC is initialized before the CPC,  */
/* so cannot register its capabilities in SC_Init().                        */
/****************************************************************************/
void RDPCALL SHCLASS SC_SetCapabilities(void)
{
    TS_SHARE_CAPABILITYSET caps;

    DC_BEGIN_FN("SC_SetCapabilities");

    /************************************************************************/
    /* Register capabilities.                                               */
    /************************************************************************/
    caps.capabilitySetType    = TS_CAPSETTYPE_SHARE;
    caps.nodeID               = (TSUINT16)scUserID;

    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&caps,
            sizeof(TS_SHARE_CAPABILITYSET));

    DC_END_FN();
}


/****************************************************************************/
/* SC_SetCombinedCapabilities()                                             */
/*                                                                          */
/* Sets the share's combined capabilities to a predetermined set of values. */
/* This is used by shadow stacks so that the host's capabilities start with */
/* the value of the previous stack.                                         */
/****************************************************************************/
void RDPCALL SHCLASS SC_SetCombinedCapabilities(UINT cbCapsSize,
                                                PTS_COMBINED_CAPABILITIES pCaps)
{

    DC_BEGIN_FN("SC_SetCombinedCapabilities");

    /************************************************************************/
    /* Initialize capabilities.                                             */
    /************************************************************************/
    CPC_SetCombinedCapabilities(cbCapsSize, pCaps);

    DC_END_FN();
}


/****************************************************************************/
/* SC_GetCombinedCapabilities()                                             */
/*                                                                          */
/* Used during initiation of a shadow to gather the currently active set of */
/* combined capabilities for the shadow client.  These will be passed to    */
/* the shadow target for negotiation.                                       */
/****************************************************************************/
void RDPCALL SHCLASS SC_GetCombinedCapabilities(LOCALPERSONID localID,
                                                PUINT pcbCapsSize,
                                                PTS_COMBINED_CAPABILITIES *ppCaps)
{

    DC_BEGIN_FN("SC_GetCombinedCapabilities");

    /************************************************************************/
    /* Initialize capabilities.                                             */
    /************************************************************************/
    CPC_GetCombinedCapabilities(localID, pcbCapsSize, ppCaps);

    DC_END_FN();
}

/****************************************************************************/
/* Name:      SC_AddPartyToShare                                            */
/*                                                                          */
/* Purpose:   Add another party to the share such that we get a new set of  */
/*            negotiated capabilities.  This function is used when a new    */
/*            shadow connects.                                              */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    netPersonID - ID of sender of capabilities                    */
/*            pCaps       - new capabilities for person                     */
/*            capsLength  - length of capability sets                       */
/*                                                                          */
/* Operation: see purpose                                                   */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS SC_AddPartyToShare(
        NETPERSONID               netPersonID,
        PTS_COMBINED_CAPABILITIES pCaps,
        unsigned                  capsLength)
{
    LOCALPERSONID localPersonID;
    BOOL          acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
    NTSTATUS      status = STATUS_SUCCESS;
    PTS_GENERAL_CAPABILITYSET pGenCapSet;
    unsigned MPPCCompressionLevel;

    DC_BEGIN_FN("SC_AddPartyToShare");

    /************************************************************************/
    /* Reject this party if it will exceed the maximum number of parties    */
    /* allowed in a share.  (Not required for RNS V1.0, but left in as it   */
    /* doesn't do any harm).                                                */
    /************************************************************************/
    if (scNumberInShare == SC_DEF_MAX_PARTIES)
    {
        TRC_ERR((TB, "Reached max parties in share %d",
               SC_DEF_MAX_PARTIES));
        status = STATUS_DEVICE_BUSY;
        DC_QUIT;
    }

    /************************************************************************/
    /* Calculate a localPersonID for the remote party and store their       */
    /* details in the party array.                                          */
    /************************************************************************/
    for ( localPersonID = 1;
          localPersonID < SC_DEF_MAX_PARTIES;
          localPersonID++ )
    {
        if (scPartyArray[localPersonID].netPersonID == 0)
        {
            /****************************************************************/
            /* Found an empty slot.                                         */
            /****************************************************************/
            TRC_NRM((TB, "Allocated local person ID %d", localPersonID));
            break;
        }
    }

    /************************************************************************/
    /* Even though scNumberInShare is checked against SC_DEF_MAX_PARTIES    */
    /* above, the loop above might still not find an empty slot.            */
    /************************************************************************/ 
    if (SC_DEF_MAX_PARTIES <= localPersonID)
    {
        TRC_ABORT((TB, "Couldn't find room to store local person"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Store the new person's details                                       */
    /************************************************************************/
    scPartyArray[localPersonID].netPersonID = netPersonID;
    memcpy(scPartyArray[localPersonID].name, L"Shadow", sizeof(L"Shadow"));
    memset(scPartyArray[localPersonID].sync,
            0,
            sizeof(scPartyArray[localPersonID].sync));

    TRC_NRM((TB, "{%d} person name %s",
            (unsigned)localPersonID, scPartyArray[localPersonID].name));

    /************************************************************************/
    /* Call the XX_PartyJoiningShare() functions for the remote party.      */
    /************************************************************************/
    if (!SCCallPartyJoiningShare(localPersonID,
                                 capsLength,
                                 (PVOID) pCaps,
                                 acceptedArray,
                                 scNumberInShare))
    {
        /********************************************************************/
        /* Some component rejected the remote party.                        */
        /********************************************************************/
        TRC_ERR((TB, "Remote party rejected"));
        SCCallPartyLeftShare(localPersonID,
                             acceptedArray,
                             scNumberInShare );
        scPartyArray[localPersonID].netPersonID = 0;
        status = STATUS_REVISION_MISMATCH;
        DC_QUIT;
    }

    // For shadow connections, we must force fast-path output off to prevent
    // any fast-path encoding from going across the cross-server pipe.
    // This is to maintain backward compatibility with TS5 beta 3.
    // Checking for m_pTSWd->shadowState in SCPartyJoiningShare() is not
    // sufficient since SHADOW_TARGET is likely not to have been set yet.
    // Note we have to update *all* precalculated header sizes, in SC and
    // UP.
    TRC_ALT((TB,"Forcing fast-path output off in shadow"));
    scUseFastPathOutput = FALSE;
    scUpdatePDUHeaderSpace = sizeof(TS_SHAREDATAHEADER);
    UP_UpdateHeaderSize();

    // Update the compression level.
    // assume no compression
    scUseShadowCompression = FALSE;
    if (pCaps != NULL) {

        pGenCapSet = (PTS_GENERAL_CAPABILITYSET) WDW_GetCapSet(
                     m_pTSWd, TS_CAPSETTYPE_GENERAL, pCaps, capsLength);

        if (pGenCapSet != NULL) {

            // update the compression capability
            if (m_pTSWd->bCompress &&
                (pGenCapSet->extraFlags & TS_SHADOW_COMPRESSION_LEVEL) &&
                (m_pTSWd->pMPPCContext->ClientComprType == pGenCapSet->generalCompressionLevel)) {

                    MPPCCompressionLevel = m_pTSWd->pMPPCContext->ClientComprType;
                    scUseShadowCompression = TRUE;
            }
        }
    }

    if (scUseShadowCompression) {

        // the compression history will be flushed
        m_pTSWd->bFlushed = PACKET_FLUSHED;

        // the compression will restart over
        initsendcontext(m_pTSWd->pMPPCContext, MPPCCompressionLevel);
    }



    /************************************************************************/
    /* The remote party is now in the share.                                */
    /************************************************************************/
    scNumberInShare++;
    TRC_ALT((TB, "Number in share %d", (unsigned)scNumberInShare));

DC_EXIT_POINT:
    DC_END_FN();
    return status;
} /* SC_AddPartyToShare */


/****************************************************************************/
/* Name:      SC_RemovePartyFromShare                                       */
/*                                                                          */
/* Purpose:   Remove a party from the share such that we get a new set of   */
/*            negotiated capabilities.  This function is used when a shadow */
/*            disconnects from the share.                                   */
/*                                                                          */
/* Params:    localID    - ID of person to remove.                          */
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS SC_RemovePartyFromShare(NETPERSONID netPersonID)
{
    BOOL acceptedArray[SC_NUM_PARTY_JOINING_FCTS];
    NTSTATUS status = STATUS_SUCCESS;
    UINT i;

    DC_BEGIN_FN("SC_RemovePartyFromShare");

    // Map network ID to the corresponding local ID
    for (i = SC_DEF_MAX_PARTIES - 1; i > 0; i--)
    {
        if (scPartyArray[i].netPersonID != netPersonID)
            continue;
        else
            break;
    }

    // Call PLS for remote person
    if (scPartyArray[i].netPersonID == netPersonID) {
        memset(acceptedArray, TRUE, sizeof(acceptedArray));

        TRC_ALT((TB, "Party %d left Share", i));
        scNumberInShare--;
        SCCallPartyLeftShare(i, acceptedArray, scNumberInShare);
        scPartyArray[i].netPersonID = 0;
        memset(&(scPartyArray[i]), 0, sizeof(*scPartyArray));
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        TRC_ERR((TB, "Unable to find netID: %ld.  Party not removed!",
                netPersonID));
    }

    scUseShadowCompression = FALSE;

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* SC_NetworkIDToLocalID()                                                  */
/*                                                                          */
/* Converts a network person ID to the corresponding local person ID.       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - a network person ID.  This must be a valid network person ID. */
/*                                                                          */
/* RETURNS: a local person ID.                                              */
/****************************************************************************/
LOCALPERSONID __fastcall SHCLASS SC_NetworkIDToLocalID(
        NETPERSONID netPersonID)
{
    LOCALPERSONID localID;
    LOCALPERSONID rc = 0;

    DC_BEGIN_FN("SC_NetworkIDToLocalID");

    /************************************************************************/
    /* Fastpath if same ID passed in as last time.                          */
    /************************************************************************/
    if (netPersonID == scLastNetID)
    {
        TRC_DBG((TB, "Same Network ID - return same local ID"));
        DC_END_FN();
        return(scLastLocID);
    }

    SC_CHECK_STATE(SCE_NETWORKIDTOLOCALID);

    TRC_ASSERT((netPersonID), (TB, "Zero personID"));

    /************************************************************************/
    /* Search for the personID.                                             */
    /************************************************************************/
    if (SC_ValidateNetworkID(netPersonID, &localID))
    {
        rc = localID;
        DC_QUIT;
    }

    TRC_ABORT((TB, "Invalid [%u]", (unsigned)netPersonID));

DC_EXIT_POINT:
    scLastNetID = netPersonID;
    scLastLocID = rc;

    DC_END_FN();
    return(rc);
}


/****************************************************************************/
/* SC_ValidateNetworkID()                                                   */
/*                                                                          */
/* Checks that a network ID is valid and returns the local ID corresponding */
/* to it if it is.                                                          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* netPersonID - a network person ID.                                       */
/* pLocalPersonID - (returned) corresponding local ID if network ID valid   */
/*     (can pass NULL if you do not want local ID)                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE - Network ID is valid FALSE - Network ID is not valid               */
/****************************************************************************/
BOOL RDPCALL SHCLASS SC_ValidateNetworkID(NETPERSONID         netPersonID,
                                          LOCALPERSONID * pLocalID)
{
    BOOL          rc = FALSE;
    LOCALPERSONID localID;

    DC_BEGIN_FN("SC_ValidateNetworkID");

    /************************************************************************/
    /* Search for the personID.                                             */
    /************************************************************************/
    for (localID = 0; localID < SC_DEF_MAX_PARTIES; localID++)
    {
        if (netPersonID == scPartyArray[localID].netPersonID)
        {
            /****************************************************************/
            /* Found required person, set return values and quit            */
            /****************************************************************/
            rc = TRUE;
            if (pLocalID)
            {
                *pLocalID = localID;
            }
            break;
        }
    }

    TRC_DBG((TB, "Network ID 0x%04u rc = 0x%04x (localID=%u)",
               netPersonID,
               rc,
               localID));

    DC_END_FN();
    return(rc);
}


/****************************************************************************/
// SC_FlushAndAllocPackage
//
// Combines a forced network flush of the current package contents with
// an allocation of the standard package buffer size.
// Returns FALSE on allocation failure.
/****************************************************************************/
NTSTATUS __fastcall ShareClass::SC_FlushAndAllocPackage(PPDU_PACKAGE_INFO pPkgInfo)
{
    NTSTATUS status = STATUS_SUCCESS;

    DC_BEGIN_FN("SC_FlushAndAllocPackage");

    if (pPkgInfo->cbLen) {
        if (pPkgInfo->cbInUse) {
            // Send the package contents.
            if (scUseFastPathOutput)
                // Send with fast-path flag.
                SM_SendData(scPSMHandle, (PVOID)pPkgInfo->pOutBuf,
                        pPkgInfo->cbInUse, TS_HIGHPRIORITY, 0, TRUE, RNS_SEC_ENCRYPT, FALSE);
            else
                SC_SendData((PTS_SHAREDATAHEADER)pPkgInfo->pOutBuf,
                        pPkgInfo->cbInUse, 0, PROT_PRIO_MISC, 0);
        }
        else {
            // or free the buffer if it's been allocated but not used.
            TRC_NRM((TB, "Freeing unused package"));
            SC_FreeBuffer(pPkgInfo->pOutBuf);
        }
    }

    // We always allocate 8K (unless the bytes needed are greater) to reduce
    // the number of buffers we allocate in the OutBuf pool. It is up to
    // the package users to pack to wire packet sizes within this
    // block.
    status = SC_AllocBuffer(&(pPkgInfo->pOutBuf), sc8KOutBufUsableSpace);
    if ( STATUS_SUCCESS == status ) {
        // If compression is not enabled, then output directly into the
        // OutBuf, else output into a temporary buffer.
        if (!m_pTSWd->bCompress)
            pPkgInfo->pBuffer = (BYTE *)pPkgInfo->pOutBuf;
        else
            pPkgInfo->pBuffer = m_pTSWd->pCompressBuffer;

        pPkgInfo->cbLen = sc8KOutBufUsableSpace;
        pPkgInfo->cbInUse = 0;
    }
    else {
        pPkgInfo->cbLen = 0;
        pPkgInfo->cbInUse = 0;
        pPkgInfo->pBuffer = NULL;

        TRC_NRM((TB, "could not allocate package buffer"));
    }

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* SC_GetSpaceInPackage                                                     */
/*                                                                          */
/* Purpose:   Ensure there's enough space in a PDU package for the data     */
/*            sending the existing package if necessary                     */
/*                                                                          */
/* Returns:   pointer to the space, or NULL if none available               */
/*            FALSE - no space available (alloc failed)                     */
/*                                                                          */
/* Params:    pPkgInfo - pointer to package info                            */
/*            cbNeeded - space needed in package                            */
/****************************************************************************/
PBYTE __fastcall SHCLASS SC_GetSpaceInPackage(
        PPDU_PACKAGE_INFO pPkgInfo,
        unsigned          cbNeeded)
{
    PBYTE pSpace;
    unsigned cbPackageSize;
    NTSTATUS status = STATUS_SUCCESS;
    unsigned RealAllocSize;

    DC_BEGIN_FN("SC_GetSpaceInPackage");

    // Handle the most common case where we have an allocated buffer and
    // enough space.
    if (pPkgInfo->cbLen) {
        if (cbNeeded <= (pPkgInfo->cbLen - pPkgInfo->cbInUse))
            goto EnoughSpace;

        // We have a buffer allocated, but from the fast-path check above
        // we know we don't have enough space. Send what we have.
        if (pPkgInfo->cbInUse != 0) {
            TRC_NRM((TB, "Not enough space - sending current package "
                    "of %u bytes",  pPkgInfo->cbInUse));

            if (scUseFastPathOutput)
                // Send with fast-path flag.
                SM_SendData(scPSMHandle, (PVOID)pPkgInfo->pOutBuf,
                        pPkgInfo->cbInUse, TS_HIGHPRIORITY, 0, TRUE, RNS_SEC_ENCRYPT, FALSE);
            else
                SC_SendData((PTS_SHAREDATAHEADER)pPkgInfo->pOutBuf,
                        pPkgInfo->cbInUse, 0, PROT_PRIO_MISC, 0);
        }
        else {
            // or free the buffer if it's been allocated but not used.
            TRC_NRM((TB, "Freeing unused package"));
            SC_FreeBuffer(pPkgInfo->pOutBuf);
        }
    }

    // We always allocate 8K (unless the bytes needed are greater) to reduce
    // the number of buffers we allocate in the OutBuf pool. It is up to
    // the package users to pack to wire packet sizes within this
    // block.
    cbPackageSize = max(cbNeeded, sc8KOutBufUsableSpace);
    status = SC_AllocBuffer(&(pPkgInfo->pOutBuf), cbPackageSize);
    if ( STATUS_SUCCESS == status ) {
        // If compression is not enabled, then output directly into the
        // OutBuf, else output into a temporary buffer.
        if (!m_pTSWd->bCompress)
            pPkgInfo->pBuffer = (BYTE *)pPkgInfo->pOutBuf;
        else
            pPkgInfo->pBuffer = m_pTSWd->pCompressBuffer;

        pPkgInfo->cbLen   = cbPackageSize;
        pPkgInfo->cbInUse = 0;
    }
    else {
        pPkgInfo->cbLen   = 0;
        pPkgInfo->cbInUse = 0;
        pPkgInfo->pBuffer = NULL;

        TRC_NRM((TB, "could not allocate package buffer"));
        pSpace = NULL;
        DC_QUIT;
    }

EnoughSpace:
    pSpace = pPkgInfo->pBuffer + pPkgInfo->cbInUse;

DC_EXIT_POINT:
    DC_END_FN();
    return pSpace;
} /* SC_GetSpaceInPackage */


/****************************************************************************/
/* SC_AddToPackage                                                          */
/*                                                                          */
/* Purpose:   Add the bytes to the PDU package - fills in the per-pdu info  */
/*                                                                          */
/* Params:    pPkgInfo - pointer to package info                            */
/*            cbLen    - Length of data to add                              */
/*            bShadow  - whether or not the data should be shadowed         */
/****************************************************************************/
void RDPCALL SHCLASS SC_AddToPackage(
        PPDU_PACKAGE_INFO pPkgInfo,
        unsigned          cbLen,
        BOOL              bShadow)
{
    BYTE *pPktHdr;
    UCHAR compressResult;
    ULONG CompressedSize;

    DC_BEGIN_FN("SC_AddToPackage");

    pPktHdr = pPkgInfo->pBuffer + pPkgInfo->cbInUse;

    // CompressedSize is the size of the data minus headers.
    CompressedSize = cbLen - scUpdatePDUHeaderSpace;
    compressResult = 0;

    if (m_pTSWd->bCompress) {
        UCHAR *pSrcBuf = pPktHdr + scUpdatePDUHeaderSpace;

        // Compress or copy the data into the OutBuf.
        if ((cbLen > WD_MIN_COMPRESS_INPUT_BUF) &&
                (cbLen < MAX_COMPRESS_INPUT_BUF) &&
                ((m_pTSWd->shadowState == SHADOW_NONE) || scUseShadowCompression)) {
            // Copy the header over to the OutBuf
            memcpy((BYTE *)pPkgInfo->pOutBuf + pPkgInfo->cbInUse, pPktHdr,
                   scUpdatePDUHeaderSpace);
            pPktHdr = (BYTE *)pPkgInfo->pOutBuf + pPkgInfo->cbInUse;

            // Attempt to compress the PDU body directly into the OutBuf
            compressResult = compress(pSrcBuf,
                    pPktHdr + scUpdatePDUHeaderSpace,
                    &CompressedSize, m_pTSWd->pMPPCContext);
            if (compressResult & PACKET_COMPRESSED) {
                unsigned CompEst;

                // Successful compression - update the compression ratio.
                TRC_ASSERT(((cbLen - scUpdatePDUHeaderSpace) >=
                        CompressedSize),
                        (TB,"Compression created larger size than uncompr"));
                scMPPCUncompTotal += cbLen - scUpdatePDUHeaderSpace;
                scMPPCCompTotal += CompressedSize;
                if (scMPPCUncompTotal >= SC_SAMPLE_SIZE) {
                    // Compression estimate is average # of bytes that
                    // SCH_UNCOMP_BYTES bytes of uncomp data compress to.
                    CompEst = SCH_UNCOMP_BYTES * scMPPCCompTotal /
                            scMPPCUncompTotal;
                    TRC_ASSERT((CompEst <= SCH_UNCOMP_BYTES),
                            (TB,"MPPC compression estimate above 1.0 (%u)",
                            CompEst));
                    scMPPCCompTotal = 0;
                    scMPPCUncompTotal = 0;

                    if (CompEst < SCH_COMP_LIMIT)
                        CompEst = SCH_COMP_LIMIT;

                    m_pShm->sch.MPPCCompressionEst = CompEst;
                    TRC_NRM((TB, "New MPPC compr estimate %u", CompEst));
                }

                compressResult |= m_pTSWd->bFlushed;
                m_pTSWd->bFlushed = 0;
            }
            else if (compressResult & PACKET_FLUSHED) {
                // Overran compression history, copy over the original
                // uncompressed buffer.
                m_pTSWd->bFlushed = PACKET_FLUSHED;
                memcpy(pPktHdr + scUpdatePDUHeaderSpace, pSrcBuf,
                       cbLen - scUpdatePDUHeaderSpace);
                m_pTSWd->pProtocolStatus->Output.CompressFlushes++;
            }
            else {
                TRC_ALT((TB, "Compression FAILURE"));
            }
        }
        else {
            // This packet is too small or too big, copy over the header and
            // uncompressed data.
            memcpy((UCHAR *)pPkgInfo->pOutBuf + pPkgInfo->cbInUse,
                   pPktHdr, cbLen);
            pPktHdr = (UCHAR *)pPkgInfo->pOutBuf + pPkgInfo->cbInUse;
        }
    }

    // Fill in the header based on whether we're using fast-path.
    if (scUseFastPathOutput) {
        if (m_pTSWd->bCompress) {
            // Set up compression flags if we're compressing, whether
            // or not the compression succeeded above.
            pPktHdr[1] = compressResult;

            // Size is the size of the payload after this header.
            *((PUINT16_UA)(pPktHdr + 2)) = (UINT16)CompressedSize;
        }
        else {
            // Size is the size of the payload after this header.
            *((PUINT16_UA)(pPktHdr + 1)) = (UINT16)CompressedSize;
        }
    }
    else {
        TS_SHAREDATAHEADER UNALIGNED *pHdr;

        pHdr = (TS_SHAREDATAHEADER UNALIGNED *)pPktHdr;

        // Fill in the Share control header.
        pHdr->shareControlHeader.totalLength = (TSUINT16)
                (CompressedSize + scUpdatePDUHeaderSpace);
        pHdr->shareControlHeader.pduType = TS_PDUTYPE_DATAPDU |
                TS_PROTOCOL_VERSION;
        pHdr->shareControlHeader.pduSource = (TSUINT16)scUserID;

        // Fill in the Share data header.
        pHdr->shareID               = scShareID;
        pHdr->streamID              = PROT_PRIO_MISC;
        pHdr->uncompressedLength    = (UINT16)cbLen;
        pHdr->generalCompressedType = (compressResult | m_pTSWd->bFlushed);
        pHdr->generalCompressedLength = (TSUINT16)(m_pTSWd->bCompress ?
                CompressedSize + scUpdatePDUHeaderSpace : 0);
    }

    // Advance the usage size past the header and compressed or
    // uncompressed data.
    pPkgInfo->cbInUse += CompressedSize + scUpdatePDUHeaderSpace;
    TRC_ASSERT((pPkgInfo->cbInUse <= pPkgInfo->cbLen),
            (TB,"Overflowed package!"));

    m_pTSWd->pProtocolStatus->Output.CompressedBytes += CompressedSize +
            scUpdatePDUHeaderSpace;

#ifdef DC_HICOLOR
    // If shadowing, we need to save this data so that the shadow stack can
    // duplicate it.
    if ((m_pTSWd->shadowState == SHADOW_TARGET) && bShadow)
    {
        if (m_pTSWd->pShadowInfo)
        {
            ULONG dataSize = CompressedSize +
                             scUpdatePDUHeaderSpace + sizeof(SHADOW_INFO) - 1;


            // If we've not started on the extra space, see if this will fit
            // in the main space
            if ((m_pTSWd->pShadowInfo->messageSizeEx == 0) &&
                (m_pTSWd->pShadowInfo->messageSize + dataSize)
                                                      <= WD_MAX_SHADOW_BUFFER)
            {
                memcpy(&m_pTSWd->pShadowInfo->data[m_pTSWd->pShadowInfo->messageSize],
                       pPktHdr,
                       CompressedSize + scUpdatePDUHeaderSpace);

                TRC_NRM((TB, "Saving shadow data buffer[%ld] += %ld",
                        m_pTSWd->pShadowInfo->messageSize,
                        CompressedSize + scUpdatePDUHeaderSpace));

                m_pTSWd->pShadowInfo->messageSize += CompressedSize +
                                                        scUpdatePDUHeaderSpace;

            }
            // Nope - will it fit in the extra buffer?
            else if ((m_pTSWd->pShadowInfo->messageSizeEx + dataSize)
                                                      <= WD_MAX_SHADOW_BUFFER)
            {
                TRC_ALT((TB, "Using extra shadow space..."));
                memcpy(&m_pTSWd->pShadowInfo->data[WD_MAX_SHADOW_BUFFER
                                       + m_pTSWd->pShadowInfo->messageSizeEx],
                       pPktHdr,
                       CompressedSize + scUpdatePDUHeaderSpace);

                TRC_NRM((TB, "Saving shadow data bufferEx[%ld] += %ld",
                        m_pTSWd->pShadowInfo->messageSizeEx,
                        CompressedSize + scUpdatePDUHeaderSpace));

                m_pTSWd->pShadowInfo->messageSizeEx += CompressedSize +
                                                        scUpdatePDUHeaderSpace;
            }
            else
            {
                TRC_ERR((TB, "Shadow buffer too small: %p[%ld/%ld] + %ld = %ld/%ld",
                        m_pTSWd->pShadowInfo->data,
                        m_pTSWd->pShadowInfo->messageSizeEx,
                        m_pTSWd->pShadowInfo->messageSize,
                        CompressedSize + scUpdatePDUHeaderSpace,
                        m_pTSWd->pShadowInfo->messageSize + cbLen,
                        m_pTSWd->pShadowInfo->messageSizeEx + cbLen));
            }
        }
    }
#else

    // If shadowing, we need to save this data so that the shadow stack can
    // duplicate it.
    if ((m_pTSWd->shadowState == SHADOW_TARGET) && bShadow) {
        if (m_pTSWd->pShadowInfo &&
                ((m_pTSWd->pShadowInfo->messageSize + cbLen +
                sizeof(SHADOW_INFO) - 1) <= WD_MAX_SHADOW_BUFFER)) {
            memcpy(&m_pTSWd->pShadowInfo->data[m_pTSWd->pShadowInfo->messageSize],
                    pPktHdr, CompressedSize + scUpdatePDUHeaderSpace);
            m_pTSWd->pShadowInfo->messageSize += CompressedSize +
                    scUpdatePDUHeaderSpace;
            TRC_NRM((TB, "Saving shadow data buffer[%ld] += %ld",
                    m_pTSWd->pShadowInfo->messageSize - CompressedSize -
                    scUpdatePDUHeaderSpace,
                    CompressedSize + scUpdatePDUHeaderSpace));
        }
        else {
            TRC_ERR((TB, "Shadow buffer too small: %p[%ld] + %ld = %ld",
                    m_pTSWd->pShadowInfo->data,
                    m_pTSWd->pShadowInfo->messageSize,
                    CompressedSize + scUpdatePDUHeaderSpace,
                    m_pTSWd->pShadowInfo->messageSize + cbLen));
        }
    }
#endif

    DC_END_FN();
} /* SC_AddToPackage */


/****************************************************************************/
/* SC_FlushPackage                                                          */
/*                                                                          */
/* Purpose:   Send any remaining data, or free the buffer if allocated      */
/*                                                                          */
/* Params:    pPkgInfo - pointer to package info                            */
/****************************************************************************/
void RDPCALL SHCLASS SC_FlushPackage(PPDU_PACKAGE_INFO pPkgInfo)
{
    DC_BEGIN_FN("SC_FlushPackage");

    /************************************************************************/
    /* If there's anything there, send it                                   */
    /************************************************************************/
    if (pPkgInfo->cbInUse > 0) {
        // Send the package contents.
        if (scUseFastPathOutput)
            // Send directly to SM with fast-path flag.
            SM_SendData(scPSMHandle, (PVOID)pPkgInfo->pOutBuf,
                    pPkgInfo->cbInUse, TS_HIGHPRIORITY, 0, TRUE, RNS_SEC_ENCRYPT, FALSE);
        else
            SC_SendData((PTS_SHAREDATAHEADER)pPkgInfo->pOutBuf,
                    pPkgInfo->cbInUse, 0, PROT_PRIO_MISC, 0);
    }

    /************************************************************************/
    /* If there's nothing in use but a buffer has been allocated, then free */
    /* it                                                                   */
    /************************************************************************/
    else if ((pPkgInfo->cbLen != 0) && (pPkgInfo->pBuffer != NULL))
        SC_FreeBuffer(pPkgInfo->pOutBuf);

    // Reset the package info.
    pPkgInfo->cbLen   = 0;
    pPkgInfo->cbInUse = 0;
    pPkgInfo->pBuffer = NULL;
    pPkgInfo->pOutBuf = NULL;

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SC_UpdateShm                                                  */
/*                                                                          */
/* Purpose:   Update the Shm data with sc data                              */
/****************************************************************************/
void RDPCALL SHCLASS SC_UpdateShm(void)
{
    DC_BEGIN_FN("SC_UpdateShm");

    m_pShm->bc.noBitmapCompressionHdr = scNoBitmapCompressionHdr;

    DC_END_FN();
}

//
// Accessor for scUseAutoReconnect
// returns TRUE if we can autoreconnect
//
BOOL RDPCALL SHCLASS SC_IsAutoReconnectEnabled()
{
    DC_BEGIN_FN("SC_IsAutoReconnectEnabled");

    DC_END_FN();
    return scUseAutoReconnect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ascdata.c ===
/****************************************************************************/
// ascdata.c
//
// Share Controller data.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ndcgdata.h>


// The current state.
DC_DATA(unsigned, scState, SCS_STARTED);

// Array of information about the parties in the share, indexed by localID.
DC_DATA_ARRAY_NULL(SC_PARTY_INFO, scPartyArray, SC_DEF_MAX_PARTIES, NULL);


// The number of parties in the current share, including the local party.
DC_DATA(unsigned, scNumberInShare, 0);

// Fastpath input/output for SC_NetworkIDToLocalID().
DC_DATA(NETPERSONID,   scLastNetID, 0);
DC_DATA(LOCALPERSONID, scLastLocID, 0);

// User ID, Share ID & Share generation number.
DC_DATA(UINT32, scUserID,     0);
DC_DATA(UINT32, scShareID,    0);
DC_DATA(UINT32, scGeneration, 0);

// SM Handle.
DC_DATA(PVOID, scPSMHandle, NULL);

// Local SC data that indicates if client supports no BC header or not.
DC_DATA(UINT16, scNoBitmapCompressionHdr, TS_EXTRA_NO_BITMAP_COMPRESSION_HDR);

// Whether all clients and server support fast-path output.
DC_DATA(BOOLEAN, scUseFastPathOutput, FALSE);

// Whether compression will be used during shadow
DC_DATA(BOOLEAN, scUseShadowCompression, FALSE);

// Whether Clients support long credentials (Username, domain and password)
DC_DATA(BOOLEAN, scUseLongCredentials, FALSE);

// Whether we should send periodic autoreconnect cookie updates (only when
// other data is being sent)
DC_DATA(BOOLEAN, scEnablePeriodicArcUpdate, FALSE);

// Whether autoreconnect is enabled (Iff capabilities and policy say it's ok)
DC_DATA(BOOLEAN, scUseAutoReconnect, FALSE);

// Compression-used flag value and size of the compression flags field
// (0 or 1) that will be used when creating fast-path output update PDUs.
DC_DATA(BYTE, scCompressionUsedValue, TS_OUTPUT_FASTPATH_COMPRESSION_USED);

// Size for update order packaging code to reserve for headers -- different
// based on whether we're using fast-path output and whther compression is
// in use.
DC_DATA(unsigned, scUpdatePDUHeaderSpace, 0);

// MPPC compressor compression ratio tallies.
DC_DATA(unsigned, scMPPCCompTotal, 0);
DC_DATA(unsigned, scMPPCUncompTotal, 0);

// Default OutBuf allocation sizes and usable space.
DC_DATA(unsigned, sc8KOutBufUsableSpace, 0);
DC_DATA(unsigned, sc16KOutBufUsableSpace, 0);


// The SC state table.
DC_CONST_DATA_2D_ARRAY(BYTE, scStateTable, SC_NUM_EVENTS, SC_NUM_STATES,
  DC_STRUCT17(
/****************************************************************************/
/* This state table simply shows which events are valid in which states.    */
/*                                                                          */
/* Values mean                                                              */
/*                                                                          */
/* - 0 event OK in this state.                                              */
/*                                                                          */
/* - 1 warning - event should not occur in this state, but does in          */
/*     some race conditions - ignore it.                                    */
/*                                                                          */
/* - 2 error - event should not occur in ths state at all.                  */
/*                                                                          */
/* These values are hard-coded here in ordeer to make the table readable.   */
/* They correspond to the constants SC_TABLE_OK, SC_TABLE_WARN &            */
/* SC_TABLE_ERROR.                                                          */
/****************************************************************************/
/* The events and states are defined in ascint.h.  The events are           */
/* prefixed with SCE and the states are prefixed with SCS                   */
/*                                                                          */
/*            Started                                                       */
/*            |    Initialized                                              */
/*            |    |    ShareStarting                                       */
/*            |    |    |    InShare                                        */
/*            |    |    |    |                                              */
/*            0    1    2    3                                              */
/****************************************************************************/
DC_STRUCT4(   0,   2,   2,   2 ),   /* INIT                                 */
DC_STRUCT4(   2,   0,   0,   0 ),   /* TERM                                 */
DC_STRUCT4(   1,   0,   1,   1 ),   /* CREATE_SHARE                         */
DC_STRUCT4(   2,   1,   0,   0 ),   /* END_SHARE                            */
DC_STRUCT4(   2,   2,   0,   0 ),   /* CONFIRM_ACTIVE                       */
DC_STRUCT4(   1,   1,   1,   0 ),   /* DETACH_USER                          */

DC_STRUCT4(   2,   2,   2,   0 ),   /* INITIATESYNC                         */
DC_STRUCT4(   2,   1,   0,   0 ),   /* CONTROLPACKET                        */
DC_STRUCT4(   2,   1,   1,   0 ),   /* DATAPACKET                           */
DC_STRUCT4(   2,   2,   0,   0 ),   /* GETMYNETWORKPERSONID                 */
DC_STRUCT4(   2,   1,   1,   0 ),   /* GETREMOTEPERSONDETAILS               */
DC_STRUCT4(   2,   1,   1,   0 ),   /* GETLOCALPERSONDETAILS                */
DC_STRUCT4(   2,   1,   1,   0 ),   /* PERIODIC                             */
DC_STRUCT4(   2,   2,   0,   0 ),   /* LOCALIDTONETWORKID                   */
DC_STRUCT4(   2,   2,   0,   0 ),   /* NETWORKIDTOLOCALID                   */
DC_STRUCT4(   2,   1,   0,   0 ),   /* ISLOCALPERSONID                      */
DC_STRUCT4(   2,   1,   0,   0 )    /* ISNETWORKPERSONID                    */

));


#ifdef DC_DEBUG
// State and event descriptions (debug build only).
DC_CONST_DATA_2D_ARRAY(char, scStateName, SC_NUM_STATES, 25,
  DC_STRUCT4(
    "SCS_STARTED",
    "SCS_INITED",
    "SCS_SHARE_STARTING",
    "SCS_IN_SHARE") );

DC_CONST_DATA_2D_ARRAY(char, scEventName, SC_NUM_EVENTS, 35,
  DC_STRUCT17(
    "SCE_INIT",
    "SCE_TERM",
    "SCE_CREATE_SHARE",
    "SCE_END_SHARE",
    "SCE_CONFIRM_ACTIVE",
    "SCE_DETACH_USER",
    "SCE_INITIATESYNC",
    "SCE_CONTROLPACKET",
    "SCE_DATAPACKET",
    "SCE_GETMYNETWORKPERSONID",
    "SCE_GETREMOTEPERSONDETAILS",
    "SCE_GETLOCALPERSONDETAILS",
    "SCE_PERIODIC",
    "SCE_LOCALIDTONETWORKID",
    "SCE_NETWORKIDTOLOCALID",
    "SCE_ISLOCALPERSONID",
    "SCE_ISNETWORKPERSONID") );

// Packet descriptions (debug only).
DC_CONST_DATA_2D_ARRAY(char, scPktName, 26, 42,
  DC_STRUCT26(
    "Unknown",
    "TS_PDUTYPE2_UPDATE",
    "TS_PDUTYPE2_FONT",
    "TS_PDUTYPE2_CONTROL",
    "TS_PDUTYPE2_WINDOWACTIVATION",
    "TS_PDUTYPE2_WINDOWLISTUPDATE",
    "TS_PDUTYPE2_APPLICATION",
    "TS_PDUTYPE2_DESKTOP_SCROLL",
    "TS_PDUTYPE2_MEDIATEDCONTROL",
    "TS_PDUTYPE2_INPUT",
    "TS_PDUTYPE2_MEDIATEDCONTROL",
    "TS_PDUTYPE2_REMOTESHARE",
    "TS_PDUTYPE2_SYNCHRONIZE",
    "TS_PDUTYPE2_UPDATECAPABILITY",
    "TS_PDUTYPE2_REFRESH_RECT",
    "TS_PDUTYPE2_PLAY_BEEP",
    "TS_PDUTYPE2_SUPPRESS_OUTPUT",
    "TS_PDUTYPE2_SHUTDOWN_REQUEST",
    "TS_PDUTYPE2_SHUTDOWN_DENIED",
    "TS_PDUTYPE2_SAVE_SESSION_INFO",
    "TS_PDUTYPE2_FONTLIST",
    "TS_PDUTYPE2_FONTMAP",
    "TS_PDUTYPE2_SET_KEYBOARD_INDICATORS",
    "TS_PDUTYPE2_CLIP",
    "TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST",
    "TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU"
));
#endif /* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asmapi.c ===
/****************************************************************************/
/* asmapi.c                                                                 */
/*                                                                          */
/* Security Manager API                                                     */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "asmapi"
#define pTRCWd (pRealSMHandle->pWDHandle)

#include <adcg.h>
#include <aprot.h>
#include <acomapi.h>
#include <nwdwapi.h>
#include <anmapi.h>
#include <asmint.h>
#include <slicense.h>
#include <regapi.h>

#define DC_INCLUDE_DATA
#include <asmdata.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
/* Name:      SM_GetDataSize                                                */
/*                                                                          */
/* Purpose:   Returns size of per-instance SM data required                 */
/*                                                                          */
/* Returns:   size of data required                                         */
/*                                                                          */
/* Operation: SM stores per-instance data in a piece of memory allocated    */
/*            by WDW.  This function returns the size of the data required. */
/*            A pointer to this data (the 'SM Handle') is passed into all   */
/*            subsequent SM functions.                                      */
/****************************************************************************/
unsigned RDPCALL SM_GetDataSize(void)
{
    DC_BEGIN_FN("SM_GetDataSize");

    DC_END_FN();
    return(sizeof(SM_HANDLE_DATA) + NM_GetDataSize());
} /* SM_GetDataSize */


/****************************************************************************/
/* Name:      SM_GetEncryptionMethods                                       */
/*                                                                          */
/* Purpose:   Return the security settings supported by this server for use */
/*            in shadowing operations.  The shadow target server dictates   */
/*            the final selected method & level.                            */
/*                                                                          */
/* Params:    pSMHandle  - SM handle                                        */
/****************************************************************************/
VOID RDPCALL SM_GetEncryptionMethods(PVOID pSMHandle, PRNS_UD_CS_SEC pSecurityData)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    ULONG ulMethods ;

    DC_BEGIN_FN("SM_SM_GetEncryptionMethods");

    // Allow a FIPS shadow client to remote control servers with lesser
    // encryption strength
    ulMethods = pRealSMHandle->encryptionMethodsSupported;
    if (ulMethods & SM_FIPS_ENCRYPTION_FLAG) {
        ulMethods |= (SM_128BIT_ENCRYPTION_FLAG | SM_40BIT_ENCRYPTION_FLAG | SM_56BIT_ENCRYPTION_FLAG);
        TRC_ALT((TB, "Allow FIPS client to shadow a lower security target: %lx",
                ulMethods));
    }
    else {
        // Allow a 128-bit shadow client to remote control servers with lesser
        // encryption strength
        if (ulMethods & SM_128BIT_ENCRYPTION_FLAG) {
            ulMethods |= (SM_40BIT_ENCRYPTION_FLAG | SM_56BIT_ENCRYPTION_FLAG);
            TRC_ALT((TB, "Allow 128-bit client to shadow a lower security target: %lx",
                    ulMethods));
        }
    }

    if( !pRealSMHandle->frenchClient ) {
        pSecurityData->encryptionMethods = ulMethods;
        pSecurityData->extEncryptionMethods = 0;

    }
    else {
        pSecurityData->encryptionMethods = 0;
        pSecurityData->extEncryptionMethods = ulMethods;
    }

    DC_END_FN();
    return;
}

/****************************************************************************/
/* Name:      SM_GetDefaultSecuritySettings                                 */
/*                                                                          */
/* Purpose:   Returns the security settings supported by this server        */
/*            for shadowing operations.                                     */
/*                                                                          */
/* Params:    pClientSecurityData - GCC user data identical to a standard   */
/*            conference connection.                                        */
/****************************************************************************/
NTSTATUS RDPCALL SM_GetDefaultSecuritySettings(PRNS_UD_CS_SEC pClientSecurityData)
{
    pClientSecurityData->header.type = RNS_UD_CS_SEC_ID;
    pClientSecurityData->header.length = sizeof(*pClientSecurityData);

    pClientSecurityData->encryptionMethods =
        SM_40BIT_ENCRYPTION_FLAG |
        SM_56BIT_ENCRYPTION_FLAG |
        SM_128BIT_ENCRYPTION_FLAG |
        SM_FIPS_ENCRYPTION_FLAG;

    pClientSecurityData->extEncryptionMethods = 0;

    return STATUS_SUCCESS;
}

/****************************************************************************/
/* Name:      SM_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize SM                                                 */
/*                                                                          */
/* Params:    pSMHandle  - SM handle                                        */
/*            pWDHandle  - WD Handle (to be passed back on WDW_SMCallback)  */
/****************************************************************************/
NTSTATUS RDPCALL SM_Init(PVOID      pSMHandle,
                         PTSHARE_WD pWDHandle,
                         BOOLEAN    bOldShadow)
{
    BOOL rc;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    unsigned i;
    unsigned regRc;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    INT32 regValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    static UINT32 keyInfoBuffer[16];
    ULONG keyInfoLength;
    HANDLE RegistryKeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    DC_BEGIN_FN("SM_Init");

    SM_CHECK_STATE(SM_EVT_INIT);

    /************************************************************************/
    /* Store the WDW Handle before we do anything else, as we can't trace   */
    /* until we do so.                                                      */
    /************************************************************************/
    pRealSMHandle->pWDHandle = pWDHandle;
    pRealSMHandle->bForwardDataToSC = FALSE;

    /************************************************************************/
    /* Get default DONTDISPLAYLASTUSERNAME setting                          */
    /************************************************************************/
    pWDHandle->fDontDisplayLastUserName = FALSE;

    RtlInitUnicodeString(&UnicodeString, W2K_GROUP_POLICY_WINLOGON_KEY);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
    
    status = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&UnicodeString, WIN_DONTDISPLAYLASTUSERNAME);
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)keyInfoBuffer;
        status = ZwQueryValueKey(RegistryKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(keyInfoBuffer),
                                 &keyInfoLength);

        //    For W2K the value should be a DWORD.
        if ((NT_SUCCESS(status)) && 
            (KeyValueInformation->Type == REG_DWORD) &&
            (KeyValueInformation->DataLength >= sizeof(DWORD))) {
                pWDHandle->fDontDisplayLastUserName =
                    (BOOLEAN)(*(PDWORD)(KeyValueInformation->Data) == 1);
        }

        ZwClose(RegistryKeyHandle);
    }
    
    //    Starting with W2K the place where the DontDislpayLastUserName policy
    //    is store has moved to another key (W2K_GROUP_POLICY_WINLOGON_KEY). But
    //    we still have to look at the old key in case we could not read the 
    //    value in the post W2K key (the policy is not definde). We want to follow  
    //    the winlogon behavior in the console. 
    //    In case there is a value set in the new policy key we will use that
    //    value. In case there isn't one we look in the old place. As I said this
    //    is what winlogon does.
    //
    if (!NT_SUCCESS(status)) {
        RtlInitUnicodeString(&UnicodeString, WINLOGON_KEY);
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        status = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);
        if (NT_SUCCESS(status)) {
            RtlInitUnicodeString(&UnicodeString, WIN_DONTDISPLAYLASTUSERNAME);
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)keyInfoBuffer;
            status = ZwQueryValueKey(RegistryKeyHandle,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     KeyValueInformation,
                                     sizeof(keyInfoBuffer),
                                     &keyInfoLength);
            if (NT_SUCCESS(status)) {
                pWDHandle->fDontDisplayLastUserName =
                    (BOOLEAN)(KeyValueInformation->Data[0] == '1');
            }

            ZwClose(RegistryKeyHandle);
        }
    }

    
    /************************************************************************/
    /* We don't run without encryption  in a retail build                   */
    /************************************************************************/

    TRC_NRM((TB, "encryption level is %d", pRealSMHandle->encryptionLevel));

    if (pRealSMHandle->encryptionLevel < 1)
    {
        TRC_ALT((TB, "Forcing encryption back to level 1!"));
        pRealSMHandle->encryptionLevel = 1;
    }    

#ifdef INSTRUM_TRACK_DISCARDED
    pRealSMHandle->nDiscardNonVCPDUWhenDead = 0;
    pRealSMHandle->nDiscardPDUBadState = 0;
    pRealSMHandle->nDiscardVCDataWhenDead = 0;
#endif

    if (pRealSMHandle->encryptionLevel == 0) {
        TRC_ALT((TB, "Not encrypting"));

        pRealSMHandle->encryptionMethodsSupported = 0;
        pRealSMHandle->encrypting = FALSE;
        pRealSMHandle->encryptDisplayData = FALSE;
        pRealSMHandle->encryptingLicToClient = FALSE;
        pRealSMHandle->encryptionMethodSelected = 0;
        pRealSMHandle->frenchClient = FALSE;
        pRealSMHandle->recvdClientRandom = FALSE;
        pRealSMHandle->bSessionKeysMade = FALSE;
        pRealSMHandle->encryptHeaderLen = 0;
        pRealSMHandle->encryptHeaderLenIfForceEncrypt = sizeof(RNS_SECURITY_HEADER1);
    }
    else {
        pRealSMHandle->encrypting = TRUE;
        pRealSMHandle->frenchClient = FALSE;
        TRC_NRM((TB, "Encrypting"));

        /********************************************************************/
        /* encrypt the display data if encryptionLevel is 2 (or above).     */
        /********************************************************************/
        if (pRealSMHandle->encryptionLevel == 1) {
            pRealSMHandle->encryptDisplayData = FALSE;
            pRealSMHandle->encryptHeaderLen = sizeof(RNS_SECURITY_HEADER);
            pRealSMHandle->encryptHeaderLenIfForceEncrypt = sizeof(RNS_SECURITY_HEADER1);
            TRC_NRM((TB, "Displaydata not encrypted"));
        }
        else {
            pRealSMHandle->encryptDisplayData = TRUE;
            pRealSMHandle->encryptHeaderLen = sizeof(RNS_SECURITY_HEADER1);
        }

        /********************************************************************/
        /* for down level compatibility, support both 40bit, 56bit          */
        /* and 128bit default.                                              */
        /********************************************************************/
        pRealSMHandle->encryptionMethodsSupported =
            SM_128BIT_ENCRYPTION_FLAG |
            SM_56BIT_ENCRYPTION_FLAG |
            SM_40BIT_ENCRYPTION_FLAG |
            SM_FIPS_ENCRYPTION_FLAG;
         
        /********************************************************************/
        /* encrypt 128bit and above if encryptionLevel is 3                 */
        /********************************************************************/
        if (pRealSMHandle->encryptionLevel == 3) {
                pRealSMHandle->encryptionMethodsSupported =
                    SM_128BIT_ENCRYPTION_FLAG | SM_FIPS_ENCRYPTION_FLAG;
        }

        /********************************************************************/
        /* encrypt in FIPS only if encryption level is 4 or above.     */
        /********************************************************************/
        if (pRealSMHandle->encryptionLevel >= 4) {
            pRealSMHandle->encryptionMethodsSupported = SM_FIPS_ENCRYPTION_FLAG;
        } 

        TRC_NRM((TB, "Encryption methods supported %08lx: Level %ld\n",
                 pRealSMHandle->encryptionMethodsSupported,
                 pRealSMHandle->encryptionLevel));

        /********************************************************************/
        /* initally set the encryption method selected as                   */
        /* SM_56BIT_ENCRYPTION_FLAG, later it will be set according to the  */
        /* client support.                                                  */
        /********************************************************************/
        pRealSMHandle->encryptionMethodSelected = SM_56BIT_ENCRYPTION_FLAG;

        /********************************************************************/
        /* misc init.                                                       */
        /********************************************************************/
        pRealSMHandle->recvdClientRandom = FALSE;
        pRealSMHandle->bSessionKeysMade = FALSE;
    }

    /************************************************************************/
    /* We do not know the certificate type used in the key exchange till    */
    /* after the exchange has taken place.                                  */
    /************************************************************************/
    pRealSMHandle->CertType = CERT_TYPE_INVALID;

#ifdef USE_LICENSE
    /************************************************************************/
    /* Initialize the Server license manager                                */
    /************************************************************************/
    pRealSMHandle->pLicenseHandle = SLicenseInit();
    if (!pRealSMHandle->pLicenseHandle)
    {
        TRC_ERR((TB, "Failed to initialize License Manager"));
        DC_QUIT;
    }
    pWDHandle->pSLicenseHandle = pRealSMHandle->pLicenseHandle;
#endif

    /************************************************************************/
    /* Initialize the console buffer stuff                                  */
    /************************************************************************/
    InitializeListHead(&pRealSMHandle->consoleBufferList);
    pRealSMHandle->consoleBufferCount = 0;

    /************************************************************************/
    /* Finally, initialize the Network Manager                              */
    /************************************************************************/
    rc = NM_Init(pRealSMHandle->pWDHandle->pNMInfo,
                 pSMHandle,
                 pWDHandle,
                 pWDHandle->hDomainKernel);
    if (!rc)
    {
        TRC_ERR((TB, "Failed to init NM"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
    SM_SET_STATE(SM_STATE_INITIALIZED);

    /************************************************************************/
    /* All worked                                                           */
    /************************************************************************/
    status = STATUS_SUCCESS;

DC_EXIT_POINT:

    /************************************************************************/
    /* If anything failed, clean up.  Must be done after calling            */
    /* FreeContextBuffer as this clears the function table.                 */
    /************************************************************************/
    if (!NT_SUCCESS(status))
    {
        TRC_ERR((TB, "Something failed - clean up"));
        SMFreeInitResources(pRealSMHandle);
    }

    DC_END_FN();
    return(status);
} /* SM_Init */


/****************************************************************************/
/* Name:      SM_Term                                                       */
/****************************************************************************/
void RDPCALL SM_Term(PVOID pSMHandle)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    DC_BEGIN_FN("SM_Term");

    /************************************************************************/
    /* SM_Term is called from WD_Close.  This can be called on the          */
    /* listening stack (and maybe in other situations) where SM_Init has    */
    /* not been called.  Check for state != SM_STATE_STARTED before going   */
    /* any further.                                                         */
    /*                                                                      */
    /* AND DON'T TRACE IF SM_INIT HASN'T BEEN CALLED.                       */
    /************************************************************************/
    if (pRealSMHandle->state == SM_STATE_STARTED)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Free connection resources                                            */
    /************************************************************************/
    TRC_NRM((TB, "Free connection resources"));
    SMFreeConnectResources(pRealSMHandle);

    /************************************************************************/
    /* Free initialization resources                                        */
    /************************************************************************/
    TRC_NRM((TB, "Free initialization resources"));
    SMFreeInitResources(pRealSMHandle);

#ifdef USE_LICENSE
    /************************************************************************/
    /* Terminate License Manager                                            */
    /************************************************************************/
    SLicenseTerm(pRealSMHandle->pLicenseHandle);
#endif

    /************************************************************************/
    /* Terminate Network Manager                                            */
    /************************************************************************/
    NM_Term(pRealSMHandle->pWDHandle->pNMInfo);

    /************************************************************************/
    /* Terminate FIPS                                                       */
    /************************************************************************/
    TSFIPS_Term(&(pRealSMHandle->FIPSData));

    /************************************************************************/
    /* Free the console buffers                                             */
    /************************************************************************/
    while (!IsListEmpty(&pRealSMHandle->consoleBufferList)) {
        PSM_CONSOLE_BUFFER pBlock;

        pBlock = CONTAINING_RECORD(pRealSMHandle->consoleBufferList.Flink, SM_CONSOLE_BUFFER, links);

        RemoveEntryList(&pBlock->links);

        COM_Free(pBlock);
    };

    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
    SM_SET_STATE(SM_STATE_STARTED);

DC_EXIT_POINT:
    DC_END_FN();
} /* SM_Term */


/****************************************************************************/
/* Name:      SM_Connect                                                    */
/*                                                                          */
/* Purpose:   Accept or Reject an incoming Client                           */
/*                                                                          */
/* Returns:   TRUE  - Connect started OK                                    */
/*            FALSE - Connect failed to start                               */
/*                                                                          */
/* Params:    ppSMHandle    - handle for subsequent SM calls on behalf of   */
/*                            this Client                                   */
/*            pUserDataIn   - SM user data received from Client             */
/*            pNetUserData  - Net user data received from Client            */
/*            bOldShadow    - indicates this is a B3 shadow request         */
/*                                                                          */
/* Operation: Note that this function completes asynchronously.  The caller */
/*            must wait for an SM_CB_CONNECTED or SM_CB_DISCONNECTED        */
/*            callback to find out whether the Connect succeeded or failed. */
/****************************************************************************/
NTSTATUS RDPCALL SM_Connect(PVOID          pSMHandle,
                            PRNS_UD_CS_SEC pUserDataIn,
                            PRNS_UD_CS_NET pNetUserData,
                            BOOLEAN        bOldShadow)
{
    NTSTATUS status = STATUS_SUCCESS;
    BOOL rc = FALSE;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    UINT32 encMethodPicked = 0;

    DC_BEGIN_FN("SM_Connect");

    SM_CHECK_STATE(SM_EVT_CONNECT);

    pRealSMHandle->pUserData = NULL;

    /************************************************************************/
    /* pick a matching encryption method.                                   */
    /************************************************************************/
    TRC_ALT((TB, "Client supports encryption: %lx",
             pUserDataIn->encryptionMethods));
    TRC_NRM((TB, "Server supports encryption: %lx",
             pRealSMHandle->encryptionMethodsSupported));

    /************************************************************************/
    /* if the server does not require any encryption ..                     */
    /************************************************************************/
    if( pRealSMHandle->encryptionMethodsSupported == 0 ) {

        encMethodPicked = 0;
        goto DC_ENC_PICKED;
    }

    //
    // French Client (old and new) set the encryptionMethods value 0.
    //

    if (pUserDataIn->encryptionMethods == 0) {

        pRealSMHandle->frenchClient = TRUE;

        //
        // check to see the request is from a new client, if so
        // use the new field to set the appropriate encryption level.
        //

        if( pUserDataIn->header.length >= sizeof(RNS_UD_CS_SEC) ) {

            pUserDataIn->encryptionMethods = pUserDataIn->extEncryptionMethods;
        }
        else {

            //
            // force old client to use 40-bit encryption.
            //

            pUserDataIn->encryptionMethods = SM_40BIT_ENCRYPTION_FLAG;
        }

        /************************************************************************/
        /* pick a matching encryption method.                                   */
        /************************************************************************/
        TRC_ALT((TB, "French Client supports encryption: %lx",
                 pUserDataIn->encryptionMethods));
    }

    /************************************************************************/
    /* if the client only supports FIPS                                     */
    /************************************************************************/
    if (pUserDataIn->encryptionMethods == SM_FIPS_ENCRYPTION_FLAG) {
        /********************************************************************/
        /* if the server supports FIPS ....                                 */
        /********************************************************************/
        if (pRealSMHandle->encryptionMethodsSupported & SM_FIPS_ENCRYPTION_FLAG) {
            encMethodPicked = SM_FIPS_ENCRYPTION_FLAG;
            goto DC_ENC_PICKED;
        }
    }

    /********************************************************************/
    /* if the server only supports FIPS ....                            */
    /********************************************************************/
    if (pRealSMHandle->encryptionMethodsSupported == SM_FIPS_ENCRYPTION_FLAG) {
        /************************************************************************/
        /* if the client supports FIPS                                       */
        /************************************************************************/
        if (pUserDataIn->encryptionMethods & SM_FIPS_ENCRYPTION_FLAG) {
            encMethodPicked = SM_FIPS_ENCRYPTION_FLAG;
            goto DC_ENC_PICKED;
        }
    }

    /************************************************************************/
    /* if the client supports 128 bit                                       */
    /************************************************************************/
    if (pUserDataIn->encryptionMethods & SM_128BIT_ENCRYPTION_FLAG) {
        /********************************************************************/
        /* if the server supports 128bit ....                               */
        /********************************************************************/
        if (pRealSMHandle->encryptionMethodsSupported &
                SM_128BIT_ENCRYPTION_FLAG) {
            encMethodPicked = SM_128BIT_ENCRYPTION_FLAG;
            goto DC_ENC_PICKED;
        }
    }

    /************************************************************************/
    /* if the client supports 56 bit                                        */
    /************************************************************************/
    if( pUserDataIn->encryptionMethods & SM_56BIT_ENCRYPTION_FLAG ) {
        /********************************************************************/
        /* if the server supports 56bit ...                                 */
        /********************************************************************/
        if( pRealSMHandle->encryptionMethodsSupported &
                SM_56BIT_ENCRYPTION_FLAG ) {
            encMethodPicked = SM_56BIT_ENCRYPTION_FLAG;
            goto DC_ENC_PICKED;
        }
    }

    /************************************************************************/
    /* if the client supports 40 bit                                        */
    /************************************************************************/
    if( pUserDataIn->encryptionMethods & SM_40BIT_ENCRYPTION_FLAG ) {
        /********************************************************************/
        /* if the server supports 40bit ...                                 */
        /********************************************************************/
        if( pRealSMHandle->encryptionMethodsSupported &
                SM_40BIT_ENCRYPTION_FLAG ) {
            encMethodPicked = SM_40BIT_ENCRYPTION_FLAG;
            goto DC_ENC_PICKED;
        }
    }

    /************************************************************************/
    /* if we are here, we did not find a match                              */
    /************************************************************************/
    TRC_ERR((TB, "Failed to match encryption package: %lx",
             pUserDataIn->encryptionMethods));
    status = STATUS_ENCRYPTION_FAILED;

    /****************************************************************/
    /* Log an error and disconnect the Client                       */
    /****************************************************************/
    if (pRealSMHandle->pWDHandle->StackClass == Stack_Primary) {
        WDW_LogAndDisconnect(
            pRealSMHandle->pWDHandle, TRUE, 
            Log_RDP_ENC_EncPkgMismatch,
            NULL,
            0);

    }
    DC_QUIT;

DC_ENC_PICKED:

    TRC_ALT((TB, "Encryption Method=%d, Level=%ld, Display=%ld",
             encMethodPicked,
             pRealSMHandle->encryptionLevel,
             pRealSMHandle->encryptDisplayData));

    /************************************************************************/
    /* remember the encryption method that we picked.                       */
    /************************************************************************/
    pRealSMHandle->encryptionMethodSelected = encMethodPicked;

    // For FIPS, do initialization
    // Even the enc method is not FIPS, we need to do initialization since we might
    //  shadow a FIPS later
    if (TSFIPS_Init(&(pRealSMHandle->FIPSData))) {
        TRC_NRM((TB, "Init Fips succeed\n"));
    }
    else {
        TRC_ERR((TB, "Init Fips Failed\n"));

        // This is only a fatal failure if FIPS was selected as the encryption
        // method.  If we chose something other than FIPS, then we should
        // proceed, although shadowing a FIPS session later should fail.
        //
        if (SM_FIPS_ENCRYPTION_FLAG == encMethodPicked)
        {
            status = STATUS_ENCRYPTION_FAILED;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Build user data to return to Client                                  */
    /************************************************************************/
    pRealSMHandle->pUserData =
        (PRNS_UD_SC_SEC)COM_Malloc(sizeof(RNS_UD_SC_SEC));
    if (pRealSMHandle->pUserData == NULL)
    {
        TRC_ERR((TB, "Failed to allocated %d bytes for user data",
                sizeof(RNS_UD_SC_SEC)));
        status = STATUS_NO_MEMORY;
        DC_QUIT;
    }

    pRealSMHandle->pUserData->header.type = RNS_UD_SC_SEC_ID;
    pRealSMHandle->pUserData->header.length = sizeof(RNS_UD_SC_SEC);
    pRealSMHandle->pUserData->encryptionMethod =
        (bOldShadow ? 0xffffffff : encMethodPicked);
    pRealSMHandle->pUserData->encryptionLevel =
        pRealSMHandle->encryptionLevel;

    /************************************************************************/
    /* Call Network Manager                                                 */
    /************************************************************************/
    SM_SET_STATE(SM_STATE_NM_CONNECTING);

    TRC_NRM((TB, "Connect to Network Manager"));
    rc = NM_Connect(pRealSMHandle->pWDHandle->pNMInfo, pNetUserData);

    if (rc != TRUE) 
    {
        status = STATUS_CANCELLED;
        DC_QUIT;
    }

    // Shadow/passthru stacks start out with no encryption.  If the target end
    // determines that the client server supports encryption, an encrypted
    // context will be set up by rdpwsx.
    if (pRealSMHandle->pWDHandle->StackClass != Stack_Primary) {
        pRealSMHandle->pWDHandle->connected = TRUE;
        pRealSMHandle->encrypting = FALSE;
        pRealSMHandle->encryptDisplayData = FALSE;
        pRealSMHandle->encryptHeaderLen = 0;
        pRealSMHandle->encryptHeaderLenIfForceEncrypt = 0;
        SM_SET_STATE(SM_STATE_CONNECTED);
        SM_SET_STATE(SM_STATE_SC_REGISTERED);
        SM_Dead(pRealSMHandle, FALSE);
        TRC_ALT((TB, "%s stack: Suspending encryption during key exchange",
                 pRealSMHandle->pWDHandle->StackClass == Stack_Shadow ?
                 "Shadow" : "Passthru"));
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* If anything failed, release resources                                */
    /************************************************************************/
    if (status != STATUS_SUCCESS)
    {
        TRC_ERR((TB, "Failed - free connect resources"));
        SMFreeConnectResources(pRealSMHandle);
    }

    DC_END_FN();
    return status;
} /* SM_Connect */


/****************************************************************************/
/* Name:      SM_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect from a Client                                      */
/*                                                                          */
/* Returns:   TRUE  - Disconnect started OK                                 */
/*            FALSE - Disconnect failed                                     */
/*                                                                          */
/* Params:    pSMHandle - SM handle                                         */
/*                                                                          */
/* Operation: Detach the user from the domain.                              */
/*            Note that this function completes asynchronously.  The caller */
/*            must wait for an SM_CB_DISCONNECTED callback to find whether  */
/*            the Disconnect succeeded or failed.                           */
/****************************************************************************/
BOOL RDPCALL SM_Disconnect(PVOID pSMHandle)
{
    BOOL rc = FALSE;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_Disconnect");

    if (SM_CHECK_STATE_Q(SM_EVT_DISCONNECT)) {
        // Call Network Layer.
        SM_SET_STATE(SM_STATE_DISCONNECTING);
        rc = NM_Disconnect(pRealSMHandle->pWDHandle->pNMInfo);
    }

    DC_END_FN();
    return rc;
}

void SM_BreakConnectionWorker(PTSHARE_WD pTSWd, PVOID pParam)
{
    NTSTATUS status;
    ICA_CHANNEL_COMMAND Command;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pTSWd->pSmInfo;

    DC_BEGIN_FN("SM_BreakConnectionWorker");

    Command.Header.Command = ICA_COMMAND_BROKEN_CONNECTION;
    Command.BrokenConnection.Reason = Broken_Unexpected;
    Command.BrokenConnection.Source = BrokenSource_Server;

    status = IcaChannelInput(pTSWd->pContext, Channel_Command, 0, NULL, (BYTE *)&Command, sizeof(Command));

    if (!NT_SUCCESS(status)) {
        TRC_NRM((TB, "Can't send ICA_COMMAND_BROKEN_CONNECTION, error code 0x%08x", status));
    }

    DC_END_FN();
}

/****************************************************************************/
/* Name:      SM_AllocBuffer                                                */
/*                                                                          */
/* Purpose:   Allocate a buffer                                             */
/*                                                                          */
/* Returns:   TRUE  - buffer allocated OK                                   */
/*            FALSE - failed to allocate buffer                             */
/*                                                                          */
/* Params:    pSMHandle     - SM Handle                                     */
/*            ppBuffer      - pointer to packet (returned)                  */
/*            bufferLen     - length of buffer                              */
/*            fForceEncrypt - Always encrypt or not                         */
/*                            Used only if encryptDisplayData is FALSE      */
/*                            i.e., encryptionLevel is less than 2          */
/****************************************************************************/
NTSTATUS __fastcall SM_AllocBuffer(PVOID  pSMHandle,
                               PPVOID ppBuffer,
                               UINT32 bufferLen,
                               BOOLEAN fWait,
                               BOOLEAN fForceEncrypt)
{
    NTSTATUS status;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    PRNS_SECURITY_HEADER2 pSecHeader2;
    UINT32 newBufferLen, padLen;

    DC_BEGIN_FN("SM_AllocBuffer");

    if (SM_CHECK_STATE_Q(SM_EVT_ALLOCBUFFER)) {
        if (pRealSMHandle->pWDHandle->StackClass != Stack_Console) {
            
            // If FIPS, adjust the BufferLen to the whole FIPS_BLOCK_LEN size
            if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                newBufferLen = TSFIPS_AdjustDataLen(bufferLen);
                padLen = newBufferLen - bufferLen;
                bufferLen = newBufferLen;
            }

            // Add enough space for a security header. We always send at least
            // a short security header.
            if (pRealSMHandle->encryptDisplayData) {
                bufferLen += pRealSMHandle->encryptHeaderLen;
            }
            else {
                if (!fForceEncrypt) {
                    bufferLen += pRealSMHandle->encryptHeaderLen;
                }
                else {
                    bufferLen += pRealSMHandle->encryptHeaderLenIfForceEncrypt;
                }
            }

            status = NM_AllocBuffer(pRealSMHandle->pWDHandle->pNMInfo, ppBuffer,
                    bufferLen, fWait);
            if ( STATUS_SUCCESS == status ) {
                TRC_NRM((TB, "Alloc buffer size %d at %p", bufferLen,
                        *ppBuffer));

                // If FIPS, fill in padSize in Header
                if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    pSecHeader2 = (PRNS_SECURITY_HEADER2)(*ppBuffer);
                    pSecHeader2->padlen = (TSUINT8)padLen;
                }

                // Adjust return pointer for security header.
                if (pRealSMHandle->encryptDisplayData) {
                    *ppBuffer = (PVOID)((PBYTE)(*ppBuffer) +
                            pRealSMHandle->encryptHeaderLen);
                }
                else {
                    if (!fForceEncrypt) {
                        *ppBuffer = (PVOID)((PBYTE)(*ppBuffer) +
                                    pRealSMHandle->encryptHeaderLen);
                    }
                    else {
                        *ppBuffer = (PVOID)((PBYTE)(*ppBuffer) +
                                    pRealSMHandle->encryptHeaderLenIfForceEncrypt);
                    }
                }
            }
            else
            {
                if( status == STATUS_IO_TIMEOUT && TRUE == fWait ) {

                    //
                    // WARNING : Disconnect client on first allocation failure, different 
                    //           result ranging from TS client AV to immediate lock up on 
                    //           re-connect if this scheme is changed disconnect on 2nd 
                    //           try, 3rd try ...
                    //

                    TRC_NRM((TB, "Failed to alloc buffer size %d, disconnecting client", bufferLen));

                    // 254514	STRESS:  TS: Tdtcp!TdRawWrite needs synchronization with the write complete routine
                    // Calling the following function will hold the connection lock in tdtcp TDSyncWrite to wait
                    // for all pending IRP to finish.  This will cause deadlock in the system.
                    //WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, FALSE, Log_RDP_AllocOutBuf, NULL, 0);

                    // return STATUS_IO_TIMEOUT back to caller, 
                    // looks like we use this return code.

                    if (!pRealSMHandle->bDisconnectWorkerSent) {
                        status = IcaQueueWorkItem(pRealSMHandle->pWDHandle->pContext,
                                                  SM_BreakConnectionWorker,
                                                  0,
                                                  ICALOCK_DRIVER);
                        if (!NT_SUCCESS(status)) {
                            TRC_NRM((TB, "IcaQueueWorkItem failed, error code 0x%08x", status));
                        } else {
                            pRealSMHandle->bDisconnectWorkerSent = TRUE;
                        }
                    }

                    status = STATUS_IO_TIMEOUT;
                }
                else {

                    // NM_AllocBuffer will have traced appropriately if the alloc
                    // failed, no need for TRC_ERR here.

                    TRC_NRM((TB, "Failed to alloc buffer size %d", bufferLen));
                }
            }
        }
        else {
            PSM_CONSOLE_BUFFER pBlock;
            // For a console stack, just alloc a suitable block - we're not
            // actually going to send it!
            TRC_NRM((TB, "console stack requesting %d bytes", bufferLen));

            *ppBuffer = NULL;

            if (!IsListEmpty(&pRealSMHandle->consoleBufferList)) {

                pBlock = CONTAINING_RECORD(pRealSMHandle->consoleBufferList.Flink, SM_CONSOLE_BUFFER, links);

                do {
                    // we could improve this by taking the smaller of the suitable blocks
                    // it can be also faster if we order the list
                    if (pBlock->length >= bufferLen) {
                        RemoveEntryList(&pBlock->links);
                        pRealSMHandle->consoleBufferCount -= 1;
                        *ppBuffer = pBlock->buffer;
                        break;
                    }

                    pBlock = CONTAINING_RECORD(pBlock->links.Flink, SM_CONSOLE_BUFFER, links);

                } while(pBlock != (PSM_CONSOLE_BUFFER)(&pRealSMHandle->consoleBufferList));

            }

            if (*ppBuffer == NULL) {
                // allocate a new block
                pBlock = COM_Malloc(sizeof(SM_CONSOLE_BUFFER) + bufferLen);
                if (pBlock != NULL) {

                    pBlock->buffer = (PVOID)((PBYTE)pBlock + sizeof(SM_CONSOLE_BUFFER));
                    pBlock->length = bufferLen;

                    *ppBuffer = pBlock->buffer;
                } else {
                    *ppBuffer = NULL;
                }
            }

            if (*ppBuffer != NULL) {
                TRC_NRM((TB, "and returning buffer at %p", *ppBuffer));
                status = STATUS_SUCCESS;
            }
            else {
                TRC_ERR((TB, "failed to alloc buffer"));
                status = STATUS_NO_MEMORY;
            }
        }
    }
    else {
        status = STATUS_UNSUCCESSFUL;   // right error code?
    }

    DC_END_FN();
    return status;
} /* SM_AllocBuffer */


/****************************************************************************/
/* Name:      SM_FreeBuffer                                                 */
/*                                                                          */
/* Purpose:   Free a buffer                                                 */
/*                                                                          */
/* Params:    pSMHandle     - SM Handle                                     */
/*            pBuffer       - buffer to free                                */
/*            fForceEncrypt - Always encrypt or not                         */
/*                            Used only if encryptDisplayData is FALSE      */
/*                            i.e., encryptionLevel is less than 2          */
/****************************************************************************/
void __fastcall SM_FreeBuffer(PVOID pSMHandle, PVOID pBuffer, BOOLEAN fForceEncrypt)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_FreeBuffer");

    // Note that, unlike SM_AllocBuffer, we don't check the state table here,
    // since if we were able to allocate the buffer, we should always be
    // able to free it. Otherwise we may end up leaking buffers during
    // warn states.
    if (pRealSMHandle->pWDHandle->StackClass != Stack_Console) {
        // Adjust for security header.
        if (pRealSMHandle->encryptDisplayData) {
            pBuffer = (PVOID)((PBYTE)pBuffer -
                    pRealSMHandle->encryptHeaderLen);
        }
        else {
            if (!fForceEncrypt) {
                pBuffer = (PVOID)((PBYTE)pBuffer -
                        pRealSMHandle->encryptHeaderLen);
            }
            else {
                pBuffer = (PVOID)((PBYTE)pBuffer -
                        pRealSMHandle->encryptHeaderLenIfForceEncrypt);
            }
        }

        TRC_NRM((TB, "Free buffer at %p", pBuffer));
        NM_FreeBuffer(pRealSMHandle->pWDHandle->pNMInfo, pBuffer);
    }
    else {
        PSM_CONSOLE_BUFFER pBlock;

        pBlock = (PSM_CONSOLE_BUFFER)((PBYTE)pBuffer - sizeof(SM_CONSOLE_BUFFER));

        // For console session, insert it in the list of freed blocks.
        TRC_NRM((TB, "console stack freeing buffer at %p", pBuffer));

        // Since this block was freshly used,
        // insert it at the beginning of the list.
        InsertHeadList(&pRealSMHandle->consoleBufferList, &pBlock->links);

        if (pRealSMHandle->consoleBufferCount >= 2) {
            PVOID listEntry;

            // Free a buffer since we have enough buffers.
            // Remove and free the last one (tail of the list),
            // assuming it's the less used.
            listEntry = RemoveTailList(&pRealSMHandle->consoleBufferList);
            pBlock = CONTAINING_RECORD(listEntry, SM_CONSOLE_BUFFER, links);

            COM_Free(pBlock);

        } else {
            pRealSMHandle->consoleBufferCount += 1;
        }
    }

    DC_END_FN();
} /* SM_FreeBuffer */


/****************************************************************************/
// SM_SendData
//
// Sends a network buffer. Note that upper layers assume that, if the send
// fails, the buffer will get deallocated. Returns FALSE on failure.
//
// Params:    pSMHandle - SM Handle
//            pData     - data to send
//            dataLen   - length if data to send
//            priority  - priority to use
//            channelID - channel ID (ignored in this version)
//            bFastPathOutput - whether pData contains fast-path output
//            flags     - the flag that should be put in RNS_SECURITY_HEADER.flags
//            fForceEncrypt - Always encrypt or not                         
//                            Used only if encryptDisplayData is FALSE      
//                            i.e., encryptionLevel is less than 2          
/****************************************************************************/
BOOL __fastcall SM_SendData(
        PVOID  pSMHandle,
        PVOID  pData,
        UINT32 dataLen,
        UINT32 priority,
        UINT32 channelID,
        BOOL   bFastPathOutput,
        UINT16 flags,
        BOOLEAN fForceEncrypt)
{
    BOOL rc = FALSE;
    PRNS_SECURITY_HEADER pSecHeader;
    PRNS_SECURITY_HEADER2 pSecHeader2;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    UINT32 sendLen;
    BOOL fUseSafeChecksum = FALSE;
    UINT32 encryptHeaderLen = 0;

    DC_BEGIN_FN("SM_SendData");

    if (SM_CHECK_STATE_Q(SM_EVT_SENDDATA)) {
        if (pRealSMHandle->pWDHandle->StackClass != Stack_Console) {
            // Send the packet unchanged if we're not encrypting at all.
            if ((!pRealSMHandle->encrypting) && (!fForceEncrypt)) {
                TRC_DATA_DBG("Send never-encrypted data", pData, dataLen);
                rc = NM_SendData(pRealSMHandle->pWDHandle->pNMInfo,
                        (BYTE *)pData, dataLen, priority, channelID,
                        bFastPathOutput | NM_NO_SECURITY_HEADER);
                DC_QUIT;
            }

            // Get interesting pointers and lengths.
            if ((!pRealSMHandle->encryptDisplayData) && !fForceEncrypt) {
                // S->C is not encrypted
                encryptHeaderLen = pRealSMHandle->encryptHeaderLen;
                sendLen = dataLen + encryptHeaderLen;
            }
            else {
                if (pRealSMHandle->encryptDisplayData) {
                    // S->C is encrypted
                    encryptHeaderLen = pRealSMHandle->encryptHeaderLen;
                }
                else {
                    // S->C is not encrypted, but we want to encrypt this packet        
                    encryptHeaderLen = pRealSMHandle->encryptHeaderLenIfForceEncrypt;
                }

                if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    pSecHeader2 = (PRNS_SECURITY_HEADER2)((PBYTE)pData - encryptHeaderLen);
                    pSecHeader2->padlen = (TSUINT8)TSFIPS_AdjustDataLen(dataLen) - dataLen;
                    sendLen = dataLen + encryptHeaderLen + pSecHeader2->padlen;

                    pSecHeader2->length = sizeof(RNS_SECURITY_HEADER2);
                    pSecHeader2->version = TSFIPS_VERSION1;
                }
                else {
                    sendLen = dataLen + encryptHeaderLen;
                }
            }

            pSecHeader = (PRNS_SECURITY_HEADER)((PBYTE)pData - encryptHeaderLen);

            
            // Encrypt display data if we are asked to do so.
            if ((!pRealSMHandle->encryptDisplayData) && !fForceEncrypt) {
                pSecHeader->flags = 0;
                // We are implicitly not setting TS_OUTPUT_FASTPATH_ENCRYPTED
                // bit in bFastPathOutput before passing to NM_SendData.
                TRC_DBG((TB, "Data not encrypted"));
            }
            else {
                // Check to see if we need to update the session key.
                if (pRealSMHandle->encryptCount == UPDATE_SESSION_KEY_COUNT) {
                    rc = TRUE;
                    // Don't need to update the session key if using FIPS
                    if (pRealSMHandle->encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                        rc = UpdateSessionKey(
                                pRealSMHandle->startEncryptKey,
                                pRealSMHandle->currentEncryptKey,
                                pRealSMHandle->encryptionMethodSelected,
                                pRealSMHandle->keyLength,
                                &pRealSMHandle->rc4EncryptKey,
                                pRealSMHandle->encryptionLevel);
                    }
                    if (rc) {
                        // Reset counter.
                        pRealSMHandle->encryptCount = 0;
                    }
                    else {
                        TRC_ERR((TB, "SM failed to update session key"));
                        WDW_LogAndDisconnect(
                                pRealSMHandle->pWDHandle, TRUE, 
                                Log_RDP_ENC_UpdateSessionKeyFailed,
                                NULL,
                                0);
                        DC_QUIT;
                    }
                }

                TRC_DATA_DBG("Data buffer before encryption", pData, dataLen);


                //
                // Disable the safe checksumming in the shadow pipe as there
                // is currently no way to reliably do caps negotiation in the
                // pipe.
                //
                // This is not an issue because we don't have fastpath in
                // the shadow pipe and as a result of this we're not vulnerable
                // to the checksum frequency analysis security vulnerability.
                // 
                //
                fUseSafeChecksum = pRealSMHandle->useSafeChecksumMethod &&
                    (pRealSMHandle->pWDHandle->StackClass == Stack_Primary);

                if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    rc = TSFIPS_EncryptData(
                                &(pRealSMHandle->FIPSData),
                                pData,
                                dataLen + pSecHeader2->padlen,
                                pSecHeader2->padlen,
                                pSecHeader2->dataSignature,
                                pRealSMHandle->totalEncryptCount);
                }
                else {
                    rc = EncryptData(
                            pRealSMHandle->encryptionLevel,
                            pRealSMHandle->currentEncryptKey,
                            &pRealSMHandle->rc4EncryptKey,
                            pRealSMHandle->keyLength,
                            pData,
                            dataLen,
                            pRealSMHandle->macSaltKey,
                            ((PRNS_SECURITY_HEADER1)pSecHeader)->dataSignature,
                            fUseSafeChecksum,
                            pRealSMHandle->totalEncryptCount);
                }
                if (rc) {
                    TRC_DBG((TB, "Data encrypted"));
                    TRC_DATA_DBG("Data buffer after encryption", pData,
                            dataLen);

                    // Successfully encrypted a packet, increment the
                    // encryption counter and set the header.
                    pRealSMHandle->encryptCount++;
                    pRealSMHandle->totalEncryptCount++;
                    TRC_ASSERT(((flags == RNS_SEC_ENCRYPT) ||
                    	        (flags == RDP_SEC_REDIRECTION_PKT3) ||
                                (flags == (RNS_SEC_ENCRYPT | RNS_SEC_LICENSE_PKT | RDP_SEC_LICENSE_ENCRYPT_CS))),
                        (TB,"SM_SendData shouldn't get this flag %d", flags));
                    pSecHeader->flags = flags;
                    if (fUseSafeChecksum) {
                        bFastPathOutput |= TS_OUTPUT_FASTPATH_SECURE_CHECKSUM;
                        pSecHeader->flags |= RDP_SEC_SECURE_CHECKSUM;
                    }
                    bFastPathOutput |= TS_OUTPUT_FASTPATH_ENCRYPTED;
                }
                else {
                    // If we failed, the in-place encryption probably
                    // destroyed part or all of the data. The stream is
                    // now corrupted, we need to disconnect.
                    TRC_ERR((TB, "SM failed to encrypt data"));
                    WDW_LogAndDisconnect(
                            pRealSMHandle->pWDHandle, TRUE, 
                            Log_RDP_ENC_EncryptFailed,
                            NULL,
                            0);
                    DC_QUIT;
                }
            }

            // Send it!
            rc = NM_SendData(pRealSMHandle->pWDHandle->pNMInfo, (BYTE *)pSecHeader,
                    sendLen, priority, channelID, bFastPathOutput);
        }
        else {
            // For console session, simply claim to have sent it.
            TRC_NRM((TB, "console stack sending buffer at %p", pData));
            rc = TRUE;

            // Note that we will have to free it.
            SM_FreeBuffer(pSMHandle, pData, fForceEncrypt);
        }
    }
    else {
        // Bad state - we need to free the data.
        TRC_ALT((TB,"Freeing buffer on bad state"));
        SM_FreeBuffer(pSMHandle, pData, fForceEncrypt);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} /* SM_SendData */



/****************************************************************************/
/* Name:      SM_Dead                                                       */
/****************************************************************************/
void RDPCALL SM_Dead(PVOID pSMHandle, BOOL dead)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_Dead");

    pRealSMHandle->dead = (BOOLEAN)dead;
    NM_Dead(pRealSMHandle->pWDHandle->pNMInfo, dead);
    if (dead)
    {
        /********************************************************************/
        /* SM_Dead(TRUE) can be called in any state to kill SM.  Don't      */
        /* check the existing state - simply set the new state to           */
        /* DISCONNECTING.                                                   */
        /********************************************************************/
        TRC_ALT((TB, "SM Dead - change state to DISCONNECTING"));
        SM_SET_STATE(SM_STATE_DISCONNECTING);
    }
    else
    {
        /********************************************************************/
        /* SM_Dead(FALSE) is called on (re)connect.  The SM state will be   */
        /* - SC_REGISTERED on connect                                       */
        /* - SM_DISCONNECTING on reconnect                                  */
        /* In both cases, set the state to SC_REGISTERED                    */
        /********************************************************************/
        SM_CHECK_STATE(SM_EVT_ALIVE);
        TRC_ALT((TB, "SM Alive - change state to SC_REGISTERED"));
        SM_SET_STATE(SM_STATE_SC_REGISTERED);
        pRealSMHandle->bDisconnectWorkerSent = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* SM_Dead */


#ifdef USE_LICENSE
/****************************************************************************/
/* Name:      SM_LicenseOK                                                  */
/****************************************************************************/
void RDPCALL SM_LicenseOK(PVOID pSMHandle)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_LicenseOK");

    TRC_NRM((TB, "Licensing Done"));
    SM_SET_STATE(SM_STATE_CONNECTED);

    DC_END_FN();
} /* SM_LicenseOK */
#endif


/****************************************************************************/
/* Name:      SM_GetSecurityData                                            */
/*                                                                          */
/* Purpose:   Retrieve security data.  This will be the encrypted client    */
/*            random for a Primary or Shadow connection.  For passthru      */
/*            stacks the shadow server random and certificate is returned.  */
/*                                                                          */
/* Params:    pSMHandle        - SM handle                                  */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/****************************************************************************/
NTSTATUS RDPCALL SM_GetSecurityData(PVOID pSMHandle, PSD_IOCTL pSdIoctl)
{
    NTSTATUS         status;
    PSM_HANDLE_DATA  pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    PSECURITYTIMEOUT pSecurityTimeout = (PSECURITYTIMEOUT)
                          pSdIoctl->InputBuffer;

    DC_BEGIN_FN("SM_GetSecurityData");

    // Wait for the connected indication from SM.
    TRC_ERR((TB, "About to wait for security data"));

    if (pSdIoctl->InputBufferLength == sizeof(SECURITYTIMEOUT)) {
        status = WDW_WaitForConnectionEvent(pRealSMHandle->pWDHandle,
                pRealSMHandle->pWDHandle->pSecEvent,
                pSecurityTimeout->ulTimeout);
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        TRC_ERR((TB, "Bogus timeout value: %ld", pSecurityTimeout->ulTimeout));
        DC_QUIT;
    }

    TRC_DBG((TB, "Back from wait for security data"));

    if (status != STATUS_SUCCESS) {
        TRC_ERR((TB, "SM connected indication timed out: (%lx), msec=%ld",
                 status, pSecurityTimeout->ulTimeout));
        status = STATUS_IO_TIMEOUT;

        DC_QUIT;
    }

    /********************************************************************/
    /* check to see the given buffer is sufficient.                     */
    /********************************************************************/
    if ((pSdIoctl->OutputBuffer == NULL) ||
            (pSdIoctl->OutputBufferLength <=
            pRealSMHandle->encClientRandomLen)) {
        status = STATUS_BUFFER_TOO_SMALL;
        DC_QUIT;
    }

    /********************************************************************/
    /* check to see security info is available.                         */
    /********************************************************************/
    TRC_ASSERT((pRealSMHandle->encryptionMethodSelected != 0),
        (TB,"SM_GetSecurityData is called when encryption is not ON"));
    if (pRealSMHandle->encryptionMethodSelected == 0) {
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    TRC_ASSERT((pRealSMHandle->recvdClientRandom == TRUE),
        (TB,"SM_GetSecurityData issued before the client random received"));
    if (pRealSMHandle->recvdClientRandom == FALSE) {
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    if (pRealSMHandle->pEncClientRandom == NULL) {
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    TRC_ASSERT((pRealSMHandle->encClientRandomLen != 0 ),
        (TB,"SM_GetSecurityData invalid pEncClientRandom buffer"));
    if (pRealSMHandle->encClientRandomLen == 0) {
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    /********************************************************************/
    /* copy return data.                                                */
    /********************************************************************/
    memcpy(
            pSdIoctl->OutputBuffer,
            pRealSMHandle->pEncClientRandom,
            pRealSMHandle->encClientRandomLen);

    /********************************************************************/
    /* set returned buffer size.                                        */
    /********************************************************************/
    pSdIoctl->BytesReturned = pRealSMHandle->encClientRandomLen;

    /********************************************************************/
    /* Free up the client pEncClientRandom Buffer, we don't need this   */
    /* any more.                                                        */
    /********************************************************************/
    COM_Free(pRealSMHandle->pEncClientRandom);
    pRealSMHandle->pEncClientRandom = NULL;
    pRealSMHandle->encClientRandomLen = 0;

    /************************************************************************/
    /* All worked OK                                                        */
    /************************************************************************/
    status = STATUS_SUCCESS;

DC_EXIT_POINT:
    DC_END_FN();
    return (status);
}


/****************************************************************************/
/* Name:      SM_SetSecurityData                                            */
/*                                                                          */
/* Purpose:   Set security data and compute session key.                    */
/*                                                                          */
/* Params:    pSMHandle - SM Handle                                         */
/*            pSecinfo  - pointer to random key pair                        */
/****************************************************************************/
NTSTATUS RDPCALL SM_SetSecurityData(PVOID pSMHandle, PSECINFO pSecInfo)
{
    BOOL rc;
    NTSTATUS status;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_SetSecurityData");


    /************************************************************************/
    /* use the given client and server random key pairs and arrive at       */
    /* session keys.                                                        */
    /************************************************************************/
    if ((pRealSMHandle->pWDHandle->StackClass == Stack_Primary) ||
            (pRealSMHandle->pWDHandle->StackClass == Stack_Shadow)) {
        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            rc = TSFIPS_MakeSessionKeys(&(pRealSMHandle->FIPSData), (LPRANDOM_KEYS_PAIR)&pSecInfo->KeyPair, NULL, FALSE);
        }
        else {
            rc = MakeSessionKeys(
                    (LPRANDOM_KEYS_PAIR)&pSecInfo->KeyPair,
                    pRealSMHandle->startEncryptKey,
                    &pRealSMHandle->rc4EncryptKey,
                    pRealSMHandle->startDecryptKey,
                    &pRealSMHandle->rc4DecryptKey,
                    pRealSMHandle->macSaltKey,
                    pRealSMHandle->encryptionMethodSelected,
                    &pRealSMHandle->keyLength,
                    pRealSMHandle->encryptionLevel );  
        }
    }

    // Passthru stack looks like a client
    else {
        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            rc = TSFIPS_MakeSessionKeys(&(pRealSMHandle->FIPSData), (LPRANDOM_KEYS_PAIR)&pSecInfo->KeyPair, NULL, TRUE);
        }
        else {
            rc = MakeSessionKeys(
                    (LPRANDOM_KEYS_PAIR)&pSecInfo->KeyPair,
                    pRealSMHandle->startDecryptKey,
                    &pRealSMHandle->rc4DecryptKey,
                    pRealSMHandle->startEncryptKey,
                    &pRealSMHandle->rc4EncryptKey,
                    pRealSMHandle->macSaltKey,
                    pRealSMHandle->encryptionMethodSelected,
                    &pRealSMHandle->keyLength,
                    pRealSMHandle->encryptionLevel );
        }
    }

    if (!rc) {
        TRC_ERR((TB, "Could not create session keys!"));
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    /************************************************************************/
    /* validate the key length returned.                                    */
    /************************************************************************/
    if (pRealSMHandle->encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
        if (pRealSMHandle->encryptionMethodSelected == SM_128BIT_ENCRYPTION_FLAG) {
            TRC_ASSERT((pRealSMHandle->keyLength == MAX_SESSION_KEY_SIZE),
                (TB,"Invalid session key length"));
        }
        else {
            TRC_ASSERT((pRealSMHandle->keyLength == (MAX_SESSION_KEY_SIZE / 2)),
                    (TB,"Invalid session key length"));
        }


        /************************************************************************/
        /* copy start session key to current.                                   */
        /************************************************************************/
        memcpy(
                pRealSMHandle->currentEncryptKey,
                pRealSMHandle->startEncryptKey,
                MAX_SESSION_KEY_SIZE);
        memcpy(
                pRealSMHandle->currentDecryptKey,
                pRealSMHandle->startDecryptKey,
                MAX_SESSION_KEY_SIZE);
    }

    pRealSMHandle->encryptCount = 0;
    pRealSMHandle->decryptCount = 0;
    pRealSMHandle->totalDecryptCount = 0;
    pRealSMHandle->totalEncryptCount = 0;
    pRealSMHandle->bSessionKeysMade = TRUE;

    // Whenever we change the state of encrypting, we need to make sure
    // we get the right header size for buffer allocations. If encrypting
    // if FALSE, the header size is zero.
    pRealSMHandle->encrypting = TRUE;
    if (pRealSMHandle->encryptionLevel == 1) {
        pRealSMHandle->encryptHeaderLen = sizeof(RNS_SECURITY_HEADER);
        pRealSMHandle->encryptDisplayData = FALSE;
        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG)
            pRealSMHandle->encryptHeaderLenIfForceEncrypt = sizeof(RNS_SECURITY_HEADER2);
        else
            pRealSMHandle->encryptHeaderLenIfForceEncrypt = sizeof(RNS_SECURITY_HEADER1);
    }
    else if (pRealSMHandle->encryptionLevel >= 2) {
        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG)
            pRealSMHandle->encryptHeaderLen = sizeof(RNS_SECURITY_HEADER2);
        else
            pRealSMHandle->encryptHeaderLen = sizeof(RNS_SECURITY_HEADER1);
        pRealSMHandle->encryptDisplayData = TRUE;
    }

    TRC_ALT((TB, "%s stack -> encryption %s: level=%ld, method=%ld, display=%ld",
             pRealSMHandle->pWDHandle->StackClass == Stack_Primary ? "Primary" :
             (pRealSMHandle->pWDHandle->StackClass == Stack_Shadow ? "Shadow" :
              "PassThru"),
             rc ? "ON" : "OFF",
             pRealSMHandle->encryptionLevel,
             pRealSMHandle->encryptionMethodSelected,
             pRealSMHandle->encryptDisplayData));

    /************************************************************************/
    /* Remember the certificate type that was used for the key exchange     */
    /************************************************************************/
    pRealSMHandle->CertType = pSecInfo->CertType;

    /************************************************************************/
    /* All worked OK                                                        */
    /************************************************************************/
    status = STATUS_SUCCESS;

DC_EXIT_POINT:
    DC_END_FN();
    return (status);
}


/****************************************************************************/
/* Name:      SM_SetEncryptionParams                                        */
/*                                                                          */
/* Purpose:   Updates the encryption level and method.  Used to set         */
/*            negotiated encryption level for passthru stack.               */
/*                                                                          */
/* Params:    pSMHandle - SM Handle                                         */
/*            ulLevel   - negotiated encryption level                       */
/*            ulMethod  - negotiated encryption method                      */
/****************************************************************************/
NTSTATUS RDPCALL SM_SetEncryptionParams(
        PVOID pSMHandle,
        ULONG ulLevel,
        ULONG ulMethod)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_SetEncryptionParams");

    // The passthru stack is simulating a client for the target server.  As
    // such, if we negotiated client input encryption, we've got to turn on
    // output encryption for this stack since it conveys all client input
    // to the target server.
    if (ulLevel == 1) {
        ulLevel = 2;
        TRC_ALT((TB, "Passthru stack switching to duplex encryption."));
    }

    pRealSMHandle->encryptionLevel = ulLevel;
    pRealSMHandle->encryptionMethodSelected = ulMethod;

    DC_END_FN();
    return STATUS_SUCCESS;
}


/****************************************************************************/
/* Name:      SM_IsSecurityExchangeCompleted                                */
/*                                                                          */
/* Purpose:   Ask SM if the security exchange protocol has already been     */
/*            completed.                                                    */
/*                                                                          */
/* Returns:   TRUE if the protocol has already been completed or FALSE      */
/*            otherwise.                                                    */
/*                                                                          */
/* Params:    pSMHandle - SM Handle                                         */
/*            pCertType - The type of certificate that is used in the       */
/*            security exchange.                                            */
/****************************************************************************/
BOOL RDPCALL SM_IsSecurityExchangeCompleted(
        PVOID     pSMHandle,
        CERT_TYPE *pCertType)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_IsSecurityExchangeCompleted");

    *pCertType = pRealSMHandle->CertType;

    DC_END_FN();
    return pRealSMHandle->encrypting;
}

#ifdef DC_DEBUG

/****************************************************************************/
// SMCheckState
//
// Debug-only embodiment of the SM_CHECK_STATE logic.
/****************************************************************************/
BOOL RDPCALL SMCheckState(PSM_HANDLE_DATA pRealSMHandle, unsigned event)
{
    BOOL rc;

    DC_BEGIN_FN("SMCheckState");

    if (smStateTable[event][pRealSMHandle->state] == SM_TABLE_OK) {
        rc = TRUE;
    }
    else {
        rc = FALSE;
        if (smStateTable[event][pRealSMHandle->state] == SM_TABLE_WARN) {
            TRC_ALT((TB, "Unusual event %s in state %s",
                    smEventName[event], smStateName[pRealSMHandle->state]));
        }
        else {
            TRC_ABORT((TB, "Invalid event %s in state %s",
                    smEventName[event], smStateName[pRealSMHandle->state]));
        }
    }

    DC_END_FN();
    return rc;
}

#endif

/****************************************************************************/
/* Name:      SM_SetSafeChecksumMethod
/*
/* Purpose:   Sets flag to use safe checksum style
/*
/* Params:    pSMHandle - SM Handle     
//            fEncryptChecksummedData - 
/****************************************************************************/
NTSTATUS RDPCALL SM_SetSafeChecksumMethod(
        PVOID pSMHandle,
        BOOLEAN fSafeChecksumMethod
        )
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_SetSafeChecksumMethod");

    pRealSMHandle->useSafeChecksumMethod = fSafeChecksumMethod;

    DC_END_FN();
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asmcpp.cpp ===
/****************************************************************************/
/* asmcpp.cpp                                                               */
/*                                                                          */
/* Security Manager C++ functions                                           */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "asmcpp"
#define pTRCWd (pRealSMHandle->pWDHandle)
#include <adcg.h>

#include <as_conf.hpp>

extern "C"
{
#include <asmint.h>
#include <slicense.h>
}

#define DC_INCLUDE_DATA
#include <asmdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/* Name:      SM_Register                                                   */
/*                                                                          */
/* Purpose:   Register with SM                                              */
/*                                                                          */
/* Returns:   TRUE  - registered OK                                         */
/*            FALSE - register failed                                       */
/*                                                                          */
/* Params:    pSMHandle   - SM handle                                       */
/*            pMaxPDUSize - max PDU size supported (returned)               */
/*            pUserID     - this person's user ID (returned)                */
/*                                                                          */
/* Operation: This function enables the Share Class to register with SM.    */
/*            This allows                                                   */
/*            - the Share Class to call SM                                  */
/*            - SM to issue callbacks to the Share Class (SC_SMCallback).   */
/****************************************************************************/
BOOL RDPCALL SM_Register(
        PVOID   pSMHandle,
        PUINT32 pMaxPDUSize,
        PUINT32 pUserID)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;
    BOOL          rc = FALSE;

    DC_BEGIN_FN("SM_Register");

    // Console stacks do not go through the typical key negotiation, so update
    // the state appropriately
    if (pRealSMHandle->pWDHandle->StackClass == Stack_Console)
    {
        TRC_ALT((TB, "Console security state to SM_STATE_SM_CONNECTED"));
        SM_SET_STATE(SM_STATE_CONNECTED);
    }
    //Skip the following CHECK_STATE. For the console reconnect,
    // this is a legal transition.
    //SM_CHECK_STATE(SM_EVT_REGISTER);

    /************************************************************************/
    /* Calculate max PDU size allowed to caller                             */
    /************************************************************************/
    *pMaxPDUSize = pRealSMHandle->maxPDUSize -
            pRealSMHandle->encryptHeaderLen;
    TRC_NRM((TB, "Max PDU size allowed to core is %d", *pMaxPDUSize));

    /************************************************************************/
    /* Return the user ID                                                   */
    /************************************************************************/
    *pUserID = pRealSMHandle->userID;
    TRC_NRM((TB, "Returning user id %d", *pUserID));

    SM_SET_STATE(SM_STATE_SC_REGISTERED);
    
    pRealSMHandle->bForwardDataToSC = TRUE;

    rc = TRUE;

//DC_EXIT_POINT:
    DC_END_FN();
    return rc;       
} /* SM_Register */


/****************************************************************************/
/* Name:      SM_OnConnected                                                */
/*                                                                          */
/* Purpose:   Handle connection state change callbacks from NM              */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            userID        - userID of the node causing the callback       */
/*            result        - result of connection attempt                  */
/*            pUserData     - Network (Server-Client) user data             */
/*            maxPDUSize    - max size of PDUs that can be sent             */
/****************************************************************************/
void RDPCALL SM_OnConnected(
        PVOID  pSMHandle,
        UINT32 userID,
        UINT32 result,
        PRNS_UD_SC_NET pUserData,
        UINT32 maxPDUSize)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_OnConnected");
   
    if (result == NM_CB_CONN_OK)
    {
        TRC_NRM((TB, "Connected OK as user %x", userID));

        SM_CHECK_STATE(SM_EVT_CONNECTED);

        /********************************************************************/
        /* Store useful stuff in SM Handle                                  */
        /********************************************************************/
        pRealSMHandle->userID = userID;
        pRealSMHandle->maxPDUSize = maxPDUSize;
        pRealSMHandle->channelID = pUserData->MCSChannelID;

        /********************************************************************/
        // Pass the result to WDW. For WDW this is the start of the
        // connection sequence.
        /********************************************************************/
        SM_SET_STATE(SM_STATE_SM_CONNECTING);
        
        WDW_OnSMConnecting(pRealSMHandle->pWDHandle, pRealSMHandle->pUserData,
                pUserData);

        /********************************************************************/
        // Free the reply user data once we've passed it to WDW.
        /********************************************************************/
        if (pRealSMHandle->pUserData != NULL)
        {
            TRC_NRM((TB, "Free user data"));
            COM_Free(pRealSMHandle->pUserData);
            pRealSMHandle->pUserData = NULL;
        }
    }
    else
    {
        TRC_NRM((TB, "Failed to connect, reason %d", result));

        /********************************************************************/
        // Tell WDW
        /********************************************************************/
        WDW_OnSMConnected(pRealSMHandle->pWDHandle, result);

        /********************************************************************/
        /* Clean up                                                         */
        /********************************************************************/
        SM_SET_STATE(SM_STATE_SM_CONNECTING);

        SM_Disconnect(pRealSMHandle);
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* SM_OnConnected */


/****************************************************************************/
/* Name:      SM_OnDisconnected                                             */
/*                                                                          */
/* Purpose:   Handle disconnection state change callback from NM            */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            userID        - userID of the node causing the callback       */
/*            result        - reason for the disconnection                  */
/****************************************************************************/
void RDPCALL SM_OnDisconnected(
        PVOID  pSMHandle,
        UINT32 userID,
        UINT32 result)
{
    ShareClass *pSC;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSMHandle;

    DC_BEGIN_FN("SM_OnDisconnected");

    SM_CHECK_STATE(SM_EVT_DISCONNECTED);

    TRC_NRM((TB, "Disconnected, reason %d", result));

    /************************************************************************/
    /* First, clear up connection resources                                 */
    /************************************************************************/
    SMFreeConnectResources(pRealSMHandle);
    SM_SET_STATE(SM_STATE_INITIALIZED);

    /************************************************************************/
    // Tell SC. Don't call if SC is not registered.
    /************************************************************************/
    if (pRealSMHandle->state == SM_STATE_SC_REGISTERED) {
        // Check that the Share Class exists.
        pSC = (ShareClass *)(pRealSMHandle->pWDHandle->dcShare);
        if (pSC != NULL) {
            // Call SC's callback.
            pSC->SC_OnDisconnected((UINT16)userID);
        }
        else {
            TRC_ERR((TB, "No Share Class"));
        }
    }
    else {
        TRC_ERR((TB, "SC Not registered"));
    }

    /************************************************************************/
    /* Then tell WDW                                                        */
    /************************************************************************/
    WDW_OnSMDisconnected(pRealSMHandle->pWDHandle);

DC_EXIT_POINT:
    DC_END_FN();
} /* SM_OnDisconnected */


/****************************************************************************/
// SM_DecodeFastPathInput
//
// Handles decryption of fast-path input data if it's an encrypted packet.
// Then passes directly to IM for bytestream decoding and injection.
/****************************************************************************/
void RDPCALL SM_DecodeFastPathInput(
        void *pSM,
        BYTE *pData,
        unsigned DataLength,
        BOOL bEncrypted,
        unsigned NumEvents,
        BOOL fSafeChecksum)
{
    BOOL rc;
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pSM;
    ShareClass *pShareClass;
    // Used if encypted using FIPS
    BYTE *pEncData, *pSigData;
    DWORD EncDataLen, dwPadLen;

    DC_BEGIN_FN("SM_FastPathInputDecode");

    // If we are being attacked or have a bad client, we may receive data
    // here before we are really in a conference. If so, ignore it.
    // We can't disconnect here because the code to do so requires pWDHandle
    // to be valid. If the protocol stream is messed up, the connection will
    // be dropped later by other decoding code.
    if (pRealSMHandle->pWDHandle != NULL) {
        pShareClass = (ShareClass *)pRealSMHandle->pWDHandle->dcShare;

        if (pRealSMHandle->encrypting) {
            if (bEncrypted) {

                //
                // Debug verification, we always go with what the protocol header
                // says but verify it's consistent with the capabilities
                //
                if (pRealSMHandle->useSafeChecksumMethod != (fSafeChecksum != 0)) {
                    TRC_ERR((TB,
                            "fastpath: fSecureChecksum: 0x%x setting"
                             "does not match protocol: 0x%x",
                            pRealSMHandle->useSafeChecksumMethod, 
                            fSafeChecksum));
                }
            
                // Make sure we have at least the size of the security context.
                if (DataLength >= DATA_SIGNATURE_SIZE) {
                    // Check to see if we need to update the session key.
                    if (pRealSMHandle->decryptCount == UPDATE_SESSION_KEY_COUNT) {
                        rc = TRUE;
                        // Don't need to update the session key if using FIPS
                        if (pRealSMHandle->encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                            rc = UpdateSessionKey(
                                    pRealSMHandle->startDecryptKey,
                                    pRealSMHandle->currentDecryptKey,
                                    pRealSMHandle->encryptionMethodSelected,
                                    pRealSMHandle->keyLength,
                                    &pRealSMHandle->rc4DecryptKey,
                                    pRealSMHandle->encryptionLevel);
                        }
                        if (rc) {
                            // Reset counter.
                            pRealSMHandle->decryptCount = 0;
                        }
                        else {
                            TRC_ERR((TB,"SM failed to update session key"));
                            goto FailedKey;
                        }
                    }
                    if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                        
                        if (DataLength < (sizeof(RNS_SECURITY_HEADER2) - sizeof(RNS_SECURITY_HEADER))) {
                            TRC_ERR((TB,"PDU len %u too short for security context in FIPS decryption",
                                    DataLength));
                            goto ShortData;
                        }

                        pEncData = pData + sizeof(RNS_SECURITY_HEADER2) - sizeof(RNS_SECURITY_HEADER);
                        pSigData = pEncData - MAX_SIGN_SIZE;
                        EncDataLen = DataLength - (sizeof(RNS_SECURITY_HEADER2) - sizeof(RNS_SECURITY_HEADER));
                        dwPadLen = *((TSUINT8 *)(pSigData - sizeof(TSUINT8)));
                        rc =  TSFIPS_DecryptData(
                                &(pRealSMHandle->FIPSData),
                                pEncData,
                                EncDataLen,
                                dwPadLen,
                                pSigData,
                                pRealSMHandle->totalDecryptCount);
                    }
                    else {
                    // Encryption signature sits in first DATA_SIGNATURE_SIZE
                    // bytes of the provided packet data.
                        rc = DecryptData(
                                pRealSMHandle->encryptionLevel,
                                pRealSMHandle->currentDecryptKey,
                                &pRealSMHandle->rc4DecryptKey,
                                pRealSMHandle->keyLength,
                                pData + DATA_SIGNATURE_SIZE,
                                DataLength - DATA_SIGNATURE_SIZE,
                                pRealSMHandle->macSaltKey,
                                pData,
                                fSafeChecksum,
                                pRealSMHandle->totalDecryptCount);
                    }
                    if (rc) {
                        TRC_DBG((TB, "Data decrypted: %u",
                                DataLength - DATA_SIGNATURE_SIZE));
    
                        // Increment decryption counter.
                        pRealSMHandle->decryptCount++;
                        pRealSMHandle->totalDecryptCount++;
    
                        // Skip past the encryption signature for passing to IM.
                        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                            pData = pEncData;
                            DataLength = EncDataLen - *((TSUINT8 *)(pSigData - sizeof(TSUINT8)));
                        }
                        else {
                            pData += DATA_SIGNATURE_SIZE;
                            DataLength -= DATA_SIGNATURE_SIZE;
                        }
                    }
                    else {
                        TRC_ERR((TB, "SM failed to decrypt data: len=%u",
                                DataLength - DATA_SIGNATURE_SIZE));
                        goto FailedDecrypt;
                    }
                }
                else {
                    TRC_ERR((TB,"PDU len %u too short for security context",
                            DataLength));
                    goto ShortData;
                }
            }
            else {
                // Need to disconnect if client only sends encrypted data
                if (pRealSMHandle->pWDHandle->bForceEncryptedCSPDU) {
                    TRC_ASSERT((FALSE), (TB, "unencrypted data in encrypted protocol")); 
                    goto FailedDecrypt;
                }
            }
        }
        // Be sure to decrypt before checking the dead and other state to
        // maintain the correct context between the client and server.
        if (!pRealSMHandle->dead && SM_CHECK_STATE_Q(SM_EVT_DATA_PACKET)) {
            // We directly inject into the mouse and keyboard streams if we
            // are a primary stack. We cannot receive fast-path data on a
            // passthru stack since it does not get RawInput calls. Fast-path
            // input cannot be received by a shadow stack since the passthru-
            // to-shadow stack data format is always the non-fast-path
            // format, munged from the fast-path format by
            // IM_ConvertFastPathToShadow().
            TRC_ASSERT((pRealSMHandle->pWDHandle->StackClass == Stack_Primary),
                    (TB,"Somehow we received fast-path input on a %s stack!",
                    (pRealSMHandle->pWDHandle->StackClass == Stack_Passthru ?
                    "passthru" :
                    pRealSMHandle->pWDHandle->StackClass == Stack_Shadow ?
                    "shadow" : "console")));
            pShareClass->IM_DecodeFastPathInput(pData, DataLength, NumEvents);
            if (pRealSMHandle->pWDHandle->shadowState == SHADOW_CLIENT)
                pShareClass->IM_ConvertFastPathToShadow(pData, DataLength, NumEvents);
        }
        else {
            TRC_ALT((TB,"Ignoring fast-path input PDU on dead or bad state"));
        }
    }
    else {
        TRC_ERR((TB,"Received fast-path input data before SM initialized, "
                "ignoring"));
        goto DataTooSoon;
    }

    DC_END_FN();
    return;

// Error handling, segregate to keep out of performance path
// instruction cache.
FailedKey:
    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
            Log_RDP_ENC_UpdateSessionKeyFailed, NULL, 0);
    return;

FailedDecrypt:
    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, Log_RDP_ENC_DecryptFailed,
            NULL, 0);
    return;

ShortData:
    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
            Log_RDP_SecurityDataTooShort, pData, DataLength);
    return;

DataTooSoon:
    // TODO: Combine the SM, NM, and TSWd state into one single struct
    // containing everything we need, then fix this code to disconnect
    // by using the pContext we need.
    ;
}


/****************************************************************************/
/* Name:      SM_MCSSendDataCallback                                        */
/*                                                                          */
/* Purpose:   Handle SendData callback from MCS                             */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/*                                                                          */
/* Params:    hUser        - MCS user handle for our user attachment        */
/*            UserDefined  - our NM handle                                  */
/*            bUniform     - Data received is from an MCS uniform-send-data */
/*            hChannel     - Handle of the receive channel                  */
/*            Priority     - MCS priority for the data                      */
/*            SenderID     - MCS UserID of the sender                       */
/*            Segmentation - MCS segmentation flags for the data            */
/*            DataLength   - Length of the incoming data                    */
/*            pData        - Pointer to (DataLength) sized memory block     */
/****************************************************************************/
BOOLEAN __fastcall SM_MCSSendDataCallback(BYTE          *pData,
                                          unsigned      DataLength,
                                          void          *UserDefined,
                                          UserHandle    hUser,
                                          BOOLEAN       bUniform,
                                          ChannelHandle hChannel,
                                          MCSPriority   Priority,
                                          UserID        SenderID,
                                          Segmentation  Segmentation)
{
    BOOLEAN result = TRUE;
    PSM_HANDLE_DATA pRealSMHandle;
    BOOL dataPkt;
    BOOL licPkt;
    UINT16 channelID;
    ShareClass *dcShare;

    DC_BEGIN_FN("SM_MCSSendDataCallback");

    /************************************************************************/
    /* SMHandle is assumed to be the first member in the NM struct pointed  */
    /* to by UserDefined.                                                   */
    /************************************************************************/
    pRealSMHandle = *((PSM_HANDLE_DATA *)UserDefined);

    dcShare = (ShareClass*)pRealSMHandle->pWDHandle->dcShare;

    /************************************************************************/
    /* Check MCS segmentation.                                              */
    /************************************************************************/
    TRC_ASSERT((Segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END)),
                (TB,"Segmented packet received"));

    /************************************************************************/
    /* Decide what type of packet it is.  This is a bit hokey.              */
    /* - If we are encrypting, the security header always tells us the type */
    /*   of packet.                                                         */
    /* - If we are not encrypting                                           */
    /*   - assume packets received in state SM_STATE_SC_REGISTERED are data */
    /*     packets                                                          */
    /*   - assume packets received in other states are not data packets.    */
    /************************************************************************/
    if (pRealSMHandle->encrypting)
    {
        if (DataLength >= sizeof(RNS_SECURITY_HEADER)) {
            dataPkt = !(((PRNS_SECURITY_HEADER_UA)pData)->flags &
                    RNS_SEC_NONDATA_PKT);
        }
        else {
            TRC_ERR((TB,"Received pkt len %u too short for security header",
                    DataLength));
            WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                    Log_RDP_SecurityDataTooShort, pData, DataLength);
            result = FALSE;
            DC_QUIT;
        }
    }
    else
    {
        dataPkt = (pRealSMHandle->state == SM_STATE_SC_REGISTERED);
    }

    TRC_DBG((TB, "Encrypting=%d: %s packet",
                pRealSMHandle->encrypting, dataPkt ? "data" : "security"));

    /************************************************************************/
    /* Handle data packets (perf path).                                     */
    /************************************************************************/
    if (dataPkt)
    {
        /********************************************************************/
        /* Decrypt the packet if necessary                                  */
        /********************************************************************/
        if (pRealSMHandle->encrypting)
        {

            if (((PRNS_SECURITY_HEADER_UA)pData)->flags & RNS_SEC_ENCRYPT)
            {
                TRC_DBG((TB, "Decrypt the packet"));

                if (SMDecryptPacket(pRealSMHandle, pData, DataLength,
                       pRealSMHandle->useSafeChecksumMethod))
                {
                    TRC_NRM((TB,"Decrypted packet at %p", pData));
                }
                else
                {
                    TRC_ERR((TB, "Failed to decrypt packet: %ld", DataLength));
                    DC_QUIT;
                }
                if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    DataLength -= (sizeof(RNS_SECURITY_HEADER2) + ((PRNS_SECURITY_HEADER2_UA)pData)->padlen);
                    pData += sizeof(RNS_SECURITY_HEADER2);   
                }
                else {
                    pData += sizeof(RNS_SECURITY_HEADER1);
                    DataLength -= sizeof(RNS_SECURITY_HEADER1);
                }
            }
            else
            {
                /************************************************************/
                /* Adjust pointer and length                                */
                /************************************************************/
                if (pRealSMHandle->pWDHandle->bForceEncryptedCSPDU) {
                
                    TRC_ASSERT((FALSE), (TB, "unencrypted data in encrypted protocol")); 
    
                    WDW_LogAndDisconnect(
                            pRealSMHandle->pWDHandle, TRUE,
                            Log_RDP_ENC_DecryptFailed, NULL, 0);
    
                    result = FALSE;
                    DC_QUIT;
                }
                else {
                    TRC_NRM((TB, "Pass packet to SC"));
                    pData += sizeof(RNS_SECURITY_HEADER);
                    DataLength -= sizeof(RNS_SECURITY_HEADER);
                }                
            }
        }

        /********************************************************************/
        /* Don't do anything if we're dead                                  */
        /********************************************************************/
        if (!pRealSMHandle->dead)
        {
            if (SM_CHECK_STATE_Q(SM_EVT_DATA_PACKET)) {
                // Decide where to send the packet based on the channel ID.
                channelID = (UINT16)MCSGetChannelIDFromHandle(hChannel);
                if (channelID == pRealSMHandle->channelID) {
                    // Pass packet to SC. Don't do it if the ShareClass
                    // doesn't exist.
                    TRC_NRM((TB, "Share channel %x", channelID));
                    if (pRealSMHandle->pWDHandle->dcShare != NULL) {
                        // Only a non-shadowing primary stack, or a shadow
                        // stack should process the full set of PDUs
                        if (((pRealSMHandle->pWDHandle->StackClass == Stack_Primary) &&
                            (pRealSMHandle->pWDHandle->shadowState != SHADOW_CLIENT))) {
                            ((ShareClass*)(pRealSMHandle->pWDHandle->dcShare))->
                                SC_OnDataReceived(pData, SenderID, DataLength,
                                                  Priority);
                        }
                        else if ((pRealSMHandle->pWDHandle->StackClass == Stack_Shadow)) {
                            UINT16 pduType = ((PTS_SHARECONTROLHEADER)pData)->pduType 
                                    & TS_MASK_PDUTYPE;
                            
                            // Unless it's CLIENTRANDOM PDU, we can only forward
                            // data to Share Class if Share Class is ready.
                            // We could be in a racing condition that Share class
                            // hasn't finished initialization, but we have received
                            // shadow data.
                            if (pRealSMHandle->bForwardDataToSC == TRUE ||
                                    pduType == TS_PDUTYPE_CLIENTRANDOMPDU) {
                                ((ShareClass*)(pRealSMHandle->pWDHandle->dcShare))->
                                        SC_OnDataReceived(pData, SenderID, DataLength,
                                        Priority);
                            }
                        }

                        // Else send to SC for shadow hotkey processing or
                        // passthru from the shadow target to the shadow
                        // client.
                        else {
                            ((ShareClass*)(pRealSMHandle->pWDHandle->dcShare))->
                                    SC_OnShadowDataReceived(pData, SenderID, DataLength,
                                    Priority);
                        }
                    }
                    else {
                        TRC_ERR((TB, "Tried to call non-existent Share Class"));
                    }
                }
                else
                {
                    /************************************************************/
                    /* Virtual Channel                                          */
                    /************************************************************/
                    TRC_NRM((TB, "Virtual channel %x", channelID));
                    WDW_OnDataReceived(pRealSMHandle->pWDHandle,
                                       pData,
                                       DataLength,
                                       channelID);
                }
            }
            else {
                TRC_ALT((TB,"Ignoring PDU because of bad state"));
#ifdef INSTRUM_TRACK_DISCARDED
                pRealSMHandle->nDiscardPDUBadState++;
#endif
                DC_QUIT;
            }
        }
        else
        {
            TRC_ERR((TB, "Recvd PDU when we're dead"));

            //
            // To help track down the VC decompression bug
            // track if we dropped any VC packets
            //
            channelID = (UINT16)MCSGetChannelIDFromHandle(hChannel);
            if (channelID != pRealSMHandle->channelID) {

                //
                // If this is VC data then we must hand it off
                // to be decompressed otherwise the server's context
                // will get out of sync with the client's
                //

                TRC_NRM((TB, "Virtual channel %x", channelID));
                WDW_OnDataReceived(pRealSMHandle->pWDHandle,
                                   pData,
                                   DataLength,
                                   channelID);

#ifdef INSTRUM_TRACK_DISCARDED
                pRealSMHandle->nDiscardVCDataWhenDead++;
#endif
            }
            else
            {
#ifdef INSTRUM_TRACK_DISCARDED
                pRealSMHandle->nDiscardNonVCPDUWhenDead++;
#endif
            }

            DC_QUIT;
        }
    }
    else
    {
        /********************************************************************/
        /* If we're encrypting, the security header tells us the packet     */
        /* type.  If we're not encrypting, we need to use our state to      */
        /* decide whether this is a licensing or security packet.           */
        /********************************************************************/
        if (pRealSMHandle->encrypting)
        {
            licPkt = (((PRNS_SECURITY_HEADER_UA)pData)->flags &
                    RNS_SEC_LICENSE_PKT);
        }
        else
        {
            licPkt = (pRealSMHandle->state == SM_STATE_LICENSING);
        }

        if (licPkt)
        {
#ifdef USE_LICENSE
            /****************************************************************/
            /* License packet                                               */
            /****************************************************************/
            TRC_NRM((TB, "Licensing packet"));
            SM_CHECK_STATE(SM_EVT_LIC_PACKET);

            if (((PRNS_SECURITY_HEADER_UA)pData)->flags & RNS_SEC_ENCRYPT)
            {
                TRC_DBG((TB, "Decrypt the licensing packet"));

                if (SMDecryptPacket(pRealSMHandle, pData, DataLength,
                      pRealSMHandle->useSafeChecksumMethod))
                {
                    TRC_NRM((TB,"Decrypted packet at %p", pData));
                }
                else
                {
                    TRC_ERR((TB, "Failed to decrypt packet: %ld", DataLength));
                    DC_QUIT;
                }
                if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    DataLength -= (sizeof(RNS_SECURITY_HEADER2) + ((PRNS_SECURITY_HEADER2_UA)pData)->padlen);
                    pData += sizeof(RNS_SECURITY_HEADER2);   
                }
                else {
                    pData += sizeof(RNS_SECURITY_HEADER1);
                    DataLength -= sizeof(RNS_SECURITY_HEADER1);
                }
            }
            else
            {
                TRC_NRM((TB, "Licensing packet not encrypted"));
                pData += sizeof(RNS_SECURITY_HEADER);
                DataLength -= sizeof(RNS_SECURITY_HEADER);

            }

            SLicenseData(pRealSMHandle->pLicenseHandle,
                         pRealSMHandle,
                         pData,
                         DataLength);
#else /* USE_LICENSE */
            TRC_ABORT((TB,"Licensing not implemented yet"));
#endif /* USE_LICENSE */
        }
        else
        {
            /****************************************************************/
            /* Security packet                                              */
            /****************************************************************/
            TRC_NRM((TB, "Security packet"));
            SM_CHECK_STATE(SM_EVT_SEC_PACKET);
            result = SMContinueSecurityExchange(pRealSMHandle, pData, DataLength);
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return (result);
} /* SM_MCSSendDataCallback */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\as_conf.cpp ===
/****************************************************************************/
/* as_conf.cpp                                                              */
/*                                                                          */
/* Routines for RDP per-conference class                                    */
/*                                                                          */
/* COPYRIGHT(C) Microsoft 1996-1999                                         */
/****************************************************************************/

/****************************************************************************/
/* There is no tracing in this file.  However, TRC_FILE is included for     */
/* completeness, pTRCWd is required by checked versions of COM_Malloc/Free  */
/****************************************************************************/
#define TRC_FILE "as_conf"
#define pTRCWd NULL

/****************************************************************************/
/* Header that sets up OS flags. Include before everything else             */
/* Also pulls in class forward references etc.                              */
/****************************************************************************/
#include <precomp.h>
#pragma hdrstop
#include <adcg.h>

#ifdef OS_WINDOWS
#include <mmsystem.h>
#endif /* OS_WINDOWS */

#include <as_conf.hpp>


/****************************************************************************/
/* Override new and delete                                                  */
/****************************************************************************/
void * __cdecl operator new(size_t nSize)
{
    PVOID ptr;

    if ((sizeof(nSize)) >= PAGE_SIZE) {
        KdPrint(("RDPWD: **** Note ShareClass allocation size %u is above "
                "page size %u, wasting %u\n", sizeof(ShareClass), PAGE_SIZE,
                PAGE_SIZE - (nSize % PAGE_SIZE)));
    }

    ptr = COM_Malloc(nSize);
    if (ptr != NULL) {
        KdPrint(("RDPWD: New: ShareClass at %p, size=%u\n", ptr, nSize));
    }

    return ptr;
}


void __cdecl operator delete(void* p)
{
    KdPrint(("RDPWD: Delete: Free memory at %p\n", p));
    COM_Free(p);
}


/****************************************************************************/
/* Now get the const data arrays initialised.                               */
/****************************************************************************/
#define DC_CONSTANT_DATA
#include <adata.c>


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\assidata.c ===
/****************************************************************************/
/* assidata.c                                                               */
/*                                                                          */
/* RDP SSI data                                                             */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright(c) Data Connection 1996                                        */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN,  ssiSaveBitmapSizeChanged, FALSE);

DC_DATA(BOOLEAN,  ssiResetInterceptor, FALSE);

DC_DATA(unsigned, ssiNewSaveBitmapSize, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\assiapi.cpp ===
/****************************************************************************/
/* assiapi.cpp                                                              */
/*                                                                          */
/* SaveScreenBits Interceptor API functions.                                */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* Copyright(c) Data Connection 1996                                        */
/* (C) 1997-1998 Microsoft Corp.                                            */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "assiapi"
#include <as_conf.hpp>


/****************************************************************************/
/* SSI_Init(..)                                                             */
/****************************************************************************/
void RDPCALL SHCLASS SSI_Init(void)
{
    DC_BEGIN_FN("SSI_Init");

#define DC_INIT_DATA
#include <assidata.c>
#undef DC_INIT_DATA

    TRC_DBG((TB, "Initializing SSI"));

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: SSI_PartyJoiningShare                                      */
/*                                                                          */
/* Called when a new party is joining the share.                            */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* locPersonID - local person ID of remote person joining the share.        */
/*                                                                          */
/* oldShareSize - the number of the parties which were in the share (ie     */
/* excludes the joining party).                                             */
/*                                                                          */
/* RETURNS: TRUE if the party can join the share.                           */
/*          FALSE if the party can NOT join the share.                      */
/****************************************************************************/
BOOL RDPCALL SHCLASS SSI_PartyJoiningShare(LOCALPERSONID locPersonID,
                                           unsigned      oldShareSize)
{
    PTS_ORDER_CAPABILITYSET pLocalOrderCaps;

    DC_BEGIN_FN("SSI_PartyJoiningShare");
    DC_IGNORE_PARAMETER(oldShareSize)

    /************************************************************************/
    /* If this is the first party in the share, reset the interceptor code. */
    /************************************************************************/
    if (oldShareSize == 0)
    {
        SSIResetInterceptor();
    }

    /************************************************************************/
    /* Redetermine the size of the save screen bitmap.                      */
    /************************************************************************/
    SSIRedetermineSaveBitmapSize();

    TRC_DBG((TB, "Person with network ID %d joining share", locPersonID));

    SSICapabilitiesChanged();

    DC_END_FN();
    return(TRUE);
}


/****************************************************************************/
/* API FUNCTION: SSI_PartyLeftShare()                                       */
/*                                                                          */
/* SSI function called when a party has left the share.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* locPersonID - local person ID of remote person leaving the share.        */
/*                                                                          */
/* newShareSize - the number of the parties now in the call (ie excludes    */
/* the leaving party).                                                      */
/****************************************************************************/
void RDPCALL SHCLASS SSI_PartyLeftShare(LOCALPERSONID locPersonID,
                                        unsigned      newShareSize)
{
    DC_BEGIN_FN("SSI_PartyLeftShare");

    DC_IGNORE_PARAMETER(locPersonID)

    /************************************************************************/
    /* Redetermine the size of the save screen bitmap.                      */
    /************************************************************************/
    SSIRedetermineSaveBitmapSize();

    /************************************************************************/
    /* If this is the last party in the share, free all resources for the   */
    /* call.                                                                */
    /************************************************************************/
    if (newShareSize == 0)
    {
        /********************************************************************/
        /* Discard all saved bitmaps.                                       */
        /********************************************************************/
        SSIResetInterceptor();
    }
    else
    {
        /********************************************************************/
        /* Deal with new capabilities.                                      */
        /********************************************************************/
        SSICapabilitiesChanged();
    }

    TRC_DBG((TB, "Person with network ID %d leaving share", locPersonID));

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SSI_SyncUpdatesNow                                             */
/*                                                                          */
/* Called by the USR to start syncing data to the remote parties.           */
/* The datastream subsequently sent by the SSI must not refer to any        */
/* previously sent.                                                         */
/****************************************************************************/
void RDPCALL SHCLASS SSI_SyncUpdatesNow(void)
{
    DC_BEGIN_FN("SSI_SyncUpdatesNow");

    /************************************************************************/
    /* Discard any saved bitmaps.  This ensures that the subsequent         */
    /* datastream will not refer to any previously sent data.               */
    /************************************************************************/
    SSIResetInterceptor();

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SSI_UpdateShm                                                  */
/*                                                                          */
/* Updates the Shared Memory with local values.  Called on WinStation       */
/* context.                                                                 */
/****************************************************************************/
void RDPCALL SHCLASS SSI_UpdateShm(void)
{
    DC_BEGIN_FN("SSI_UpdateShm");

    m_pShm->ssi.resetInterceptor =
            (m_pShm->ssi.resetInterceptor || ssiResetInterceptor);
    ssiResetInterceptor = FALSE;

    m_pShm->ssi.newSaveBitmapSize = ssiNewSaveBitmapSize;

    m_pShm->ssi.saveBitmapSizeChanged =
              (m_pShm->ssi.saveBitmapSizeChanged || ssiSaveBitmapSizeChanged);
    ssiSaveBitmapSizeChanged = FALSE;

    TRC_NRM((TB, "resetInterceptor(%u) newSaveBitmapSize(%u)"
                 " saveBitmapSizeChanged(%u)",
                 m_pShm->ssi.resetInterceptor,
                 m_pShm->ssi.newSaveBitmapSize,
                 m_pShm->ssi.saveBitmapSizeChanged ));

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SSIEnumBitmapCacheCaps()                                       */
/*                                                                          */
/* Function passed to CPC_EnumerateCapabilities.  It will be called with a  */
/* capability structure for each person in the call corresponding to the    */
/* TS_CAPSETTYPE_ORDER capability structure.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - ID of person with these capabilities.                         */
/*                                                                          */
/* pProtCaps - pointer to capabilities structure for this person. This      */
/* pointer is only valid within the call to this function.                  */
/****************************************************************************/
void RDPCALL SHCLASS SSIEnumBitmapCacheCaps(
        LOCALPERSONID personID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCaps)
{
    PTS_ORDER_CAPABILITYSET pOrderCaps;

    DC_BEGIN_FN("SSIEnumBitmapCacheCaps");

    DC_IGNORE_PARAMETER(UserData);

    pOrderCaps = (PTS_ORDER_CAPABILITYSET)pCaps;

    TRC_NRM((TB, "[%u]Receiver bitmap size %ld", (unsigned)personID,
            pOrderCaps->desktopSaveSize));

    /************************************************************************/
    /* Set the size of the local send save screen bitmap to the minimum of  */
    /* its current size and this party's receive save screen bitmap size.   */
    /************************************************************************/
    ssiNewSaveBitmapSize = min(ssiNewSaveBitmapSize,
            pOrderCaps->desktopSaveSize);

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: SSIRedetermineSaveBitmapSize                                   */
/*                                                                          */
/* Enumerates all the people in the share and redetermines the size of the  */
/* save screen bitmap depending on their and the local receive              */
/* capabilities.                                                            */
/****************************************************************************/
void RDPCALL SHCLASS SSIRedetermineSaveBitmapSize(void)
{
    PTS_ORDER_CAPABILITYSET pOrderCaps;

    DC_BEGIN_FN("SSIRedetermineSaveBitmapSize");

    /************************************************************************/
    /* Enumerate all the save screen bitmap receive capabilities of the     */
    /* parties in the share.  The usable size of the send save screen       */
    /* bitmap is then the minimum of all the remote receive sizes and the   */
    /* local send size.                                                     */
    /************************************************************************/
    ssiNewSaveBitmapSize = SAVE_BITMAP_WIDTH * SAVE_BITMAP_HEIGHT;
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_ORDER, NULL,
            SSIEnumBitmapCacheCaps);
    TRC_NRM((TB, "Sender bitmap size %ld", ssiNewSaveBitmapSize));

    DC_END_FN();
}


/****************************************************************************/
/* SSIResetInterceptor                                                      */
/*                                                                          */
/* DESCRIPTION: Reset the save screen bits interceptor                      */
/****************************************************************************/
void RDPCALL SHCLASS SSIResetInterceptor(void)
{
    DC_BEGIN_FN("SSIResetInterceptor");

    /************************************************************************/
    /* Make sure the display driver resets the save level.                  */
    /************************************************************************/
    ssiResetInterceptor = TRUE;
    DCS_TriggerUpdateShmCallback();

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SSICapabilitiesChanged                                        */
/*                                                                          */
/* Purpose:   Called when the SSI capabilities have been renegotiated.      */
/****************************************************************************/
void RDPCALL SHCLASS SSICapabilitiesChanged(void)
{
    DC_BEGIN_FN("SSICapabilitiesChanged");

    ssiSaveBitmapSizeChanged = TRUE;
    DCS_TriggerUpdateShmCallback();

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\as_conf.hpp ===
/****************************************************************************/
// as_conf.hpp
//
// Definition of RDP ShareClass. Note ShareClass is a huge amalgam of the
// public and private portions of each "component" (IM, SC, etc.).
//
// COPYRIGHT(C) Microsoft 1996-1999
/****************************************************************************/
#ifndef _H_AS_CONF
#define _H_AS_CONF

/****************************************************************************/
/* All the headers we need for the class definition (which is pretty much   */
/* all the headers...)                                                      */
/****************************************************************************/
#include <adcs.h>

/****************************************************************************/
/* Make sure we use a standard trace group if the module has not defined a  */
/* custom one.                                                              */
/****************************************************************************/
#ifndef TRC_GROUP
#define TRC_GROUP TRC_GROUP_DCSHARE
#endif

/****************************************************************************/
/* Define the pWD for use by tracing, if the module has not alreasy defined */
/* one.                                                                     */
/****************************************************************************/
#ifndef pTRCWd
#define pTRCWd m_pTSWd
#endif

extern "C"
{
#include <atrcapi.h>
}

#include <aprot.h>

/****************************************************************************/
/* References to the WD struct.                                             */
/****************************************************************************/
#include <nwdwapi.h>

/****************************************************************************/
/* WD IOCtls                                                                */
/****************************************************************************/
#include <nwdwioct.h>

/****************************************************************************/
/* Include all API and INT headers which do not contain references to the   */
/* ShareClass.  Try to keep as many headers as possible here, otherwise you */
/* hit the Microsoft C++ compiler error "fatal error C1067: compiler limit  */
/* : debug information module size exceeded.", even on retail builds.       */
/*                                                                          */
/* If you hit error "fatal error C2644: basis class 'class' for pointer to  */
/* member has not been defined", you need to move the offending header      */
/* which includes a reference to ShareClass into the class definition below.*/
/****************************************************************************/
#include <abcapi.h>
#include <abaapi.h>
#include <acaapi.h>
#include <aimapi.h>
#include <aoaapi.h>
#include <aoeapi.h>
#include <apmapi.h>
#include <aschapi.h>
#include <asdgapi.h>
#include <assiapi.h>
#include <aupapi.h>
#include <ausrapi.h>
#include <nshmapi.h>


/****************************************************************************/
/* Class:        ShareClass                                                 */
/*                                                                          */
/* Description:  RDP WD-only per-conference Share Class                     */
/****************************************************************************/
class ShareClass
{
public:

    /************************************************************************/
    /* Constructor                                                          */
    /************************************************************************/
    ShareClass(PTSHARE_WD pTSWd,
               unsigned   desktopHeight,
               unsigned   desktopWidth,
               unsigned   desktopBpp,
               PVOID      pSmInfo): m_pTSWd        (pTSWd),
                                    m_desktopHeight(desktopHeight),
                                    m_desktopWidth (desktopWidth),
                                    m_desktopBpp   (desktopBpp),
                                    m_pSmInfo      (pSmInfo)
                                      {};

    /************************************************************************/
    /* Destructor not required.                                             */
    /************************************************************************/

    /************************************************************************/
    /* Member variables that are used for communication with other WD       */
    /* sub-components (WDW, SM, NM) or the WD.                              */
    /************************************************************************/

    /************************************************************************/
    /* Pointer to the WD data structure                                     */
    /************************************************************************/
    PTSHARE_WD m_pTSWd;

    /************************************************************************/
    /* SM handle                                                            */
    /************************************************************************/
    PVOID m_pSmInfo;

    /************************************************************************/
    /* Display characteristics                                              */
    /************************************************************************/
    unsigned m_desktopHeight;
    unsigned m_desktopWidth;
    unsigned m_desktopBpp;

    /************************************************************************/
    /* Pointer to the shared memory                                         */
    /************************************************************************/
    PSHM_SHARED_MEMORY m_pShm;

/****************************************************************************/
/* Include the API and INT headers which do contain references to the       */
/* ShareClass (and those headers which end up including these!).  Try to    */
/* keep this list as small as possible to avoid hitting the compiler error  */
/* C1067.                                                                   */
/****************************************************************************/
#include <ascapi.h>
#include <ascint.h>
#include <adcsapi.h>
#include <acpcapi.h>
#include <acmapi.h>
#include <asbcapi.h>
#include <achapi.h>


    /************************************************************************/
    /* Other public member functions.  These are the API functions which    */
    /* are accessed from outside the class.                                 */
    /************************************************************************/
#include <adcsafn.h>
#include <ascafn.h>
#include <aupafn.h>
#include <aschafn.h>
#include <asbcafn.h>
#include <aimafn.h>

private:

    /************************************************************************/
    /* Private member functions.                                            */
    /* These are the INT functions of all components, plus the API          */
    /* functions of components that are not accessed from outside the class.*/
    /************************************************************************/
#include <abaafn.h>
#include <abcafn.h>
#include <acaafn.h>
#include <acpcafn.h>
#include <acmafn.h>
#include <aoaafn.h>
#include <aoacom.h>
#include <aoeafn.h>
#include <apmafn.h>
#include <asdgafn.h>
#include <assiafn.h>
#include <ausrafn.h>

#include <ascifn.h>

    /************************************************************************/
    /* Private member data items - which is all data.                       */
    /************************************************************************/

#ifdef DLL_TSHRKDX
public:               /* need all class data to be public for kd extensions */
#else
private:
#endif

#define DC_DEFINE_DATA
#include <adata.c>
#undef DC_DEFINE_DATA

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asmdata.c ===
/****************************************************************************/
// asmdata.c
//
// SM constant global data
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#ifndef DC_INCLUDE_DATA
#include <adcg.h>
#endif

#include <ndcgdata.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <asmint.h>


/****************************************************************************/
/* SM State table                                                           */
/****************************************************************************/
DC_CONST_DATA_2D_ARRAY(BYTE, smStateTable, SM_NUM_EVENTS, SM_NUM_STATES,
 DC_STRUCT12(

/****************************************************************************/
/* This state table simply shows which events are valid in which states.    */
/*                                                                          */
/* Values mean                                                              */
/*                                                                          */
/* - 0 event OK in this state.                                              */
/*                                                                          */
/* - 1 warning - event should not occur in this state, but does in          */
/*     some race conditions - ignore it.                                    */
/*                                                                          */
/* - 2 error - event should not occur in ths state at all.                  */
/*                                                                          */
/* These values are hard-coded here in ordeer to make the table readable.   */
/* They correspond to the constants SM_TABLE_OK, SM_TABLE_WARN &            */
/* SM_TABLE_ERROR.                                                          */
/****************************************************************************/
/* The events and states are defined in asmint.h.  The events are           */
/* prefixed with SM_EVT and the states are prefixed with SM_STATE           */
/*                                                                          */
/*            Started                                                       */
/*            |    Initialized                                              */
/*            |    |    NM_Connecting                                       */
/*            |    |    |    SM_Connecting                                  */
/*            |    |    |    |    Licensing                                 */
/*            |    |    |    |    |    Connected                            */
/*            |    |    |    |    |    |    SC_Registered                   */
/*            |    |    |    |    |    |    |    Disconnecting              */
/*            |    |    |    |    |    |    |    |                          */
/*            0    1    2    3    4    5    6    7                          */
/****************************************************************************/
DC_STRUCT8(   0,   2,   2,   2,   2,   2,   2,   2 ), /* Init               */
DC_STRUCT8(   1,   0,   0,   0,   0,   0,   0,   0 ), /* Term               */
DC_STRUCT8(   2,   2,   2,   2,   2,   0,   0,   2 ), /* Register           */
DC_STRUCT8(   2,   0,   2,   2,   2,   2,   2,   2 ), /* Connect            */
DC_STRUCT8(   2,   2,   2,   0,   0,   0,   0,   2 ), /* Disconnect         */
DC_STRUCT8(   2,   2,   0,   2,   2,   2,   2,   2 ), /* Connected          */
DC_STRUCT8(   1,   1,   0,   0,   0,   0,   0,   0 ), /* Disconnected       */
DC_STRUCT8(   1,   1,   1,   1,   1,   1,   0,   1 ), /* Data Packet        */
DC_STRUCT8(   1,   1,   1,   0,   0,   1,   0,   1 ), /* Send Data          */
DC_STRUCT8(   2,   2,   2,   0,   2,   2,   2,   1 ), /* Security Packet    */
DC_STRUCT8(   2,   2,   2,   2,   0,   1,   1,   1 ), /* Licensing Packet   */
DC_STRUCT8(   2,   2,   2,   2,   2,   2,   0,   0 )  /* Alive              */

));


#ifdef DC_DEBUG

/****************************************************************************/
/* State and event descriptions (debug build only)                          */
/****************************************************************************/
DC_CONST_DATA_2D_ARRAY(char, smStateName, SM_NUM_STATES, 25,
  DC_STRUCT8(
    "SM_STATE_STARTED",
    "SM_STATE_INITIALIZED",
    "SM_STATE_NM_CONNECTING",
    "SM_STATE_SM_CONNECTING",
    "SM_STATE_SM_LICENSING",
    "SM_STATE_CONNECTED",
    "SM_STATE_SC_REGISTERED",
    "SM_STATE_DISCONNECTING"
    ) );

DC_CONST_DATA_2D_ARRAY(char, smEventName, SM_NUM_EVENTS, 35,
  DC_STRUCT12(
    "SM_EVT_INIT",
    "SM_EVT_TERM",
    "SM_EVT_REGISTER",
    "SM_EVT_CONNECT",
    "SM_EVT_DISCONNECT",
    "SM_EVT_CONNECTED",
    "SM_EVT_DISCONNECTED",
    "SM_EVT_DATA_PACKET",
    "SM_EVT_ALLOC/FREE/SEND",
    "SM_EVT_SEC_PACKET",
    "SM_EVT_LIC_PACKET",
    "SM_EVT_ALIVE"
    ) );
#endif /* DC_DEBUG   */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aupdata.c ===
/****************************************************************************/
/* aupdata.c                                                                */
/*                                                                          */
/* RDP update packer global data.                                           */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(BOOLEAN, upfSyncTokenRequired, FALSE);

DC_DATA(BOOLEAN, upCanSendBeep,        FALSE);

// Precalculated update-orders PDU header size. Different based on fast-path
// output vs. regular.
DC_DATA(unsigned, upUpdateHdrSize, 0);

/****************************************************************************/
/* Compression ststistics                                                   */
/****************************************************************************/
DC_DATA (unsigned, upCompTotal, 0);
DC_DATA (unsigned, upUncompTotal, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aupapi.cpp ===
/****************************************************************************/
// aupapi.cpp
//
// RDP Update Packager functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "aupapi"
#include <as_conf.hpp>

/****************************************************************************/
// UP_Init
/****************************************************************************/
void RDPCALL SHCLASS UP_Init(void)
{
    DC_BEGIN_FN("UP_Init");

#define DC_INIT_DATA
#include <aupdata.c>
#undef DC_INIT_DATA

    DC_END_FN();
}


/****************************************************************************/
// UP_ReceivedPacket
//
// Handles TS_SUPPRESS_OUTPUT_PDU.
/****************************************************************************/
void RDPCALL SHCLASS UP_ReceivedPacket(
        PTS_SUPPRESS_OUTPUT_PDU pSupOutPDU,
        unsigned                DataLength,
        LOCALPERSONID           personID)
{
    NTSTATUS Status;
    ICA_CHANNEL_COMMAND Cmd;

    DC_BEGIN_FN("UP_ReceivedPacket");

    DC_IGNORE_PARAMETER(personID);

    if (DataLength >= (sizeof(TS_SUPPRESS_OUTPUT_PDU) -
            sizeof(TS_RECTANGLE16) + 
            pSupOutPDU->numberOfRectangles * sizeof(TS_RECTANGLE16))) {

        // Don't suppress output if we are being shadowed
        if ((pSupOutPDU->numberOfRectangles == TS_QUIET_FULL_SUPPRESSION) &&
                (m_pTSWd->shadowState == SHADOW_NONE)) {
            TRC_NRM((TB, "Turning frame buffer updates OFF"));
            Cmd.Header.Command = ICA_COMMAND_STOP_SCREEN_UPDATES;
            Status = IcaChannelInput(m_pTSWd->pContext, Channel_Command, 0,
                    NULL, (unsigned char *)&Cmd, sizeof(ICA_CHANNEL_COMMAND));
            TRC_DBG((TB, "Issued StopUpdates, status %lu", Status));
        }
        else {
            if (pSupOutPDU->numberOfRectangles <= TS_MAX_INCLUDED_RECTS) {
                // Any other value means we send all output.
                TRC_NRM((TB, "Turning screen buffer updates ON with full "
                        "repaint"));
                Cmd.Header.Command = ICA_COMMAND_REDRAW_SCREEN;
                Status = IcaChannelInput(m_pTSWd->pContext, Channel_Command,
                        0, NULL, (unsigned char *)&Cmd,
                        sizeof(ICA_CHANNEL_COMMAND));
                TRC_DBG((TB, "Issued RedrawScreen, status %lu", Status));
            }
            else {
                TRC_ERR((TB,"Too many rectangles in PDU, disconnecting"));
                goto BadPDU;
            }
        }
    }
    else {
        TRC_ERR((TB,"Data length %u too short for suppress-output PDU header",
                DataLength));
        goto BadPDU;
    }

    DC_END_FN();
    return;

// Error handling.
BadPDU:
    WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_BadSupressOutputPDU,
            (BYTE *)pSupOutPDU, DataLength);

    DC_END_FN();
} /* UP_ReceivedPacket */


/****************************************************************************/
// UP_SendUpdates
//
// Tries to send orders and bitmap data.
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS UP_SendUpdates(
        BYTE *pFrameBuf,
        UINT32 frameBufWidth,
        PPDU_PACKAGE_INFO pPkgInfo)
{
    BOOL ordersToSend;
    BOOL sdaToSend;
    NTSTATUS status = STATUS_SUCCESS;

    DC_BEGIN_FN("UP_SendUpdates");

    TRC_DBG((TB, "New set of updates"));

    ordersToSend = (OA_GetTotalOrderListBytes() > 0);
    sdaToSend = SDG_ScreenDataIsWaiting();

    // If we actually have updates to send then try to send a sync token.
    // If there is work to do on entry, then set a reschedule.
    if (ordersToSend || sdaToSend) {
        SCH_ContinueScheduling(SCH_MODE_NORMAL);

        TRC_NRM((TB, "Updates waiting %d:%d", ordersToSend, sdaToSend));

        // Normal case is no sync required. Only send updates if sync token
        // has been sent.
        if (!upfSyncTokenRequired || UPSendSyncToken(pPkgInfo)) {
            // There is no outstanding sync token waiting to be sent, so we
            // can send the orders and screen data updates.
            // Send accumulated orders.  If this call fails (probably out
            // of memory) then don't send any other updates - we'll try
            // sending the whole lot later.  The orders MUST be sent before
            // the screen data.
#ifdef DC_HICOLOR
            // test for hi color will avoid call into PM
            if ((m_pTSWd->desktopBpp > 8) ||
                    PM_MaybeSendPalettePacket(pPkgInfo))
#else
            if (PM_MaybeSendPalettePacket(pPkgInfo))
#endif
            {
                status = UPSendOrders(pPkgInfo);

                // Since it may take multiple output flushes to send all the
                // orders during a shadow operation, we only want to send
                // screen data once all the orders are gone.

                //
                // STATUS_IO_TIMEOUT means disconnected client, no reason to send
                // screen data
                //
                if (OA_GetTotalOrderListBytes() == 0) {
                    if (sdaToSend) {
                        TRC_NRM((TB, "Sending SD"));
                        SDG_SendScreenDataArea(pFrameBuf,
                                               frameBufWidth,
                                               pPkgInfo);
                    }
                }
            }
        }
    }

    DC_END_FN();

    return status;
}


/****************************************************************************/
// UP_SyncNow
//
// Called when a sync operation is required.
/****************************************************************************/
void RDPCALL SHCLASS UP_SyncNow(BOOLEAN bShadowSync)
{
    DC_BEGIN_FN("UP_SyncNow");

    // Indicate that a sync token is required. We will only actually send
    // the token if we get updates to send.
    upfSyncTokenRequired = TRUE;

    // Call all the XXX_SyncUpdatesNow routines.
    // On a shadow synchronization, the DD will have already performed this
    // work. Skip it to avoid an unnecessary DD kick.
    if (!bShadowSync) {
        BA_SyncUpdatesNow();
        OA_SyncUpdatesNow();    
        SBC_SyncUpdatesNow();
        SSI_SyncUpdatesNow();
    }

    DC_END_FN();
}


/****************************************************************************/
// UPSendSyncToken
//
// Sends SynchronizePDU. Returns nonzero on success.
/****************************************************************************/
BOOL RDPCALL SHCLASS UPSendSyncToken(PPDU_PACKAGE_INFO pPkgInfo)
{
    DC_BEGIN_FN("UP_SendSyncToken");

    // The sync is handled in different ways depending on whether we're using
    // fast-path output.
    if (scUseFastPathOutput) {
        BYTE *pPackageSpace;

        // For the fast-path case, we send a zero-byte fast-path update PDU
        // (just the header with size field = 0).
        pPackageSpace = SC_GetSpaceInPackage(pPkgInfo,
                scUpdatePDUHeaderSpace);
        if (pPackageSpace != NULL) {
            pPackageSpace[0] = TS_UPDATETYPE_SYNCHRONIZE |
                    scCompressionUsedValue;
            SC_AddToPackage(pPkgInfo, scUpdatePDUHeaderSpace, TRUE);
            upfSyncTokenRequired = FALSE;
        }
        else {
            // Try again later.
            TRC_NRM((TB,"Failed sync packet alloc"));
        }
    }
    else {
        TS_UPDATE_SYNCHRONIZE_PDU UNALIGNED *pUpdateSyncPDU;

        // For the normal case we send a full TS_UPDATE_SYNCHRONIZE_PDU.
        pUpdateSyncPDU = (TS_UPDATE_SYNCHRONIZE_PDU UNALIGNED *)
                SC_GetSpaceInPackage(pPkgInfo,
                sizeof(TS_UPDATE_SYNCHRONIZE_PDU));
        if (pUpdateSyncPDU != NULL) {
            // Fill in the packet contents.
            pUpdateSyncPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_UPDATE;
            pUpdateSyncPDU->updateType = TS_UPDATETYPE_SYNCHRONIZE;
            SC_AddToPackage(pPkgInfo, sizeof(TS_UPDATE_SYNCHRONIZE_PDU),
                    TRUE);
            upfSyncTokenRequired = FALSE;
        }
        else {
            // Try again later.
            TRC_NRM((TB, "failed to allocate sync packet"));
        }
    }

    DC_END_FN();
    return (!upfSyncTokenRequired);
}


/****************************************************************************/
/* Name:      UP_SendBeep                                                   */
/*                                                                          */
/* Purpose:   Send a beep PDU to the client                                 */
/*                                                                          */
/* Returns:   TRUE = success; FALSE = failed to alloc packet                */
/*                                                                          */
/* Params:    IN    duration   - length of beep in ms                       */
/*            IN    frequency  - frequency of beep in Hz                    */
/*                                                                          */
/* Operation: Alloc a beep packet, fill it in and send it.                  */
/****************************************************************************/
BOOL RDPCALL SHCLASS UP_SendBeep(UINT32 duration, UINT32 frequency)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("UP_SendBeep");

    PTS_PLAY_SOUND_PDU pBeepPDU;

    /************************************************************************/
    // If caps say we're not allowed to send this beep, then we jump
    // out. The return code is still TRUE since nothing actually went
    // wrong.
    /************************************************************************/
    if (upCanSendBeep) {
        /********************************************************************/
        // Get a buffer and send the beep.
        /********************************************************************/
        if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pBeepPDU, sizeof(TS_PLAY_SOUND_PDU)) ) {
            // Fill in the PDU 
            pBeepPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_PLAY_SOUND;
            pBeepPDU->data.duration  = duration;
            pBeepPDU->data.frequency = frequency;

            rc = SC_SendData((PTS_SHAREDATAHEADER)pBeepPDU,
                             sizeof(TS_PLAY_SOUND_PDU),
                             sizeof(TS_PLAY_SOUND_PDU),
                             PROT_PRIO_UPDATES,
                             0);
        }
        else {
            TRC_ALT((TB, "Failed to allocate packet for TS_PLAY_SOUND_PDU"));
            rc = FALSE;
        }
    }

    DC_END_FN();
    return rc;
} /* UP_SendBeep */


/****************************************************************************/
/* Name:      UP_PartyJoiningShare                                          */
/*                                                                          */
/* Purpose:   Handles update of sound caps when party joins share           */
/*                                                                          */
/* Returns:   TRUE - party can join                                         */
/*            FALSE - party can't join                                      */
/*                                                                          */
/* Params:    locPersonID - local ID of person trying to join               */
/*            oldShareSize - old share size                                 */
/****************************************************************************/
BOOL RDPCALL SHCLASS UP_PartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      oldShareSize)
{
    DC_BEGIN_FN("UP_PartyJoiningShare");

    DC_IGNORE_PARAMETER(oldShareSize);

    if (SC_LOCAL_PERSON_ID != locPersonID) {
        // Assume we can send beeps. UPEnumSoundCaps will then turn beeps off
        // if a party doesn't support them.
        upCanSendBeep = TRUE;
        CPC_EnumerateCapabilities(TS_CAPSETTYPE_SOUND, NULL, UPEnumSoundCaps);
        TRC_NRM((TB, "Beeps are now %s", upCanSendBeep ? "ENABLED" :
                "DISABLED"));

        UP_UpdateHeaderSize();
    }

    DC_END_FN();
    return TRUE;
} /* UP_PartyJoiningShare */


/****************************************************************************/
/* Name:      UP_PartyLeftShare                                             */
/*                                                                          */
/* Params:    personID - local ID of person leaving                         */
/*            newShareSize - new share size                                 */
/****************************************************************************/
void RDPCALL SHCLASS UP_PartyLeftShare(
        LOCALPERSONID personID,
        unsigned newShareSize)
{
    DC_BEGIN_FN("UP_PartyLeftShare");

    // We always just want to reenumerate the caps and reset variables.
    UP_PartyJoiningShare(personID, newShareSize);

    DC_END_FN();
} /* UP_PartyLeftShare */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\asmint.c ===
/****************************************************************************/
/* asmint.c                                                                 */
/*                                                                          */
/* Security Manager internal functions                                      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "asmint"
#define pTRCWd (pRealSMHandle->pWDHandle)

#include <adcg.h>

#include <acomapi.h>
#include <nwdwapi.h>
#include <anmapi.h>

#include <asmint.h>
#include <tsremdsk.h>

#define DC_INCLUDE_DATA
#include <asmdata.c>
#undef DC_INCLUDE_DATA


/****************************************************************************/
/* Code page based driver compatible Unicode translations                   */
/****************************************************************************/
// Note these are initialized and LastNlsTableBuffer is freed in ntdd.c
// at driver entry and exit.
FAST_MUTEX fmCodePage;
ULONG LastCodePageTranslated;  // I'm assuming 0 is not a valid codepage
PVOID LastNlsTableBuffer;
CPTABLEINFO LastCPTableInfo;
UINT NlsTableUseCount;


/****************************************************************************/
/* Name:      SMDecryptPacket                                               */
/*                                                                          */
/* Purpose:   Decrypt a packet                                              */
/*                                                                          */
/* Returns:   TRUE  - decryption succeeded                                  */
/*            FALSE - decryption failed                                     */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            pData   - packet to decrypt                                   */
/*            dataLen - length of packet to decrypt                         */
/*            fSecureChecksum - take the checksum of the encrypted bytes    */
/*                                                                          */
/****************************************************************************/
BOOL RDPCALL SMDecryptPacket(PSM_HANDLE_DATA pRealSMHandle,
                             PVOID           pData,
                             unsigned        dataLen,
                             BOOL            fSecureChecksum)
{
    BOOL rc = TRUE;
    PRNS_SECURITY_HEADER1_UA pSecHdr;
    PRNS_SECURITY_HEADER2_UA pSecHdr2;
    unsigned coreDataLen;
    PBYTE pCoreData;
    unsigned SecHdrLen;

    DC_BEGIN_FN("SMDecryptPacket");

    /************************************************************************/
    /* Check to see we are encryption is on for this session                */
    /************************************************************************/
    TRC_ASSERT((pRealSMHandle->encrypting),
                (TB,"Decrypt called when we are not encrypting"));

    if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        SecHdrLen = sizeof(RNS_SECURITY_HEADER2);
        pSecHdr2 = (PRNS_SECURITY_HEADER2_UA)pData;
    }
    else {
        SecHdrLen = sizeof(RNS_SECURITY_HEADER1);
    }
    /************************************************************************/
    /* Check if this packet is encrypted                                    */
    /************************************************************************/
    if (dataLen >= SecHdrLen) {
        pSecHdr = (PRNS_SECURITY_HEADER1_UA)pData;
        TRC_ASSERT((pSecHdr->flags & RNS_SEC_ENCRYPT),
                (TB, "This packet is not encrypted"));
    }
    else {
        TRC_ERR((TB,"PDU len %u too short for security header1", dataLen));
        WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                Log_RDP_SecurityDataTooShort, pData, dataLen);
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Get interesting pointers and lengths                                 */
    /************************************************************************/
    if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        coreDataLen = dataLen - sizeof(RNS_SECURITY_HEADER2);
        pCoreData = (PBYTE)(pSecHdr) + sizeof(RNS_SECURITY_HEADER2);
    }
    else {
        coreDataLen = dataLen - sizeof(RNS_SECURITY_HEADER1);
        pCoreData = (PBYTE)(pSecHdr) + sizeof(RNS_SECURITY_HEADER1);
    }

    //
    // Debug verification, we always go with what the protocol header
    // says but verify it's consistent with the capabilities
    //
    if (fSecureChecksum !=
        ((pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM) != 0)) {
        TRC_ERR((TB,
                "fSecureChecksum: 0x%x setting does not match protocol: 0x%x",
                fSecureChecksum, 
                (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM)));
    }

    /************************************************************************/
    /* check to see we need to update the session key.                      */
    /************************************************************************/
    if (pRealSMHandle->decryptCount == UPDATE_SESSION_KEY_COUNT) {
        rc = TRUE;
        // Don't need to update the session key if using FIPS
        if (pRealSMHandle->encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
            rc = UpdateSessionKey(
                    pRealSMHandle->startDecryptKey,
                    pRealSMHandle->currentDecryptKey,
                    pRealSMHandle->encryptionMethodSelected,
                    pRealSMHandle->keyLength,
                    &pRealSMHandle->rc4DecryptKey,
                    pRealSMHandle->encryptionLevel );
        }

        if( !rc ) {
            TRC_ERR((TB, "SM failed to update session key"));

            /****************************************************************/
            /* Log an error and disconnect the Client                       */
            /****************************************************************/
            WDW_LogAndDisconnect(
                    pRealSMHandle->pWDHandle, TRUE, 
                    Log_RDP_ENC_UpdateSessionKeyFailed,
                    NULL,
                    0);

            rc = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* reset counter.                                                   */
        /********************************************************************/
        pRealSMHandle->decryptCount = 0;
    }

    TRC_DATA_DBG("Data buffer before decryption", pCoreData, coreDataLen);

    if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        rc =  TSFIPS_DecryptData(
                            &(pRealSMHandle->FIPSData),
                            pCoreData,
                            coreDataLen,
                            pSecHdr2->padlen,
                            pSecHdr2->dataSignature,
                            pRealSMHandle->totalDecryptCount);
    }
    else {
        rc = DecryptData(
                pRealSMHandle->encryptionLevel,
                pRealSMHandle->currentDecryptKey,
                &pRealSMHandle->rc4DecryptKey,
                pRealSMHandle->keyLength,
                pCoreData,
                coreDataLen,
                pRealSMHandle->macSaltKey,
                pSecHdr->dataSignature,
                (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM),
                pRealSMHandle->totalDecryptCount);
    }

    if (rc) {
        TRC_DBG((TB, "Data decrypted: %ld", coreDataLen));
        TRC_DATA_DBG("Data buffer after decryption", pCoreData, coreDataLen);

        /********************************************************************/
        /* successfully decrypted a packet, increment the decrption counter.*/
        /********************************************************************/
        pRealSMHandle->decryptCount++;
        pRealSMHandle->totalDecryptCount++;
    }
    else {
        TRC_ERR((TB, "SM failed to decrypt data: %ld", coreDataLen));

        /********************************************************************/
        /* Log an error and disconnect the Client                           */
        /********************************************************************/
        WDW_LogAndDisconnect(
                pRealSMHandle->pWDHandle, TRUE, 
                Log_RDP_ENC_DecryptFailed,
                NULL,
                0);

        rc = FALSE;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} /* SMDecryptPacket  */


/****************************************************************************/
/* Name:      SMContinueSecurityExchange                                    */
/*                                                                          */
/* Purpose:   Continue a security exchange                                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                                                          */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            pData         - incoming security exchange packet             */
/*            dataLen       - length of incoming packet                     */
/*                                                                          */
/****************************************************************************/
BOOLEAN RDPCALL SMContinueSecurityExchange(
                    PSM_HANDLE_DATA pRealSMHandle,
                    PVOID           pData,
                    UINT32          dataLen)
{
    BOOLEAN result = TRUE;
    PRNS_SECURITY_PACKET_UA pSecPkt = (PRNS_SECURITY_PACKET_UA) pData;
    
    DC_BEGIN_FN("SMContinueSecurityExchange");

    if (dataLen >= sizeof(RNS_SECURITY_PACKET)) {
        ULONG flags = ((PRNS_SECURITY_PACKET_UA)pData)->flags;

        if (flags & RNS_SEC_INFO_PKT)
            result = SMSecurityExchangeInfo(pRealSMHandle, pData, dataLen);
        else if (flags & RNS_SEC_EXCHANGE_PKT)
            result = SMSecurityExchangeKey(pRealSMHandle, pData, dataLen);
        else
            TRC_ERR((TB,"Unknown security exchange packet flag: %lx", flags));
    }
    else {
        TRC_ERR((TB,"Packet len %u too short for security packet", dataLen));
        WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                Log_RDP_SecurityDataTooShort, pData, dataLen);
        result = FALSE;
    }

    DC_END_FN();
    return (result);
} /* SMContinueSecurityExchange */


/****************************************************************************/
/* Name:      SMSecurityExchangeInfo                                        */
/*                                                                          */
/* Purpose:   Continue a security exchange                                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                                                          */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            pData         - incoming security exchange packet             */
/*            dataLen       - length of incoming packet                     */
/*                                                                          */
/****************************************************************************/
BOOLEAN RDPCALL SMSecurityExchangeInfo(PSM_HANDLE_DATA pRealSMHandle,
                                       PVOID         pData,
                                       UINT32        dataLength)
{
    BOOL rc;
    BOOLEAN result = TRUE;
    PRNS_INFO_PACKET_UA pInfoPkt;
    UINT cb;
    NTSTATUS Status;
   
    DC_BEGIN_FN("SMSecurityExchangeInfo");

    /************************************************************************/
    /* Decrypt the packet if necessary                                      */
    /************************************************************************/
    if (pRealSMHandle->encrypting)
    {
        if (((PRNS_SECURITY_HEADER_UA)pData)->flags & RNS_SEC_ENCRYPT)
        {
            // Wait for session key creation. This can fail if
            // the client has sent bad security data (check
            // pTSWd->SessKeyCreationStatus) or we time out (which
            // indicates an early socket close by the client, since we're
            // using an infinite wait and the socket close returns
            // timeout). On a session key error we force a client disconnect
            // with an appropriate error in the log. Note that we do not
            // have an infinite wait deadlock here, since we have already
            // received the client data and are simply waiting for a 
            // verdict from the WSX about whether the key is usable.
            TRC_DBG((TB, "About to wait for session key creation"));
            Status = WDW_WaitForConnectionEvent(pRealSMHandle->pWDHandle,
                    (pRealSMHandle->pWDHandle)->pSessKeyEvent, -1);
            TRC_DBG((TB, "Back from wait for session key creation"));

            if (!((pRealSMHandle->pWDHandle)->dead) && Status == STATUS_SUCCESS &&
                    NT_SUCCESS((pRealSMHandle->pWDHandle)->
                    SessKeyCreationStatus)) {
                TRC_DBG((TB, "Decrypt the packet"));
                rc = SMDecryptPacket(pRealSMHandle,
                                     pData,
                                     dataLength,
                                     FALSE);
                if (!rc)
                {
                    TRC_ERR((TB, "Failed to decrypt packet"));
                    DC_QUIT;
                }
            }
            else {
                // We initiate an error log and disconnect only if we actually
                // get an error return from user mode in getting the client
                // random / session key. If we don't have an error in the 
                // session key status, and we received a timeout, we
                // know the client disconnected because of the infinite
                // wait above.
                if ((pRealSMHandle->pWDHandle)->dead && Status == STATUS_TIMEOUT) {
                    TRC_NRM((TB,"Client disconnected during sess key wait"));
                }
                else {
                    TRC_ERR((TB,"Failed session key creation, "
                            "wait status=%X, sess key status = %X", Status,
                            (pRealSMHandle->pWDHandle)->
                            SessKeyCreationStatus));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                            Log_RDP_ENC_DecryptFailed, NULL, 0);
                    result = FALSE;
                }

                DC_QUIT;
            }
        }
        else {

            if (pRealSMHandle->pWDHandle->bForceEncryptedCSPDU) {
                TRC_ASSERT((FALSE), (TB, "unencrypted data in encrypted protocol")); 
    
                WDW_LogAndDisconnect(
                            pRealSMHandle->pWDHandle, TRUE,
                            Log_RDP_ENC_DecryptFailed, NULL, 0);
    
                result = FALSE;
                DC_QUIT;
            }
        }
        /********************************************************************/
        /* Adjust pointer and length                                        */
        /********************************************************************/
        if (pRealSMHandle->encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            (PBYTE)pData += sizeof(RNS_SECURITY_HEADER2);
            dataLength -= (sizeof(RNS_SECURITY_HEADER2) + ((PRNS_SECURITY_HEADER2_UA)pData)->padlen);   
        }
        else {
            (PBYTE)pData += sizeof(RNS_SECURITY_HEADER1);
            dataLength -= sizeof(RNS_SECURITY_HEADER1);
        }
    }
    else
    {
        /********************************************************************/
        /* Adjust pointer and length                                        */
        /********************************************************************/
        (PBYTE) pData += sizeof(RNS_SECURITY_HEADER);
        dataLength -= sizeof(RNS_SECURITY_HEADER);
    }

    {
        // Time zone information
        // initialization in case if no timezone information received
        //
        
        //This time zone information is invalid
        //using it we set BaseSrvpStaticServerData->TermsrvClientTimeZoneId to
        //TIME_ZONE_ID_INVALID!
        RDP_TIME_ZONE_INFORMATION InvalidTZ={0,L"",
                {0,10,0,6/*this number makes it invalid; day numbers >5 not allowed*/,0,0,0,0},0,L"",
                {0,4,0,6/*this number makes it invalid*/,0,0,0,0},0};
 
        memcpy(&(pRealSMHandle->pWDHandle->clientTimeZone), &InvalidTZ, 
            sizeof(RDP_TIME_ZONE_INFORMATION));
        
    }

    // initialize the client sessionid to invalid in case there isn't
    // one in the packet
    pRealSMHandle->pWDHandle->clientSessionId = RNS_INFO_INVALID_SESSION_ID;

    /************************************************************************/
    /* Process the packet contents                                          */
    /************************************************************************/
    if (dataLength >= FIELD_OFFSET(RNS_INFO_PACKET, Domain)) {
        // Big enough for the header, but the header promises more data.
        // Validate that we received a packet with all that data
        //
        // To conserve network bandwidth, the RNS_INFO_PACKET is collapsed down so
        // the strings are all adjacent before being sent. Read it in and put the
        // strings in the correct places
        //
        pInfoPkt = (PRNS_INFO_PACKET_UA)pData;
        cb = FIELD_OFFSET(RNS_INFO_PACKET, Domain) + pInfoPkt->cbDomain +
                pInfoPkt->cbUserName + pInfoPkt->cbPassword +
                pInfoPkt->cbAlternateShell + pInfoPkt->cbWorkingDir;

        // There's always 5 extra null terminations
        if (pInfoPkt->flags & RNS_INFO_UNICODE) {
            cb += sizeof(wchar_t) * 5;
        } else {
            cb += 5;
        }

        if (dataLength < cb) {
                TRC_ERR((TB,"Packet len %u too short for info packet data %u",
                        dataLength, cb));
                WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                result = FALSE;
                DC_QUIT;
        }
    } else {
        TRC_ERR((TB,"Packet len %u too short for info packet header",
                                dataLength));
        WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                Log_RDP_SecurityDataTooShort, pData, dataLength);
        result = FALSE;
        DC_QUIT;
    }

    if (pInfoPkt->flags & RNS_INFO_UNICODE) {
        // The client can handle Unicode logon information, so we don't have
        // to do the translation work
        PBYTE psz = &pInfoPkt->Domain[0];
        UINT size;

        //
        // The CodePage field in InfoPacket is overridden to mean
        // active input locale when the infopacket is UNICODE
        //
        pRealSMHandle->pWDHandle->activeInputLocale = pInfoPkt->CodePage;

        // Domain
        cb = pInfoPkt->cbDomain;
        if (cb > TS_MAX_DOMAIN_LENGTH - sizeof(wchar_t))
            cb = TS_MAX_DOMAIN_LENGTH - sizeof(wchar_t);

        pTRCWd->pInfoPkt->cbDomain = (UINT16)cb;
        memcpy(pTRCWd->pInfoPkt->Domain, psz, cb);

        TRC_NRM((TB, "Received Domain (len %d):'%S'", cb,
                pTRCWd->pInfoPkt->Domain));

        psz += pInfoPkt->cbDomain + sizeof(wchar_t);
       
        // Username, Salem Expert pass hardcoded HelpAssistant account
        // name.  Remote Assistance login make uses of auto-logon feature
        // of TermSrv, if login is from HelpAssistant, we by-pass this 
        // fDontDisplayLastUserName and TermSrv will disconnect client 
        // if fail in RA security check.
        cb = pInfoPkt->cbUserName;
        if (cb > TS_MAX_USERNAME_LENGTH - sizeof(wchar_t))
            cb = TS_MAX_USERNAME_LENGTH - sizeof(wchar_t);
        
        pTRCWd->pInfoPkt->cbUserName = (UINT16)cb;
        memcpy(pTRCWd->pInfoPkt->UserName, psz, cb);

        TRC_NRM((TB, "Received UserName (len %d):'%S'", cb,
                pTRCWd->pInfoPkt->UserName));

        psz += pInfoPkt->cbUserName + sizeof(wchar_t);
        cb = pInfoPkt->cbPassword;

        if (cb > TS_MAX_PASSWORD_LENGTH - sizeof(wchar_t))
            cb = TS_MAX_PASSWORD_LENGTH - sizeof(wchar_t);

        pTRCWd->pInfoPkt->cbPassword = (UINT16)cb;
        memcpy(pTRCWd->pInfoPkt->Password, psz, cb);

        TRC_NRM((TB, "Received Password (len %d)", cb));

        psz += pInfoPkt->cbPassword + sizeof(wchar_t);

        // AlternateShell
        cb = pInfoPkt->cbAlternateShell;
        if (cb > TS_MAX_ALTERNATESHELL_LENGTH - sizeof(wchar_t))
            cb = TS_MAX_ALTERNATESHELL_LENGTH - sizeof(wchar_t);

        pTRCWd->pInfoPkt->cbAlternateShell = (UINT16)cb;
        memcpy(pTRCWd->pInfoPkt->AlternateShell, psz,
                cb);

        TRC_NRM((TB, "Received AlternateShell (len %d):'%S'", cb,
                pTRCWd->pInfoPkt->AlternateShell));

        psz += pInfoPkt->cbAlternateShell + sizeof(wchar_t);

        // WorkingDir
        cb = pInfoPkt->cbWorkingDir;
        if (cb > TS_MAX_WORKINGDIR_LENGTH - sizeof(wchar_t))
            cb = TS_MAX_WORKINGDIR_LENGTH - sizeof(wchar_t);

        pTRCWd->pInfoPkt->cbWorkingDir = (UINT16)cb;
        memcpy(pTRCWd->pInfoPkt->WorkingDir, psz, cb);

        TRC_NRM((TB, "Received WorkingDir (len %d):'%S'", cb,
                pTRCWd->pInfoPkt->WorkingDir));
        psz += pInfoPkt->cbWorkingDir + sizeof(wchar_t);

        // new info fields added post win2000 beta 3
        if ((UINT32)(psz - (PBYTE)pData) < dataLength) {
            int currentLen =  (UINT32)(psz - (PBYTE)pData);

            if (currentLen + sizeof(UINT16) * 2 < dataLength) {
                // computer address family
                pRealSMHandle->pWDHandle->clientAddressFamily = 
                        *((PUINT16_UA)psz);
                psz += sizeof(UINT16);
                
                TRC_NRM((TB, "Client address family=%d",
                        pRealSMHandle->pWDHandle->clientAddressFamily));

                // computer address length
                cb = *((PUINT16_UA)psz);
                psz += sizeof(UINT16);

                currentLen += sizeof(UINT16) * 2;

            }
            else {
                TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                        dataLength));
                WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                result = FALSE;
                DC_QUIT;
            }

            if (cb) {
                if (currentLen + cb < dataLength) {
                    // computer address
                    if (cb < TS_MAX_CLIENTADDRESS_LENGTH) 
                        memcpy(&(pRealSMHandle->pWDHandle->clientAddress[0]),
                                psz, cb);
                    else 
                        memcpy(&(pRealSMHandle->pWDHandle->clientAddress[0]),
                                psz, TS_MAX_CLIENTADDRESS_LENGTH - sizeof(wchar_t));
                    psz += cb;
                    TRC_NRM((TB, "Client address=%S", pRealSMHandle->pWDHandle->clientAddress));

                    currentLen += cb;
                }
                else {
                    TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                            dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                            Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // client dir length
            if (currentLen + sizeof(UINT16) < dataLength) {
                cb = *((PUINT16_UA)psz);
                psz += sizeof(UINT16);

                currentLen += sizeof(UINT16);
            }
            else {
                TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                        dataLength));
                WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                result = FALSE;
                DC_QUIT;
            }

            if (cb) {
                // client dir
                if (currentLen + cb <= dataLength) {
                    if (cb < TS_MAX_CLIENTDIR_LENGTH) 
                        memcpy(&(pRealSMHandle->pWDHandle->clientDir[0]),
                                psz, cb);
                    else
                        memcpy(&(pRealSMHandle->pWDHandle->clientDir[0]),
                                psz, TS_MAX_CLIENTDIR_LENGTH - sizeof(wchar_t));
                    psz += cb;
                    TRC_NRM((TB, "Client directory: %S", pRealSMHandle->pWDHandle->clientDir));
                    currentLen += cb;
                }
                else {
                    TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                            dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }


            // is there something else? If yes it must be the time zone
            if ((UINT32)currentLen < dataLength)
            {
                //client time zone information
                cb = sizeof(RDP_TIME_ZONE_INFORMATION);

                if (currentLen + cb <= dataLength) {
                    //time zone information received
                    memcpy(&(pRealSMHandle->pWDHandle->clientTimeZone), psz, cb);
                    
                    psz += cb;

                    currentLen += cb;
                } 
                else {
                    TRC_ERR((TB,"Packet len %u too short for time zone data", dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // is there something else? If yes it must be the client session id
            if ((UINT32)currentLen < dataLength)
            {
                //client session ID
                cb = sizeof(UINT32);

                if (currentLen + cb <= dataLength) {
                    // session id of the client received
                    pRealSMHandle->pWDHandle->clientSessionId = *((PUINT32_UA)psz);

                    psz += cb;

                    currentLen += cb;
                } 
                else {
                    TRC_ERR((TB,"Packet len %u too short for session id data", dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            //
            // is there something else? If yes it must be the perf
            // disabled feature list
            //
            if ((UINT32)currentLen < dataLength)
            {
                //Disabled feature list
                cb = sizeof(UINT32);

                if (currentLen + cb <= dataLength) {
                    // session id of the client received
                    pRealSMHandle->pWDHandle->performanceFlags = *((PUINT32_UA)psz);
                    psz += cb;
                    currentLen += cb;
                } 
                else {
                    TRC_ERR((TB,"Packet len %u too short for session id data", dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // Autoreconnect info length
            pTRCWd->pInfoPkt->ExtraInfo.cbAutoReconnectLen = 0;

            //
            // Is there something else? If yes it must be the autoreconnect info
            //
            if ((UINT32)currentLen < dataLength)
            {
                if (currentLen + sizeof(UINT16) <= dataLength) {
                    cb = *((PUINT16_UA)psz);
                    psz += sizeof(UINT16);
                    currentLen += sizeof(UINT16);
                }
                else {
                    TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                            dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                            Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }

                //
                // Autoreconnect info is optional
                //
                if (cb) {
                    // Variable length Autoreconnect info
                    if (currentLen + cb <= dataLength) {
                        if (cb <= TS_MAX_AUTORECONNECT_LEN) {
                            pTRCWd->pInfoPkt->ExtraInfo.cbAutoReconnectLen = (UINT16)cb;
                            memcpy(pTRCWd->pInfoPkt->ExtraInfo.autoReconnectCookie,
                                   psz, cb);
                            psz += cb;
                            currentLen += cb;
                        }
                        else {
                            pTRCWd->pInfoPkt->ExtraInfo.cbAutoReconnectLen = (UINT16)0;
                            memset(pTRCWd->pInfoPkt->ExtraInfo.autoReconnectCookie, 0,
                                   sizeof(pTRCWd->pInfoPkt->ExtraInfo.autoReconnectCookie));
                            TRC_ERR((TB,"Autoreconnect info too long %d",cb));
                            WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                                Log_RDP_SecurityDataTooShort, pData, dataLength);
                            result = FALSE;
                            DC_QUIT;
                        }
                    }
                    else {
                        TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                                dataLength));
                        WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                            Log_RDP_SecurityDataTooShort, pData, dataLength);
                        result = FALSE;
                        DC_QUIT;
                    }
                }
            }
        }
        // Flags
        pTRCWd->pInfoPkt->flags = pInfoPkt->flags;
    } else {
        // The client can't handle Unicode session information, so the server
        // needs to do the conversion. Most likely Win3.1 client.

        PSTR pszA;

        pszA = pInfoPkt->Domain;

        //
        // The CodePage field in InfoPacket is overridden to mean
        // active input locale when the infopacket is UNICODE.
        // Now that we are ansi we don't get any input locale info so
        // make sure it is zero'd out.
        //
        pRealSMHandle->pWDHandle->activeInputLocale = 0;


        // Domain
        cb = pInfoPkt->cbDomain;
        if (cb >= TS_MAX_DOMAIN_LENGTH)
            cb = TS_MAX_DOMAIN_LENGTH - 1;

        if (-1 == (cb = ConvertToAndFromWideChar(pRealSMHandle,
                pInfoPkt->CodePage, (LPWSTR)pTRCWd->pInfoPkt->Domain,
                sizeof(pTRCWd->pInfoPkt->Domain), pszA, cb, TRUE)))
        {
            TRC_ERR((TB, "Unable to convert domain name"));
            pTRCWd->pInfoPkt->cbDomain = 0;
        }
        else
        {
            pTRCWd->pInfoPkt->cbDomain = (UINT16)cb;
        }

        pszA += pInfoPkt->cbDomain + 1;
        cb = pInfoPkt->cbUserName;
        if (cb >= TS_MAX_USERNAME_LENGTH)
            cb = TS_MAX_USERNAME_LENGTH - 1;

        if (-1 == (cb = ConvertToAndFromWideChar(pRealSMHandle,
                pInfoPkt->CodePage, (LPWSTR)pTRCWd->pInfoPkt->UserName,
                sizeof(pTRCWd->pInfoPkt->UserName), pszA, cb, TRUE)))
        {
            TRC_ERR((TB, "Unable to convert UserName name"));
            pTRCWd->pInfoPkt->cbUserName = 0;
        }
        else
        {
            pTRCWd->pInfoPkt->cbUserName = (UINT16)cb;
        }

        pszA += pInfoPkt->cbUserName + 1;
        cb = pInfoPkt->cbPassword;
        if (cb >= TS_MAX_PASSWORD_LENGTH)
            cb = TS_MAX_PASSWORD_LENGTH - 1;

        if (-1 == (cb = ConvertToAndFromWideChar(pRealSMHandle,
                pInfoPkt->CodePage, (LPWSTR)pTRCWd->pInfoPkt->Password,
                sizeof(pTRCWd->pInfoPkt->Password), pszA, cb, TRUE)))
        {
            TRC_ERR((TB, "Unable to convert Password name"));
            pTRCWd->pInfoPkt->cbPassword = 0;
        }
        else
        {
            pTRCWd->pInfoPkt->cbPassword = (UINT16)cb;
        }
        
        pszA += pInfoPkt->cbPassword + 1;

        // AlternateShell
        cb = pInfoPkt->cbAlternateShell;
        if (cb >= TS_MAX_ALTERNATESHELL_LENGTH)
            cb = TS_MAX_ALTERNATESHELL_LENGTH - 1;

        if (-1 == (cb = ConvertToAndFromWideChar(pRealSMHandle,
                pInfoPkt->CodePage, (LPWSTR)pTRCWd->pInfoPkt->AlternateShell,
                sizeof(pTRCWd->pInfoPkt->AlternateShell), pszA, cb, TRUE)))
        {
            TRC_ERR((TB, "Unable to convert AlternateShell name"));
            pTRCWd->pInfoPkt->cbAlternateShell = 0;
        }
        else
        {
            pTRCWd->pInfoPkt->cbAlternateShell = (UINT16)cb;
        }

        pszA += pInfoPkt->cbAlternateShell + 1;

        // WorkingDir
        cb = pInfoPkt->cbWorkingDir;
        if (cb >= TS_MAX_WORKINGDIR_LENGTH)
            cb = TS_MAX_WORKINGDIR_LENGTH - 1;

        if (-1 == (cb = ConvertToAndFromWideChar(pRealSMHandle,
                pInfoPkt->CodePage, (LPWSTR)pTRCWd->pInfoPkt->WorkingDir,
                sizeof(pTRCWd->pInfoPkt->WorkingDir), pszA, cb, TRUE)))
        {
            TRC_ERR((TB, "Unable to convert WorkingDir name"));
            pTRCWd->pInfoPkt->cbWorkingDir = 0;
        }
        else
        {
            pTRCWd->pInfoPkt->cbWorkingDir = (UINT16)cb;
        }

        pszA += pInfoPkt->cbWorkingDir + 1;

        // new info fields added post win2000 beta 3
        if ((UINT32)(pszA - (PBYTE)pData) < dataLength) {
            int len, currentLen;

            currentLen =  (UINT32)(pszA - (PBYTE)pData);

            if (currentLen + sizeof(UINT16) * 2 < dataLength) {
                // computer address family
                pRealSMHandle->pWDHandle->clientAddressFamily = 
                        *((PUINT16_UA)pszA);
                pszA += sizeof(UINT16);
                TRC_NRM((TB, "Client address family=%d",
                        pRealSMHandle->pWDHandle->clientAddressFamily));

                // computer address length
                cb = *((PUINT16_UA)pszA);
                pszA += sizeof(UINT16);

                currentLen += sizeof(UINT16) * 2;
            }
            else {
               TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                       dataLength));
               WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                    Log_RDP_SecurityDataTooShort, pData, dataLength);
               result = FALSE;
               DC_QUIT;
            }
 
            if (cb) {
                // computer address
                if (currentLen + cb < dataLength) {
                    len = min(cb, TS_MAX_CLIENTADDRESS_LENGTH - sizeof(wchar_t));

                    if (-1 == (len = ConvertToAndFromWideChar(pRealSMHandle,
                            pInfoPkt->CodePage, (LPWSTR)pRealSMHandle->pWDHandle->clientAddress,
                            sizeof(pRealSMHandle->pWDHandle->clientAddress), pszA, len, TRUE)))
                    {
                        TRC_ERR((TB, "Unable to convert clientaddress"));
                        pRealSMHandle->pWDHandle->clientAddress[0] = '\0';
                    }
            
                    pszA += cb;
                    TRC_NRM((TB, "Client address: %S", pRealSMHandle->pWDHandle->clientAddress));

                    currentLen += cb;
                }
                else {
                    TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                            dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // client directory length
            if (currentLen + sizeof(UINT16) < dataLength) {
                cb = *((PUINT16_UA)pszA);
                pszA += sizeof(UINT16);

                currentLen += sizeof(UINT16);
            }
            else {
                TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                        dataLength));
                WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                    Log_RDP_SecurityDataTooShort, pData, dataLength);
                result = FALSE;
                DC_QUIT;
            }

            if (cb) {
                if (currentLen + cb <= dataLength) {
                    len = min(cb, TS_MAX_CLIENTDIR_LENGTH);

                    if (-1 == (len = ConvertToAndFromWideChar(pRealSMHandle,
                            pInfoPkt->CodePage, (LPWSTR)pRealSMHandle->pWDHandle->clientDir,
                            sizeof(pRealSMHandle->pWDHandle->clientDir), pszA, len, TRUE)))
                    {
                        TRC_ERR((TB, "Unable to convert clientaddress"));
                        pRealSMHandle->pWDHandle->clientDir[0] = '\0';
                    }

                    pszA += cb;
                    TRC_NRM((TB, "Client directory: %S", pRealSMHandle->pWDHandle->clientDir));

                    currentLen += cb;
                }
                else {
                    TRC_ERR((TB,"Packet len %u too short for extra info packet data",
                            dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // is there something else? If yes it must be the time zone
            if ((UINT32)currentLen < dataLength)
            {
                //client time zone information
                cb = sizeof(RDP_TIME_ZONE_INFORMATION);

                if (currentLen + cb <= dataLength) {
                    //timezone information received
                
                    memcpy(&(pRealSMHandle->pWDHandle->clientTimeZone), pszA, cb);
                 
                    pszA += cb;
                    currentLen += cb;
                } 
                else {
                    TRC_ERR((TB,"Packet len %u too short for time zone data", dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }

            // is there something else? If yes it must be the client session id
            if ((UINT32)currentLen < dataLength)
            {
                //client time zone information
                cb = sizeof(UINT32);

                if (currentLen + cb <= dataLength) {
                    // session id of the client received
                    pRealSMHandle->pWDHandle->clientSessionId = *((PUINT32_UA)pszA);

                    pszA += cb;

                    currentLen += cb;
                } 
                else {
                    TRC_ERR((TB,"Packet len %u too short for session id data", dataLength));
                    WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                        Log_RDP_SecurityDataTooShort, pData, dataLength);
                    result = FALSE;
                    DC_QUIT;
                }
            }
        }

        // Flags
        pTRCWd->pInfoPkt->flags = pInfoPkt->flags;
        pTRCWd->pInfoPkt->flags |= RNS_INFO_UNICODE;
    }

    //
    // Does client only send encrypted PDUs
    //
    pRealSMHandle->pWDHandle->bForceEncryptedCSPDU = (pInfoPkt->flags & 
            RNS_INFO_FORCE_ENCRYPTED_CS_PDU) ? TRUE : FALSE;

    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
#ifdef USE_LICENSE
    SM_SET_STATE(SM_STATE_LICENSING);
#else
    SM_SET_STATE(SM_STATE_CONNECTED);
#endif

    /************************************************************************/
    /* Tell WDW                                                             */
    /************************************************************************/
    WDW_OnSMConnected(pRealSMHandle->pWDHandle, NM_CB_CONN_OK);

DC_EXIT_POINT:
    DC_END_FN();
    return (result);
} /* SMSecurityExchangeInfo */


/****************************************************************************/
/* Name:      SMSecurityExchangeKey                                         */
/*                                                                          */
/* Purpose:   security key exchange                                         */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*            pData         - incoming security exchange packet             */
/*            dataLen       - length of incoming packet                     */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Values for local variable rc                                             */
/****************************************************************************/
#define SM_RC_DONE      0
#define SM_RC_WAIT      1
#define SM_RC_FAILED    2
BOOLEAN RDPCALL SMSecurityExchangeKey(PSM_HANDLE_DATA pRealSMHandle,
                                      PVOID           pData,
                                      UINT32          dataLen)
{
    BOOLEAN result = TRUE;
    PRNS_SECURITY_PACKET_UA pSecPkt = (PRNS_SECURITY_PACKET_UA) pData;

    DC_BEGIN_FN("SMSecurityExchangeKey");

    /************************************************************************/
    /* check to see we are encrypting.                                      */
    /************************************************************************/
    TRC_ASSERT((pRealSMHandle->encrypting == TRUE),
        (TB,"Recvd a security exchange pkg when we aren't encrypting"));
    if (pRealSMHandle->encrypting == FALSE)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* check to see we received a security exchange pkg.  This pkt contains */
    /* a client random encrypted with the server's public key.              */
    /************************************************************************/

    if (pSecPkt->flags & RNS_SEC_EXCHANGE_PKT) {
        /**********************************************************************/
        /* check to see we have not received a security exchange packet before*/
        /**********************************************************************/
        TRC_ASSERT((pRealSMHandle->recvdClientRandom == FALSE),
            (TB,"Client security packet is already received"));

        if( pRealSMHandle->recvdClientRandom == TRUE ) {
            DC_QUIT;
        }

        // Remember if the client can decrypt an encrypted license packet
        if (pSecPkt->flags & RDP_SEC_LICENSE_ENCRYPT_SC)
            pRealSMHandle->encryptingLicToClient = TRUE;
        else
            pRealSMHandle->encryptingLicToClient = FALSE;

        // Validate the data length
        if(sizeof(RNS_SECURITY_PACKET) + pSecPkt->length > dataLen)
        {
            TRC_ERR((TB, "Error: Security packet length %u too short", dataLen));
            WDW_LogAndDisconnect(pRealSMHandle->pWDHandle, TRUE, 
                    Log_RDP_SecurityDataTooShort, pData, dataLen);
            result = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* note the length of the security pkg.                             */
        /********************************************************************/
    
        pRealSMHandle->encClientRandomLen = pSecPkt->length;
    
        /********************************************************************/
        /* Allocate memory for the security info.                           */
        /********************************************************************/
    
        pRealSMHandle->pEncClientRandom =
            (PBYTE)COM_Malloc(pSecPkt->length);
    
        if( pRealSMHandle->pEncClientRandom == NULL ) {
            DC_QUIT;
        }

        /********************************************************************/
        /* copy the client random, set the appropriate flags and signal it. */
        /********************************************************************/
        
        memcpy(
            pRealSMHandle->pEncClientRandom,
            (PBYTE)(pSecPkt + 1),
            pSecPkt->length );
    
        pRealSMHandle->recvdClientRandom = TRUE;
            
        /********************************************************************/
        /* Shadow stacks go immediately to connected at this stage since    */
        /* we don't have to wait for the normal initial prog, etc. to come  */
        /* from the client.                                                 */
        /********************************************************************/        
        if (pRealSMHandle->pWDHandle->StackClass == Stack_Shadow) {
           pRealSMHandle->pWDHandle->connected = TRUE;
           SM_SET_STATE(SM_STATE_CONNECTED);
           SM_SET_STATE(SM_STATE_SC_REGISTERED);
           SM_Dead(pRealSMHandle, FALSE);
        }

        KeSetEvent ((pRealSMHandle->pWDHandle)->pSecEvent, 0, FALSE);
    }
    else {
        TRC_ERR((TB, "Unknown security packet flags: %lx", pSecPkt->flags));                
    }

DC_EXIT_POINT:
    DC_END_FN();
    return (result);
} /* SMSecurityExchangeKey */


/****************************************************************************/
/* Name:      SMFreeInitResources                                           */
/*                                                                          */
/* Purpose:   Free resources allocated at initialization                    */
/****************************************************************************/
void RDPCALL SMFreeInitResources(PSM_HANDLE_DATA pRealSMHandle)
{
    DC_BEGIN_FN("SMFreeInitResources");

    /************************************************************************/
    /* nothing to free up here.                                             */
    /************************************************************************/

    DC_END_FN();
} /* SMFreeInitResources */


/****************************************************************************/
/* Name:      SMFreeConnectResources                                        */
/*                                                                          */
/* Purpose:   Free resources allocated when a Client connects               */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pRealSMHandle - SM Handle                                     */
/*                                                                          */
/****************************************************************************/
void RDPCALL SMFreeConnectResources(PSM_HANDLE_DATA pRealSMHandle)
{
    DC_BEGIN_FN("SMFreeConnectResources");

    /************************************************************************/
    /* Free the user data (if any)                                          */
    /************************************************************************/
    if (pRealSMHandle->pUserData)
    {
        TRC_NRM((TB, "Free user data"));
        COM_Free(pRealSMHandle->pUserData);
        pRealSMHandle->pUserData = NULL;
    }

    if( pRealSMHandle->pEncClientRandom != NULL ) {

        TRC_NRM((TB, "Free pEncClientRandom"));
        COM_Free(pRealSMHandle->pEncClientRandom);
        pRealSMHandle->pEncClientRandom = NULL;
    }
    
    DC_END_FN();
} /* SMFreeClientResources */



#define NLS_TABLE_KEY \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage"

BOOL GetNlsTablePath(
    PSM_HANDLE_DATA pRealSMHandle,
    UINT CodePage,
    PWCHAR PathBuffer
)
/*++

Routine Description:

  This routine takes a code page identifier, queries the registry to find the
  appropriate NLS table for that code page, and then returns a path to the
  table.

Arguments;

  CodePage - specifies the code page to look for

  PathBuffer - Specifies a buffer into which to copy the path of the NLS
    file.  This routine assumes that the size is at least MAX_PATH

Return Value:

  TRUE if successful, FALSE otherwise.

Gerrit van Wingerden [gerritv] 1/22/96

-*/
{
    NTSTATUS NtStatus;
    BOOL Result = FALSE;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    DC_BEGIN_FN("GetNlsTablePath");

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        WCHAR *ResultBuffer;
        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH + 
          sizeof(KEY_VALUE_FULL_INFORMATION);

        ResultBuffer = ExAllocatePoolWithTag(PagedPool, BufferSize, (ULONG) 'slnG');
        if(ResultBuffer)
        {
            ULONG ValueReturnedLength;
            WCHAR CodePageStringBuffer[20];
            RtlZeroMemory(ResultBuffer, BufferSize);
            swprintf(CodePageStringBuffer, L"%d", CodePage);

            RtlInitUnicodeString(&UnicodeString,CodePageStringBuffer);

            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) ResultBuffer;

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {

                swprintf(PathBuffer,L"\\SystemRoot\\System32\\%ws",
                         &(KeyValueInformation->Data[0]));
                Result = TRUE;
            }
            else
            {
                TRC_ERR((TB, "GetNlsTablePath failed to get NLS table\n"));
            }
            ExFreePool((PVOID)ResultBuffer);
        }
        else
        {
            TRC_ERR((TB, "GetNlsTablePath out of memory\n"));
        }

        ZwClose(RegistryKeyHandle);
    }
    else
    {
        TRC_ERR((TB, "GetNlsTablePath failed to open NLS key\n"));
    }


    DC_END_FN();
    return(Result);
}


INT ConvertToAndFromWideChar(
    PSM_HANDLE_DATA pRealSMHandle,
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString,
    BOOL ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a character string to or from a wide char string
  assuming a specified code page.  Most of the actual work is done inside
  RtlCustomCPToUnicodeN, but this routine still needs to manage the loading
  of the NLS files before passing them to the RtlRoutine.  We will cache
  the mapped NLS file for the most recently used code page which ought to
  suffice for out purposes.

Arguments:
  CodePage - the code page to use for doing the translation.

  WideCharString - buffer the string is to be translated into.

  BytesInWideCharString - number of bytes in the WideCharString buffer
    if converting to wide char and the buffer isn't large enough then the
    string in truncated and no error results.

  MultiByteString - the multibyte string to be translated to Unicode.

  BytesInMultiByteString - number of bytes in the multibyte string if
    converting to multibyte and the buffer isn't large enough the string
    is truncated and no error results

  ConvertToWideChar - if TRUE then convert from multibyte to widechar
    otherwise convert from wide char to multibyte

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Gerrit van Wingerden [gerritv] 1/22/96

-*/
{
    NTSTATUS NtStatus;
    USHORT OemCodePage, AnsiCodePage;
    CPTABLEINFO LocalTableInfo;
    PCPTABLEINFO TableInfo = NULL;
    PVOID LocalTableBase = NULL;
    INT BytesConverted = 0;

    DC_BEGIN_FN("ConvertToAndFromWideChar");

    // Codepage 0 is not valid
    if (0 == CodePage) 
    {
        TRC_ERR((TB, "EngMultiByteToWideChar invalid code page\n"));
        BytesConverted = -1;
        DC_QUIT;
    }

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    // see if we can use the default translation routinte

    if(AnsiCodePage == CodePage)
    {
        if(ConvertToWideChar)
        {
            NtStatus = RtlMultiByteToUnicodeN(WideCharString,
                                              BytesInWideCharString,
                                              &BytesConverted,
                                              MultiByteString,
                                              BytesInMultiByteString);
        }
        else
        {
            NtStatus = RtlUnicodeToMultiByteN(MultiByteString,
                                              BytesInMultiByteString,
                                              &BytesConverted,
                                              WideCharString,
                                              BytesInWideCharString);
        }


        if(NT_SUCCESS(NtStatus))
        {
            return(BytesConverted);
        }
        else
        {
            return(-1);
        }
    }

    ExAcquireFastMutex(&fmCodePage);

    if(CodePage == LastCodePageTranslated)
    {
        // we can use the cached code page information
        TableInfo = &LastCPTableInfo;
        NlsTableUseCount += 1;
    }

    ExReleaseFastMutex(&fmCodePage);

    if(TableInfo == NULL)
    {
        // get a pointer to the path of the NLS table

        WCHAR NlsTablePath[MAX_PATH];

        if(GetNlsTablePath(pRealSMHandle, CodePage,NlsTablePath))
        {
            UNICODE_STRING UnicodeString;
            IO_STATUS_BLOCK IoStatus;
            HANDLE NtFileHandle;
            OBJECT_ATTRIBUTES ObjectAttributes;

            RtlInitUnicodeString(&UnicodeString,NlsTablePath);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                       NULL,
                                       NULL);

            NtStatus = ZwCreateFile(&NtFileHandle,
                                    SYNCHRONIZE | FILE_READ_DATA,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0);

            if(NT_SUCCESS(NtStatus))
            {
                FILE_STANDARD_INFORMATION StandardInfo;

                // Query the object to determine its length.

                NtStatus = ZwQueryInformationFile(NtFileHandle,
                                                  &IoStatus,
                                                  &StandardInfo,
                                                  sizeof(FILE_STANDARD_INFORMATION),
                                                  FileStandardInformation);

                if(NT_SUCCESS(NtStatus))
                {
                    UINT LengthOfFile = StandardInfo.EndOfFile.LowPart;

                    LocalTableBase = ExAllocatePoolWithTag(PagedPool, LengthOfFile,
                            (ULONG)'cwcG');

                    if(LocalTableBase)
                    {
                        RtlZeroMemory(LocalTableBase, LengthOfFile);

                        // Read the file into our buffer.

                        NtStatus = ZwReadFile(NtFileHandle,
                                              NULL,
                                              NULL,
                                              NULL,
                                              &IoStatus,
                                              LocalTableBase,
                                              LengthOfFile,
                                              NULL,
                                              NULL);

                        if(!NT_SUCCESS(NtStatus))
                        {
                            TRC_ERR((TB, "WDMultiByteToWideChar unable to read file\n"));
                            ExFreePool((PVOID)LocalTableBase);
                            LocalTableBase = NULL;
                        }
                    }
                    else
                    {
                        TRC_ERR((TB, "WDMultiByteToWideChar out of memory\n"));
                    }
                }
                else
                {
                    TRC_ERR((TB, "WDMultiByteToWideChar unable query NLS file\n"));
                }

                ZwClose(NtFileHandle);
            }
            else
            {
                TRC_ERR((TB, "EngMultiByteToWideChar unable to open NLS file\n"));
            }
        }
        else
        {
            TRC_ERR((TB, "EngMultiByteToWideChar get registry entry for NLS file failed\n"));
        }

        if(LocalTableBase == NULL)
        {
            return(-1);
        }

        // now that we've got the table use it to initialize the CodePage table

        RtlInitCodePageTable(LocalTableBase,&LocalTableInfo);
        TableInfo = &LocalTableInfo;
    }

    // Once we are here TableInfo points to the the CPTABLEINFO struct we want


    if(ConvertToWideChar)
    {
        NtStatus = RtlCustomCPToUnicodeN(TableInfo,
                                         WideCharString,
                                         BytesInWideCharString,
                                         &BytesConverted,
                                         MultiByteString,
                                         BytesInMultiByteString);
    }
    else
    {
        NtStatus = RtlUnicodeToCustomCPN(TableInfo,
                                         MultiByteString,
                                         BytesInMultiByteString,
                                         &BytesConverted,
                                         WideCharString,
                                         BytesInWideCharString);
    }


    if(!NT_SUCCESS(NtStatus))
    {
        // signal failure

        BytesConverted = -1;
    }


    // see if we need to update the cached CPTABLEINFO information

    if(TableInfo != &LocalTableInfo)
    {
        // we must have used the cached CPTABLEINFO data for the conversion
        // simple decrement the reference count

        ExAcquireFastMutex(&fmCodePage);
        NlsTableUseCount -= 1;
        ExReleaseFastMutex(&fmCodePage);
    }
    else
    {
        PVOID FreeTable;

        // we must have just allocated a new CPTABLE structure so cache it
        // unless another thread is using current cached entry

        ExAcquireFastMutex(&fmCodePage);
        if(!NlsTableUseCount)
        {
            LastCodePageTranslated = CodePage;
            RtlMoveMemory(&LastCPTableInfo, TableInfo, sizeof(CPTABLEINFO));
            FreeTable = LastNlsTableBuffer;
            LastNlsTableBuffer = LocalTableBase;
        }
        else
        {
            FreeTable = LocalTableBase;
        }
        ExReleaseFastMutex(&fmCodePage);

        // Now free the memory for either the old table or the one we allocated
        // depending on whether we update the cache.  Note that if this is
        // the first time we are adding a cached value to the local table, then
        // FreeTable will be NULL since LastNlsTableBuffer will be NULL

        if(FreeTable)
        {
            ExFreePool((PVOID)FreeTable);
        }
    }

    // we are done
DC_EXIT_POINT:
    DC_END_FN();

    return(BytesConverted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\hotkey.c ===
/****************************************************************************/
/* hotkey.c                                                                 */
/*                                                                          */
/* RDP Shadow hotkey handling functions.                                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-2000                             */
/****************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#define TRC_FILE "hotkey"

#include <precomp.h>
#pragma hdrstop

#define pTRCWd pWd
#include <adcg.h>
#include <nwdwapi.h>
#include <nwdwint.h>
#include "kbd.h"        //TODO:  Good Grief!


typedef struct {
    DWORD dwVersion;
    DWORD dwFlags;
    DWORD dwMapCount;
    DWORD dwMap[0];
} SCANCODEMAP, *PSCANCODEMAP;


/***************************************************************************\
* How some Virtual Key values change when a SHIFT key is held down.
\***************************************************************************/
#define VK_MULTIPLY       0x6A
#define VK_SNAPSHOT       0x2C
const ULONG aulShiftCvt_VK[] = {
    MAKELONG(VK_MULTIPLY, VK_SNAPSHOT),
    MAKELONG(0,0)
};


/***************************************************************************\
* How some Virtual Key values change when a CONTROL key is held down.
\***************************************************************************/
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5
#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91
#define VK_PAUSE          0x13
#define VK_CANCEL         0x03
//#define KBDEXT      (USHORT)0x0100


const ULONG aulControlCvt_VK[] = {
    MAKELONG(VK_NUMLOCK,  VK_PAUSE | KBDEXT),
    MAKELONG(VK_SCROLL,   VK_CANCEL),
    MAKELONG(0,0)
};


/***************************************************************************\
* How some Virtual Key values change when an ALT key is held down.
* The SHIFT and ALT keys both alter VK values the same way!!
\***************************************************************************/
#define aulAltCvt_VK aulShiftCvt_VK


/***************************************************************************\
* This table list keys that may affect Virtual Key values when held down.
*
* See kbd.h for a full description.
*
* 101/102key keyboard (type 4):
*    Virtual Key values vary only if CTRL is held down.
* 84-86 key keyboards (type 3):
*    Virtual Key values vary if one of SHIFT, CTRL or ALT is held down.
\***************************************************************************/
#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
//#define KBDSHIFT       1
//#define KBDCTRL        2
//#define KBDALT         4

const VK_TO_BIT aVkToBits_VK[] = {
    { VK_SHIFT,   KBDSHIFT }, // 0x01
    { VK_CONTROL, KBDCTRL  }, // 0x02
    { VK_MENU,    KBDALT   }, // 0x04
    { 0,          0        }
};


/***************************************************************************\
* Tables defining how some Virtual Key values are modified when other keys
* are held down.
* Translates key combinations into indices for gapulCvt_VK_101[] or for
* gapulCvt_VK_84[] or for
*
* See kbd.h for a full description.
*
\***************************************************************************/

//#define SHFT_INVALID 0x0F
const MODIFIERS Modifiers_VK = {
    (PVK_TO_BIT)&aVkToBits_VK[0],
    4,                 // Maximum modifier bitmask/index
    {
        SHFT_INVALID,  // no keys held down    (no VKs are modified)
        0,             // SHIFT held down      84-86 key kbd
        1,             // CTRL held down       101/102 key kbd
        SHFT_INVALID,  // CTRL-SHIFT held down (no VKs are modified)
        2              // ALT held down        84-86 key kbd
    }
};


/***************************************************************************\
* A tables of pointers indexed by the number obtained from Modify_VK.
* If a pointer is non-NULL then the table it points to is searched for
* Virtual Key that should have their values changed.
* There are two versions: one for 84-86 key kbds, one for 101/102 key kbds.
* gapulCvt_VK is initialized with the default (101/102 key kbd).
\***************************************************************************/
const ULONG *const gapulCvt_VK_101[] = {
    NULL,                 // No VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    NULL                  // No VKs are changed by ALT being held down
};

const ULONG *const gapulCvt_VK_84[] = {
    aulShiftCvt_VK,       // Some VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    aulAltCvt_VK          // Some VKs are changed by ALT being held down
};


/*
 * Determine the state of all the Modifier Keys (a Modifier Key
 * is any key that may modify values produced by other keys: these are
 * commonly SHIFT, CTRL and/or ALT)
 * Build a bit-mask (wModBits) to encode which modifier keys are depressed.
 */
#define KEY_BYTE(pb, vk)           pb[((BYTE)(vk)) >> 2]
#define KEY_DOWN_BIT(vk)           (1 << ((((BYTE)(vk)) & 3) << 1))
#define KEY_TOGGLE_BIT(vk)         (1 << (((((BYTE)(vk)) & 3) << 1) + 1))

#define TestKeyDownBit(pb, vk)     (KEY_BYTE(pb,vk) &   KEY_DOWN_BIT(vk))
#define SetKeyDownBit(pb, vk)      (KEY_BYTE(pb,vk) |=  KEY_DOWN_BIT(vk))
#define ClearKeyDownBit(pb, vk)    (KEY_BYTE(pb,vk) &= ~KEY_DOWN_BIT(vk))
#define TestKeyToggleBit(pb, vk)   (KEY_BYTE(pb,vk) &   KEY_TOGGLE_BIT(vk))
#define SetKeyToggleBit(pb, vk)    (KEY_BYTE(pb,vk) |=  KEY_TOGGLE_BIT(vk))
#define ClearKeyToggleBit(pb, vk)  (KEY_BYTE(pb,vk) &= ~KEY_TOGGLE_BIT(vk))
#define ToggleKeyToggleBit(pb, vk) (KEY_BYTE(pb,vk) ^=  KEY_TOGGLE_BIT(vk))

WORD GetModifierBits(
    PMODIFIERS pModifiers,
    LPBYTE afKeyState)
{
    PVK_TO_BIT pVkToBit = pModifiers->pVkToBit;
    WORD wModBits = 0;

    while (pVkToBit->Vk) {
        if (TestKeyDownBit(afKeyState, pVkToBit->Vk)) {
            wModBits |= pVkToBit->ModBits;
        }
        pVkToBit++;
    }
    return wModBits;
}


/***************************************************************************\
* MapScancode
*
* Converts a scancode (and it's prefix, if any) to a different scancode
* and prefix.
*
* Parameters:
*   pbScanCode = address of Scancode byte, the scancode may be changed
*   pbPrefix   = address of Prefix byte, The prefix may be changed
*
* Return value:
*   TRUE  - mapping was found, scancode was altered.
*   FALSE - no mapping fouind, scancode was not altered.
*
* Note on scancode map table format:
*     A table entry DWORD of 0xE0450075 means scancode 0x45, prefix 0xE0
*     gets mapped to scancode 0x75, no prefix
*
* History:
* 96-04-18 IanJa      Created.
\***************************************************************************/
BOOL
MapScancode(
    PSCANCODEMAP gpScancodeMap,
    PBYTE pbScanCode,
    PBYTE pbPrefix
    )
{
    DWORD *pdw;
    WORD wT = MAKEWORD(*pbScanCode, *pbPrefix);

    ASSERT(gpScancodeMap != NULL);

    for (pdw = &(gpScancodeMap->dwMap[0]); *pdw; pdw++) {
        if (HIWORD(*pdw) == wT) {
            wT = LOWORD(*pdw);
            *pbScanCode = LOBYTE(wT);
            *pbPrefix = HIBYTE(wT);
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * Given modifier bits, return the modification number.
 */
WORD GetModificationNumber(
    PMODIFIERS pModifiers,
    WORD wModBits)
{
    if (wModBits > pModifiers->wMaxModBits) {
         return SHFT_INVALID;
    }

    return pModifiers->ModNumber[wModBits];
}


/***************************************************************************\
* UpdatePhysKeyState
*
* A helper routine for KeyboardApcProcedure.
* Based on a VK and a make/break flag, this function will update the physical
* keystate table.
*
* History:
* 10-13-91 IanJa        Created.
\***************************************************************************/
void UpdatePhysKeyState(
    BYTE Vk,
    BOOL fBreak,
    LPBYTE gafPhysKeyState )
{
    if (fBreak) {
        ClearKeyDownBit(gafPhysKeyState, Vk);
    } else {

        /*
         * This is a key make.  If the key was not already down, update the
         * physical toggle bit.
         */
        if (!TestKeyDownBit(gafPhysKeyState, Vk)) {
            if (TestKeyToggleBit(gafPhysKeyState, Vk)) {
                ClearKeyToggleBit(gafPhysKeyState, Vk);
            } else {
                SetKeyToggleBit(gafPhysKeyState, Vk);
            }
        }

        /*
         * This is a make, so turn on the physical key down bit.
         */
        SetKeyDownBit(gafPhysKeyState, Vk);
    }
}


/*****************************************************************************\
* VKFromVSC
*
* This function is called from KeyEvent() after each call to VSCFromSC.  The
* keyboard input data passed in is translated to a virtual key code.
* This translation is dependent upon the currently depressed modifier keys.
*
* For instance, scan codes representing the number pad keys may be
* translated into VK_NUMPAD codes or cursor movement codes depending
* upon the state of NumLock and the modifier keys.
*
* History:
*
\*****************************************************************************/
BYTE WD_VKFromVSC(
    PKBDTABLES pKbdTbl,
    PKE pke,
    BYTE bPrefix,
    LPBYTE gafPhysKeyState,
    BOOLEAN KeyboardType101 )
{
    USHORT usVKey = 0xFF;
    PVSC_VK pVscVk = NULL;
    static BOOL fVkPause;
    PULONG *gapulCvt_VK;

//    DBG_UNREFERENCED_PARAMETER(afKeyState);

    if (pke->bScanCode == 0xFF) {
        /*
         * Kbd overrun (kbd hardware and/or keyboard driver) : Beep!
         * (some DELL keyboards send 0xFF if keys are hit hard enough,
         * presumably due to keybounce)
         */
//        xxxMessageBeep(0);
        return 0;
    }

    pke->bScanCode &= 0x7F;

//    if (gptiForeground == NULL) {
//        RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL gptiForeground\n");
//        pKbdTbl = gpKbdTbl;
//    } else {
//        if (gptiForeground->spklActive) {
//            pKbdTbl = gptiForeground->spklActive->spkf->pKbdTbl;
//        } else {
//            RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL spklActive\n");
//            pKbdTbl = gpKbdTbl;
//        }
//    }
    if (bPrefix == 0) {
        if (pke->bScanCode < pKbdTbl->bMaxVSCtoVK) {
            /*
             * direct index into non-prefix table
             */
            usVKey = pKbdTbl->pusVSCtoVK[pke->bScanCode];
            if (usVKey == 0) {
                return 0xFF;
            }
        } else {
            /*
             * unexpected scancode
             */
//            RIPMSG2(RIP_VERBOSE, "unrecognized scancode 0x%x, prefix %x",
//                    pke->bScanCode, bPrefix);
            return 0xFF;
        }
    } else {
        /*
         * Scan the E0 or E1 prefix table for a match
         */
        if (bPrefix == 0xE0) {
            /*
             * Ignore the SHIFT keystrokes generated by the hardware
             */
            if ((pke->bScanCode == SCANCODE_LSHIFT) ||
                    (pke->bScanCode == SCANCODE_RSHIFT)) {
                return 0;
            }
            pVscVk = pKbdTbl->pVSCtoVK_E0;
        } else if (bPrefix == 0xE1) {
            pVscVk = pKbdTbl->pVSCtoVK_E1;
        }
        while (pVscVk != NULL && pVscVk->Vk) {
            if (pVscVk->Vsc == pke->bScanCode) {
                usVKey = pVscVk->Vk;
                break;
            }
            pVscVk++;
        }
    }

    /*
     * Scancode set 1 returns PAUSE button as E1 1D 45 (E1 Ctrl NumLock)
     * so convert E1 Ctrl to VK_PAUSE, and remember to discard the NumLock
     */
    if (fVkPause) {
        /*
         * This is the "45" part of the Pause scancode sequence.
         * Discard this key event: it is a false NumLock
         */
        fVkPause = FALSE;
        return 0;
    }
    if (usVKey == VK_PAUSE) {
        /*
         * This is the "E1 1D" part of the Pause scancode sequence.
         * Alter the scancode to the value Windows expects for Pause,
         * and remember to discard the "45" scancode that will follow
         */
        pke->bScanCode = 0x45;
        fVkPause = TRUE;
    }

    /*
     * Convert to a different VK if some modifier keys are depressed.
     */
    if (usVKey & KBDMULTIVK) {
        WORD nMod;
        PULONG pul;

        nMod = GetModificationNumber(
                   (MODIFIERS *)&Modifiers_VK,
                   GetModifierBits((MODIFIERS *)&Modifiers_VK,
                       gafPhysKeyState));

        /*
         * Scan gapulCvt_VK[nMod] for matching VK.
         */
        if ( KeyboardType101 )
            gapulCvt_VK = (PULONG *)gapulCvt_VK_101;
        else
            gapulCvt_VK = (PULONG *)gapulCvt_VK_84;
        if ((nMod != SHFT_INVALID) && ((pul = gapulCvt_VK[nMod]) != NULL)) {
            while (*pul != 0) {
                if (LOBYTE(*pul) == LOBYTE(usVKey)) {
                    pke->usFlaggedVk = (USHORT)HIWORD(*pul);
                    return (BYTE)pke->usFlaggedVk;
                }
                pul++;
            }
        }
    }

    pke->usFlaggedVk = usVKey;
    return (BYTE)usVKey;
}


/***************************************************************************\
* KeyboardHotKeyProcedure 
*
* return TRUE if the hotkey is detected, false otherwise
*
* HotkeyVk (input)
*    - hotkey to look for
* HotkeyModifiers (input)
*    - hotkey to look for
* pkei (input)
*    - scan code 
* gpScancodeMap (input)
*    - scan code map from WIN32K
* pKbdTbl (input)
*    - keyboard layout from WIN32K
* KeyboardType101 (input)
*    - keyboard type from WIN32K
* gafPhysKeyState (input/output)
*    - key states
*
\***************************************************************************/
BOOLEAN KeyboardHotKeyProcedure(
        BYTE HotkeyVk,
        USHORT HotkeyModifiers,
        PKEYBOARD_INPUT_DATA pkei,
        PVOID gpScancodeMap,
        PVOID pKbdTbl,
        BOOLEAN KeyboardType101,
        PVOID gafPhysKeyState )
{
    BYTE Vk;
    BYTE bPrefix;
    KE ke;
    WORD ModBits;

    if ( !pKbdTbl || !gafPhysKeyState ) {
        return FALSE;
    }

    if (pkei->Flags & KEY_E0) {
        bPrefix = 0xE0;
    } else if (pkei->Flags & KEY_E1) {
        bPrefix = 0xE1;
    } else {
        bPrefix = 0;
    }

    ke.bScanCode = (BYTE)(pkei->MakeCode & 0x7F);
    if (gpScancodeMap) {
        MapScancode(gpScancodeMap, &ke.bScanCode, &bPrefix);
    }

    Vk = WD_VKFromVSC(pKbdTbl, &ke, bPrefix, gafPhysKeyState, KeyboardType101);

    if ((Vk == 0) || (Vk == VK__none_)) {
        return FALSE;
    }

    if (pkei->Flags & KEY_BREAK) {
        ke.usFlaggedVk |= KBDBREAK;
    }

//    Vk = (BYTE)ke.usFlaggedVk;

    UpdatePhysKeyState(Vk, ke.usFlaggedVk & KBDBREAK, gafPhysKeyState);

    /*
     * Convert Left/Right Ctrl/Shift/Alt key to "unhanded" key.
     * ie: if VK_LCONTROL or VK_RCONTROL, convert to VK_CONTROL etc.
     */
    if ((Vk >= VK_LSHIFT) && (Vk <= VK_RMENU)) {
        Vk = (BYTE)((Vk - VK_LSHIFT) / 2 + VK_SHIFT);
        UpdatePhysKeyState(Vk, ke.usFlaggedVk & KBDBREAK, gafPhysKeyState);
    }

    /*
     * Now check if the shadow hotkey has been hit
     */
    if ( Vk == HotkeyVk && !(ke.usFlaggedVk & KBDBREAK) ) {
        ModBits = GetModifierBits( (MODIFIERS *)&Modifiers_VK, gafPhysKeyState );
        if ( ModBits == HotkeyModifiers )
              return( TRUE );
    }

    return( FALSE );
}


/*******************************************************************************
 *
 *  KeyboardSetKeyState
 *
 *  Initialize keyboard state
 *
 * ENTRY:
 *    pgafPhysKeyState (input/output)
 *       - buffer to allocate or clear
 *    
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
#define CVKKEYSTATE                 256
#define CBKEYSTATE                  (CVKKEYSTATE >> 2)

NTSTATUS
KeyboardSetKeyState( PTSHARE_WD pWd, PVOID *pgafPhysKeyState )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( *pgafPhysKeyState == NULL ) {
        *pgafPhysKeyState = COM_Malloc(CBKEYSTATE);
        if ( *pgafPhysKeyState == NULL )
            return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( *pgafPhysKeyState, CBKEYSTATE );

    return Status;
}

/*******************************************************************************
 *
 *  KeyboardFixupLayout
 *
 *  Fixup the pointers inside the keyboard layout 
 *
 * ENTRY:
 *    pLayout (input/output)
 *       - buffer to fixup
 *    pOriginal (input)
 *       - pointer to original layout buffer
 *    Length (input)
 *       - length of layout buffer
 *    pKbdTblOriginal (input)
 *       - pointer to original KbdTbl table
 *    ppKbdTbl (output)
 *       - pointer to location to save ptr to new KbdTbl table
 *    
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
#define FIXUP_PTR(p, pBase, pOldBase) ((p) ? (p) = (PVOID) ( (PBYTE)pBase + (ULONG) ( (PBYTE)p - (PBYTE)pOldBase ) ) : 0)
//#define CHECK_PTR( p, Limit) { if ( (PVOID)p > Limit ) { ASSERT(FALSE); return STATUS_BUFFER_TOO_SMALL; } }

#define CHECK_PTR( ptr, Limit) \
    { if ( (PBYTE) (ptr) > (PBYTE) (Limit) ) { \
        KdPrint(("Bad Ptr, Line %ld: %p > %p \n", __LINE__, ptr, Limit)); \
        /* ASSERT(FALSE); */ \
        /* return STATUS_BUFFER_TOO_SMALL; */ } }

NTSTATUS
KeyboardFixupLayout( PVOID pKbdLayout, PVOID pOriginal, ULONG Length,
                     PVOID pKbdTblOrig, PVOID *ppKbdTbl )
{
    NTSTATUS Status = STATUS_SUCCESS;
    VK_TO_WCHAR_TABLE *pVkToWcharTable;
    VSC_LPWSTR *pKeyName;
    LPWSTR *lpDeadKey;
    PKBDTABLES pKbdTbl;
    PVOID pLimit;

    if ( Length < sizeof(KBDTABLES) )  {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto error;
    }

    pLimit = (PBYTE)pKbdLayout + Length;

    pKbdTbl = pKbdTblOrig;
    FIXUP_PTR(pKbdTbl, pKbdLayout,  pOriginal);
    FIXUP_PTR(pKbdTbl->pCharModifiers, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pCharModifiers, pLimit);
    FIXUP_PTR(pKbdTbl->pCharModifiers->pVkToBit, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pCharModifiers->pVkToBit, pLimit);
    if (FIXUP_PTR(pKbdTbl->pVkToWcharTable, pKbdLayout, pOriginal)) {
        CHECK_PTR(pKbdTbl->pVkToWcharTable, pLimit);
        for (pVkToWcharTable = pKbdTbl->pVkToWcharTable;
             pVkToWcharTable->pVkToWchars != NULL; pVkToWcharTable++) {
            FIXUP_PTR(pVkToWcharTable->pVkToWchars, pKbdLayout, pOriginal);
            CHECK_PTR(pVkToWcharTable->pVkToWchars, pLimit);
        }
    }
    FIXUP_PTR(pKbdTbl->pDeadKey, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pDeadKey, pLimit);
    if (FIXUP_PTR(pKbdTbl->pKeyNames, pKbdLayout, pOriginal)) {
        CHECK_PTR(pKbdTbl->pKeyNames, pLimit);
        for (pKeyName = pKbdTbl->pKeyNames; pKeyName->vsc != 0; pKeyName++) {
            FIXUP_PTR(pKeyName->pwsz, pKbdLayout, pOriginal);
            CHECK_PTR(pKeyName->pwsz, pLimit);
        }
    }
    if (FIXUP_PTR(pKbdTbl->pKeyNamesExt, pKbdLayout, pOriginal)) {
        CHECK_PTR(pKbdTbl->pKeyNamesExt, pLimit);
        for (pKeyName = pKbdTbl->pKeyNamesExt; pKeyName->vsc != 0; pKeyName++) {
            FIXUP_PTR(pKeyName->pwsz, pKbdLayout, pOriginal);
            CHECK_PTR(pKeyName->pwsz, pLimit);
        }
    }
    if (FIXUP_PTR(pKbdTbl->pKeyNamesDead, pKbdLayout, pOriginal)) {
        CHECK_PTR(pKbdTbl->pKeyNamesDead, pLimit);
        for (lpDeadKey = pKbdTbl->pKeyNamesDead; *lpDeadKey != NULL;
             lpDeadKey++) {
            FIXUP_PTR(*lpDeadKey, pKbdLayout, pOriginal);
            CHECK_PTR(*lpDeadKey, pLimit);
        }
    }
    FIXUP_PTR(pKbdTbl->pusVSCtoVK, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pusVSCtoVK, pLimit);
    FIXUP_PTR(pKbdTbl->pVSCtoVK_E0, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pVSCtoVK_E0, pLimit);
    FIXUP_PTR(pKbdTbl->pVSCtoVK_E1, pKbdLayout, pOriginal);
    CHECK_PTR(pKbdTbl->pVSCtoVK_E1, pLimit);

    *ppKbdTbl = pKbdTbl;

error:
    return( Status );
}



#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\keyboard.c ===
/****************************************************************************/
/* keyboard.c                                                               */
/*                                                                          */
/* Keyboard IOCtl handling                                                  */
/*                                                                          */
/* Copyright 1996, Citrix Systems Inc.                                      */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "keyboard"
#define pTRCWd pWd
#include <adcg.h>
#include <nwdwapi.h>
#include <nwdwint.h>
#include <acomapi.h>


/*******************************************************************************
 *
 *  KeyboardQueryAttributes
 *
 *  return the keyboard attributes
 *
 *  typedef struct _KEYBOARD_ID {
 *      UCHAR Type;
 *      UCHAR Subtype;
 *  } KEYBOARD_ID, *PKEYBOARD_ID;
 *
 *  typedef struct _KEYBOARD_ATTRIBUTES {
 *      KEYBOARD_ID KeyboardIdentifier;
 *      USHORT KeyboardMode;
 *      USHORT NumberOfFunctionKeys;
 *      USHORT NumberOfIndicators;
 *      USHORT NumberOfKeysTotal;
 *      ULONG  InputDataQueueLength;
 *      KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMinimum;
 *      KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMaximum;
 *  } KEYBOARD_ATTRIBUTES, *PKEYBOARD_ATTRIBUTES;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - KEYBOARD_ATTRIBUTES
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardQueryAttributes( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_ATTRIBUTES pAttrib;

    if ( pSdIoctl->OutputBufferLength < sizeof(KEYBOARD_ATTRIBUTES) )
        return( STATUS_BUFFER_TOO_SMALL );

    pAttrib = (PKEYBOARD_ATTRIBUTES)pSdIoctl->OutputBuffer;

    pAttrib->KeyboardIdentifier.Type    = 4;
    pAttrib->KeyboardIdentifier.Subtype = 0;
    pAttrib->KeyboardMode               = 1;
    pAttrib->NumberOfFunctionKeys       = 12;
    pAttrib->NumberOfIndicators         = 3;
    pAttrib->NumberOfKeysTotal          = 101;
    pAttrib->InputDataQueueLength       = 100;

    pAttrib->KeyRepeatMinimum.UnitId    = 0;
    pAttrib->KeyRepeatMinimum.Rate      = 2;
    pAttrib->KeyRepeatMinimum.Delay     = 250;

    pAttrib->KeyRepeatMaximum.UnitId    = 0;
    pAttrib->KeyRepeatMaximum.Rate      = 30;
    pAttrib->KeyRepeatMaximum.Delay     = 1000;

    pSdIoctl->BytesReturned = sizeof(KEYBOARD_ATTRIBUTES);

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  KeyboardQueryTypematic
 *
 *  return the keyboard typematic rate
 *
 *  typedef struct _KEYBOARD_TYPEMATIC_PARAMETERS {
 *      USHORT UnitId;
 *      USHORT  Rate;
 *      USHORT  Delay;
 *  } KEYBOARD_TYPEMATIC_PARAMETERS, *PKEYBOARD_TYPEMATIC_PARAMETERS;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - KEYBOARD_TYPEMATIC_PARAMETERS
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardQueryTypematic( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_TYPEMATIC_PARAMETERS pTypematic;

    if ( pSdIoctl->OutputBufferLength < sizeof(KEYBOARD_TYPEMATIC_PARAMETERS) )
        return( STATUS_BUFFER_TOO_SMALL );

    pTypematic = (PKEYBOARD_TYPEMATIC_PARAMETERS)pSdIoctl->OutputBuffer;

    *pTypematic = pWd->KeyboardTypematic;
    pSdIoctl->BytesReturned = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  KeyboardSetTypematic
 *
 *  set the keyboard typematic rate
 *
 *  typedef struct _KEYBOARD_TYPEMATIC_PARAMETERS {
 *      USHORT UnitId;
 *      USHORT  Rate;
 *      USHORT  Delay;
 *  } KEYBOARD_TYPEMATIC_PARAMETERS, *PKEYBOARD_TYPEMATIC_PARAMETERS;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - KEYBOARD_TYPEMATIC_PARAMETERS
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetTypematic( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_TYPEMATIC_PARAMETERS pTypematic;

    if ( pSdIoctl->InputBufferLength < sizeof(KEYBOARD_TYPEMATIC_PARAMETERS) )
        return( STATUS_BUFFER_TOO_SMALL );

    pTypematic = (PKEYBOARD_TYPEMATIC_PARAMETERS)pSdIoctl->InputBuffer;

    pWd->KeyboardTypematic = *pTypematic;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  KeyboardQueryIndicators
 *
 *  return the state of the keyboard indicators
 *
 *  typedef struct _KEYBOARD_INDICATOR_PARAMETERS {
 *      USHORT UnitId;
 *      USHORT LedFlags;
 *  } KEYBOARD_INDICATOR_PARAMETERS, *PKEYBOARD_INDICATOR_PARAMETERS;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - KEYBOARD_INDICATOR_PARAMETERS
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardQueryIndicators( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_INDICATOR_PARAMETERS pIndicator;

    if ( pSdIoctl->OutputBufferLength < sizeof(KEYBOARD_INDICATOR_PARAMETERS) )
        return( STATUS_BUFFER_TOO_SMALL );

    pIndicator = (PKEYBOARD_INDICATOR_PARAMETERS)pSdIoctl->OutputBuffer;

    *pIndicator = pWd->KeyboardIndicators;
    pSdIoctl->BytesReturned = sizeof(KEYBOARD_INDICATOR_PARAMETERS);

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  KeyboardSetIndicators
 *
 *  set the keyboard indicators
 *
 *  typedef struct _KEYBOARD_INDICATOR_PARAMETERS {
 *      USHORT UnitId;
 *      USHORT LedFlags;
 *  } KEYBOARD_INDICATOR_PARAMETERS, *PKEYBOARD_INDICATOR_PARAMETERS;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - KEYBOARD_INDICATOR_PARAMETERS
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetIndicators( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_INDICATOR_PARAMETERS pIndicator;
    NTSTATUS Status = STATUS_SUCCESS;

    if (pSdIoctl->InputBufferLength < sizeof(KEYBOARD_INDICATOR_PARAMETERS))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        pIndicator = (PKEYBOARD_INDICATOR_PARAMETERS)pSdIoctl->InputBuffer;

        if (pWd->KeyboardIndicators.LedFlags != (pIndicator->LedFlags & 0x7))
        {
            pWd->KeyboardIndicators.UnitId = pIndicator->UnitId;
            pWd->KeyboardIndicators.LedFlags = (pIndicator->LedFlags & 0x7);

            if ((pWd->StackClass == Stack_Shadow) ||
                (pIndicator->LedFlags & KEYBOARD_LED_INJECTED)) {
                WDWKeyboardSetIndicators(pWd);
            }
        }
    }

    return( Status );
}


/*******************************************************************************
 *
 *  KeyboardQueryIndicatorTranslation
 *
 *  return the state of the keyboard indicators
 *
 *  typedef struct _INDICATOR_LIST {
 *      USHORT MakeCode;
 *      USHORT IndicatorFlags;
 *  } INDICATOR_LIST, *PINDICATOR_LIST;
 *
 *  typedef struct _KEYBOARD_INDICATOR_TRANSLATION {
 *      USHORT NumberOfIndicatorKeys;
 *      INDICATOR_LIST IndicatorList[1];
 *  } KEYBOARD_INDICATOR_TRANSLATION, *PKEYBOARD_INDICATOR_TRANSLATION;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - ICA_STACK_CONFIG
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardQueryIndicatorTranslation( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    pSdIoctl->BytesReturned = 0;
    return( STATUS_INVALID_DEVICE_REQUEST );
}


/*******************************************************************************
 *
 *  KeyboardSetLayout
 *
 *  set the keyboard layouts for shadow hotkey processing
 *
 * ENTRY:
 *    pWd (input)
 *       pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - keyboard layout table
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetLayout( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )  
{
    NTSTATUS Status;
    PVOID pKbdLayout;
    PVOID pKbdTbl;

    if ( pSdIoctl->InputBufferLength < 1 )  {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto error;
    }

    /*
     * The keyboard layout is in winstation space so copy it to a new buffer and
     * adjust the pointers.  The pointers where all relative to a base address before
     * so just duplicate the fixup code from Win32K.
     */
    pKbdLayout = COM_Malloc(pSdIoctl->InputBufferLength);
    if (pKbdLayout == NULL) {
        Status = STATUS_NO_MEMORY;
        goto error;
    }

    RtlCopyMemory( pKbdLayout, pSdIoctl->InputBuffer, pSdIoctl->InputBufferLength );

    Status = KeyboardFixupLayout( pKbdLayout, pSdIoctl->InputBuffer,
                                  pSdIoctl->InputBufferLength,
                                  pSdIoctl->OutputBuffer,
                                  &pKbdTbl );

    if ( !NT_SUCCESS( Status ) ) {
        COM_Free( pKbdLayout );
        pKbdLayout = NULL;
        goto error;
    }

    if ( pWd->pKbdLayout )
        COM_Free( pWd->pKbdLayout );
    pWd->pKbdLayout = pKbdLayout;
    pWd->pKbdTbl = pKbdTbl;

error:
    TRACE(( pWd->pContext, TC_WD, TT_ERROR, "KeyboardSetLayout %X\n", Status ));

    return( Status );
}


/*******************************************************************************
 *
 *  KeyboardSetScanMap
 *
 *  set the keyboard scan map for shadow hotkey processing
 *
 * ENTRY:
 *    pWd (input)
 *       pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - keyboard scan map table
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetScanMap( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )  
{
    NTSTATUS Status;
    PVOID pScanMap;

    DC_BEGIN_FN("KeyboardSetScanMap");

    if (pSdIoctl->InputBufferLength >= 1) {
        // The keyboard scan code map is in winstation space so copy it to
        // a new buffer.
        pScanMap = COM_Malloc( pSdIoctl->InputBufferLength );
        if (pScanMap != NULL ) {
            RtlCopyMemory(pScanMap, pSdIoctl->InputBuffer,
                    pSdIoctl->InputBufferLength);

            // Scancode maps are allocated once.
            TRC_ASSERT((pWd->gpScancodeMap == NULL),
                    (TB,"Previous scancode map present"));
            pWd->gpScancodeMap = pScanMap;
            Status = STATUS_SUCCESS;
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }
    else {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    TRACE(( pWd->pContext, TC_WD, TT_ERROR, "KeyboardSetScanMap %X\n", Status ));

    DC_END_FN();
    return Status;
}


/*******************************************************************************
 *
 *  KeyboardSetType
 *
 *  set the keyboard scan map for shadow hotkey processing
 *
 * ENTRY:
 *    pWd (input)
 *       pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - keyboard type
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetType( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )  
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( pSdIoctl->InputBufferLength < sizeof(BOOLEAN) )  {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto error;
    }

    pWd->KeyboardType101 = *(PBOOLEAN)(pSdIoctl->InputBuffer);

error:
    TRACE(( pWd->pContext, TC_WD, TT_ERROR, "KeyboardSetType %X\n", Status ));

    return( Status );
}


/*******************************************************************************
 *
 *  KeyboardSetImeStatus
 *
 *  set ime status to the keyboard
 *
 *  typedef struct _KEYBOARD_IME_STATUS {
 *      USHORT UnitId;
 *      ULONG  ImeOpen;
 *      ULONG  ImeConvMode;
 *  } KEYBOARD_IME_STATUS, *PKEYBOARD_IME_STATUS;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - KEYBOARD_IME_STATUS
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
KeyboardSetImeStatus( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PKEYBOARD_IME_STATUS pImeStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    if (pSdIoctl->InputBufferLength < sizeof(KEYBOARD_IME_STATUS))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        pImeStatus = (PKEYBOARD_IME_STATUS)pSdIoctl->InputBuffer;

        pWd->KeyboardImeStatus = *pImeStatus;

        WDWKeyboardSetImeStatus(pWd);
    }

    return( Status );
}



#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\mouse.c ===
/****************************************************************************/
// mouse.c
//
// Mouse IOCTL handlers.
//
// Copyright (C) 1996 Citrix Systems Inc.
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <precomp.h>
#pragma hdrstop

#include <adcg.h>
#include <nwdwapi.h>
#include <nwdwint.h>


/*============================================================================
==   External procedures defined
============================================================================*/
NTSTATUS MouseQueryAttributes( PTSHARE_WD, PSD_IOCTL  );


/*****************************************************************************
 *
 *  MouseQueryAttributes
 *
 *  return the mouse attributes
 *
 *  typedef struct _MOUSE_ATTRIBUTES {
 *      USHORT MouseIdentifier;
 *      USHORT NumberOfButtons;
 *      USHORT SampleRate;
 *      ULONG  InputDataQueueLength;
 *  } MOUSE_ATTRIBUTES, *PMOUSE_ATTRIBUTES;
 *
 *
 * ENTRY:
 *    pWd (input)
 *       Pointer to wd data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - MOUSE_ATTRIBUTES
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
MouseQueryAttributes( PTSHARE_WD pWd, PSD_IOCTL pSdIoctl )
{
    PMOUSE_ATTRIBUTES pAttrib;

    if ( pSdIoctl->OutputBufferLength < sizeof(MOUSE_ATTRIBUTES) )
        return( STATUS_BUFFER_TOO_SMALL );

    pAttrib = (PMOUSE_ATTRIBUTES)pSdIoctl->OutputBuffer;

    pAttrib->MouseIdentifier      = MOUSE_SERIAL_HARDWARE;
    pAttrib->NumberOfButtons      = 3;
    pAttrib->SampleRate           = 40;
    pAttrib->InputDataQueueLength = 100;

    pSdIoctl->BytesReturned = sizeof(MOUSE_ATTRIBUTES);

    return( STATUS_SUCCESS );
}



#ifdef __cplusplus
}
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ausrdata.c ===
/****************************************************************************/
/* ausrdata.c                                                               */
/*                                                                          */
/* RDP Update sender/receiver global data                                   */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <ndcgdata.h>


/****************************************************************************/
/* Indicates whether we have sent our remote font packet.                   */
/****************************************************************************/
DC_DATA(BOOLEAN, usrRemoteFontInfoSent,     FALSE);
DC_DATA(BOOLEAN, usrRemoteFontInfoReceived, FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nschapi.cpp ===
/****************************************************************************/
/* nschapi.cpp                                                              */
/*                                                                          */
/* Scheduling component API                                                 */
/*                                                                          */
/* Copyright(c) Microsoft Corporation 1996-1999                             */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "nschapi"
#include <as_conf.hpp>

#include <nprcount.h>


/****************************************************************************/
/* Name:      SCH_Init                                                      */
/*                                                                          */
/* Purpose:   Scheduler initialization function.                            */
/****************************************************************************/
void RDPCALL SHCLASS SCH_Init(void)
{
    DC_BEGIN_FN("SCH_Init");

#define DC_INIT_DATA
#include <nschdata.c>
#undef DC_INIT_DATA

    // ASLEEP mode gets no timer.
    schPeriods[SCH_MODE_ASLEEP] = SCH_NO_TIMER;

    // Get scheduling periods that were saved in WD_Open.
    schPeriods[SCH_MODE_NORMAL] = m_pTSWd->outBufDelay;

    // If compression is enabled (ie it's a slow link) then crank up the
    // turbo period to improve responsiveness.
    if (m_pTSWd->bCompress) {
        TRC_ALT((TB, "Slow link"));
        schPeriods[SCH_MODE_TURBO] = SCH_TURBO_PERIOD_SLOW_LINK_DELAY;
        schTurboModeDuration = SCH_TURBO_MODE_SLOW_LINK_DURATION;

        m_pShm->sch.MPPCCompressionEst = SCH_MPPC_INIT_EST;
    }
    else {
        TRC_ALT((TB, "Fast link"));
        schPeriods[SCH_MODE_TURBO] = m_pTSWd->interactiveDelay;
        schTurboModeDuration = SCH_TURBO_MODE_FAST_LINK_DURATION;

        // To avoid branching, we set the compression ratio for non-compressed
        // to the same size as the divisor to create a 1:1 calculation.
        m_pShm->sch.MPPCCompressionEst = SCH_UNCOMP_BYTES;
    }

    TRC_ALT((TB, "Normal period=%u ms, turbo period=%u ms, turbo duration=%u ms",
             schPeriods[SCH_MODE_NORMAL], schPeriods[SCH_MODE_TURBO],
             schTurboModeDuration / 10000));

    DC_END_FN();
}


/****************************************************************************/
// Updates the SHM
/****************************************************************************/
void RDPCALL SHCLASS SCH_UpdateShm(void)
{
    DC_BEGIN_FN("SCH_UpdateShm");

    m_pShm->sch.schSlowLink = m_pTSWd->bCompress;

    // Set up packing sizes based on link speed.
    if (m_pTSWd->bCompress) {
        m_pShm->sch.SmallPackingSize = SMALL_SLOWLINK_PAYLOAD_SIZE;
        m_pShm->sch.LargePackingSize = LARGE_SLOWLINK_PAYLOAD_SIZE;
    }
    else {
        m_pShm->sch.SmallPackingSize = SMALL_LAN_PAYLOAD_SIZE;
        m_pShm->sch.LargePackingSize = LARGE_LAN_PAYLOAD_SIZE;
    }

    SET_INCOUNTER(IN_SCH_SMALL_PAYLOAD, m_pShm->sch.SmallPackingSize);
    SET_INCOUNTER(IN_SCH_LARGE_PAYLOAD, m_pShm->sch.LargePackingSize);

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SCH_ContinueScheduling                                        */
/*                                                                          */
/* Purpose:   Called by components when they want periodic scheduling to    */
/*            continue.  They are guaranteed to get at least one more       */
/*            periodic callback following a call to this function.          */
/*            If they want further callbacks then they must call this       */
/*            function again during their periodic processing.              */
/*                                                                          */
/* Params:    schedulingMode - either SCH_MODE_NORMAL or SCH_MODE_TURBO     */
/*                                                                          */
/* Operation: -                                                             */
/*            SCH_MODE_NORMAL triggers periodic processing at 200ms         */
/*            intervals (5 times a second)                                  */
/*                                                                          */
/*            SCH_MODE_TURBO triggers periodic processing at 100ms          */
/*            intervals (10 times a second)                                 */
/*                                                                          */
/*            The scheduler automatically drops from SCH_MODE_TURBO back    */
/*            to SCH_MODE_NORMAL after 1 second of turbo mode processing.   */
/*                                                                          */
/*            SCH_MODE_TURBO overrides SCH_MODE_NORMAL, so if calls to      */
/*            this function are made with SCH_MODE_NORMAL when the          */
/*            scheduler is in TURBO mode, TURBO mode continues.             */
/*                                                                          */
/*            If this function is not called during one pass through        */
/*            DCS_TimeToDoStuff then the scheduler enters                   */
/*            SLEEP mode - and will not generate any more periodic          */
/*            callbacks until it is woken by another call to                */
/*            this function, or until the output accumulation code          */
/*            IOCtls into the WD again.                                     */
/****************************************************************************/
void RDPCALL SHCLASS SCH_ContinueScheduling(unsigned schedulingMode)
{
    BOOL restart = FALSE;

    DC_BEGIN_FN("SCH_ContinueScheduling");

    TRC_ASSERT( ((schedulingMode == SCH_MODE_NORMAL) ||
                 (schedulingMode == SCH_MODE_TURBO)),
                 (TB, "Invalid scheduling state: %u", schedulingMode) );

    if (schedulingMode == SCH_MODE_TURBO)
    {
        // TURBO mode is often turned off because of packets that need to
        // be sent out IMMEDIATELY.  This makes it very difficult to actually
        // ask the question, "has input come accross in the last n milliseconds.
        // This is what we use schInputKickMode for!
        schInputKickMode = TRUE;
    }

    TRC_DBG((TB, "Continue scheduling (%s) -> (%s), InTTDS(%d)",
            schCurrentMode == SCH_MODE_TURBO ? "Turbo" :
            schCurrentMode == SCH_MODE_NORMAL ? "Normal" : "Asleep",
            schedulingMode == SCH_MODE_TURBO ? "Turbo" :
            schedulingMode == SCH_MODE_NORMAL ? "Normal" : "Asleep",
            schInTTDS));

    if (schCurrentMode == SCH_MODE_TURBO) {
        // If we're in TURBO mode, then the only interesting event is a
        // requirement to stay there longer than currently planned.
        if (schedulingMode == SCH_MODE_TURBO) {
            COM_GETTICKCOUNT(schLastTurboModeSwitch);
            TRC_DBG((TB, "New Turbo switch time %lu",
                    schLastTurboModeSwitch));
        }
    }
    else {
        if (schedulingMode == SCH_MODE_TURBO) {
            COM_GETTICKCOUNT(schLastTurboModeSwitch);
            restart = TRUE;
            TRC_DBG((TB, "New Turbo switch time %lu",
                    schLastTurboModeSwitch));
        }

        /********************************************************************/
        /* We're waking up.  If we're not in the middle of a TTDS pass,     */
        /* then start the new timer straight away.                          */
        /********************************************************************/
        if (!schInTTDS && ((schCurrentMode == SCH_MODE_ASLEEP) || restart)) {
            TRC_DBG((TB, "Starting a timer for %lu ms",
                    schPeriods[schedulingMode]));
            WDW_StartRITTimer(m_pTSWd, schPeriods[schedulingMode]);
        }

        schCurrentMode = schedulingMode;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ausrapi.cpp ===
/****************************************************************************/
/* ausrapi.cpp                                                              */
/*                                                                          */
/* RDP Update sender/receiver API functions                                 */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "ausrapi"
#include <as_conf.hpp>

/****************************************************************************/
/* API FUNCTION: USR_Init                                                   */
/*                                                                          */
/* Initializes the USR.                                                     */
/****************************************************************************/
void RDPCALL SHCLASS USR_Init(void)
{
    TS_BITMAP_CAPABILITYSET BitmapCaps;
    TS_FONT_CAPABILITYSET FontCaps;

    DC_BEGIN_FN("USR_Init");

    /************************************************************************/
    /* This initialises all the global data for this component              */
    /************************************************************************/
#define DC_INIT_DATA
#include <ausrdata.c>
#undef DC_INIT_DATA

    /************************************************************************/
    /* Setup the local font capabilities                                    */
    /************************************************************************/
    FontCaps.capabilitySetType = TS_CAPSETTYPE_FONT;
    FontCaps.lengthCapability  = sizeof(FontCaps);
    FontCaps.fontSupportFlags  = TS_FONTSUPPORT_FONTLIST;
    FontCaps.pad2octets        = 0;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&FontCaps,
            sizeof(TS_FONTSUPPORT_FONTLIST));

    /************************************************************************/
    /* Initialize the local bitmap capabilities structure.                  */
    /************************************************************************/
    BitmapCaps.capabilitySetType = TS_CAPSETTYPE_BITMAP;
    BitmapCaps.preferredBitsPerPixel = (TSUINT16)m_desktopBpp;
    BitmapCaps.receive1BitPerPixel  = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.receive4BitsPerPixel = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.receive8BitsPerPixel = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.desktopWidth         = (TSUINT16)m_desktopWidth;
    BitmapCaps.desktopHeight        = (TSUINT16)m_desktopHeight;
    BitmapCaps.pad2octets = 0;
    BitmapCaps.desktopResizeFlag    = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.bitmapCompressionFlag = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.highColorFlags = 0;
    BitmapCaps.pad1octet = 0;
    BitmapCaps.multipleRectangleSupport = TS_CAPSFLAG_SUPPORTED;
    BitmapCaps.pad2octetsB = 0;
    CPC_RegisterCapabilities((PTS_CAPABILITYHEADER)&BitmapCaps,
            sizeof(TS_BITMAP_CAPABILITYSET));

    /************************************************************************/
    /* Initialize the sub components.                                       */
    /************************************************************************/
    UP_Init();
    OE_Init();
    SDG_Init();
    OA_Init();
    BA_Init();

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: USR_Term                                                   */
/*                                                                          */
/* Terminate the USR.                                                       */
/****************************************************************************/
void RDPCALL SHCLASS USR_Term(void)
{
    DC_BEGIN_FN("USR_Term");

    TRC_NRM((TB, "Notify share exit ? %s", m_pShm ? "Y" : "N"));

    // Set the "font info sent" flag so we don't try to send it again.
    usrRemoteFontInfoSent = TRUE;
    usrRemoteFontInfoReceived = FALSE;

    // Terminate the sub components.
    UP_Term();
    OE_Term();
    OA_Term();
    SDG_Term();
    BA_Term();

    DC_END_FN();
}


/****************************************************************************/
// USR_ProcessRemoteFonts
//
// Returns a FontMapPDU to the client and releases the DD IOCTL waiting for
// client connection sequence completion.
/****************************************************************************/
void RDPCALL SHCLASS USR_ProcessRemoteFonts(
        PTS_FONT_LIST_PDU pFontListPDU,
        unsigned DataLength,
        LOCALPERSONID localID)
{
    unsigned listFlags;

    DC_BEGIN_FN("USR_ProcessRemoteFonts");

    if (DataLength >= (sizeof(TS_FONT_LIST_PDU) - sizeof(TS_FONT_ATTRIBUTE))) {
        listFlags = pFontListPDU->listFlags;

        // If this is the last entry we will be receiving, return an empty font
        // map PDU (since we no longer support text orders, only the glyph cache).
        // Then release the client-connection lock to allow us to return to
        // the DD from the DD connection IOCTL.
        if (listFlags & TS_FONTLIST_LAST) {
            PTS_FONT_MAP_PDU pFontMapPDU;
            unsigned         pktSize;

            usrRemoteFontInfoReceived = TRUE;

            // Send font map to client.
            if (!usrRemoteFontInfoSent) {
                // Calculate the total packet size.
                // Allow for the fact that sizeof(TS_FONT_PDU) already
                // includes one TS_FONT_ATTRIBUTE structure.
                pktSize = sizeof(TS_FONT_MAP_PDU) - sizeof(TS_FONTTABLE_ENTRY);

                // Allocate a Network Packet of the correct size.
                if ( STATUS_SUCCESS == SC_AllocBuffer((PPVOID)&pFontMapPDU, pktSize) ) {
                    // Fill in the data and send it.
                    pFontMapPDU->shareDataHeader.shareControlHeader.pduType =
                            TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
                    TS_DATAPKT_LEN(pFontMapPDU) = (UINT16)pktSize;
                    pFontMapPDU->shareDataHeader.pduType2 =
                            TS_PDUTYPE2_FONTMAP;

                    pFontMapPDU->data.mapFlags = 0;
                    pFontMapPDU->data.totalNumEntries = 0;
                    pFontMapPDU->data.entrySize =
                            ((UINT16)sizeof(TS_FONTTABLE_ENTRY));
                    pFontMapPDU->data.mapFlags |= TS_FONTMAP_FIRST;
                    pFontMapPDU->data.mapFlags |= TS_FONTMAP_LAST;

                    // Set the number of font mappings we actually put in the
                    // packet.
                    pFontMapPDU->data.numberEntries = 0;

                    SC_SendData((PTS_SHAREDATAHEADER)pFontMapPDU, pktSize,
                            pktSize, PROT_PRIO_MISC, 0);

                    TRC_NRM((TB, "Sent font map packet with %hu fonts mappings",
                                pFontMapPDU->data.numberEntries));

                    // Set the flag that indicates that we have successfully
                    // sent the font info.
                    usrRemoteFontInfoSent = TRUE;

                    // Kick WDW back into life.
                    TRC_NRM((TB, "Wake up WDW"));
                    WDW_ShareCreated(m_pTSWd, TRUE);
                }
                else {
                    // Failed to allocate a packet.
                    TRC_ALT((TB, "Failed to alloc font map packet"));
                }
            }
        }
    }
    else {
        TRC_ERR((TB,"Received FONT_LIST_PDU bad size %u", DataLength));
        WDW_LogAndDisconnect(m_pTSWd, TRUE, Log_RDP_ShareDataTooShort,
                (BYTE *)pFontListPDU, DataLength);
    }

    DC_END_FN();
}


/****************************************************************************/
/* API FUNCTION: USR_PartyJoiningShare                                      */
/*                                                                          */
/* Called when a party is added to the share.                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - the local ID of the host.                                  */
/* oldShareSize - the number of people in the share, excluding this one.    */
/*                                                                          */
/* RETURNS:                                                                 */
/* TRUE if the new person is acceptable, FALSE if not.                      */
/****************************************************************************/
BOOL RDPCALL SHCLASS USR_PartyJoiningShare(
        LOCALPERSONID locPersonID,
        unsigned      oldShareSize)
{
    BOOL rc;

    DC_BEGIN_FN("USR_PartyJoiningShare");
    DC_IGNORE_PARAMETER(locPersonID)

    if (oldShareSize == 0) {
        // Reset the "font info sent" flags.
        usrRemoteFontInfoSent = FALSE;
        usrRemoteFontInfoReceived = FALSE;

        // Continue periodic scheduling.
        SCH_ContinueScheduling(SCH_MODE_NORMAL);

        rc = TRUE;
    }
    else {
        /********************************************************************/
        /* There is more than one person in the share now, so check out the */
        /* combined capabilities.                                           */
        /********************************************************************/
        rc = USRDetermineCaps();
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* API FUNCTION: USR_PartyLeftShare                                         */
/*                                                                          */
/* Called when a party is leaves the share.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - the local network ID of the host.                          */
/* newShareSize - the number of people in the share, excluding this one.    */
/****************************************************************************/
void RDPCALL SHCLASS USR_PartyLeftShare(
        LOCALPERSONID locPersonID,
        unsigned      newShareSize)
{
    DC_BEGIN_FN("USR_PartyLeftShare");

    DC_IGNORE_PARAMETER(locPersonID)
    if (newShareSize == 0)
    {
        // Set the "font info sent" flag so we don't try to send it again.
        usrRemoteFontInfoSent = TRUE;
        usrRemoteFontInfoReceived = FALSE;
    }
    else if (newShareSize > 1)
    {
        /********************************************************************/
        /* There is still more than one person in the share now, so         */
        /* redetermine the capabilities for the remaining parties.          */
        /* USRDetermineCaps returns FALSE if it cannot determine common     */
        /* caps, but this can never happen when someone is leaving the      */
        /* share.                                                           */
        /********************************************************************/
        USRDetermineCaps();
    }

    DC_END_FN();
}


/****************************************************************************/
/* FUNCTION: USRDetermineCaps                                               */
/*                                                                          */
/* Enumerates the bitmap capabilities of all parties currently in the       */
/* share, and determines the common capabilities.                           */
/*                                                                          */
/* RETURNS: TRUE if there are good common caps, or false on failure (which  */
/* has the effect of rejecting a new party from joining the share).         */
/****************************************************************************/
BOOL RDPCALL SHCLASS USRDetermineCaps(void)
{
    BOOL CapsOK;

    DC_BEGIN_FN("USRDetermineCaps");

    CapsOK = TRUE;
    CPC_EnumerateCapabilities(TS_CAPSETTYPE_BITMAP, (UINT_PTR)&CapsOK,
            USREnumBitmapCaps);

    DC_END_FN();
    return CapsOK;
}


/****************************************************************************/
/* FUNCTION: USREnumBitmapCaps                                              */
/*                                                                          */
/* Function passed to CPC_EnumerateCapabilities.  It is called once for     */
/* each person in the share corresponding to the TS_CAPSETTYPE_BITMAP       */
/* capability structure.                                                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* personID - ID of person with these capabilities.                         */
/*                                                                          */
/* pCaps - pointer to capabilities structure for this person.  This         */
/* pointer is only valid within the call to this function.                  */
/****************************************************************************/
void CALLBACK SHCLASS USREnumBitmapCaps(
        LOCALPERSONID personID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCaps)
{
    BOOL *pCapsOK = (BOOL *)UserData;
    PTS_BITMAP_CAPABILITYSET pBitmapCaps = (PTS_BITMAP_CAPABILITYSET)pCaps;

    DC_BEGIN_FN("USREnumBitmapCaps");

    if (pBitmapCaps->lengthCapability >= sizeof(TS_BITMAP_CAPABILITYSET)) {
        if (!pBitmapCaps->bitmapCompressionFlag) {
            TRC_ERR((TB,"PersonID %u: BitmapPDU compression flag not set",
                    personID));
            *pCapsOK = FALSE;
        }

        // Check for multiple-rectangle-per-PDU support. All clients (4.0
        // release and above) should have this capability set.
        if (!pBitmapCaps->multipleRectangleSupport) {
            TRC_ERR((TB,"PersonID %u: BitmapPDU mult rect flag not set",
                    personID));
            *pCapsOK = FALSE;
        }
    }
    else {
        TRC_ERR((TB,"PersonID %u: BitmapPDU caps too short", personID));
        *pCapsOK = FALSE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\aupint.cpp ===
/****************************************************************************/
// aupint.cpp
//
// RDP Update Packager internal functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "aupint"
#include <as_conf.hpp>
#include <nprcount.h>


/****************************************************************************/
// UPSendOrders
//
// Packages orders to send to the client. Returns TRUE if all orders for
// this call (all available orders for non-shadow, one buffer for shadow)
// were sent.
//
// Packing algorithm details:
//
// Each network buffer (allocated in SC) is size sc8KOutBufUsableSpace
// (8K minus some header space). Within that space we try to pack to
// multiples of the 1460-byte TCP payload. For slow link connections we aim
// for 1460 * 1 (SMALL_SLOWLINK_PAYLOAD_SIZE) as the final size to send,
// for LAN, 1460 * 3 (LARGE_SLOWLINK_PAYLOAD_SIZE).
//
// Order packing takes into account the current MPPC compression estimate
// for slow links. We divide the target size by the compression ratio to get
// the predicted size of data that, when compressed, will fit into the 
// target size. This size is throttled by the sc8KOutBufUsableSpace
// size so we don't overrun the network buffer.
/****************************************************************************/
NTSTATUS RDPCALL SHCLASS UPSendOrders(PPDU_PACKAGE_INFO pPkgInfo)
{
    BYTE *pOrderBuffer;
    unsigned NumOrders;
    unsigned cbOrderBytes;
    unsigned cbOrderBytesRemaining;
    unsigned cbPacketSize;
    int RealSpaceAvail, ScaledSpaceAvail;
    unsigned SmallPackingSize = m_pShm->sch.SmallPackingSize;
    unsigned LargePackingSize = m_pShm->sch.LargePackingSize;
    unsigned MPPCCompEst = m_pShm->sch.MPPCCompressionEst;
    unsigned ScaledSmallPackingSize;
    unsigned ScaledLargePackingSize;
    unsigned CurrentScaledLargePackingSize;
    unsigned BufLen;
    BOOL bSmallPackingSizeTarget;
#ifdef DC_HICOLOR
    BOOL bTriedVeryLargeBuffer = FALSE;
#endif
    NTSTATUS status = STATUS_SUCCESS;


    DC_BEGIN_FN("UPSendOrders");

    // Find out how many bytes of orders there are in the Order List.
    cbOrderBytesRemaining = OA_GetTotalOrderListBytes();

    // Process any orders on the list.
    if (cbOrderBytesRemaining > 0) {
        TRC_DBG((TB, "%u order bytes to fetch", cbOrderBytesRemaining));

        BufLen = pPkgInfo->cbLen;

        // Handling for the first buffer is different from any later ones.
        // We want at least a few bytes beyond the update-orders PDU
        // header for some orders. If we are at the end of a packing buffer
        // for the first packing size, use the second packing size. If
        // we are at the end of the second packing size, we need to flush.
        if (pPkgInfo->cbInUse < SmallPackingSize) {
            // Check that we actually have a buffer allocated.
            if (BufLen) {
                RealSpaceAvail = SmallPackingSize - pPkgInfo->cbInUse;
                if (RealSpaceAvail >=
                        (int)(upUpdateHdrSize + SCH_MIN_ORDER_BUFFER_SPACE)) {
                    bSmallPackingSizeTarget = TRUE;
                }
                else {
                    bSmallPackingSizeTarget = FALSE;
                    RealSpaceAvail = LargePackingSize - pPkgInfo->cbInUse;
                }
                pOrderBuffer = (BYTE *)pPkgInfo->pBuffer +
                        pPkgInfo->cbInUse + upUpdateHdrSize;
            }
            else {
                goto ForceFlush;
            }
        }
        else {
            // Note RealSpaceAvail is an int to easily handle where cbInUse >
            // LargePackingSize.
            RealSpaceAvail = (int)LargePackingSize - (int)pPkgInfo->cbInUse;
            if (RealSpaceAvail >=
                    (int)(upUpdateHdrSize + SCH_MIN_ORDER_BUFFER_SPACE)) {
                bSmallPackingSizeTarget = FALSE;
                pOrderBuffer = (BYTE *)pPkgInfo->pBuffer +
                        pPkgInfo->cbInUse + upUpdateHdrSize;
            }
            else {
ForceFlush:
                status = SC_FlushAndAllocPackage(pPkgInfo);

                if ( STATUS_SUCCESS == status ) {
                    // If we are not shadowing (or are shadowing but had
                    // a null buffer in the package), then we can continue.
                    // Otherwise, we've sent our one buffer allowed this
                    // round.
                    if (m_pTSWd->shadowState == SHADOW_NONE || BufLen == 0) {
                        TRC_ASSERT((pPkgInfo->cbLen >= LargePackingSize),
                                (TB,"Assumed default package alloc size too "
                                "small"));
                        RealSpaceAvail = (int)SmallPackingSize;
                        bSmallPackingSizeTarget = TRUE;
                        pOrderBuffer = (BYTE *)pPkgInfo->pBuffer +
                                upUpdateHdrSize;
                    }
                    else {
                        DC_QUIT;
                    }
                }
                else {
                    // Failed to allocate a packet. We skip out immediately
                    // and try again later.
                    TRC_NRM((TB, "Failed to alloc order packet"));
                    INC_INCOUNTER(IN_SND_NO_BUFFER);
                    DC_QUIT;
                }
            }
        }

        // Calculate the scaled packing sizes, which are the sizes of buffer
        // available after the update order PDU header.
        if (m_pTSWd->bCompress) {
            // Whatever size we're packing for, we need to divide by the MPPC
            // compression estimate to get the size we really want to pack
            // so that, after compression, we achieve the size we would like
            // to get. Note we add in a 7/8 fudge factor to increase the
            // chance we will pack within the target buffer and closer to
            // a full packet size. Also tried 3/4, 4/5, and 15/16 as factors
            // but they yielded more frames. The scaled size is throttled at
            // the full size of the buffer.
            ScaledSpaceAvail = (int)(((unsigned)RealSpaceAvail -
                    upUpdateHdrSize) * SCH_UNCOMP_BYTES / MPPCCompEst *
                    7 / 8);
            ScaledSpaceAvail = min(ScaledSpaceAvail, (int)(pPkgInfo->cbLen -
                    pPkgInfo->cbInUse - upUpdateHdrSize));

            // Calculate the large packing size target for the first buffer,
            // based on the space currently available. This value will be
            // used below for if we need to retry the order copy after
            // failure to transfer any orders to a small buffer size.
            // It is throttled at the buffer maximum size.
            TRC_ASSERT(((int)pPkgInfo->cbInUse < LargePackingSize),
                    (TB,"At least LargePackingSize in use and we've not "
                    "flushed - cbInUse=%u, LargePackingSize=%u",
                    pPkgInfo->cbInUse, LargePackingSize));
            TRC_ASSERT((MPPCCompEst <= SCH_UNCOMP_BYTES),
                    (TB,"MPPC compression ratio > 1.0!"));
            CurrentScaledLargePackingSize = (LargePackingSize -
                    pPkgInfo->cbInUse - upUpdateHdrSize) * SCH_UNCOMP_BYTES /
                    MPPCCompEst * 7 / 8;
            CurrentScaledLargePackingSize = min(CurrentScaledLargePackingSize,
                    (pPkgInfo->cbLen - pPkgInfo->cbInUse - upUpdateHdrSize));

            // Precalculate the large and small sizes for the second and later
            // buffers (where pPkgInfo->cbInUse is reset to 0).
            // Throttle the small size to reduce slow-link burstiness.
            ScaledSmallPackingSize = (SmallPackingSize - upUpdateHdrSize) *
                    SCH_UNCOMP_BYTES / MPPCCompEst * 7 / 8;
            ScaledSmallPackingSize = min(ScaledSmallPackingSize,
                    (sc8KOutBufUsableSpace - upUpdateHdrSize));
            ScaledSmallPackingSize = (unsigned int)min(ScaledSmallPackingSize,
                    (2 * SMALL_SLOWLINK_PAYLOAD_SIZE));
            ScaledLargePackingSize = (LargePackingSize - upUpdateHdrSize) *
                    SCH_UNCOMP_BYTES / MPPCCompEst * 7 / 8;
            ScaledLargePackingSize = min(ScaledLargePackingSize,
                    (sc8KOutBufUsableSpace - upUpdateHdrSize));
        }
        else {
            ScaledSpaceAvail = RealSpaceAvail - upUpdateHdrSize;

            // Calculate initial large packing size for the first buffer.
            CurrentScaledLargePackingSize = LargePackingSize -
                    pPkgInfo->cbInUse - upUpdateHdrSize;

            // For uncompressed, packing sizes need no scaling.
            ScaledSmallPackingSize = SmallPackingSize - upUpdateHdrSize;
            ScaledLargePackingSize = LargePackingSize - upUpdateHdrSize;
        }

        // Keep sending packets while there are some orders to do.
        while (cbOrderBytesRemaining > 0) {
            // Loop in case we need to use multiple packing sizes.
            for (;;) {
                // The encoded orders must not exceed the packing buffer
                // bounds.
                TRC_ASSERT(((pPkgInfo->cbInUse + (unsigned)ScaledSpaceAvail +
                        upUpdateHdrSize) <= pPkgInfo->cbLen),
                        (TB,"Target ScaledSpaceAvail %d exceeds the "
                        "encoding buffer - cbInUse=%u, cbLen=%u, "
                        "upHdrSize=%u",
                        ScaledSpaceAvail, pPkgInfo->cbInUse,
                        pPkgInfo->cbLen, upUpdateHdrSize));

                // Transfer as many orders into the packet as will fit.
                cbOrderBytes = (unsigned)ScaledSpaceAvail;
                cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                        pOrderBuffer, &NumOrders, &cbOrderBytes);

                TRC_DBG((TB, "%u bytes fetched into %d byte payload. %u "
                        "remain", cbOrderBytes, ScaledSpaceAvail -
                        upUpdateHdrSize, cbOrderBytesRemaining));

                if (cbOrderBytes > 0) {
                    // If we had any orders transferred, fill out the header
                    // and record the added bytes in the package.
                    if (scUseFastPathOutput) {
                        *(pOrderBuffer - upUpdateHdrSize) =
                                TS_UPDATETYPE_ORDERS |
                                scCompressionUsedValue;
                        *((PUINT16_UA)(pOrderBuffer - 2)) =
                                (UINT16)NumOrders;
                    }
                    else {
                        TS_UPDATE_ORDERS_PDU UNALIGNED *pUpdateOrdersPDU;

                        pUpdateOrdersPDU = (TS_UPDATE_ORDERS_PDU UNALIGNED *)
                                (pOrderBuffer - upUpdateHdrSize);
                        pUpdateOrdersPDU->shareDataHeader.pduType2 =
                                TS_PDUTYPE2_UPDATE;
                        pUpdateOrdersPDU->data.updateType =
                                TS_UPDATETYPE_ORDERS;
                        pUpdateOrdersPDU->data.numberOrders =
                                (UINT16)NumOrders;
                    }

                    // Add the data we have and allow MPPC compression to
                    // take place.
                    TRC_DBG((TB, "Send orders pkt. size(%d)", cbOrderBytes));
                    SC_AddToPackage(pPkgInfo, (cbOrderBytes + upUpdateHdrSize),
                            TRUE);

#ifdef DC_HICOLOR
                    // Having sent some data, we can again resort to the
                    // Very Large Buffer later if we need to
                    bTriedVeryLargeBuffer = FALSE;
#endif
                    // No need to try a larger size.
                    break;
                }
                else if (bSmallPackingSizeTarget) {
                    // Not having any orders transferred is not an error
                    // condition if we are working with a buffer target
                    // smaller than LargePackingSize -- there may
                    // have been a large order (most likely a cache-bitmap
                    // secondary order) that would not fit in the space we
                    // had in the buffer. Try again with a larger size.
                    ScaledSpaceAvail = CurrentScaledLargePackingSize;
                    bSmallPackingSizeTarget = FALSE;
                    continue;
                }
                else if (pPkgInfo->cbInUse) {
                    // This was the first packet and we may not have had
                    // enough space for a really large order. Need to force
                    // the packet to flush. Jump out of the loop.
                    break;
                }
#ifdef DC_HICOLOR
                else if (!bTriedVeryLargeBuffer) {
                    // Last ditch - try the very biggest package we're
                    // allowed to send.
                    TRC_NRM((TB, "Failed to send order in 8k - try 16k (%d)",
                            sc16KOutBufUsableSpace));

                    if (SC_GetSpaceInPackage(pPkgInfo,
                            sc16KOutBufUsableSpace)) {
                        pOrderBuffer = (BYTE *)pPkgInfo->pBuffer +
                                upUpdateHdrSize;
                        ScaledSpaceAvail = sc16KOutBufUsableSpace -
                                upUpdateHdrSize;
                        bTriedVeryLargeBuffer = TRUE;
                    }
                    else {
                        // Failed to allocate a packet. Skip out immediately
                        // and try again later.
                        TRC_NRM((TB, "Failed to alloc order packet"));
                        INC_INCOUNTER(IN_SND_NO_BUFFER);
                        status =  STATUS_NO_MEMORY;
                        DC_QUIT;
                    }
                }
#endif
                else {
                    // We're totally out of luck here. See comments immediately
                    // above. Return FALSE to simulate a failed allocation.
                    TRC_ASSERT((!bSmallPackingSizeTarget &&
                            pPkgInfo->cbInUse > 0),
                            (TB,"We failed to add an order even with largest "
                            "buffer size"));
                    status = STATUS_UNSUCCESSFUL; // what's the right error code here
                    DC_QUIT;
                }
            }

            // Force flush only if we have more orders to encode. Otherwise,
            // we might be able to fit in more info into the package.
            if (cbOrderBytesRemaining > 0) {
                // Flush the packet.

                status = SC_FlushAndAllocPackage(pPkgInfo);
                if ( STATUS_SUCCESS == status ) {
                    // If we were unable to transfer during the last order
                    // flush, use the large size in this new package.
                    if (cbOrderBytes) {
                        bSmallPackingSizeTarget = TRUE;
                        ScaledSpaceAvail = ScaledSmallPackingSize;
                    }
                    else {
                        bSmallPackingSizeTarget = FALSE;
                        ScaledSpaceAvail = ScaledLargePackingSize;
                    }

                    // No longer the first packet, we can push out to the full
                    // large packing size for packet retries.
                    CurrentScaledLargePackingSize = ScaledLargePackingSize;

                    pOrderBuffer = (BYTE *)pPkgInfo->pBuffer +
                            upUpdateHdrSize;
                }
                else {
                    // Failed to allocate a packet. We skip out immediately
                    // and try again later.
                    TRC_NRM((TB, "Failed to alloc order packet"));
                    INC_INCOUNTER(IN_SND_NO_BUFFER);
                    DC_QUIT;
                }
            }

            // If we are not shadowing, then send as many buffers as necessary
            if (m_pTSWd->shadowState == SHADOW_NONE)
                continue;

            // Else return back to the DD if we are in a shadow to force sending
            // one buffer at a time.
            else if (cbOrderBytesRemaining != 0) {
                break;
            }
        }
    }

    TRC_DBG((TB, "%d bytes of orders left", cbOrderBytesRemaining));
    if (cbOrderBytesRemaining == 0) {
        TRC_DBG((TB, "No orders left, reset the start of the heap"));
        OA_ResetOrderList();
    }
    else if (m_pTSWd->shadowState == SHADOW_NONE) {
        TRC_ALT((TB, "Shouldn't get here: heap should be empty!")); 

        // shouldn't we assert here?
        status = STATUS_UNSUCCESSFUL;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return status;
}


/****************************************************************************/
// UPFetchOrdersIntoBuffer
//
// Copies as many orders as will fit from the order heap into the given packet
// space, freeing the order heap space for each order copied. Returns the
// number of orders copied and the number of bytes of order heap data
// remaining.
/****************************************************************************/
unsigned RDPCALL SHCLASS UPFetchOrdersIntoBuffer(
        PBYTE    pBuffer,
        unsigned *pcOrders,
        PUINT    pcbBufferSize)
{
    PINT_ORDER pOrder;
    unsigned   FreeBytesInBuffer;
    unsigned   OrdersCopied;

    DC_BEGIN_FN("UPFetchOrdersIntoBuffer");

    // Initialize the buffer pointer and size.
    FreeBytesInBuffer = *pcbBufferSize;

    // Keep a count of the number of orders we copy.
    OrdersCopied = 0;

    // Return as many orders as possible.
    pOrder = OA_GetFirstListOrder();
    TRC_DBG((TB, "First order: %p", pOrder));

    while (pOrder != NULL) {

#if DC_DEBUG
        unsigned sum = 0;
        unsigned i;

        // Check the order checksum integrity
        for (i = 0; i < pOrder->OrderLength; i++) {
            sum += pOrder->OrderData[i];
        }
        if (pOrder->CheckSum != sum) {
            TRC_ASSERT((FALSE), (TB, "order heap corruption: %p\n", pOrder));            
        }
#endif

        // All orders are placed in the heap pre-encoded for the wire.
        // We need simply copy the resulting orders into the target buffer.
        if (pOrder->OrderLength <= FreeBytesInBuffer) {
            TRC_DBG((TB,"Copying heap order at hdr addr %p, len %u",
                    pOrder, pOrder->OrderLength));

            memcpy(pBuffer, pOrder->OrderData, pOrder->OrderLength);

            // Update the buffer pointer past the encoded order and get the
            // next order.
            pBuffer += pOrder->OrderLength;
            FreeBytesInBuffer -= pOrder->OrderLength;
            OrdersCopied++;
            pOrder = OA_RemoveListOrder(pOrder);
        }
        else {
            // The order was too big to fit in this buffer.
            // Exit the loop - this order will go in the next packet.
            break;
        }
    }

    // Fill in the packet header.
    *pcOrders = OrdersCopied;

    // Update the buffer size to indicate how much data we have written.
    *pcbBufferSize -= FreeBytesInBuffer;

    TRC_DBG((TB, "Returned %d orders in %d bytes", OrdersCopied,
            *pcbBufferSize));

    DC_END_FN();
    return OA_GetTotalOrderListBytes();
}


/****************************************************************************/
/* Name:      UPEnumSoundCaps                                               */
/*                                                                          */
/* Purpose:   Enumeration function for sound capabilities                   */
/*                                                                          */
/* Params:    locPersonID - persion ID of supplied caps                     */
/*            pCapabilities - caps                                          */
/****************************************************************************/
void CALLBACK SHCLASS UPEnumSoundCaps(
        LOCALPERSONID locPersonID,
        UINT_PTR UserData,
        PTS_CAPABILITYHEADER pCapabilities)
{
    PTS_SOUND_CAPABILITYSET pSoundCaps =
            (PTS_SOUND_CAPABILITYSET)pCapabilities;

    DC_BEGIN_FN("UPEnumSoundCaps");

    DC_IGNORE_PARAMETER(UserData);

    TRC_ASSERT((pSoundCaps->capabilitySetType == TS_CAPSETTYPE_SOUND),
            (TB,"Caps type not sound"));

    // We don't want to take our own sound caps into account - we are the
    // server so we don't advertise support for sound PDUs.
    if (SC_LOCAL_PERSON_ID != locPersonID) {
        // If there are no caps or the beep flag isn't set, disable beeps.
        if (pSoundCaps->lengthCapability == 0 ||
                !(pSoundCaps->soundFlags & TS_SOUND_FLAG_BEEPS))
            upCanSendBeep = FALSE;
    }

    DC_END_FN();
} /* UPEnumSoundCaps */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\kbd.h ===
/****************************** Module Header ******************************\
* Module Name: kbd.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Keyboard table values that form the basis for languages and keyboard types.
* The basis is US, kbd type 4 - all others are a variation on this.
* This file is included by all kbd**.h files.
*
* History:
* 10-Jan-1991 GregoryW
* 23-Apr-1991 IanJa         VSC_TO_VK _* macros from oemtab.c
\***************************************************************************/

#ifndef _KBD_
#define _KBD_

/****************************************************************************\
*
* Keyboard Layers.   Used in kdb??.dll and in usersrv.dll
*
\****************************************************************************/

/*
 * Key Event (KE) structure
 * Stores a Virtual Key event
 */
typedef struct tagKE {
    BYTE   bScanCode;   // Virtual Scan Code (Set 1)
    USHORT usFlaggedVk; // Vk | Flags
} KE, *PKE;

typedef BOOL (* KEPROC)(PKE pKe);

/*
 * KE.usFlaggedVk values, also used in the keyboard layer tables.
 */
#define KBDEXT      (USHORT)0x0100
#define KBDMULTIVK  (USHORT)0x0200
#define KBDSPECIAL  (USHORT)0x0400
#define KBDNUMPAD   (USHORT)0x0800
#define KBDUNICODE  (USHORT)0x1000
#define KBDBREAK    (USHORT)0x8000

/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * Keyboard Shift State defines. These correspond to the bit mask defined
 * by the VkKeyScan() API.
 */
#define KBDBASE        0
#define KBDSHIFT       1
#define KBDCTRL        2
#define KBDALT         4
// three symbols KANA, ROYA, LOYA are for FE
#define KBDKANA        8
#define KBDROYA        0x10
#define KBDLOYA        0x20
#define KBDGRPSELTAP   0x80

/*
 * Handy diacritics
 */
#define GRAVE           0x0300
#define ACUTE           0x0301
#define CIRCUMFLEX      0x0302
#define TILDE           0x0303
#define MACRON          0x0304
#define OVERSCORE       0x0305
#define BREVE           0x0306
#define DOT_ABOVE       0x0307
#define UMLAUT          0x0308
#define DIARESIS        UMLAUT
#define HOOK_ABOVE      0x0309
#define RING            0x030A
#define DOUBLE_ACUTE    0x030B
#define HACEK           0x030C

#define CEDILLA         0x0327
#define OGONEK          0x0328
#define TONOS           0x0384
#define DIARESIS_TONOS  0x0385


#define wszGRAVE           L"\x0300"
#define wszACUTE           L"\x0301"
#define wszCIRCUMFLEX      L"\x0302"
#define wszTILDE           L"\x0303"
#define wszMACRON          L"\x0304"
#define wszOVERSCORE       L"\x0305"
#define wszBREVE           L"\x0306"
#define wszDOT_ABOVE       L"\x0307"
#define wszUMLAUT          L"\x0308"
#define wszHOOK_ABOVE      L"\x0309"
#define wszRING            L"\x030A"
#define wszDOUBLE_ACUTE    L"\x030B"
#define wszHACEK           L"\x030C"

#define wszCEDILLA         L"\x0327"
#define wszOGONEK          L"\x0328"
#define wszTONOS           L"\x0384"
#define wszDIARESIS_TONOS  L"\x0385"

/***************************************************************************\
* MODIFIER KEYS
*
* All keyboards have "Modifier" keys which are used to alter the behaviour of
* some of the other keys.  These shifter keys are usually:
*   Shift  (left and/or right Shift key)
*   Ctrl   (left and/or right Ctrl key)
*   Alt    (left and/or right Alt key)
*   AltGr  (right Alt key only)
*
* NOTE:
*   All keyboards use the Shift key.
*   All keyboards use a Ctrl key to generate ASCII control characters.
*   All keyboards with a number pad use the Alt key and the NumPad to
*     generate characters by number.
*   Keyboards using AltGr as a Modifier Key usually translate the Virtual
*     ScanCode to Virtual Keys VK_CTRL + VK_ALT at input time: the Modifier
*     tables should be written to treat Ctrl + Alt as a valid shifter
*     key combination in these cases.
*
* By holding down 0 or more of these Modifier keys, a "shift state" is
* obtained : the shift state may affect the translation of Virtual Scancodes
* to Virtual Keys and/or the translation of Virtuals Key to Characters.
*
* EXAMPLES:
*
* Each key on a particular keyboard may be marked with up to five different
* characters in five different positions:
*
*              .-------.
*             /|       |\
*            : | 2   4 | :
*            | |       | |
*            | |       | |
*            | | 1   3 | |
*            | |_______| |
*            | /       \ |
*            |/    5    \|
*            `-----------'
*
* A key may also be able to generate a character that is not marked on it:
* these are ASCII Control chars, lower-case letters and/or "invisible keys".
*                                                  .-------.
*      An example of an "Invisible Key":          /|       |\
*                                                : | >     | :
*  The German M24 keyboard 2 should produce the  | |       | |
*  '|' character when ALT SHIFT is is held down  | |       | |
*  while the '<' key (shown here) is pressed:    | | <   \ | |
*  This keyboard has four other invisible        | |_______| |
*  characters.  France, Italy and Spain also     | /       \ |
*  support invisible characters on the M24       |/         \|
*  Keyboard 2 with ALT SHIFT depressed.          `-----------'
*
* The keyboard table must list the keys that contribute to it's shift state,
* and indicate which combinations are valid.  This is done with
*    aCharModifiers[]  - convert combinations of Modifier Keys to Bitmasks.
* and
*    aModification[];  - convert Modifier Bitmasks to enumerated Modifications
*
* AN EXAMPLE OF VALID AND INVALID MODIFIER KEY COMBINATIONS
*
*    The US English keyboard has 3 Modifier keys:
*      Shift (left or right); Ctrl (left or right); and Alt (left or right).
*
*    The only valid combinations of these Modifier Keys are:
*      none pressed      : Character at position (1) on the key.
*      Shift             : Character at position (2) on the key.
*      Ctrl              : Ascii Control characters
*      Shift + Ctrl      : Ascii Control characters
*      Alt               : Character-by-number on the numpad
*
*    The invalid combinations (that do not generate any characters) are:
*      Shift + Alt
*      Alt + Ctrl
*      Shift + Alt + Ctrl
*
* Something (???) :
* -----------------
*      Modifier keys              Character produced
*      -------------------------  ------------------
*   0  No shifter key depressed   position 1
*   1  Shift key is depressed     position 2
*   2  AltGr (r.h. Alt) depressed position 4 or 5 (whichever is marked)
*
* However, note that 3 shifter keys (SHIFT, can be combined in a
* characters, depending on the Keyboards
* Consider the following keyboards:
*
*     .-------.            STRANGE KBD         PECULIAR KBD
*    /|       |\           ==================  ==================
*   : | 2   4 | :    1   -
*   | |       | |    2   - SHIFT               SHIFT
*   | |       | |    3   - MENU                MENU
*   | | 1   3 | |    4   - SHIFT + MENU        SHIFT + MENU
*   | |_______| |    5   -    no such keys     CTRL  + MENU
*   | /       \ |
*   |/    5    \|
*   `-----------'
* Both STRANGE and PECULIAR keyboards could have aVkToBits[] =
*   { VK_SHIFT  , KBDSHIFT }, // 0x01
*   { VK_CONTROL, KBDCTRL  }, // 0x02
*   { VK_MENU   , KBDALT   }, // 0x04
*   { 0,          0        }
*
* The STRANGE keyboard has 4 distinct shift states, while the PECULIAR kbd
* has 5.  However, note that 3 shifter bits can be combined in a
* total of 2^3 == 8 ways.  Each such combination must be related to one (or
* none) of the enumerated shift states.
* Each shifter key combination can be represented by three binary bits:
*  Bit 0  is set if VK_SHIFT is down
*  Bit 1  is set if VK_CONTROL is down
*  Bit 2  is set if VK_MENU is down
*
* Example: If the STRANGE keyboard generates no characters in combination
* when just the ALT key is held down, nor when the SHIFT, CTRL and ALT keys
* are all held down, then the tables might look like this:
*
*                                VK_MENU,
*                        VK_CTRL,                    0
*    };
*    aModification[] = {
*        0,            //   0       0       0     = 000  <none>
*        1,            //   0       0       1     = 001  SHIFT
*        SHFT_INVALID, //   0       1       0     = 010  ALT
*        2,            //   0       1       1     = 011  SHIFT ALT
*        3,            //   1       0       0     = 100  CTRL
*        4,            //   1       0       1     = 101  SHIFT CTRL
*        5,            //   1       1       0     = 110  CTRL ALT
*        SHFT_INVALID  //   1       1       1     = 111  SHIFT CTRL ALT
*    };
*
*
\***************************************************************************/

/***************************************************************************\
* VK_TO_BIT - associate a Virtual Key with a Modifier bitmask.
*
* Vk        - the Virtual key (eg: VK_SHIFT, VK_RMENU, VK_CONTROL etc.)
*             Special Values:
*                0        null terminator
* ModBits   - a combination of KBDALT, KBDCTRL, KBDSHIFT and kbd-specific bits
*             Any kbd-specific shift bits must be the lowest-order bits other
*             than KBDSHIFT, KBDCTRL and KBDALT (0, 1 & 2)
*
* Those languages that use AltGr (VK_RMENU) to shift keys convert it to
* CTRL+ALT with the KBDSPECIAL bit in the ausVK[] entry for VK_RMENU
* and by having an entry in aVkToPfnOem[] to simulate the right Vk sequence.
*
\***************************************************************************/
typedef struct {
    BYTE Vk;
    BYTE ModBits;
} VK_TO_BIT, *PVK_TO_BIT;

/***************************************************************************\
* pModNumber  - a table to map shift bits to enumerated shift states
*
* Table attributes: Ordered table
*
* Maps all possible shifter key combinations to an enumerated shift state.
* The size of the table depends on the value of the highest order bit used
* in aCharModifiers[*].ModBits
*
* Special values for aModification[*]
*   SHFT_INVALID - no characters produced with this shift state.
LATER: (ianja) no SHFT_CTRL - control characters encoded in tables like others
*   SHFT_CTRL    - standard control character production (all keyboards must
*                  be able to produce CTRL-C == 0x0003 etc.)
*   Other        - enumerated shift state (not less than 0)
*
* This table is indexed by the Modifier Bits to obtain an Modification Number.
*
*                        CONTROL MENU SHIFT
*
*    aModification[] = {
*        0,            //   0     0     0     = 000  <none>
*        1,            //   0     0     1     = 001  SHIFT
*        SHFT_INVALID, //   0     1     0     = 010  ALT
*        2,            //   0     1     1     = 011  SHIFT ALT
*        3,            //   1     0     0     = 100  CTRL
*        4,            //   1     0     1     = 101  SHIFT CTRL
*        5,            //   1     1     0     = 110  CTRL ALT
*        SHFT_INVALID  //   1     1     1     = 111  SHIFT CTRL ALT
*    };
*
\***************************************************************************/
typedef struct {
    PVK_TO_BIT pVkToBit;     // Virtual Keys -> Mod bits
    WORD       wMaxModBits;  // max Modification bit combination value
    BYTE       ModNumber[];  // Mod bits -> Modification Number
} MODIFIERS, *PMODIFIERS;

WORD GetModifierBits(PMODIFIERS pModifiers, LPBYTE afKeyState);
WORD GetModificationNumber(PMODIFIERS pModifiers, WORD wModBits);

// FE Modifiers_VK
extern PMODIFIERS gpModifiers_VK;
extern MODIFIERS Modifiers_VK_STANDARD;
extern MODIFIERS Modifiers_VK_IBM02;

#define SHFT_INVALID 0x0F

/***************************************************************************\
* apulCvt_VK[] - obtain VK translation table from shift state
*     A VK translation table is used to change the value of the Virtual Key
*     according to the shift state.   OEM only (not locale-specific)
\***************************************************************************/
extern const PULONG *gapulCvt_VK;
extern const ULONG *const gapulCvt_VK_101[];
extern const ULONG *const gapulCvt_VK_84[];
// gapulCvt_VK_IBM02[] is for FE
extern const ULONG *const gapulCvt_VK_IBM02[];

/***************************************************************************\
* awNumPadCvt[]   - Translate cursor movement keys to numpad keys
\***************************************************************************/
extern const MODIFIERS Modifiers_VK;
extern BYTE aVkNumpad[];

/***************************************************************************\
* VSC_VK     - Associate a Virtual Scancode with a Virtual Key
*  Vsc - Virtual Scancode
*  Vk  - Virtual Key | flags
* Used by VKFromVSC() for scancodes prefixed 0xE0 or 0xE1
\***************************************************************************/
typedef struct _VSC_VK {
    BYTE Vsc;
    USHORT Vk;
} VSC_VK, *PVSC_VK;

/***************************************************************************\
* VK_VSC     - Associate a Virtual Key with a Virtual Scancode
*  Vk  - Virtual Key
*  Vsc - Virtual Scancode
* Used by MapVirtualKey for Virtual Keys not appearing in ausVK[]
\***************************************************************************/
typedef struct _VK_VSC {
    BYTE Vk;
    BYTE Vsc;
} VK_VSC, *PVK_VSC;

/***************************************************************************\
*
* VK_TO_WCHARS<n> - Associate a Virtual Key with <n> UNICODE characters
*
* VirtualKey  - The Virtual Key.
* wch[]       - An array of characters, one for each shift state that
*               applies to the specified Virtual Key.
*
* Special values for VirtualKey:
*    -1        - This entry contains dead chars for the previous entry
*    0         - Terminates a VK_TO_WCHARS[] table
*
* Special values for Attributes:
*    CAPLOK    - The CAPS-LOCK key affects this key like SHIFT
*    SGCAPS    - CapsLock uppercases the unshifted char (Swiss-German)
*
* Special values for wch[*]:
*    WCH_NONE  - No character is generated by pressing this key with the
*                current shift state.
*    WCH_DEAD  - The character is a dead-key: the next VK_TO_WCHARS[] entry
*                will contain the values of the dead characters (diaresis)
*                that can be produced by the Virtual Key.
*    WCH_LGTR  - The character is a ligature.  The characters generated by
*                this keystroke are found in the ligature table.
*
\***************************************************************************/
#define WCH_NONE 0xF000
#define WCH_DEAD 0xF001
#define WCH_LGTR 0xF002

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04
// KANALOK is for FE
#define KANALOK     0x08
#define GRPSELTAP   0x80

/*
 * Macro for VK to WCHAR with "n" shift states
 */
#define TYPEDEF_VK_TO_WCHARS(n) typedef struct _VK_TO_WCHARS##n {  \
                                    BYTE  VirtualKey;      \
                                    BYTE  Attributes;      \
                                    WCHAR wch[n];          \
                                } VK_TO_WCHARS##n, *PVK_TO_WCHARS##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of shift states), used
 * to facilitate static initializations of tables.
 * VK_TO_WCHARS1 and PVK_TO_WCHARS1 may be used as the generic type
 */
TYPEDEF_VK_TO_WCHARS(1) // VK_TO_WCHARS1, *PVK_TO_WCHARS1;
TYPEDEF_VK_TO_WCHARS(2) // VK_TO_WCHARS2, *PVK_TO_WCHARS2;
TYPEDEF_VK_TO_WCHARS(3) // VK_TO_WCHARS3, *PVK_TO_WCHARS3;
TYPEDEF_VK_TO_WCHARS(4) // VK_TO_WCHARS4, *PVK_TO_WCHARS4;
TYPEDEF_VK_TO_WCHARS(5) // VK_TO_WCHARS5, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(6) // VK_TO_WCHARS6, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(7) // VK_TO_WCHARS7, *PVK_TO_WCHARS7;
// these three (8,9,10) are for FE
TYPEDEF_VK_TO_WCHARS(8) // VK_TO_WCHARS8, *PVK_TO_WCHARS8;
TYPEDEF_VK_TO_WCHARS(9) // VK_TO_WCHARS9, *PVK_TO_WCHARS9;
TYPEDEF_VK_TO_WCHARS(10) // VK_TO_WCHARS10, *PVK_TO_WCHARS10;

/***************************************************************************\
*
* VK_TO_WCHAR_TABLE - Describe a table of VK_TO_WCHARS1
*
* pVkToWchars     - points to the table.
* nModifications  - the number of shift-states supported by this table.
*                   (this is the number of elements in pVkToWchars[*].wch[])
*
* A keyboard may have several such tables: all keys with the same number of
*    shift-states are grouped together in one table.
*
* Special values for pVktoWchars:
*     NULL     - Terminates a VK_TO_WCHAR_TABLE[] list.
*
\***************************************************************************/

typedef struct _VK_TO_WCHAR_TABLE {
    PVK_TO_WCHARS1 pVkToWchars;
    BYTE           nModifications;
    BYTE           cbSize;
} VK_TO_WCHAR_TABLE, *PVK_TO_WCHAR_TABLE;

/***************************************************************************\
*
* Dead Key (diaresis) tables
*
* LATER IanJa: supplant by an NLS API that composes Diacritic+Base -> WCHAR
*
\***************************************************************************/
typedef struct {
    DWORD  dwBoth;  // diacritic & char
    WCHAR  wchComposed;
    USHORT uFlags;
} DEADKEY, *PDEADKEY;

#define DEADTRANS(ch, accent, comp, flags) { MAKELONG(ch, accent), comp, flags}

/*
 * Bit values for uFlags
 */
#define DKF_DEAD  0x0001

/***************************************************************************\
*
* Ligature table
*
\***************************************************************************/
/*
 * Macro for ligature with "n" characters
 */
#define TYPEDEF_LIGATURE(n) typedef struct _LIGATURE##n {     \
                                    BYTE  VirtualKey;         \
                                    WORD  ModificationNumber; \
                                    WCHAR wch[n];             \
                                } LIGATURE##n, *PLIGATURE##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of ligatures), used
 * to facilitate static initializations of tables.
 *
 * LIGATURE1 and PLIGATURE1 are used as the generic type
 */
TYPEDEF_LIGATURE(1) // LIGATURE1, *PLIGATURE1;
TYPEDEF_LIGATURE(2) // LIGATURE2, *PLIGATURE2;
TYPEDEF_LIGATURE(3) // LIGATURE3, *PLIGATURE3;
TYPEDEF_LIGATURE(4) // LIGATURE4, *PLIGATURE4;
TYPEDEF_LIGATURE(5) // LIGATURE5, *PLIGATURE5;

/***************************************************************************\
* VSC_LPWSTR - associate a Virtual Scancode with a Text string
*
* Uses:
*   GetKeyNameText(), aKeyNames[]  Map virtual scancode to name of key
*
\***************************************************************************/
typedef struct {
    BYTE   vsc;
    LPWSTR pwsz;
} VSC_LPWSTR, *PVSC_LPWSTR;

/*
 * Along with ligature support we're adding a proper version number.
 * The previous version number (actually just unused bits...) was
 * always zero.  The version number will live in the high word of
 * fLocaleFlags.
 */
#define KBD_VERSION         1
#define GET_KBD_VERSION(p)  (HIWORD((p)->fLocaleFlags))

/*
 * Attributes such as AltGr, LRM_RLM, ShiftLock are stored in the the low word
 * of fLocaleFlags (layout specific) or in gdwKeyboardAttributes (all layouts)
 */
#define KLLF_ALTGR       0x0001
#define KLLF_SHIFTLOCK   0x0002
#define KLLF_LRM_RLM     0x0004

/*
 * Some attributes are per-layout (specific to an individual layout), some
 * attributes are per-user (apply globally to all layouts).  Some are both.
 */
#define KLLF_LAYOUT_ATTRS (KLLF_SHIFTLOCK | KLLF_ALTGR | KLLF_LRM_RLM)
#define KLLF_GLOBAL_ATTRS (KLLF_SHIFTLOCK)

/*
 * Flags passed in to the KeyboardLayout API (KLF_*) as can be converted to
 * internal (KLLF_*) attributes:
 */
#define KLL_ATTR_FROM_KLF(x)         ((x) >> 15)
#define KLL_LAYOUT_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_LAYOUT_ATTRS)
#define KLL_GLOBAL_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_GLOBAL_ATTRS)

#ifdef _WINUSERP_
/*
 * If we have included winuserp.h, we can check our KLLF_* values
 */
#if KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
    #error KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
#endif
#if KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
    #error KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
#endif
#endif // _WINUSERP_

/***************************************************************************\
* KBDTABLES
*
* This structure describes all the tables that implement the keyboard layer.
*
* When switching to a new layer, we get a new KBDTABLES structure: all key
* processing tables are accessed indirectly through this structure.
*
\***************************************************************************/

typedef struct tagKbdLayer {
    /*
     * Modifier keys
     */
    PMODIFIERS pCharModifiers;

    /*
     * Characters
     */
    VK_TO_WCHAR_TABLE *pVkToWcharTable;  // ptr to tbl of ptrs to tbl

    /*
     * Diacritics
     */
    PDEADKEY pDeadKey;

    /*
     * Names of Keys
     */
    VSC_LPWSTR *pKeyNames;
    VSC_LPWSTR *pKeyNamesExt;
    LPWSTR     *pKeyNamesDead;

    /*
     * Scan codes to Virtual Keys
     */
    USHORT *pusVSCtoVK;
    BYTE    bMaxVSCtoVK;
    PVSC_VK pVSCtoVK_E0;  // Scancode has E0 prefix
    PVSC_VK pVSCtoVK_E1;  // Scancode has E1 prefix

    /*
     * Locale-specific special processing
     */
    DWORD fLocaleFlags;

    /*
     * Ligatures
     */
    BYTE       nLgMax;
    BYTE       cbLgEntry;
    PLIGATURE1 pLigature;
} KBDTABLES, *PKBDTABLES;

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];

/*
 * FarEast-specific special...
 */
typedef struct _VK_FUNCTION_PARAM {
    BYTE  NLSFEProcIndex;
    ULONG NLSFEProcParam;
} VK_FPARAM, *PVK_FPARAM;

typedef struct _VK_TO_FUNCTION_TABLE {
    BYTE Vk;
    BYTE NLSFEProcType;
    BYTE NLSFEProcCurrent;
    // Index[0] : Base
    // Index[1] : Shift
    // Index[2] : Control
    // Index[3] : Shift+Control
    // Index[4] : Alt
    // Index[5] : Shift+Alt
    // Index[6] : Control+Alt
    // Index[7] : Shift+Control+Alt
    BYTE NLSFEProcSwitch;   // 8 bits
    VK_FPARAM NLSFEProc[8];
    VK_FPARAM NLSFEProcAlt[8];
} VK_F, *PVK_F;

typedef struct tagKbdNlsLayer {
    USHORT OEMIdentifier;
    USHORT LayoutInformation;
    UINT  NumOfVkToF;
    VK_F   *pVkToF;
    //
    // The pusMouseVKey array provides a translation from the virtual key
    // value to an index.  The index is used to select the appropriate
    // routine to process the virtual key, as well as to select extra
    // information that is used by this routine during its processing.
    // If this value is NULL, following default will be used.
    //
    // ausMouseVKey[] = {
    //     VK_CLEAR,           // Numpad 5: Click active button
    //     VK_PRIOR,           // Numpad 9: Up & Right
    //     VK_NEXT,            // Numpad 3: Down & Right
    //     VK_END,             // Numpad 1: Down & Left
    //     VK_HOME,            // Numpad 7: Up & Left
    //     VK_LEFT,            // Numpad 4: Left
    //     VK_UP,              // Numpad 8: Up
    //     VK_RIGHT,           // Numpad 6: Right
    //     VK_DOWN,            // Numpad 2: Down
    //     VK_INSERT,          // Numpad 0: Active button down
    //     VK_DELETE,          // Numpad .: Active button up
    //     VK_MULTIPLY,        // Numpad *: Select both buttons
    //     VK_ADD,             // Numpad +: Double click active button
    //     VK_SUBTRACT,        // Numpad -: Select right button
    //     VK_DEVIDE|KBDEXT,   // Numpad /: Select left button
    //     VK_NUMLOCK|KBDEXT}; // Num Lock
    //
    INT     NumOfMouseVKey;
    USHORT *pusMouseVKey;
} KBDNLSTABLES, *PKBDNLSTABLES;

//
// OEM Ids - KBDNLSTABLES.OEMIdentifier
//
// PSS ID Number: Q130054
// Article last modified on 05-16-1995
//
// 3.10 1.20 | 3.50 1.20
// WINDOWS   | WINDOWS NT
//
// ---------------------------------------------------------------------
// The information in this article applies to:
// - Microsoft Windows Software Development Kit (SDK) for Windows
//   version 3.1
// - Microsoft Win32 Software Development Kit (SDK) version 3.5
// - Microsoft Win32s version 1.2
// ---------------------------------------------------------------------
// SUMMARY
// =======
// Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
// so on) in Japan, sometimes Windows-based applications need to know which
// OEM (original equipment manufacturer) manufactured the computer that is
// running the application. This article explains how.
//
// MORE INFORMATION
// ================
// There is no documented way to detect the manufacturer of the computer that
// is currently running an application. However, a Windows-based application
// can detect the type of OEM Windows by using the return value of the
// GetKeyboardType() function.
//
// If an application uses the GetKeyboardType API, it can get OEM ID by
// specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
// is listed here:
//
// OEM Windows       OEM ID
// ------------------------------
// Microsoft         00H (DOS/V)
// all AX            01H
// EPSON             04H
// Fujitsu           05H
// IBMJ              07H
// Matsushita        0AH
// NEC               0DH
// Toshiba           12H
//
// Application programs can use these OEM IDs to distinguish the type of OEM
// Windows. Note, however, that this method is not documented, so Microsoft
// may not support it in the future version of Windows.
//
// As a rule, application developers should write hardware-independent code,
// especially when making Windows-based applications. If they need to make a
// hardware-dependent application, they must prepare the separated program
// file for each different hardware architecture.
//
// Additional reference words: 3.10 1.20 3.50 1.20 kbinf
// KBCategory: kbhw
// KBSubcategory: wintldev
// =============================================================================
// Copyright Microsoft Corporation 1995.
//
#define NLSKBD_OEM_MICROSOFT          0x00
#define NLSKBD_OEM_AX                 0x01
#define NLSKBD_OEM_EPSON              0x04
#define NLSKBD_OEM_FUJITSU            0x05
#define NLSKBD_OEM_IBM                0x07
#define NLSKBD_OEM_MATSUSHITA         0x0A
#define NLSKBD_OEM_NEC                0x0D
#define NLSKBD_OEM_TOSHIBA            0x12
#define NLSKBD_OEM_DEC                0x18 // only NT
//
// Microsoft (default) - keyboards hardware/layout
//
#define MICROSOFT_KBD_101_TYPE           0
#define MICROSOFT_KBD_AX_TYPE            1
#define MICROSOFT_KBD_106_TYPE           2
#define MICROSOFT_KBD_002_TYPE           3
#define MICROSOFT_KBD_001_TYPE           4
#define MICROSOFT_KBD_FUNC              12
//
// AX consortium - keyboards hardware/layout
//
#define AX_KBD_DESKTOP_TYPE              1
//
// Fujitsu - keyboards hardware/layout
//
#define FMR_KBD_JIS_TYPE                 0
#define FMR_KBD_OASYS_TYPE               1
#define FMV_KBD_OASYS_TYPE               2
//
// NEC - keyboards hardware/layout
//
#define NEC_KBD_NORMAL_TYPE              1
#define NEC_KBD_N_MODE_TYPE              2
#define NEC_KBD_H_MODE_TYPE              3
#define NEC_KBD_LAPTOP_TYPE              4
#define NEC_KBD_106_TYPE                 5
//
// Toshiba - keyboards hardware/layout
//
#define TOSHIBA_KBD_DESKTOP_TYPE        13
#define TOSHIBA_KBD_LAPTOP_TYPE         15
//
// DEC - keyboards hardware/layout
//
#define DEC_KBD_ANSI_LAYOUT_TYPE         1 // only NT
#define DEC_KBD_JIS_LAYOUT_TYPE          2 // only NT

//
// Keyboard layout information - KBDNLSTABLE.LayoutInformation
//

//
// If this flag is on, System sends notification to keyboard
// drivers (leyout/kernel mode). when IME (Input-Mehod-Editor)
// status become changed.
//
#define NLSKBD_INFO_SEND_IME_NOTIFICATION  0x0001

//
// If this flag is on, System will use VK_HOME/VK_KANA instead of
// VK_NUMLOCK/VK_OEM_SCROLL for Accessibility toggle keys.
// + Typically, NEC PC-9800 Series will use this bit, because
//   they does not have 'NumLock' and 'ScrollLock' keys.
//
#define NLSKBD_INFO_ACCESSIBILITY_KEYMAP   0x0002

//
// If this flag is on, System will return 101 or 106 Japanese
// keyboard type/subtype id, when GetKeyboardType() is called.
//
#define NLSKBD_INFO_EMURATE_101_KEYBOARD   0x0010
#define NLSKBD_INFO_EMURATE_106_KEYBOARD   0x0020

//
// Keyboard layout function types
//
// - VK_F.NLSFEProcType
//
#define KBDNLS_TYPE_NULL      0
#define KBDNLS_TYPE_NORMAL    1
#define KBDNLS_TYPE_TOGGLE    2

//
// - VK_F.NLSFEProcCurrent
//
#define KBDNLS_INDEX_NORMAL   1
#define KBDNLS_INDEX_ALT      2

//
// - VK_F.NLSFEProc[]
//
#define KBDNLS_NULL             0 // Invalid function
#define KBDNLS_NOEVENT          1 // Drop keyevent
#define KBDNLS_SEND_BASE_VK     2 // Send Base VK_xxx
#define KBDNLS_SEND_PARAM_VK    3 // Send Parameter VK_xxx
#define KBDNLS_KANALOCK         4 // VK_KANA (with hardware lock)
#define KBDNLS_ALPHANUM         5 // VK_DBE_ALPHANUMERIC
#define KBDNLS_HIRAGANA         6 // VK_DBE_HIRAGANA
#define KBDNLS_KATAKANA         7 // VK_DBE_KATAKANA
#define KBDNLS_SBCSDBCS         8 // VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR
#define KBDNLS_ROMAN            9 // VK_DBE_ROMAN/VK_DBE_NOROMAN
#define KBDNLS_CODEINPUT       10 // VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT
#define KBDNLS_HELP_OR_END     11 // VK_HELP or VK_END [NEC PC-9800 Only]
#define KBDNLS_HOME_OR_CLEAR   12 // VK_HOME or VK_CLEAR [NEC PC-9800 Only]
#define KBDNLS_NUMPAD          13 // VK_NUMPAD? for Numpad key [NEC PC-9800 Only]
#define KBDNLS_KANAEVENT       14 // VK_KANA [Fujitsu FMV oyayubi Only]
#define KBDNLS_CONV_OR_NONCONV 15 // VK_CONVERT and VK_NONCONVERT [Fujitsu FMV oyayubi Only]

typedef BOOL (* NLSKEPROC)(PKE pKe, ULONG dwExtraInfo, ULONG dwParam);
typedef BOOL (* NLSVKFPROC)(PVK_F pVkToF, PKE pKe, ULONG dwExtraInfo);

//
// Keyboard Type = 7 : Japanese Keyboard
// Keyboard Type = 8 : Korean Keyboard
//
#define JAPANESE_KEYBOARD(Id)  ((Id).Type == 7)
#define KOREAN_KEYBOARD(Id)    ((Id).Type == 8)

#define JAPANESE_KBD_LAYOUT(hkl) ((LOBYTE(LOWORD(HandleToUlong(hkl)))) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)   ((LOBYTE(LOWORD(HandleToUlong(hkl)))) == LANG_KOREAN)

//
// NLS Keyboard functions
//
VOID NlsKbdInitializePerSystem(VOID);
VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion);

// end of FE specific

/***************************************************************************\
* Macros for ausVK[] values (used below)
*
* These macros prefix each argument with VK_ to produce the name of a Virtual
* Key defined in "winuser.h" (eg: ESCAPE becomes VK_ESCAPE).
\***************************************************************************/
#ifndef KBD_TYPE
#define KBD_TYPE 4
#endif

/*
 * _NE() selects the Virtual Key according to keyboard type
 */
#if   (KBD_TYPE == 1)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v1)
#elif (KBD_TYPE == 2)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v2)
#elif (KBD_TYPE == 3)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v3)
#elif (KBD_TYPE == 4)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v4)
#elif (KBD_TYPE == 5)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v5)
#elif (KBD_TYPE == 6)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v6)
#elif (KBD_TYPE == 7)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v7)
#elif (KBD_TYPE == 8)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v8)
#elif (KBD_TYPE == 10)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v10)
#elif (KBD_TYPE == 11)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v11)
#elif (KBD_TYPE == 12)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v12)
#elif (KBD_TYPE == 13)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v13)
#elif (KBD_TYPE == 16)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v16)
#elif (KBD_TYPE == 20)
#define _NE(v20,v21,v22)           (VK_##v20)
#elif (KBD_TYPE == 21)
#define _NE(v20,v21,v22)           (VK_##v21)
#elif (KBD_TYPE == 22)
#define _NE(v20,v21,v22)           (VK_##v22)
#elif (KBD_TYPE == 30)
#define _NE(v30,v33,v34)           (VK_##v30)
#elif (KBD_TYPE == 33)
#define _NE(v30,v33,v34)           (VK_##v33)
#elif (KBD_TYPE == 34)
#define _NE(v30,v33,v34)           (VK_##v34)
#elif (KBD_TYPE == 40)
#define _NE(v40,v41)               (VK_##v40)
#elif (KBD_TYPE == 41)
#define _NE(v40,v41)               (VK_##v41)
#endif

/*
 * _EQ() selects the same Virtual Key for all keyboard types
 */
#if   (KBD_TYPE <= 6)
#define _EQ(         v4      ) (VK_##v4)
#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
#define _EQ(   v8            ) (VK_##v8)
#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
#define _EQ(v20              ) (VK_##v20)
#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
#define _EQ(         v30     ) (VK_##v30)
#elif (KBD_TYPE == 37)
#define _EQ(         v37     ) (VK_##v37)
#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
#define _EQ( v40             ) (VK_##v40)
#endif

/*
 * A bit of trickery for virtual key names 'A' to 'Z' and '0' to '9' so
 * that they are not converted to a VK_* name.
 * With this macro, VK_'A' equates to 'A' etc.
 */
#define VK_
#define VK__none_   0xFF
#define VK_ABNT_C1  0xC1
#define VK_ABNT_C2  0xC2

#if (KBD_TYPE <= 6)
/***************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* These values are for Scancode Set 3 and the USA.
* Other languages substitute their own values where required (files kbd**.h)
*
* Six sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =======================================================
*    1       AT&T '301' & '302'; Olivetti 83-key; PC-XT 84-key; etc.
*    2       Olivetti M24 102-key
*    3       HP Vectra (DIN); Olivetti 86-key; etc.
*    4 *     Enhanced 101/102-key; Olivetti A; etc.
*    5       Nokia (Ericsson) type 5 (1050, etc.)
*    6       Nokia (Ericsson) type 6 (9140)
*
* * If KBD_TYPE is not defined, the default is type 4.
*
* KB3270 comments refers to KB 3270 keyboards in native emulation mode (DIP
* switches all OFF), and the Scancode Map used to convert its scancodes to
* standard scancode set 1.
*    KB3270 <= 57      - this entry is reached by mapping from scancode 0x57
*                        to an arbitrary scancode: the VK is what counts
*    KB3270 => HOME    - this scancode is mapped to the scancode for VK_HOME
*    KB3270            - no mapping involved, a scancode for KB3270 only
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +--------+--------+--------+--------+--------+--------+
*     | Scan | |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |
*     | code | | type 1 | type 2 | type 3 | type 4 | type 5 | type 6 |
\****+-------+-+--------+--------+--------+--------+--------+--------+******/
#define T00 _EQ(                           _none_                    )
#define T01 _EQ(                           ESCAPE                    )
#define T02 _EQ(                           '1'                       )
#define T03 _EQ(                           '2'                       )
#define T04 _EQ(                           '3'                       )
#define T05 _EQ(                           '4'                       )
#define T06 _EQ(                           '5'                       )
#define T07 _EQ(                           '6'                       )
#define T08 _EQ(                           '7'                       )
#define T09 _EQ(                           '8'                       )
#define T0A _EQ(                           '9'                       )
#define T0B _EQ(                           '0'                       )
#define T0C _EQ(                           OEM_MINUS                 )
#define T0D _NE(OEM_PLUS,OEM_4,   OEM_PLUS,OEM_PLUS,OEM_PLUS,OEM_PLUS)
#define T0E _EQ(                           BACK                      )
#define T0F _EQ(                           TAB                       )
#define T10 _EQ(                           'Q'                       )
#define T11 _EQ(                           'W'                       )
#define T12 _EQ(                           'E'                       )
#define T13 _EQ(                           'R'                       )
#define T14 _EQ(                           'T'                       )
#define T15 _EQ(                           'Y'                       )
#define T16 _EQ(                           'U'                       )
#define T17 _EQ(                           'I'                       )
#define T18 _EQ(                           'O'                       )
#define T19 _EQ(                           'P'                       )
#define T1A _NE(OEM_4,   OEM_6,   OEM_4,   OEM_4,   OEM_4,   OEM_4   )
#define T1B _NE(OEM_6,   OEM_1,   OEM_6,   OEM_6,   OEM_6,   OEM_6   )
#define T1C _EQ(                           RETURN                    )
#define T1D _EQ(                           LCONTROL                  )
#define T1E _EQ(                           'A'                       )
#define T1F _EQ(                           'S'                       )
#define T20 _EQ(                           'D'                       )
#define T21 _EQ(                           'F'                       )
#define T22 _EQ(                           'G'                       )
#define T23 _EQ(                           'H'                       )
#define T24 _EQ(                           'J'                       )
#define T25 _EQ(                           'K'                       )
#define T26 _EQ(                           'L'                       )
#define T27 _NE(OEM_1,   OEM_PLUS,OEM_1,   OEM_1,   OEM_1,   OEM_1   )
#define T28 _NE(OEM_7,   OEM_3,   OEM_7,   OEM_7,   OEM_3,   OEM_3   )
#define T29 _NE(OEM_3,   OEM_7,   OEM_3,   OEM_3,   OEM_7,   OEM_7   )
#define T2A _EQ(                           LSHIFT                    )
#define T2B _EQ(                           OEM_5                     )
#define T2C _EQ(                           'Z'                       )
#define T2D _EQ(                           'X'                       )
#define T2E _EQ(                           'C'                       )
#define T2F _EQ(                           'V'                       )
#define T30 _EQ(                           'B'                       )
#define T31 _EQ(                           'N'                       )
#define T32 _EQ(                           'M'                       )
#define T33 _EQ(                           OEM_COMMA                 )
#define T34 _EQ(                           OEM_PERIOD                )
#define T35 _EQ(                           OEM_2                     )
#define T36 _EQ(                           RSHIFT                    )
#define T37 _EQ(                           MULTIPLY                  )
#define T38 _EQ(                           LMENU                     )
#define T39 _EQ(                           ' '                       )
#define T3A _EQ(                           CAPITAL                   )
#define T3B _EQ(                           F1                        )
#define T3C _EQ(                           F2                        )
#define T3D _EQ(                           F3                        )
#define T3E _EQ(                           F4                        )
#define T3F _EQ(                           F5                        )
#define T40 _EQ(                           F6                        )
#define T41 _EQ(                           F7                        )
#define T42 _EQ(                           F8                        )
#define T43 _EQ(                           F9                        )
#define T44 _EQ(                           F10                       )
#define T45 _EQ(                           NUMLOCK                   )
#define T46 _EQ(                           OEM_SCROLL                )
#define T47 _EQ(                           HOME                      )
#define T48 _EQ(                           UP                        )
#define T49 _EQ(                           PRIOR                     )
#define T4A _EQ(                           SUBTRACT                  )
#define T4B _EQ(                           LEFT                      )
#define T4C _EQ(                           CLEAR                     )
#define T4D _EQ(                           RIGHT                     )
#define T4E _EQ(                           ADD                       )
#define T4F _EQ(                           END                       )
#define T50 _EQ(                           DOWN                      )
#define T51 _EQ(                           NEXT                      )
#define T52 _EQ(                           INSERT                    )
#define T53 _EQ(                           DELETE                    )
#define T54 _EQ(                           SNAPSHOT                  )
#define T55 _EQ(                           _none_                    ) // KB3270 => DOWN
#define T56 _NE(OEM_102, HELP,    OEM_102, OEM_102, _none_,  OEM_PA2 ) // KB3270 => LEFT
#define T57 _NE(F11,     RETURN,  F11,     F11,     _none_,  HELP    ) // KB3270 => ZOOM
#define T58 _NE(F12,     LEFT,    F12,     F12,     _none_,  OEM_102 ) // KB3270 => HELP
#define T59 _EQ(                           CLEAR                     )
#define T5A _EQ(                           OEM_WSCTRL                )// WSCtrl
#define T5B _EQ(                           OEM_FINISH                )// Finish
#define T5C _EQ(                           OEM_JUMP                  )// Jump
#define T5D _EQ(                           EREOF                     )
#define T5E _EQ(                           OEM_BACKTAB               ) // KB3270 <= 7E
#define T5F _EQ(                           OEM_AUTO                  ) // KB3270
#define T60 _EQ(                           _none_                    )
#define T61 _EQ(                           _none_                    )
#define T62 _EQ(                           ZOOM                      ) // KB3270 <= 57
#define T63 _EQ(                           HELP                      ) // KB3270 <= 58
#define T64 _EQ(                           F13                       )
#define T65 _EQ(                           F14                       )
#define T66 _EQ(                           F15                       )
#define T67 _EQ(                           F16                       )
#define T68 _EQ(                           F17                       )
#define T69 _EQ(                           F18                       )
#define T6A _EQ(                           F19                       )
#define T6B _EQ(                           F20                       )
#define T6C _EQ(                           F21                       )
#define T6D _EQ(                           F22                       )
#define T6E _EQ(                           F23                       )
#define T6F _EQ(                           OEM_PA3                   ) // KB3270
#define T70 _EQ(                           _none_                    )
#define T71 _EQ(                           OEM_RESET                 ) // KB3270
#define T72 _EQ(                           _none_                    )
#define T73 _EQ(                           ABNT_C1                   )
#define T74 _EQ(                           _none_                    )
#define T75 _EQ(                           _none_                    ) // KB3270 => RETURN
#define T76 _EQ(                           F24                       )
#define T77 _EQ(                           _none_                    ) // KB3270 => HOME
#define T78 _EQ(                           _none_                    ) // KB3270 => UP
#define T79 _EQ(                           _none_                    ) // KB3270 => DELETE
#define T7A _EQ(                           _none_                    ) // KB3270 => INSERT
#define T7B _EQ(                           OEM_PA1                   ) // KB3270
#define T7C _EQ(                           TAB                       ) // KB3270 => TAB
#define T7D _EQ(                           _none_                    ) // KB3270 => RIGHT
#define T7E _EQ(                           ABNT_C2                   ) // KB3270 => BACKTAB
#define T7F _EQ(                           OEM_PA2                   ) // KB3270

#define X1C _EQ(                           RETURN                    )
#define X1D _EQ(                           RCONTROL                  )
#define X35 _EQ(                           DIVIDE                    )
#define X37 _EQ(                           SNAPSHOT                  )
#define X38 _EQ(                           RMENU                     )
#define X46 _EQ(                           CANCEL                    )
#define X47 _EQ(                           HOME                      )
#define X48 _EQ(                           UP                        )
#define X49 _EQ(                           PRIOR                     )
#define X4B _EQ(                           LEFT                      )
#define X4D _EQ(                           RIGHT                     )
#define X4F _EQ(                           END                       )
#define X50 _EQ(                           DOWN                      )
#define X51 _NE(NEXT,    F1,      NEXT,    NEXT,    _none_, OEM_PA2  )
#define X52 _EQ(                           INSERT                    )
#define X53 _EQ(                           DELETE                    )
#define X5B _EQ(                           LWIN                      )
#define X5C _EQ(                           RWIN                      )
#define X5D _EQ(                           APPS                      )
#define X5E _EQ(                           POWER                     )
#define X5F _EQ(                           SLEEP                     )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(                           PAUSE                     )

#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
/***********************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*    7       Japanese IBM type 002 keyboard.
*    8 *     Japanese OADG (106) keyboard.
*   10       Korean 101 (type A) keyboard.
*   11       Korean 101 (type B) keyboard.
*   12       Korean 101 (type C) keyboard.
*   13       Korean 103 keyboard.
*   16       Japanese AX keyboard.
*
*     +------+ +----------+----------+----------+----------+----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |
*     | code | |  type 7  |  type 8  |  type 16 |  type 10 |  type 11 |  type 12 |  type 13 |
\****+-------+-+----------+----------+----------+----------+----------+----------+----------+*/
#define T00 _EQ(           _none_                                                           )
#define T01 _EQ(           ESCAPE                                                           )
#define T02 _EQ(           '1'                                                              )
#define T03 _EQ(           '2'                                                              )
#define T04 _EQ(           '3'                                                              )
#define T05 _EQ(           '4'                                                              )
#define T06 _EQ(           '5'                                                              )
#define T07 _EQ(           '6'                                                              )
#define T08 _EQ(           '7'                                                              )
#define T09 _EQ(           '8'                                                              )
#define T0A _EQ(           '9'                                                              )
#define T0B _EQ(           '0'                                                              )
#define T0C _EQ(           OEM_MINUS                                                        )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS  )
#define T0E _EQ(           BACK                                                             )
#define T0F _EQ(           TAB                                                              )
#define T10 _EQ(           'Q'                                                              )
#define T11 _EQ(           'W'                                                              )
#define T12 _EQ(           'E'                                                              )
#define T13 _EQ(           'R'                                                              )
#define T14 _EQ(           'T'                                                              )
#define T15 _EQ(           'Y'                                                              )
#define T16 _EQ(           'U'                                                              )
#define T17 _EQ(           'I'                                                              )
#define T18 _EQ(           'O'                                                              )
#define T19 _EQ(           'P'                                                              )
#define T1A _NE(OEM_4,     OEM_3,     OEM_4,     OEM_4,     OEM_4,     OEM_4,     OEM_4     )
#define T1B _NE(OEM_6,     OEM_4,     OEM_6,     OEM_6,     OEM_6,     OEM_6,     OEM_6     )
#define T1C _EQ(           RETURN                                                           )
#define T1D _EQ(           LCONTROL                                                         )
#define T1E _EQ(           'A'                                                              )
#define T1F _EQ(           'S'                                                              )
#define T20 _EQ(           'D'                                                              )
#define T21 _EQ(           'F'                                                              )
#define T22 _EQ(           'G'                                                              )
#define T23 _EQ(           'H'                                                              )
#define T24 _EQ(           'J'                                                              )
#define T25 _EQ(           'K'                                                              )
#define T26 _EQ(           'L'                                                              )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1,     OEM_1,     OEM_1,     OEM_1,     OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7,     OEM_7,     OEM_7,     OEM_7,     OEM_7     )
#define T29 _NE(OEM_3,     DBE_SBCSCHAR,OEM_3,   OEM_3,     OEM_3,     OEM_3,     OEM_3     )
#define T2A _EQ(           LSHIFT                                                           )
#define T2B _NE(OEM_5,     OEM_6,     OEM_5,     OEM_5,     OEM_5,     OEM_5,     OEM_5     )
#define T2C _EQ(           'Z'                                                              )
#define T2D _EQ(           'X'                                                              )
#define T2E _EQ(           'C'                                                              )
#define T2F _EQ(           'V'                                                              )
#define T30 _EQ(           'B'                                                              )
#define T31 _EQ(           'N'                                                              )
#define T32 _EQ(           'M'                                                              )
#define T33 _EQ(           OEM_COMMA                                                        )
#define T34 _EQ(           OEM_PERIOD                                                       )
#define T35 _EQ(           OEM_2                                                            )
#define T36 _EQ(           RSHIFT                                                           )
#define T37 _EQ(           MULTIPLY                                                         )
#define T38 _EQ(           LMENU                                                            )
#define T39 _EQ(           ' '                                                              )
#define T3A _NE(DBE_ALPHANUMERIC,DBE_ALPHANUMERIC,CAPITAL,CAPITAL,CAPITAL,CAPITAL,CAPITAL   )
#define T3B _EQ(           F1                                                               )
#define T3C _EQ(           F2                                                               )
#define T3D _EQ(           F3                                                               )
#define T3E _EQ(           F4                                                               )
#define T3F _EQ(           F5                                                               )
#define T40 _EQ(           F6                                                               )
#define T41 _EQ(           F7                                                               )
#define T42 _EQ(           F8                                                               )
#define T43 _EQ(           F9                                                               )
#define T44 _EQ(           F10                                                              )
#define T45 _EQ(           NUMLOCK                                                          )
#define T46 _EQ(           OEM_SCROLL                                                       )
#define T47 _EQ(           HOME                                                             )
#define T48 _EQ(           UP                                                               )
#define T49 _EQ(           PRIOR                                                            )
#define T4A _EQ(           SUBTRACT                                                         )
#define T4B _EQ(           LEFT                                                             )
#define T4C _EQ(           CLEAR                                                            )
#define T4D _EQ(           RIGHT                                                            )
#define T4E _EQ(           ADD                                                              )
#define T4F _EQ(           END                                                              )
#define T50 _EQ(           DOWN                                                             )
#define T51 _EQ(           NEXT                                                             )
#define T52 _EQ(           INSERT                                                           )
#define T53 _EQ(           DELETE                                                           )
#define T54 _EQ(           SNAPSHOT                                                         )
#define T55 _EQ(           _none_                                                           )
#define T56 _NE(_none_,    _none_,    OEM_102,   OEM_102,   OEM_102,   OEM_102,   OEM_102   )
#define T57 _EQ(           F11                                                              )
#define T58 _EQ(           F12                                                              )
#define T59 _EQ(           CLEAR                                                            )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL)
#define T5B _NE(NONAME,    NONAME,    CONVERT,   OEM_FINISH,OEM_FINISH,OEM_FINISH,OEM_FINISH)
#define T5C _NE(NONAME,    NONAME,    OEM_AX,    OEM_JUMP,  OEM_JUMP,  OEM_JUMP,  OEM_JUMP  )
#define T5D _EQ(           EREOF                                                            )
#define T5E _NE(_none_,    _none_,    _none_,    OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB)
#define T5F _NE(NONAME,    NONAME,    NONAME,    OEM_AUTO,  OEM_AUTO,  OEM_AUTO,  OEM_AUTO  )
#define T60 _EQ(           _none_                                                           )
#define T61 _NE(_none_,    _none_,    _none_,    ZOOM,      ZOOM,      ZOOM,      ZOOM      )
#define T62 _NE(_none_,    _none_,    _none_,    HELP,      HELP,      HELP,      HELP      )
#define T63 _EQ(           _none_                                                           )
#define T64 _EQ(           F13                                                              )
#define T65 _EQ(           F14                                                              )
#define T66 _EQ(           F15                                                              )
#define T67 _EQ(           F16                                                              )
#define T68 _EQ(           F17                                                              )
#define T69 _EQ(           F18                                                              )
#define T6A _EQ(           F19                                                              )
#define T6B _EQ(           F20                                                              )
#define T6C _EQ(           F21                                                              )
#define T6D _EQ(           F22                                                              )
#define T6E _EQ(           F23                                                              )
#define T6F _NE(_none_,    _none_,    _none_,    OEM_PA3,   OEM_PA3,   OEM_PA3,   OEM_PA3   )
#define T70 _NE(DBE_KATAKANA,DBE_HIRAGANA,_none_,_none_,    _none_,    _none_,    _none_    )
#define T71 _NE(_none_,    _none_,    _none_,    OEM_RESET, OEM_RESET, OEM_RESET, OEM_RESET )
#define T72 _EQ(           _none_                                                           )
#define T73 _NE(OEM_102,   OEM_102,   _none_,    ABNT_C1,   ABNT_C1,   ABNT_C1,   ABNT_C1   )
#define T74 _EQ(           _none_                                                           )
#define T75 _EQ(           _none_                                                           )
#define T76 _EQ(           F24                                                              )
#define T77 _NE(DBE_SBCSCHAR,_none_,  _none_,    _none_,    _none_,    _none_,    _none_    )
#define T78 _EQ(           _none_                                                           )
#define T79 _NE(CONVERT,   CONVERT,   _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7A _EQ(           _none_                                                           )
#define T7B _NE(NONCONVERT,NONCONVERT,_none_,    OEM_PA1,   OEM_PA1,   OEM_PA1,   OEM_PA1   )
#define T7C _EQ(           TAB                                                              )
#define T7D _NE(_none_,    OEM_5,     _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7E _EQ(           ABNT_C2                                                          )
#define T7F _EQ(           OEM_PA2                                                          )

#define X1C _EQ(           RETURN                                                           )
#define X1D _NE(RCONTROL,  RCONTROL,DBE_KATAKANA,HANJA,     HANGEUL,   RCONTROL,  RCONTROL  )
#define X33 _NE(OEM_8,     _none_,    _none_,    _none_,    _none_,    _none_,    _none_    )
#define X35 _EQ(           DIVIDE                                                           )
#define X37 _EQ(           SNAPSHOT                                                         )
#define X38 _NE(DBE_HIRAGANA,RMENU,   KANJI,     HANGEUL,   HANJA,     RMENU,     RMENU     )
#define X42 _EQ(           _none_                                                           )
#define X43 _EQ(           _none_                                                           )
#define X44 _EQ(           _none_                                                           )
#define X46 _EQ(           CANCEL                                                           )
#define X47 _EQ(           HOME                                                             )
#define X48 _EQ(           UP                                                               )
#define X49 _EQ(           PRIOR                                                            )
#define X4B _EQ(           LEFT                                                             )
#define X4D _EQ(           RIGHT                                                            )
#define X4F _EQ(           END                                                              )
#define X50 _EQ(           DOWN                                                             )
#define X51 _EQ(           NEXT                                                             )
#define X52 _EQ(           INSERT                                                           )
#define X53 _EQ(           DELETE                                                           )
#define X5B _EQ(           LWIN                                                             )
#define X5C _EQ(           RWIN                                                             )
#define X5D _EQ(           APPS                                                             )
#define X5E _EQ(           POWER                                                            )
#define X5F _EQ(           SLEEP                                                            )
#define XF1 _NE(_none_,    _none_,    _none_,    HANJA,     HANJA,     HANJA,     HANJA     )
#define XF2 _NE(_none_,    _none_,    _none_,    HANGEUL,   HANGEUL,   HANGEUL,   HANGEUL   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(           PAUSE                                                            )

#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   20       Fujitsu FMR JIS keyboard.
*   21       Fujitsu FMR OYAYUBI keyboard.
*   22 *     Fujitsu FMV OYAYUBI keyboard.
*
*     +------+ +----------+----------+----------+
*     | Scan | |  kbd     |  kbd     |  kbd     |
*     | code | | type 20  | type 21  | type 22  |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(                      _none_    )
#define T01 _EQ(                      ESCAPE    )
#define T02 _EQ(                      '1'       )
#define T03 _EQ(                      '2'       )
#define T04 _EQ(                      '3'       )
#define T05 _EQ(                      '4'       )
#define T06 _EQ(                      '5'       )
#define T07 _EQ(                      '6'       )
#define T08 _EQ(                      '7'       )
#define T09 _EQ(                      '8'       )
#define T0A _EQ(                      '9'       )
#define T0B _EQ(                      '0'       )
#define T0C _EQ(                      OEM_MINUS )
#define T0D _EQ(                      OEM_7     )
#define T0E _NE(OEM_5,     OEM_5,     BACK      )
#define T0F _NE(BACK,      BACK,      TAB       )
#define T10 _NE(TAB,       TAB,       'Q'       )
#define T11 _NE('Q',       'Q',       'W'       )
#define T12 _NE('W',       'W',       'E'       )
#define T13 _NE('E',       'E',       'R'       )
#define T14 _NE('R',       'R',       'T'       )
#define T15 _NE('T',       'T',       'Y'       )
#define T16 _NE('Y',       'Y',       'U'       )
#define T17 _NE('U',       'U',       'I'       )
#define T18 _NE('I',       'I',       'O'       )
#define T19 _NE('O',       'O',       'P'       )
#define T1A _NE('P',       'P',       OEM_3     )
#define T1B _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1C _NE(OEM_4,     OEM_4,     RETURN    )
#define T1D _NE(RETURN,    RETURN,    LCONTROL  )
#define T1E _EQ(                      'A'       )
#define T1F _EQ(                      'S'       )
#define T20 _EQ(                      'D'       )
#define T21 _EQ(                      'F'       )
#define T22 _EQ(                      'G'       )
#define T23 _EQ(                      'H'       )
#define T24 _EQ(                      'J'       )
#define T25 _EQ(                      'K'       )
#define T26 _EQ(                      'L'       )
#define T27 _EQ(                      OEM_PLUS  )
#define T28 _EQ(                      OEM_1     )
#define T29 _NE(OEM_6,     OEM_6,     DBE_SBCSCHAR)
#define T2A _NE('Z',       'Z',       LSHIFT    )
#define T2B _NE('X',       'X',       OEM_6     )
#define T2C _NE('C',       'C',       'Z'       )
#define T2D _NE('V',       'V',       'X'       )
#define T2E _NE('B',       'B',       'C'       )
#define T2F _NE('N',       'N',       'V'       )
#define T30 _NE('M',       'M',       'B'       )
#define T31 _NE(OEM_COMMA, OEM_COMMA, 'N'       )
#define T32 _NE(OEM_PERIOD,OEM_PERIOD,'M'       )
#define T33 _NE(OEM_2,     OEM_2,     OEM_COMMA )
#define T34 _NE(OEM_8,     OEM_8,     OEM_PERIOD)
#define T35 _NE(' ',       ' ',       OEM_2     )
#define T36 _NE(MULTIPLY,  MULTIPLY,  RSHIFT    )
#define T37 _NE(DIVIDE,    DIVIDE,    MULTIPLY  )
#define T38 _NE(ADD,       ADD,       LMENU     )
#define T39 _NE(SUBTRACT,  SUBTRACT,  ' '       )
#define T3A _NE(NUMPAD7,   NUMPAD7,   DBE_ALPHANUMERIC)
#define T3B _NE(NUMPAD8,   NUMPAD8,   F1        )
#define T3C _NE(NUMPAD9,   NUMPAD9,   F2        )
#define T3D _NE(EQUAL,     EQUAL,     F3        )
#define T3E _NE(NUMPAD4,   NUMPAD4,   F4        )
#define T3F _NE(NUMPAD5,   NUMPAD5,   F5        )
#define T40 _NE(NUMPAD6,   NUMPAD6,   F6        )
#define T41 _NE(SEPARATOR, SEPARATOR, F7        )
#define T42 _NE(NUMPAD1,   NUMPAD1,   F8        )
#define T43 _NE(NUMPAD2,   NUMPAD2,   F9        )
#define T44 _NE(NUMPAD3,   NUMPAD3,   F10       )
#define T45 _NE(RETURN,    RETURN,    NUMLOCK   )
#define T46 _NE(NUMPAD0,   NUMPAD0,   OEM_SCROLL)
#define T47 _NE(DECIMAL,   DECIMAL,   HOME      )
#define T48 _NE(INSERT,    INSERT,    UP        )
#define T49 _NE(OEM_00,    OEM_00,    PRIOR     )
#define T4A _NE(OEM_000,   OEM_000,   SUBTRACT  )
#define T4B _NE(DELETE,    DELETE,    LEFT      )
#define T4C _NE(_none_,    _none_,    CLEAR     )
#define T4D _NE(UP,        UP,        RIGHT     )
#define T4E _NE(HOME,      HOME,      ADD       )
#define T4F _NE(LEFT,      LEFT,      END       )
#define T50 _EQ(                      DOWN      )
#define T51 _NE(RIGHT,     RIGHT,     NEXT      )
#define T52 _NE(LCONTROL,  LCONTROL,  INSERT    )
#define T53 _NE(LSHIFT,    LSHIFT,    DELETE    )
#define T54 _NE(_none_,    _none_,    SNAPSHOT  )
#define T55 _NE(CAPITAL,   _none_,    _none_    )
#define T56 _NE(DBE_HIRAGANA,_none_,  _none_    )
#define T57 _NE(NONCONVERT,NONCONVERT,F11       )
#define T58 _NE(CONVERT,   CONVERT,   F12       )
#define T59 _NE(KANJI,     KANJI,     CLEAR     )
#define T5A _NE(DBE_KATAKANA,_none_,  NONAME    )
#define T5B _NE(F12,       F12,       NONAME    )
#define T5C _NE(LMENU,     LMENU,     NONAME    )
#define T5D _NE(F1,        F1,        EREOF     )
#define T5E _NE(F2,        F2,        _none_    )
#define T5F _NE(F3,        F3,        NONAME    )
#define T60 _NE(F4,        F4,        _none_    )
#define T61 _NE(F5,        F5,        _none_    )
#define T62 _NE(F6,        F6,        _none_    )
#define T63 _NE(F7,        F7,        _none_    )
#define T64 _NE(F8,        F8,        F13       )
#define T65 _NE(F9,        F9,        F14       )
#define T66 _NE(F10,       F10,       F15       )
#define T67 _NE(_none_,    OEM_LOYA,  F16       )
#define T68 _NE(_none_,    OEM_ROYA,  F17       )
#define T69 _NE(F11,       F11,       F18       )
#define T6A _NE(_none_,    DBE_ALPHANUMERIC,F19 )
#define T6B _NE(OEM_JISHO, OEM_JISHO, F20       )
#define T6C _NE(OEM_MASSHOU,OEM_MASSHOU,F21     )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(PRIOR,     PRIOR,     F23       )
#define T6F _NE(_none_,    DBE_KATAKANA,_none_  )
#define T70 _NE(NEXT,      NEXT,      DBE_HIRAGANA)
#define T71 _EQ(                      _none_    )
#define T72 _NE(CANCEL,    CANCEL,    _none_    )
#define T73 _NE(EXECUTE,   EXECUTE,   OEM_102   )
#define T74 _NE(F13,       F13,       _none_    )
#define T75 _NE(F14,       F14,       _none_    )
#define T76 _NE(F15,       F15,       F24       )
#define T77 _NE(F16,       F16,       _none_    )
#define T78 _NE(CLEAR,     CLEAR,     _none_    )
#define T79 _NE(HELP,      HELP,      CONVERT   )
#define T7A _NE(END,       END,       _none_    )
#define T7B _NE(OEM_SCROLL,OEM_SCROLL,NONCONVERT)
#define T7C _NE(PAUSE,     PAUSE,     TAB       )
#define T7D _NE(SNAPSHOT,  SNAPSHOT,  OEM_5     )
#define T7E _NE(_none_,    _none_,    ABNT_C2   )
#define T7F _NE(_none_,    _none_,    OEM_PA2   )

#define X1C _NE(_none_,    _none_,    RETURN    )
#define X1D _NE(_none_,    _none_,    RCONTROL  )
#define X33 _EQ(                      _none_    )
#define X35 _NE(_none_,    _none_,    DIVIDE    )
#define X37 _NE(_none_,    _none_,    SNAPSHOT  )
#define X38 _NE(_none_,    _none_,    RMENU     )
#define X42 _EQ(                      _none_    )
#define X43 _EQ(                      _none_    )
#define X44 _EQ(                      _none_    )
#define X46 _NE(_none_,    _none_,    CANCEL    )
#define X47 _NE(_none_,    _none_,    HOME      )
#define X48 _NE(_none_,    _none_,    UP        )
#define X49 _NE(_none_,    _none_,    PRIOR     )
#define X4B _NE(_none_,    _none_,    LEFT      )
#define X4D _NE(_none_,    _none_,    RIGHT     )
#define X4F _NE(_none_,    _none_,    END       )
#define X50 _NE(_none_,    _none_,    DOWN      )
#define X51 _NE(_none_,    _none_,    NEXT      )
#define X52 _NE(_none_,    _none_,    INSERT    )
#define X53 _NE(_none_,    _none_,    DELETE    )
#define X5B _NE(_none_,    _none_,    LWIN      )
#define X5C _NE(_none_,    _none_,    RWIN      )
#define X5D _NE(_none_,    _none_,    APPS      )
#define X5E _EQ(                      POWER     )
#define X5F _EQ(                      SLEEP     )
#define X60 _NE(OEM_SCROLL,OEM_SCROLL,_none_    )
#define X61 _NE(HOME,      HOME,      _none_    )
#define X62 _NE(END,       END,       _none_    )
#define X63 _EQ(                      _none_    )
#define X64 _EQ(                      _none_    )
#define X65 _EQ(                      _none_    )
#define X66 _EQ(                      _none_    )
#define X6D _NE(OEM_TOUROKU,OEM_TOUROKU,_none_  )
#define X71 _NE(DBE_SBCSCHAR,DBE_SBCSCHAR,_none_)
#define X74 _EQ(                      _none_    )
#define X75 _EQ(                      _none_    )
#define X76 _EQ(                      _none_    )
#define X77 _EQ(                      _none_    )
#define X78 _EQ(                      _none_    )
#define X79 _EQ(                      _none_    )
#define X7A _EQ(                      _none_    )
#define X7B _EQ(                      _none_    )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(              PAUSE             )

#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   30 *     NEC PC-9800 Normal Keyboard.
*   31       NEC PC-9800 Document processor Keyboard.  - not supported on NT5
*   32       NEC PC-9800 106 Keyboard. - same as KBD_TYPE 8
*   33       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 5.0.
*            NEC PC-98NX for Hydra: PC-9800 Keyboard on Windows 95/NT.
*   34       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 3.51/4.0.
*
*     +------+ +----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |
*     | code | |  type 30 |  type 33 |  type 34 |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(_none_                          )
#define T01 _EQ(ESCAPE                          )
#define T02 _EQ('1'                             )
#define T03 _EQ('2'                             )
#define T04 _EQ('3'                             )
#define T05 _EQ('4'                             )
#define T06 _EQ('5'                             )
#define T07 _EQ('6'                             )
#define T08 _EQ('7'                             )
#define T09 _EQ('8'                             )
#define T0A _EQ('9'                             )
#define T0B _EQ('0'                             )
#define T0C _EQ(OEM_MINUS                       )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS  )
#define T0E _EQ(BACK                            )
#define T0F _EQ(TAB                             )
#define T10 _EQ('Q'                             )
#define T11 _EQ('W'                             )
#define T12 _EQ('E'                             )
#define T13 _EQ('R'                             )
#define T14 _EQ('T'                             )
#define T15 _EQ('Y'                             )
#define T16 _EQ('U'                             )
#define T17 _EQ('I'                             )
#define T18 _EQ('O'                             )
#define T19 _EQ('P'                             )
#define T1A _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1B _NE(OEM_4,     OEM_4,     OEM_6     )
#define T1C _EQ(RETURN                          )
#define T1D _EQ(LCONTROL                        )
#define T1E _EQ('A'                             )
#define T1F _EQ('S'                             )
#define T20 _EQ('D'                             )
#define T21 _EQ('F'                             )
#define T22 _EQ('G'                             )
#define T23 _EQ('H'                             )
#define T24 _EQ('J'                             )
#define T25 _EQ('K'                             )
#define T26 _EQ('L'                             )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7     )
#define T29 _NE(DBE_SBCSCHAR, \
                           DBE_SBCSCHAR, \
                                      OEM_3     )
#define T2A _EQ(LSHIFT                          )
#define T2B _NE(OEM_6,     OEM_6,     OEM_5     )
#define T2C _EQ('Z'                             )
#define T2D _EQ('X'                             )
#define T2E _EQ('C'                             )
#define T2F _EQ('V'                             )
#define T30 _EQ('B'                             )
#define T31 _EQ('N'                             )
#define T32 _EQ('M'                             )
#define T33 _EQ(OEM_COMMA                       )
#define T34 _EQ(OEM_PERIOD                      )
#define T35 _EQ(OEM_2                           )
#define T36 _EQ(RSHIFT                          )
#define T37 _EQ(MULTIPLY                        )
#define T38 _EQ(LMENU                           )
#define T39 _EQ(' '                             )
#define T3A _EQ(CAPITAL                         )
#define T3B _EQ(F1                              )
#define T3C _EQ(F2                              )
#define T3D _EQ(F3                              )
#define T3E _EQ(F4                              )
#define T3F _EQ(F5                              )
#define T40 _EQ(F6                              )
#define T41 _EQ(F7                              )
#define T42 _EQ(F8                              )
#define T43 _EQ(F9                              )
#define T44 _EQ(F10                             )
#define T45 _EQ(NUMLOCK                         )
#define T46 _EQ(OEM_SCROLL                      )
#define T47 _NE(NUMPAD7,   NUMPAD7,   HOME      )
#define T48 _NE(NUMPAD8,   NUMPAD8,   UP        )
#define T49 _NE(NUMPAD9,   NUMPAD9,   PRIOR     )
#define T4A _EQ(SUBTRACT                        )
#define T4B _NE(NUMPAD4,   NUMPAD4,   LEFT      )
#define T4C _NE(NUMPAD5,   NUMPAD5,   CLEAR     )
#define T4D _NE(NUMPAD6,   NUMPAD6,   RIGHT     )
#define T4E _EQ(ADD                             )
#define T4F _NE(NUMPAD1,   NUMPAD1,   END       )
#define T50 _NE(NUMPAD2,   NUMPAD2,   DOWN      )
#define T51 _NE(NUMPAD3,   NUMPAD3,   NEXT      )
#define T52 _NE(NUMPAD0,   NUMPAD0,   INSERT    )
#define T53 _NE(DECIMAL,   DECIMAL,   DELETE    )
#define T54 _EQ(SNAPSHOT                        )
#define T55 _NE(_none_,    _none_,    OEM_8     )
#define T56 _EQ(_none_                          )
#define T57 _EQ(F11                             )
#define T58 _EQ(F12                             )
#define T59 _EQ(OEM_NEC_EQUAL                   )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT)
#define T5B _NE(_none_,    _none_,    NONAME    )
#define T5C _EQ(OEM_NEC_SEPARATE                )
#define T5D _EQ(F13                             )
#define T5E _EQ(F14                             )
#define T5F _EQ(F15                             )
#define T60 _EQ(_none_                          )
#define T61 _EQ(_none_                          )
#define T62 _EQ(_none_                          )
#define T63 _EQ(_none_                          )
#define T64 _NE(_none_,    _none_,    F13       )
#define T65 _NE(_none_,    _none_,    F14       )
#define T66 _NE(_none_,    _none_,    F15       )
#define T67 _NE(_none_,    _none_,    F16       )
#define T68 _NE(_none_,    _none_,    F17       )
#define T69 _NE(_none_,    _none_,    F18       )
#define T6A _NE(_none_,    _none_,    F19       )
#define T6B _NE(_none_,    _none_,    F20       )
#define T6C _NE(_none_,    _none_,    F21       )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(_none_,    _none_,    F23       )
#define T6F _EQ(_none_                          )
#define T70 _NE(KANA,      KANA,      DBE_HIRAGANA)
#define T71 _EQ(_none_                          )
#define T72 _EQ(_none_                          )
#define T73 _NE(OEM_8,     OEM_8,     _none_    )
#define T74 _NE(_none_,    OEM_NEC_EQUAL, \
                                      _none_    )
#define T75 _NE(_none_,    OEM_NEC_SEPARATE, \
                                      _none_    )
#define T76 _NE(_none_,    _none_,    F24       )
#define T77 _NE(_none_,    _none_,    DBE_SBCSCHAR)
#define T78 _EQ(_none_                          )
#define T79 _EQ(CONVERT                         )
#define T7A _EQ(_none_                          )
#define T7B _EQ(NONCONVERT                      )
#define T7C _NE(TAB,       _none_,    _none_    )
#define T7D _NE(OEM_5,     OEM_5,     _none_    )
#define T7E _NE(ABNT_C2,   ABNT_C2,   _none_    )
#define T7F _NE(OEM_PA2,   OEM_PA2,   _none_    )

#define X1C _EQ(RETURN                          )
#define X1D _NE(RCONTROL,  RCONTROL,  KANA      )
#define X33 _EQ(_none_                          )
#define X35 _EQ(DIVIDE                          )
#define X37 _EQ(SNAPSHOT                        )
#define X38 _NE(_none_,    _none_,    KANJI     )
#define X42 _NE(_none_,    _none_,    RCONTROL  )
#define X43 _NE(_none_,    _none_,    RMENU     )
#define X44 _EQ(_none_                          )
#define X46 _EQ(CANCEL                          )
#define X47 _EQ(HOME                            )
#define X48 _EQ(UP                              )
#define X49 _EQ(PRIOR                           )
#define X4B _EQ(LEFT                            )
#define X4D _EQ(RIGHT                           )
#define X4F _EQ(END                             )
#define X50 _EQ(DOWN                            )
#define X51 _EQ(NEXT                            )
#define X52 _EQ(INSERT                          )
#define X53 _EQ(DELETE                          )
#define X5B _EQ(LWIN                            )
#define X5C _EQ(RWIN                            )
#define X5D _EQ(APPS                            )
#define X5E _EQ(POWER                           )
#define X5F _EQ(SLEEP                           )
#define X60 _EQ(_none_                          )
#define X61 _EQ(_none_                          )
#define X62 _EQ(_none_                          )
#define X63 _EQ(_none_                          )
#define X64 _EQ(_none_                          )
#define X65 _EQ(_none_                          )
#define X66 _EQ(_none_                          )
#define X6D _EQ(_none_                          )
#define X71 _EQ(_none_                          )
#define X74 _EQ(_none_                          )
#define X75 _EQ(_none_                          )
#define X76 _EQ(_none_                          )
#define X77 _EQ(_none_                          )
#define X78 _EQ(_none_                          )
#define X79 _EQ(_none_                          )
#define X7A _EQ(_none_                          )
#define X7B _EQ(_none_                          )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE                          )

#elif (KBD_TYPE == 37)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   37 *     NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows 95.
*
*     +------+ +----------+
*     | Scan | |   kbd    |
*     | code | |  type 37 |
\****+-------+-+----------+*********************************************/
#define T00 _EQ(ESCAPE    )
#define T01 _EQ('1'       )
#define T02 _EQ('2'       )
#define T03 _EQ('3'       )
#define T04 _EQ('4'       )
#define T05 _EQ('5'       )
#define T06 _EQ('6'       )
#define T07 _EQ('7'       )
#define T08 _EQ('8'       )
#define T09 _EQ('9'       )
#define T0A _EQ('0'       )
#define T0B _EQ(OEM_MINUS )
#define T0C _EQ(OEM_7     )
#define T0D _EQ(OEM_5     )
#define T0E _EQ(BACK      )
#define T0F _EQ(TAB       )
#define T10 _EQ('Q'       )
#define T11 _EQ('W'       )
#define T12 _EQ('E'       )
#define T13 _EQ('R'       )
#define T14 _EQ('T'       )
#define T15 _EQ('Y'       )
#define T16 _EQ('U'       )
#define T17 _EQ('I'       )
#define T18 _EQ('O'       )
#define T19 _EQ('P'       )
#define T1A _EQ(OEM_3     )
#define T1B _EQ(OEM_4     )
#define T1C _EQ(RETURN    )
#define T1D _EQ('A'       )
#define T1E _EQ('S'       )
#define T1F _EQ('D'       )
#define T20 _EQ('F'       )
#define T21 _EQ('G'       )
#define T22 _EQ('H'       )
#define T23 _EQ('J'       )
#define T24 _EQ('K'       )
#define T25 _EQ('L'       )
#define T26 _EQ(OEM_PLUS  )
#define T27 _EQ(OEM_1     )
#define T28 _EQ(OEM_6     )
#define T29 _EQ('Z'       )
#define T2A _EQ('X'       )
#define T2B _EQ('C'       )
#define T2C _EQ('V'       )
#define T2D _EQ('B'       )
#define T2E _EQ('N'       )
#define T2F _EQ('M'       )
#define T30 _EQ(OEM_COMMA )
#define T31 _EQ(OEM_PERIOD)
#define T32 _EQ(OEM_2     )
#define T33 _EQ(OEM_8     )
#define T34 _EQ(' '       )
#define T35 _EQ(CONVERT   )
#define T36 _EQ(NEXT      )
#define T37 _EQ(PRIOR     )
#define T38 _EQ(INSERT    )
#define T39 _EQ(DELETE    )
#define T3A _EQ(UP        )
#define T3B _EQ(LEFT      )
#define T3C _EQ(RIGHT     )
#define T3D _EQ(DOWN      )
#define T3E _EQ(HOME      )
#define T3F _EQ(END       )
#define T40 _EQ(SUBTRACT  )
#define T41 _EQ(DIVIDE    )
#define T42 _EQ(NUMPAD7   )
#define T43 _EQ(NUMPAD8   )
#define T44 _EQ(NUMPAD9   )
#define T45 _EQ(MULTIPLY  )
#define T46 _EQ(NUMPAD4   )
#define T47 _EQ(NUMPAD5   )
#define T48 _EQ(NUMPAD6   )
#define T49 _EQ(ADD       )
#define T4A _EQ(NUMPAD1   )
#define T4B _EQ(NUMPAD2   )
#define T4C _EQ(NUMPAD3   )
#define T4D _EQ(OEM_NEC_EQUAL)
#define T4E _EQ(NUMPAD0   )
#define T4F _EQ(OEM_NEC_SEPARATE)
#define T50 _EQ(DECIMAL   )
#define T51 _EQ(NONCONVERT)
#define T52 _EQ(F11       )
#define T53 _EQ(F12       )
#define T54 _EQ(F13       )
#define T55 _EQ(F14       )
#define T56 _EQ(F15       )
#define T57 _EQ(_none_    )
#define T58 _EQ(_none_    )
#define T59 _EQ(_none_    )
#define T5A _EQ(_none_    )
#define T5B _EQ(_none_    )
#define T5C _EQ(RETURN    )
#define T5D _EQ(_none_    )
#define T5E _EQ(_none_    )
#define T5F _EQ(_none_    )
#define T60 _EQ(CANCEL    )
#define T61 _EQ(SNAPSHOT  )
#define T62 _EQ(F1        )
#define T63 _EQ(F2        )
#define T64 _EQ(F3        )
#define T65 _EQ(F4        )
#define T66 _EQ(F5        )
#define T67 _EQ(F6        )
#define T68 _EQ(F7        )
#define T69 _EQ(F8        )
#define T6A _EQ(F9        )
#define T6B _EQ(F10       )
#define T6C _EQ(_none_    )
#define T6D _EQ(_none_    )
#define T6E _EQ(_none_    )
#define T6F _EQ(_none_    )
#define T70 _EQ(LSHIFT    )
#define T71 _EQ(CAPITAL   )
#define T72 _EQ(KANA      )
#define T73 _EQ(LMENU     )
#define T74 _EQ(LCONTROL  )
#define T75 _EQ(_none_    )
#define T76 _EQ(_none_    )
#define T77 _EQ(LWIN      )
#define T78 _EQ(RWIN      )
#define T79 _EQ(APPS      )
#define T7A _EQ(_none_    )
#define T7B _EQ(_none_    )
#define T7C _EQ(_none_    )
#define T7D _EQ(RSHIFT    )
#define T7E _EQ(ABNT_C2   )
#define T7F _EQ(OEM_PA2   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must conevrt the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE    )

#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Two sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   40 *     DEC LK411-JJ (JIS  layout) keyboard
*   41       DEC LK411-AJ (ANSI layout) keyboard
*
*     +------+ +-----------+-----------+
*     | Scan | |    kbd    |    kbd    |
*     | code | |  LK411-JJ |  LK411-AJ |
\*****+------+-+-----------+-----------+********************************/
#define T00 _EQ(        _none_            )
#define T01 _EQ(        ESCAPE            )
#define T02 _EQ(        '1'               )
#define T03 _EQ(        '2'               )
#define T04 _EQ(        '3'               )
#define T05 _EQ(        '4'               )
#define T06 _EQ(        '5'               )
#define T07 _EQ(        '6'               )
#define T08 _EQ(        '7'               )
#define T09 _EQ(        '8'               )
#define T0A _EQ(        '9'               )
#define T0B _EQ(        '0'               )
#define T0C _EQ(        OEM_MINUS         )
#define T0D _NE( OEM_7,      OEM_PLUS     ) // "^"/"="
#define T0E _EQ(        BACK              )
#define T0F _EQ(        TAB               )
#define T10 _EQ(        'Q'               )
#define T11 _EQ(        'W'               )
#define T12 _EQ(        'E'               )
#define T13 _EQ(        'R'               )
#define T14 _EQ(        'T'               )
#define T15 _EQ(        'Y'               )
#define T16 _EQ(        'U'               )
#define T17 _EQ(        'I'               )
#define T18 _EQ(        'O'               )
#define T19 _EQ(        'P'               )
#define T1A _NE( OEM_3,      OEM_4        ) // "@"/"["
#define T1B _NE( OEM_4,      OEM_6        ) // "["/"]"
#define T1C _EQ(        RETURN            )
#define T1D _EQ(        LCONTROL          )
#define T1E _EQ(        'A'               )
#define T1F _EQ(        'S'               )
#define T20 _EQ(        'D'               )
#define T21 _EQ(        'F'               )
#define T22 _EQ(        'G'               )
#define T23 _EQ(        'H'               )
#define T24 _EQ(        'J'               )
#define T25 _EQ(        'K'               )
#define T26 _EQ(        'L'               )
#define T27 _NE( OEM_PLUS,   OEM_1        ) // ";"
#define T28 _NE( OEM_1,      OEM_7        ) // ":"/"'"
#define T29 _NE( _none_,     DBE_SBCSCHAR ) // LK411AJ uses "<>" as SBCS/DBCS key
#define T2A _EQ(        LSHIFT            )
#define T2B _NE( OEM_6,      OEM_5        ) // "]"/"\"
#define T2C _EQ(        'Z'               )
#define T2D _EQ(        'X'               )
#define T2E _EQ(        'C'               )
#define T2F _EQ(        'V'               )
#define T30 _EQ(        'B'               )
#define T31 _EQ(        'N'               )
#define T32 _EQ(        'M'               )
#define T33 _EQ(        OEM_COMMA         )
#define T34 _EQ(        OEM_PERIOD        )
#define T35 _EQ(        OEM_2             ) // "/"
#define T36 _EQ(        RSHIFT            )
#define T37 _EQ(        MULTIPLY          ) // PF3 : "*"
#define T38 _EQ(        LMENU             ) // Alt(Left)
#define T39 _EQ(        ' '               ) // Space
#define T3A _EQ(        CAPITAL           ) // LOCK : Caps Lock
#define T3B _EQ(        F1                )
#define T3C _EQ(        F2                )
#define T3D _EQ(        F3                )
#define T3E _EQ(        F4                )
#define T3F _EQ(        F5                )
#define T40 _EQ(        F6                )
#define T41 _EQ(        F7                )
#define T42 _EQ(        F8                )
#define T43 _EQ(        F9                )
#define T44 _EQ(        F10               )
#define T45 _EQ(        NUMLOCK           ) // PF1 : Num Lock
#define T46 _EQ(        OEM_SCROLL        ) // F19 : Scroll Lock
#define T47 _EQ(        HOME              ) // KP7 : Home
#define T48 _EQ(        UP                ) // KP8 : Up
#define T49 _EQ(        PRIOR             ) // KP9 : Page Up
#define T4A _EQ(        SUBTRACT          ) // PF4 : "-"
#define T4B _EQ(        LEFT              ) // KP4 : Left
#define T4C _EQ(        CLEAR             ) // KP5 : Clear
#define T4D _EQ(        RIGHT             ) // KP6 : Right
#define T4E _EQ(        ADD               ) // KP, : Add
#define T4F _EQ(        END               ) // KP1 : End
#define T50 _EQ(        DOWN              ) // KP2 : Down
#define T51 _EQ(        NEXT              ) // KP3 : Next
#define T52 _EQ(        INSERT            ) // KP0 : Ins
#define T53 _EQ(        DELETE            ) // KP. : Del
#define T54 _EQ(        SNAPSHOT          )
#define T55 _EQ(        _none_            )
#define T56 _EQ(        _none_            )
#define T57 _EQ(        F11               )
#define T58 _EQ(        F12               )
#define T59 _EQ(        _none_            )
#define T5A _EQ(        _none_            )
#define T5B _EQ(        _none_            )
#define T5C _EQ(        _none_            )
#define T5D _EQ(        _none_            )
#define T5E _EQ(        _none_            )
#define T5F _EQ(        _none_            )
#define T60 _EQ(        _none_            )
#define T61 _EQ(        _none_            )
#define T62 _EQ(        _none_            )
#define T63 _EQ(        _none_            )
#define T64 _EQ(        _none_            )
#define T65 _EQ(        _none_            )
#define T66 _EQ(        _none_            )
#define T67 _EQ(        _none_            )
#define T68 _EQ(        _none_            )
#define T69 _EQ(        _none_            )
#define T6A _EQ(        _none_            )
#define T6B _EQ(        _none_            )
#define T6C _EQ(        _none_            )
#define T6D _EQ(        _none_            )
#define T6E _EQ(        _none_            )
#define T6F _EQ(        _none_            )
#define T70 _EQ(       DBE_HIRAGANA       ) // Hiragana/Katakana
#define T71 _EQ(        _none_            )
#define T72 _EQ(        _none_            )
#define T73 _NE( OEM_102,     _none_      ) // LK411JJ, Katakana "Ro"
#define T74 _EQ(        _none_            )
#define T75 _EQ(        _none_            )
#define T76 _EQ(        _none_            )
#define T77 _EQ(        _none_            )
#define T78 _EQ(        _none_            )
#define T79 _EQ(        CONVERT           ) // Henkan
#define T7A _EQ(        _none_            )
#define T7B _EQ(        NONCONVERT        ) // Mu-Henkan
#define T7C _EQ(        _none_            )
#define T7D _NE( OEM_5,       _none_      ) // LK411JJ, Yen(Back-slash)
#define T7E _EQ(        _none_            )
#define T7F _EQ(        _none_            )

#define X0F _EQ(        KANA              ) // Kana
#define X1C _EQ(        RETURN            ) // Enter
#define X1D _EQ(        RCONTROL          ) // Comp : Right Control
#define X33 _EQ(        _none_            )
#define X35 _EQ(        DIVIDE            ) // PF2: "/"
#define X37 _EQ(        SNAPSHOT          ) // F18: PrintScreen
#define X38 _EQ(        RMENU             ) // Alt(Right)
#define X3D _EQ(        F13               )
#define X3E _EQ(        F14               )
#define X3F _EQ(        F15               ) // Help : F15
#define X40 _EQ(        F16               ) // Do :   F16
#define X41 _EQ(        F17               )
#define X42 _EQ(        _none_            )
#define X43 _EQ(        _none_            )
#define X44 _EQ(        _none_            )
#define X46 _EQ(        CANCEL            )
#define X47 _EQ(        HOME              ) // Find : HOME
#define X48 _EQ(        UP                )
#define X49 _EQ(        PRIOR             ) // Prev : PageUp
#define X4B _EQ(        LEFT              )
#define X4D _EQ(        RIGHT             )
#define X4E _EQ(        ADD               ) // KP- (Minus but "Add")
#define X4F _EQ(        END               ) // Select : END
#define X50 _EQ(        DOWN              )
#define X51 _EQ(        NEXT              ) // Next : PageDown
#define X52 _EQ(        INSERT            )
#define X53 _EQ(        DELETE            ) // Remove
#define X5B _EQ(        _none_            )
#define X5C _EQ(        _none_            )
#define X5D _EQ(        _none_            )
#define X5E _EQ(        POWER             )
#define X5F _EQ(        SLEEP             )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(        PAUSE             )

#endif // KBD_TYPE

#define SCANCODE_LSHIFT      0x2A
#define SCANCODE_RSHIFT      0x36
#define SCANCODE_CTRL        0x1D
#define SCANCODE_ALT         0x38
#define SCANCODE_SIMULATED   (FAKE_KEYSTROKE >> 16)

#define SCANCODE_NUMPAD_FIRST 0x47
#define SCANCODE_NUMPAD_LAST  0x52

#define SCANCODE_LWIN         0x5B
#define SCANCODE_RWIN         0x5C

#define SCANCODE_THAI_LAYOUT_TOGGLE 0x29

/*
 * Hydra FarEast
 */

/*
 * Structure for client keyboard information
 */
typedef struct _CLIENTKEYBOARDTYPE {
    ULONG Type;
    ULONG SubType;
    ULONG FunctionKey;
} CLIENTKEYBOARDTYPE, *PCLIENTKEYBOARDTYPE;


#endif // _KBD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nschdata.c ===
/****************************************************************************/
/* nschdata.c                                                               */
/*                                                                          */
/* RDP Scheduler global data                                                */
/*                                                                          */
/* Copyright (c) 1996-1999 Microsoft Corp.                                  */
/****************************************************************************/

#include <ndcgdata.h>


DC_DATA(UINT32,  schCurrentMode, SCH_MODE_ASLEEP);
DC_DATA(BOOLEAN, schInputKickMode, FALSE);

// Avoid branches by using a table for setting the period.
DC_DATA_ARRAY_NULL(UINT32, schPeriods, 3, NULL);

DC_DATA(UINT32,  schTurboModeDuration,   0);
DC_DATA(UINT32,  schLastTurboModeSwitch, 0);
DC_DATA(BOOLEAN, schInTTDS,              FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nwdwapi.c ===
/****************************************************************************/
// nwdwapi.c
//
// RDPWD general header
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define pTRCWd pTSWd
#define TRC_FILE "nwdwapi"

#include <adcg.h>

#include <nwdwapi.h>
#include <nwdwioct.h>
#include <nwdwint.h>
#include <aschapi.h>
#include <anmapi.h>
#include <asmapi.h>
#include <asmint.h>

#include <mcsioctl.h>
#include <tsrvexp.h>
#include "domain.h"


/****************************************************************************/
/* Name:      DriverEntry                                                   */
/*                                                                          */
/* Purpose:   Default driver entry point                                    */
/*                                                                          */
/* Returns:   NTSTATUS value.                                               */
/*                                                                          */
/* Params:    INOUT  pContext  - Pointer to the SD context structure        */
/*            IN     fLoad     - TRUE:  load driver                         */
/*                               FALSE: unload driver                       */
/****************************************************************************/
#ifdef _HYDRA_
const PWCHAR ModuleName = L"rdpwd";
NTSTATUS ModuleEntry(PSDCONTEXT pContext, BOOLEAN fLoad)
#else
NTSTATUS DriverEntry(PSDCONTEXT pContext, BOOLEAN fLoad)
#endif
{
    NTSTATUS rc;

    if (fLoad)
    {
        rc = WDWLoad(pContext);
    }
    else
    {
        rc = WDWUnload(pContext);
    }

    return(rc);
}


/****************************************************************************/
/* Name:      WD_Open                                                       */
/*                                                                          */
/* Purpose:   Open and initialize winstation driver                         */
/*                                                                          */
/* Returns:   NTSTATUS value.                                               */
/*                                                                          */
/* Params:    IN     pTSWd     - Points to wd data structure                */
/*            INOUT  pSdOpen   - Points to the parameter structure SD_OPEN  */
/*                                                                          */
/* Operation: Sanity check the details of the Open packet.                  */
/*            Save the address of the protocol counters struct.             */
/*                                                                          */
/****************************************************************************/
NTSTATUS WD_Open(PTSHARE_WD pTSWd, PSD_OPEN pSdOpen)
{
    NTSTATUS rc = STATUS_SUCCESS;

    MCSError MCSErr;

    DC_BEGIN_FN("WD_Open");

    /************************************************************************/
    /* None of the info in the SD_OPEN is of great relevance to us, but we  */
    /* do some sanity checks that we aren't being confused with an ICA WD.  */
    /************************************************************************/
    TRC_ASSERT((pSdOpen->WdConfig.WdFlag & WDF_TSHARE),
                   (TB,"Not a TShare WD, %x", pSdOpen->WdConfig.WdFlag));

    pTSWd->StackClass = pSdOpen->StackClass;
    TRC_ALT((TB,"Stack class (%ld)", pSdOpen->StackClass));

    pTSWd->pProtocolStatus = pSdOpen->pStatus;
    TRC_DBG((TB, "Protocol counters are at %p", pTSWd->pProtocolStatus));

    /************************************************************************/
    /* Save our name for later use                                          */
    /************************************************************************/
    memcpy(pTSWd->DLLName, pSdOpen->WdConfig.WdDLL, sizeof(DLLNAME));
    TRC_NRM((TB, "Our name is >%S<", pTSWd->DLLName));

    /************************************************************************/
    /* Save off the connection name.  This is the registry key to look      */
    /* under for config settings.                                           */
    /************************************************************************/
    memcpy(pTSWd->WinStationRegName,
           pSdOpen->WinStationRegName,
           sizeof(pTSWd->WinStationRegName));

    /************************************************************************/
    /* Save the scheduling timings.  These get copied later into            */
    /* schNormalPeriod and schTurboPeriod respectively.                     */
    /************************************************************************/
    pTSWd->outBufDelay      = pSdOpen->PdConfig.Create.OutBufDelay;
    pTSWd->interactiveDelay = pSdOpen->PdConfig.Create.InteractiveDelay;

    /************************************************************************/
    /* Indicate that we do not want ICADD managing outbuf headers/trailers  */
    /************************************************************************/
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /************************************************************************/
    /* Initalize MCS                                                        */
    /************************************************************************/
    MCSErr = MCSInitialize(pTSWd->pContext, pSdOpen, &pTSWd->hDomainKernel,
            pTSWd->pSmInfo);
    if (MCSErr != MCS_NO_ERROR)
    {
        TRC_ERR((TB, "MCSInitialize returned %d", MCSErr));
        return STATUS_INSUFFICIENT_RESOURCES;    
    }

    /************************************************************************/
    /* We have not yet initialized virtual channels                         */
    /************************************************************************/
    pTSWd->bVirtualChannelBound = FALSE;

    pTSWd->_pRecvDecomprContext2 = NULL;
    pTSWd->_pVcDecomprReassemblyBuf =  NULL;

#ifdef DC_DEBUG
    /************************************************************************/
    /* There's no trace config yet                                          */
    /************************************************************************/
    pTSWd->trcShmNeedsUpdate = FALSE;

//  // TODO: Need to fix termsrv so that it enabled tracing on shadow &
//  //       primary stacks.  For now, set it to standard alert level tracing.
//  if ((pTSWd->StackClass == Stack_Primary) ||
//      (pTSWd->StackClass == Stack_Console))
//  {
//      SD_IOCTL SdIoctl;
//      ICA_TRACE  traceSettings;
//
//      traceSettings.fDebugger = TRUE;
//      traceSettings.fTimestamp = TRUE;
//      traceSettings.TraceClass = 0x10000008;
//      traceSettings.TraceEnable = 0x000000cc;
//      memset(traceSettings.TraceOption, 0, sizeof(traceSettings.TraceOption));
//
//      SdIoctl.IoControlCode = IOCTL_ICA_SET_TRACE;           // IN
//      SdIoctl.InputBuffer = &traceSettings;             // IN OPTIONAL
//      SdIoctl.InputBufferLength = sizeof(traceSettings);       // IN
//      SdIoctl.OutputBuffer = NULL;            // OUT OPTIONAL
//      SdIoctl.OutputBufferLength = 0;      // OUT
//      SdIoctl.BytesReturned = 0;           // OUT
//
//      TRC_UpdateConfig(pTSWd, &SdIoctl);
//  }
#endif /* DC_DEBUG */

    /************************************************************************/
    /* Read registry settings.
    /************************************************************************/
    if (COM_OpenRegistry(pTSWd, L""))
    {
        /************************************************************************/
        /* Read the flow control sleep interval.
        /************************************************************************/
        COM_ReadProfInt32(pTSWd,
                          WD_FLOWCONTROL_SLEEPINTERVAL,
                          WD_FLOWCONTROL_SLEEPINTERVAL_DFLT,
                          &(pTSWd->flowControlSleepInterval));

        TRC_NRM((TB, "Flow control sleep interval %ld",
            pTSWd->flowControlSleepInterval));

#ifdef DC_DEBUG
#ifndef NO_MEMORY_CHECK
        /************************************************************************/
        /* Decide whether to break on memory leaks         
        /************************************************************************/
        COM_ReadProfInt32(pTSWd,
                          WD_BREAK_ON_MEMORY_LEAK,
                          WD_BREAK_ON_MEMORY_LEAK_DFLT,
                          &(pTSWd->breakOnLeak));
        TRC_NRM((TB, "Break on memory leak ? %s",
            pTSWd->breakOnLeak ? "yes" : "no"));
#endif
#endif /* DC_DEBUG */
    }
    COM_CloseRegistry(pTSWd);


    // Establish full connectivity (sans encryption) for passthru stacks.
    // The encrypted context will come up later if supported by the requesting
    // server.  Hang the output user data off of our context so it can be
    // retrieved later by rpdwsx.
    if (pTSWd->StackClass == Stack_Passthru) {

        PUSERDATAINFO pUserData;
        ULONG OutputLength;

        // Because WDW_OnSMConnecting doesn't check the length of the
        // ioctl output buffer and doesn't return any error status, we
        // have to allocate enough space at the first try.
        // Use 128 as it is the amount used in rdpwsx/TSrvInitWDConnectInfo.

        OutputLength = 128;

        pUserData = (PUSERDATAINFO) COM_Malloc(OutputLength /*MIN_USERDATAINFO_SIZE*/) ;
        if (pUserData != NULL) {
            SD_IOCTL SdIoctl;

            memset(&SdIoctl, 0, sizeof(SdIoctl));
            memset(pUserData, 0, OutputLength /*MIN_USERDATAINFO_SIZE*/);
            pUserData->cbSize = OutputLength /*MIN_USERDATAINFO_SIZE*/;
            SdIoctl.IoControlCode = IOCTL_TSHARE_SHADOW_CONNECT;
            SdIoctl.OutputBuffer = pUserData;
            SdIoctl.OutputBufferLength = OutputLength /*MIN_USERDATAINFO_SIZE*/;

            rc = WDWShadowConnect(pTSWd, &SdIoctl) ;
            TRC_ALT((TB, "Passthru stack connected: rc=%lx", rc));

            if (NT_SUCCESS(rc)) {
                pTSWd->pUserData = pUserData;
            }
        }
        else {
            TRC_ERR((TB, "Passthru stack unable to allocate output user data"));
            rc = STATUS_NO_MEMORY;
        }
    }

    DC_END_FN();
    return rc;
} /* WD_Open */


/****************************************************************************/
/* Name:      WD_Close                                                      */
/*                                                                          */
/* Purpose:   Close winstation driver                                       */
/*                                                                          */
/* Params:    IN     pTSWd     - Points to wd data structure                */
/*            INOUT  pSdClose  - Points to the parameter structure SD_CLOSE */
/****************************************************************************/
NTSTATUS WD_Close(PTSHARE_WD pTSWd, PSD_CLOSE pSdClose)
{
    DC_BEGIN_FN("WD_Close");

    TRC_NRM((TB, "WD_Close on WD %p", pTSWd));

    // Make sure that Domain.StatusDead is consistent with TSWd.dead
    pTSWd->dead = TRUE;
    ((PDomain)(pTSWd->hDomainKernel))->StatusDead = TRUE;

    pSdClose->SdOutBufHeader = 0;   // OUT: returned by sd
    pSdClose->SdOutBufTrailer = 0;  // OUT: returned by sd

    // Clean up MCS.
    if (pTSWd->hDomainKernel != NULL)
        MCSCleanup(&pTSWd->hDomainKernel);

    // Opportunity to clean up if anything has been left lying around.
    if (pTSWd->dcShare != NULL) {
        if (pTSWd->shareClassInit) {
            // Terminate the Share Class.
            TRC_NRM((TB, "Terminate Share Class"));
            WDWTermShareClass(pTSWd);
        }

        // It's OK to free the Share object - this is allocated out of
        // system memory and is therefore accessible to WD_Close.
        TRC_NRM((TB, "Delete Share object"));
        WDWDeleteShareClass(pTSWd);
    }

    // Terminate SM.
    if (pTSWd->pSmInfo != NULL) {
        TRC_NRM((TB, "Terminate SM"));
        SM_Term(pTSWd->pSmInfo);
    }

    // Clean up protocol stats pointer. NOTE: It's a pointer to TermDD's
    // memory - we should not attempt to free it!
    pTSWd->pProtocolStatus = NULL;

    // Clean up the MPPC compression context and buffer, if allocated.
    // Note that both buffers are concatenated into one allocation
    // starting at pMPPCContext.
    if (pTSWd->pMPPCContext != NULL) {
        COM_Free(pTSWd->pMPPCContext);
        pTSWd->pMPPCContext = NULL;
        pTSWd->pCompressBuffer = NULL;
    }

    // Clean up the decompression context buffer if allocated
    if( pTSWd->_pRecvDecomprContext2) {
        COM_Free( pTSWd->_pRecvDecomprContext2);
        pTSWd->_pRecvDecomprContext2 = NULL;
    }

    // Clean up the decompression reassembly buffer if allocated
    if(pTSWd->_pVcDecomprReassemblyBuf) {
        COM_Free(pTSWd->_pVcDecomprReassemblyBuf);
        pTSWd->_pVcDecomprReassemblyBuf = NULL;
    }

    // Set compression state to default.
    pTSWd->bCompress = FALSE;

    // Clean up shadow buffers if allocated.
    if (pTSWd->pShadowInfo != NULL) {
        COM_Free(pTSWd->pShadowInfo);
        pTSWd->pShadowInfo = NULL;
    }

    if (pTSWd->pShadowCert != NULL) {
        TRC_NRM((TB, "Free pShadowCert"));
        COM_Free(pTSWd->pShadowCert);
        pTSWd->pShadowCert = NULL;
    }

    if (pTSWd->pShadowRandom != NULL) {
        TRC_NRM((TB, "Free pShadowRandom"));
        COM_Free(pTSWd->pShadowRandom);
        pTSWd->pShadowRandom = NULL;
    }
    
    if (pTSWd->pUserData != NULL) {
        TRC_NRM((TB, "Free pUserData"));
        COM_Free(pTSWd->pUserData);
        pTSWd->pUserData = NULL;
    }
    
    // Free any shadow hotkey processing structures.  Note that we don't free
    // pWd->pKbdTbl because we didn't allocate it!
    if (pTSWd->pgafPhysKeyState != NULL) {
        COM_Free(pTSWd->pgafPhysKeyState);
        pTSWd->pgafPhysKeyState = NULL;
    }

    if (pTSWd->pKbdLayout != NULL) {
        COM_Free(pTSWd->pKbdLayout);
        pTSWd->pKbdLayout = NULL;
    }

    if (pTSWd->gpScancodeMap != NULL) {
        COM_Free(pTSWd->gpScancodeMap);
        pTSWd->gpScancodeMap = NULL;
    }

    // Free the InfoPkt.
    if (pTSWd->pInfoPkt != NULL) {
        COM_Free(pTSWd->pInfoPkt);
        pTSWd->pInfoPkt = NULL;
    }

#ifdef DC_DEBUG
#ifndef NO_MEMORY_CHECK
    // Check for un-freed memory.
    if (pTSWd->memoryHeader.pNext != NULL) {
        PMALLOC_HEADER pNext;
        TRC_ERR((TB, "Unfreed memory"));
        pNext = pTSWd->memoryHeader.pNext;
        while (pNext != NULL) {
            TRC_ERR((TB, "At %#p, len %d, caller %#p",
                    pNext, pNext->length, pNext->pCaller));
            pNext = pNext->pNext;
        }

        if (pTSWd->breakOnLeak)
            DbgBreakPoint();
    }
#endif /* NO_MEMORY_CHECK */
#endif /* DC_DEBUG */

    DC_END_FN();
    return STATUS_SUCCESS;
} /* WD_Close */


/****************************************************************************/
/* Name:      WD_ChannelWrite                                               */
/*                                                                          */
/* Purpose:   Handle channel writing (virtual channel)                      */
/****************************************************************************/
NTSTATUS WD_ChannelWrite(PTSHARE_WD pTSWd, PSD_CHANNELWRITE pSdChannelWrite)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PVOID               pBuffer;
    UINT16              MCSChannelID;
    BOOL                bRc;
    CHANNEL_PDU_HEADER UNALIGNED *pHdr;
    PBYTE               pSrc;
    unsigned            dataLeft;
    unsigned            thisLength;
    unsigned            lengthToSend;
    UINT16              flags;
    PNM_CHANNEL_DATA    pChannelData;
    UCHAR compressResult = 0;
    ULONG CompressedSize = 0;
    BOOL                fCompressVC;
    DWORD               ret;

    DC_BEGIN_FN("WD_ChannelWrite");

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    TRC_ASSERT((pTSWd != NULL), (TB,"NULL pTSWd"));
    TRC_ASSERT((pSdChannelWrite != NULL), (TB,"NULL pTSdChannelWrite"));
    TRC_ASSERT((pSdChannelWrite->ChannelClass == Channel_Virtual),
        (TB,"non Virtual Channel, class=%lu", pSdChannelWrite->ChannelClass));

    TRC_DBG((TB,
            "Received channel write. class %lu, channel %lu, numbytes %lu",
                 (ULONG)pSdChannelWrite->ChannelClass,
                 (ULONG)pSdChannelWrite->VirtualClass,
                 pSdChannelWrite->ByteCount));

    /************************************************************************/
    /* Don't do this if we're dead                                          */
    /************************************************************************/
    if (pTSWd->dead)
    {
        TRC_ALT((TB, "Dead - don't do anything"));
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    /************************************************************************/
    /* Convert virtual channel ID to MCS channel ID                         */
    /************************************************************************/
    MCSChannelID = NM_VirtualChannelToMCS(pTSWd->pNMInfo,
                                          pSdChannelWrite->VirtualClass,
                                          &pChannelData);
    if (MCSChannelID == (UINT16) -1)
    {
        TRC_ERR((TB, "Unsupported virtual channel %d",
                pSdChannelWrite->VirtualClass));
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }
    TRC_NRM((TB, "Virtual channel %d = MCS Channel %hx",
            pSdChannelWrite->VirtualClass, MCSChannelID));

    //
    // Check if VC compression is enabled for this channel
    //
    fCompressVC = ((pChannelData->flags & CHANNEL_OPTION_COMPRESS_RDP)   &&
                   (pTSWd->bCompress)                                    &&
                   (pTSWd->shadowState == SHADOW_NONE)                   &&
                   (pTSWd->bClientSupportsVCCompression));
    TRC_NRM((TB,"Virtual Channel %d will be compressed.",
             pSdChannelWrite->VirtualClass));

    /************************************************************************/
    /* Initialize loop variables                                            */
    /************************************************************************/
    flags = CHANNEL_FLAG_FIRST;
    pSrc = pSdChannelWrite->pBuffer;
    dataLeft = pSdChannelWrite->ByteCount;

    /************************************************************************/
    /* Loop through the data                                                */
    /************************************************************************/
    while (dataLeft > 0)
    {
        /********************************************************************/
        /* Decide how much to send in this chunk                            */
        /********************************************************************/
        if (dataLeft > CHANNEL_CHUNK_LENGTH)
        {
            thisLength = CHANNEL_CHUNK_LENGTH;
        }
        else
        {
            thisLength = dataLeft;
            flags |= CHANNEL_FLAG_LAST;
        }


        /********************************************************************/
        // If the buffer is not a low prio write, then block right behind the
        // rest of the pending buffer allocs until we get a free buffer.
        /********************************************************************/
        if (!(pSdChannelWrite->fFlags & SD_CHANNELWRITE_LOWPRIO)) {
            status = SM_AllocBuffer(pTSWd->pSmInfo,
                                 &pBuffer,
                                 thisLength + sizeof(CHANNEL_PDU_HEADER),
                                 TRUE,
                                 FALSE);
        }
        /********************************************************************/
        // Else if the buffer is a low prio write, then sleep and alloc until 
        // we get a buffer without blocking.  This allows default priority allocs 
        // that block in SM_AllocBuffer to take precedence.
        /********************************************************************/
        else {
            status = SM_AllocBuffer(pTSWd->pSmInfo,
                                 &pBuffer,
                                 thisLength + sizeof(CHANNEL_PDU_HEADER),
                                 FALSE,
                                 FALSE);
            while (status == STATUS_IO_TIMEOUT) {

                TRC_NRM((TB, "SM_AllocBuffer would block"));            

                //  Bail out on any failure in this function to prevent an
                //  infinite loop.  STATUS_CTX_CLOSE_PENDING will be returned
                //  if the connection is being shut down.
                ret = IcaFlowControlSleep(pTSWd->pContext, 
                                        pTSWd->flowControlSleepInterval);
                if (ret == STATUS_SUCCESS) {
                    status = SM_AllocBuffer(pTSWd->pSmInfo,
                                         &pBuffer,
                                         thisLength + sizeof(CHANNEL_PDU_HEADER),
                                         FALSE,
                                         FALSE);
                }
                else {
                    TRC_ALT((TB, "IcaFlowControlSleep failed."));  
                    status = ret;
                    DC_QUIT;
                }
            }
            
        }

        if (status != STATUS_SUCCESS)
        {
            TRC_ALT((TB, "Failed to get a %d-byte buffer", thisLength));

            // prevent regression, keep original code path 
            status = STATUS_NO_MEMORY;
            DC_QUIT;
        }

        TRC_NRM((TB, "Buffer (%d bytes) allocated OK", thisLength));

        /************************************************************************/
        /* Fill in the buffer header                                            */
        /************************************************************************/
        pHdr = (CHANNEL_PDU_HEADER UNALIGNED *)pBuffer;
        pHdr->length = pSdChannelWrite->ByteCount;
        pHdr->flags = flags;

        /************************************************************************/
        /* Copy the data                                                        */
        /* If compression is enabled, try to compress directly into the outbuf  */
        /************************************************************************/
        CompressedSize=0;
        lengthToSend=0;
        __try {
            if((fCompressVC)                            &&
               (thisLength > WD_MIN_COMPRESS_INPUT_BUF) &&
               (thisLength < MAX_COMPRESS_INPUT_BUF))
            {
                compressResult = WDWCompressToOutbuf(pTSWd,(UCHAR*)pSrc,thisLength,
                                                     (UCHAR*)(pHdr+1),&CompressedSize);
                if(0 != compressResult)
                {
                    lengthToSend = CompressedSize;
                    //Update the VC packet header flags with the compression info
                    pHdr->flags |= ((compressResult & VC_FLAG_COMPRESS_MASK) <<
                                     VC_FLAG_COMPRESS_SHIFT);
                }
                else
                {
                    TRC_ERR((TB, "SC_CompressToOutbuf failed"));
                    SM_FreeBuffer(pTSWd->pSmInfo, pBuffer, FALSE);
                    DC_QUIT;
                }
            }
            else
            {
                //copy directly
                memcpy(pHdr + 1, pSrc, thisLength);
                lengthToSend = thisLength;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            TRC_ERR((TB, "Exception (0x%08lx) copying evil user buffer", status));
            SM_FreeBuffer(pTSWd->pSmInfo, pBuffer, FALSE);
            DC_QUIT;
        }

        TRC_NRM((TB, "Copied user buffer"));

        /************************************************************************/
        /* Send it                                                              */
        /************************************************************************/
        bRc = SM_SendData(pTSWd->pSmInfo, pBuffer,
                lengthToSend + sizeof(CHANNEL_PDU_HEADER), TS_LOWPRIORITY,
                MCSChannelID, FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (!bRc)
        {
            TRC_ERR((TB, "Failed to send data"));
            status = STATUS_UNSUCCESSFUL;
            DC_QUIT;
        }
        TRC_NRM((TB, "Sent a %d-byte chunk, flags %#x", lengthToSend, flags));

        /********************************************************************/
        /* Set up for next loop                                             */
        /********************************************************************/
        pSrc += thisLength;
        dataLeft -= thisLength;
        flags = 0;
    }

    /************************************************************************/
    /* Well, it's gone somwehere.                                           */
    /************************************************************************/
    TRC_NRM((TB, "Data sent OK"));

DC_EXIT_POINT:
    DC_END_FN();
    return(status);
} /* WD_ChannelWrite */


/****************************************************************************/
// WDW_OnSMConnecting
//
// Handles a 'connecting' state change callback from SM. This state occurs
// when the network connection is up but security negotiation has not yet
// begun. It is assumed that at this point GCCConferenceCreateResponse will
// be issued. Here we use the user data received from the client to build
// return GCC data in the TShareSRV IOCTL buffer.
/****************************************************************************/
void RDPCALL WDW_OnSMConnecting(
        PVOID hWD,
        PRNS_UD_SC_SEC pSecData,
        PRNS_UD_SC_NET pNetData)
{
    PTSHARE_WD pTSWd = (PTSHARE_WD)hWD;
    PUSERDATAINFO  pOutData;
    RNS_UD_SC_CORE coreData;
    BOOL           error = FALSE;
    BYTE           *pRgData;
    GCCOctetString UNALIGNED *pOctet;

    DC_BEGIN_FN("WDW_OnSMConnecting");

    // Save the broadcast channel ID for use in shadowing
    pTSWd->broadcastChannel = pNetData->MCSChannelID;

    /************************************************************************/
    /* Locate the output buffer.  NB the size of this has already been      */
    /* checked when we rx'd the IOCtl.                                      */
    /************************************************************************/
    if (pTSWd->pSdIoctl == NULL)
    {
        TRC_ERR((TB, "No IOCtl to fill in"));
        error = TRUE;
        DC_QUIT;
    }

    // Build the return GCC data required for the IOCTL_TSHARE_CONF_CONNECT
    pOutData = pTSWd->pSdIoctl->OutputBuffer;
    TRC_DBG((TB, "pOutData at %p", pOutData));

    /************************************************************************/
    /* Build core user data                                                 */
    /************************************************************************/
    memset(&coreData, 0, sizeof(coreData));
    coreData.header.type = RNS_UD_SC_CORE_ID;
    coreData.header.length = sizeof(coreData);
    coreData.version = RNS_UD_VERSION;

    /************************************************************************/
    /* Build the user data header and key                                   */
    /************************************************************************/
    /************************************************************************/
    /* Only one piece of user data to fill in, and the following code is    */
    /* specific to that.                                                    */
    /************************************************************************/
    pOutData->ulUserDataMembers = 1;
    pOutData->hDomain = pTSWd->hDomain;
    pOutData->version = pTSWd->version;
    pOutData->rgUserData[0].key.key_type = GCC_H221_NONSTANDARD_KEY;

    /************************************************************************/
    /* Put the key octet immediately after the rgUserData.                  */
    /************************************************************************/
    pRgData = (BYTE *)(pOutData + 1);
    pOctet = &(pOutData->rgUserData[0].key.u.h221_non_standard_id);

    pOctet->octet_string = pRgData - (UINT_PTR)pOutData;
    pOctet->octet_string_length = sizeof(SERVER_H221_KEY) - 1;
    strncpy(pRgData,
            (const char*)SERVER_H221_KEY,
            sizeof(SERVER_H221_KEY) - 1);
    TRC_DBG((TB, "Key octet at %p (offs %p)",
            pRgData, pRgData - (UINT_PTR)pOutData));

    /************************************************************************/
    /* Put the data octet immediately after the key octet.                  */
    /************************************************************************/
    pRgData += sizeof(SERVER_H221_KEY) - 1;
    pOctet = (GCCOctetString UNALIGNED *)pRgData;
    TRC_DBG((TB, "Data octet pointer at %p (offs %p)",
            pRgData, pRgData - (UINT_PTR)pOutData));

    pOutData->rgUserData[0].octet_string =
                             (GCCOctetString *)(pRgData - (UINT_PTR)pOutData);
    pOctet->octet_string_length = pSecData->header.length +
                                  coreData.header.length +
                                  pNetData->header.length;
    pRgData += sizeof(GCCOctetString);
    pOctet->octet_string = pRgData - (UINT_PTR)pOutData;

    /************************************************************************/
    /* Now add the data itself                                              */
    /************************************************************************/
    TRC_DBG((TB, "Core data at %p (offs %p)",
            pRgData, pRgData - (UINT_PTR)pOutData));
    memcpy(pRgData, &coreData, coreData.header.length);
    pRgData += coreData.header.length;

    TRC_DBG((TB, "Net data at %p (offs %p)",
            pRgData, pRgData - (UINT_PTR)pOutData));
    memcpy(pRgData, pNetData, pNetData->header.length);
    pRgData += pNetData->header.length;

    /************************************************************************/
    /* the security data is moved to the end of user data, fix the client   */
    /* code accordingly.                                                    */
    /************************************************************************/
    TRC_DBG((TB, "Sec data at %p (offs %p)",
            pRgData, pRgData - (UINT_PTR)pOutData));
    memcpy(pRgData, pSecData, pSecData->header.length);
    pRgData += pSecData->header.length;

    /************************************************************************/
    /* Finally, set up the number of valid bytes.                           */
    /************************************************************************/
    pOutData->cbSize = (ULONG)(UINT_PTR)(pRgData - (UINT_PTR)pOutData);
    pTSWd->pSdIoctl->BytesReturned = pOutData->cbSize;

    TRC_DBG((TB, "Build %d bytes of returned user data", pOutData->cbSize));
    TRC_DATA_NRM("Returned user data", pOutData, pOutData->cbSize);

DC_EXIT_POINT:
    if (error)
    {
        TRC_ERR((TB, "Something went wrong - bring down the WinStation"));
        WDW_LogAndDisconnect(pTSWd, TRUE, 
                             Log_RDP_CreateUserDataFailed,
                             NULL, 0);
    }

    DC_END_FN();
} /* WDW_OnSMConnecting */


/****************************************************************************/
// WDW_OnSMConnected
//
// Receives connection-completed state change callback from SM.
/****************************************************************************/
void RDPCALL WDW_OnSMConnected(PVOID hWD, unsigned Result)
{
    PTSHARE_WD pTSWd = (PTSHARE_WD)hWD;

    DC_BEGIN_FN("WDW_OnSMConnected");

    TRC_NRM((TB, "Got Connected Notification, rc %lu", Result));

    // Unblock the query IOCtl.
    pTSWd->connected = TRUE;
    KeSetEvent (pTSWd->pConnEvent, EVENT_INCREMENT, FALSE);

    // If we failed, get the whole thing winding down straight away.
    if (Result != NM_CB_CONN_ERR) {
        // If compression is enabled in the net flags, indicate we need to
        // do the compression, get the compression level, and allocate
        // the context buffers.
        if (pTSWd->pInfoPkt->flags & RNS_INFO_COMPRESSION) {
            unsigned MPPCCompressionLevel;

            pTSWd->pMPPCContext = COM_Malloc(sizeof(SendContext) +
                    MAX_COMPRESSED_BUFFER);
            if (pTSWd->pMPPCContext != NULL) {
                pTSWd->pCompressBuffer = (BYTE *)pTSWd->pMPPCContext +
                        sizeof(SendContext);

                // Negotiate down to our highest level of compression support
                // if we receive a larger number.
                MPPCCompressionLevel =
                        (pTSWd->pInfoPkt->flags & RNS_INFO_COMPR_TYPE_MASK) >>
                        RNS_INFO_COMPR_TYPE_SHIFT;
                if (MPPCCompressionLevel > PACKET_COMPR_TYPE_MAX)
                    MPPCCompressionLevel = PACKET_COMPR_TYPE_MAX;

                initsendcontext(pTSWd->pMPPCContext, MPPCCompressionLevel);

                pTSWd->bCompress = TRUE;
            }
            else {
                TRC_ERR((TB,"Failed allocation of MPPC compression buffers"));
            }
        }
    }
    else {
        TRC_ERR((TB, "Connection error: winding down now"));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_ConnectFailed, NULL, 0);
    }

    if(pTSWd->bCompress)
    {
        //If we're compressing then allocate a decompression context
        //for virtual channels
        pTSWd->_pRecvDecomprContext2 = (RecvContext2_8K*)COM_Malloc(sizeof(RecvContext2_8K));
        if(pTSWd->_pRecvDecomprContext2)
        {
            pTSWd->_pRecvDecomprContext2->cbSize = sizeof(RecvContext2_8K);
            initrecvcontext(&pTSWd->_DecomprContext1,
                            (RecvContext2_Generic*)pTSWd->_pRecvDecomprContext2,
                            PACKET_COMPR_TYPE_8K);
        }
    }

    DC_END_FN();
}


/****************************************************************************/
// WDW_OnSMDisconnected
//
// Handles disconnection state change callback from SM.
/****************************************************************************/
void WDW_OnSMDisconnected(PVOID hWD)
{
    PTSHARE_WD pTSWd = (PTSHARE_WD)hWD;

    DC_BEGIN_FN("WDW_OnSMDisconnected");

    TRC_ALT((TB, "Got Disconnected notification"));

    // Unblock the query IOCtl.
    pTSWd->connected = FALSE;
    KeSetEvent(pTSWd->pConnEvent, EVENT_INCREMENT, FALSE);

    DC_END_FN();
}


/****************************************************************************/
// WDW_OnClientDisconnected
//
// Direct-disconnect path called from MCS to set the create event so that
// CSRSS threads waiting for DD completion of DrvConnect or DrvDisconnect
// will be freed when the client goes down. This prevents a timing window for
// a denial-of-service attack where the client connects then closes its socket
// immediately, leaving the DD waiting and the rest of rdpwsx unable
// to complete closing the TermDD handle, until the 60-second create event
// wait completes.
//
// We cannot use WDW_OnSMDisconnected because its being called is dependent
// on the NM and SM state machines and whether they believe the disconnect
// should be called.
/****************************************************************************/
void RDPCALL WDW_OnClientDisconnected(void *pWD)
{
    PTSHARE_WD pTSWd = (PTSHARE_WD)pWD;

    DC_BEGIN_FN("WDW_OnClientDisconnected");

    // Set the disconnect event to cause any waiting connect-time events
    // to get a STATUS_TIMEOUT.
    KeSetEvent(pTSWd->pClientDisconnectEvent, EVENT_INCREMENT, FALSE);

    DC_END_FN();
}


/****************************************************************************/
// WDW_WaitForConnectionEvent
//
// Encapsulates a wait for a connection-time event (e.g. pTSWd->pCreateEvent
// for waiting for the font PDU to release the DD to draw). Adds
// functionality to also wait on a single "client disconnected" event,
// which allows the client disconnection code a single point of signaling
// to shut down the various waits.
/****************************************************************************/
NTSTATUS RDPCALL WDW_WaitForConnectionEvent(
        PTSHARE_WD pTSWd,
        PKEVENT pEvent,
        LONG Timeout)
{
    NTSTATUS Status;
    PKEVENT Events[2];

    DC_BEGIN_FN("WDW_WaitForConnectionEvent");

    Events[0] = pEvent;
    Events[1] = pTSWd->pClientDisconnectEvent;

    Status = IcaWaitForMultipleObjects(pTSWd->pContext, 2, Events,
            WaitAny, Timeout);
    if (Status == 0) {
        // First object (real wait) hit. We just return the status value.
        TRC_DBG((TB,"Primary event hit"));
    }
    else if (Status == 1) {
        // Second object (clietn disconnect) hit. Translate to a TIMEOUT
        // for the caller, so they clean up properly.
        Status = STATUS_TIMEOUT;
        TRC_ALT((TB,"Client disconnect event hit"));
    }
    else {
        // Other return (e.g. timeout or close error). Just return it normally.
        TRC_DBG((TB,"Other status 0x%X", Status));
    }

    DC_END_FN();
    return Status;
}


/****************************************************************************/
/* Name:      WDW_OnDataReceived                                            */
/*                                                                          */
/* Purpose:   Callback when virtual channel data received from Client       */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pTSWd - ptr to WD                                             */
/*            pData - ptr to data received                                  */
/*            dataLength - length of data received                          */
/*            chnnelID - MCS channel on which data was received             */
/*                                                                          */
/* NOTE: Can be called when dead, in which case our only job should be to   */
/*       decompress the data to make sure the context remains in sync       */
/****************************************************************************/
void WDW_OnDataReceived(PTSHARE_WD pTSWd,
                        PVOID      pData,
                        unsigned   dataLength,
                        UINT16     channelID)
{
    VIRTUALCHANNELCLASS virtualClass;
    NTSTATUS status;
    PNM_CHANNEL_DATA pChannelData;
    CHANNEL_PDU_HEADER UNALIGNED *pHdr;
    ULONG  thisLength;
    unsigned totalLength;
    PUCHAR pDataOut;
    UCHAR  vcCompressFlags;
    UCHAR *pDecompOutBuf;
    int    cbDecompLen;


    DC_BEGIN_FN("WDW_OnDataReceived");

    /************************************************************************/
    /* Translate MCS channel ID to virtual channel ID                       */
    /************************************************************************/
    virtualClass = NM_MCSChannelToVirtual(pTSWd->pNMInfo,
                                          channelID,
                                          &pChannelData);
    if ((-1 == virtualClass) || (NULL == pChannelData)) 
    {
        TRC_ERR((TB,"Invalid MCS Channel ID: %u", channelID));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_InvalidChannelID,
                (BYTE *)pData, dataLength);
        DC_QUIT;
    }
    TRC_ASSERT((virtualClass < 32),
                (TB, "Invalid virtual channel %d for MCS channel %hx",
                virtualClass, channelID));

    TRC_NRM((TB, "Data received on MCS channel %hx, virtual channel %d",
            channelID, virtualClass));
    TRC_DATA_NRM("Channel data received", pData, dataLength);

    if (dataLength >= sizeof(CHANNEL_PDU_HEADER)) {
        pHdr = (CHANNEL_PDU_HEADER UNALIGNED *)pData;
        totalLength = pHdr->length;
    }
    else {
        TRC_ERR((TB,"Channel data len %u not enough for channel header",
                dataLength));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_VChannelDataTooShort,
                (BYTE *)pData, dataLength);
        DC_QUIT;
    }

    //
    // Decompress the buffer
    //
    vcCompressFlags = (pHdr->flags >> VC_FLAG_COMPRESS_SHIFT) &
                       VC_FLAG_COMPRESS_MASK;

    //
    // Server only supports 8K decompression context
    //
    if((pChannelData->flags & CHANNEL_OPTION_COMPRESS_RDP) &&
       (vcCompressFlags & PACKET_COMPRESSED))
    {
        if(!pTSWd->_pRecvDecomprContext2)
        {
            TRC_ERR((TB,"No decompression context!!!"));
            DC_QUIT;
        }

        if(PACKET_COMPR_TYPE_8K == (vcCompressFlags & PACKET_COMPR_TYPE_MASK))
        {
            //Decompress channel data
            if(vcCompressFlags & PACKET_FLUSHED)
            {
                initrecvcontext (&pTSWd->_DecomprContext1,
                                 (RecvContext2_Generic*)pTSWd->_pRecvDecomprContext2,
                                 PACKET_COMPR_TYPE_8K);
            }
            if (decompress((PUCHAR)(pHdr+1),
                           dataLength - sizeof(CHANNEL_PDU_HEADER),
                           (vcCompressFlags & PACKET_AT_FRONT),
                           &pDecompOutBuf,
                           &cbDecompLen,
                           &pTSWd->_DecomprContext1,
                           (RecvContext2_Generic*)pTSWd->_pRecvDecomprContext2,
                           vcCompressFlags & PACKET_COMPR_TYPE_MASK))
            {
                //
                // Successful decompression
                // If we're in the dead state then bail out now as the context
                // has been updated
                //

                if (!pTSWd->dead && (pHdr->flags & CHANNEL_FLAG_SHOW_PROTOCOL))
                {
                    TRC_DBG((TB, "Include VC protocol header (decompressed)"));
                    //Here is where things get nasty, we need to prepend
                    //the header to the decompression buffer which lives
                    //within the decompression context buffer.
    
                    //There is no (un-hackerific) way to do this without a
                    //memcpy, so go ahead and copy using a cached reassembly
                    //buffer.
                    if(!pTSWd->_pVcDecomprReassemblyBuf)
                    {
                        pTSWd->_pVcDecomprReassemblyBuf=(PUCHAR)
                                            COM_Malloc(WD_VC_DECOMPR_REASSEMBLY_BUF);
                    }
    
                    //Data received cannot decompress to something bigger
                    //than the chunk length.
                    TRC_ASSERT((cbDecompLen + sizeof(CHANNEL_PDU_HEADER)) <
                               WD_VC_DECOMPR_REASSEMBLY_BUF,
                               (TB,"Reassembly buffer too small"));
                    if(pTSWd->_pVcDecomprReassemblyBuf &&
                       ((cbDecompLen + sizeof(CHANNEL_PDU_HEADER)) <
                        WD_VC_DECOMPR_REASSEMBLY_BUF))
                    {
                        memcpy(pTSWd->_pVcDecomprReassemblyBuf, pHdr,
                               sizeof(CHANNEL_PDU_HEADER));
                        memcpy(pTSWd->_pVcDecomprReassemblyBuf +
                               sizeof(CHANNEL_PDU_HEADER),
                               pDecompOutBuf,
                               cbDecompLen);
    
                        //Hide the internal protocol from the user
                        pDataOut = pTSWd->_pVcDecomprReassemblyBuf;
                        thisLength = cbDecompLen + sizeof(CHANNEL_PDU_HEADER);
    
                        //Hide the internal protocol fields from the user
                        ((CHANNEL_PDU_HEADER UNALIGNED *)pDataOut)->flags &=
                             ~VC_FLAG_PRIVATE_PROTOCOL_MASK;
                    }
                    else
                    {
                        //Either the allocation failed or the channel
                        //decompressed to something bigger than a chunk
                        TRC_ERR((TB,"Can't use reassembly buffer"));
                        DC_QUIT;
                    }
                }
                else if (pTSWd->dead)
                {
                    TRC_NRM((TB,"Decompressed when dead, bailing out"));
                    DC_QUIT;
                }
                else
                {
                    TRC_DBG((TB, "Exclude VC protocol header (decompressed)"));
                    pDataOut = (PUCHAR)pDecompOutBuf;
                    thisLength = cbDecompLen;
                }
            }
            else {
                TRC_ABORT((TB, "Decompression FAILURE!!!"));
                WDW_LogAndDisconnect(pTSWd, TRUE, 
                                     Log_RDP_VirtualChannelDecompressionErr,
                                     NULL, 0);
                DC_QUIT;
            }
        }
        else
        {
            //
            //This server only supports 8K VC compression from client
            //(Specified by capabilities) it should not have
            //been sent this invalid compression type
            TRC_ABORT((TB,"Received packet with invalid compression type %d",
                      (vcCompressFlags & PACKET_COMPR_TYPE_MASK)));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                                 Log_RDP_InvalidVCCompressionType,
                                 NULL, 0);
            DC_QUIT;
        }
    }
    else
    {
        //Channel data is not compressd
        if (pHdr->flags & CHANNEL_FLAG_SHOW_PROTOCOL)
        {
            TRC_DBG((TB, "Include VC protocol header"));
            pDataOut = (PUCHAR)pHdr;
            thisLength = dataLength;
            //Hide the internal protocol fields from the user
            ((CHANNEL_PDU_HEADER UNALIGNED *)pDataOut)->flags &=
                 ~VC_FLAG_PRIVATE_PROTOCOL_MASK;
        }
        else
        {
            TRC_DBG((TB, "Exclude VC protocol header"));
            pDataOut = (PUCHAR)(pHdr + 1);
            thisLength = dataLength - sizeof(*pHdr);
        }
    }

    if (!pTSWd->dead)
    {
        TRC_NRM((TB,
                "Input %d bytes (of %d) at %p (Hdr %p, flags %#x) on channel %d",
                thisLength, totalLength, pDataOut, pHdr, pHdr->flags,
                virtualClass));
        status = IcaChannelInput(pTSWd->pContext,
                                 Channel_Virtual,
                                 virtualClass,
                                 NULL,
                                 pDataOut,
                                 thisLength);
    }
    else
    {
        TRC_NRM((TB,"Skipping input (%d bytes) because dead",
                 thisLength));
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* WDW_OnDataReceived */


/****************************************************************************/
/* Name:      WDW_InvalidateRect                                            */
/*                                                                          */
/* Purpose:   Tell ICADD to redraw a given rectangle.                       */
/*                                                                          */
/* Returns:   VOID.                                                         */
/*                                                                          */
/* Params:    IN    pTSWd - ptr to WD                                       */
/*            IN    personID - the originator of this PDU                   */
/*            IN    rect - the area to redraw                               */
/*                                                                          */
/* Operation: Build command and pass it to ICADD.                           */
/****************************************************************************/
void WDW_InvalidateRect(
        PTSHARE_WD           pTSWd,
        PTS_REFRESH_RECT_PDU pRRPDU,
        unsigned             DataLength)
{
    ICA_CHANNEL_COMMAND Cmd;
    NTSTATUS            status;
    unsigned            i;

    DC_BEGIN_FN("WDW_InvalidateRect");

    // Make sure we have enough data before accessing.
    if (DataLength >= (sizeof(TS_REFRESH_RECT_PDU) - sizeof(TS_RECTANGLE16))) {
        TRC_NRM((TB, "Got request to refresh %hu area%s",
                (UINT16)pRRPDU->numberOfAreas,
                pRRPDU->numberOfAreas == 1 ? " " : "s"));
        if ((unsigned)(TS_UNCOMP_LEN(pRRPDU) -
                FIELDOFFSET(TS_REFRESH_RECT_PDU, areaToRefresh[0])) >=
                (pRRPDU->numberOfAreas * sizeof(TS_RECTANGLE16)) &&
            (unsigned)(DataLength -
                FIELDOFFSET(TS_REFRESH_RECT_PDU, areaToRefresh[0])) >=
                (pRRPDU->numberOfAreas * sizeof(TS_RECTANGLE16))) {
            for (i = 0; i < pRRPDU->numberOfAreas; i++) {
                // Rects arrive inclusive, convert to exclusive for the system.
                Cmd.Header.Command = ICA_COMMAND_REDRAW_RECTANGLE;
                Cmd.RedrawRectangle.Rect.Left = pRRPDU->areaToRefresh[i].left;
                Cmd.RedrawRectangle.Rect.Top = pRRPDU->areaToRefresh[i].top;
                Cmd.RedrawRectangle.Rect.Right = pRRPDU->areaToRefresh[i].
                        right + 1;
                Cmd.RedrawRectangle.Rect.Bottom = pRRPDU->areaToRefresh[i].
                        bottom + 1;

                /************************************************************/
                // Pass the filled in structure to ICADD.
                /************************************************************/
                status = IcaChannelInput(pTSWd->pContext,
                                         Channel_Command,
                                         0,
                                         NULL,
                                         (unsigned char *) &Cmd,
                                         sizeof(ICA_CHANNEL_COMMAND));

                TRC_DBG((TB,"Issued Refresh Rect for %u,%u,%u,%u (exclusive); "
                        "status %lu",
                        pRRPDU->areaToRefresh[i].left,
                        pRRPDU->areaToRefresh[i].top,
                        pRRPDU->areaToRefresh[i].right + 1,
                        pRRPDU->areaToRefresh[i].bottom + 1,
                        status));
            }
        }
        else {
            /****************************************************************/
            // There can't be enough space in this PDU to store the number of
            // rectangles that it apparently contains. Don't process it.
            /****************************************************************/
            TCHAR detailData[(sizeof(UINT16) * 4) + 2];
            TRC_ERR((TB, "Invalid RefreshRectPDU: %hu rects; %hu bytes long",
                     (UINT16)pRRPDU->numberOfAreas,
                     pRRPDU->shareDataHeader.uncompressedLength));

            /****************************************************************/
            // Log an error and disconnect the Client
            /****************************************************************/
            swprintf(detailData, L"%hx %hx",
                        (UINT16)pRRPDU->numberOfAreas,
                        pRRPDU->shareDataHeader.uncompressedLength,
                        sizeof(detailData));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                                 Log_RDP_InvalidRefreshRectPDU,
                                 NULL, 0);
        }
    }
    else {
        TRC_ERR((TB,"Data len %u not enough for refresh rect PDU",
                DataLength));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_InvalidRefreshRectPDU,
                (BYTE *)pRRPDU, DataLength);
    }

    DC_END_FN();
} /* WDW_InvalidateRect */


#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      WDW_Malloc                                                    */
/*                                                                          */
/* Purpose:   Allocate memory (checked builds only)                         */
/*                                                                          */
/* Returns:   ptr to memory allocated                                       */
/*                                                                          */
/* Params:    pTSWd                                                         */
/*            length - size of memory required                              */
/****************************************************************************/
PVOID RDPCALL WDW_Malloc(PTSHARE_WD pTSWd, ULONG length)
{
    PVOID pMemory;

#ifndef NO_MEMORY_CHECK
    /************************************************************************/
    /* If we're checking memory, allow space for the header                 */
    /************************************************************************/
    length += sizeof(MALLOC_HEADER);
#endif

    /************************************************************************/
    /* Allocate the memory                                                  */
    /************************************************************************/
    pMemory = ExAllocatePoolWithTag(PagedPool, length, WD_ALLOC_TAG);

    if (pMemory == NULL)
    {
        KdPrint(("WDTShare: COM_Malloc failed to alloc %u bytes\n", length));
        DC_QUIT;
    }

#ifndef NO_MEMORY_CHECK
    /************************************************************************/
    /* If we haven't been passed a TSWd, we can't save the memory details - */
    /* clear the header.                                                    */
    /************************************************************************/
    if (pTSWd == NULL)
    {
        memset(pMemory, 0, sizeof(MALLOC_HEADER));
    }
    else
    {
        /********************************************************************/
        /* we've been passed a TSWd - save memory details                   */
        /********************************************************************/
        PVOID pReturnAddress = NULL;
        PMALLOC_HEADER pHeader;

#ifdef _X86_
        /********************************************************************/
        /* Find caller's address (X86 only)                                 */
        /********************************************************************/
        _asm mov eax,[ebp+4]
        _asm mov pReturnAddress,eax
#endif /* _X86_ */

        /********************************************************************/
        /* Save memory allocation details                                   */
        /********************************************************************/
        pHeader = (PMALLOC_HEADER)pMemory;
        pHeader->pCaller = pReturnAddress;
        pHeader->length = length;
        pHeader->pPrev = &(pTSWd->memoryHeader);
        if (pTSWd->memoryHeader.pNext != NULL)
        {
            (pTSWd->memoryHeader.pNext)->pPrev = pHeader;
        }
        pHeader->pNext = pTSWd->memoryHeader.pNext;
        pTSWd->memoryHeader.pNext = pHeader;

    }

    /************************************************************************/
    /* Bump pointer past header                                             */
    /************************************************************************/
    pMemory = (PVOID)((BYTE *)pMemory + sizeof(MALLOC_HEADER));
#endif /* NO_MEMORY_CHECK */

DC_EXIT_POINT:
    return(pMemory);
}


/****************************************************************************/
/* Name:      WDW_Free                                                      */
/*                                                                          */
/* Purpose:   Free memory (checked builds only)                             */
/*                                                                          */
/* Params:    pMemory - pointer to memory to free                           */
/****************************************************************************/
void RDPCALL WDW_Free(PVOID pMemory)
{
#ifndef NO_MEMORY_CHECK
    /************************************************************************/
    /* Remove this block from memory allocation chain                       */
    /************************************************************************/
    PMALLOC_HEADER pHeader;

    pHeader = (PMALLOC_HEADER)pMemory - 1;
    if (pHeader->pNext != NULL)
    {
        pHeader->pNext->pPrev = pHeader->pPrev;
    }
    if (pHeader->pPrev != NULL)
    {
        pHeader->pPrev->pNext = pHeader->pNext;
    }

    pMemory = (PVOID)pHeader;
#endif /* NO_MEMORY_CHECK */

    /************************************************************************/
    /* Free the memory                                                      */
    /************************************************************************/
    ExFreePool(pMemory);
}
#endif /* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ntdd.c ===
/****************************************************************************/
// ntdd.c
//
// Standard NT driver initialization, for inclusion in each of the TS
// stack drivers.
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define DEVICE_NAME_PREFIX L"\\Device\\"


//
// Global data
//
PDEVICE_OBJECT DrvDeviceObject;


//
// External references
//

// This is the name of the WD/TD/PD module we are initializing as.
extern const PWCHAR ModuleName;

// Global code page caching data to be initialized and freed in asmint.c.
extern FAST_MUTEX fmCodePage;
extern ULONG LastCodePageTranslated;
extern PVOID LastNlsTableBuffer;
extern UINT NlsTableUseCount;


// This is the stack driver module entry point defined in ntos\citrix\inc\sdapi.h
NTSTATUS
_stdcall
ModuleEntry(
    IN OUT PSDCONTEXT pSdContext,
    IN BOOLEAN bLoad
    );


//
// Forward refrences
//
VOID DrvUnload( PDRIVER_OBJECT );

NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )


/*++

Routine Description:

    Standard NT driver entry routine.

Arguments:

    DriverObject - NT passed driver object
    RegistryPath - Path to driver specific registry entry

Return Value:

    NTSTATUS code.

Environment:

    Kernel mode, DDK
--*/
{
    ULONG i;
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    PWCHAR NameBuffer;
    ULONG  NameSize;

    PAGED_CODE( );

    NameSize = sizeof(DEVICE_NAME_PREFIX) + sizeof(WCHAR);
    NameSize += (wcslen(ModuleName) * sizeof(WCHAR));

    NameBuffer = ExAllocatePool( NonPagedPool, NameSize );
    if( NameBuffer == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy( NameBuffer, DEVICE_NAME_PREFIX );
    wcscat( NameBuffer, ModuleName );

    RtlInitUnicodeString( &DeviceName, NameBuffer );

    Status = IoCreateDevice(
                 DriverObject,
                 0,       // No DeviceExtension
                 &DeviceName,
                 FILE_DEVICE_TERMSRV,
                 0,
                 FALSE,
                 &DrvDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
        ExFreePool( NameBuffer );
        return( Status );
    }

    DriverObject->DriverUnload = DrvUnload;
    DriverObject->FastIoDispatch = NULL;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DrvDispatch;
    }

    // Init code page handling info from asmint.c.
    ExInitializeFastMutex(&fmCodePage);
    LastCodePageTranslated = 0;
    LastNlsTableBuffer = NULL;
    NlsTableUseCount = 0;
    
    DrvDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ExFreePool( NameBuffer );

    return( Status );
}


VOID
DrvUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Driver unload routine.

Arguments:

    DriverObject - Driver object being unloaded.

Return Value:

    None.

Environment:

    Kernel mode, DDK
--*/
{
    PAGED_CODE( );

    // Free remaining code page data on exit, if it exists.
    if (LastNlsTableBuffer != NULL) {
        ExFreePool(LastNlsTableBuffer);
        LastNlsTableBuffer = NULL;
    }

    IoDeleteDevice( DrvDeviceObject );

    return;
}


NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for the driver.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Environment:

    Kernel mode, DDK
--*/
{
    PIO_STACK_LOCATION irpSp;
    KIRQL saveIrql;
    NTSTATUS Status;
    PSD_MODULE_INIT pmi;

    DeviceObject;   // prevent compiler warnings

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MajorFunction ) {

        case IRP_MJ_CREATE:
    
            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );
    
            return Status;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:

            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.IoControlCode !=
                    IOCTL_SD_MODULE_INIT ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(SD_MODULE_INIT) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            // Return the SD module entry point.
            pmi = (PSD_MODULE_INIT)Irp->UserBuffer;
            pmi->SdLoadProc = ModuleEntry;

            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(SD_MODULE_INIT);
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );
    
            return Status;

        case IRP_MJ_CLEANUP:
    
            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );
    
            return Status;

        case IRP_MJ_CLOSE:
    
            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );
    
            return Status;

        default:
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            IoCompleteRequest( Irp, 0 );
    
            return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nsdgint.cpp ===
/****************************************************************************/
// nsdgint.cpp
//
// RDP Screen Data Grabber internal functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define TRC_FILE "nsdgint"
#include <as_conf.hpp>
#include <nprcount.h>


/****************************************************************************/
/* Name:      SDGSendSDARect                                                */
/*                                                                          */
/* Purpose:   Attempts to send the given rectangle of Screen Data           */
/*            in one or more BitmapPDUs                                     */
/*                                                                          */
/* Returns:   TRUE if whole rectangle sucessfully sent, FALSE otherwise.    */
/*            The supplied rectangle is always updated to remove the area   */
/*            that was successfully sent i.e. upon return the rectangle     */
/*            contains the area that was NOT sent.                          */
/*                                                                          */
/* Params:    IN: pFrameBuf - pointer to the Frame Buffer                   */
/*            IN/OUT: pRect - pointer to rectangle to send.  Updated to     */
/*            contain the rectangle that was not sent.                      */
/*            IN:  mustSend - set if the PDU must be sent (last rectangle)  */
/*            IN:  pPkgInfo - PDU package to use                            */
/****************************************************************************/
BOOL RDPCALL SHCLASS SDGSendSDARect(
        BYTE               *pFrameBuf,
        unsigned           frameBufferWidth,
        PRECTL             pRect,
        BOOL               mustSend,
        PPDU_PACKAGE_INFO  pPkgInfo,
        SDG_ENCODE_CONTEXT *pContext)
{
    BOOL rc = FALSE;
    int rectWidth;
    int rectHeight;
    int paddedWidthInPels;

// DC_HICOLOR
    int paddedWidthInBytes;

    unsigned padByte;
    unsigned maxRowsLeft;
    BYTE *pSrc;
    BYTE *pPrevSrc;
    unsigned uncompressedBitmapSize;
    unsigned compressedBitmapSize = 0;
    unsigned transferHeight;
    unsigned pduSize;
    unsigned compEst;
    unsigned cbAdded;
    unsigned compRowsLeft;
    unsigned dataLeft;
    unsigned buffSpaceLeft;
    BOOL compRc;

    // Macro to calculate remaining space in the BitmapPDU, allowing for
    // any current rectangles.
#define SDG_SPACE_LEFT \
    ((pContext->pPackageSpace + pContext->BitmapPDUSize) - \
         ((BYTE *)pContext->pSDARect + \
         FIELDOFFSET(TS_BITMAP_DATA, bitmapData[0])))

    DC_BEGIN_FN("SDGSendSDARect");

    TRC_NRM((TB, "SDA rect: (%d,%d)(%d,%d)", pRect->left, pRect->top,
            pRect->right, pRect->bottom));

#ifdef DC_HICOLOR
    // For simplicity on 4bpp, round left down to an even number.
    if (m_pTSWd->desktopBpp == 4)
        pRect->left &= (~0x1);

    // Get the rectangle width and height, remembering that the supplied
    // coords are inclusive.
    rectWidth  = pRect->right  - pRect->left;
    rectHeight = pRect->bottom - pRect->top;

    // Pad rect width so that each row is dword aligned.
    paddedWidthInPels = (rectWidth + 3) & (~0x03);

    // Set up a pointer to the first byte to fetch from the Frame Buffer,
    // alowing for the color depth.
    if (m_pTSWd->desktopBpp == 24) {
        pSrc = pFrameBuf + 3 * (pRect->top * frameBufferWidth + pRect->left);
        paddedWidthInBytes = paddedWidthInPels * 3;
    }
    else if ((m_pTSWd->desktopBpp == 16) || (m_pTSWd->desktopBpp == 15)) {
        pSrc = pFrameBuf + 2 * (pRect->top * frameBufferWidth + pRect->left);
        paddedWidthInBytes = paddedWidthInPels * 2;
    }
    else if (m_pTSWd->desktopBpp == 8) {
        pSrc = pFrameBuf + (pRect->top * frameBufferWidth) + pRect->left;
        paddedWidthInBytes = paddedWidthInPels;
    }
    else {
        pSrc = pFrameBuf +
                (((pRect->top * frameBufferWidth) + pRect->left) >> 1);
        paddedWidthInBytes = paddedWidthInPels;
    }
#else
    // Set up a pointer to the first byte to fetch from the Frame Buffer.
    if (m_pTSWd->desktopBpp == 8) {
        // Get the rectangle width and height, remembering that the
        // supplied coords are exclusive.
        rectWidth = pRect->right - pRect->left;
        rectHeight = pRect->bottom - pRect->top;
        pSrc = pFrameBuf + (pRect->top * frameBufferWidth) + pRect->left;

// DC_HICOLOR
        paddedWidthInBytes = (rectWidth + 3) & (~0x03);
    }
    else {
        // Get the rectangle width and height, remembering that the
        // supplied coords are exclusive.
        // For simplicity on 4bpp, round left down to an even number.
        pRect->left &= (~0x1);
        rectWidth = pRect->right - pRect->left;
        rectHeight = pRect->bottom - pRect->top;
        pSrc = pFrameBuf + (((pRect->top * frameBufferWidth) +
                pRect->left) >> 1);

// DC_HICOLOR
        paddedWidthInBytes = (rectWidth + 3) & (~0x03);
    }
#endif

    TRC_NRM((TB, "%dbpp: pSrc %p, bytes/row %d",
             m_pTSWd->desktopBpp, pSrc, paddedWidthInBytes));

#ifndef DC_HICOLOR
    // Pad rect width so that each row is dword aligned.
    paddedWidthInPels = (rectWidth + 3) & (~0x03);
#endif

    while ((rectHeight > 0) || mustSend) {
        // Have we filled the current PDU?  Yes, if:
        // - there is no room for more data; or
        // - the last rectangle has been completely added; or
        // - multiple rects per PDU are not supported.
        if ((pContext->pBitmapPDU != NULL) &&
                ((SDG_SPACE_LEFT < paddedWidthInBytes) ||
                (rectHeight == 0)))
        {
            pduSize = (unsigned)((BYTE *)pContext->pSDARect -
                    pContext->pPackageSpace);
            TRC_NRM((TB, "Send PDU size %u, numrects=%u", pduSize,
                    pContext->pBitmapPDU->numberRectangles));

            // Add the PDU to the package.
            SC_AddToPackage(pPkgInfo, pduSize, TRUE);

            INC_INCOUNTER(IN_SND_SDA_PDUS);

            // Just used up an entire PDU. Quit if the entire rectangle
            // was consumed OR we are in the middle of accumulating a
            // shadow buffer.
            pContext->pPackageSpace = NULL;
            pContext->pBitmapPDU = NULL;
            pContext->pSDARect   = NULL;
            TRC_DBG((TB, "Reset pSDARect and pBitmapPDU"));

            if ((rectHeight == 0) || m_pTSWd->shadowState) {
                // There is no new data. Break out of while loop.
                // mustSend must be set.
                TRC_NRM((TB, "Finished processing rectangle"));
                break;
            }
        }

        // Set up a new PDU if required.
        if (pContext->pBitmapPDU == NULL) {
            // Find space needed for headers plus one TS_BITMAP_DATA hdr plus
            // the size of the header, throttled by the large packing size.
            dataLeft = rectHeight * paddedWidthInBytes + scUpdatePDUHeaderSpace +
                    (unsigned)FIELDOFFSET(TS_UPDATE_BITMAP_PDU_DATA,
                    rectangle[0]) +
                    (unsigned)FIELDOFFSET(TS_BITMAP_DATA, bitmapData[0]);
            dataLeft = min(dataLeft, m_pShm->sch.LargePackingSize);

            TRC_NRM((TB, "Getting PDU, min size %d", dataLeft));
            pContext->pPackageSpace = SC_GetSpaceInPackage(pPkgInfo,
                    dataLeft);
            if (pContext->pPackageSpace != NULL) {
                // Set up the current PDU size. Throttle to the large
                // packing size.
                pContext->BitmapPDUSize = min(
                        (pPkgInfo->cbLen - pPkgInfo->cbInUse),
                        m_pShm->sch.LargePackingSize);
                TRC_NRM((TB, "Got PDU size %d", pContext->BitmapPDUSize));

                // Fill in PDU header.
                if (scUseFastPathOutput) {
                    pContext->pPackageSpace[0] = TS_UPDATETYPE_BITMAP |
                            scCompressionUsedValue;
                }
                else {
                    ((TS_UPDATE_BITMAP_PDU UNALIGNED *)
                            pContext->pPackageSpace)->shareDataHeader.pduType2 =
                            TS_PDUTYPE2_UPDATE;
                }
                pContext->pBitmapPDU = (TS_UPDATE_BITMAP_PDU_DATA UNALIGNED *)
                        (pContext->pPackageSpace + scUpdatePDUHeaderSpace);
                pContext->pBitmapPDU->updateType = TS_UPDATETYPE_BITMAP;
                pContext->pBitmapPDU->numberRectangles = 0;

                // Set up a pointer to the rectangles.
                pContext->pSDARect = &(pContext->pBitmapPDU->rectangle[0]);
            }
            else {
                TRC_ALT((TB, "Failed to allocate buffer"));
                DC_QUIT;
            }
        }

        // Now copy as many lines as possible into the PDU. Code above
        // means there must be room for a line.
        TRC_ASSERT((paddedWidthInBytes > 0), (TB, "zero paddedRectWidth"));
        maxRowsLeft = (unsigned)SDG_SPACE_LEFT / paddedWidthInBytes;
        TRC_ASSERT((maxRowsLeft > 0),
                 (TB, "Internal error: no room for a row, space %u, width %u",
                 SDG_SPACE_LEFT, paddedWidthInBytes));

        // This figure does not allow for the compression we are about to
        // apply - lets revise it accordingly.
        compRowsLeft = maxRowsLeft * SCH_UNCOMP_BYTES /
                SCH_GetBACompressionEst();
        transferHeight         = min((unsigned)rectHeight, compRowsLeft);
        uncompressedBitmapSize = transferHeight * paddedWidthInBytes;

        // Check that this won't blow the compression algorithm.
        if (uncompressedBitmapSize > MAX_UNCOMPRESSED_DATA_SIZE) {
            TRC_NRM((TB, "Rect size %u too big to compress in one go",
                         uncompressedBitmapSize));
            transferHeight = MAX_UNCOMPRESSED_DATA_SIZE / paddedWidthInBytes;
            uncompressedBitmapSize = transferHeight * paddedWidthInBytes;

            TRC_NRM((TB, "Reduced size to %u (%u rows)",
                uncompressedBitmapSize, transferHeight));
        }

        // Fill in the common header fields for this rectangle.
        // Convert the rect to inclusive for the wire protocol.
        pContext->pBitmapPDU->numberRectangles++;
        pContext->pSDARect->destLeft = (INT16)(pRect->left);
        pContext->pSDARect->destRight = (INT16)(pRect->right - 1);
        pContext->pSDARect->destTop = (INT16)(pRect->top);
        pContext->pSDARect->width = (UINT16)paddedWidthInPels;
#ifdef DC_HICOLOR
        pContext->pSDARect->bitsPerPixel = (UINT16)m_pTSWd->desktopBpp;

        if (pContext->pSDARect->bitsPerPixel < 8) {
            pContext->pSDARect->bitsPerPixel = 8;
        }
#else
        pContext->pSDARect->bitsPerPixel = 8;
#endif

        // Set up the data in the transfer buffer.
        pPrevSrc = pSrc;
        SDGPrepareData(&pSrc, rectWidth, paddedWidthInBytes,
                transferHeight, frameBufferWidth);

        // The compression algorithm does not deal well with very small
        // buffers.
        if (transferHeight > 1 || paddedWidthInPels > 12) {
            // Try to compress the bitmap directly into the network packet.
            // First we try to compress with the data size based on how well
            // we expect it to compress.
            buffSpaceLeft = min((unsigned)SDG_SPACE_LEFT,
                    uncompressedBitmapSize);
#ifdef DC_HICOLOR

            compRc = BC_CompressBitmap(
                             m_pShm->sdgTransferBuffer,
                             pContext->pSDARect->bitmapData,
                             NULL,
                             buffSpaceLeft,
                             &compressedBitmapSize,
                             paddedWidthInPels,
                             transferHeight,
                             m_pTSWd->desktopBpp);
#else
            compRc = BC_CompressBitmap(m_pShm->sdgTransferBuffer,
                    pContext->pSDARect->bitmapData, buffSpaceLeft,
                    &compressedBitmapSize, paddedWidthInPels,
                    transferHeight);
#endif
            if (compRc) {
                // We have successfully compressed the bitmap data.
                pContext->pSDARect->compressedFlag = TRUE;

                // Indicates if this SDA data includes BC header or not.
                pContext->pSDARect->compressedFlag |=
                        m_pShm->bc.noBitmapCompressionHdr;

                TRC_NRM((TB, "1st pass compr of %u x %u, size %u -> %u",
                        transferHeight, paddedWidthInPels,
                        uncompressedBitmapSize, compressedBitmapSize));

                goto COMPRESSION_DONE;
            }

            // Compression failed - may be because the data didn't compress
            // quite as well as we thought it would and hence didn't fit into
            // the buffer, so we'll try again.
            // Copy as many lines as possible into the PDU. Code above means
            // there must be room for a line.
            TRC_NRM((TB, "Failed compress bitmap size %u (%u rows) - " \
                    "try smaller chunk", uncompressedBitmapSize,
                    transferHeight));

            maxRowsLeft = (unsigned)SDG_SPACE_LEFT / paddedWidthInBytes;
            TRC_ASSERT((maxRowsLeft > 0),
                     (TB, "No room for a row, space %u, width %u",
                     SDG_SPACE_LEFT, paddedWidthInBytes));

            transferHeight = min((unsigned)rectHeight, maxRowsLeft);
            uncompressedBitmapSize = transferHeight * paddedWidthInBytes;
            TRC_DBG((TB, "Retry with %u rows", transferHeight));

            // Set up the new data in the transfer buffer.
            pSrc = pPrevSrc;
            SDGPrepareData(&pSrc, rectWidth, paddedWidthInBytes,
                    transferHeight, frameBufferWidth);

            // Try to compress the bitmap directly into the network packet.
            buffSpaceLeft = min((unsigned)SDG_SPACE_LEFT,
                    uncompressedBitmapSize);
#ifdef DC_HICOLOR
            compRc = BC_CompressBitmap(m_pShm->sdgTransferBuffer,
                    pContext->pSDARect->bitmapData, NULL, buffSpaceLeft,
                    &compressedBitmapSize, paddedWidthInPels,
                    transferHeight, m_pTSWd->desktopBpp);
#else
            compRc = BC_CompressBitmap(m_pShm->sdgTransferBuffer,
                    pContext->pSDARect->bitmapData, buffSpaceLeft,
                    &compressedBitmapSize, paddedWidthInPels, transferHeight);
#endif
            if (compRc) {
                TRC_NRM((TB,
                        "2nd pass compr %u x %u, size %u -> %u",
                        transferHeight, paddedWidthInPels,
                        uncompressedBitmapSize, compressedBitmapSize));
                pContext->pSDARect->compressedFlag = TRUE;

                // Indicates if this SDA data includes BC header or not.
                pContext->pSDARect->compressedFlag |=
                        m_pShm->bc.noBitmapCompressionHdr;

                goto COMPRESSION_DONE;
            }

            // The compression really really failed so just copy the
            // uncompressed data from the sdgTransferBuffer to the packet and
            // send it uncompressed.
            TRC_NRM((TB, "Really failed to compress bitmap size(%u)",
                    uncompressedBitmapSize));
            TRC_NRM((TB, "Copy %u x %u, size %u",
                    transferHeight, paddedWidthInPels, uncompressedBitmapSize));
            goto NoCompression;
        }
        else {
            // Small buffer, no compression applied.
            // So we just copy the uncompressed data from the sdgTransferBuffer
            // to the packet and send it uncompressed.
            TRC_NRM((TB, "first time copy of %u rows by %u columns, size %u",
                    transferHeight, paddedWidthInPels, uncompressedBitmapSize));

NoCompression:
            pContext->pSDARect->compressedFlag = FALSE;
            memcpy(pContext->pSDARect->bitmapData,
                    m_pShm->sdgTransferBuffer,
                    uncompressedBitmapSize);

            // Init the compressed data size to the uncompressed size.
            compressedBitmapSize = uncompressedBitmapSize;
        }

COMPRESSION_DONE:
        // Write the size of the data into the header. Be sure compressedSize
        // has been set up, even if uncompressed.
        pContext->pSDARect->bitmapLength = (UINT16)compressedBitmapSize;

        // Now we know the height actually used, we can fill in the rest of
        // the SDA header.
        pContext->pSDARect->height = (UINT16)transferHeight;
        pContext->pSDARect->destBottom =
                (INT16)(pRect->top + (transferHeight - 1));

        TRC_NRM((TB, "Add rect %d: (%d,%d)(%d,%d) %u(%u->%u bytes)",
                pContext->pBitmapPDU->numberRectangles,
                pContext->pSDARect->destLeft,
                pContext->pSDARect->destTop,
                pContext->pSDARect->destRight,
                pContext->pSDARect->destBottom,
                pContext->pSDARect->compressedFlag,
                uncompressedBitmapSize,
                compressedBitmapSize));

        // Update the compression statistics.
        sdgUncompTotal += uncompressedBitmapSize;
        sdgCompTotal += compressedBitmapSize;
        if (sdgUncompTotal >= SDG_SAMPLE_SIZE) {
            // Compression estimate is average # of bytes that
            // SCH_UNCOMP_BYTES bytes of uncomp data compress to.
            compEst = SCH_UNCOMP_BYTES * sdgCompTotal / sdgUncompTotal;
            TRC_ASSERT((compEst <= 1024),(TB,"Screen data compression "
                    "estimate out of range - %u", compEst));
            sdgCompTotal = 0;
            sdgUncompTotal = 0;
            if (compEst < SCH_COMP_LIMIT)
                compEst = SCH_COMP_LIMIT;

            SCH_UpdateBACompressionEst(compEst);

            TRC_NRM((TB, "New BA compression estimate %lu", compEst));
        }

        // Update variables to reflect the chunk of data we successfully sent.
        rectHeight -= transferHeight;
        pRect->top += transferHeight;

        // Update the SDA pointer. Add the TS_BITMAP_DATA header plus the
        // actual bitmap bits.
        cbAdded = (unsigned)FIELDOFFSET(TS_BITMAP_DATA, bitmapData[0]) +
                pContext->pSDARect->bitmapLength;
        pContext->pSDARect = (TS_BITMAP_DATA UNALIGNED *)
                ((BYTE *)pContext->pSDARect + cbAdded);
        TRC_DBG((TB, "pSDARect = %p", pContext->pSDARect));
    } /* ... while (rectHeight > 0) */

    // The entire rectangle was consumed if we managed to pack in all the rows.
    // For shadowing, we want to indicate if more work is required to finish
    rc = (rectHeight == 0);

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
// SDGPrepareData
//
// Copies a bitmap rectangle from the screen buffer to sdgTransferBuffer.
/****************************************************************************/
void RDPCALL SHCLASS SDGPrepareData(
        BYTE     **ppSrc,
        int      rectWidth,
        int      paddedRectWidth,
        unsigned transferHeight,
        unsigned frameBufferWidth)
{
    PBYTE pDst;
    PBYTE pEnd4, pDst4, pSrc4;
    unsigned row;
    unsigned numPadBytes;
    unsigned lineWidth;
    PBYTE pSrc = *ppSrc;

    DC_BEGIN_FN("SDGPrepareData");

    // We need to copy the data from the Frame Buffer into the
    // sdgTransferBuffer so that each of the rectangle rows to be sent are
    // contiguous in memory.
    // However, we also need to flip the bitmap vertically to convert from
    // the top-down format of the frame buffer to the bottom-up format of
    // the PDU bitmap data.  We therefore set pDst to point to the address
    // of the beginning of the last row (in memory) of the bitmap within
    // the Transfer Buffer and the code below moves it back through memory
    // as we copy each row of source data.
#ifdef DC_HICOLOR
    pDst = m_pShm->sdgTransferBuffer + paddedRectWidth * (transferHeight - 1);
    if (m_pTSWd->desktopBpp == 8)
        lineWidth = frameBufferWidth;
    else if (m_pTSWd->desktopBpp == 24)
        lineWidth = frameBufferWidth * 3;
    else if ((m_pTSWd->desktopBpp == 16) || (m_pTSWd->desktopBpp == 15))
        lineWidth = frameBufferWidth * 2;
    else if (m_pTSWd->desktopBpp == 4)
        lineWidth = frameBufferWidth / 2;
#else
    pDst = m_pShm->sdgTransferBuffer + (paddedRectWidth * (transferHeight-1));
    lineWidth = (m_pTSWd->desktopBpp == 4) ? (frameBufferWidth / 2)
                                           : frameBufferWidth;
#endif
    TRC_NRM((TB, "FB width %d, line width %d, Bpp %d",
            frameBufferWidth, lineWidth, m_pTSWd->desktopBpp));

    // Copy the data into the Transfer Buffer, reformatting it as we go.
    if (m_pTSWd->desktopBpp == 8) {
        for (row = 0; row < transferHeight; row++) {
            memcpy(pDst, pSrc, rectWidth);
            pSrc += lineWidth;
            pDst -= paddedRectWidth;
        }
    }
#ifdef DC_HICOLOR
    else if (m_pTSWd->desktopBpp == 24) {
        TRC_NRM((TB, "Copy %d rows of %d pels, line w %d, prw %d",
                  transferHeight, rectWidth, lineWidth, paddedRectWidth));
        for (row = 0; row < transferHeight; row++)
        {
            memcpy(pDst, pSrc, 3 * rectWidth);
            pSrc += lineWidth;
            pDst -= paddedRectWidth;
        }
    }
    else if ((m_pTSWd->desktopBpp == 15) || (m_pTSWd->desktopBpp == 16)) {
        TRC_NRM((TB, "Copy %d rows of %d pels, line w %d, prw %d",
                  transferHeight, rectWidth, lineWidth, paddedRectWidth));
        for (row = 0; row < transferHeight; row++)
        {
            memcpy(pDst, pSrc, 2 * rectWidth);
            pSrc += lineWidth;
            pDst -= paddedRectWidth;
        }
    }
#endif
    else {
        for (row = 0; row < transferHeight; row++) {
            pEnd4 = pDst + rectWidth;
            for (pDst4 = pDst, pSrc4 = pSrc; pDst4 < pEnd4; pDst4++, pSrc4++) {
                *pDst4 = (*pSrc4 >> 4) & 0xf;
                pDst4++;
                *pDst4 = *pSrc4 & 0xf;
            }
            pSrc += lineWidth;
            pDst -= paddedRectWidth;
        }
    }

    // Zero the pad bytes on the end of each row (this aids compression).
    // Split each case out separately to aid performance (rather than the
    // alternative of testing numPadBytes within every iteration of a for
    // loop). Set pDst to the first pad byte in the first row.
#ifdef DC_HICOLOR
    pDst = m_pShm->sdgTransferBuffer +
            (rectWidth * ((m_pTSWd->desktopBpp + 7) / 8));
    numPadBytes = (unsigned)(paddedRectWidth -
            (rectWidth * ((m_pTSWd->desktopBpp + 7) / 8)));
#else
    pDst = m_pShm->sdgTransferBuffer + rectWidth;
    numPadBytes = (unsigned)(paddedRectWidth - rectWidth);
#endif
    switch (numPadBytes) {
        case 0:
            // No padding required.
            break;

        case 1:
            // 1 byte padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *pDst = 0;
                pDst += paddedRectWidth;
            }
            break;

        case 2:
            // 2 bytes padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *((PUINT16_UA)pDst) = 0;
                pDst += paddedRectWidth;
            }
            break;

        case 3:
            // 3 bytes padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *((PUINT16_UA)pDst) = 0;
                *(pDst + 2) = 0;
                pDst += paddedRectWidth;
            }
            break;

#ifdef DC_HICOLOR
        case 4:
            // 4 bytes padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *((PUINT32_UA)pDst) = 0;
                pDst += paddedRectWidth;
            }
            break;

        case 6:
            // 6 bytes padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *((PUINT32_UA)pDst)       = 0;
                *((PUINT16_UA)(pDst + 4)) = 0;
                pDst += paddedRectWidth;
            }
            break;

        case 9:
            // 9 bytes padding per row required.
            for (row = 0; row < transferHeight; row++) {
                *((PUINT32_UA)pDst)     = 0;
                *((PUINT32_UA)(pDst+4)) = 0;
                *(pDst + 8)             = 0;
                pDst += paddedRectWidth;
            }
            break;
#endif

        default:
#ifdef DC_HICOLOR
            TRC_ALT((TB, "Invalid numPadBytes %u, rect %u, p/rect %u",
                     numPadBytes, rectWidth, paddedRectWidth));
#else
            TRC_ABORT((TB, "Invalid numPadBytes: %u", numPadBytes));
#endif
            break;
    }

    // All done - update the supplied source pointer.
    *ppSrc = pSrc;

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nwdwint.c ===
/****************************************************************************/
// nwdwint.c
//
// RDP WD code.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define pTRCWd pTSWd
#define TRC_FILE "nwdwint"
#include <adcg.h>

#include <randlib.h>
#include <pchannel.h>
#include <anmapi.h>
#include <asmint.h>
#include <nwdwapi.h>
#include <nwdwioct.h>
#include <nwdwint.h>

#include <nwdwdata.c>

#include <asmint.h>
#include <anmint.h>
#include <tsperf.h>

//
// RNG api doesn't refcount it's shutdown so do it for them
//
LONG g_RngUsers = 0;


/****************************************************************************/
/* Name:      WDWLoad                                                       */
/*                                                                          */
/* Purpose:   Load WinStation driver                                        */
/*                                                                          */
/* Params:    INOUT  pContext - pointer to the SD context structure         */
/****************************************************************************/
NTSTATUS WDWLoad(PSDCONTEXT pContext)
{
    NTSTATUS   Status;
    PTSHARE_WD pTSWd;
    unsigned   smnmBytes;
    unsigned   wdBytes;

    DC_BEGIN_FN("WDWLoad");

    /************************************************************************/
    /* WARNING: Don't trace in this function, it will cause ICADD to crash, */
    /* as the stack context hasn't been set up properly until we return     */
    /* from this function.                                                  */
    /* Use KdPrint instead.                                                 */
    /************************************************************************/

    // Initialize Calldown and callup procedures.
    pContext->pProcedures = (PSDPROCEDURE)G_pWdProcedures;
    pContext->pCallup = (SDCALLUP *)G_pWdCallups;

    // Do a quick sanity check on the SHM size to alert of bad paging
    // characteristics.
    wdBytes = sizeof(SHM_SHARED_MEMORY);
#ifdef DC_DEBUG
    wdBytes -= sizeof(TRC_SHARED_DATA);
#endif
    if ((wdBytes % PAGE_SIZE) < (PAGE_SIZE / 8))
        KdPrintEx((DPFLTR_TERMSRV_ID, 
                  DPFLTR_INFO_LEVEL, 
                  "RDPWD: **** Note SHM_SHARED_MEMORY fre size is wasting "
                "at least 7/8 of a page - page size=%u, SHM=%u, wasting %u\n",
                PAGE_SIZE, wdBytes, PAGE_SIZE - (wdBytes % PAGE_SIZE)));

    // Allocate WD data structure - first find out how many bytes are
    // needed by the SM/NM code.
    smnmBytes = SM_GetDataSize();
    wdBytes = DC_ROUND_UP_4(sizeof(TSHARE_WD));

    KdPrintEx((DPFLTR_TERMSRV_ID, 
              DPFLTR_INFO_LEVEL,
              "RDPWD: WDWLoad: Alloc TSWD=%d + NM/SM=%d (= %d) bytes for TSWd\n",
            wdBytes, smnmBytes, wdBytes + smnmBytes));
    if ((wdBytes + smnmBytes) >= PAGE_SIZE)
        KdPrintEx((DPFLTR_TERMSRV_ID,
                  DPFLTR_INFO_LEVEL,
                  "RDPWD: **** Note TSWd allocation is above page size %u, "
                "wasting %u\n", PAGE_SIZE,
                PAGE_SIZE - ((wdBytes + smnmBytes) % PAGE_SIZE)));

#ifdef DC_DEBUG
    // Preinit pTSWd for debug COM_Malloc.
    pTSWd = NULL;
#endif

    pTSWd = COM_Malloc(wdBytes + smnmBytes);
    if (pTSWd != NULL) {
        // Zero the allocated mem.
        memset(pTSWd, 0, wdBytes + smnmBytes);
    }
    else {
        KdPrintEx((DPFLTR_TERMSRV_ID,
                  DPFLTR_ERROR_LEVEL, 
                  "RDPWD: WDWLoad: Failed alloc TSWD\n"));
        Status = STATUS_NO_MEMORY;
        DC_QUIT;
    }

    //
    // Init the performance flags to non-perf-aware client setting.
    // We need this to differentiate between
    // non-experience-aware clients and xp clients.
    // We cannot use protocol versions as they are
    // are not being setup properly now.
    //
    pTSWd->performanceFlags = TS_PERF_DEFAULT_NONPERFCLIENT_SETTING;
    
    // Set up pointers both ways between PSDCONTEXT and PTSHARE_WD.
    // Note that we still can't yet trace.
    pTSWd->pSmInfo = ((BYTE *)pTSWd) + wdBytes;
    pTSWd->pNMInfo = (BYTE *)pTSWd->pSmInfo + sizeof(SM_HANDLE_DATA);

    KdPrintEx((DPFLTR_TERMSRV_ID,
              DPFLTR_INFO_LEVEL,
              "RDPWD: pTSWd=%p, pSM=%p, pNM=%p, sizeof(TSWd)=%u, sizeof(SM)=%u\n",
              pTSWd, pTSWd->pSmInfo, pTSWd->pNMInfo, sizeof(TSHARE_WD),
              sizeof(SM_HANDLE_DATA), sizeof(NM_HANDLE_DATA)));

    pTSWd->pContext = pContext;
    pContext->pContext = pTSWd;

    // Now allocate the RNS_INFO_PACKET as a separate allocation. InfoPkt
    // is large (~3K) and if included in TSHARE_WD pushes the TSWd
    // allocation over the Intel 4K page size, causing most of a second
    // page to be wasted. Since we can't get rid of the data (it's
    // referenced at various points in the normal and shadow connection
    // sequences), we alloc it separately to let the system sub-page
    // allocator use memory more effectively.
    KdPrintEx((DPFLTR_TERMSRV_ID,
              DPFLTR_INFO_LEVEL,
              "RDPWD: WDWLoad: Alloc %u bytes for InfoPkt\n",
            sizeof(RNS_INFO_PACKET)));
    if ((sizeof(RNS_INFO_PACKET)) >= PAGE_SIZE)
        KdPrintEx((DPFLTR_TERMSRV_ID,
                  DPFLTR_INFO_LEVEL,
                  "RDPWD: **** Note INFO_PACKET allocation is above "
                  "page size %u, wasting %u\n", PAGE_SIZE,
                  PAGE_SIZE - (sizeof(RNS_INFO_PACKET) % PAGE_SIZE)));
    pTSWd->pInfoPkt = COM_Malloc(sizeof(RNS_INFO_PACKET));
    if (pTSWd->pInfoPkt != NULL) {
        memset(pTSWd->pInfoPkt, 0, sizeof(RNS_INFO_PACKET));
    }
    else {
        KdPrintEx((DPFLTR_TERMSRV_ID,
                  DPFLTR_ERROR_LEVEL,
                  "RDPWD: WDWLoad: Failed alloc InfoPkt\n"));
        COM_Free(pTSWd);
        Status = STATUS_NO_MEMORY;
        DC_QUIT;
    }

    // Allocate and initialize the connEvent, createEvent, secEvent,
    // SessKeyEvent, and ClientDisconnectEvent. Use ExAllocatePool directly,
    // as COM_Malloc allocates paged memory, and these events must be in
    // non-paged memory.
    pTSWd->pConnEvent = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(KEVENT) * 5,
                                              WD_ALLOC_TAG);
    if (pTSWd->pConnEvent != NULL) {
        pTSWd->pCreateEvent = pTSWd->pConnEvent + 1;
        pTSWd->pSecEvent = pTSWd->pCreateEvent + 1;
        pTSWd->pSessKeyEvent = pTSWd->pSecEvent + 1;
        pTSWd->pClientDisconnectEvent = pTSWd->pSessKeyEvent + 1;

        KeInitializeEvent(pTSWd->pConnEvent, NotificationEvent, FALSE);
        KeInitializeEvent(pTSWd->pCreateEvent, NotificationEvent, FALSE);
        KeInitializeEvent(pTSWd->pSecEvent, NotificationEvent, FALSE);
        KeInitializeEvent(pTSWd->pSessKeyEvent, NotificationEvent, FALSE);
        KeInitializeEvent(pTSWd->pClientDisconnectEvent, NotificationEvent,
                FALSE);
    }
    else {
        KdPrintEx((DPFLTR_TERMSRV_ID,
                  DPFLTR_ERROR_LEVEL,
                  "RDPWD: Failed to allocate memory for WD events\n"));
        COM_Free(pTSWd->pInfoPkt);
        COM_Free(pTSWd);
        Status = STATUS_NO_MEMORY;
        DC_QUIT;
    }

    //
    // Init the random number generator
    //
    if (InitializeRNG(NULL)) {
        InterlockedIncrement(&g_RngUsers);
    }

    Status = STATUS_SUCCESS;

    KdPrintEx((DPFLTR_TERMSRV_ID,
              DPFLTR_INFO_LEVEL,
              "RDPWD: WDWLoad done\n"));

DC_EXIT_POINT:
    DC_END_FN();
    return Status;
}


/****************************************************************************/
/* Name:      WDWUnload                                                     */
/*                                                                          */
/* Purpose:   Unload WinStation driver                                      */
/*                                                                          */
/* Params:    INOUT  pContext - pointer to the SD context structure         */
/****************************************************************************/
NTSTATUS WDWUnload( PSDCONTEXT pContext )
{
    PTSHARE_WD pTSWd;

    /************************************************************************/
    /* Get pointers to WD data structures                                   */
    /************************************************************************/
    pTSWd = (PTSHARE_WD)pContext->pContext;
    if (pTSWd != NULL) {
        // Free connEvent & createEvent.
        if (NULL != pTSWd->pConnEvent)
            ExFreePool(pTSWd->pConnEvent);

        // Free the InfoPkt.
        if (pTSWd->pInfoPkt != NULL)
            COM_Free(pTSWd->pInfoPkt);

        // Free TSWd itself.
        COM_Free(pTSWd);
    }

    /************************************************************************/
    /* Clear context structure                                              */
    /************************************************************************/
    pContext->pContext    = NULL;
    pContext->pProcedures = NULL;
    pContext->pCallup     = NULL;

    //
    // Shutdown the random number generator
    //
    if (0L == InterlockedDecrement(&g_RngUsers)) {
        ShutdownRNG(NULL);
    }

    return STATUS_SUCCESS;
}


/****************************************************************************/
/* Name:      WDWConnect                                                    */
/*                                                                          */
/* Purpose:   Processes a conference connect request from the WD.  It is    */
/*            used by connects from TShareSrv as well as shadow connects.   */
/*                                                                          */
/* Params:    IN    pTSWd            - pointer to WD struct                 */
/*            IN    PRNS_UD_CS_CORE  - Client Core Data                     */
/*            IN    PRNS_UD_CS_SEC   - Client Security Data                 */
/*            IN    PRNS_UD_CS_NET   - Client Net Data                      */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl this will be one */
/*                               of IOCTL_TSHARE_CONF_CONNECT or            */
/*                               IOCTL_ICA_SET_CONNECTED(shadow)            */
/*                                                                          */
/* Operation: Parse the user data for core, security, and network bits.     */
/*            Pull the values we want out of the core piece                 */
/*            Initialize the Security Manager                               */
/*            Create a share core, passing in the key values from user data */
/*            Tell the user manager to proceed with connecting              */
/****************************************************************************/
NTSTATUS WDWConnect(
        PTSHARE_WD pTSWd,
        PRNS_UD_CS_CORE pClientCoreData,
        PRNS_UD_CS_SEC pClientSecurityData,
        PRNS_UD_CS_NET pClientNetData,
        PTS_UD_CS_CLUSTER pClientClusterData,
        PSD_IOCTL pSdIoctl,
        BOOLEAN bOldShadow)
{
    NTSTATUS status = STATUS_SUCCESS;
    BOOL smInit = FALSE;

    DC_BEGIN_FN("WDWConnect");

    // Get the required values from the core user data.
    pTSWd->version = pClientCoreData->version;
    pTSWd->desktopWidth = pClientCoreData->desktopWidth;
    pTSWd->desktopHeight = pClientCoreData->desktopHeight;

    // We only support 4096 x 2048
    if (pTSWd->desktopHeight > 2048)
        pTSWd->desktopHeight = 2048;
    if (pTSWd->desktopWidth > 4096)
        pTSWd->desktopWidth = 4096;

    // Checks the client software for compatibility and rejects if not
    // equivalent to server software.
    TRC_NRM((TB, "Client version is %#lx", pClientCoreData->version));
    if (_RNS_MAJOR_VERSION(pClientCoreData->version) != RNS_UD_MAJOR_VERSION) {
        TRC_ERR((TB, "Unmatching software version, expected %#lx got %#lx",
                RNS_UD_VERSION, pClientCoreData->version));
        status = RPC_NT_INVALID_VERS_OPTION;
        DC_QUIT;
    }

    
    if(pClientCoreData->header.length >=
            (FIELDOFFSET(RNS_UD_CS_CORE, earlyCapabilityFlags) +
             FIELDSIZE(RNS_UD_CS_CORE, earlyCapabilityFlags))) {
        //
        // Does client support extended error reporting PDU
        //
        pTSWd->bSupportErrorInfoPDU = (pClientCoreData->earlyCapabilityFlags &
                                       RNS_UD_CS_SUPPORT_ERRINFO_PDU) ?
                                       TRUE : FALSE;        
    }
    else
    {
        pTSWd->bSupportErrorInfoPDU = FALSE;
    }
    TRC_NRM((TB, "ErrorInfoPDU supported = %d", pTSWd->bSupportErrorInfoPDU));
    
#ifdef DC_HICOLOR
    // Work out high color support.
    if (pClientCoreData->header.length >=
            (FIELDOFFSET(RNS_UD_CS_CORE, supportedColorDepths) +
             FIELDSIZE(RNS_UD_CS_CORE, supportedColorDepths))) {
        long maxServerBpp;
        long limitedBpp;

        // Store off the supported color depths.
        pTSWd->supportedBpps = pClientCoreData->supportedColorDepths;

        // Client may want other than 4 or 8bpp, so lets see what we can
        // do. First up is to see what limits are imposed at this end.
        maxServerBpp = pTSWd->maxServerBpp;

        TRC_NRM((TB, "Client requests color depth %u, server limit %d",
                pClientCoreData->highColorDepth, maxServerBpp));

        // Now see if we can allow the requested value.
        if (pClientCoreData->highColorDepth > maxServerBpp) {
            TRC_NRM((TB, "Limiting requested color depth..."));
            switch (maxServerBpp) {
                case 16:
                    if (pClientCoreData->supportedColorDepths &
                            RNS_UD_16BPP_SUPPORT) {
                        limitedBpp = 16;
                        break;
                    }
                    // deliberate fall through!

                case 15:
                    if (pClientCoreData->supportedColorDepths &
                            RNS_UD_15BPP_SUPPORT) {
                        limitedBpp = 15;
                        break;
                    }
                    // deliberate fall through!

                default:
                    limitedBpp = 8;
                    break;
            }

            TRC_ALT((TB, "Restricted requested color depth %d to %d",
                              pClientCoreData->highColorDepth, maxServerBpp));
            pClientCoreData->highColorDepth = (UINT16)limitedBpp;
        }

        // Now set up the proper color depth from the (possibly
        // restricted) high color value.
        if (pClientCoreData->highColorDepth == 24)
            pClientCoreData->colorDepth = RNS_UD_COLOR_24BPP;
        else if (pClientCoreData->highColorDepth == 16)
            pClientCoreData->colorDepth = RNS_UD_COLOR_16BPP_565;
        else if (pClientCoreData->highColorDepth == 15)
            pClientCoreData->colorDepth = RNS_UD_COLOR_16BPP_555;
        else if (pClientCoreData->highColorDepth == 4)                  
            pClientCoreData->colorDepth = RNS_UD_COLOR_4BPP;               
        else
            pClientCoreData->colorDepth = RNS_UD_COLOR_8BPP;
    }
    else {

        // No hicolor support.
        pTSWd->supportedBpps = 0;
#endif

        // A beta2 Server rejects Clients with a color depth of 4bpp.
        // Therefore a new field, postBeta2ColorDepth, is added, which can be
        // 4bpp. If this field exists, use it instead of colorDepth.
        if (pClientCoreData->header.length >=
                (FIELDOFFSET(RNS_UD_CS_CORE, postBeta2ColorDepth) +
                 FIELDSIZE(RNS_UD_CS_CORE, postBeta2ColorDepth))) {
            TRC_NRM((TB, "Post-beta2 color depth id %#x",
                    pClientCoreData->postBeta2ColorDepth));
            pClientCoreData->colorDepth = pClientCoreData->postBeta2ColorDepth;
        }
#ifdef DC_HICOLOR
    }
#endif

    if (pClientCoreData->colorDepth == RNS_UD_COLOR_8BPP) {
        TRC_NRM((TB, "8 BPP"));
        pTSWd->desktopBpp = 8;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_4BPP) {
        TRC_NRM((TB, "4 BPP"));
        pTSWd->desktopBpp = 4;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_16BPP_555) {
#ifdef DC_HICOLOR
        TRC_NRM((TB, "15 BPP (16 BPP, 555)"));
        pTSWd->desktopBpp = 15;
#else
        // May want to save whether it's 555 or 565.
        TRC_NRM((TB, "16 BPP 555"));
        pTSWd->desktopBpp = 16;
#endif
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_16BPP_565) {
#ifdef DC_HICOLOR
        TRC_NRM((TB, "16 BPP (565)"));
#else
        TRC_NRM((TB, "16 BPP 565"));
#endif
        pTSWd->desktopBpp = 16;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_24BPP) {
        TRC_NRM((TB, "24 BPP"));
        pTSWd->desktopBpp = 24;
    }
    else {
        TRC_ERR((TB, "Unknown BPP %x returned by client",
                pClientCoreData->colorDepth));
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    pTSWd->sas = pClientCoreData->SASSequence;
    pTSWd->kbdLayout = pClientCoreData->keyboardLayout;
    pTSWd->clientBuild = pClientCoreData->clientBuild;
    //    here we don't copy the last character in the buffer because 
    //    we force zero termination later by writting a 0 at the end;
    memcpy(pTSWd->clientName, pClientCoreData->clientName, 
                   sizeof(pTSWd->clientName)-sizeof(pTSWd->clientName[0]));
    pTSWd->clientName[sizeof(pTSWd->clientName)
                                        / sizeof(pTSWd->clientName[0]) - 1] = 0;
    
    

    pTSWd->keyboardType = pClientCoreData->keyboardType;
    pTSWd->keyboardSubType = pClientCoreData->keyboardSubType;
    pTSWd->keyboardFunctionKey = pClientCoreData->keyboardFunctionKey;
    //    here we don't copy the last character in the buffer because 
    //    we force zero termination later by writting a 0 at the end;
    memcpy(pTSWd->imeFileName, pClientCoreData->imeFileName, 
                   sizeof(pTSWd->imeFileName)-sizeof(pTSWd->imeFileName[0]));
    pTSWd->imeFileName[sizeof(pTSWd->imeFileName)
                                       / sizeof(pTSWd->imeFileName[0]) - 1] = 0;

    pTSWd->clientDigProductId[0] = 0;

    // Win2000 Post Beta 3 fields added
    if (pClientCoreData->header.length >=
            (FIELDOFFSET(RNS_UD_CS_CORE, serialNumber) + 
             FIELDSIZE(RNS_UD_CS_CORE, serialNumber))) {
        pTSWd->clientProductId = pClientCoreData->clientProductId;
        pTSWd->serialNumber = pClientCoreData->serialNumber;
            //shadow loop fix
            if (pClientCoreData->header.length >=  
                            (FIELDOFFSET(RNS_UD_CS_CORE, clientDigProductId) + 
                            FIELDSIZE(RNS_UD_CS_CORE, clientDigProductId))) {
               //    here we don't copy the last character in the buffer because 
               //    we force zero termination later by writting a 0 at the end;
               memcpy( pTSWd->clientDigProductId, 
                       pClientCoreData->clientDigProductId, 
                       sizeof(pTSWd->clientDigProductId)
                       -sizeof(pTSWd->clientDigProductId[0]));
               pTSWd->clientDigProductId[sizeof(pTSWd->clientDigProductId)
                                 / sizeof(pTSWd->clientDigProductId[0]) -1] = 0;           
            }
            
          
    }

    // Parse and store the client's cluster support info, if provided.
    // If not present, the memset here will implicitly set FALSE the flags
    // for the client cluster capabilities. Note we do not have the
    // username and domain available yet (it comes in the info packet
    // later) so we cannot fill out the username and domain yet.
    if (pClientClusterData != NULL) {
        if (pClientClusterData->Flags & TS_CLUSTER_REDIRECTION_SUPPORTED) {
            TRC_NRM((TB,"Client supports load balance redirection"));
            pTSWd->bClientSupportsRedirection = TRUE;
        }
        if (pClientClusterData->Flags &
                TS_CLUSTER_REDIRECTED_SESSIONID_FIELD_VALID) {
            TRC_NRM((TB,"Client has been load-balanced to this server, "
                    "sessid=%u", pClientClusterData->RedirectedSessionID));
            pTSWd->bRequestedSessionIDFieldValid = TRUE;
            pTSWd->RequestedSessionID =
                    pClientClusterData->RedirectedSessionID;
            if (pClientClusterData->Flags & TS_CLUSTER_REDIRECTED_SMARTCARD) {
                pTSWd->bUseSmartcardLogon = TRUE;
            }
        }

        // The 2..5 bits (start from 0) are the PDU version
        pTSWd->ClientRedirectionVersion = ((pClientClusterData->Flags & 0x3C) >> 2);
        
    }

    // Create a new share object.
    status = WDWNewShareClass(pTSWd);
    if (!NT_SUCCESS(status)) {
        TRC_ERR((TB, "Failed to get a new Share Object - quit"));
        DC_QUIT;
    }

    // Bring up SM.
    status = SM_Init(pTSWd->pSmInfo, pTSWd, bOldShadow);
    if (NT_SUCCESS(status)) {
        smInit = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to init SM, rc %lu", status));
        DC_QUIT;
    }

    // Hook the IOCtl off the WD structure to allow the SM callback to
    // process it.
    // Also NULL the output buffer - this is solely to allow us to assert
    // (later) that the callback has in fact been taken.
    TRC_ASSERT((pTSWd->pSdIoctl == NULL),
            (TB,"Already an IOCTL linked from pTSWd"));
    pTSWd->pSdIoctl = pSdIoctl;
    if ((pSdIoctl->IoControlCode == IOCTL_TSHARE_CONF_CONNECT) &&
            pSdIoctl->OutputBuffer) {
        ((PUSERDATAINFO)pSdIoctl->OutputBuffer)->ulUserDataMembers = 0;
    }

    // Tell SM we're done here.
    status = SM_Connect(pTSWd->pSmInfo, pClientSecurityData, pClientNetData,
            bOldShadow);
    if (status != STATUS_SUCCESS) {
        TRC_ERR((TB, "SM_Connect failed: rc=%lx", status));
        DC_QUIT;
    }

    /************************************************************************/
    /* The scheduling is such that we are guaranteed that the connecting    */
    /* status will have been received from SM before the previous call      */
    /* returns.  Just for safety we assert that this is so!                 */
    /************************************************************************/
    if ((pSdIoctl->IoControlCode == IOCTL_TSHARE_CONF_CONNECT) &&
        pSdIoctl->OutputBuffer) {
        TRC_ASSERT((((PUSERDATAINFO)pSdIoctl->OutputBuffer)->ulUserDataMembers
                                                                         != 0),
            (TB,"We didn't get callback from SM - BAD NEWS"));
    }

DC_EXIT_POINT:
    // Clean up anything we created if we failed.
    if (status == STATUS_SUCCESS) {
        pTSWd->pSdIoctl = NULL;
    }
    else {
        TRC_NRM((TB, "Cleaning up..."));
        if (pTSWd->dcShare != NULL) {
            TRC_NRM((TB, "Deleting Share object"));
            WDWDeleteShareClass(pTSWd);
        }
        if (smInit) {
            TRC_NRM((TB, "Terminating SM"));
            SM_Term(pTSWd->pSmInfo);
        }
    }

    DC_END_FN();
    return status;
} /* WDWConnect */


/****************************************************************************/
/* Name:      WDWConfConnect                                                */
/*                                                                          */
/* Purpose:   Processes a TSHARE_CONF_CONNECT IOCtl from TShareSRV          */
/*                                                                          */
/* Params:    IN    pTSWd        - pointer to WD struct                     */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Parse the user data for core bits and SM bits.                */
/*            pull the values we want out of the core piece                 */
/*            initialize the Security Manager                               */
/*            create a share core, passing in the key values from user data */
/*            tell the user manager to proceed with connecting              */
/****************************************************************************/
NTSTATUS WDWConfConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    unsigned DataLen;
    PRNS_UD_CS_CORE pClientCoreData;
    PRNS_UD_CS_SEC  pClientSecurityData;
    PRNS_UD_CS_NET  pClientNetData;
    PTS_UD_CS_CLUSTER pClientClusterData;

    DC_BEGIN_FN("WDWConfConnect");

    // First make sure we've received enough data for the initial headers
    // and that the sizes presented in the data block are valid. An attacker
    // might try sending malformed data here to fault the server.
    DataLen = pSdIoctl->InputBufferLength;
    if (sizeof(USERDATAINFO)>DataLen) {
        TRC_ERR((TB,"Apparent attack via user data, size %u too small for UD hdr",
                DataLen));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_BadUserData, pSdIoctl->InputBuffer,
                DataLen);
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    if (((PUSERDATAINFO)pSdIoctl->InputBuffer)->cbSize > DataLen) {
        TRC_ERR((TB,"Apparent attack via user data, the cbSize is set to a length bigger then the total buffer %u",
                ((PUSERDATAINFO)pSdIoctl->InputBuffer)->cbSize > DataLen));
        WDW_LogAndDisconnect(pTSWd, TRUE, Log_RDP_BadUserData, pSdIoctl->InputBuffer,
                DataLen);
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }
    
    // Validate that the output buffer is big enough.
    if ((pSdIoctl->OutputBuffer == NULL) || 
        (pSdIoctl->OutputBufferLength < MIN_USERDATAINFO_SIZE)) {
            TRC_ERR((TB, "No Out Buffer on TSHARE_CONF_CONNECT."));
            status = STATUS_BUFFER_TOO_SMALL;
            DC_QUIT;
    }

    if (((PUSERDATAINFO)pSdIoctl->OutputBuffer)->cbSize < MIN_USERDATAINFO_SIZE) {
            // Buffer has been supplied but is too small, - so tell
            // TShareSRV how big a buffer we actually need.
            
            ((PUSERDATAINFO)pSdIoctl->OutputBuffer)->cbSize = MIN_USERDATAINFO_SIZE;

            TRC_ERR((TB, "Telling TShareSRV to have another go with %d",
                    MIN_USERDATAINFO_SIZE));
            
            status = STATUS_BUFFER_TOO_SMALL;
            DC_QUIT;
    }

    // Parse the input data.
    if (WDWParseUserData(pTSWd, (PUSERDATAINFO)pSdIoctl->InputBuffer, DataLen,
            NULL, 0, &pClientCoreData, &pClientSecurityData,
            &pClientNetData, &pClientClusterData)) {
        status = WDWConnect(pTSWd, pClientCoreData, pClientSecurityData,
                pClientNetData, pClientClusterData, pSdIoctl, FALSE);
    }
    else {
        status = STATUS_UNSUCCESSFUL;
        TRC_ERR((TB, "Could not parse the user data successfully"));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return status;
} /* WDWConfConnect */


/****************************************************************************/
/* Name:      WDWConsoleConnect                                             */
/*                                                                          */
/* Purpose:   Processes a TSHARE_CONSOLE_CONNECT IOCtl from TShareSRV       */
/*                                                                          */
/* Params:    IN    pTSWd        - pointer to WD struct                     */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Parse the user data for core bits and SM bits.                */
/*            pull the values we want out of the core piece                 */
/*            initialize the Security Manager                               */
/*            create a share core, passing in the key values from user data */
/*            tell the user manager to proceed with connecting              */
/****************************************************************************/
NTSTATUS WDWConsoleConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS        status = STATUS_SUCCESS;
    PUSERDATAINFO   pUserInfo;
    PRNS_UD_CS_CORE pClientCoreData;

    BOOL smInit = FALSE;

    DC_BEGIN_FN("WDWConsoleConnect");

    /************************************************************************/
    /* get the Client data from the IOCTL                                   */
    /************************************************************************/
    pUserInfo       = (PUSERDATAINFO)(pSdIoctl->InputBuffer);
    pClientCoreData = (PRNS_UD_CS_CORE)(pUserInfo->rgUserData);

    /************************************************************************/
    /* version info                                                         */
    /************************************************************************/
    pTSWd->version = pClientCoreData->version;

    /************************************************************************/
    /* Set up the desktop size                                              */
    /************************************************************************/
    pTSWd->desktopWidth  = pClientCoreData->desktopWidth;
    pTSWd->desktopHeight = pClientCoreData->desktopHeight;

#ifdef DC_HICOLOR
    /************************************************************************/
    /* And the color depth                                                  */
    /************************************************************************/
    if (pClientCoreData->colorDepth == RNS_UD_COLOR_8BPP)
    {
        pTSWd->desktopBpp = 8;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_4BPP)
    {
        pTSWd->desktopBpp = 4;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_16BPP_555)
    {
        pTSWd->desktopBpp = 15;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_16BPP_565)
    {
        pTSWd->desktopBpp = 16;
    }
    else if (pClientCoreData->colorDepth == RNS_UD_COLOR_24BPP)
    {
        pTSWd->desktopBpp = 24;
    }
    else
    {
        TRC_ERR((TB, "Unknown BPP %x returned by client",
                pClientCoreData->colorDepth));
        pTSWd->desktopBpp = 8;
    }

    pTSWd->supportedBpps = pClientCoreData->supportedColorDepths;

    TRC_ALT((TB, "Console at %d bpp", pTSWd->desktopBpp));
#else
    /************************************************************************/
    /* always 8bpp                                                          */
    /************************************************************************/
    pTSWd->desktopBpp = 8;
#endif

    /************************************************************************/
    /* @@@ Need to set these up in RDPWSX first                             */
    /************************************************************************/
    // pTSWd->sas         = pClientCoreData->SASSequence;
    // pTSWd->kbdLayout   = pClientCoreData->keyboardLayout;
    // pTSWd->clientBuild = pClientCoreData->clientBuild;
    // wcscpy(pTSWd->clientName, pClientCoreData->clientName);
    //
    // pTSWd->keyboardType        = pClientCoreData->keyboardType;
    // pTSWd->keyboardSubType     = pClientCoreData->keyboardSubType;
    // pTSWd->keyboardFunctionKey = pClientCoreData->keyboardFunctionKey;
    // wcscpy(pTSWd->imeFileName, pClientCoreData->imeFileName);

    /************************************************************************/
    /* ... now a new share object...                                        */
    /************************************************************************/
    status = WDWNewShareClass(pTSWd);
    if (!NT_SUCCESS(status))
    {
        TRC_ERR((TB, "Failed to get a new Share Object - quit"));
        DC_QUIT;
    }

    /************************************************************************/
    /* ...then bring up SM...                                               */
    /************************************************************************/
    status = SM_Init(pTSWd->pSmInfo, pTSWd, FALSE);
    if (NT_SUCCESS(status))
    {
        smInit = TRUE;
    }
    else {
        TRC_ERR((TB, "Failed to init SM, rc %lu", status));
        DC_QUIT;
    }

    //
    // Always compress at the highest level.
    //
    pTSWd->pInfoPkt->flags |= RNS_INFO_COMPRESSION |
                (PACKET_COMPR_TYPE_64K << RNS_INFO_COMPR_TYPE_SHIFT);


    /************************************************************************/
    /* Now we bypass the rest of SM setup altogether!                       */
    /************************************************************************/
    WDW_OnSMConnected(pTSWd, NM_CB_CONN_OK);

DC_EXIT_POINT:
    /************************************************************************/
    /* Clean up anything we created if we failed.                           */
    /************************************************************************/
    if (status == STATUS_SUCCESS) {
        pTSWd->pSdIoctl = NULL;
    }
    else {
        TRC_NRM((TB, "Cleaning up..."));

        if (pTSWd->dcShare != NULL)
        {
            TRC_NRM((TB, "Deleting Share object"));
            WDWDeleteShareClass(pTSWd);
        }

        if (smInit)
        {
            TRC_NRM((TB, "Terminating SM"));
            SM_Term(pTSWd->pSmInfo);
        }
    }

    DC_END_FN();
    return status;
} /* WDWConsoleConnect */


/****************************************************************************/
/* Name:      WDWShadowConnect                                              */
/*                                                                          */
/* Purpose:   Processes an IOCTL_ICA_STACK_SET_CONNECTED ioctl from TermSrv.*
/*            The contents of this message are gathered from the shadow     */
/*            client.                                                       */
/*                                                                          */
/* Params:    IN    pTSWd        - pointer to WD struct                     */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Parse the user data for core bits and SM bits.                */
/*            pull the values we want out of the core piece                 */
/*            initialize the Security Manager                               */
/*            create a share core, passing in the key values from user data */
/*            tell the user manager to proceed with connecting              */
/****************************************************************************/
NTSTATUS WDWShadowConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS         status = STATUS_SUCCESS;
    MCSError         MCSErr;
    UserHandle       hUser;
    ChannelHandle    hChannel;
    UINT32           maxPDUSize;
    BOOLEAN          bCompleted;
    BOOL             bSuccess = FALSE;
    BOOLEAN          bOldShadow = FALSE;
    RNS_UD_CS_CORE   clientCoreData, *pClientCoreData;
    RNS_UD_CS_SEC    clientSecurityData, *pClientSecurityData;
    RNS_UD_CS_NET    clientNetData, *pClientNetData;
    PTS_UD_CS_CLUSTER pClientClusterData;

    PTSHARE_MODULE_DATA    pModuleData = 
        (PTSHARE_MODULE_DATA) pSdIoctl->InputBuffer;
    PTSHARE_MODULE_DATA_B3 pModuleDataB3 = 
        (PTSHARE_MODULE_DATA_B3) pSdIoctl->InputBuffer;

    DC_BEGIN_FN("WDWShadowConnect");

    TRC_ERR((TB,
            "%s stack: WDWShadowConnect (data=%p), (size=%ld)",
            pTSWd->StackClass == Stack_Shadow ? "Shadow" : 
            (pTSWd->StackClass == Stack_Primary ? "Primary" : "Passthru"),
            pModuleData, pSdIoctl->InputBufferLength));
        
    /************************************************************************/
    /* Validate that the output buffer is big enough                        */
    /************************************************************************/
    if ((pSdIoctl->OutputBuffer == NULL) ||
            (pSdIoctl->OutputBufferLength < MIN_USERDATAINFO_SIZE) ||
            (((PUSERDATAINFO)pSdIoctl->OutputBuffer)->cbSize <
            MIN_USERDATAINFO_SIZE))
    {
        if (pSdIoctl->OutputBuffer != NULL)
        {
            /****************************************************************/
            /* Buffer has been supplied but is too small, - so tell         */
            /* TShareSRV how big a buffer we actually need.                 */
            /****************************************************************/
            ((PUSERDATAINFO)pSdIoctl->OutputBuffer)->cbSize
                                                      = MIN_USERDATAINFO_SIZE;
            TRC_ERR((TB, "Telling rdpwsx to have another go with %d",
                                                      MIN_USERDATAINFO_SIZE));
        }
        else
        {
            TRC_ERR((TB, "No Out Buffer on TSHARE_SHADOW_CONNECT."));
        }

        status = STATUS_BUFFER_TOO_SMALL;
        DC_QUIT;
    }
    
    switch (pTSWd->StackClass) {
        // Use the parameters we collected from the shadow client
        case Stack_Shadow:

            // B3 and B3_oops! servers used a fixed length user data structure
            if (pSdIoctl->InputBufferLength == sizeof(TSHARE_MODULE_DATA_B3)) {
                TRC_ERR((TB, "B3 shadow request!: %ld", pSdIoctl->InputBufferLength));
                bSuccess = WDWParseUserData(
                        pTSWd, NULL, 0,
                        (PRNS_UD_HEADER) &pModuleDataB3->clientCoreData,
                        sizeof(RNS_UD_CS_CORE_V0) + sizeof(RNS_UD_CS_SEC_V0),
                        &pClientCoreData,
                        &pClientSecurityData,
                        &pClientNetData,
                        &pClientClusterData);
                bOldShadow = TRUE;
            }
            else if (pSdIoctl->InputBufferLength == sizeof(TSHARE_MODULE_DATA_B3_OOPS)) {
                TRC_ERR((TB, "B3 Oops! shadow request!: %ld", pSdIoctl->InputBufferLength));
                bSuccess = WDWParseUserData(
                        pTSWd, NULL, 0,
                        (PRNS_UD_HEADER)&pModuleDataB3->clientCoreData,
                        sizeof(RNS_UD_CS_CORE_V1) + sizeof(RNS_UD_CS_SEC_V1),
                        &pClientCoreData,
                        &pClientSecurityData,
                        &pClientNetData,
                        &pClientClusterData);
                bOldShadow = TRUE;
            }

            // else, parse variable length data
            else if (pSdIoctl->InputBufferLength == (sizeof(TSHARE_MODULE_DATA) +
                     pModuleData->userDataLen - sizeof(RNS_UD_HEADER))) {
                TRC_ERR((TB, "RC1 shadow request!: %ld", pSdIoctl->InputBufferLength));
                bSuccess = WDWParseUserData(
                        pTSWd, NULL, 0,
                        (PRNS_UD_HEADER) &pModuleData->userData,
                        pModuleData->userDataLen,
                        &pClientCoreData,
                        &pClientSecurityData,
                        &pClientNetData,
                        &pClientClusterData);
            }
            else {
                TRC_ERR((TB, "Invalid module data size: %ld", 
                        pSdIoctl->InputBufferLength));
                bSuccess = FALSE;
                status = STATUS_INVALID_PARAMETER;
                DC_QUIT;
            }

            if (bSuccess) {
                TRC_ALT((TB, "Parsed shadow user data: %ld", 
                         pSdIoctl->InputBufferLength));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
                DC_QUIT;
            }
            break;

        // passthru stacks are initialized to defaults on open, but we can't 
        // return any user data until rdpwsx asks for it.  If the user data is
        // hanging around then return it, otherwise generate it.
        case Stack_Passthru:
            if (pTSWd->pUserData != NULL) {
                memcpy(pSdIoctl->OutputBuffer, pTSWd->pUserData, 
                       pTSWd->pUserData->cbSize);
                pSdIoctl->OutputBufferLength = pTSWd->pUserData->cbSize;
                pSdIoctl->BytesReturned = pTSWd->pUserData->cbSize;
                status = STATUS_SUCCESS;
                COM_Free(pTSWd->pUserData);
                pTSWd->pUserData = NULL;
                DC_QUIT;
            }
            pClientCoreData = &clientCoreData;
            pClientSecurityData = &clientSecurityData;
            pClientNetData = &clientNetData;
            WDWGetDefaultCoreParams(pClientCoreData);
            SM_GetDefaultSecuritySettings(pClientSecurityData);
            TRC_ALT((TB, "WDWShadowConnect: Defaulting passthru stack params"))
            break;


        default:
            TRC_ERR((TB, "WDWShadowConnect: Unexpected stack type: %ld", 
                     pTSWd->StackClass));
            status = STATUS_INVALID_PARAMETER;
            DC_QUIT;
            break;
    }

    status = WDWConnect(pTSWd,
                        pClientCoreData,
                        pClientSecurityData,
                        NULL,
                        NULL,
                        pSdIoctl,
                        bOldShadow);

    // If we successfully connected the server to the share, then connect the
    // remote client as well.
    if (NT_SUCCESS(status)) {
        MCSErr = MCSAttachUserRequest(pTSWd->hDomainKernel,
                                      NULL, // request callback (remote)
                                      NULL, // data callback (remote)
                                      NULL, // context (remote)
                                      &hUser,
                                      &maxPDUSize,
                                      &bCompleted);
        if (MCSErr != MCS_NO_ERROR)
        {
            TRC_ERR((TB, "Shadow MCSAttachUserRequest failed %d", MCSErr));
            status = STATUS_INSUFFICIENT_RESOURCES;
            DC_QUIT;
        }

        // Join the remote user to the broadcast channel
        MCSErr = MCSChannelJoinRequest(hUser, pTSWd->broadcastChannel,
                                       &hChannel, &bCompleted);
        if (MCSErr != MCS_NO_ERROR)
        {
            TRC_ERR((TB, "Remote broadcast channel join failed returned %d", MCSErr));
            status = STATUS_INSUFFICIENT_RESOURCES;
            DC_QUIT;
        }

        // Join the remote user to their own private channel
        MCSErr = MCSChannelJoinRequest(hUser, MCSGetUserIDFromHandle(hUser),
                                       &hChannel, &bCompleted);
        if (MCSErr != MCS_NO_ERROR)
        {
            TRC_ERR((TB, "Remote user channel join failed %d", MCSErr));
            status = STATUS_INSUFFICIENT_RESOURCES;
            DC_QUIT;
        }

        // Tell MCS which channel(s) we want shadowed.
        if (pTSWd->StackClass == Stack_Shadow) {
            MCSErr = MCSSetShadowChannel(pTSWd->hDomainKernel,
                                         pTSWd->broadcastChannel);
            if (MCSErr != MCS_NO_ERROR)
            {
                TRC_ERR((TB, "Remote user channel join failed %d", MCSErr));
                status = STATUS_INSUFFICIENT_RESOURCES;
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:

    if (NT_SUCCESS(status)) {
        TRC_ALT((TB, "WDWShadowConnect [%ld]: success!", pTSWd->StackClass));
    }
    else {
        TRC_ERR((TB, "WDWShadowConnect [%ld]: failed! rc=%lx", 
                 pTSWd->StackClass, status));
    }

    DC_END_FN();
    return status;
} /* WDWShadowConnect */


/****************************************************************************/
/* Name:      WDWGetClientData                                              */
/*                                                                          */
/* Purpose:   Process an IOCTL_ICA_STACK_QUERY_CLIENT                       */
/*                                                                          */
/* Returns:   STATUS_SUCCESS so long as buffer is big enough.               */
/*                                                                          */
/* Params:    IN  pTSWd - WD ptr.                                           */
/*            IN  pSdIoctl - IOCtl struct.                                  */
/*                                                                          */
/* Operation: Wait for the connected indication (this is to prevent the     */
/*            rest of the system going running off before we're ready).     */
/*                                                                          */
/*            Fill in the required data and then return the IOCtl.          */
/****************************************************************************/
NTSTATUS WDWGetClientData(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    PWINSTATIONCLIENTW pClientData =
            (PWINSTATIONCLIENTW)pSdIoctl->OutputBuffer;

    DC_BEGIN_FN("WDWGetClientData");
    
    /************************************************************************/
    /* Validate that the output buffer is big enough                        */
    /************************************************************************/
    if (pClientData != NULL &&
            pSdIoctl->OutputBufferLength >= sizeof(WINSTATIONCLIENTW)) {
        memset(pClientData, 0, sizeof(WINSTATIONCLIENTW));
    }
    else {
        status = STATUS_BUFFER_TOO_SMALL;
        TRC_ERR((TB,
                "Stack_Query_Client OutBuf too small - expected/got %d/%d",
                sizeof(WINSTATIONCLIENTW),
                pSdIoctl->OutputBufferLength));
        
        DC_QUIT;
    }

    /************************************************************************/
    /* ...and now fill out the reply buffer.                                */
    /************************************************************************/
    pClientData->fTextOnly = 0;

    /************************************************************************/
    /* Set the client StartSessionInfo values as specified by the client.   */
    /************************************************************************/
    pClientData->fMouse = (pTSWd->pInfoPkt->flags & RNS_INFO_MOUSE) != 0;

    pClientData->fDisableCtrlAltDel = (pTSWd->pInfoPkt->flags &
            RNS_INFO_DISABLECTRLALTDEL) != 0;

    pClientData->fEnableWindowsKey = (pTSWd->pInfoPkt->flags &
            RNS_INFO_ENABLEWINDOWSKEY) != 0;

    pClientData->fDoubleClickDetect = (pTSWd->pInfoPkt->flags &
            RNS_INFO_DOUBLECLICKDETECT) != 0;

    pClientData->fMaximizeShell = (pTSWd->pInfoPkt->flags &
            RNS_INFO_MAXIMIZESHELL) != 0;

    pClientData->fRemoteConsoleAudio = (pTSWd->pInfoPkt->flags &
            RNS_INFO_REMOTECONSOLEAUDIO) != 0;

    wcsncpy(pClientData->Domain, (LPWSTR)pTSWd->pInfoPkt->Domain,
            ((sizeof(pClientData->Domain) / sizeof(WCHAR)) - 1));
    pClientData->Domain[sizeof(pClientData->Domain) / sizeof(WCHAR) - 1] =
            L'\0';

    wcsncpy(pClientData->UserName, (LPWSTR)pTSWd->pInfoPkt->UserName,
            ((sizeof(pClientData->UserName) / sizeof(WCHAR)) - 1));
    pClientData->UserName[sizeof(pClientData->UserName) / sizeof(WCHAR) - 1] =
            L'\0';

    wcsncpy(pClientData->Password, (LPWSTR)pTSWd->pInfoPkt->Password,
        ((sizeof(pClientData->Password) / sizeof(WCHAR)) - 1));
    pClientData->Password[sizeof(pClientData->Password) / sizeof(WCHAR) - 1] =
            L'\0';

    pClientData->fPromptForPassword = !(pTSWd->pInfoPkt->flags &
            RNS_INFO_AUTOLOGON);

    /************************************************************************/
    /* The next fields are only used for the case (now supported by us)     */
    /* where the function is to have a specific app loaded as part of the   */
    /* WinStation creation.                                                 */
    /************************************************************************/
    memcpy(pClientData->WorkDirectory, pTSWd->pInfoPkt->WorkingDir,
            sizeof(pClientData->WorkDirectory));
    memcpy(pClientData->InitialProgram, pTSWd->pInfoPkt->AlternateShell,
            sizeof(pClientData->InitialProgram));

    // These fields are set by post Win2000 Beta 3 clients
    pClientData->SerialNumber = pTSWd->serialNumber;
    pClientData->ClientAddressFamily = pTSWd->clientAddressFamily;
    wcscpy(pClientData->ClientAddress, pTSWd->clientAddress);
    wcscpy(pClientData->ClientDirectory, pTSWd->clientDir);

    // Client time zone information
    pClientData->ClientTimeZone.Bias         = pTSWd->clientTimeZone.Bias;
    pClientData->ClientTimeZone.StandardBias = pTSWd->clientTimeZone.StandardBias;
    pClientData->ClientTimeZone.DaylightBias = pTSWd->clientTimeZone.DaylightBias;
    memcpy(&pClientData->ClientTimeZone.StandardName,&pTSWd->clientTimeZone.StandardName,
        sizeof(pClientData->ClientTimeZone.StandardName));
    memcpy(&pClientData->ClientTimeZone.DaylightName,&pTSWd->clientTimeZone.DaylightName,
        sizeof(pClientData->ClientTimeZone.DaylightName));

    pClientData->ClientTimeZone.StandardDate.wYear         = pTSWd->clientTimeZone.StandardDate.wYear        ;
    pClientData->ClientTimeZone.StandardDate.wMonth        = pTSWd->clientTimeZone.StandardDate.wMonth       ;
    pClientData->ClientTimeZone.StandardDate.wDayOfWeek    = pTSWd->clientTimeZone.StandardDate.wDayOfWeek   ;
    pClientData->ClientTimeZone.StandardDate.wDay          = pTSWd->clientTimeZone.StandardDate.wDay         ;
    pClientData->ClientTimeZone.StandardDate.wHour         = pTSWd->clientTimeZone.StandardDate.wHour        ;
    pClientData->ClientTimeZone.StandardDate.wMinute       = pTSWd->clientTimeZone.StandardDate.wMinute      ;
    pClientData->ClientTimeZone.StandardDate.wSecond       = pTSWd->clientTimeZone.StandardDate.wSecond      ;
    pClientData->ClientTimeZone.StandardDate.wMilliseconds = pTSWd->clientTimeZone.StandardDate.wMilliseconds;

    pClientData->ClientTimeZone.DaylightDate.wYear         = pTSWd->clientTimeZone.DaylightDate.wYear        ;
    pClientData->ClientTimeZone.DaylightDate.wMonth        = pTSWd->clientTimeZone.DaylightDate.wMonth       ;
    pClientData->ClientTimeZone.DaylightDate.wDayOfWeek    = pTSWd->clientTimeZone.DaylightDate.wDayOfWeek   ;
    pClientData->ClientTimeZone.DaylightDate.wDay          = pTSWd->clientTimeZone.DaylightDate.wDay         ;
    pClientData->ClientTimeZone.DaylightDate.wHour         = pTSWd->clientTimeZone.DaylightDate.wHour        ;
    pClientData->ClientTimeZone.DaylightDate.wMinute       = pTSWd->clientTimeZone.DaylightDate.wMinute      ;
    pClientData->ClientTimeZone.DaylightDate.wSecond       = pTSWd->clientTimeZone.DaylightDate.wSecond      ;
    pClientData->ClientTimeZone.DaylightDate.wMilliseconds = pTSWd->clientTimeZone.DaylightDate.wMilliseconds;

    // Client session id
    pClientData->ClientSessionId = pTSWd->clientSessionId;

    // Client performance flags (currently just disabled feature list)
    pClientData->PerformanceFlags = pTSWd->performanceFlags;

    // Client active input locale
    pClientData->ActiveInputLocale = pTSWd->activeInputLocale;

    // Set the client encryption level.
    pClientData->EncryptionLevel = (BYTE)
            ((PSM_HANDLE_DATA)(pTSWd->pSmInfo))->encryptionLevel;

    /************************************************************************/
    /* Unused.                                                              */
    /************************************************************************/
    pClientData->ClientLicense[0] = '\0';
    pClientData->ClientModem[0] = '\0';
    pClientData->ClientHardwareId = 0;

    /************************************************************************/
    /* Finally some real values.                                            */
    /************************************************************************/
    wcscpy(pClientData->ClientName, pTSWd->clientName);
    pClientData->ClientBuildNumber = pTSWd->clientBuild;
    pClientData->ClientProductId = pTSWd->clientProductId;
    pClientData->OutBufCountClient = TSHARE_WD_BUFFER_COUNT;
    pClientData->OutBufCountHost = TSHARE_WD_BUFFER_COUNT;
    pClientData->OutBufLength = 1460;  /* LARGE_OUTBUF_SIZE in TermDD. */
    pClientData->HRes = (UINT16)pTSWd->desktopWidth;
    pClientData->VRes = (UINT16)pTSWd->desktopHeight;
    pClientData->ProtocolType = PROTOCOL_RDP;
    pClientData->KeyboardLayout = pTSWd->kbdLayout;
    //shadow loop fix
    wcscpy( pClientData->clientDigProductId, pTSWd->clientDigProductId );

    /************************************************************************/
    /* WinAdmin uses special numbers for ColorDepth.                        */
    /************************************************************************/
#ifdef DC_HICOLOR
    pClientData->ColorDepth = (pTSWd->desktopBpp == 4  ? 1 :
                               pTSWd->desktopBpp == 8  ? 2 :
                               pTSWd->desktopBpp == 16 ? 4 :
                               pTSWd->desktopBpp == 24 ? 8 :
                               pTSWd->desktopBpp == 15 ? 16:
                                                         2);
#else
    pClientData->ColorDepth = (pTSWd->desktopBpp == 4  ? 1 :
                               pTSWd->desktopBpp == 8  ? 2 :
                               pTSWd->desktopBpp == 16 ? 4 :
                               pTSWd->desktopBpp == 24 ? 8 :
                                                         2);
#endif

    /************************************************************************/
    /* FE data                                                              */
    /************************************************************************/
    pClientData->KeyboardType = pTSWd->keyboardType;
    pClientData->KeyboardSubType = pTSWd->keyboardSubType;
    pClientData->KeyboardFunctionKey = pTSWd->keyboardFunctionKey;
    wcscpy(pClientData->imeFileName, pTSWd->imeFileName);

    pSdIoctl->BytesReturned = sizeof(WINSTATIONCLIENTW);

DC_EXIT_POINT:
    DC_END_FN();
    return status;
} /* WDWGetClientData */


/****************************************************************************/
/* Name:      WDWGetExtendedClientData                                      */
/*                                                                          */
/* Purpose:   Process an IOCTL_ICA_STACK_QUERY_CLIENT_EXTENSION             */
/*            Was introduced for Long UserName, Password support            */
/*                                                                          */
/* Returns:   STATUS_SUCCESS so long as buffer is big enough.               */
/*                                                                          */
/* Params:    IN  RnsInfoPacket - ptr to protocol packet from client.       */
/*            IN  pSdIoctl - IOCtl struct.                                  */
/*                                                                          */
/* Operation: Fill in the required data and then return the IOCtl.          */
/*            The data filled in are the long UserName, Password and Domain */
/****************************************************************************/
NTSTATUS WDWGetExtendedClientData(RNS_INFO_PACKET *RnsInfoPacket, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    pExtendedClientCredentials pExtendedClientData =
            (pExtendedClientCredentials)pSdIoctl->OutputBuffer;

    /************************************************************************/
    /* Validate that the output buffer is big enough                        */
    /************************************************************************/
    if (pExtendedClientData != NULL &&
            pSdIoctl->OutputBufferLength >= sizeof(ExtendedClientCredentials)) {
        memset(pExtendedClientData, 0, sizeof(ExtendedClientCredentials));
    }
    else {
        status = STATUS_BUFFER_TOO_SMALL;
        return status; 
    }

    //copy the long UserName, Password and Domain from protocol packet to the IOCTL buffer
    wcsncpy(pExtendedClientData->Domain, (LPWSTR)RnsInfoPacket->Domain,
            ((sizeof(pExtendedClientData->Domain) / sizeof(WCHAR)) - 1));
    pExtendedClientData->Domain[sizeof(pExtendedClientData->Domain) / sizeof(WCHAR) - 1] =
            L'\0';

    wcsncpy(pExtendedClientData->UserName, (LPWSTR)RnsInfoPacket->UserName,
            ((sizeof(pExtendedClientData->UserName) / sizeof(WCHAR)) - 1));
    pExtendedClientData->UserName[sizeof(pExtendedClientData->UserName) / sizeof(WCHAR) - 1] =
            L'\0';

    wcsncpy(pExtendedClientData->Password, (LPWSTR)RnsInfoPacket->Password,
        ((sizeof(pExtendedClientData->Password) / sizeof(WCHAR)) - 1));
    pExtendedClientData->Password[sizeof(pExtendedClientData->Password) / sizeof(WCHAR) - 1] =
            L'\0';

    return status ;
}

//
// WDWGetAutoReconnectInfo
// Process an IOCTL_ICA_STACK_QUERY_AUTORECONNECT to retreive
// autoreconnect info.
//
// Returns:   STATUS_SUCCESS so long as buffer is big enough.
//
// Params:    IN  RnsInfoPacket - ptr to protocol packet from client.
//
NTSTATUS WDWGetAutoReconnectInfo(PTSHARE_WD pTSWd,
                                 RNS_INFO_PACKET* pRnsInfoPacket,
                                 PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    PTS_AUTORECONNECTINFO pAutoReconnectInfo;
    BYTE fGetServerToClientInfo;
    ULONG cb = 0;
    DC_BEGIN_FN("WDWGetAutoReconnectInfo");

    //
    // Expect a byte as input
    //
    TRC_ASSERT((pSdIoctl->InputBufferLength == sizeof(BYTE)),
            (TB,"Already an IOCTL linked from pTSWd"));


    pAutoReconnectInfo = (PTS_AUTORECONNECTINFO)pSdIoctl->OutputBuffer;
    memcpy(&fGetServerToClientInfo,
           pSdIoctl->InputBuffer,
           sizeof(fGetServerToClientInfo));

    //
    // Validate that the output buffer is big enough
    //
    if (pAutoReconnectInfo != NULL &&
            pSdIoctl->OutputBufferLength >= sizeof(TS_AUTORECONNECTINFO)) {
        memset(pAutoReconnectInfo, 0, sizeof(TS_AUTORECONNECTINFO));
    }
    else {
        status = STATUS_BUFFER_TOO_SMALL;
        TRC_ERR((TB,
                "Stack_Query_Client OutBuf too small - expected/got %d/%d",
                sizeof(TS_AUTORECONNECTINFO),
                pSdIoctl->OutputBufferLength));
        DC_QUIT;
    }

    if (fGetServerToClientInfo) {

        //
        // Get the server to client ARC cookie contents (if present)
        //
        if (pTSWd->arcTokenValid) {
            pAutoReconnectInfo->cbAutoReconnectInfo = sizeof(pTSWd->arcCookie);
            memcpy(pAutoReconnectInfo->AutoReconnectInfo,
                   pTSWd->arcCookie,
                   sizeof(pTSWd->arcCookie));
            pSdIoctl->BytesReturned = sizeof(pTSWd->arcCookie);
        }
        else {
            status = STATUS_NOT_FOUND;
        }
    }
    else {

        //
        // Get info sent from the client to the server
        //

        if (pRnsInfoPacket->ExtraInfo.cbAutoReconnectLen <= 
                sizeof(pAutoReconnectInfo->AutoReconnectInfo)) {

            pAutoReconnectInfo->cbAutoReconnectInfo = 
                pRnsInfoPacket->ExtraInfo.cbAutoReconnectLen;
            memcpy(pAutoReconnectInfo->AutoReconnectInfo,
                   pRnsInfoPacket->ExtraInfo.autoReconnectCookie,
                   pRnsInfoPacket->ExtraInfo.cbAutoReconnectLen);

            pSdIoctl->BytesReturned = 
                pRnsInfoPacket->ExtraInfo.cbAutoReconnectLen;
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
            TRC_ERR((TB,
                    "Buffer from client too large got: %d limit: %d",
                    pRnsInfoPacket->ExtraInfo.cbAutoReconnectLen,
                    sizeof(pAutoReconnectInfo->AutoReconnectInfo)));
            DC_QUIT;
        }
    }


DC_EXIT_POINT:
    DC_END_FN();
    return status;
}


/****************************************************************************/
/* Name:      WDWParseUserData                                              */
/*                                                                          */
/* Purpose:   Separate out the parts of the GCC User Data                   */
/*                                                                          */
/* Returns:   TRUE if all data found OK; else FALSE.                        */
/*                                                                          */
/* Params:    IN    pTSWd - WD Handle                                       */
/*            IN    pUserData - user data from TShareSRV (from indication)  */
/*            IN    pHeader - optional post parse data (shadow)             */
/*            IN    cbParsedData - optional post data length (shadow)       */
/*            OUT   ppClientCoreData - ptr to Core data                     */
/*            OUT   ppClientSecurityData - ptr to SM data                   */
/*            OUT   ppNetSecurityData - ptr to Net data                     */
/*                                                                          */
/* Operation: Locate our user data, then the two items required from within */
/*            it.                                                           */
/****************************************************************************/
BOOL WDWParseUserData(
        PTSHARE_WD       pTSWd,
        PUSERDATAINFO    pUserData,
        unsigned         UserDataLen,
        PRNS_UD_HEADER   pHeader,
        ULONG            cbParsedData,
        PPRNS_UD_CS_CORE ppClientCoreData,
        PPRNS_UD_CS_SEC  ppClientSecurityData,
        PPRNS_UD_CS_NET  ppClientNetData,
        PTS_UD_CS_CLUSTER *ppClientClusterData)
{
    BOOL           success = FALSE;
    GCCUserData    *pClientUserData;
    char           clientH221Key[] = CLIENT_H221_KEY;
    PRNS_UD_HEADER pEnd;
    GCCOctetString UNALIGNED *pOctet;
    unsigned char  *pStr;
    UINT32         dataLen;
    UINT32         keyLen;

    DC_BEGIN_FN("WDWParseUserData");

    *ppClientNetData = NULL;
    *ppClientSecurityData = NULL;
    *ppClientCoreData = NULL;
    *ppClientClusterData = NULL;

    // Actual GCC user data so parse it to make sure it's good.
    if (pHeader == NULL) {
        // We assume the data length was checked by the caller for at least
        // the length of the USERDATAINFO header. We have to validate the rest.

        // We are expecting exactly 1 piece of user data.
        if (pUserData->ulUserDataMembers == 1) {
            // Check that it has a non-standard key.

            pClientUserData = &(pUserData->rgUserData[0]);

            if (pClientUserData->key.key_type == GCC_H221_NONSTANDARD_KEY) {
                // Check it has our non-standard key.
                keyLen = pClientUserData->key.u.h221_non_standard_id.
                        octet_string_length;
                
                pStr = (unsigned char *)((BYTE *)pUserData +
                        (UINT_PTR)pClientUserData->key.u.
                        h221_non_standard_id.octet_string);            
                   
                TRC_DATA_DBG("GCC_H221_NONSTANDARD_KEY", pStr, keyLen);
                //    We check here if this is exactly our key.
                //    pStr was obtained by adding to the pUserData an untrusted
                //    length so we have to check for overflow (pStr should not
                //    be smaller then pUserData). Then we check if adding keyLen
                //    will overrun our buffer.
                if ((keyLen != sizeof(clientH221Key) - 1) ||
                     ((PBYTE)pStr < (PBYTE)pUserData) ||                                            
                     ((PBYTE)pStr+keyLen > (PBYTE)(pUserData) + UserDataLen)) {
                     
                    TRC_ERR((TB, "Invalid key buffer %d %p", keyLen, pStr));
                    WDW_LogAndDisconnect(pTSWd, TRUE, 
                            Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                    DC_QUIT;
                }

                if (strncmp(pStr, clientH221Key, sizeof(clientH221Key) - 1)) {
                      TRC_ERR((TB, "Wrong key %*s", pStr));
                      WDW_LogAndDisconnect(pTSWd, TRUE, 
                            Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                      DC_QUIT;
                }
            } 
            else {
                TRC_ERR((TB, "Wrong key %d on user data",
                        pClientUserData->key.key_type));
                WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                DC_QUIT;
            }
        } 
        else {
            TRC_ERR((TB,
              "<%p> %d pieces of user data on Conf Create Indication: reject it",
                    pUserData->hDomain, pUserData->ulUserDataMembers));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);

            DC_QUIT;
        }
        
        // This is our client data.
        // Save the domain handle for later.
        pTSWd->hDomain = pUserData->hDomain;

        //    Parse the user data. Make sure the octet string is well-formed.
        //    pClientUserData->octet_string is an offset from the start of the
        //    user data.

        //  Validate data length
        if ((UINT_PTR)pClientUserData->octet_string < sizeof(USERDATAINFO)) 
        {
            
            TRC_ERR((TB,"UserData octet_string offset %p too short",
                     pClientUserData->octet_string));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }
        
        if ((UINT_PTR)pClientUserData->octet_string >= UserDataLen) 
        {
        
            TRC_ERR((TB,"UserData octet_string offset %p too long for data len %u",
                pClientUserData->octet_string, UserDataLen));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }

        pOctet = (GCCOctetString UNALIGNED *)((PBYTE)pUserData +
                (UINT_PTR)pClientUserData->octet_string);

        //    Here we have to ckeck if we can actually dereference. 
        //    We obtained pOcted by adding a size to the pUserData. And we already
        //    checked that what we added is less then the UserData length. 
        if (((LPBYTE)pOctet+sizeof(GCCOctetString) > (LPBYTE)pUserData+UserDataLen) ||
            ((LPBYTE)pOctet+sizeof(GCCOctetString) < (LPBYTE)pOctet)) {
   
            TRC_ERR((TB,"Not enough buffer for an sizeof(GCCOctetString)=%d  at %p ",
                sizeof(GCCOctetString), pOctet->octet_string));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }
        
        if ((UINT_PTR)pOctet->octet_string >= UserDataLen) 
        {
            TRC_ERR((TB,"UserData octet_string offset %p too long for data len %u",
                pOctet->octet_string, UserDataLen));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }

        pHeader = (PRNS_UD_HEADER)((PBYTE)pUserData +
                (UINT_PTR)pOctet->octet_string);
        dataLen = pOctet->octet_string_length;

        // Validate the datalength
        if (dataLen < sizeof(RNS_UD_HEADER)) 
        {
            TRC_ERR((TB, "Error: User data too short!"));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }

        //    At this point we know that pHeader points within the buffer. 
        //    We checked that the pOctet->octet_string is less then the UserDataLen
        //    We just have to check that we have enough buffer left 
        //    after that fordataLen.
        //    Note taht dataLen at this point is at least the size of RNS_UD_HEADER.
        if (((LPBYTE)pHeader +dataLen > (PBYTE)pUserData + UserDataLen ) ||
            ((LPBYTE)pHeader +dataLen < (PBYTE)pHeader )  ||
            (pHeader->length >dataLen)) {
            TRC_ERR((TB,"Not enough buffer left to store RNS_UD_HEADER %p, %p, %u ",
                pUserData, pHeader, UserDataLen ));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
            DC_QUIT;
        }
    }
    // Else, this is pre-parsed user data via a shadow connection
    else {
        dataLen = cbParsedData;
    }

    // We assume that the pre-parsed data is trusted.
    pEnd = (PRNS_UD_HEADER)((PBYTE)pHeader + dataLen);

    TRC_DATA_DBG("Our client's User Data", pHeader, dataLen);
    
    // Loop through user data, extracting each piece.
    do {
        switch (pHeader->type) {
            case RNS_UD_CS_CORE_ID:
                //   Beta2 Client core user data did not include the new
                //   field postBeta2ColorDepth, so check that the length of
                //   the incoming user data is at least this long.
                //   The WDWConnect parses this data and it checks the length we  
                //   supply before it derefs parameters that are declared after 
                //   postBeta2ColorDepth in the struct.
                if (pHeader->length >=
                        (FIELDOFFSET(RNS_UD_CS_CORE, postBeta2ColorDepth) +
                         FIELDSIZE(RNS_UD_CS_CORE, postBeta2ColorDepth))) {
                    *ppClientCoreData = (PRNS_UD_CS_CORE)pHeader;
                    TRC_DATA_DBG("Core data", pHeader, pHeader->length);
                }
                else {
                    TRC_ERR((TB, "Core data not long enough -- old client?"));
                    WDW_LogAndDisconnect(pTSWd, TRUE, 
                        Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                    DC_QUIT;
                }
                break;

            case RNS_UD_CS_SEC_ID:
                // Old clients don't have the extEncryptionMethods. 
                // The extEncryptionMethods field is used only for french locale.
                // We have to allow buffers that don't have space for extEncryptionMethods 
                // because the buffer will be processed in SM_Connect and there we take care of shorter fields.
                // Nothing else processes this buffer after SM_Connect at this point.
                if (pHeader->length >= FIELDOFFSET(RNS_UD_CS_SEC,encryptionMethods)
                                 + FIELDSIZE(RNS_UD_CS_SEC,encryptionMethods)) { 
                    *ppClientSecurityData = (PRNS_UD_CS_SEC)pHeader;
                    TRC_DATA_DBG("Security data", pHeader, pHeader->length);
                } else {
                    TRC_ERR((TB, "Security data not long enough"));
                    WDW_LogAndDisconnect(pTSWd, TRUE, 
                        Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                    DC_QUIT;
                }   
                break;
                
            case RNS_UD_CS_NET_ID:
                if (pHeader->length >= sizeof(RNS_UD_CS_NET)) {
                    *ppClientNetData = (PRNS_UD_CS_NET)pHeader;
                    TRC_DATA_DBG("Net data", pHeader, pHeader->length);
                } else {
                    TRC_ERR((TB, "Net data not long enough"));
                    WDW_LogAndDisconnect(pTSWd, TRUE, 
                        Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                    DC_QUIT;
                }
                break;

            case TS_UD_CS_CLUSTER_ID:
                if (pHeader->length >=sizeof(TS_UD_CS_CLUSTER)) {
                    *ppClientClusterData = (TS_UD_CS_CLUSTER *)pHeader;
                    TRC_DATA_DBG("Cluster data", pHeader, pHeader->length);
                } else {
                    TRC_ERR((TB, "Cluster data not long enough"));
                    WDW_LogAndDisconnect(pTSWd, TRUE, 
                        Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
                    DC_QUIT;                    
                }
                break;

            default:
                TRC_ERR((TB, "Unknown user data type %d", pHeader->type));
                TRC_DATA_ERR("Unknown user data", pHeader, pHeader->length);
                WDW_LogAndDisconnect(pTSWd, TRUE, 
                    Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);

                break;
        }
        
        if ((PBYTE)pHeader + pHeader->length < (PBYTE)pHeader) {
            //   we detected a length that causes overflow
            TRC_ERR((TB, "Header length too big! Overflow detected !"));
            WDW_LogAndDisconnect(pTSWd, TRUE, 
                Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);

            DC_QUIT;
        }

        //   We check the zero length now after we update the pHeader value.  
        //   Otherwize we will exit with an error when we actually check the sizes.
        //   don't get stuck here for ever...
        if (pHeader->length == 0) {
            TRC_ERR((TB, "header length was zero!"));
            break;
        }

        // Move on to the next user data string.
        pHeader = (PRNS_UD_HEADER)((PBYTE)pHeader + pHeader->length);
        
    } while ((pHeader +1) <= pEnd);

    if ((PBYTE)pHeader > (PBYTE)pEnd) 
    {
        TRC_ERR((TB, "Error: User data too short!"));
        WDW_LogAndDisconnect(pTSWd, TRUE, 
                Log_RDP_BadUserData, (PBYTE)pUserData, UserDataLen);
        DC_QUIT;
    }

    // Make sure we found all our client data.  Note that Net and
    // Cluster data blocks are optional - RDP4 client doesn't send Net data,
    // RDP4 and 5 don't send Cluster data.
    if ((*ppClientSecurityData == NULL) || (*ppClientCoreData == NULL)) {
        TRC_ERR((TB,"<%p> Security [%p] or Core [%p] data missing",
                pUserData ? pUserData->hDomain : 0,
                *ppClientSecurityData, *ppClientCoreData));
        DC_QUIT;
    }

    success = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return success;

} /* WDWParseUserData */


/****************************************************************************/
/* Name:      WDWVCMessage                                                  */
/*                                                                          */
/* Purpose:   Send a control message to the Client's VC subsystem           */
/*                                                                          */
/* Params:    flags - VC header flags to send                               */
/****************************************************************************/
void WDWVCMessage(PTSHARE_WD pTSWd, UINT32 flags)
{
    PVOID               pBuffer;
    CHANNEL_PDU_HEADER UNALIGNED *pHdr;
    PNM_CHANNEL_DATA    pChannelData;
    UINT16              MCSChannelID;

    DC_BEGIN_FN("WDWVCMessage");

    /************************************************************************/
    /* Pick a random channel - any channel will reach the VC subsystem      */
    /************************************************************************/
    MCSChannelID = NM_VirtualChannelToMCS(pTSWd->pNMInfo,
                                          0,
                                          &pChannelData);

    /************************************************************************/
    /* If channel 0 doesn't exist, there are no channels - drop out now.    */
    /************************************************************************/
    if (MCSChannelID != (UINT16) -1)
    {
        /********************************************************************/
        /* Get a buffer                                                     */
        /********************************************************************/
        if ( STATUS_SUCCESS == SM_AllocBuffer(pTSWd->pSmInfo, &pBuffer,
                           sizeof(CHANNEL_PDU_HEADER), TRUE, FALSE) )
        {
            pHdr = (CHANNEL_PDU_HEADER UNALIGNED *)pBuffer;
            pHdr->flags = flags;
            pHdr->length = sizeof(CHANNEL_PDU_HEADER);

            /****************************************************************/
            /* Send the info                                                */
            /****************************************************************/
            SM_SendData(pTSWd->pSmInfo, pBuffer, sizeof(CHANNEL_PDU_HEADER),
                    TS_LOWPRIORITY, MCSChannelID, FALSE, RNS_SEC_ENCRYPT, FALSE);

            TRC_NRM((TB, "Sent VC flags %#x", flags));
        }
        else
        {
            TRC_ERR((TB, "Failed to alloc %d byte buffer",
                    sizeof(CHANNEL_PDU_HEADER)));
        }
    }
    else {
        TRC_ALT((TB, "Dropping VC message for channel 0!"));
    }

    DC_END_FN();
} /* WDWVCMessage */

//
// WDWCompressToOutbuf
// Compressed the buffer directly into the outbuf.
// Caller MUST decide if input buf is in size range for compression
// and should handle copying over the buffer directly in that case.
//
// Note this function does not update the SC compression estimates.
// It is intended for compressing VC data. The SC compression estimates
// are used to predict how much space to allocate for the graphics outbuf's
// anyway so it is actually more appropriate for that estimate to be computed
// separately. VC compression does not need an estimate, we allocate up to
// our max channel chunk length.
//
// Params:
//  pSrcData - input buffer
//  cbSrcLen - length of input buffer
//  pOutBuf  - output buffer
//  pcbOutLen- compressed output size
// Returns:
//  Compression result (see compress() fn)
//
UCHAR WDWCompressToOutbuf(PTSHARE_WD pTSWd, UCHAR* pSrcData, ULONG cbSrcLen,
                          UCHAR* pOutBuf,  ULONG* pcbOutLen)
{
    UCHAR compressResult = 0;
    ULONG CompressedSize = cbSrcLen;

    DC_BEGIN_FN("WDWCompressToOutbuf");

    TRC_ASSERT((pTSWd != NULL), (TB,"NULL pTSWd"));
    TRC_ASSERT(((cbSrcLen > WD_MIN_COMPRESS_INPUT_BUF) &&
                (cbSrcLen < MAX_COMPRESS_INPUT_BUF)),
               (TB,"Compression src len out of range: %d",
                cbSrcLen));

    //Attempt to compress directly into the outbuf
    compressResult =  compress(pSrcData,
                               pOutBuf,
                               &CompressedSize,
                               pTSWd->pMPPCContext);
    if(compressResult & PACKET_COMPRESSED)
    {
        //Successful compression.
        TRC_ASSERT((CompressedSize >= CompressedSize),
                (TB,"Compression created larger size than uncompr"));
        compressResult |= pTSWd->bFlushed;
        pTSWd->bFlushed = 0;
    }
    else if(compressResult & PACKET_FLUSHED)
    {
        //Overran compression history, copy over the
        //uncompressed buffer.
        pTSWd->bFlushed = PACKET_FLUSHED;
        memcpy(pOutBuf, pSrcData, cbSrcLen);
        pTSWd->pProtocolStatus->Output.CompressFlushes++;
    }
    else
    {
        TRC_ALT((TB, "Compression FAILURE"));
    }

    DC_END_FN();
    *pcbOutLen = CompressedSize;
    return compressResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\ntrcapi.c ===
/****************************************************************************/
// ntrcapi.c
//
// RDP Trace helper functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <precomp.h>
#pragma hdrstop


#ifdef DC_DEBUG

#include <adcg.h>
#include <nwdwapi.h>
#include <atrcapi.h>


/****************************************************************************/
// Main wrapper function to pipe trace into TS stack trace
/****************************************************************************/
void RDPCALL TRC_TraceLine(
        PVOID pWD,
        UINT32 traceClass,
        UINT32 traceType,
        char *traceString,
        char separator,
        unsigned lineNumber,
        char *funcName,
        char *fileName)
{
    // Very occasionally a timing issue occurs where tracing can happen
    // before the pTRCWd in each particular WD component is not initialized.
    if (pWD != NULL) {
        char FinalTraceString[TRC_BUFFER_SIZE];

        sprintf(FinalTraceString, "RDP%c%p%c"TRC_FUNC_FMT"%c"TRC_LINE_FMT"%c%s\n",
                separator, pWD, separator, TRC_FUNCNAME_LEN, TRC_FUNCNAME_LEN,
                funcName, separator, lineNumber, separator, traceString);

        IcaStackTrace((PSDCONTEXT)(((PTSHARE_WD)pWD)->pContext), traceClass,
                traceType, FinalTraceString);
    }
}


/****************************************************************************/
/* TRC_UpdateConfig                                                         */
/****************************************************************************/
void RDPCALL TRC_UpdateConfig(PVOID pTSWd, PSD_IOCTL pSdIoctl)
{
    PICA_TRACE pTraceInfo;
    char traceOptions[64];
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;
    char *pStart;
    char *pEnd;
    unsigned numChars;
    unsigned index;
    UINT32 startLine;
    UINT32 endLine;

    pTraceInfo = (PICA_TRACE)(pSdIoctl->InputBuffer);

    // Copy trace info to TSWd structure.
    ((PTSHARE_WD)pTSWd)->trc.TraceClass  = pTraceInfo->TraceClass;
    ((PTSHARE_WD)pTSWd)->trc.TraceEnable = pTraceInfo->TraceEnable;

    // Handle trace prefix information.
    RtlZeroMemory(traceOptions, sizeof(traceOptions));
    unicodeString.Length = sizeof(WCHAR) * wcslen(pTraceInfo->TraceOption);
    unicodeString.MaximumLength = unicodeString.Length;
    unicodeString.Buffer        = (pTraceInfo->TraceOption);
    ansiString.Length           = 0;
    ansiString.MaximumLength    = sizeof(traceOptions);
    ansiString.Buffer           = traceOptions;

    if (STATUS_SUCCESS != RtlUnicodeStringToAnsiString(&ansiString,
            &unicodeString, FALSE)) {
        KdPrint(("RDPWD: Couldn't set trace prefix info\n"));
        DC_QUIT;
    }

    RtlZeroMemory(((PTSHARE_WD)pTSWd)->trc.prefix,
            TRC_MAX_PREFIX * sizeof(TRC_PREFIX_DATA));

    index = 0;

    // Ignore any spaces at the start of the string.
    pEnd = traceOptions;
    while (' ' == *pEnd)
        pEnd++;

    // Main loop to parse prefix string.
    while ('\0' != *pEnd) {
        pStart = pEnd;

        // Run along the string looking for some sort of delimiter.
        while (('\0' != *pEnd) &&
                ('='  != *pEnd) &&
                (' '  != *pEnd) &&
                ('('  != *pEnd) &&
                (';'  != *pEnd) &&
                (','  != *pEnd))
        {
            pEnd++;
        }

        // We now have a filename prefix, so save it.  Don't need to worry
        // about a NULL terminator since we zeroed the array already.
        numChars = min((unsigned)(pEnd - pStart), TRC_PREFIX_NAME_LEN - 1);

        memcpy(((PTSHARE_WD)pTSWd)->trc.prefix[index].name, pStart, numChars);

        // Skip any spaces after this word, which may precede an '('.
        while (' ' == *pEnd)
            pEnd++;

        // Now split out the (optional) line number range.
        // Syntax is (aaa-bbb), where aaa is the start line number and bbb
        // is the end line number.
        // Spaces are allowed - e.g.  ( aaa - bbb )
        if ('(' == *pEnd) {
            pEnd++;                     /* skip past the open bracket       */
            startLine = 0;
            endLine = 0;

            // Skip past blanks.
            while (' ' == *pEnd)
                pEnd++;

            // Extract the start line number.
            while (('0' <= *pEnd) &&
                    ('9' >= *pEnd)) {
                startLine = (startLine * 10) + (*pEnd - '0');
                pEnd++;
            }

            // Look for the next delimiter: '-' or ')'.
            while (('-' != *pEnd) &&
                    (')' != *pEnd) &&
                    ('\0' != *pEnd))
                pEnd++;

            // Stop now if we've reached the end of the line.
            if ('\0' == *pEnd) {
                KdPrint(("RDPWD: Unexpected EOL in trace options\n"));
                DC_QUIT;
            }

            // Extract the end line number (if any).
            if ('-' == *pEnd) {
                pEnd++;                 /* skip past '-'                    */
                while (' ' == *pEnd)
                    pEnd++;

                while (('0' <= *pEnd) &&
                        ('9' >= *pEnd)) {
                    endLine = (endLine * 10) + (*pEnd - '0');
                    pEnd++;
                }

                // Look for the closing delimiter: ')'.
                while (('\0' != *pEnd) &&
                        (')' != *pEnd))
                    pEnd++;
            }
            else {
                // Must be a bracket then - only one number was specified.
                endLine = startLine;
            }

            // Stop now if we've reached the end of the line.
            if ('\0' == *pEnd) {
                KdPrint(("RDPWD: Unexpected EOL in trace options\n"));
                DC_QUIT;
            }

            pEnd++;                     /* Jump past close bracket          */

            // Store the start and end line numbers if they make sense.
            if (endLine >= startLine) {
                ((PTSHARE_WD)pTSWd)->trc.prefix[index].start = startLine;
                ((PTSHARE_WD)pTSWd)->trc.prefix[index].end   = endLine;
            }
        }

        // Move on to the next prefix entry in the array.
        index++;

        if (index >= TRC_MAX_PREFIX) {
            // We've overrun the prefix list - so send some trace to the
            // debug console and then quit.
            KdPrint(("RDPWD: The trace option array is full!\n"));
            DC_QUIT;
        }

        // Skip past any delimiters.
        while ((',' == *pEnd) ||
                (';' == *pEnd) ||
                (' ' == *pEnd))
            pEnd++;
    }

DC_EXIT_POINT:
    // Dump details to debugger.
    KdPrint(("RDPWD: New trace config for %p:\n", pTSWd));
    KdPrint(("RDPWD:     Class:  %lx\n",
        ((PTSHARE_WD)pTSWd)->trc.TraceClass));
    KdPrint(("RDPWD:     Enable: %lx\n",
        ((PTSHARE_WD)pTSWd)->trc.TraceEnable));
    KdPrint(("RDPWD:     Prefix info:\n"));

    if (((PTSHARE_WD)pTSWd)->trc.prefix[0].name[0] == '\0') {
        KdPrint(("RDPWD:         None\n"));
    }

    for (index = 0;
            (index < TRC_MAX_PREFIX) &&
            (((PTSHARE_WD)pTSWd)->trc.prefix[index].name[0] != '\0');
            index++)
    {
        if ((((PTSHARE_WD)pTSWd)->trc.prefix[index].start == 0) &&
                (((PTSHARE_WD)pTSWd)->trc.prefix[index].end   == 0)) {
            KdPrint(("RDPWD:         %s(all lines)\n",
                    ((PTSHARE_WD)pTSWd)->trc.prefix[index].name));
        }
        else {
            KdPrint(("RDPWD:         %s(%lu-%lu)\n",
                    ((PTSHARE_WD)pTSWd)->trc.prefix[index].name,
                    ((PTSHARE_WD)pTSWd)->trc.prefix[index].start,
                    ((PTSHARE_WD)pTSWd)->trc.prefix[index].end));
        }
    }

    ((PTSHARE_WD)pTSWd)->trc.init = TRUE;
    ((PTSHARE_WD)pTSWd)->trcShmNeedsUpdate = TRUE;
}


/****************************************************************************/
/* Name:      TRC_MaybeCopyConfig                                           */
/*                                                                          */
/* Purpose:   Copies trace config to SHM if necessary                       */
/****************************************************************************/
void RDPCALL TRC_MaybeCopyConfig(PVOID pTSWd, PTRC_SHARED_DATA pTrc)
{
    if (((PTSHARE_WD)pTSWd)->trcShmNeedsUpdate) {
        memcpy(pTrc, &(((PTSHARE_WD)pTSWd)->trc), sizeof(TRC_SHARED_DATA));
        ((PTSHARE_WD)pTSWd)->trcShmNeedsUpdate = FALSE;
    }
} /* TRC_MaybeCopyConfig */


/****************************************************************************/
/* TRCPrefixMatch                                                           */
/*                                                                          */
/* Internal function to compare a component name to a prefix.               */
/* - assumes both are the same case                                         */
/* - returns                                                                */
/*   - TRUE  if characters up to end of prefix match                        */
/*   - FALSE otherwise                                                      */
/****************************************************************************/
BOOL RDPCALL TRCPrefixMatch(char *cpnt, char *prefix)
{
    while ((*cpnt == *prefix) && (*prefix != 0)) {
        cpnt++;
        prefix++;
    }

    if (*prefix == 0)
        return TRUE;

    return FALSE;
}


/****************************************************************************/
// TRC_WillTrace
//
// Determines if a trace line will be traced.
/****************************************************************************/
BOOL RDPCALL TRC_WillTrace(
        PVOID  pTSWd,
        UINT32 traceType,
        UINT32 traceClass,
        char *fileName,
        UINT32 line)
{
    BOOL rc;

    // Very occasionally a timing issue occurs where tracing can happen
    // before the pTRCWd in each particular WD component is not initialized.
    if (pTSWd != NULL) {
        PTRC_SHARED_DATA pTrc = &(((PTSHARE_WD)pTSWd)->trc);
        int i;

        // If SHM is not set up, return TRUE and let TermDD decide.
        if (!pTrc->init) {
            rc = TRUE;
            DC_QUIT;
        }

        // Check whether this type and class are enabled.
        if (!(traceType & pTrc->TraceEnable) ||
                !(traceClass & pTrc->TraceClass)) {
            rc = FALSE;
            DC_QUIT;
        }

        // Always trace errors, irrespective of prefix.
        if (traceType & TT_API4) {
            rc = TRUE;
            DC_QUIT;
        }

        // Trace all lines if no prefixes are defined.
        if (pTrc->prefix[0].name[0] == 0) {
            rc = TRUE;
            DC_QUIT;
        }

        // Some prefixes are defined - check whether this line matches any of
        // them.
        for (i = 0; i < TRC_MAX_PREFIX; i++) {
            if (pTrc->prefix[i].name[0] == 0) {
                // End of list - break.
                break;
            }

            if (TRCPrefixMatch(&(fileName[1]), pTrc->prefix[i].name)) {
                // Found matching filename - is there a line number range
                // specified?
                if ((pTrc->prefix[i].start == 0) &&
                        (pTrc->prefix[i].end == 0)) {
                    // No line number range - trace this line.
                    rc = TRUE;
                    DC_QUIT;
                }

                // There's a line number range - see if this line falls within
                // it.
                if ((line >= pTrc->prefix[i].start) &&
                        (line <= pTrc->prefix[i].end)) {
                    // Line within prefix range - trace it.
                    rc = TRUE;
                    DC_QUIT;
                }
            }
        } /* for */

        // If we get here, we've searched the list of prefixes and failed to
        // find a match - don't trace the line.
        rc = FALSE;
    }
    else {
        rc = FALSE;
    }

DC_EXIT_POINT:
    return rc;
}


#endif // DC_DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\precomp.h ===
/****************************************************************************/
// precomp.h
//
// RDPWD precompiled header.
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/
#ifndef _H_PRECOMP
#define _H_PRECOMP

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#pragma warning(disable:4200)


#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#ifndef _HYDRA_
#include <cxstatus.h>
#endif
#include <winstaw.h>
#include <ctxver.h>
#include <compress.h>

#ifdef far
#undef far
#endif
#define far

#include <icadd.h>
#include <sdapi.h>

#include <adcg.h>

    
//RDP protocol specific error codes
#include "rdperr.h"

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _H_PRECOMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nwdwdata.c ===
/****************************************************************************/
/* Module:    nwdwdata.c                                                    */
/*                                                                          */
/* Purpose:   Declare WD data items                                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

/****************************************************************************/
/* WD procedures                                                            */
/*                                                                          */
/* We only need Open, Close, IOCtl.  May need ChannelWrite for sound        */
/* support.                                                                 */
/****************************************************************************/
const PSDPROCEDURE G_pWdProcedures[] =
{
    (PSDPROCEDURE)WD_Open,
    (PSDPROCEDURE)WD_Close,
    (PSDPROCEDURE)WD_RawWrite,
    (PSDPROCEDURE)WD_ChannelWrite,
    NULL, // WdSyncWrite
    (PSDPROCEDURE)WD_Ioctl,
};

/****************************************************************************/
/* WD callups                                                               */
/****************************************************************************/
const SDCALLUP G_pWdCallups[] =
{
    NULL, // buffer alloc
    NULL, // buffer free
    NULL, // buffer error
    MCSIcaRawInput,
    MCSIcaChannelInput,
};

/****************************************************************************/
/* WD Load / Unload variables                                               */
/****************************************************************************/
LONG WD_ShareId = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\nwdwcpp.cpp ===
/****************************************************************************/
// nwdwcpp.cpp
//
// WDW internal functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define pTRCWd pTSWd
#define TRC_FILE "nwdwcpp"
#include <as_conf.hpp>

extern "C" {
#include <nwdwint.h>
#include <asmint.h>
#include <asmapi.h>
#include <ntverp.h>
}
#include "slicense.h"
#include <anmapi.h>
#include <mcsioctl.h>
#include "domain.h"

//Client side error reporting
#include "tserrs.h"

#ifdef DC_DEBUG
extern "C" {
    VOID IcaBreakOnDebugger( );
}
#endif


extern "C" {

/****************************************************************************/
/* Data returned on IOCTL_VIDEO_QUERY_CURRENT_MODE                          */
/*                                                                          */
/* This code unashamedly filched from Remotedd code developed for           */
/* NetMeeting.                                                              */
/****************************************************************************/
const VIDEO_MODE_INFORMATION wdSimModes[] =
{
    sizeof(VIDEO_MODE_INFORMATION),     /* length                           */
    0,                                  /* Mode index                       */

    /************************************************************************/
    /* VisScreenWidth and VisScreenHeight can be in two forms:              */
    /* - 0xaaaabbbb - range of values supported (aaaa = max, bbbb = min)    */
    /* - 0x0000aaaa - single value supported                                */
    /* For example:                                                         */
    /* - 0x07d0012c = 2000-300                                              */
    /* - 0x0640012c = 1600-300                                              */
    /* - 0x04b000c8 = 1200-200                                              */
    /*                                                                      */
    /* @@@MF For now, support 800x600 only                                  */
    /************************************************************************/
    0x00000320,                     /* VisScreenWidth                       */
    0x00000258,                     /* VisScrenHeight                       */

    0x00000320,                     /* ScreenStride (0xffff0000 = any)      */
    0x00000001,                     /* NumberOfPlanes                       */
    0x00000008,                     /* BitsPerPlane                         */
    0,                              /* Frequency                            */
    0,                              /* XMillimeter                          */
    0,                              /* YMillimeter                          */
    0,                              /* NumberRedBits                        */
    0,                              /* NumberGreenBits                      */
    0,                              /* NumberBlueBits                       */
    0x00000000,                     /* RedMask                              */
    0x00000000,                     /* GreenMask                            */
    0x00000000,                     /* BlueMask                             */
    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
                                    /* AttributeFlags                       */
    0x00000320,                     /* VideoMemoryBitmapWidth               */
    0x00000258,                     /* VideoMemoryBitmapHeight              */
    0                               /* DriverSpecificAttributeFlags         */
};


#ifdef DC_DEBUG
/****************************************************************************/
/* IOCtl descriptions (debug build only)                                    */
/****************************************************************************/
const char *wdIoctlA[] =
{
    "IOCTL_ICA_SET_TRACE",
    "IOCTL_ICA_TRACE",
    "IOCTL_ICA_SET_SYSTEM_TRACE",
    "IOCTL_ICA_SYSTEM_TRACE",
    "IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "IOCTL_ICA_STACK_PUSH",
    "IOCTL_ICA_STACK_POP",
    "IOCTL_ICA_STACK_CREATE_ENDPOINT",
    "IOCTL_ICA_STACK_CD_CREATE_ENDPOINT",
    "IOCTL_ICA_STACK_OPEN_ENDPOINT",
    "IOCTL_ICA_STACK_CLOSE_ENDPOINT",
    "IOCTL_ICA_STACK_ENABLE_DRIVER",
    "IOCTL_ICA_STACK_CONNECTION_WAIT",
    "IOCTL_ICA_STACK_WAIT_FOR_ICA",
    "IOCTL_ICA_STACK_CONNECTION_QUERY",
    "IOCTL_ICA_STACK_CONNECTION_SEND",
    "IOCTL_ICA_STACK_CONNECTION_REQUEST",
    "IOCTL_ICA_STACK_QUERY_PARAMS",
    "IOCTL_ICA_STACK_SET_PARAMS",
    "IOCTL_ICA_STACK_ENCRYPTION_OFF",
    "IOCTL_ICA_STACK_ENCRYPTION_PERM",
    "IOCTL_ICA_STACK_CALLBACK_INITIATE",
    "IOCTL_ICA_STACK_QUERY_LAST_ERROR",
    "IOCTL_ICA_STACK_WAIT_FOR_STATUS",
    "IOCTL_ICA_STACK_QUERY_STATUS",
    "IOCTL_ICA_STACK_REGISTER_HOTKEY",
    "IOCTL_ICA_STACK_CANCEL_IO",
    "IOCTL_ICA_STACK_QUERY_STATE",
    "IOCTL_ICA_STACK_SET_STATE",
    "IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME",
    "IOCTL_ICA_STACK_TRACE",
    "IOCTL_ICA_STACK_CALLBACK_COMPLETE",
    "IOCTL_ICA_STACK_CD_CANCEL_IO",
    "IOCTL_ICA_STACK_QUERY_CLIENT",
    "IOCTL_ICA_STACK_QUERY_MODULE_DATA",
    "IOCTL_ICA_STACK_REGISTER_BROKEN",
    "IOCTL_ICA_STACK_ENABLE_IO",
    "IOCTL_ICA_STACK_DISABLE_IO",
    "IOCTL_ICA_STACK_SET_CONNECTED",
    "IOCTL_ICA_STACK_SET_CLIENT_DATA",
    "IOCTL_ICA_STACK_QUERY_BUFFER",
    "IOCTL_ICA_STACK_DISCONNECT",
    "IOCTL_ICA_STACK_RECONNECT",
    "IOCTL_ICA_STACK_CONSOLE_CONNECT",
    "IOCTL_ICA_STACK_SET_CONFIG"
};

const char *wdIoctlB[] =
{
    "IOCTL_ICA_CHANNEL_TRACE",
    "IOCTL_ICA_CHANNEL_ENABLE_SHADOW",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "IOCTL_ICA_VIRTUAL_LOAD_FILTER",
    "IOCTL_ICA_VIRTUAL_UNLOAD_FILTER",
    "IOCTL_ICA_VIRTUAL_ENABLE_FILTER",
    "IOCTL_ICA_VIRTUAL_DISABLE_FILTER",
    "IOCTL_ICA_VIRTUAL_BOUND",
    "IOCTL_ICA_VIRTUAL_CANCEL_INPUT",
    "IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT",
    "IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA",
    "IOCTL_ICA_VIRTUAL_QUERY_BINDINGS",
    "IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES",
    "IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE",
    "IOCTL_ICA_STACK_SEND_CLIENT_LICENSE",
    "IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE",
    "IOCTL_ICA_STACK_GET_LICENSE_DATA",
    "IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU",
    "IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO",
    "IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION",
    "IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED",
    "IOCTL_ICA_STACK_QUERY_AUTORECONNECT"
};

const char *wdIoctlC[] =
{
    "IOCTL_VIDEO_QUERY_AVAIL_MODES",
    "IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES",
    "IOCTL_VIDEO_QUERY_CURRENT_MODE",
    "IOCTL_VIDEO_SET_CURRENT_MODE",
    "IOCTL_VIDEO_RESET_DEVICE",
    "IOCTL_VIDEO_LOAD_AND_SET_FONT",
    "IOCTL_VIDEO_SET_PALETTE_REGISTERS",
    "IOCTL_VIDEO_SET_COLOR_REGISTERS",
    "IOCTL_VIDEO_ENABLE_CURSOR",
    "IOCTL_VIDEO_DISABLE_CURSOR",
    "IOCTL_VIDEO_SET_CURSOR_ATTR",
    "IOCTL_VIDEO_QUERY_CURSOR_ATTR",
    "IOCTL_VIDEO_SET_CURSOR_POSITION",
    "IOCTL_VIDEO_QUERY_CURSOR_POSITION",
    "IOCTL_VIDEO_ENABLE_POINTER",
    "IOCTL_VIDEO_DISABLE_POINTER",
    "IOCTL_VIDEO_SET_POINTER_ATTR",
    "IOCTL_VIDEO_QUERY_POINTER_ATTR",
    "IOCTL_VIDEO_SET_POINTER_POSITION",
    "IOCTL_VIDEO_QUERY_POINTER_POSITION",
    "IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES",
    "IOCTL_VIDEO_GET_BANK_SELECT_CODE",
    "IOCTL_VIDEO_MAP_VIDEO_MEMORY",
    "IOCTL_VIDEO_UNMAP_VIDEO_MEMORY",
    "IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES",
    "IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES",
    "IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES",
    "IOCTL_VIDEO_SET_POWER_MANAGEMENT",
    "IOCTL_VIDEO_GET_POWER_MANAGEMENT",
    "IOCTL_VIDEO_SHARE_VIDEO_MEMORY",
    "IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY",
};

const char *wdIoctlD[] =
{
    "IOCTL_KEYBOARD_ICA_INPUT",
    "IOCTL_KEYBOARD_ICA_LAYOUT",
    "IOCTL_KEYBOARD_ICA_SCANMAP",
    "IOCTL_KEYBOARD_ICA_TYPE"
};

const char *wdIoctlE[] =
{
    "IOCTL_VIDEO_ICA_QUERY_FONT_PAIRS",
    "IOCTL_VIDEO_ICA_ENABLE_GRAPHICS",
    "IOCTL_VIDEO_ICA_DISABLE_GRAPHICS",
    "IOCTL_VIDEO_ICA_SET_CP",
    "IOCTL_VIDEO_ICA_STOP_OK",
    "IOCTL_VIDEO_ICA_REVERSE_MOUSE_POINTER",
    "IOCTL_VIDEO_ICA_COPY_FRAME_BUFFER",
    "IOCTL_VIDEO_ICA_WRITE_TO_FRAME_BUFFER",
    "IOCTL_VIDEO_ICA_INVALIDATE_MODES",
    "IOCTL_VIDEO_ICA_SCROLL",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "IOCTL_ICA_STACK_ENCRYPTION_ENTER",
    "IOCTL_ICA_STACK_ENCRYPTION_EXIT",
};

const char *wdIoctlTsh[] =
{
    "IOCTL_WDTS_DD_CONNECT",
    "IOCTL_WDTS_DD_DISCONNECT",
    "IOCTL_WDTS_DD_RECONNECT",
    "IOCTL_WDTS_DD_OUTPUT_AVAILABLE",
    "IOCTL_WDTS_DD_TIMER_INFO",
    "IOCTL_WDTS_DD_CLIP",
    "IOCTL_WDTS_DD_SHADOW_CONNECT",
    "IOCTL_WDTS_DD_SHADOW_DISCONNECT",
    "IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE",
    "IOCTL_WDTS_DD_REDRAW_SCREEN",
    "IOCTL_WDTS_DD_QUERY_SHADOW_CAPS",
    "IOCTL_WDTS_DD_GET_BITMAP_KEYDATABASE",
};
#endif /* DC_DEBUG */





/****************************************************************************/
// WD_Ioctl
//
// Query/Set configuration information for the WD.
/****************************************************************************/
NTSTATUS WD_Ioctl(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    UINT32   bufferLen;
    unsigned fn;
    PVIDEO_MODE_INFORMATION pVidInfo;

    DC_BEGIN_FN("WD_Ioctl");

    // Special-case output-available DD ioctl for speed - separating the
    // most commonly-run case into a separate if that will tend to fall
    // through greatly speeds up Pentium Pro branch prediction and cache
    // line hit probability.
    if (pSdIoctl->IoControlCode == IOCTL_WDTS_DD_OUTPUT_AVAILABLE) {
        PTSHARE_DD_OUTPUT_IN pOutputIn;
        PTSHARE_DD_OUTPUT_OUT pOutputOut;
        ShareClass *dcShare;

        // Local variables to make the code more readable.
        pOutputIn = (PTSHARE_DD_OUTPUT_IN)pSdIoctl->InputBuffer;
        pOutputOut = (PTSHARE_DD_OUTPUT_OUT)pSdIoctl->OutputBuffer;
        dcShare = (ShareClass *)(pTSWd->dcShare);
        dcShare->m_pShm = (PSHM_SHARED_MEMORY)pOutputIn->pShm;

        WDW_CHECK_SHM((pOutputIn->pShm));

        if ((pTSWd->StackClass == Stack_Primary) ||
                (pTSWd->StackClass == Stack_Console)) {
            INT32 milliSecs;

            TRC_DBG((TB, "IOCTL_WDTS_DD_OUTPUT_AVAILABLE"));

            if (!pTSWd->dead) {
                TRC_DBG((TB, "OK to process the IOCtl"));

                TRC_ASSERT((dcShare != NULL), (TB, "NULL Share Class"));

                // NB There is no code here to check the size of the buffers
                // on the IOCtl.  This is a performance critical path which
                // can do without it.
                TRC_DBG((TB, "OutputAvailable IOCtl: force send=%d",
                        pOutputIn->forceSend));

                // Check if the framebuffer is valid
                if (pOutputIn->pFrameBuf != NULL &&
                        pOutputIn->frameBufHeight != 0 &&
                        pOutputIn->frameBufWidth != 0) {

                    // For normal output IOCTLs, call DCS_TTDS.
                    if (!pOutputIn->schedOnly) {
                        TRC_DBG((TB, "Normal output"));

                        // Stop the timer (in the main we don't use it, so
                        // avoid excess context switches).
                        WDWStopRITTimer(pTSWd);

                        // Call the Share Core to do the work.

                        // need to return status code so caller can bail out
                        // in case of error
                        status = dcShare->DCS_TimeToDoStuff(pOutputIn,
                                &(pOutputOut->schCurrentMode), &milliSecs);

                        // Restart the timer if requested by the core.
                        if (milliSecs != -1L) {
                            TRC_DBG((TB, "Run the RIT timer for %ld ms", milliSecs));
                            WDW_StartRITTimer(pTSWd, milliSecs);
                        }
                        else {
                            TRC_DBG((TB, "Skipped starting the timer!"));
                        }
                    }
                    else {
                        // It's just a wake-up call to the scheduler.
                        TRC_NRM((TB, "Just wake up the scheduler"));
                        dcShare->SCH_ContinueScheduling(SCH_MODE_NORMAL);

                        // Be sure to set the current scheduler mode.
                        pOutputOut->schCurrentMode = dcShare->SCH_GetCurrentMode();
                    }
                    pOutputOut->schInputKickMode = dcShare->SCH_GetInputKickMode();
                }
                else {
                    TRC_ERR((TB, "Bad FrameBuffer input parameter"));
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else {
                dcShare->DCS_DiscardAllOutput();
                TRC_ERR((TB, "Dead - ignoring IOCTL_WDTS_DD_OUTPUT_AVAILABLE"));
                status = STATUS_DEVICE_NOT_READY;
            }

            dcShare->m_pShm = NULL;
            WDW_CHECK_SHM((pOutputIn->pShm));
            DC_QUIT;
        }

        // Shadow stack: Duplicate the data send.  Note that the target's primary
        // stack will have already placed the data in the shadow buffer so we
        // don't need to re-encode it.  There may be multiple shadow stacks
        // consuming data from the primary stack so don't touch it!
        else {
            PSHADOW_INFO pShadowInfo = dcShare->m_pShm->pShadowInfo;

            if (pShadowInfo && pShadowInfo->messageSize) {
                PBYTE pShadowBuffer;
                //
                //find out if the stack doesn't want a low water mark
                //if so, allocate out of the ring (8192)
                //
                UINT32 sizeToAlloc = IcaGetSizeForNoLowWaterMark(pTSWd->pContext);
                
                // fWait is TRUE means that we will always wait for a buffer to be avail
                status = SM_AllocBuffer(dcShare->m_pSmInfo, (PPVOID) &pShadowBuffer,
                    sizeToAlloc > pShadowInfo->messageSize? sizeToAlloc : pShadowInfo->messageSize,
                    TRUE, FALSE);

                if ( STATUS_SUCCESS == status ) {

                    memcpy(pShadowBuffer, pShadowInfo->data,
                           pShadowInfo->messageSize);

                    if (SM_SendData(dcShare->m_pSmInfo, pShadowBuffer,
                            pShadowInfo->messageSize, PROT_PRIO_MISC, 0,
                            FALSE, RNS_SEC_ENCRYPT, FALSE)) {
                        status = STATUS_SUCCESS;
                        TRC_NRM((TB, "Shadow stack send: %ld",
                                pShadowInfo->messageSize));
                    }
                    else {
                        status = STATUS_UNEXPECTED_IO_ERROR;
                        TRC_ALT((TB, "Shadow stack send failed: %ld",
                                pShadowInfo->messageSize));
                    }
#ifdef DC_HICOLOR
                    // Is there any overflow data too send?
                    if (pShadowInfo->messageSizeEx)
                    {
                        status = SM_AllocBuffer(dcShare->m_pSmInfo,(PPVOID)&pShadowBuffer,
                                           (sizeToAlloc > pShadowInfo->messageSizeEx )? 
                                           sizeToAlloc : pShadowInfo->messageSizeEx, 
                                           TRUE, FALSE);

                        if ( STATUS_SUCCESS == status )
                        {

                            memcpy(
                                 pShadowBuffer,
                                 &pShadowInfo->data[WD_MAX_SHADOW_BUFFER],
                                 pShadowInfo->messageSizeEx);

                            if (SM_SendData(dcShare->m_pSmInfo,
                                            pShadowBuffer,
                                            pShadowInfo->messageSizeEx,
                                            PROT_PRIO_MISC, 0, FALSE, RNS_SEC_ENCRYPT, FALSE))
                            {
                                status = STATUS_SUCCESS;
                                TRC_NRM((TB, "Shadow stack send: %ld",
                                            pShadowInfo->messageSizeEx));
                            }
                            else
                            {
                                status = STATUS_UNEXPECTED_IO_ERROR;
                                TRC_ALT((TB, "Shadow stack send failed: %ld",
                                             pShadowInfo->messageSizeEx));
                            }
                        }
                        else
                        {
                            // Prevent regression, keep original return code
                            status = STATUS_UNEXPECTED_IO_ERROR;
                            TRC_ERR((TB, "Failed to allocate shadow stack send buffer"));
                        }
                    }
#endif
                }
                else {
                    // Prevent regression, keep original return code
                    status = STATUS_UNEXPECTED_IO_ERROR;
                    TRC_ERR((TB, "Failed to allocate shadow stack send buffer"));
                }

            }

            dcShare->m_pShm = NULL;
            WDW_CHECK_SHM((pOutputIn->pShm));
            DC_QUIT;
        }
    }
    else {
        // Non-perf path IOCTLs.
        fn = WDW_IOCTL_FUNCTION(pSdIoctl->IoControlCode);
        TRC_NRM((TB, "%s (%d)",
                fn == 6     ? "IOCTL_VIDEO_ENUM_MONITOR_PDO" :
                fn <  49    ?  wdIoctlA[fn] :
                fn <  50    ? "Unknown Ioctl" :
                fn <  77    ?  wdIoctlB[fn - 50] :
                fn <  0x100 ? "Unknown Ioctl" :
                fn <  0x11f ?  wdIoctlC[fn - 0x100] :
                fn <  0x200 ? "Unknown Ioctl" :
                fn <  0x204 ?  wdIoctlD[fn - 0x200] :
                fn == 0x300 ? "IOCTL_MOUSE_ICA_INPUT" :
                fn <  0x400 ? "Unknown Ioctl" :
                fn <  0x412 ?  wdIoctlE[fn - 0x400] :
                fn == 0x500 ? "IOCTL_T120_REQUEST" :
                fn <  0x510 ? "Unknown Ioctl" :
                fn <  0x520 ?  wdIoctlTsh[fn - 0x510] :
                fn == 0x900 ? "IOCTL_TSHARE_CONF_CONNECT" :
                fn == 0x901 ? "IOCTL_TSHARE_CONF_DISCONNECT" :
                fn == 0x903 ? "IOCTL_TSHARE_USER_LOGON" :
                fn == 0x904 ? "IOCTL_TSHARE_GET_SEC_DATA" :
                fn == 0x905 ? "IOCTL_TSHARE_SET_SEC_DATA" :
                fn == 0x906 ? "IOCTL_TSHARE_SET_NO_ENCRYPT" :
                fn == 0x907 ? "IOCTL_TSHARE_QUERY_CHANNELS" :
                fn == 0x908 ? "IOCTL_TSHARE_CONSOLE_CONNECT" :
                fn == 0x909 ? "IOCTL_TSHARE_SEND_CERT_DATA" :
                fn == 0x90A ? "IOCTL_TSHARE_GET_CERT_DATA" :
                fn == 0x90B ? "IOCTL_TSHARE_SEND_CLIENT_RANDOM" :
                fn == 0x90C ? "IOCTL_TSHARE_GET_CLIENT_RANDOM" :
                fn == 0x90D ? "IOCTL_TSHARE_SHADOW_CONNECT" :
                fn == 0x90E ? "IOCTL_TSHARE_SET_ERROR_INFO" :
                              "Unknown Ioctl",
                fn));
    }


    /************************************************************************/
    /* Firstly, zero the no. of returned bytes.                             */
    /************************************************************************/
    pSdIoctl->BytesReturned = 0;

    switch ( pSdIoctl->IoControlCode ) {


        /********************************************************************/
        // We expect IOCTL_ICA_TRACE before tracing anything. Check for NULL
        // Inbuf - we've seen this happen.
        //
        //   *** DO NOT TRACE IN THIS BRANCH ***
        /********************************************************************/
        case IOCTL_ICA_TRACE:
        {
            PICA_TRACE_BUFFER pTrc = (PICA_TRACE_BUFFER)pSdIoctl->InputBuffer;
            if (pTrc != NULL)
            {
                IcaStackTrace(pTSWd->pContext,
                              TC_DISPLAY, // @@@MF Should be pTrc->TraceClass
                                          // but it's overwritten with '7'
                              pTrc->TraceEnable,
                              (char *)pTrc->Data);
            }
            break;
        }


/****************************************************************************/
/****************************************************************************/
/* Firstly, for debug purposes, group together those IOCtls that we do not  */
/* expect to get (ICA uses them for text mode support, which we do not      */
/* implement).                                                              */
/****************************************************************************/
/****************************************************************************/

        case IOCTL_VIDEO_QUERY_CURSOR_ATTR :
        case IOCTL_VIDEO_SET_CURSOR_ATTR :
        case IOCTL_VIDEO_QUERY_CURSOR_POSITION :
        case IOCTL_VIDEO_SET_CURSOR_POSITION :
        case IOCTL_VIDEO_ENABLE_CURSOR :
        case IOCTL_VIDEO_DISABLE_CURSOR :
        case IOCTL_VIDEO_QUERY_POINTER_ATTR :
        case IOCTL_VIDEO_SET_POINTER_ATTR :
        case IOCTL_VIDEO_QUERY_POINTER_POSITION :
        case IOCTL_VIDEO_ENABLE_POINTER :
        case IOCTL_VIDEO_DISABLE_POINTER :
        case IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES :
        case IOCTL_VIDEO_SET_PALETTE_REGISTERS :
        case IOCTL_VIDEO_LOAD_AND_SET_FONT :
        case IOCTL_VIDEO_MAP_VIDEO_MEMORY :
        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY :
        case IOCTL_VIDEO_ICA_QUERY_FONT_PAIRS :
        case IOCTL_VIDEO_ICA_COPY_FRAME_BUFFER :
        case IOCTL_VIDEO_ICA_WRITE_TO_FRAME_BUFFER :
        case IOCTL_VIDEO_ICA_REVERSE_MOUSE_POINTER :
        case IOCTL_VIDEO_ICA_SET_CP :
        case IOCTL_VIDEO_ICA_SCROLL :

        {
            TRC_ALT((TB, "Unexpected IOCtl %x (function %d)",
                    pSdIoctl->IoControlCode,
                    WDW_IOCTL_FUNCTION(pSdIoctl->IoControlCode)));
        }
        break;

/****************************************************************************/
/****************************************************************************/
/*  Now the IOCtls that we do nothing with but just return OK.              */
/****************************************************************************/
/****************************************************************************/

        /********************************************************************/
        /* Both of the following are expected (they occur whenever we       */
        /* enable or disable graphics - typically when the client is        */
        /* minimized and restored).  However we don't need to do anything   */
        /* with them.                                                       */
        /********************************************************************/
        case IOCTL_VIDEO_ICA_ENABLE_GRAPHICS :
        case IOCTL_VIDEO_ICA_DISABLE_GRAPHICS :

        /********************************************************************/
        /* Miscellaneous IOCTLs we don't process.                           */
        /********************************************************************/
        case IOCTL_ICA_STACK_DISCONNECT:
        case IOCTL_VIDEO_SET_POINTER_POSITION :
        case IOCTL_VIDEO_ICA_STOP_OK :
        case IOCTL_ICA_STACK_SET_CLIENT_DATA:
        case IOCTL_ICA_STACK_ENCRYPTION_OFF:
        case IOCTL_ICA_STACK_ENCRYPTION_PERM:
        case IOCTL_VIDEO_ICA_INVALIDATE_MODES :
        {
            TRC_NRM((TB, "Nothing to do"));
        }
        break;

/****************************************************************************/
/****************************************************************************/
/* Here are a block of IOCtls that we process exactly as per Citrix.  The   */
/* calls are to unmodified Citrix routines.                                 */
/****************************************************************************/
/****************************************************************************/
        case IOCTL_KEYBOARD_QUERY_ATTRIBUTES :
        {
            status = KeyboardQueryAttributes( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_QUERY_TYPEMATIC :
        {
            status = KeyboardQueryTypematic( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_SET_TYPEMATIC :
        {
            status = KeyboardSetTypematic( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_QUERY_INDICATORS :
        {
            status = KeyboardQueryIndicators( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_SET_INDICATORS :
        {
            status = KeyboardSetIndicators( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION :
        {
            status = KeyboardQueryIndicatorTranslation( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_SET_IME_STATUS :
        {
            status = KeyboardSetImeStatus( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_MOUSE_QUERY_ATTRIBUTES :
        {
            status = MouseQueryAttributes( pTSWd, pSdIoctl );
        }
        break;

        case IOCTL_KEYBOARD_ICA_LAYOUT :
            status = KeyboardSetLayout( pTSWd, pSdIoctl );
            break;

        case IOCTL_KEYBOARD_ICA_SCANMAP :
            status = KeyboardSetScanMap( pTSWd, pSdIoctl );
            break;

        case IOCTL_KEYBOARD_ICA_TYPE :
            status = KeyboardSetType( pTSWd, pSdIoctl );
            break;

/****************************************************************************/
/****************************************************************************/
/* The next set of cases are the IOCtls with which we do significant real   */
/* work.                                                                    */
/****************************************************************************/
/****************************************************************************/

        // stash our new session ID
        case IOCTL_ICA_STACK_RECONNECT:
        {
           TRC_NRM((TB, "Got reconnect IOCTL"));
           TRC_ASSERT((pSdIoctl->InputBufferLength == sizeof(ICA_STACK_RECONNECT)),
                      (TB, "Bad Reconnect Info"));
           pTSWd->sessionId =
              ((PICA_STACK_RECONNECT)(pSdIoctl->InputBuffer))->sessionId;
        }
        break;

        case IOCTL_ICA_SET_TRACE:
        {
#ifdef DC_DEBUG
            TRC_UpdateConfig(pTSWd, pSdIoctl);
            TRC_NRM((TB, "Got Set Trace IOCtl"));
#endif
        }
        break;

        case IOCTL_BEEP_SET:
        {
            TRC_NRM((TB, "Got Beep Set IOCtl"));
            WDWSendBeep(pTSWd, pSdIoctl);
        }
        break;

        case IOCTL_TSHARE_USER_LOGON:
        {
            TRC_NRM((TB, "Got user logon IOCtl"));
            WDWUserLoggedOn(pTSWd, pSdIoctl);
            pSdIoctl->BytesReturned = 0;
        }
        break;

        case IOCTL_TSHARE_GET_SEC_DATA:
        {
            TRC_NRM((TB, "Got GetSecurityData IOCtl"));

            status = SM_GetSecurityData(pTSWd->pSmInfo, pSdIoctl);
        }
        break;

        case IOCTL_TSHARE_SET_SEC_DATA:
        {
            TRC_NRM((TB, "Got SetSecurityData IOCtl"));

            if ((pSdIoctl->InputBuffer != NULL) &&
                     (pSdIoctl->InputBufferLength >= sizeof(SECINFO))) {
                status = pTSWd->SessKeyCreationStatus =
                        SM_SetSecurityData(pTSWd->pSmInfo,
                        (PSECINFO) pSdIoctl->InputBuffer);
            }
            else {
                // NULL data is sent when the client random or shadow
                // stack random could not be generated in user mode,
                // likely because of decryption failure on the random value.
                // We need to succeedd the IOCTL, but fail the key creation
                // return to the pSessKeyEvent waiter.
                status = STATUS_SUCCESS;
                pTSWd->SessKeyCreationStatus = STATUS_UNSUCCESSFUL;
            }

            // We always set the session key event to prevent a deadlock
            // if we are being attacked with bad client security data. This
            // set used to be in SM_SetSecurityData(), but there it might
            // not have been set if any encryption errors occurred.
            KeSetEvent(pTSWd->pSessKeyEvent, 0, FALSE);
        }
        break;


        // The shadow server sends it's certificate and shadow random to the
        // shadow client, which then sends an encrypted client random.  This
        // is identical to the standard connection sequence.
        case IOCTL_TSHARE_SEND_CERT_DATA:
        {
            ShareClass *dcShare;
            dcShare = (ShareClass *)(pTSWd->dcShare);

            status = dcShare->SC_SendServerCert(
                        (PSHADOWCERT) pSdIoctl->InputBuffer,
                        pSdIoctl->InputBufferLength);
        }
        break;

        case IOCTL_TSHARE_SEND_CLIENT_RANDOM:
        {
            ShareClass *dcShare;
            dcShare = (ShareClass *)(pTSWd->dcShare);

            status = dcShare->SC_SendClientRandom((PBYTE) pSdIoctl->InputBuffer,
                                                  pSdIoctl->InputBufferLength);
        }
        break;

        case IOCTL_TSHARE_GET_CERT_DATA:
        case IOCTL_TSHARE_GET_CLIENT_RANDOM:
        {
            ShareClass *dcShare;
            dcShare = (ShareClass *)(pTSWd->dcShare);

            status = dcShare->SC_GetSecurityData(pSdIoctl);
        }
        break;

        case IOCTL_ICA_STACK_SET_CONFIG:
        {
            PICA_STACK_CONFIG_DATA pConfigData;
            pConfigData = (PICA_STACK_CONFIG_DATA) pSdIoctl->InputBuffer;

            TRC_NRM((TB, "Got stack config data"));
            WDWSetConfigData(pTSWd, pConfigData);
        }
        break;

        case IOCTL_ICA_STACK_WAIT_FOR_ICA :
        {
            /****************************************************************/
            /* Return the "default query stack," meaning reuse these        */
            /* drivers.                                                     */
            /****************************************************************/
            TRC_NRM((TB, "Stack wait for ICA"));
        }
        break;

        case IOCTL_ICA_STACK_CONSOLE_CONNECT :
        {
            /****************************************************************/
            /* Return the "default query stack," meaning reuse these        */
            /* drivers.                                                     */
            /****************************************************************/
            TRC_NRM((TB, "Stack Console Connect"));
        }
        break;

        case IOCTL_ICA_STACK_QUERY_BUFFER :
        {
            ICA_STACK_QUERY_BUFFER  *pBuffers;
            pBuffers = (ICA_STACK_QUERY_BUFFER *) pSdIoctl->OutputBuffer;

            pBuffers->WdBufferCount = TSHARE_WD_BUFFER_COUNT;
            pBuffers->TdBufferSize = TSHARE_TD_BUFFER_SIZE;

            pSdIoctl->BytesReturned = sizeof(ICA_STACK_QUERY_BUFFER);
            TRC_NRM((TB, "Stack query buffer, num %d, size %d",
                    pBuffers->WdBufferCount,
                    pBuffers->TdBufferSize));
        }
        break;

        case IOCTL_TSHARE_CONF_CONNECT:
        {
            TRC_NRM((TB, "Got TSHARE_CONF_CONNECT IOCtl"));
            status = WDWConfConnect(pTSWd, pSdIoctl);
        }
        break;

        case IOCTL_TSHARE_CONSOLE_CONNECT:
        {
            TRC_NRM((TB, "Got TSHARE_CONSOLE_CONNECT IOCtl"));
            status = WDWConsoleConnect(pTSWd, pSdIoctl);
        }
        break;

        case IOCTL_TSHARE_SHADOW_CONNECT:
            status = WDWShadowConnect(pTSWd, pSdIoctl) ;
            break;

        case IOCTL_TSHARE_SET_ERROR_INFO:
        {
            TRC_NRM((TB, "Got SetErrorInfo IOCtl"));
            status = WDWSetErrorInfo(pTSWd, pSdIoctl);
            pSdIoctl->BytesReturned = 0;
        }
        break;

        case IOCTL_TSHARE_SEND_ARC_STATUS:
        {
            TRC_NRM((TB, "Got SetArcStatus IOCtl"));
            status = WDWSendArcStatus(pTSWd, pSdIoctl);
            pSdIoctl->BytesReturned = 0;
        }
        break;

        case IOCTL_ICA_STACK_SET_CONNECTED:
            status = STATUS_SUCCESS;
            break;

        case IOCTL_ICA_STACK_CONNECTION_QUERY :
        {
            PICA_STACK_CONFIG pIcaStackConfig;

            pIcaStackConfig = (PICA_STACK_CONFIG) pSdIoctl->OutputBuffer;
            memcpy(pIcaStackConfig->WdDLL,
                   pTSWd->DLLName,
                   sizeof(pIcaStackConfig->WdDLL));
            pIcaStackConfig->SdClass[0] = SdNone;
            pSdIoctl->BytesReturned = pSdIoctl->OutputBufferLength;
            TRC_NRM((TB, "Stack Connection Query"));
        }
        break;

        case IOCTL_TSHARE_QUERY_CHANNELS:
        {
            TRC_NRM((TB, "Query Virtual Channel data"));
            status = NM_QueryChannels(pTSWd->pNMInfo,
                                      pSdIoctl->OutputBuffer,
                                      pSdIoctl->OutputBufferLength,
                                      &(pSdIoctl->BytesReturned));
        }
        break;

        case IOCTL_WDTS_DD_CONNECT:
        {
            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm)) {
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
    
                TRC_DBG((TB, "Got TSHARE_DD_CONNECT IOCtl"));
                status = WDWDDConnect(pTSWd, pSdIoctl, FALSE);
    
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

        case IOCTL_WDTS_DD_DISCONNECT:
        {
            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm)) {
            
                WDW_CHECK_SHM(
                       (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm));
    
                TRC_ALT((TB, "Got TSHARE_DD_DISCONNECT IOCtl: Stack (%ld)",
                         pTSWd->StackClass));
                if ((pTSWd->StackClass == Stack_Primary) ||
                    (pTSWd->StackClass == Stack_Console)) {
                    status = WDWDDDisconnect(pTSWd, pSdIoctl, FALSE);
                }
    
                WDW_CHECK_SHM(
                       (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

        case IOCTL_WDTS_DD_RECONNECT:
        {
            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm)) {
            
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
    
                TRC_DBG((TB, "Got TSHARE_DD_RECONNECT IOCtl"));
    
                if (pTSWd->shadowState == SHADOW_CLIENT) {
                    TRC_ALT((TB, "Shadow termination on reconnect, in share(%ld)",
                             pTSWd->bInShadowShare));
    
                    pTSWd->shadowState = SHADOW_NONE;
    
                    // If we were formerly in an active shadow, then we need to
                    // deactivate the client before reconnecting in a new share
                    if (pTSWd->bInShadowShare) {
                        ShareClass *pSC = (ShareClass *)pTSWd->dcShare;
                        pSC->SC_EndShare(TRUE);
                        pTSWd->bInShadowShare = FALSE;
                    }
                    // Make sure that Domain.StatusDead is consistent with TSWd.dead
                    pTSWd->dead = TRUE;
                    ((PDomain)(pTSWd->hDomainKernel))->StatusDead = TRUE;
                    SM_Dead(pTSWd->pSmInfo, TRUE);
    
                    if (pTSWd->bCompress == TRUE) {
    
                        // the compression history will be flushed
                        pTSWd->bFlushed = PACKET_FLUSHED;
    
                        // the compression will restart over
                        initsendcontext(pTSWd->pMPPCContext, pTSWd->pMPPCContext->ClientComprType);
                    }
                }
    
                status = WDWDDConnect(pTSWd, pSdIoctl, TRUE);
    
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

        case IOCTL_WDTS_DD_TIMER_INFO:
        {
            if (pSdIoctl->InputBufferLength < sizeof(TSHARE_DD_TIMER_INFO))
            {
                TRC_ERR((TB, "Timer info IOCtl too small at %lu",
                                            pSdIoctl->InputBufferLength));
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                /************************************************************/
                /* Store the timer handle                                   */
                /************************************************************/
                pTSWd->ritTimer =
                    ((PTSHARE_DD_TIMER_INFO)(pSdIoctl->InputBuffer))->
                                                               pKickTimer;

                TRC_DBG((TB, "Got TSHARE_DD_TIMER_INFO IOCtl, handle %p",
                                                       pTSWd->ritTimer));

                /************************************************************/
                /* Start a timer to get things moving                       */
                /************************************************************/
                WDW_StartRITTimer(pTSWd, pTSWd->outBufDelay);
            }
        }
        break;

        case IOCTL_WDTS_DD_REDRAW_SCREEN :
        {
            ShareClass *dcShare;

            dcShare = (ShareClass *)(pTSWd->dcShare);

            TRC_NRM((TB, "RDPDD requests to redraw screen\n"));

            if (dcShare != NULL) {
                // We have a valid share class, do screen redraw
                dcShare->SC_RedrawScreen();
            }
        }
        break;

        case IOCTL_ICA_STACK_CONNECTION_SEND :
        {
            // Wait for the connected indication from SM.
            TRC_DBG((TB, "About to wait for connected indication"));
            status = WDW_WaitForConnectionEvent(pTSWd,
                   pTSWd->pConnEvent, 60000);
            TRC_DBG((TB, "Back from wait for connected indication"));
            if (status != STATUS_SUCCESS) {
                TRC_ERR((TB, "Connected indication timed out (%x)",
                        status));
                status = STATUS_IO_TIMEOUT;
                DC_QUIT;
            }

            // Pass the IOCtl on to the next driver.
            status = IcaCallNextDriver(pTSWd->pContext, SD$IOCTL, pSdIoctl);
        }
        break;

        case IOCTL_ICA_STACK_QUERY_CLIENT :
        {
            status = WDWGetClientData( pTSWd, pSdIoctl );
            TRC_NRM((TB, "Return client data"));
        }
        break;

        // This IOCTL was introduced to support long UserName, Password and Domain names

        case IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED :
        {
            status = WDWGetExtendedClientData(pTSWd->pInfoPkt, pSdIoctl);
            TRC_NRM((TB, "Return Extended client data"));
        }
        break;

        case IOCTL_ICA_STACK_QUERY_AUTORECONNECT:
        {
            TRC_NRM((TB, "Query autoreconnect information"));
            status = WDWGetAutoReconnectInfo(pTSWd, pTSWd->pInfoPkt, pSdIoctl);
        }
        break;
/****************************************************************************/
/****************************************************************************/
/* Here are some IOCtls that we have to deal with in our guise of miniport  */
/* driver.                                                                  */
/****************************************************************************/
/****************************************************************************/
        case IOCTL_VIDEO_QUERY_CURRENT_MODE:
        {
            TRC_NRM((TB, "QueryCurrentModes"));

            if (pSdIoctl->OutputBufferLength <
                                           sizeof(VIDEO_MODE_INFORMATION))
            {
                TRC_ERR((TB,
                  "QueryCurrentMode buffer too small: got/expected %d/%d",
                    pSdIoctl->OutputBufferLength,
                    sizeof(VIDEO_MODE_INFORMATION) ));
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                TRC_NRM((TB, "Return current mode"));

                /************************************************************/
                /* Copy the default mode information, and then update it    */
                /* with our current screen dimensions.                      */
                /************************************************************/
                pVidInfo =
                          (PVIDEO_MODE_INFORMATION)pSdIoctl->OutputBuffer;

                memcpy(pVidInfo,
                       wdSimModes,
                       sizeof(wdSimModes));

                pVidInfo->Length = sizeof(VIDEO_MODE_INFORMATION);
                pVidInfo->VisScreenWidth = pTSWd->desktopWidth;
                pVidInfo->VisScreenHeight = pTSWd->desktopHeight;
                pVidInfo->BitsPerPlane = pTSWd->desktopBpp;
                pVidInfo->VideoMemoryBitmapWidth = pTSWd->desktopWidth;
                pVidInfo->VideoMemoryBitmapHeight = pTSWd->desktopHeight;
#ifdef DC_HICOLOR
                switch (pTSWd->desktopBpp)
                {
                    case 24:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_24BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_24BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_24BPP;
                    }
                    break;

                    case 16:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_16BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_16BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_16BPP;
                    }
                    break;

                    case 15:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_15BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_15BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_15BPP;
                    }
                    break;

                    default:
                    {
                        pVidInfo->RedMask   = 0;
                        pVidInfo->GreenMask = 0;
                        pVidInfo->BlueMask  = 0;
                    }
                    break;
                }
#endif

                pSdIoctl->BytesReturned = sizeof(wdSimModes);
            }
        }
        break;

        case IOCTL_VIDEO_QUERY_AVAIL_MODES:
        {
            TRC_NRM((TB, "QueryAvailableModes"));

            if (pSdIoctl->OutputBufferLength <
                                           sizeof(VIDEO_MODE_INFORMATION))
            {
                TRC_ERR((TB,
                  "QueryCurrentMode buffer too small: got/expected %d/%d",
                    pSdIoctl->OutputBufferLength,
                    sizeof(VIDEO_MODE_INFORMATION) ));
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                TRC_NRM((TB, "Return just one mode"));

                // Copy the default mode information, and then update it
                // with our current screen dimensions.
                pVidInfo = (PVIDEO_MODE_INFORMATION)pSdIoctl->OutputBuffer;

                memcpy(pVidInfo,
                       wdSimModes,
                       sizeof(wdSimModes));
                pVidInfo->Length = sizeof(VIDEO_MODE_INFORMATION);
                pVidInfo->VisScreenWidth = pTSWd->desktopWidth;
                pVidInfo->VisScreenHeight = pTSWd->desktopHeight;
                pVidInfo->BitsPerPlane = pTSWd->desktopBpp;
                pVidInfo->VideoMemoryBitmapWidth = pTSWd->desktopWidth;
                pVidInfo->VideoMemoryBitmapHeight = pTSWd->desktopHeight;
                pVidInfo->Frequency = 42; // required by the display cpl

#ifdef DC_HICOLOR
                switch (pTSWd->desktopBpp)
                {
                    case 24:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_24BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_24BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_24BPP;
                    }
                    break;

                    case 16:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_16BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_16BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_16BPP;
                    }
                    break;

                    case 15:
                    {
                        pVidInfo->RedMask   = TS_RED_MASK_15BPP;
                        pVidInfo->GreenMask = TS_GREEN_MASK_15BPP;
                        pVidInfo->BlueMask  = TS_BLUE_MASK_15BPP;
                    }
                    break;

                    default:
                    {
                        pVidInfo->RedMask   = 0;
                        pVidInfo->GreenMask = 0;
                        pVidInfo->BlueMask  = 0;
                    }
                    break;
                }
#endif

                pSdIoctl->BytesReturned = sizeof(wdSimModes);
            }
        }
        break;

        case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:
        {
            TRC_NRM((TB, "QueryNumAvailableModes"));
            if (pSdIoctl->OutputBufferLength < sizeof(VIDEO_NUM_MODES))
            {
                TRC_ERR((TB,
            "QueryNumAvailableModes buffer too small: got/expected %d/%d",
                        pSdIoctl->OutputBufferLength,
                        sizeof(VIDEO_NUM_MODES)));
                        status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PVIDEO_NUM_MODES pNumModes =
                        (PVIDEO_NUM_MODES)(pSdIoctl->OutputBuffer);
                TRC_NRM((TB, "Return 1 mode available"));
                pNumModes->NumModes = 1;
                pNumModes->ModeInformationLength =
                        sizeof(VIDEO_MODE_INFORMATION);
                pSdIoctl->BytesReturned = sizeof(VIDEO_NUM_MODES);
            }
        }
        break;

        case IOCTL_VIDEO_SET_CURRENT_MODE:
        {
            /****************************************************************/
            /* Not clear why we might get this, hence we trace at high      */
            /* level for now.  In any case, the IOCtl is sent to set a      */
            /* particular VGA mode: we have told Win32 what we support:     */
            /* either it is setting that, or we have a problem waiting to   */
            /* happen.                                                      */
            /****************************************************************/
            TRC_ALT((TB, "SetCurrentMode"));
            if (pSdIoctl->InputBufferLength < sizeof(VIDEO_MODE))
            {
                TRC_ERR((TB,
                        "SetCurrentMode buffer too small: got/expected %d/%d",
                        pSdIoctl->InputBufferLength, sizeof(VIDEO_MODE) ));
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                TRC_ALT((TB, "Set current mode to %d",
                        ((PVIDEO_MODE)(pSdIoctl->InputBuffer))->RequestedMode));
            }
        }
        break;

        case IOCTL_VIDEO_SET_COLOR_REGISTERS:
        {
            TRC_NRM((TB, "SetColorRegisters"));
        }
        break;

        case IOCTL_VIDEO_RESET_DEVICE:
        {
            TRC_NRM((TB, "ResetDevice"));
        }
        break;

/****************************************************************************/
/****************************************************************************/
/* IOCtls that require translation for MCS                                  */
/****************************************************************************/
/****************************************************************************/

        /********************************************************************/
        /* Process Query Bindings for local and MCS virtual channels        */
        /********************************************************************/
        case IOCTL_ICA_VIRTUAL_QUERY_BINDINGS :
        {
            PSD_VCBIND pVBind;

            /****************************************************************/
            /* This IOCtl is issued twice                                   */
            /****************************************************************/
            if (!pTSWd->bVirtualChannelBound)
            {
                /************************************************************/
                /* First time, return internal channels                     */
                /************************************************************/
                pVBind = (PSD_VCBIND) pSdIoctl->OutputBuffer;

                /************************************************************/
                /* Let MCS define channel(s)                                */
                /************************************************************/
                MCSIcaVirtualQueryBindings(pTSWd->hDomainKernel,
                                           &pVBind,
                                           (unsigned int *)&pSdIoctl->
                                                              BytesReturned);

                // Add RDPDD->RDPWD channel.
                RtlCopyMemory(pVBind->VirtualName,
                              VIRTUAL_THINWIRE,
                              sizeof(VIRTUAL_THINWIRE));
                pVBind->VirtualClass = WD_THINWIRE_CHANNEL;
                pSdIoctl->BytesReturned += sizeof(SD_VCBIND);
                pTSWd->bVirtualChannelBound = TRUE;
                TRC_NRM((TB, "%d Virtual Channels (first time)",
                        pSdIoctl->BytesReturned/sizeof(SD_VCBIND)));
            }
            else
            {
                /************************************************************/
                /* Second time, return virtual channels                     */
                /************************************************************/
                pVBind = (PSD_VCBIND)pSdIoctl->OutputBuffer;
                status = NM_VirtualQueryBindings(pTSWd->pNMInfo,
                                                 pVBind,
                                                 pSdIoctl->OutputBufferLength,
                                                 &(pSdIoctl->BytesReturned));
                TRC_NRM((TB, "%d Virtual Channels (second time)",
                        pSdIoctl->BytesReturned/sizeof(SD_VCBIND)));
            }
        }
        break;

        /********************************************************************/
        /* T.120 request from user mode - pass it on                        */
        /********************************************************************/
        case IOCTL_T120_REQUEST:
        {
            status = MCSIcaT120Request(pTSWd->hDomainKernel, pSdIoctl);
        }
        break;

#ifdef USE_LICENSE

/****************************************************************************/
/****************************************************************************/
/* Licensing IOCtls                                                         */
/****************************************************************************/
/****************************************************************************/

        /********************************************************************/
        /* Query the client licensing capabilities
        /********************************************************************/

        case IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES:
        {
            PLICENSE_CAPABILITIES pLicenseCap;

            if( pSdIoctl->OutputBufferLength < sizeof( LICENSE_CAPABILITIES ) )
            {
                TRC_ERR( ( TB,
                    "QueryLicenseCapabilities buffer too small: got/expected %d/%d",
                    pSdIoctl->OutputBufferLength, sizeof( LICENSE_CAPABILITIES ) ) );
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                //
                // set the client licensing capability.  Here we temporarily hard-code
                // the client to use the RSA key exchange algorithm and the licensing
                // protocol version.
                //

                pLicenseCap = ( PLICENSE_CAPABILITIES )( pSdIoctl->OutputBuffer );
                pLicenseCap->KeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;

                if( RNS_TERMSRV_40_UD_VERSION >= pTSWd->version )
                {
                    //
                    // this is a hydra 4.0 client, use the corresponding licensing
                    // protocol.
                    //

                    pLicenseCap->ProtocolVer = LICENSE_HYDRA_40_PROTOCOL_VERSION;
                    pLicenseCap->fAuthenticateServer = TRUE;
                }
                else
                {
                    //
                    // Use the latest licensing protocol for later clients
                    //

                    pLicenseCap->ProtocolVer = LICENSE_HIGHEST_PROTOCOL_VERSION;

                    //
                    // if encryption is enabled, then the server has already been
                    // authenticated in the earlier key exchange protocol and the
                    // licensing protocol does not have to authenticate the server
                    // again.
                    //

                    pLicenseCap->fAuthenticateServer = ( SM_IsSecurityExchangeCompleted(
                                                                pTSWd->pSmInfo,
                                                                &pLicenseCap->CertType ) ?
                                                        FALSE : TRUE );


                }

                TRC_NRM( ( TB, "Key Exchange Alg = %d", pLicenseCap->KeyExchangeAlg ) );
                TRC_NRM( ( TB, "License Protocol Version = %x", pLicenseCap->ProtocolVer ) );

                //
                // copy the client name
                //

                if( pLicenseCap->pbClientName )
                {
                    memcpy( pLicenseCap->pbClientName,
                            pTSWd->clientName,
                            ( ( pLicenseCap->cbClientName < sizeof( pTSWd->clientName ) ) ?
                            pLicenseCap->cbClientName : sizeof( pTSWd->clientName ) ) );
                }

                pSdIoctl->BytesReturned = sizeof( LICENSE_CAPABILITIES );
            }
        }
        break;

        /********************************************************************/
        /* Send and receive licensing protocol data to and from client.
        /********************************************************************/
        case IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE:
        {
            PLicense_Handle pLicenseHandle;
            BOOL rc = FALSE;
            BOOL encrypingLicToCli;
            NTSTATUS waitStatus;
            PBYTE pOutBuffer;
            PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)(pTSWd->pSmInfo);
            PRNS_SECURITY_HEADER pLicenseHeader;

            pLicenseHandle = ( PLicense_Handle )pTSWd->pSLicenseHandle;

            //
            // validate input parameters
            //
            ASSERT( NULL != pLicenseHandle );
            ASSERT( NULL != pSdIoctl->InputBuffer );
            ASSERT( 0 < pSdIoctl->InputBufferLength );

            if( ( NULL == pLicenseHandle ) ||
                ( NULL == pSdIoctl->InputBuffer ) ||
                ( 0 >= pSdIoctl->InputBufferLength ) )
            {
                TRC_ERR( ( TB, "invalid Licensing IOCTL parameters" ) );
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            if( ( pSdIoctl->OutputBuffer ) && ( pSdIoctl->OutputBufferLength > 0 ) )
            {
                //
                // set the output buffer pointer so that we can receive data
                // when the client response
                //
                pLicenseHandle->pDataBuf = ( PBYTE )pSdIoctl->OutputBuffer;
                pLicenseHandle->cbDataBuf = pSdIoctl->OutputBufferLength;
            }
            else
            {
                pLicenseHandle->pDataBuf = NULL;
                pLicenseHandle->cbDataBuf = 0;
            }

            //
            // We will encrypt the S->C licensing packet if encryption is
            // on AND if the client told us they can decrypt this particular
            // packet.
            // If encryptDisplayData is not set (low encryption), we don't
            //  encrypt the S->C licensing packet
            //
            encrypingLicToCli = (pRealSMHandle->encrypting &&
                                 pRealSMHandle->encryptingLicToClient &&
                                 pRealSMHandle->encryptDisplayData);

            if (!encrypingLicToCli)
            {
                //
                // Allocate an NM buffer for sending the data.  we are allocating an extra
                // DWORD to hack around the encryption problem.
                // fWait is TRUE means that we will always wait for a buffer to be avail
                status =  NM_AllocBuffer( pTSWd->pNMInfo,
                                      ( PPVOID )&pOutBuffer,
                                      pSdIoctl->InputBufferLength +
                                      sizeof( RNS_SECURITY_HEADER ),
                                      TRUE );

                if( STATUS_SUCCESS != status || pTSWd->hDomainKernel == NULL)
                {
                    TRC_ERR( ( TB, "Failed to allocate NM buffer" ) );

                    if (STATUS_SUCCESS == status) {
                        NM_FreeBuffer(pTSWd->pNMInfo, pOutBuffer);
                        status = STATUS_NET_WRITE_FAULT;
                    }
                    else {
                        // Follow old code path.
                        status = STATUS_NO_MEMORY;
                    }
                    break;
                }

                //
                // initialize the license data header
                //
                pLicenseHeader          = ( PRNS_SECURITY_HEADER )pOutBuffer;
                //
                // Indicate this is a licensing packet and then cheat and sneak
                // in the flag that indicates the client should encrypt all
                // licensing data sent to the server (early capabilities)
                //
                pLicenseHeader->flags   = RNS_SEC_LICENSE_PKT |
                                          RDP_SEC_LICENSE_ENCRYPT_CS;

                pLicenseHeader->flagsHi  = ( WORD )pSdIoctl->InputBufferLength;

                //
                // copy the data over
                //
                ASSERT( NULL != pOutBuffer );
                memcpy( pOutBuffer + sizeof( RNS_SECURITY_HEADER ),
                        pSdIoctl->InputBuffer,
                        pSdIoctl->InputBufferLength );
            }
            else
            {
                if (STATUS_SUCCESS == SM_AllocBuffer(pTSWd->pSmInfo, (PPVOID) &pOutBuffer, pSdIoctl->InputBufferLength, TRUE, FALSE))
                {
                    memcpy(pOutBuffer, (PBYTE)pSdIoctl->InputBuffer, pSdIoctl->InputBufferLength);
                }
                else {
                    TRC_ERR((TB, "FAILED to alloc license data buffer"));
                    status = STATUS_NO_MEMORY;
                    break;
                }
            }

            //
            // clear the incoming data event
            //
            KeClearEvent( pLicenseHandle->pDataEvent );

            //
            // send the data in the input buffer
            //
            if (encrypingLicToCli)
            {
                rc = SM_SendData(pTSWd->pSmInfo, pOutBuffer, pSdIoctl->InputBufferLength,
                        TS_HIGHPRIORITY, 0, FALSE, RNS_SEC_LICENSE_PKT | RDP_SEC_LICENSE_ENCRYPT_CS | RNS_SEC_ENCRYPT, FALSE);
            }
            else
            {
                rc = NM_SendData(pTSWd->pNMInfo, (BYTE *)pOutBuffer,
                        pSdIoctl->InputBufferLength + sizeof(RNS_SECURITY_HEADER),
                        TS_HIGHPRIORITY, 0, FALSE);
            }
            if (!rc)
            {
                TRC_ERR((TB, "Failed to send licensing data"));
                status = STATUS_NET_WRITE_FAULT;
                break;
            }

            if (pLicenseHandle->pDataBuf)
            {
                //
                // caller supplied a return buffer, wait for the client response
                //
                waitStatus = WDW_WaitForConnectionEvent(pTSWd,
                                   pLicenseHandle->pDataEvent, 60000L);
                if (STATUS_TIMEOUT == waitStatus)
                {
                    TRC_ERR( ( TB, "Timeout waiting for client licensing response" ) );
                    pSdIoctl->BytesReturned = 0;
                    status = STATUS_IO_TIMEOUT;
                }
                else
                {
                    //
                    // got the client response, check that the data is received
                    // correctly
                    //
                    if( !NT_SUCCESS( pLicenseHandle->Status ) )
                    {
                        status = pLicenseHandle->Status;

                        //
                        // The data was not copied correctly.  If the buffer provided is
                        // too small, let the caller know the right size of the
                        // buffer to provide.
                        //
                        if( STATUS_BUFFER_TOO_SMALL == status )
                        {
                            TRC_ERR( ( TB,
                                       "IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE buffer too small: got/expected %d/%d",
                                       pSdIoctl->InputBufferLength, pLicenseHandle->cbCacheBuf ) );

                            pSdIoctl->BytesReturned = pLicenseHandle->cbCacheBuf;
                        }
                        else
                        {
                            pSdIoctl->BytesReturned = 0;
                        }
                    }
                    else
                    {
                        pSdIoctl->BytesReturned = pLicenseHandle->cbDataBuf;
                    }
                }

                if (status != STATUS_SUCCESS)
                {
                    // Make sure we don't try to write to pointer when
                    // client data comes in

                    pLicenseHandle->pDataBuf = NULL;
                    pLicenseHandle->cbDataBuf = 0;
                }
            }
            else
            {
                //
                // caller did not supply a return buffer, simply return
                //
                pSdIoctl->BytesReturned = 0;
            }
        }
        break;

        /********************************************************************/
        /* Send licensing protocol data to client without waiting for reply.
        /********************************************************************/
        case IOCTL_ICA_STACK_SEND_CLIENT_LICENSE:
        {
            PLicense_Handle pLicenseHandle;
            BOOL rc = FALSE;
            BOOL encrypingLicToCli;
            PBYTE pOutBuffer;
            PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)(pTSWd->pSmInfo);
            PRNS_SECURITY_HEADER pLicenseHeader;

            pLicenseHandle = ( PLicense_Handle )pTSWd->pSLicenseHandle;

            //
            // validate input parameters
            //
            ASSERT( NULL != pLicenseHandle );
            ASSERT( NULL != pSdIoctl->InputBuffer );
            ASSERT( 0 < pSdIoctl->InputBufferLength );

            if( ( NULL == pLicenseHandle ) ||
                ( NULL == pSdIoctl->InputBuffer ) ||
                ( 0 >= pSdIoctl->InputBufferLength ) )
            {
                TRC_ERR( ( TB, "invalid Licensing IOCTL parameters" ) );
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // We will encrypt the S->C licensing packet if encryption is
            // on AND if the client told us they can decrypt this particular
            // packet.
            // If encryptDisplayData is not set (low encryption), we don't
            //  encrypt the S->C licensing packet
            //
            encrypingLicToCli = (pRealSMHandle->encrypting &&
                                 pRealSMHandle->encryptingLicToClient &&
                                 pRealSMHandle->encryptDisplayData);

            if (!encrypingLicToCli)
            {
                //
                // allocate NM buffer for sending
                // fWait is TRUE means that we will always wait for a buffer to be avail
                status =  NM_AllocBuffer( pTSWd->pNMInfo,
                                      ( PPVOID )&pOutBuffer,
                                      pSdIoctl->InputBufferLength + sizeof( RNS_SECURITY_HEADER ),
                                      TRUE );

                if( STATUS_SUCCESS != status || pTSWd->hDomainKernel == NULL)
                {
                    TRC_ERR( ( TB, "Failed to allocate SM buffer" ) );

                    if (STATUS_SUCCESS == status) {
                        NM_FreeBuffer(pTSWd->pNMInfo, pOutBuffer);
                        status = STATUS_NET_WRITE_FAULT;
                    }
                    else {
                        // Follow old code path.
                        status = STATUS_NO_MEMORY;
                    }
                    break;
                }

                //
                // initialize the license data header
                //
                pLicenseHeader          = ( PRNS_SECURITY_HEADER )pOutBuffer;
                //
                // Indicate this is a licensing packet and then cheat and sneak
                // in the flag that indicates the client should encrypt all
                // licensing data sent to the server (early capabilities)
                //
                pLicenseHeader->flags   = RNS_SEC_LICENSE_PKT |
                                          RDP_SEC_LICENSE_ENCRYPT_CS;

                pLicenseHeader->flagsHi  = ( WORD )pSdIoctl->InputBufferLength;

                //
                // copy the data over
                //
                ASSERT( NULL != pOutBuffer );
                memcpy( pOutBuffer + sizeof( RNS_SECURITY_HEADER ),
                        pSdIoctl->InputBuffer,
                        pSdIoctl->InputBufferLength );
            }
            else
            {
                if (STATUS_SUCCESS == SM_AllocBuffer(pTSWd->pSmInfo, (PPVOID) &pOutBuffer, pSdIoctl->InputBufferLength, TRUE, FALSE))
                {
                    memcpy(pOutBuffer, (PBYTE)pSdIoctl->InputBuffer, pSdIoctl->InputBufferLength);
                }
                else {
                    TRC_ERR((TB, "FAILED to alloc license data buffer"));
                    status = STATUS_NO_MEMORY;
                    break;
                }
            }

            //
            // clear the incoming data event
            //
            KeClearEvent(pLicenseHandle->pDataEvent);

            //
            // send the data in the input buffer
            //
            if (encrypingLicToCli)
            {
                rc = SM_SendData(pTSWd->pSmInfo, pOutBuffer, pSdIoctl->InputBufferLength,
                        TS_HIGHPRIORITY, 0, FALSE, RNS_SEC_LICENSE_PKT | RDP_SEC_LICENSE_ENCRYPT_CS | RNS_SEC_ENCRYPT, FALSE);
            }
            else
            {
                rc = NM_SendData(pTSWd->pNMInfo, (BYTE *)pOutBuffer,
                        pSdIoctl->InputBufferLength + sizeof(RNS_SECURITY_HEADER),
                        TS_HIGHPRIORITY, 0, FALSE);
            }
            if (!rc)
            {
                TRC_ERR( ( TB, "Failed to send licensing data" ) );
                status = STATUS_NET_WRITE_FAULT;
            }
        }
        break;

        /********************************************************************/
        /* Indicate that the licensing protocol has completed.
        /********************************************************************/
        case IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE:
        {
            PULONG pResult;

            //
            // validate input parameters
            //
            ASSERT( NULL != pSdIoctl->InputBuffer );
            ASSERT( 0 < pSdIoctl->InputBufferLength );

            if( ( NULL == pSdIoctl->InputBuffer ) ||
                ( 0 >= pSdIoctl->InputBufferLength ) )
            {
                TRC_ERR( ( TB, "invalid Licensing IOCTL parameters" ) );
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Tell SM if the client license has been validated successfully
            //
            pResult = ( PULONG )( pSdIoctl->InputBuffer );
            if( LICENSE_PROTOCOL_SUCCESS == ( *pResult ) )
            {
                SM_LicenseOK(pTSWd->pSmInfo);
            }
        }
        break;

        /********************************************************************/
        /* Indicate to retrieve the licensing data that was previously
        /* cached.
        /********************************************************************/
        case IOCTL_ICA_STACK_GET_LICENSE_DATA:
        {
            PLicense_Handle pLicenseHandle = ( PLicense_Handle )pTSWd->pSLicenseHandle;

            //
            // validate input parameters
            //
            if ((NULL == pSdIoctl->OutputBuffer) ||
                    (NULL == pLicenseHandle))
            {
                pSdIoctl->BytesReturned = 0;
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // check that there's actually cached data
            //
            if( NULL == pLicenseHandle->pCacheBuf )
            {
                pSdIoctl->BytesReturned = 0;
                status = STATUS_NO_DATA_DETECTED;
                break;
            }

            if( pSdIoctl->OutputBufferLength < pLicenseHandle->cbCacheBuf )
            {
                pSdIoctl->BytesReturned = 0;
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // copy the cached data and free the cached data buffer
            //
            memcpy(pSdIoctl->OutputBuffer,
                   pLicenseHandle->pCacheBuf,
                   pLicenseHandle->cbCacheBuf );

            pSdIoctl->BytesReturned = pLicenseHandle->cbCacheBuf;

            ExFreePool( pLicenseHandle->pCacheBuf );
            pLicenseHandle->pCacheBuf = NULL;
        }

        break;

#endif // #ifdef USE_LICENSE


/********************************************************************/
/* shadow only IOCTLS                                               */
/********************************************************************/

        // Pass all relevent stack data from the client's primary stack to the
        // target's shadow stack.
        case IOCTL_ICA_STACK_QUERY_MODULE_DATA:
            TRC_ALT((TB, "IOCTL_ICA_STACK_QUERY_MODULE_DATA(%p) - stack class %d",
                    pTSWd, pTSWd->StackClass));

            if ((pTSWd->StackClass == Stack_Primary) ||
                (pTSWd->StackClass == Stack_Console)) {
                status = WDWGetModuleData(pTSWd, pSdIoctl);
            }
            break;

        // Pass all relevant capabilities data from the client to the shadow
        // target display driver.
        case IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA:
            PTSHARE_VIRTUAL_MODULE_DATA pVirtModuleData;
            PTS_COMBINED_CAPABILITIES pCaps;
            PTS_GENERAL_CAPABILITYSET pGenCapSet;
            unsigned capsLength;
            ShareClass * dcShare;
            dcShare = (ShareClass *)(pTSWd->dcShare);

            dcShare->SC_GetCombinedCapabilities(SC_REMOTE_PERSON_ID,
                                                &capsLength, &pCaps);

            if (pCaps != NULL) {

                pGenCapSet = (PTS_GENERAL_CAPABILITYSET) WDW_GetCapSet(
                             pTSWd, TS_CAPSETTYPE_GENERAL, pCaps, capsLength);

                if (pGenCapSet != NULL) {
                    // update the compression capability
                    if (pTSWd->bCompress) {
                        pGenCapSet->extraFlags |= TS_SHADOW_COMPRESSION_LEVEL;
                        pGenCapSet->generalCompressionLevel = (TSUINT16)pTSWd->pMPPCContext->ClientComprType;
                    }
                }

                if (pSdIoctl->OutputBufferLength >=
                        (capsLength + sizeof(TSHARE_VIRTUAL_MODULE_DATA) - 1)) {
                    pVirtModuleData = (PTSHARE_VIRTUAL_MODULE_DATA) pSdIoctl->OutputBuffer;
                    pVirtModuleData->capsLength = capsLength;
                    memcpy(&pVirtModuleData->combinedCapabilities,
                           pCaps, capsLength);
                }
                else {
                    status = STATUS_BUFFER_OVERFLOW;
                }
            }
            else {
                status =  STATUS_NO_MEMORY;
            }

            pSdIoctl->BytesReturned = capsLength +
                                      sizeof(TSHARE_VIRTUAL_MODULE_DATA) - 1;
            TRC_ALT((TB, "IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA: rc=%lx, in=%ld, out=%ld",
                    status, pSdIoctl->OutputBufferLength, pSdIoctl->BytesReturned));

            break;

        case IOCTL_WDTS_DD_SHADOW_CONNECT:
        {
            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm)) {
            
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
    
                TRC_ALT((TB, "++TSHARE_DD_SHADOW_CONNECT(%p) - stack class %d",
                        pTSWd, pTSWd->StackClass));
    
                status = WDWDDShadowConnect(pTSWd, pSdIoctl);
    
                TRC_ALT((TB, "--TSHARE_DD_SHADOW_CONNECT(%p) - stack class %d",
                        pTSWd, pTSWd->StackClass));
    
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

#ifdef DC_HICOLOR
        // Maybe get the caps of the shadower
        case IOCTL_WDTS_DD_QUERY_SHADOW_CAPS:
        {
            // only respond to this if we're a shadow stack
            if (pTSWd->StackClass == Stack_Shadow)
            {
                PTS_COMBINED_CAPABILITIES pCaps;
                PTSHARE_VIRTUAL_MODULE_DATA pVMData = NULL;
                unsigned capsLength;
                ShareClass * dcShare;

                dcShare = (ShareClass *)(pTSWd->dcShare);

                if (pSdIoctl->OutputBufferLength >= sizeof(unsigned))
                {
                    pVMData = (PTSHARE_VIRTUAL_MODULE_DATA)pSdIoctl->OutputBuffer;
                }

                dcShare->SC_GetCombinedCapabilities(SC_REMOTE_PERSON_ID,
                                                    &capsLength, &pCaps);

                if (pCaps != NULL)
                {
                    if (pSdIoctl->OutputBufferLength >=
                                              (capsLength + sizeof(unsigned)))
                    {
                        memcpy(&pVMData->combinedCapabilities,
                               pCaps, capsLength);
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
                else
                {
                    status =  STATUS_NO_MEMORY;
                }

                pSdIoctl->BytesReturned = capsLength + sizeof(unsigned);
                if (pVMData)
                {
                    pVMData->capsLength = capsLength;
                }

                TRC_ALT((TB, "IOCTL_WDTS_DD_QUERY_SHADOW_CAPS:" \
                                              " rc=%lx, in=%ld, out=%ld",
                        status, pSdIoctl->OutputBufferLength,
                        pSdIoctl->BytesReturned));
            }
            else
            {
                TRC_ALT((TB, "IOCTL_WDTS_DD_QUERY_SHADOW_CAPS: " \
                             "not shadow stack so ignoring"));
                TRC_ALT((TB, " rc=%lx, in=%ld, out=%ld",
                        status, pSdIoctl->OutputBufferLength,
                        pSdIoctl->BytesReturned));
            }


        }
        break;

        case IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE:
        {
            ShareClass * dcShare;
            PTS_COMBINED_CAPABILITIES pCaps;
            unsigned capsLen;

            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm)) {
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm));

                // synchronize this stack, this is required so that OE2 will match up
                // for both shadow client and target.
                dcShare = (ShareClass *)(pTSWd->dcShare);
    
                pCaps = ((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShadowCaps;
                capsLen = ((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->capsLen;
                dcShare->SC_ShadowSyncShares(pCaps, capsLen);
    
                TRC_ALT((TB, "Synchronized share for stack [%ld]", pTSWd->StackClass));
    
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }

        }
        break;
#else
        case IOCTL_WDTS_DD_SHADOW_SYNCHRONIZE:
        {
            ShareClass * dcShare;

            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm)) {
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm));
    
                // synchronize this stack, this is required so that OE2 will match up
                // for both shadow client and target.
                dcShare = (ShareClass *)(pTSWd->dcShare);
    
                dcShare->SC_ShadowSyncShares();
    
                TRC_ALT((TB, "Synchronized share for stack [%ld]", pTSWd->StackClass));
    
                WDW_CHECK_SHM(
                          (((PTSHARE_DD_SHADOWSYNC_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;
#endif


        case IOCTL_WDTS_DD_SHADOW_DISCONNECT:
        {
            if (pSdIoctl->InputBuffer && 
                    (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm)) {
                WDW_CHECK_SHM(
                       (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm));
    
                status = WDWDDShadowDisconnect(pTSWd, pSdIoctl);
    
                WDW_CHECK_SHM(
                       (((PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer)->pShm));
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

        case IOCTL_ICA_STACK_REGISTER_HOTKEY :
        {
            PICA_STACK_HOTKEY pHotkey = (PICA_STACK_HOTKEY) pSdIoctl->InputBuffer;

            if (pHotkey->HotkeyVk) {
                pTSWd->shadowState = SHADOW_CLIENT;
                pTSWd->HotkeyVk = pHotkey->HotkeyVk;
                pTSWd->HotkeyModifiers = pHotkey->HotkeyModifiers;

                TRC_ALT((TB, "IOCTL_ICA_STACK_REGISTER_HOTKEY - Enable Vk(%ld, %lx)",
                        pHotkey->HotkeyVk, pHotkey->HotkeyModifiers));

                // Allocate and initialize a physical key state array
                status = KeyboardSetKeyState(pTSWd, &pTSWd->pgafPhysKeyState);
                if (NT_SUCCESS(status)) {
                    TRC_ALT((TB, "Allocated phys key state"));
                }
                else {
                    TRC_ALT((TB, "Failed to alloc phys key states: %lx", status));
                }

                // VCs don't work when shadowing.  Tell VC subsystem to
                // suspend now.
                WDWVCMessage(pTSWd, CHANNEL_FLAG_SUSPEND);
            }
            else
            {
                pTSWd->shadowState = SHADOW_NONE;
                pTSWd->HotkeyVk = 0;
                pTSWd->HotkeyModifiers = 0;
                TRC_ALT((TB, "IOCTL_ICA_STACK_REGISTER_HOTKEY - Disable"));

                if (pTSWd->pShadowInfo != NULL) {
                    TRC_ALT((TB, "Primary client stack freeing reassembly info [%p]",
                            pTSWd->pShadowInfo));
                   COM_Free(pTSWd->pShadowInfo);
                   pTSWd->pShadowInfo = NULL;
                }

                // VCs don't work when shadowing.  Tell VC subsystem to
                // resume now.
                WDWVCMessage(pTSWd, CHANNEL_FLAG_RESUME);
            }
        }
        break;

        case IOCTL_WDTS_DD_GET_BITMAP_KEYDATABASE:
        {
            ShareClass *dcShare;
            PTSHARE_DD_BITMAP_KEYDATABASE_OUT pKDBOut = 
                    (PTSHARE_DD_BITMAP_KEYDATABASE_OUT) pSdIoctl->OutputBuffer;

            dcShare = (ShareClass *)(pTSWd->dcShare);

            TRC_NRM((TB, "DD tries to get keydatabase\n"));
            
            if (dcShare != NULL) {
                // We have a valid share class, get the key database 
                dcShare->SBC_GetBitmapKeyDatabase(&pKDBOut->bitmapKeyDatabaseSize,
                        &pKDBOut->bitmapKeyDatabase);
            }
        }
        break;

#ifdef DC_DEBUG
        case IOCTL_WDTS_DD_ICABREAKONDEBUGGER:
        {
            IcaBreakOnDebugger();
        }
        break;
#endif

/********************************************************************/
// Send KeepAlive PDU IOCTL
/********************************************************************/
        case IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU:
        {
            ShareClass *dcShare;

            dcShare = (ShareClass *)(pTSWd->dcShare);

            TRC_NRM((TB, "TermDD requests to send a keepalive pkt to client\n"));

            if (dcShare != NULL) {
                // We have a valid share class, send a keepalive pdu to client
                dcShare->SC_KeepAlive();
            }
        }
        break;

        /********************************************************************/
        // Load balancing IOCTLs.
        /********************************************************************/
        case IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO:
        {
            TS_LOAD_BALANCE_INFO *pLBInfo =
                    (TS_LOAD_BALANCE_INFO *)pSdIoctl->OutputBuffer;

            TRC_ASSERT((pSdIoctl->OutputBufferLength >=
                    sizeof(TS_LOAD_BALANCE_INFO)),
                    (TB,"Invalid output buf size %u for STACK_QUERY_LBINFO",
                    pSdIoctl->OutputBufferLength));

            // We need to fill in the IOCTL info from the gathered client
            // info packet and the initial capabilities.
            pLBInfo->bClientSupportsRedirection =
                    pTSWd->bClientSupportsRedirection;
            pLBInfo->bRequestedSessionIDFieldValid =
                    pTSWd->bRequestedSessionIDFieldValid;
            pLBInfo->RequestedSessionID = pTSWd->RequestedSessionID;
            pLBInfo->bUseSmartcardLogon = pTSWd->bUseSmartcardLogon;
            pLBInfo->ProtocolType = PROTOCOL_RDP;

            pLBInfo->bClientRequireServerAddr = 
                pTSWd->ClientRedirectionVersion > TS_CLUSTER_REDIRECTION_VERSION1 ? 0 : 1;

            pLBInfo->ClientRedirectionVersion = pTSWd->ClientRedirectionVersion;

            wcsncpy(pLBInfo->UserName, (WCHAR *)pTSWd->pInfoPkt->UserName,
                    sizeof(pLBInfo->UserName) / sizeof(WCHAR) - 1);
            pLBInfo->UserName[sizeof(pLBInfo->UserName) / sizeof(WCHAR) - 1] =
                    L'\0';
            wcsncpy(pLBInfo->Domain, (WCHAR *)pTSWd->pInfoPkt->Domain,
                    sizeof(pLBInfo->Domain) / sizeof(WCHAR) - 1);
            pLBInfo->Domain[sizeof(pLBInfo->Domain) / sizeof(WCHAR) - 1] =
                    L'\0';
            wcsncpy(pLBInfo->InitialProgram,
                    (WCHAR *)pTSWd->pInfoPkt->AlternateShell,
                    sizeof(pLBInfo->InitialProgram) / sizeof(WCHAR) - 1);
            pLBInfo->InitialProgram[sizeof(pLBInfo->InitialProgram) /
                    sizeof(WCHAR) - 1] = L'\0';

            break;
        }


        case IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION:
        {
            BOOL rc;
            TS_CLIENT_REDIRECTION_INFO *pRedirInfo =
                    (TS_CLIENT_REDIRECTION_INFO *)pSdIoctl->InputBuffer;

            TRC_ASSERT((pSdIoctl->InputBufferLength >=
                    sizeof(TS_CLIENT_REDIRECTION_INFO)),
                    (TB,"Invalid input buf size %u for STACK_CLIENT_REDIR",
                    pSdIoctl->InputBufferLength));

            
            if (pTSWd->ClientRedirectionVersion == TS_CLUSTER_REDIRECTION_VERSION1) {
                RDP_SERVER_REDIRECTION_PACKET *pPkt;
                PBYTE ServerName;
                unsigned PktSize;
                unsigned ServerNameLen;

                // Get the server name length in bytes, including null.
                ServerNameLen = *((ULONG UNALIGNED*)(pRedirInfo + 1));
                ServerName = (PBYTE)(pRedirInfo + 1) + sizeof(ULONG);

                // Calculate the PDU size.
                PktSize = sizeof(RDP_SERVER_REDIRECTION_PACKET) + ServerNameLen -
                        sizeof(WCHAR);
    
                // The client username/domain info resulted in an off-machine
                // session to be redirected-to. We receive this IOCTL before
                // the licensing protocll occurs, hence we need to send a
                // non-data packet. If the client indicated support for
                // redirection, it must know how to parse this type of packet.
                status = NM_AllocBuffer(pTSWd->pNMInfo, (PPVOID)&pPkt,
                        PktSize, TRUE);
                if ( STATUS_SUCCESS == status && pTSWd->hDomainKernel != NULL) {
                    // Fill in the packet fields.
                    pPkt->Flags = RDP_SEC_REDIRECTION_PKT;
                    pPkt->Length = (UINT16)PktSize;
                    pPkt->SessionID = pRedirInfo->SessionID;
                    memcpy(pPkt->ServerAddress, ServerName, ServerNameLen);
    
                    TRC_DBG((TB, "Client Redirection PDU V1, ServerName: %S, ServerNameLen: %d",
                             ServerName, ServerNameLen));
                    
                    rc = NM_SendData(pTSWd->pNMInfo, (BYTE *)pPkt, PktSize,
                            TS_HIGHPRIORITY, 0, FALSE);
                    if (rc) {
                        TRC_ALT((TB, "Sent TS_SERVER_REDIRECT_PDU: %u", PktSize));
                        status = STATUS_SUCCESS;
                    }
                    else {
                        TRC_ERR((TB,"Failed to send redir PDU"));
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                else {
                    TRC_ERR((TB, "Failed to alloc %d bytes for redir PDU",
                            PktSize));
    
                    
                    if (STATUS_SUCCESS == status) {
                        NM_FreeBuffer(pTSWd->pNMInfo, pPkt);
                    }

                    // prevent regression, keep original return code.
                    status = STATUS_UNSUCCESSFUL;
                }
            }
            else if (pTSWd->ClientRedirectionVersion == TS_CLUSTER_REDIRECTION_VERSION2) {
                RDP_SERVER_REDIRECTION_PACKET_V2 *pPkt;
                unsigned PktSize, DataLen;
                
                // Calculate the PDU size
                DataLen = pSdIoctl->InputBufferLength - sizeof(TS_CLIENT_REDIRECTION_INFO);
                PktSize = sizeof(RDP_SERVER_REDIRECTION_PACKET_V2) + DataLen;

                // The client username/domain info resulted in an off-machine
                // session to be redirected-to. We receive this IOCTL before
                // the licensing protocll occurs, hence we need to send a
                // non-data packet. If the client indicated support for
                // redirection, it must know how to parse this type of packet.
                status = NM_AllocBuffer(pTSWd->pNMInfo, (PPVOID)&pPkt,
                        PktSize, TRUE);
                if ( STATUS_SUCCESS == status && pTSWd->hDomainKernel != NULL) {

                    // Fill in the packet fields.
                    pPkt->Flags = RDP_SEC_REDIRECTION_PKT2;
                    pPkt->Length = (UINT16)PktSize;
                    pPkt->SessionID = pRedirInfo->SessionID;
                    pPkt->RedirFlags = pRedirInfo->Flags;

                    memcpy(pPkt + 1, pRedirInfo + 1, DataLen); 
                    
                    TRC_DBG((TB, "Client Redirection PDU V2"));
                    
                    rc = NM_SendData(pTSWd->pNMInfo, (BYTE *)pPkt, PktSize,
                            TS_HIGHPRIORITY, 0, FALSE);
                    if (rc) {
                        TRC_ALT((TB, "Sent TS_SERVER_REDIRECT_PDU: %u", PktSize));
                        status = STATUS_SUCCESS;
                    }
                    else {
                        TRC_ERR((TB,"Failed to send redir PDU"));
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                else {
                    TRC_ERR((TB, "Failed to alloc %d bytes for redir PDU",
                            PktSize));
                    
                    if (STATUS_SUCCESS == status) {
                        NM_FreeBuffer(pTSWd->pNMInfo, pPkt);
                    }

                    // prevent regression, keep original return code.
                    status = STATUS_UNSUCCESSFUL;
                }           
            }
            else {
                RDP_SERVER_REDIRECTION_PACKET_V3 *pPkt;
                unsigned PktSize, DataLen;
                
                // Calculate the PDU size
                DataLen = pSdIoctl->InputBufferLength - sizeof(TS_CLIENT_REDIRECTION_INFO);
                PktSize = sizeof(RDP_SERVER_REDIRECTION_PACKET_V3) + DataLen;

                status = SM_AllocBuffer(pTSWd->pSmInfo, (PPVOID)&pPkt,
                                        PktSize, TRUE, TRUE);
                if ( STATUS_SUCCESS == status ) {
                                        
                    // Fill in the packet fields.
                    pPkt->Flags = RDP_SEC_REDIRECTION_PKT3;
                    pPkt->Length = (UINT16)PktSize;
                    pPkt->SessionID = pRedirInfo->SessionID;
                    pPkt->RedirFlags = pRedirInfo->Flags;
                    
                    if (pTSWd->fDontDisplayLastUserName) {
                        pPkt->RedirFlags |= LB_DONTSTOREUSERNAME;
                    }

                    memcpy(pPkt + 1, pRedirInfo + 1, DataLen); 
                    
                    TRC_DBG((TB, "Client Redirection PDU V3"));
                    
                    rc = SM_SendData(pTSWd->pSmInfo, (BYTE *)pPkt, PktSize,
                            TS_HIGHPRIORITY, 0, FALSE, RDP_SEC_REDIRECTION_PKT3, TRUE);
                    if (rc) {
                        TRC_NRM((TB, "Sent TS_SERVER_REDIRECT_PDU: %u", PktSize));
                        status = STATUS_SUCCESS;
                    }
                    else {
                        TRC_ERR((TB,"Failed to send redir PDU"));
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                else {
                    TRC_ERR((TB, "Failed to alloc %d bytes for redir PDU",
                            PktSize));
    
                    // prevent regression, keep original return code.
                    status = STATUS_UNSUCCESSFUL;
                }  
            }
            break;
        }


/****************************************************************************/
/****************************************************************************/
/* Finally the IOCtls that we pass on to the rest of the stack without      */
/* getting in the way.                                                      */
/****************************************************************************/
/****************************************************************************/

        /********************************************************************/
        /* This IOCtl indicates the connection is down.  Tell MCS before    */
        /* forwarding the IOCtl                                             */
        /********************************************************************/
        case IOCTL_ICA_STACK_CANCEL_IO :
        {
            MCSIcaStackCancelIo(pTSWd->hDomainKernel);
            TRC_NRM((TB, "CancelIO - set WD dead"));
            // Make sure that Domain.StatusDead is consistent with TSWd.dead
            pTSWd->dead = TRUE;
            ((PDomain)(pTSWd->hDomainKernel))->StatusDead = TRUE;
        }

        /********************************************************************/
        /* NB NOTE NO BREAK here - we drop through deliberately.            */
        /********************************************************************/

        /********************************************************************/
        /* modem callback and some others we're not interested in but lower */
        /* layers might be                                                  */
        /********************************************************************/
        case IOCTL_ICA_STACK_CALLBACK_INITIATE :
        case IOCTL_ICA_STACK_CALLBACK_COMPLETE :
        case IOCTL_ICA_STACK_CREATE_ENDPOINT :
        case IOCTL_ICA_STACK_OPEN_ENDPOINT :
        case IOCTL_ICA_STACK_CLOSE_ENDPOINT :
        case IOCTL_ICA_STACK_CONNECTION_WAIT :
        case IOCTL_ICA_STACK_CONNECTION_REQUEST :  // required for shadowing
        case IOCTL_ICA_STACK_QUERY_LOCALADDRESS :
        {
            status =
                 IcaCallNextDriver( pTSWd->pContext, SD$IOCTL, pSdIoctl );
            TRC_DBG((TB,
                     "Chaining on IOCtl %#x (function %d): status %#x",
                     pSdIoctl->IoControlCode,
                     WDW_IOCTL_FUNCTION(pSdIoctl->IoControlCode),
                     status));
        }
        break;


        // Returning bad status for this makes GRE ignore it.
        case IOCTL_VIDEO_ENUM_MONITOR_PDO:
            status = STATUS_DEVICE_NOT_READY;
            break;

        default:
        {
            TRC_ALT((TB, "UNKNOWN WdIoctl %#x (function %d): status %#x",
                    pSdIoctl->IoControlCode,
                    WDW_IOCTL_FUNCTION(pSdIoctl->IoControlCode),
                    status));
            status =
                 IcaCallNextDriver( pTSWd->pContext, SD$IOCTL, pSdIoctl );
            break;
        }
    }

    DC_END_FN();

DC_EXIT_POINT:
    return status;
}


/****************************************************************************/
/* Name:      WD_RawWrite                                                   */
/*                                                                          */
/* Purpose:   Handle I/O writes to and from the client of a shadow operation*/
/*                                                                          */
/* Params:    IN     pTSWd       - Points to wd data structure              */
/*            INOUT  pSdRawWrite - Points to a SD_RAWWRITE structure        */
/*                                                                          */
/* Operation: Forward the data to the client of this stack.                 */
/****************************************************************************/
NTSTATUS WD_RawWrite(PTSHARE_WD pTSWd, PSD_RAWWRITE pSdRawWrite)
{
    PUCHAR pInBuffer;
    PBYTE  pOutBuffer;
    ULONG  newBytes;
    BOOL   bSuccess = TRUE;
    NTSTATUS status;

    DC_BEGIN_FN("WD_RawWrite");

    pInBuffer = pSdRawWrite->pBuffer;
    newBytes = pSdRawWrite->ByteCount;

    status = SM_AllocBuffer(pTSWd->pSmInfo, (PPVOID) &pOutBuffer, newBytes, TRUE, FALSE);
    if ( STATUS_SUCCESS == status ) {
        memcpy(pOutBuffer, pInBuffer, newBytes);

        bSuccess = SM_SendData(pTSWd->pSmInfo, pOutBuffer, newBytes,
                PROT_PRIO_MISC, 0, FALSE, RNS_SEC_ENCRYPT, FALSE);
        if (bSuccess) {
            TRC_NRM((TB, "Sent shadow data to %s: %ld",
                     (pTSWd->StackClass == Stack_Primary) ? "client" : "target",
                newBytes));
            status=STATUS_SUCCESS;
        }
        else {
            TRC_ERR((TB, "FAILED to Send shadow data to %s: %ld",
                     (pTSWd->StackClass == Stack_Primary) ? "client" : "target",
                newBytes));
            status = STATUS_UNEXPECTED_IO_ERROR;
        }
    }
    else {
        TRC_ERR((TB, "FAILED to alloc shadow buffer for %s: %ld",
                 (pTSWd->StackClass == Stack_Primary) ? "client" : "target",
            newBytes));

        // prevent regression, keep original return code.
        status = STATUS_NO_MEMORY;
    }

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* Name:      WDWNewShareClass                                              */
/*                                                                          */
/* Purpose:   Create a new ShareClass object                                */
/****************************************************************************/
NTSTATUS WDWNewShareClass(PTSHARE_WD pTSWd)
{
    NTSTATUS status = STATUS_SUCCESS;
    ShareClass *pSC;

    DC_BEGIN_FN("WDWNewShareClass");

#ifdef DC_HICOLOR
    pSC = new ShareClass(pTSWd, pTSWd->desktopHeight, pTSWd->desktopWidth,
                         pTSWd->desktopBpp, pTSWd->pSmInfo);
#else
    pSC = new ShareClass(pTSWd, pTSWd->desktopHeight, pTSWd->desktopWidth,
            8, pTSWd->pSmInfo);
#endif

    if (pSC != NULL) {
        TRC_NRM((TB, "Created Share Class"));
        pTSWd->dcShare = (PVOID)pSC;
    }
    else {
        TRC_ERR((TB, "Failed to create Share Class"));
        status = STATUS_NO_MEMORY;
    }

    DC_END_FN();
    return status;
} /* WDWNewShareClass */


/****************************************************************************/
/* Name:      WDWDeleteShareClass                                           */
/*                                                                          */
/* Purpose:   Delete a Share Class object                                   */
/****************************************************************************/
void WDWDeleteShareClass(PTSHARE_WD pTSWd)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWDeleteShareClass");

    TRC_ASSERT((pSC != NULL), (TB, "NULL Share Class"));

    TRC_NRM((TB, "Delete Share Class"));

    delete pSC;
    pTSWd->dcShare = NULL;

    DC_END_FN();
} /* WDWDeleteShareClass */


/****************************************************************************/
/* Name:      WDWTermShareClass                                             */
/*                                                                          */
/* Purpose:   Terminate the Share Class                                     */
/****************************************************************************/
void WDWTermShareClass(PTSHARE_WD pTSWd)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWTermShareClass");

    TRC_ASSERT((pSC != NULL), (TB, "NULL Share Class"));

    if (pTSWd->shareClassInit) {
        pSC->DCS_Term();
        TRC_NRM((TB, "Share Class terminated"));
        pTSWd->shareClassInit = FALSE;
    }
    else {
        TRC_ALT((TB, "Can't terminate uninitialized Share Core"));
    }

    DC_END_FN();
} /* WDWTermShareClass */


/****************************************************************************/
/* Name:      WDWDDConnect                                                  */
/*                                                                          */
/* Purpose:   Process an IOCTL_WDTS_DD_CONNECT or                           */
/*            IOCTL_WDTS_DD_SHADOW_CONNECT from the client.                 */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*            IN    reconnect  - TRUE  - this is a reconnect                */
/*                               FALSE - this is a connect                  */
/*                                                                          */
/* Operation: Save the frame buffer pointer                                 */
/*            Initialize the share core (will start to bring the share up)  */
/*            Return the required pointers to the DD.                       */
/****************************************************************************/
NTSTATUS WDWDDConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl, BOOL reconnect)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    NTSTATUS waitStatus;
    BOOL rc;
    PTS_BITMAP_CAPABILITYSET pBitmapCaps;
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;
    PTSHARE_DD_CONNECT_IN pIn = (PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer;
    PTSHARE_DD_CONNECT_OUT pOut =
            (PTSHARE_DD_CONNECT_OUT)pSdIoctl->OutputBuffer;
    
    DC_BEGIN_FN("WDWDDConnect");

    TRC_ASSERT((pSC != NULL), (TB, "NULL Share Class"));

    // Check we're connected OK.
    if (!pTSWd->connected) {
        TRC_ERR((TB, "Not connected"));
        status = STATUS_CONNECTION_DISCONNECTED;
        DC_QUIT;
    }

    // Check we've been given a sensible IOCtl.
    if ((pIn == NULL) ||
            (pOut == NULL) ||
            (pSdIoctl->InputBufferLength < sizeof(TSHARE_DD_CONNECT_IN)) ||
            (pSdIoctl->OutputBufferLength < sizeof(TSHARE_DD_CONNECT_OUT)))
    {
        status = STATUS_BUFFER_TOO_SMALL;
        TRC_ERR((TB, "A buffer not present or big enough, %p, %lu; %p, %lu",
                                        pIn, pSdIoctl->InputBufferLength,
                                        pOut, pSdIoctl->OutputBufferLength));
        DC_QUIT;
    }

    // Check that the DD sizeof(SHM_SHARED_MEMORY) matches our expectations.
    // If not, we have mismatched binaries.
    if (pIn->DDShmSize != sizeof(SHM_SHARED_MEMORY)) {
        DbgPrint("****** RDPWD: Mismatched DD/WD - DD Shm size=%u, WD=%u\n",
                pIn->DDShmSize, sizeof(SHM_SHARED_MEMORY));
        return STATUS_INVALID_PARAMETER;
    }

    // Set returned buffer length.
    pSdIoctl->BytesReturned = sizeof(TSHARE_DD_CONNECT_OUT);

    // Increment the loadcount
    pTSWd->shareId = InterlockedIncrement(&WD_ShareId);
    ((PSHM_SHARED_MEMORY) (pIn->pShm))->shareId = pTSWd->shareId;

    // Now get the share core initialized or reconnected.
    if (reconnect) {
        // Restore the timer info.
        TRC_NRM((TB, "Reconnect Share Core"));
        pTSWd->ritTimer = pIn->pKickTimer;
        WDW_StartRITTimer(pTSWd, pTSWd->interactiveDelay);
    }
    else {
        // Check for re-initialization.
// This is now legal with console disconnect.
//        if (pTSWd->shareClassInit)
//        {
//
//            if (pTSWd->StackClass != Stack_Console)
//            {
//                TRC_ERR((TB, "Re-initialization - fail it"));
//                status = STATUS_UNSUCCESSFUL;
//                DC_QUIT;
//            }
//            else
//            {
//                TRC_ALT((TB, "Re-initialize console stack"));
//            }
//        }
        //Make sure the sbcKeyDatabase is freed before initialization
        if (pTSWd->shareClassInit)
        {
            pSC->SBC_FreeBitmapKeyDatabase();
        }

        // Initialize the Share Core.
        TRC_NRM((TB, "Initialize Share Core"));
        pSC->m_pShm = (SHM_SHARED_MEMORY *)pIn->pShm;
        rc = pSC->DCS_Init(pTSWd, pTSWd->pSmInfo);
        pSC->m_pShm = NULL;
        if (rc) {
            // Initialized OK
            TRC_NRM((TB, "Share Class initialized, rc %d", rc));
            pTSWd->shareClassInit = TRUE;
        }
        else {
            TRC_ERR((TB, "Failed to initialize Share Class"));
            status = STATUS_UNSUCCESSFUL;
            DC_QUIT;
        }
    }

    // If this is the primary stack, tell the display driver the desktop
    // width/height we need to use.
    if ((pTSWd->StackClass == Stack_Primary) ||
            (pTSWd->StackClass == Stack_Console)) {
        pOut->desktopHeight = pTSWd->desktopHeight;
        pOut->desktopWidth = pTSWd->desktopWidth;

        // Share's on its way up, so give the key values back to the DD.
        pOut->pTSWd = (PVOID)pTSWd;
        pOut->pProtocolStatus = pTSWd->pProtocolStatus;
        TRC_ERR((TB, "Stored pTSWD %p, protocol status %p",
                pTSWd, pTSWd->pProtocolStatus));
    }
    else {
        // For shadow connects, the DD tells the shadow WD the width/height
        // of the shadow target's desktop such that input from the shadow client
        // can be scaled appropriately.
        /********************************************************************/
        /* See if the shadowing client supports dynamic resizing.  First we */
        /* need to extract the bitmap caps from the connect data            */
        /********************************************************************/
        pBitmapCaps = (PTS_BITMAP_CAPABILITYSET) WDW_GetCapSet(
                                  pTSWd,
                                  TS_CAPSETTYPE_BITMAP,
                                  &pIn->pVirtModuleData->combinedCapabilities,
                                  pIn->pVirtModuleData->capsLength);

        /********************************************************************/
        /* If we found the bitmap caps, and the client does support dynamic */
        /* resizing, then just go ahead and assign the size.                */
        /********************************************************************/
        if (pBitmapCaps &&
                (pBitmapCaps->desktopResizeFlag == TS_CAPSFLAG_SUPPORTED))
        {
            TRC_ALT((TB, "Client supports dynamic resizing"));
            pTSWd->desktopHeight = pIn->desktopHeight;
            pTSWd->desktopWidth = pIn->desktopWidth;
            pSC->m_desktopHeight = pIn->desktopHeight;
            pSC->m_desktopWidth = pIn->desktopWidth;
        }
        /********************************************************************/
        /* If the client does NOT support dynamic resizing, then make sure  */
        /* that the shadower client is at least as big as the shadow target */
        /* client - or the shadower client will trap                        */
        /********************************************************************/
        else if ((pTSWd->desktopHeight >= pIn->desktopHeight) &&
                (pTSWd->desktopWidth >= pIn->desktopWidth)) {
            pTSWd->desktopHeight = pIn->desktopHeight;
            pTSWd->desktopWidth = pIn->desktopWidth;
            pSC->m_desktopHeight = pIn->desktopHeight;
            pSC->m_desktopWidth = pIn->desktopWidth;
        }
        else {
            TRC_ERR((TB, "Rejecting attempt to shadow a higher res client"));
            status = STATUS_UNSUCCESSFUL;
            DC_QUIT;
        }

#ifdef DC_HICOLOR
        /********************************************************************/
        /* Can the shadower cope with the target BPP?
        /********************************************************************/
        TRC_ALT((TB, "Shadower WD:  %d bpp", pTSWd->desktopBpp ));
        TRC_ALT((TB, "Target WD:    %d bpp", pIn->desktopBpp ));
        if (pTSWd->desktopBpp == pIn->desktopBpp) {
            TRC_ALT((TB, "Color depths match - ok"));
            pSC->m_desktopBpp = pIn->desktopBpp;
        }
        else {
            TRC_ALT((TB, "Color depth mismatch"));
            /****************************************************************/
            /* Test the shadower's supported color depths                   */
            /****************************************************************/
            status = STATUS_SUCCESS;

            switch (pIn->desktopBpp)
            {
                case 24:
                {
                    if (pTSWd->supportedBpps & RNS_UD_24BPP_SUPPORT)
                    {
                        TRC_DBG((TB, "24bpp supported"));
                        break;
                    }
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

                case 16:
                {
                    if (pTSWd->supportedBpps & RNS_UD_16BPP_SUPPORT)
                    {
                        TRC_DBG((TB, "16bpp supported"));
                        break;
                    }
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

                case 15:
                {
                    if (pTSWd->supportedBpps & RNS_UD_15BPP_SUPPORT)
                    {
                        TRC_DBG((TB, "15bpp supported"));
                        break;
                    }
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

                case 8:
                case 4:
                {
                    TRC_DBG((TB, "8/4 bpp supported"));
                }
                break;

                default:
                {
                    TRC_ASSERT((FALSE), (TB, "Attempt to shadow unknown" \
                                " target color depth %d", pIn->desktopBpp));
                }
                break;
            }

            /****************************************************************/
            /* Did they support it?                                         */
            /****************************************************************/
            if (status == STATUS_UNSUCCESSFUL)
            {
                TRC_ERR((TB, "Rejecting shadow: unsupported color depth"));
                DC_QUIT;
            }
            else
            {
                TRC_ALT((TB, "but client claims to cope..."));
                pTSWd->desktopBpp = pIn->desktopBpp;
                pSC->m_desktopBpp = pIn->desktopBpp;
            }
        }
#endif
    }

    /************************************************************************/
    /* Share Core is no longer dead                                         */
    /************************************************************************/
    // Make sure that Domain.StatusDead is consistent with TSWd.dead
    pTSWd->dead = FALSE;
    ((PDomain)(pTSWd->hDomainKernel))->StatusDead = FALSE;
    SM_Dead(pTSWd->pSmInfo, FALSE);

    /************************************************************************/
    /* Clear the create event before creating the Share                     */
    /************************************************************************/
    KeClearEvent(pTSWd->pCreateEvent);

    /************************************************************************/
    /* Now create a Share                                                   */
    /************************************************************************/
#ifdef DC_HICOLOR
    TRC_ALT((TB, "Creating share at %d bpp", pTSWd->desktopBpp ));
#endif
    rc = pSC->SC_CreateShare();
    if (rc) {
        // Initialized OK - save the Shared Memory pointer.
        TRC_NRM((TB, "Share create started"));
    }
    else {
        TRC_ERR((TB, "Failed to create Share"));
        status = STATUS_CONNECTION_DISCONNECTED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Wait for Share creation to complete before returning to TShareDD     */
    /************************************************************************/
    TRC_NRM((TB, "Wait for Share Core to create the Share"));
    waitStatus = WDW_WaitForConnectionEvent(pTSWd,
                                        pTSWd->pCreateEvent,
                                        60000L);

    /************************************************************************/
    /* It is possible that the WD has been closed while we were waiting for */
    /* the Share creation to complete.  If this is the case, the Share      */
    /* class will have been deleted, so we can't continue.  Return a        */
    /* failure to TShareDD.                                                 */
    /************************************************************************/
    if (pTSWd->dcShare == NULL)
    {
        TRC_ERR((TB, "Share Class ended while waiting for Share creation"));
        status = STATUS_CONNECTION_DISCONNECTED;
        DC_QUIT;
    }

    if (waitStatus == STATUS_TIMEOUT)
    {
        /********************************************************************/
        /* The wait timed out - probably because the connection was         */
        /* disconnected before the Share was created.  Tidy up the Share.   */
        /********************************************************************/
        TRC_ERR((TB, "Timeout waiting for Share creation"));
        pSC->m_pShm = (SHM_SHARED_MEMORY *)pIn->pShm;
        pSC->SC_EndShare(FALSE);
        pSC->m_pShm = NULL;
        TRC_NRM((TB, "Share ended"));
        status = STATUS_CONNECTION_DISCONNECTED;

        // Can no longer accept input from RDPDD or PDMCS.
        if (pTSWd->shadowState != SHADOW_CLIENT) {
            // Make sure that Domain.StatusDead is consistent with TSWd.dead
            pTSWd->dead = TRUE;
            ((PDomain)(pTSWd->hDomainKernel))->StatusDead = TRUE;
            SM_Dead(pTSWd->pSmInfo, TRUE);
        }
        else {
            // The client shadow stack is disconnected from its display driver
            // during a shadow, but must still be able to send/receive data
            // to/from the target shadow stack and shadow client.
            TRC_ALT((TB, "In shadow: leaving SM active"));
        }

        DC_QUIT;
    }

    /************************************************************************/
    /* Check whether the Share was created OK.  If not, quit now.           */
    /************************************************************************/
    if (!pTSWd->shareCreated)
    {
        TRC_ERR((TB, "Share creation failed"));
        status = STATUS_UNSUCCESSFUL;
        DC_QUIT;
    }

    // We have successfully received the initial share creation PDUs.
    // Update the received info for the DD to use.
    pSC->SBC_GetBitmapKeyDatabase(&pOut->bitmapKeyDatabaseSize,
                                  &pOut->bitmapKeyDatabase);

    // For shadow connects, we need to add in the remote party to negotiate
    // capabilities correctly.
    if ((pSdIoctl->IoControlCode == IOCTL_WDTS_DD_SHADOW_CONNECT) &&
        ((pTSWd->StackClass == Stack_Primary) ||
         (pTSWd->StackClass == Stack_Console))) {
        TRC_ALT((TB, "Negotiating shadow capabilities"));
        status = pSC->SC_AddPartyToShare(
                SC_SHADOW_PERSON_ID,
                &pIn->pVirtModuleData->combinedCapabilities,
                pIn->pVirtModuleData->capsLength);
        if (status != STATUS_SUCCESS) {
            TRC_ERR((TB, "Failed to negotiate shadow capabilities: %lx", status));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* By now, the capabilities have been exchanged with the Client.  Call  */
    /* the core to update SHM.                                              */
    /************************************************************************/
    if ((pTSWd->StackClass == Stack_Primary) ||
        (pTSWd->StackClass == Stack_Console)) {
        TRC_NRM((TB, "Update SHM"));
        pSC->m_pShm = (SHM_SHARED_MEMORY *)pIn->pShm;
        pSC->DCS_UpdateShm();
        pSC->m_pShm = NULL;

    #ifdef DC_DEBUG
        // Make sure trace config is updated in SHM.
        pTSWd->trcShmNeedsUpdate = TRUE;
        TRC_MaybeCopyConfig(pTSWd, &(((SHM_SHARED_MEMORY *)(pIn->pShm))->trc));
    #endif
    }

    // All worked OK.
    TRC_NRM((TB, "Share created"));
    status = STATUS_SUCCESS;

DC_EXIT_POINT:

    // record the individual connection status of each stack.
    if (pTSWd->StackClass == Stack_Primary)
        pOut->primaryStatus = status;
    else
        pOut->secondaryStatus |= status;

    DC_END_FN();
    return (status);
} /* WDWDDConnect */


/****************************************************************************/
/* Name:      WDWDDDisconnect                                               */
/*                                                                          */
/* Purpose:   Handle the disconnect IOCtl from the DD                       */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*            IN    bForce     - used by shadow to force sending of a       */
/*                               deactivate all PDU.                        */
/****************************************************************************/
NTSTATUS WDWDDDisconnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl, BOOLEAN bForce)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;
    PTSHARE_DD_DISCONNECT_IN pIn =
            (PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer;

    DC_BEGIN_FN("WDWDDDisconnect");

    TRC_ASSERT((pTSWd->dcShare != NULL),
                                 (TB,"Got a disconnect with no share obj!"));

    // Remove all references to WinStation resources.
    WDWStopRITTimer(pTSWd);
    pTSWd->ritTimer = NULL;

    // Dump the bitmap cache key database to system memory. If this disconnect
    // is in preparation for a reconnect, the database will allow us to
    // preserve the bitmap cache state.
    //
    // If this is a disconnect in preparation for a shadow, then we can't save
    // off the keys.  For the shadow target, bShadowDisconnect will be set by
    // the DD in DrvShadowConnect() processing.  The shadow state for the shadow
    // client will be other than NONE since we would have seen hotkey enable
    // requests prior to the disconnect.
    pSC->m_pShm = (SHM_SHARED_MEMORY *)pIn->pShm;
    if (pSC->m_pShm != NULL) {
        pSC->SBC_DumpBitmapKeyDatabase(!pIn->bShadowDisconnect &&
                                       (pTSWd->shadowState == SHADOW_NONE));
    }

    // First of all, end the Share.
    pSC->SC_EndShare(bForce);
    TRC_NRM((TB, "Share ended"));

    // Can no longer accept input from RDPDD or PDMCS.
    if (pTSWd->shadowState != SHADOW_CLIENT) {
        // Make sure that Domain.StatusDead is consistent with TSWd.dead
        pTSWd->dead = TRUE;
        ((PDomain)(pTSWd->hDomainKernel))->StatusDead = TRUE;
        SM_Dead(pTSWd->pSmInfo, TRUE);
    }
    else {
        // The client shadow stack is disconnected from its display driver
        // during a shadow, but must still be able to send/receive data
        // to/from the target shadow stack and shadow client.
        TRC_ALT((TB, "In shadow: leaving SM active"));
    }

    // Tell Share Class to disconnect.
    pSC->DCS_Disconnect();
    TRC_NRM((TB, "Share Class disconnected"));

    pSC->m_pShm = NULL;

    DC_END_FN();
    return STATUS_SUCCESS;
} /* WDWDDDisconnect */


/****************************************************************************/
/* Name:      WDWDDShadowConnect                                            */
/*                                                                          */
/* Purpose:   Process an IOCTL_WDTS_DD_SHADOW_CONNECT from the DD           */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Initialize either the primary stack or the shadow stack for   */
/*            a shadowing session.                                          */
/****************************************************************************/
NTSTATUS WDWDDShadowConnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    PTSHARE_DD_CONNECT_IN  pIn  = (PTSHARE_DD_CONNECT_IN)pSdIoctl->InputBuffer;
    PTSHARE_DD_CONNECT_OUT pOut = (PTSHARE_DD_CONNECT_OUT)pSdIoctl->OutputBuffer;
    PSHM_SHARED_MEMORY pShm = (PSHM_SHARED_MEMORY) pIn->pShm;

    DC_BEGIN_FN("WDWDDShadowConnect");

    switch (pTSWd->StackClass) {
        case Stack_Primary:
        case Stack_Console:
            // Reconnect the primary stack
            status = WDWDDConnect(pTSWd, pSdIoctl, TRUE);
            if (NT_SUCCESS(status)) {
                TRC_ALT((TB, "Primary target stack reconnected!"));
            }
            else {
                TRC_ERR((TB, "Primary target stack could not reconnect: %lx)", status));
                DC_QUIT;
            }

            // Set up the shadow data buffer.  The primary stack will copy output to
            // this location so all other shadow stacks can just squirt it.
#ifdef DC_HICOLOR
            pTSWd->pShadowInfo = (PSHADOW_INFO)COM_Malloc(2 * WD_MAX_SHADOW_BUFFER);
#else
            pTSWd->pShadowInfo = (PSHADOW_INFO)COM_Malloc(WD_MAX_SHADOW_BUFFER);
#endif

            // Stash the shadow buffer so the DD can pass it to all shadow stacks
            // via the Shm.
            if (pTSWd->pShadowInfo != NULL) {
                pTSWd->shadowState = SHADOW_TARGET;
                memset(pTSWd->pShadowInfo, 0, sizeof(SHADOW_INFO));
                pShm->pShadowInfo = pTSWd->pShadowInfo;

#ifdef DC_HICOLOR
                TRC_ALT((TB, "Primary stack allocated shadow info: %p[%ld]",
                        pTSWd->pShadowInfo, 2 * WD_MAX_SHADOW_BUFFER));
#else
                TRC_ALT((TB, "Primary stack allocated shadow info: %p[%ld]",
                        pTSWd->pShadowInfo, WD_MAX_SHADOW_BUFFER));
#endif
            }

            // Primary stack is really OK in this scenario, however it is fatal
            // for the shadow stack
            else {
                pTSWd->pShadowInfo = NULL;
                pShm->pShadowInfo = NULL;
                pOut->secondaryStatus = STATUS_NO_MEMORY;

                TRC_ERR((TB, "Could not allocate shadow data buffer"));
                DC_QUIT;
            }
            break;

        // Drive the shadow stack thru the normal connection phase
        case Stack_Shadow:
            status = WDWDDConnect(pTSWd, pSdIoctl, FALSE);
            if (NT_SUCCESS(status)) {
                TRC_ALT((TB, "Shadow stack connected!"));
            }
            else {
                TRC_ERR((TB, "Shadow stack could not connect: %lx", status));
            }
            break;

        default:
            TRC_ERR((TB, "Unknown stack class: %ld", pTSWd->StackClass));
            status = STATUS_INVALID_PARAMETER;
            break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return (status);
}


/****************************************************************************/
/* Name:      WDWDDShadowDisconnect                                         */
/*                                                                          */
/* Purpose:   Process an IOCTL_WDTS_DD_SHADOW_DISCONNECT from the DD        */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Stop shadowing on the primary stack.                          */
/****************************************************************************/
NTSTATUS WDWDDShadowDisconnect(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status = STATUS_SUCCESS;
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;
    PTSHARE_DD_DISCONNECT_IN pIn =
                             (PTSHARE_DD_DISCONNECT_IN)pSdIoctl->InputBuffer;

    DC_BEGIN_FN("WDWDDShadowDisconnect");

    switch (pTSWd->StackClass) {
        // Deallocate the shadow buffer
        case Stack_Primary:
        case Stack_Console:
            pTSWd->shadowState = SHADOW_NONE;
            if (pTSWd->pShadowInfo != NULL)
                COM_Free(pTSWd->pShadowInfo);
            pTSWd->pShadowInfo = NULL;

            if (pTSWd->bCompress == TRUE) {
                unsigned MPPCCompressionLevel;

                // Negotiate down to our highest level of compression support
                // if we receive a larger number.
                MPPCCompressionLevel =
                        (pTSWd->pInfoPkt->flags & RNS_INFO_COMPR_TYPE_MASK) >>
                        RNS_INFO_COMPR_TYPE_SHIFT;
                if (MPPCCompressionLevel > PACKET_COMPR_TYPE_MAX)
                    MPPCCompressionLevel = PACKET_COMPR_TYPE_MAX;

                // the compression history will be flushed
                pTSWd->bFlushed = PACKET_FLUSHED;

                // the compression will restart over
                initsendcontext(pTSWd->pMPPCContext, MPPCCompressionLevel);
            }

            pSC->SC_RemovePartyFromShare(SC_SHADOW_PERSON_ID);
            TRC_ALT((TB, "Update SHM after party left share"));

            pSC->m_pShm = (SHM_SHARED_MEMORY *)pIn->pShm;

            // Bump up the share ID to invalidate any old GRE cache entries for
            // glyphs or brushes.  This is necessary when RDP caches are destroyed
            // since GRE may keep around the brush or font structure in its cache
            pTSWd->shareId = InterlockedIncrement(&WD_ShareId);
            pSC->m_pShm->shareId = pTSWd->shareId;


            pSC->SC_Update();
            pSC->DCS_UpdateShm();
            pSC->m_pShm = NULL;

            TRC_ALT((TB, "TSHARE_DD_SHADOW_DISCONNECT: Primary target stack"));
            break;

        // By the time this ioctl arrives TermDD should have already stopped echoing
        // calls to the shadow stack.
        case Stack_Shadow:
            TRC_ERR((TB, "Shadow stack received an unexpected disconnect!"));
            break;

        default:
            TRC_ERR((TB, "Unexpected stack class: %ld", pTSWd->StackClass));
            break;
    }

    DC_END_FN();
    return status;
}


/****************************************************************************/
/* Name:      WDWUserLoggedOn                                               */
/*                                                                          */
/* Purpose:   Notify the core that a user has logged on                     */
/****************************************************************************/
void WDWUserLoggedOn(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWUserLoggedOn");

    TRC_ASSERT((pSC != NULL),
               (TB, "NULL Share Class"));
    TRC_ASSERT((pSdIoctl->InputBufferLength == sizeof(LOGONINFO)),
               (TB, "Bad LogonInfo"));

    pSC->DCS_UserLoggedOn((PLOGONINFO)pSdIoctl->InputBuffer);

    DC_END_FN();
} /* WDWUserLoggedOn */


/****************************************************************************/
/* Name:      WDWKeyboardSetIndicators                                      */
/*                                                                          */
/* Purpose:   Notify the core of new keyboard indicators                    */
/****************************************************************************/
void WDWKeyboardSetIndicators(PTSHARE_WD pTSWd)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWUserLoggedOn");

    TRC_ASSERT((pSC != NULL),
               (TB, "NULL Share Class"));

    pSC->DCS_WDWKeyboardSetIndicators();

    DC_END_FN();
} /* WDWKeyboardSetIndicators */


/****************************************************************************/
/* Name:      WDWKeyboardSetImeStatus                                       */
/*                                                                          */
/* Purpose:   Notify the core of new ime status                             */
/****************************************************************************/
void WDWKeyboardSetImeStatus(PTSHARE_WD pTSWd)
{
    ShareClass *dcShare = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWKeyboardSetImeStatus");

    TRC_ASSERT((dcShare != NULL),
               (TB, "NULL Share Class"));

    dcShare->DCS_WDWKeyboardSetImeStatus();

    DC_END_FN();
} /* WDWKeyboardSetImeStatus */


/****************************************************************************/
/* Name:      WDWSendBeep                                                   */
/*                                                                          */
/* Purpose:   Send a beep PDU to the client                                 */
/*                                                                          */
/* Params:    IN    pTSWd      - pointer to WD struct                       */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: Check validity of IOCtl & call through to UP.                 */
/****************************************************************************/
NTSTATUS WDWSendBeep(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS status  = STATUS_UNSUCCESSFUL;
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWSendBeep");

    if (pSdIoctl->InputBufferLength == sizeof(BEEP_SET_PARAMETERS) && 
            pSdIoctl->InputBuffer != NULL) {

        /************************************************************************/
        /* Call into the Share Class to allocate and send the beep PDU          */
        /************************************************************************/
        if (pSC != NULL && pTSWd->shareClassInit) {
            if (pSC->UP_SendBeep(
                    ((PBEEP_SET_PARAMETERS)pSdIoctl->InputBuffer)->Duration,
                    ((PBEEP_SET_PARAMETERS)pSdIoctl->InputBuffer)->Frequency))
                status = STATUS_SUCCESS;
        }
    
        pSdIoctl->BytesReturned = 0;
    }
    else {
        TRC_ASSERT((TRUE), (TB,"Got Beep Ioctl but input buffer too small"));
    }

    DC_END_FN();
    return status;
} /* WDWSendBeep */


/****************************************************************************/
/* Name:      WDWGetModuleData                                              */
/*                                                                          */
/* Purpose:   Processes an IOCTL_ICA_STACK_QUERY_MODULE_DATA from Termsrv.  */
/*                                                                          */
/* Params:    IN    pTSWd        - pointer to WD struct                     */
/*            INOUT PSD_IOCTL  - pointer to received IOCtl                  */
/*                                                                          */
/* Operation: return all the relevant conference creation info              */
/****************************************************************************/
NTSTATUS WDWGetModuleData(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS               status = STATUS_SUCCESS;
    ShareClass             *dcShare = (ShareClass *)pTSWd->dcShare;
    PTSHARE_MODULE_DATA    pModuleData = (PTSHARE_MODULE_DATA)
                                         pSdIoctl->OutputBuffer;
    PBYTE                  pData;
    ULONG                  ulDataSize;
    PRNS_UD_CS_CORE        pCoreData;
    PRNS_UD_CS_SEC         pSecurityData;

    DC_BEGIN_FN("WDWGetModuleData");

    ulDataSize = sizeof(TSHARE_MODULE_DATA) - sizeof(RNS_UD_HEADER) +
                 sizeof(RNS_UD_CS_CORE) +
                 sizeof(RNS_UD_CS_SEC);

    // Make sure the output buffer is big enough!
    pSdIoctl->BytesReturned = ulDataSize;
    if (pSdIoctl->OutputBufferLength < ulDataSize) {
        status = STATUS_BUFFER_TOO_SMALL;
        DC_QUIT;
    }

    pModuleData->ulLength = ulDataSize;
    pModuleData->ulVersion = 2;
    pModuleData->userDataLen = sizeof(RNS_UD_CS_CORE) + sizeof(RNS_UD_CS_SEC);
    pData = (PBYTE) &pModuleData->userData;

    // Client to server core data
    pCoreData = (PRNS_UD_CS_CORE) pData;
    pCoreData->header.type   = RNS_UD_CS_CORE_ID;
    pCoreData->header.length = sizeof(RNS_UD_CS_CORE);
    pCoreData->version       = RNS_UD_VERSION;
    pCoreData->desktopWidth  = (UINT16)pTSWd->desktopWidth;
    pCoreData->desktopHeight = (UINT16)pTSWd->desktopHeight;

    // Re-munge the color depth
    switch (pTSWd->desktopBpp) {
        case 8:
            pCoreData->colorDepth = RNS_UD_COLOR_8BPP;
            break;

        case 4:
            pCoreData->colorDepth = RNS_UD_COLOR_4BPP;
            break;

#ifdef DC_HICOLOR
        case 15:
            pCoreData->colorDepth = RNS_UD_COLOR_16BPP_555;
            break;
#endif

        case 16:
            pCoreData->colorDepth = RNS_UD_COLOR_16BPP_565;
            break;

        case 24:
            pCoreData->colorDepth = RNS_UD_COLOR_24BPP;
            break;

        default:
            status = STATUS_UNSUCCESSFUL;
            DC_QUIT;
    }
    pCoreData->postBeta2ColorDepth = pCoreData->colorDepth;

#ifdef DC_HICOLOR
    /************************************************************************/
    /* Copy across the current color depth                                  */
    /************************************************************************/
    pCoreData->highColorDepth       = (TSUINT16)pTSWd->desktopBpp;
    pCoreData->supportedColorDepths = (TSUINT16)pTSWd->supportedBpps;
#endif

    // Other useful stuff from user data
    pCoreData->version = pTSWd->version;
    pCoreData->SASSequence = pTSWd->sas;
    pCoreData->keyboardLayout = pTSWd->kbdLayout;
    pCoreData->clientBuild = pTSWd->clientBuild;
    memcpy(pCoreData->clientName, pTSWd->clientName, sizeof(pTSWd->clientName));

    //Whistler post Beta2 - shadow loop fix
    memcpy( pCoreData->clientDigProductId, pTSWd->clientDigProductId, sizeof( pTSWd->clientDigProductId ));

    // FE data
    pCoreData->keyboardType = pTSWd->keyboardType;
    pCoreData->keyboardSubType = pTSWd->keyboardSubType;
    pCoreData->keyboardFunctionKey = pTSWd->keyboardFunctionKey;
    memcpy(pCoreData->imeFileName, pTSWd->imeFileName, sizeof(pTSWd->imeFileName));

    // Win2000 Post Beta3 fields added
    pCoreData->clientProductId = pTSWd->clientProductId;
    pCoreData->serialNumber = pTSWd->serialNumber;

    // client to server security data
    pSecurityData = (PRNS_UD_CS_SEC) (pCoreData + 1);
    pSecurityData->header.type = RNS_UD_CS_SEC_ID;
    pSecurityData->header.length = sizeof(RNS_UD_CS_SEC);
    SM_GetEncryptionMethods(pTSWd->pSmInfo, pSecurityData );

    // UGH!  Now copy this data in a redundant form so we won't break
    // compatibility with TS5 B3.
    memcpy(&pModuleData->clientCoreData, pCoreData, sizeof(RNS_UD_CS_CORE_V0));
    memcpy(&pModuleData->clientSecurityData, pSecurityData, sizeof(RNS_UD_CS_SEC_V0));
    MCSGetDefaultDomain(pTSWd->pContext,
                        &pModuleData->DomParams,
                        &pModuleData->MaxSendSize,
                        &pModuleData->MaxX224DataSize,
                        &pModuleData->X224SourcePort);
    pModuleData->shareId = pTSWd->shareId;

DC_EXIT_POINT:
    DC_END_FN();
    return status;
} /* WDWGetModuleData */


/****************************************************************************/
/* Name:      WDW_GetCapSet                                                 */
/*                                                                          */
/* Purpose:   Extract the specific capabilities from a combined             */
/*            capabilities set                                              */
/*                                                                          */
/* Returns:   pointer to caps or NULL if not found                          */
/*                                                                          */
/* Params:    IN pTSWd         - pointer to WD struct                       */
/*            IN CapSetType    - type of capability set                     */
/*            IN pCombinedCaps - pointer to combined capabilites            */
/*            IN lengthCaps    - length of supplied caps                    */
/*                                                                          */
/* Operation: find the specific caps in supplied capability set             */
/****************************************************************************/
PTS_CAPABILITYHEADER WDW_GetCapSet(
        PTSHARE_WD                pTSWd,
        UINT32                    CapSetType,
        PTS_COMBINED_CAPABILITIES pCaps,
        UINT32                    capsLength)
{
    PTS_CAPABILITYHEADER     pCapsHeader = NULL;
    UINT32                   capsOffset;

    DC_BEGIN_FN("WDW_GetCapSet");

    /************************************************************************/
    /* Set up the pointer to the first capability set, and check that there */
    /* is at least one set of caps!                                         */
    /************************************************************************/
    pCapsHeader = (PTS_CAPABILITYHEADER)pCaps->data;
    capsOffset  = sizeof(TS_COMBINED_CAPABILITIES) - 1;
    if (capsOffset >= capsLength)
    {
        TRC_NRM((TB, "No Caps found"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now loop through all the caps, looking for the specified capabilities*/
    /************************************************************************/
    while (pCapsHeader->capabilitySetType != CapSetType)
    {
        /****************************************************************/
        /* Add the length of this capability to the offset, to keep     */
        /* track of how much of the combined caps we have processed.    */
        /****************************************************************/
        capsOffset += pCapsHeader->lengthCapability;
        if (capsOffset >= capsLength)
        {
            TRC_NRM((TB, "Bitmap Caps not found"));
            pCapsHeader = NULL;
            break;
        }

        /****************************************************************/
        /* Add the length of this capability to the header pointer, so  */
        /* it points to the next capability set.                        */
        /****************************************************************/
        pCapsHeader = (PTS_CAPABILITYHEADER)
                (((PBYTE)pCapsHeader) + pCapsHeader->lengthCapability);
        TRC_NRM((TB, "Next set: %u", pCapsHeader->capabilitySetType));
    }

    /************************************************************************/
    /* pCapsHeader is either NULL or a pointer to the desired caps - which  */
    /* is what we want to return                                            */
    /************************************************************************/

DC_EXIT_POINT:
    DC_END_FN();
    return(pCapsHeader);
} /* WDW_GetCapSet */


/****************************************************************************/
/* Name:      WDWGetDefaultCoreParams                                       */
/*                                                                          */
/* Purpose:   Defaults the core params used by the shadow stacks            */
/*                                                                          */
/* Params:    OUT pClientCoreData - WD core data                            */
/*                                                                          */
/* Operation: Default the core params used by the shadow stacks             */
/****************************************************************************/
NTSTATUS WDWGetDefaultCoreParams(PRNS_UD_CS_CORE pClientCoreData)
{
    DC_BEGIN_FN("WDWGetDefaultCoreParams");

    // Client to server core data
    pClientCoreData->header.type = RNS_UD_CS_CORE_ID;
    pClientCoreData->header.length = sizeof(RNS_UD_CS_CORE);

    // Desktop parameters
    pClientCoreData->desktopHeight = 640;
    pClientCoreData->desktopWidth = 480;
    pClientCoreData->colorDepth = RNS_UD_COLOR_8BPP;
    pClientCoreData->postBeta2ColorDepth = RNS_UD_COLOR_8BPP;

#ifdef DC_HICOLOR
    pClientCoreData->highColorDepth       = 15;
    pClientCoreData->supportedColorDepths = RNS_UD_24BPP_SUPPORT ||
                                            RNS_UD_16BPP_SUPPORT ||
                                            RNS_UD_15BPP_SUPPORT;
#endif

    // Other useful stuff from user data
    pClientCoreData->version = RNS_TERMSRV_40_UD_VERSION;
    pClientCoreData->SASSequence = RNS_UD_SAS_NONE;
    pClientCoreData->keyboardLayout = 0;
    pClientCoreData->clientBuild = VER_PRODUCTBUILD;
    memcpy(pClientCoreData->clientName, L"Passthru Stack", sizeof(L"Passthru Stack"));
     //Whistler post Beta2 - shadow loop fix
    pClientCoreData->clientDigProductId[0] = 0;

    // FE data
    pClientCoreData->keyboardType = 0;
    pClientCoreData->keyboardSubType = 0;
    pClientCoreData->keyboardFunctionKey = 0;
    memset(pClientCoreData->imeFileName, 0, sizeof(pClientCoreData->imeFileName));

    return STATUS_SUCCESS;
}

/****************************************************************************/
// Name:      WDWSetConfigData
//
// Purpose:   Sets the stack configuration/Policy settings from winstation
//
// Params:    IN pConfigData
/****************************************************************************/
NTSTATUS WDWSetConfigData(PTSHARE_WD pTSWd, PICA_STACK_CONFIG_DATA pConfigData)
{
    PSM_HANDLE_DATA pRealSMHandle = (PSM_HANDLE_DATA)pTSWd->pSmInfo;

    DC_BEGIN_FN("WDWSetConfigData");

    if (pConfigData->colorDepth == TS_24BPP_SUPPORT) {
        pTSWd->maxServerBpp = 24;
    }
    else if (pConfigData->colorDepth == TS_16BPP_SUPPORT) {
        pTSWd->maxServerBpp = 16;
    }
    else if (pConfigData->colorDepth == TS_15BPP_SUPPORT) {
        pTSWd->maxServerBpp = 15;
    }
    else {
        pTSWd->maxServerBpp = 8;
    }

    TRC_DBG((TB, "Max Color Depth support: %d", pTSWd->maxServerBpp));

    pRealSMHandle->encryptionLevel = pConfigData->encryptionLevel;
    pRealSMHandle->encryptAfterLogon =
            (pConfigData->fDisableEncryption == 0) ? TRUE : FALSE;

    TRC_DBG((TB, "Encryption after logon: %d", pRealSMHandle->encryptAfterLogon));
    TRC_DBG((TB, "Encryption level: %d", pRealSMHandle->encryptionLevel));

    pTSWd->fPolicyDisablesArc = pConfigData->fDisableAutoReconnect;
    TRC_DBG((TB, "AutoReconnect disabled: %d", pTSWd->fPolicyDisablesArc));

    DC_END_FN();
    return STATUS_SUCCESS;
}

/****************************************************************************/
/* Name:      WDWSetErrorInfo                                               */
/*                                                                          */
/* Purpose:   Send error info to the client                                 */
/****************************************************************************/
NTSTATUS WDWSetErrorInfo(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWSetErrorInfo");

    TRC_ASSERT((pSC != NULL),
               (TB, "NULL Share Class"));
    TRC_ASSERT((pSdIoctl->InputBufferLength == sizeof(TSUINT32)),
               (TB, "Bad ErrorInfo"));
    if(pSC)
    {
        if(pTSWd->bSupportErrorInfoPDU)
        {
            pSC->DCS_SendErrorInfo(*((PTSUINT32)pSdIoctl->InputBuffer));
        }
        else
        {
            TRC_NRM((TB,"SetErrorInfo called but client doesn't support error PDU"));
        }
    }

    DC_END_FN();
    return STATUS_SUCCESS;
} /* WDWSetErrorInfo */

/****************************************************************************/
/* Name:      WDWSendArcStatus
/*
/* Purpose:   Send autoreconnect status update to client
/****************************************************************************/
NTSTATUS WDWSendArcStatus(PTSHARE_WD pTSWd, PSD_IOCTL pSdIoctl)
{
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;

    DC_BEGIN_FN("WDWSendArcStatus");

    TRC_ASSERT((pSC != NULL),
               (TB, "NULL Share Class"));
    TRC_ASSERT((pSdIoctl->InputBufferLength == sizeof(TSUINT32)),
               (TB, "Bad ErrorInfo"));
    if(pSC)
    {
        if(pSC->SC_IsAutoReconnectEnabled())
        {
            pSC->DCS_SendAutoReconnectStatus(*((PTSUINT32)pSdIoctl->InputBuffer));
        }
        else
        {
            TRC_NRM((TB,"SetErrorInfo called but client doesn't ARC error PDU"));
        }
    }

    DC_END_FN();
    return STATUS_SUCCESS;
} /* WDWSendArcStatus */



/****************************************************************************/
/* Name:      WDW_LogAndDisconnect                                          */
/*                                                                          */
/* Purpose:   Log an event and disconnect the Client                        */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    pTSWd                                                         */
/*            errDetailCode - error code to log                             */
/*            pDetailData   - additional data                               */
/*            detailDataLen - length of additional data                     */
/*                                                                          */
/****************************************************************************/
void RDPCALL WDW_LogAndDisconnect(
        PTSHARE_WD pTSWd,
        BOOL fSendErrorToClient,
        unsigned   errDetailCode,
        PBYTE      pDetailData,
        unsigned   detailDataLen)
{
    DC_BEGIN_FN("WDW_LogAndDisconnect");

    //Report the error code back to the client
    ShareClass *pSC = (ShareClass *)pTSWd->dcShare;
 
    if(pSC)
    {
        if(fSendErrorToClient && pTSWd->bSupportErrorInfoPDU)
        {
            pSC->DCS_SendErrorInfo( (errDetailCode + TS_ERRINFO_PROTOCOL_BASE));
        }
        else
        {
            if( fSendErrorToClient )
            {
                TRC_NRM((TB,"SetErrorInfo called but client doesn't support error PDU"));
            }
            else
            {
                TRC_NRM((TB,"SetErrorInfo called but asked not to send error code to client"));
            }
        }
    }

    if( !pTSWd->dead )
        MCSProtocolErrorEvent(pTSWd->pContext, pTSWd->pProtocolStatus,
            errDetailCode, pDetailData, detailDataLen);

    DC_END_FN();
}



} /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\slicense.c ===
/****************************************************************************/
// slicense.c
//
// Server License Manager code
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop
#include "license.h"
#include <slicense.h>
#include <at120ex.h>


/****************************************************************************/
/* Name:      SLicenseInit                                                  */
/*                                                                          */
/* Purpose:   Initialize License Manager                                    */
/*                                                                          */
/* Returns:   Handle to be passed to subsequent License Manager functions   */
/*                                                                          */
/* Operation: LicenseInit is called during Server initialization.  Its      */
/*            purpose is to allow one-time initialization.  It returns a    */
/*            handle which is subsequently passed to all License Manager    */
/*            functions.  A typical use for this handle is as a pointer to  */
/*            memory containing per-instance data.                          */
/****************************************************************************/
LPVOID _stdcall SLicenseInit(VOID)
{
    PLicense_Handle pLicenseHandle;

    // create a license handle
    pLicenseHandle = ExAllocatePoolWithTag(PagedPool,
            sizeof(License_Handle),
            'clST');
        
    if (pLicenseHandle != NULL) {
        pLicenseHandle->pDataBuf = NULL;
        pLicenseHandle->cbDataBuf = 0;
        pLicenseHandle->pCacheBuf = NULL;
        pLicenseHandle->cbCacheBuf = 0;

        // allocate memory for the data event and initialize the event
        pLicenseHandle->pDataEvent = ExAllocatePoolWithTag(NonPagedPool,
                sizeof(KEVENT), WD_ALLOC_TAG);
        if (pLicenseHandle->pDataEvent != NULL) {
            KeInitializeEvent(pLicenseHandle->pDataEvent, NotificationEvent,
                    FALSE);
        }
        else {
            ExFreePool(pLicenseHandle);
            pLicenseHandle = NULL;
        }
    }
    else {
        KdPrint(("SLicenseInit: Failed to alloc License Handle\n"));
    }

    return (LPVOID)pLicenseHandle;
}


/****************************************************************************/
/* Name:      SLicenseData                                                  */
/*                                                                          */
/* Purpose:   Handle license data received from the Client                  */
/*                                                                          */
/* Params:    pHandle   - handle returned by LicenseInit                    */
/*            pSMHandle - SM Handle                                         */
/*            pData     - data received from Client                         */
/*            dataLen   - length of data received                           */
/*                                                                          */
/* Operation: This function is passed all license packets received from the */
/*            Client.  It should parse the packet and respond (by calling   */
/*            suitable SM functions - see asmapi.h) as required.  The SM    */
/*            Handle is provided so that SM calls can be made.              */
/*                                                                          */
/*            If license negotiation is complete and successful, the        */
/*            License Manager must call SM_LicenseOK.                       */
/*                                                                          */
/*            If license negotiation is complete but unsuccessful, the      */
/*            License Manager must disconnect the session.                  */
/*                                                                          */
/*            Incoming packets from the Client will continue to be          */
/*            interpreted as license packets until SM_LicenseOK is called,  */
/*            or the session is disconnected.                               */
/****************************************************************************/
void _stdcall SLicenseData(
        LPVOID pHandle,
        LPVOID pSMHandle,
        LPVOID pData,
        UINT   dataLen)
{
    PLicense_Handle pLicenseHandle;
    pLicenseHandle = (PLicense_Handle)pHandle;
    
    // only copy the incoming data if the buffer provided is large enough
    if (pLicenseHandle->cbDataBuf < dataLen)
    {
        // The provided data buffer is too small, we'll cache the data
        // for the caller.
        if (pLicenseHandle->pCacheBuf != NULL)
        {
            // free the previously cached data
            ExFreePool(pLicenseHandle->pCacheBuf);
        }

        // allocate new buffer to cache the data
        pLicenseHandle->pCacheBuf = ExAllocatePoolWithTag( PagedPool,
                                                           dataLen,
                                                           'eciL' );
        if (pLicenseHandle->pCacheBuf != NULL) {
            memcpy(pLicenseHandle->pCacheBuf, 
                    pData,
                    dataLen);

            pLicenseHandle->cbCacheBuf = dataLen;
            pLicenseHandle->Status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            pLicenseHandle->Status = STATUS_NO_MEMORY;
        }

        goto done;
    }
    
    // We got here because the caller has provided a buffer large enough to copy
    // copy the incoming data.
    if ((pLicenseHandle->pDataBuf) && (dataLen >  0))
    {
        memcpy(pLicenseHandle->pDataBuf,
                pData, 
                dataLen);

        pLicenseHandle->cbDataBuf = dataLen;

        // set the status for this operation
        pLicenseHandle->Status = STATUS_SUCCESS;
        goto done;
    }

done:

    // wake up the IOCTL waiting for incoming data
    KeSetEvent(pLicenseHandle->pDataEvent, 0, FALSE);
}


/****************************************************************************/
/* Name:      SLicenseTerm                                                  */
/*                                                                          */
/* Purpose:   Terminate Server License Manager                              */
/*                                                                          */
/* Params:    pHandle - handle returned from LicenseInit                    */
/*                                                                          */
/* Operation: This function is provided to do one-time termination of the   */
/*            License Manager.  For example, if pHandle points to per-      */
/*            instance memory, this would be a good place to free it.       */
/****************************************************************************/
VOID _stdcall SLicenseTerm(LPVOID pHandle)
{
    PLicense_Handle pLicenseHandle;

    pLicenseHandle = (PLicense_Handle)pHandle;
    if (pLicenseHandle != NULL) {
        if (pLicenseHandle->pCacheBuf != NULL)
            ExFreePool(pLicenseHandle->pCacheBuf);

        // free the memory for the data event and the license handle
        if (NULL != pLicenseHandle->pDataEvent)
            ExFreePool(pLicenseHandle->pDataEvent);

        ExFreePool(pLicenseHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\debug.h ===
/***************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}

#else

#define DISPDBG(arg)
#define RIP(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\rdpwd\tsfipsenc.c ===
/****************************************************************************/
/* tsfipsenc.c                                                              */
/*                                                                          */
/* FIPS encrpt/decrypt                                                      */
/*                                                                          */
/* Copyright (C) 2002-2004 Microsoft Corporation                            */
/****************************************************************************/



#include <precomp.h>

#include <fipsapi.h>
#include "asmint.h"

const BYTE DESParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                      0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};
// IV for all block ciphers
BYTE rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};

#ifdef _M_IA64
#define ALIGNMENT_BOUNDARY 7
#else
#define ALIGNMENT_BOUNDARY 3
#endif

//
// Name:        PrintData
//
// Purpose:     Print out the data in debugger
//
// Returns:     No
//
// Params:      IN      pKeyData: point to the data to be printed
//              IN      cbSize: the size of the key

void PrintData(BYTE *pKeyData, DWORD cbSize)
{
    DWORD dwIndex;
    //
    //print out the key
    //
    for( dwIndex = 0; dwIndex<cbSize; dwIndex++ ) {

        KdPrint(("0x%x ", pKeyData[dwIndex]));
        if( dwIndex > 0 && (dwIndex+1) % 8 == 0 )
            KdPrint(("\n"));
    }        

}


//
// Name:        Mydesparityonkey
//
// Purpose:     Set the parity on the DES key to be odd
//
// Returns:     No
//
// Params:      IN/OUT  pbKey: point to the key
//              IN      cbKey: the size of the key

void Mydesparityonkey(
        BYTE *pbKey,
        DWORD cbKey)
{
    DWORD i;

    for (i=0; i<cbKey; i++)
    {
        if (!((DESParityTable[pbKey[i]>>4] + DESParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = pbKey[i] ^ 0x01;
    }
}



//
// Name:        Expandkey
//
// Purpose:     Expand a 21-byte 3DES key to a 24-byte 3DES key (including parity bit)
//              by inserting a parity bit after every 7 bits in the 21-byte DES
//
// Returns:     No
//
// Params:      IN/OUT  pbKey: point to the key
////
#define PARITY_UNIT 7

void Expandkey(
        BYTE *pbKey
        )
{
    BYTE pbTemp[DES3_KEYLEN];
    DWORD i, dwCount;
    UINT16 shortTemp;
    BYTE *pbIn, *pbOut;

    RtlCopyMemory(pbTemp, pbKey, sizeof(pbTemp));
    dwCount = (DES3_KEYLEN * 8) / PARITY_UNIT;

    pbOut = pbKey;
    for (i=0; i<dwCount; i++) {
        pbIn = ((pbTemp + (PARITY_UNIT * i) / 8));
        //shortTemp = *(pbIn + 1);
        shortTemp = *pbIn + (((UINT16)*(pbIn + 1)) << 8);
        shortTemp = shortTemp >> ((PARITY_UNIT * i) % 8);
        //shortTemp = (*(unsigned short *)((pbTemp + (PARITY_UNIT * i) / 8))) >> ((PARITY_UNIT * i) % 8);
        *pbOut = (BYTE)(shortTemp & 0x7F);
        pbOut++;
    }
}



// Name:        TSFIPS_Init
//
// Purpose:     Initialize the FIPS library table.
//
// Returns:     TRUE  - succeeded                                  
//              FALSE - failed
//
// Params:      IN pFipsData: Fips data

BOOL TSFIPS_Init(PSM_FIPS_Data pFipsData)
{   
    NTSTATUS status;
	UNICODE_STRING fipsDeviceName;
	PDEVICE_OBJECT pDeviceObject = NULL;
	PIRP pIrpFips;
	KEVENT event;
	IO_STATUS_BLOCK iostatus;
    BOOLEAN rc = FALSE;

    // Begin Initialize FIPS device
    RtlInitUnicodeString(
		&fipsDeviceName,
		FIPS_DEVICE_NAME);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    status = IoGetDeviceObjectPointer(
                &fipsDeviceName,
                FILE_READ_DATA,
                &(pFipsData->pFileObject),
                &(pFipsData->pDeviceObject));
    if (!NT_SUCCESS(status)) {
        KdPrint(("TSFIPS - IoGetDeviceObjectPointer failed - %X\n", status));
        goto HandleError;
    }
		
    // Irp is freed by I/O manager when next lower driver completes
    pIrpFips = IoBuildDeviceIoControlRequest(
                IOCTL_FIPS_GET_FUNCTION_TABLE,
                pFipsData->pDeviceObject,
                NULL,							                // no input buffer
                0,
                &(pFipsData->FipsFunctionTable),                // output buffer is func table
                sizeof(FIPS_FUNCTION_TABLE),
                FALSE,							                // specifies IRP_MJ_DEVICE_CONTROL
                &event,
                &iostatus);
	if (! pIrpFips) {
        // IoBuildDeviceIoControlRequest returns NULL if Irp could not be created.
        ObDereferenceObject(pFipsData->pFileObject);
        pFipsData->pFileObject = NULL;
        KdPrint(("TSFIPS - IoBuildDeviceIoControlRequest failed, 0x%x\n", iostatus.Status));
        goto HandleError;
    }
		
    status = IoCallDriver(
                pFipsData->pDeviceObject,
                pIrpFips);
    if (STATUS_PENDING == status) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
			
        // Lower-level driver can pass status info up via the IO_STATUS_BLOCK
        // in the Irp.
        status = iostatus.Status;
    }
    if (! NT_SUCCESS(status)) {
        ObDereferenceObject(pFipsData->pFileObject);
        pFipsData->pFileObject = NULL;
        KdPrint(("TSFIPS - IoCallDriver failed, 0x%x\n", status));
        goto HandleError;
    }


    rc = TRUE;
HandleError:
    return rc;
}



// Name:        TSFIPS_Term
//
// Purpose:     Terminate the FIPS .
//
// Returns:     No                                
//             
//
// Params:      IN pFipsData: Fips data

void TSFIPS_Term(PSM_FIPS_Data pFipsData)
{
    if (pFipsData->pFileObject) {
        ObDereferenceObject(pFipsData->pFileObject);
        pFipsData->pFileObject = NULL;
    }
}




// Name:        FipsSHAHash
//
// Purpose:     Hash the data using SHA.
//
// Returns:     No
//
// Params:      IN      pFipsFunctionTable: Fips function table
//              IN      pbData: point to the data to be hashed
//              IN      cbData: the size of the data to be hashed
//              OUT     pbHash: point to the hash

void FipsSHAHash(PFIPS_FUNCTION_TABLE pFipsFunctionTable,
            BYTE *pbData,
            DWORD cbData,
            BYTE *pbHash)
{
    A_SHA_CTX HashContext;

    pFipsFunctionTable->FipsSHAInit(&HashContext);
    pFipsFunctionTable->FipsSHAUpdate(&HashContext, pbData, cbData);
    pFipsFunctionTable->FipsSHAFinal(&HashContext, pbHash);
}


// Name:        FipsSHAHashEx
//
// Purpose:     Hash 2 set of data using SHA.
//
// Returns:     No
//
// Params:      IN      pFipsFunctionTable: Fips function table
//              IN      pbData: point to the data to be hashed
//              IN      cbData: the size of the data to be hashed
//              IN      pbData2: point to the data to be hashed
//              IN      cbData2: the size of the data to be hashed
//              OUT     pbHash: point to the hash result

void FipsSHAHashEx(PFIPS_FUNCTION_TABLE pFipsFunctionTable,
            BYTE *pbData,
            DWORD cbData,
            BYTE *pbData2,
            DWORD cbData2,
            BYTE *pbHash)
{
    A_SHA_CTX HashContext;

    pFipsFunctionTable->FipsSHAInit(&HashContext);
    pFipsFunctionTable->FipsSHAUpdate(&HashContext, pbData, cbData);
    pFipsFunctionTable->FipsSHAUpdate(&HashContext, pbData2, cbData2);
    pFipsFunctionTable->FipsSHAFinal(&HashContext, pbHash);
}




// Name:        FipsHmacSHAHash
//
// Purpose:     Hash the data using HmacSHA.
//
// Returns:     No
//
// Params:      IN      pFipsFunctionTable: Fips function table
//              IN      pbData: point to the data to be hashed
//              IN      cbData: the size of the data to be hashed
//              IN      pbKey: point to the key used for calculating hash
//              IN      cbKey: the size of the key
//              OUT     pbHash: point to the hash result

void FipsHmacSHAHash(PFIPS_FUNCTION_TABLE pFipsFunctionTable,
                BYTE *pbData,
                DWORD cbData,
                BYTE *pbKey,
                DWORD cbKey,
                BYTE *pbHash)
{
    A_SHA_CTX HashContext;

    pFipsFunctionTable->FipsHmacSHAInit(&HashContext, pbKey, cbKey);
    pFipsFunctionTable->FipsHmacSHAUpdate(&HashContext, pbData, cbData);
    pFipsFunctionTable->FipsHmacSHAFinal(&HashContext, pbKey, cbKey, pbHash);
}




// Name:        FipsHmacSHAHashEx
//
// Purpose:     Hash the 2 set ofdata using HmacSHA.
//
// Returns:     No
//
// Params:      IN      pFipsFunctionTable: Fips function table
//              IN      pbData: point to the data to be hashed
//              IN      cbData: the size of the data to be hashed
//              IN      pbData2: point to the data to be hashed
//              IN      cbData2: the size of the data to be hashed
//              IN      pbKey: point to the key used for calculating hash
//              IN      cbKey: the size of the key
//              OUT     pbHash: point to the hash result

void FipsHmacSHAHashEx(PFIPS_FUNCTION_TABLE pFipsFunctionTable,
                BYTE *pbData,
                DWORD cbData,
                BYTE *pbData2,
                DWORD cbData2,
                BYTE *pbKey,
                DWORD cbKey,
                BYTE *pbHash)
{
    A_SHA_CTX HashContext;

    pFipsFunctionTable->FipsHmacSHAInit(&HashContext, pbKey, cbKey);
    pFipsFunctionTable->FipsHmacSHAUpdate(&HashContext, pbData, cbData);
    pFipsFunctionTable->FipsHmacSHAUpdate(&HashContext, pbData2, cbData2);
    pFipsFunctionTable->FipsHmacSHAFinal(&HashContext, pbKey, cbKey, pbHash);
}




// Name:        FipsDeriveKey
//
// Purpose:     Derive the key from the hash.
//
// Returns:     No
//
// Params:      IN      pFipsFunctionTable: Fips function table
//              IN      rgbSHABase: hash data used to derive the key
//              IN      cbSHABase: size of the hash
//              OUT     pKeyData: point to the derived DESkey
//              OUT     pKeyTable: point to the derived DES key table

void FipsDeriveKey(PFIPS_FUNCTION_TABLE pFipsFunctionTable,
                    BYTE *rgbSHABase,
                    DWORD cbSHABase,
                    BYTE *pKeyData,
                    PDES3TABLE pKeyTable)
{
    BOOL        rc = FALSE;

    //
    //Generate the key as follows
    //1. Hash the secret.  Call the result H1 (rgbSHABase in our case)
    //2. Use 1st 21 bytes of [H1|H1] as the 3DES key
    //3. Expand the 21-byte 3DES key to a 24-byte 3DES key (including parity bit), which
    //      will be used by CryptAPI
    //4. Set the parity on the 3DES key to be odd

    //
    //Step 2 - [H1|H1]
    //
    RtlCopyMemory(pKeyData, rgbSHABase, cbSHABase);
    RtlCopyMemory(pKeyData + cbSHABase, rgbSHABase, MAX_FIPS_SESSION_KEY_SIZE - cbSHABase);

    //
    //Step 3 - Expand the key
    //

    Expandkey(pKeyData);

    //
    //Step 4 - Set parity
    //
    Mydesparityonkey(pKeyData, MAX_FIPS_SESSION_KEY_SIZE);


    //DES3TABLE Des3Table;
    pFipsFunctionTable->Fips3Des3Key(pKeyTable, pKeyData);
}



// Name:        TSFIPS_MakeSessionKeys
//
// Purpose:     Make the key from client/server random numbers
//
// Returns:     TRUE if succeeded
//
// Params:      IN      pFipsData: Fips Data
//              IN      pRandomKey: Randow numbers used to generate key
//              IN      pEnumMethod: To generate Encrypt or Decrypt key, If NULL, both keys
//              IN      bPassThroughStack: If it's the passthrough stack in shadow

BOOL TSFIPS_MakeSessionKeys(PSM_FIPS_Data pFipsData,
                            LPRANDOM_KEYS_PAIR pRandomKey,
                            CryptMethod *pEnumMethod,
                            BOOL bPassThroughStack)
{
    BYTE rgbSHABase1[A_SHA_DIGEST_LEN]; 
    BYTE rgbSHABase2[A_SHA_DIGEST_LEN];
    BYTE Signature[A_SHA_DIGEST_LEN];
    BYTE *pKey1, *pKey2;
    A_SHA_CTX HashContext;

    memset(rgbSHABase1, 0, sizeof(rgbSHABase1));
    memset(rgbSHABase2, 0, sizeof(rgbSHABase2));

    // Server Encrypt/Client Decrypt key
    if ((pEnumMethod == NULL) ||
        (*pEnumMethod == Encrypt)) {
        pFipsData->FipsFunctionTable.FipsSHAInit(&HashContext);
        pFipsData->FipsFunctionTable.FipsSHAUpdate(&HashContext, pRandomKey->clientRandom, RANDOM_KEY_LENGTH/2);
        pFipsData->FipsFunctionTable.FipsSHAUpdate(&HashContext, pRandomKey->serverRandom, RANDOM_KEY_LENGTH/2);
        pFipsData->FipsFunctionTable.FipsSHAFinal(&HashContext, rgbSHABase1);
    
        if (!bPassThroughStack) {
            FipsDeriveKey(&(pFipsData->FipsFunctionTable), rgbSHABase1, sizeof(rgbSHABase1),
                        pFipsData->bEncKey, &(pFipsData->EncTable));
            pKey1 = pFipsData->bEncKey;
            // Set IV
            RtlCopyMemory(pFipsData->bEncIv, rgbIV, sizeof(rgbIV));
        }
        else {
            // If it's passthrough stack in shadow, it's server decrypt key
            FipsDeriveKey(&(pFipsData->FipsFunctionTable), rgbSHABase1, sizeof(rgbSHABase1),
                        pFipsData->bDecKey, &(pFipsData->DecTable));
            pKey1 = pFipsData->bDecKey;
            // Set IV
            RtlCopyMemory(pFipsData->bDecIv, rgbIV, sizeof(rgbIV));
        }
    }

    
    // Client Encrypt/Server Decrypt key
    if ((pEnumMethod == NULL) ||
        (*pEnumMethod == Decrypt)) {
        pFipsData->FipsFunctionTable.FipsSHAInit(&HashContext);
        pFipsData->FipsFunctionTable.FipsSHAUpdate(&HashContext, pRandomKey->clientRandom + RANDOM_KEY_LENGTH/2, RANDOM_KEY_LENGTH/2);
        pFipsData->FipsFunctionTable.FipsSHAUpdate(&HashContext, pRandomKey->serverRandom + RANDOM_KEY_LENGTH/2, RANDOM_KEY_LENGTH/2);
        pFipsData->FipsFunctionTable.FipsSHAFinal(&HashContext, rgbSHABase2);
    
        if (!bPassThroughStack) {
            FipsDeriveKey(&(pFipsData->FipsFunctionTable), rgbSHABase2, sizeof(rgbSHABase2),
                        pFipsData->bDecKey, &(pFipsData->DecTable));
            pKey2 = pFipsData->bDecKey;
            // Set IV
            RtlCopyMemory(pFipsData->bDecIv, rgbIV, sizeof(rgbIV));
        }
        else {
            // It's passthrough stack in shadow, it's server encrypt key
            FipsDeriveKey(&(pFipsData->FipsFunctionTable), rgbSHABase2, sizeof(rgbSHABase2),
                        pFipsData->bEncKey, &(pFipsData->EncTable));
            pKey2 = pFipsData->bEncKey;
            // Set IV
            RtlCopyMemory(pFipsData->bEncIv, rgbIV, sizeof(rgbIV));
        }
    }

    //
    // Get the signing key
    // The signing key is SHA(rgbSHABase1|rgbSHABase2)
    //
    if (pEnumMethod == NULL) {
        FipsSHAHashEx(&(pFipsData->FipsFunctionTable), rgbSHABase1, sizeof(rgbSHABase1), rgbSHABase2,
                  sizeof(rgbSHABase2), pFipsData->bSignKey);
    }

    return TRUE;
}


// Name:        TSFIPS_AdjustDataLen
//
// Purpose:     In Block encryption mode, adjust the data len to multiple of blocks
//
// Returns:     Adjusted data length
//
// Params:      IN      dataLen: Data length needed to be encrypted

UINT32 TSFIPS_AdjustDataLen(UINT32 dataLen)
{ 
    return (dataLen - dataLen % FIPS_BLOCK_LEN + FIPS_BLOCK_LEN);
}




// Name:        TSFIPS_EncryptData
//
// Purpose:     Encrypt the data and compute the signature
//
// Returns:     TRUE if successfully encrypted the data
//
// Params:      IN      pFipsData: Fips Data
//              IN/OUT  pbData: pointer to the data buffer being encrypted, encrypted data is
//                          returned in the same buffer.
//              IN      dwDataLen: data length to be encrypted
//              IN      dwPadLen: padding length in the data buffer
//              OUT     pbSignature: pointer to a signature buffer where the data signature is returned.
//              IN      dwEncryptionCount: running counter of all encryptions

BOOL TSFIPS_EncryptData(
                        PSM_FIPS_Data pFipsData,
                        LPBYTE pbData,
                        DWORD dwDataLen,
                        DWORD dwPadLen,
                        LPBYTE pbSignature,
                        DWORD  dwEncryptionCount)
{
    UINT8 Pad;
    BYTE rgbSHA[A_SHA_DIGEST_LEN];
    BYTE pbHmac[A_SHA_DIGEST_LEN];
    BOOL rc = FALSE;
    BYTE *pTempBuffer = NULL;
    BOOL bGetNewBuffer = FALSE;
    
    // Pad the the data with the padding size
    Pad = (UINT8)dwPadLen;
    memset(pbData + dwDataLen - dwPadLen, Pad, dwPadLen);

    // Compute signature
    FipsHmacSHAHashEx(&(pFipsData->FipsFunctionTable), pbData, dwDataLen - dwPadLen, (BYTE *)&dwEncryptionCount,
                     sizeof(dwEncryptionCount), pFipsData->bSignKey, sizeof(pFipsData->bSignKey), pbHmac);
    // Take the 1st 8 bytes of Hmac as signature
    RtlCopyMemory(pbSignature, pbHmac, MAX_SIGN_SIZE);

    // FipsBlockCBC need the data buffer to be aligned
    // so allocate a new buffer to hold the data if pbData is not aligned
    if ((ULONG_PTR)pbData & ALIGNMENT_BOUNDARY) {
        pTempBuffer = (BYTE *)ExAllocatePoolWithTag(PagedPool, dwDataLen, WD_ALLOC_TAG);
        if (pTempBuffer == NULL) {
            goto Exit;
        }
        RtlCopyMemory(pTempBuffer, pbData, dwDataLen);
        bGetNewBuffer = TRUE;
    }
    else {
        pTempBuffer = pbData;
    }

    pFipsData->FipsFunctionTable.FipsBlockCBC(FIPS_CBC_3DES,
                                              pTempBuffer,
                                              pTempBuffer,
                                              dwDataLen,
                                              &(pFipsData->EncTable),
                                              ENCRYPT,
                                              pFipsData->bEncIv);

    // Need to copy the data back if we allocate a new buffer to hold the data
    if (bGetNewBuffer) {
        RtlCopyMemory(pbData, pTempBuffer, dwDataLen);
        ExFreePool(pTempBuffer);
    }
    rc = TRUE;

Exit:
    return rc;
}




// Name:        TSFIPS_DecryptData
//
// Purpose:     Decrypt the data and compare the signature
//
// Returns:     TRUE if successfully decrypted the data
//
// Params:      IN      pFipsData: Fips Data
//              IN/OUT  pbData: pointer to the data buffer being decrypted, decrypted data is
//                          returned in the same buffer.
//              IN      dwDataLen: data length to be decrypted
//              IN      dwPadLen: padding length in the data buffer
//              IN      pbSignature: pointer to a signature buffer
//              IN      dwDecryptionCount: running counter of all encryptions

BOOL TSFIPS_DecryptData(
            PSM_FIPS_Data pFipsData,
            LPBYTE pbData,
            DWORD dwDataLen,
            DWORD dwPadLen,
            LPBYTE pbSignature,
            DWORD dwDecryptionCount)
{

    BOOL rc = FALSE;
    BYTE abSignature[A_SHA_DIGEST_LEN];
    BYTE rgbSHA[A_SHA_DIGEST_LEN];
    BYTE *pTempBuffer = NULL;
    BOOL bGetNewBuffer = FALSE;

    // dwPadLen should always be less than dwDataLen, if it's not the case
    // it means we're under attack so bail out here
    if (dwPadLen >= dwDataLen) {
        goto Exit;
    }

    // FipsBlockCBC need the data buffer to be aligned
    // so allocate a new buffer to hold the data if pbData is not aligned
    if ((ULONG_PTR)pbData & ALIGNMENT_BOUNDARY) {
        pTempBuffer = (BYTE *)ExAllocatePoolWithTag(PagedPool, dwDataLen, WD_ALLOC_TAG);
        if (pTempBuffer == NULL) {
            goto Exit;
        }
        RtlCopyMemory(pTempBuffer, pbData, dwDataLen);
        bGetNewBuffer = TRUE;
    }
    else {
        pTempBuffer = pbData;
    }

    pFipsData->FipsFunctionTable.FipsBlockCBC(FIPS_CBC_3DES,
                                              pTempBuffer,
                                              pTempBuffer,
                                              dwDataLen,
                                              &(pFipsData->DecTable),
                                              DECRYPT,
                                              pFipsData->bDecIv);

    // Need to copy the data back if we allocate a new buffer to hold the data
    if (bGetNewBuffer) {
        RtlCopyMemory(pbData, pTempBuffer, dwDataLen);
        ExFreePool(pTempBuffer);
    }

    // Compute signature
    FipsHmacSHAHashEx(&(pFipsData->FipsFunctionTable), pbData, dwDataLen - dwPadLen, (BYTE *)&dwDecryptionCount,
                      sizeof(dwDecryptionCount), pFipsData->bSignKey, sizeof(pFipsData->bSignKey), abSignature);
    
    //
    // check to see the sigature match.
    //

    if(!memcmp(
            (LPBYTE)abSignature,
            pbSignature,
            MAX_SIGN_SIZE)) {
        rc = TRUE;;
    }

Exit:
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\debug.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\color.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\driver.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* contains prototypes for the frame buffer driver.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "stddef.h"
#include <stdarg.h>
#include "windef.h"
#include "wingdi.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"
#include "debug.h"

typedef struct  _PDEV
{
    HANDLE  hDriver;                    // Handle to \Device\Screen
    HDEV    hdevEng;                    // Engine's handle to PDEV
    HSURF   hsurfEng;                   // Engine's handle to surface
    HPALETTE hpalDefault;               // Handle to the default palette for device.
    PVOID   pdsurf;                     // Associated surface
    SIZEL   sizlSurf;                   // Displayed size of the surface
    PBYTE   pjScreen;                   // This is pointer to base screen address
    ULONG   cxScreen;                   // Visible screen width
    ULONG   cyScreen;                   // Visible screen height
    POINTL  ptlOrg;                     // Where this display is anchored in
                                        //   the virtual desktop.
    ULONG   ulMode;                     // Mode the mini-port driver is in.
    LONG    lDeltaScreen;               // Distance from one scan to the next.
    ULONG   cScreenSize;                // size of video memory, including
                                        // offscreen memory.
    PVOID   pOffscreenList;             // linked list of DCI offscreen surfaces.
    FLONG   flRed;                      // For bitfields device, Red Mask
    FLONG   flGreen;                    // For bitfields device, Green Mask
    FLONG   flBlue;                     // For bitfields device, Blue Mask
    ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
    POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
    VIDEO_POINTER_CAPABILITIES PointerCapabilities; // HW pointer abilities
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes; // hardware pointer attributes
    DWORD   cjPointerAttributes;        // Size of buffer allocated
    BOOL    fHwCursorActive;            // Are we currently using the hw cursor
    PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal
    BOOL    bSupportDCI;                // Does the miniport support DCI?
} PDEV, *PPDEV;


typedef struct _DEVSURF                 /* dsurf */
{
    ULONG       flSurf;                 // DS_ flags as defined below
    BYTE        iColor;                 // Solid color surface if DS_SOLIDBRUSH

// If DS_SOLIDBRUSH, the following fields are undefined and not guaranteed to
// have been allocated!

    BYTE        iFormat;                // BMF_*, BMF_PHYSDEVICE
    BYTE        jReserved1;             // Reserved
    BYTE        jReserved2;             // Reserved
    PPDEV       ppdev;                  // Pointer to associated PDEV
    SIZEL       sizlSurf;               // Size of the surface
    ULONG       lNextScan;              // Offset from scan  "n" to "n+1"
    ULONG       lNextPlane;             // Offset from plane "n" to "n+1"
    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
                                        //  control function
    ULONG       ajBits[1];              // Bits will start here for device bitmaps
} DEVSURF, * PDEVSURF;


DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInitPointer(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisableSURF(PPDEV);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"framebuf"   // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "FRAMEBUF: "  // All debug output is prefixed
#define ALLOC_TAG               'bfDD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\enable.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvOffset,                (PFN) DrvOffset             },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  }
};

/* from VGA
static  DRVFN   gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush           },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap     },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap     },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape        },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits         },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  }
};*/

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT5_01;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        RIP("DISP DrvEnablePDEV failed EngAllocMem\n");
        return((DHPDEV) 0);
    }

    memset(ppdev, 0, sizeof(PDEV));

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"DISP DrvEnablePDEV failed\n"));
        goto error_free;
    }

    // Initialize the cursor information.

    if (!bInitPointer(ppdev, &DevInfo))
    {
        // Not a fatal error...
        DISPDBG((0, "DrvEnablePDEV failed bInitPointer\n"));
    }

    // Initialize palette information.

    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP("DrvEnablePDEV failed bInitPalette\n");
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    EngFreeMem(ppdev);
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{

    vDisablePalette((PPDEV) dhpdev);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvOffset
*
* DescriptionText
*
\**************************************************************************/

BOOL DrvOffset(
SURFOBJ*    pso,
LONG        x,
LONG        y,
FLONG       flReserved)
{
    PDEV*   ppdev = (PDEV*) pso->dhpdev;

    // Add back last offset that we subtracted.  I could combine the next
    // two statements, but I thought this was more clear.  It's not
    // performance critical anyway.

    ppdev->pjScreen += ((ppdev->ptlOrg.y * ppdev->lDeltaScreen) +
                        (ppdev->ptlOrg.x * ((ppdev->ulBitCount+1) >> 3)));

    // Subtract out new offset

    ppdev->pjScreen -= ((y * ppdev->lDeltaScreen) +
                        (x * ((ppdev->ulBitCount+1) >> 3)));

    ppdev->ptlOrg.x = x;
    ppdev->ptlOrg.y = y;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    PDEVSURF pdsurf;
    DHSURF   dhsurf;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    ppdev->ptlOrg.x = 0;
    ppdev->ptlOrg.y = 0;

    if (!bInitSURF(ppdev, TRUE))
    {
        DISPDBG((0, "DISP DrvEnableSurface failed bInitSURF\n"));
        return((HSURF) 0);
    }

    dhsurf = (DHSURF) EngAllocMem(0, sizeof(DEVSURF), ALLOC_TAG);

    if (dhsurf == (DHSURF) 0)
    {
        return((HSURF) 0);
    }

    // from VGA - begin
    pdsurf = (PDEVSURF) dhsurf;

    pdsurf->flSurf          = 0;
    pdsurf->iFormat         = 0;
    pdsurf->jReserved1      = 0;
    pdsurf->jReserved2      = 0;
    pdsurf->ppdev           = ppdev;
    pdsurf->sizlSurf.cx     = ppdev->sizlSurf.cx;
    pdsurf->sizlSurf.cy     = ppdev->sizlSurf.cy;
    pdsurf->lNextPlane      = 0;
    // from VGA - end


    hsurf = (HSURF)EngCreateDeviceSurface(dhsurf, ppdev->sizlSurf, BMF_8BPP);

    if (hsurf == (HSURF) 0)
    {
        DISPDBG((0,"DISP DrvEnableSurface failed EngCreateBitmap\n"));
        EngFreeMem(dhsurf);
        return((HSURF) 0);
    }


    if (!EngAssociateSurface(hsurf, ppdev->hdevEng,
                        HOOK_BITBLT | HOOK_TEXTOUT | HOOK_STROKEPATH |
                        HOOK_COPYBITS | HOOK_PAINT | HOOK_FILLPATH
                        ))
    {
        DISPDBG((0, "DISP DrvEnableSurface failed EngAssociateSurface\n"));
        EngDeleteSurface(hsurf);
        EngFreeMem(dhsurf);
        return((HSURF) 0);
    }

    ppdev->hsurfEng = hsurf;
    ppdev->pdsurf = pdsurf;

    return(hsurf);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
    if (((PPDEV) dhpdev)->pPointerAttributes != NULL) {
        EngFreeMem(((PPDEV) dhpdev)->pPointerAttributes);
        ((PPDEV) dhpdev)->pPointerAttributes = NULL;
    }
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    if (bEnable)
    {
        //
        // The screen must be reenabled, reinitialize the device to clean state.
        //

        return (bInitSURF(ppdev, FALSE));
    }
    else
    {
        //
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.
        //

        /*
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
        {
            RIP("DISP DrvAssertMode failed IOCTL");
            return FALSE;
        }
        else
        */
        {
            return TRUE;
        }
    }
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((3, "DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW)
                                                     + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}

////////////////////////////////////////////////////////////////////////////
// Hooked functions that drop everything because our surface is NULL
////////////////////////////////////////////////////////////////////////////

/******************************Public*Routine******************************\
* VOID DrvBitBlt(pso,pso,pso,pco,pxlo,prcl,pptl,pptl,pdbrush,pptl,rop4)
*
* Bitblt.
*
\**************************************************************************/

BOOL DrvBitBlt
(
    SURFOBJ    *psoTrg,             // Target surface
    SURFOBJ    *psoSrc,             // Source surface
    SURFOBJ    *psoMask,            // Mask
    CLIPOBJ    *pco,                // Clip through this
    XLATEOBJ   *pxlo,               // Color translation
    RECTL      *prclTrg,            // Target offset and extent
    POINTL     *pptlSrc,            // Source offset
    POINTL     *pptlMask,           // Mask offset
    BRUSHOBJ   *pbo,                // Pointer to brush object
    POINTL     *pptlBrush,          // Brush offset
    ROP4        rop4                // Raster operation
)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut(pso,pstro,pfo,pco,prclExtra,prcOpaque,
*                 pvFore,pvBack,pptOrg,r2Fore,r2Back)
*
\**************************************************************************/

BOOL DrvTextOut(
 SURFOBJ  *pso,
 STROBJ   *pstro,
 FONTOBJ  *pfo,
 CLIPOBJ  *pco,
 PRECTL    prclExtra,
 PRECTL    prclOpaque,
 BRUSHOBJ *pboFore,
 BRUSHOBJ *pboOpaque,
 PPOINTL   pptlOrg,
 MIX       mix)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits(psoTrg,psoSrc,pco,pxlo,prclTrg,pptlSrc)
*
*  Copy the bits.
*
\**************************************************************************/
BOOL DrvCopyBits
(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    PRECTL    prclTrg,
    PPOINTL   pptlSrc
)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath
(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix,
    FLONG    flOptions
)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\palette.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// Global Table defining the 20 Window Default Colors.        For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        EngFreeMem((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (ppdev->ulBitCount == 8)
    {
        ULONG ulLoop;
        BYTE jRed,jGre,jBlu;

        //
        // Allocate our palette
        //

        ppdev->pPal = (PPALETTEENTRY)EngAllocMem(0, sizeof(PALETTEENTRY) * 256,
                                                 ALLOC_TAG);

        if ((ppdev->pPal) == NULL) {
            RIP("DISP bInitDefaultPalette() failed EngAllocMem\n");
            return(FALSE);
        }

        //
        // Generate 256 (8*4*4) RGB combinations to fill the palette
        //

        jRed = jGre = jBlu = 0;

        for (ulLoop = 0; ulLoop < 256; ulLoop++)
        {
            ppdev->pPal[ulLoop].peRed   = jRed;
            ppdev->pPal[ulLoop].peGreen = jGre;
            ppdev->pPal[ulLoop].peBlue  = jBlu;
            ppdev->pPal[ulLoop].peFlags = (BYTE)0;

            if (!(jRed += 32))
            if (!(jGre += 32))
            jBlu += 64;
        }

        //
        // Fill in Windows Reserved Colors from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colors for
        // painting windows borders and for non-palette managed applications.
        //

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            //
            // First 10
            //

            ppdev->pPal[ulLoop] = BASEPALETTE[ulLoop];

            //
            // Last 10
            //

            ppdev->pPal[246 + ulLoop] = BASEPALETTE[ulLoop+10];
        }

        //
        // Create handle for palette.
        //

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                   256,
                                                   (PULONG) ppdev->pPal,
                                                   0,0,0);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            EngFreeMem(ppdev->pPal);
            return(FALSE);
        }

        //
        // Initialize the hardware with the initial palette.
        //

        return(TRUE);

    } else {

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                                   0,(PULONG) NULL,
                                                   ppdev->flRed,
                                                   ppdev->flGreen,
                                                   ppdev->flBlue);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
	/*
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        //
        // Fill in pScreenClut header info:
        //

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        //
        // Copy colours in:
        //

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        //
        // Set palette registers:
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }
	*/

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    //
    // Fill in pScreenClut header info:
    //

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    //
    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.
    //

	/*
    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    //
    // Set palette registers
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }
	*/

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\memory.c ===
/*******************************************************************************
*
*   MEMORY.C
*
*   Memory allocation routines
*
*
*   Copyright Microsoft. 1998
*
*
******************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>



/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/


/*******************************************************************************
 *
 *  MemoryAllocate
 *
 *  This routine allocate a block of memory
 *
 *  ENTRY:
 *     Length (input)
 *        length of memory to allocate
 *     ppMemory (output)
 *        address to return pointer to memory
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
MemoryAllocate( ULONG Length, PVOID * ppMemory )
{
    ASSERT( Length > 0 );

    *ppMemory = IcaStackAllocatePoolWithTag( NonPagedPool, Length, '  DT' );
    if ( *ppMemory == NULL )
        return( STATUS_NO_MEMORY );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  MemoryFree
 *
 *  This routine frees a block of memory allocated by "MemoryAllocate"
 *
 *  ENTRY:
 *     pMemory (output)
 *        pointer to memory to free
 *
 *  EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
MemoryFree( PVOID pMemory )
{
    IcaStackFreePool( pMemory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\pointer.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c                                                   *
*                                                                          *
* This module contains the hardware Pointer support for the framebuffer    *
*                                                                          *
* Copyright (c) 1992-1998 Microsoft Corporation                            *
\**************************************************************************/

#include "driver.h"

BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo);

BOOL bCopyMonoPointer(
PPDEV ppdev,
SURFOBJ *psoMask);

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl);

/******************************Public*Routine******************************\
* DrvMovePointer
*
* Moves the hardware pointer to a new position.
*
\**************************************************************************/

VOID DrvMovePointer
(
    SURFOBJ *pso,
    LONG     x,
    LONG     y,
    RECTL   *prcl
)
{
	/*
    PPDEV ppdev = (PPDEV) pso->dhpdev;
    DWORD returnedDataLength;
    VIDEO_POINTER_POSITION NewPointerPosition;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.

    UNREFERENCED_PARAMETER(prcl);

    // Convert the pointer's position from relative to absolute
    // coordinates (this is only significant for multiple board
    // support).

    x -= ppdev->ptlOrg.x;
    y -= ppdev->ptlOrg.y;

    // If x is -1 after the offset then take down the cursor.

    if (x == -1)
    {
        //
        // A new position of (-1,-1) means hide the pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }
    }
    else
    {
        NewPointerPosition.Column = (SHORT) x - (SHORT) (ppdev->ptlHotSpot.x);
        NewPointerPosition.Row    = (SHORT) y - (SHORT) (ppdev->ptlHotSpot.y);

        //
        // Call miniport driver to move Pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_POINTER_POSITION,
                               &NewPointerPosition,
                               sizeof(VIDEO_POINTER_POSITION),
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_SET_POINTER_POSITION\n"));
        }
    }
	*/
}

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape
(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    DWORD   returnedDataLength;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.
    UNREFERENCED_PARAMETER(prcl);

    if (ppdev->pPointerAttributes == (PVIDEO_POINTER_ATTRIBUTES) NULL)
    {
        // Mini-port has no hardware Pointer support.
        return(SPS_ERROR);
    }

    // See if we are being asked to hide the pointer

    if (psoMask == (SURFOBJ *) NULL)
    {
		/*
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // It should never be possible to fail.
            // Message supplied for debugging.
            //

            DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }
		*/

        return(TRUE);
    }

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    if (!bSetHardwarePointerShape(pso,psoMask,psoColor,pxlo,x,y,fl))
    {
            if (ppdev->fHwCursorActive) {
                ppdev->fHwCursorActive = FALSE;

				/*
                if (EngDeviceIoControl(ppdev->hDriver,
                                       IOCTL_VIDEO_DISABLE_POINTER,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       &returnedDataLength)) {

                    DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
                }
				*/
            }

            //
            // Mini-port declines to realize this Pointer
            //

            return(SPS_DECLINE);
    }
    else
    {
        ppdev->fHwCursorActive = TRUE;
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* bSetHardwarePointerShape
*
* Changes the shape of the Hardware Pointer.
*
* Returns: True if successful, False if Pointer shape can't be hardware.
*
\**************************************************************************/

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl)
{
    PPDEV     ppdev = (PPDEV) pso->dhpdev;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    DWORD     returnedDataLength;

    if (psoColor != (SURFOBJ *) NULL)
    {
        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER) &&
                bCopyColorPointer(ppdev, psoMask, psoColor, pxlo))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_COLOR_POINTER;
        } else {
            return(FALSE);
        }

    } else {

        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER) &&
                bCopyMonoPointer(ppdev, psoMask))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_MONO_POINTER;
        } else {
            return(FALSE);
        }
    }

    //
    // Initialize Pointer attributes and position
    //

	/*
    pPointerAttributes->Enable = 1;

    //
    // if x,y = -1,-1 then pass them directly to the miniport so that
    // the cursor will be disabled

    pPointerAttributes->Column = (SHORT)(x);
    pPointerAttributes->Row    = (SHORT)(y);

    if ((x != -1) || (y != -1)) {
        pPointerAttributes->Column -= (SHORT)(ppdev->ptlHotSpot.x);
        pPointerAttributes->Row    -= (SHORT)(ppdev->ptlHotSpot.y);
    }

    //
    // set animate flags
    //

    if (fl & SPS_ANIMATESTART) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    } else if (fl & SPS_ANIMATEUPDATE) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;
    }

    //
    // Set the new Pointer shape.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_POINTER_ATTR,
                           pPointerAttributes,
                           ppdev->cjPointerAttributes,
                           NULL,
                           0,
                           &returnedDataLength)) {

        DISPDBG((1, "DISP:Failed IOCTL_VIDEO_SET_POINTER_ATTR call\n"));
        return(FALSE);
    }
	*/

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyMonoPointer
*
* Copies two monochrome masks into a buffer of the maximum size handled by the
* miniport, with any extra bits set to 0.  The masks are converted to topdown
* form if they aren't already.  Returns TRUE if we can handle this pointer in
* hardware, FALSE if not.
*
\**************************************************************************/

BOOL bCopyMonoPointer(
    PPDEV    ppdev,
    SURFOBJ *pso)
{
    ULONG cy;
    PBYTE pjSrcAnd, pjSrcXor;
    LONG  lDeltaSrc, lDeltaDst;
    LONG  lSrcWidthInBytes;
    ULONG cxSrc = pso->sizlBitmap.cx;
    ULONG cySrc = pso->sizlBitmap.cy;
    ULONG cxSrcBytes;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    PBYTE pjDstAnd = pPointerAttributes->Pixels;
    PBYTE pjDstXor = pPointerAttributes->Pixels;

    // Make sure the new pointer isn't too big to handle
    // (*2 because both masks are in there)
    if ((cxSrc > ppdev->PointerCapabilities.MaxWidth) ||
        (cySrc > (ppdev->PointerCapabilities.MaxHeight * 2)))
    {
        return(FALSE);
    }

    pjDstXor += ((ppdev->PointerCapabilities.MaxWidth + 7) / 8) *
            ppdev->pPointerAttributes->Height;

    // set the desk and mask to 0xff
    RtlFillMemory(pjDstAnd, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height, 0xFF);

    // Zero the dest XOR mask
    RtlZeroMemory(pjDstXor, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = pso->lDelta) < 0)
    {
        lSrcWidthInBytes = -lDeltaSrc;
    } else {
        lSrcWidthInBytes = lDeltaSrc;
    }

    pjSrcAnd = (PBYTE) pso->pvBits;

    // If the incoming pointer bitmap is bottomup, we'll flip it to topdown to
    // save the miniport some work
    if (!(pso->fjBitmap & BMF_TOPDOWN))
    {
        // Copy from the bottom
        pjSrcAnd += lSrcWidthInBytes * (cySrc - 1);
    }

    // Height of just AND mask
    cySrc = cySrc / 2;

    // Point to XOR mask
    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset from end of one dest scan to start of next
    lDeltaDst = ppdev->pPointerAttributes->WidthInBytes;

    for (cy = 0; cy < cySrc; ++cy)
    {
        RtlCopyMemory(pjDstAnd, pjSrcAnd, cxSrcBytes);
        RtlCopyMemory(pjDstXor, pjSrcXor, cxSrcBytes);

        // Point to next source and dest scans
        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyColorPointer
*
* Copies the mono and color masks into the buffer of maximum size
* handled by the miniport with any extra bits set to 0. Color translation
* is handled at this time. The masks are converted to topdown form if they
* aren't already.  Returns TRUE if we can handle this pointer in  hardware,
* FALSE if not.
*
\**************************************************************************/
BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo)
{
    return(FALSE);
}


/******************************Public*Routine******************************\
* bInitPointer
*
* Initialize the Pointer attributes.
*
\**************************************************************************/

BOOL bInitPointer(PPDEV ppdev, DEVINFO *pdevinfo)
{
    DWORD    returnedDataLength;

    ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES) NULL;
    ppdev->cjPointerAttributes = 0; // initialized in screen.c

    //
    // Ask the miniport whether it provides pointer support.
    //

	/*
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES,
                           &ppdev->ulMode,
                           sizeof(PVIDEO_MODE),
                           &ppdev->PointerCapabilities,
                           sizeof(ppdev->PointerCapabilities),
                           &returnedDataLength))
    {
         return(FALSE);
    }

    //
    // If neither mono nor color hardware pointer is supported, there's no
    // hardware pointer support and we're done.
    //

    if ((!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)) &&
        (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)))
    {
        return(TRUE);
    }

    //
    // Note: The buffer itself is allocated after we set the
    // mode. At that time we know the pixel depth and we can
    // allocate the correct size for the color pointer if supported.
    //

    //
    // Set the asynchronous support status (async means miniport is capable of
    // drawing the Pointer at any time, with no interference with any ongoing
    // drawing operation)
    //

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_ASYNC_POINTER)
    {
       pdevinfo->flGraphicsCaps |= GCAPS_ASYNCMOVE;
    }
    else
    {
       pdevinfo->flGraphicsCaps &= ~GCAPS_ASYNCMOVE;
    }
	*/

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\tsddd\screen.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    ( GCAPS_OPAQUERECT
    | GCAPS_MONO_DITHER
                   ), /* Graphics capabilities         */
    SYSTM_LOGFONT,    /* Default font description */
    HELVE_LOGFONT,    /* ANSI variable font description   */
    COURI_LOGFONT,    /* ANSI fixed font description          */
    0,                /* Count of device fonts          */
    0,                /* Preferred DIB format          */
    8,                /* Width of color dither          */
    8,                /* Height of color dither   */
    0                 /* Default palette to use for this device */
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.        Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;

    //
    // Set the current mode into the hardware.
    //

	/*
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_CURRENT_MODE,
                           &(ppdev->ulMode),
                           sizeof(ULONG),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        RIP("DISP bInitSURF failed IOCTL_SET_MODE\n");
        return(FALSE);
    }
	*/

    //
    // If this is the first time we enable the surface we need to map in the
    // memory also.
    //

    if (bFirst)
    {
        videoMemory.RequestedVirtualAddress = NULL;

		/*
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            RIP("DISP bInitSURF failed IOCTL_VIDEO_MAP\n");
            return(FALSE);
        }
		*/

		//
		// Let's take for now 640x480x8bpp
		//

		videoMemoryInformation.VideoRamBase = NULL;//EngAllocMem(0, 640*480*8, ALLOC_TAG);
		videoMemoryInformation.VideoRamLength = 0;//640*480*8; 

		/*if (videoMemoryInformation.VideoRamBase == NULL)
		{
			return FALSE;
		}*/

		videoMemoryInformation.FrameBufferBase = videoMemoryInformation.VideoRamBase;
		videoMemoryInformation.FrameBufferLength = videoMemoryInformation.VideoRamLength; 


        ppdev->pjScreen = (PBYTE)(videoMemoryInformation.FrameBufferBase);

        if (videoMemoryInformation.FrameBufferBase !=
            videoMemoryInformation.VideoRamBase)
        {
            RIP("VideoRamBase does not correspond to FrameBufferBase\n");
        }

        ppdev->cScreenSize = videoMemoryInformation.VideoRamLength;

        //
        // Initialize the head of the offscreen list to NULL.
        //

        ppdev->pOffscreenList = NULL;

        // It's a hardware pointer; set up pointer attributes.

        MaxHeight = ppdev->PointerCapabilities.MaxHeight;

        // Allocate space for two DIBs (data/mask) for the pointer. If this
        // device supports a color Pointer, we will allocate a larger bitmap.
        // If this is a color bitmap we allocate for the largest possible
        // bitmap because we have no idea of what the pixel depth might be.

        // Width rounded up to nearest byte multiple

        if (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER))
        {
            MaxWidth = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
        }
        else
        {
            MaxWidth = ppdev->PointerCapabilities.MaxWidth * sizeof(DWORD);
        }

        ppdev->cjPointerAttributes =
                sizeof(VIDEO_POINTER_ATTRIBUTES) +
                ((sizeof(UCHAR) * MaxWidth * MaxHeight) * 2);

        ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES)
                EngAllocMem(0, ppdev->cjPointerAttributes, ALLOC_TAG);

        if (ppdev->pPointerAttributes == NULL) {

            DISPDBG((0, "bInitPointer EngAllocMem failed\n"));
            return(FALSE);
        }

        ppdev->pPointerAttributes->Flags = ppdev->PointerCapabilities.Flags;
        ppdev->pPointerAttributes->WidthInBytes = MaxWidth;
        ppdev->pPointerAttributes->Width = ppdev->PointerCapabilities.MaxWidth;
        ppdev->pPointerAttributes->Height = MaxHeight;
        ppdev->pPointerAttributes->Column = 0;
        ppdev->pPointerAttributes->Row = 0;
        ppdev->pPointerAttributes->Enable = 0;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

	/*
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           &videoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        RIP("DISP vDisableSURF failed IOCTL_VIDEO_UNMAP\n");
    }
	*/

	//EngFreeMem(ppdev->pjScreen);
}


/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        return(FALSE);
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pDevMode->dmPelsWidth        == 0) &&
        (pDevMode->dmPelsHeight       == 0) &&
        (pDevMode->dmBitsPerPel       == 0) &&
        (pDevMode->dmDisplayFrequency == 0))
    {
        DISPDBG((2, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((2, "Requested mode..."));
        DISPDBG((2, "   Screen width  -- %li", pDevMode->dmPelsWidth));
        DISPDBG((2, "   Screen height -- %li", pDevMode->dmPelsHeight));
        DISPDBG((2, "   Bits per pel  -- %li", pDevMode->dmBitsPerPel));
        DISPDBG((2, "   Frequency     -- %li", pDevMode->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((3, "Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        EngFreeMem(pVideoBuffer);
        DISPDBG((0,"DISP bInitPDEV failed - no valid modes\n"));
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->sizlSurf.cx = ppdev->cxScreen;
    ppdev->sizlSurf.cy = ppdev->cyScreen;

    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;


    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 1;     // We don't have accelerated screen-
                                        //   to-screen blts, and any
                                        //   window alignment is okay

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

#ifdef MIPS
    if (ppdev->ulBitCount == 8)
        pGdiInfo->flTextCaps = (TC_RA_ABLE | TC_SCROLLBLT);
    else
#endif
    pGdiInfo->flTextCaps = TC_RA_ABLE;

    pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

    pGdiInfo->ulDACRed   = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue  = pVideoModeSelected->NumberBlueBits;

    pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    //
    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.
    //

	/*
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                           NULL,
                           0,
                           &colorCapabilities,
                           sizeof(VIDEO_COLOR_CAPABILITIES),
                           &ulTemp))
	*/
    {

        DISPDBG((2, "getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
	/*
    else
    {
        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };
	*/

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

    // Note: this should be modified later to take into account the size
    // of the display and the resolution.

    pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

    pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    // Fill in the rest of the devinfo and GdiInfo structures.

	if (ppdev->ulBitCount == 8)
    {
        // It is Palette Managed.

        pGdiInfo->ulNumColors = 20;
        pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

        pDevInfo->flGraphicsCaps |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
        pDevInfo->iDitherFormat = BMF_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
    }
    else
    {
        pGdiInfo->ulNumColors = (ULONG) (-1);
        pGdiInfo->ulNumPalReg = 0;

		if (ppdev->ulBitCount == 16)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
            pDevInfo->iDitherFormat = BMF_16BPP;
        }
        else if (ppdev->ulBitCount == 24)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
            pDevInfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
            pDevInfo->iDitherFormat = BMF_32BPP;
        }
    }

    EngFreeMem(pVideoBuffer);

    return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

VIDEO_MODE_INFORMATION gaVideoModesInfo[]=
{
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		0,								// ULONG ModeIndex
		640,							// ULONG VisScreenWidth
		480,							// ULONG VisScreenHeight
		480*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		640,							// ULONG VideoMemoryBitmapWidth
		480,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		1,								// ULONG ModeIndex
		800,							// ULONG VisScreenWidth
		600,							// ULONG VisScreenHeight
		600*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		800,							// ULONG VideoMemoryBitmapWidth
		600,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		2,								// ULONG ModeIndex
		1024,							// ULONG VisScreenWidth
		768,							// ULONG VisScreenHeight
		768*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1024,							// ULONG VideoMemoryBitmapWidth
		768,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		3,								// ULONG ModeIndex
		1152,							// ULONG VisScreenWidth
		864,							// ULONG VisScreenHeight
		1152*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1152,							// ULONG VideoMemoryBitmapWidth
		864,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		4,								// ULONG ModeIndex
		1280,							// ULONG VisScreenWidth
		1024,							// ULONG VisScreenHeight
		1024*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1280,							// ULONG VideoMemoryBitmapWidth
		1024,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		5,								// ULONG ModeIndex
		1600,							// ULONG VisScreenWidth
		1200,							// ULONG VisScreenHeight
		1200*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1600,							// ULONG VideoMemoryBitmapWidth
		1200,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		6,								// ULONG ModeIndex
		1856,							// ULONG VisScreenWidth
		1392,							// ULONG VisScreenHeight
		1392*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,							// ULONG XMillimeter
		240,							// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1856,							// ULONG VideoMemoryBitmapWidth
		1392,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	},
	{
		sizeof(VIDEO_MODE_INFORMATION), // ULONG Length
		7,								// ULONG ModeIndex
		1920,							// ULONG VisScreenWidth
		1200,							// ULONG VisScreenHeight
		1200*8,							// ULONG ScreenStride
		1,								// ULONG NumberOfPlanes
		8,								// ULONG BitsPerPlane
		60,								// ULONG Frequency
		320,								// ULONG XMillimeter
		240,								// ULONG YMillimeter
		3,								// ULONG NumberRedBits
		3,								// ULONG NumberGreenBits
		2,								// ULONG NumberBlueBits
		0,								// ULONG RedMask
		0,								// ULONG GreenMask
		0,								// ULONG BlueMask
		VIDEO_MODE_GRAPHICS,			// ULONG AttributeFlags
		1920,							// ULONG VideoMemoryBitmapWidth
		1200,							// ULONG VideoMemoryBitmapHeight
		0,								// ULONG DriverSpecificAttributeFlags
	}
};


DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

	/*
    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }
	*/
	modes.NumModes = sizeof(gaVideoModesInfo)/sizeof(gaVideoModesInfo[0]);
	modes.ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(0, modes.NumModes *
                                    modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

	/*
    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }
	*/

	/*
	(*modeInformation)->Length = sizeof(VIDEO_MODE_INFORMATION);
    (*modeInformation)->ModeIndex = 0;
    (*modeInformation)->VisScreenWidth = 640;
    (*modeInformation)->VisScreenHeight = 480;
    (*modeInformation)->ScreenStride = 480*8;
    (*modeInformation)->NumberOfPlanes = 1;
    (*modeInformation)->BitsPerPlane = 8;
    (*modeInformation)->Frequency = 60;
    (*modeInformation)->XMillimeter = 0;
    (*modeInformation)->YMillimeter = 0;
    (*modeInformation)->NumberRedBits = 3;
    (*modeInformation)->NumberGreenBits = 3;
    (*modeInformation)->NumberBlueBits = 2;
    (*modeInformation)->RedMask = 0;
    (*modeInformation)->GreenMask = 0;
    (*modeInformation)->BlueMask = 0;
    (*modeInformation)->AttributeFlags = VIDEO_MODE_GRAPHICS;
    (*modeInformation)->VideoMemoryBitmapWidth = 640;
    (*modeInformation)->VideoMemoryBitmapHeight = 480;
    (*modeInformation)->DriverSpecificAttributeFlags = 0;
	*/

	//
	// copy all predefined modes
	//
	RtlCopyMemory(*modeInformation, gaVideoModesInfo, modes.ModeInformationLength*modes.NumModes);

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\buffer.c ===
/*************************************************************************
*
* buffer.c 
*
* Common buffering code for all transport drivers
*
* Copyright 1998, Microsoft
*
*  
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

/*=============================================================================
==   External Functions Defined
=============================================================================*/

VOID OutBufError( PTD, POUTBUF );
VOID OutBufFree( PTD, POUTBUF );

/*=============================================================================
==   Functions used
=============================================================================*/


/*******************************************************************************
 *
 *  OutBufError
 *
 *  This routine is used to return an output buffer to the ICA driver
 *  free pool on an unsuccessful write or other error. 
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pOutBuf (input)
 *       pointer to output buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
OutBufError( PTD pTd, POUTBUF pOutBuf )
{
    ASSERT( pOutBuf->Links.Flink == pOutBuf->Links.Blink );

    IcaBufferError( pTd->pContext, pOutBuf );
}


/*******************************************************************************
 *
 *  OutBufFree
 *
 *  This routine is used to return an output buffer to the up stream
 *  stack driver.  This routine should only be used when the data contained
 *  in the output buffer was successfully written to the transport.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pOutBuf (input)
 *       pointer to output buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
OutBufFree( PTD pTd, POUTBUF pOutBuf )
{
    ASSERT( pOutBuf->Links.Flink == pOutBuf->Links.Blink );

    IcaBufferFree( pTd->pContext, pOutBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\input.c ===
/*************************************************************************
*
* input.c 
*
* Common input code for all transport drivers
*
* Copyright 1998, Microsoft
*
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS TdInputThread( PTD );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdInBufAlloc( PTD, PINBUF * );
VOID     _TdInBufFree( PTD, PINBUF );
NTSTATUS _TdInitializeRead( PTD, PINBUF );
NTSTATUS _TdReadComplete( PTD, PINBUF );
NTSTATUS _TdReadCompleteRoutine( PDEVICE_OBJECT, PIRP, PVOID );


/*=============================================================================
==   Functions used
=============================================================================*/

NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS NtSetInformationThread( HANDLE, THREADINFOCLASS, PVOID, ULONG );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*******************************************************************************
 *
 *  TdInputThread
 *
 *   This private TD thread waits for input data.  This thread is created
 *   when a client connection is established and is terminated when 
 *   StackCancelIo is called.
 *
 *   All received data is sent to the up stream stack driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS 
TdInputThread( PTD pTd )
{
    ICA_CHANNEL_COMMAND Command;
    KPRIORITY Priority;
    PFILE_OBJECT pFileObject;
    PINBUF pInBuf;
    PLIST_ENTRY Head, Next;
    KIRQL oldIrql;
    ULONG InputByteCount;
    int i;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (entry)\n" ));

    /*
     *  Check if driver is being closed or endpoint has been closed
     */
    if ( pTd->fClosing || pTd->pDeviceObject == NULL ) {
        TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (exit) on init\n" ));
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     *  Set the priority of this thread to lowest realtime (16).
     */
    Priority = LOW_REALTIME_PRIORITY;
    NtSetInformationThread( NtCurrentThread(), ThreadPriority, 
                            &Priority, sizeof(KPRIORITY) );

    /*
     * Initialize the input wait event
     */
    KeInitializeEvent( &pTd->InputEvent, NotificationEvent, FALSE );

    /*
     * Allocate and pre-submit one less than the total number
     * of input buffers that we will use.  The final buffer will
     * be allocated/submitted within the input loop.
     */
    for ( i = 1; i < pTd->InBufCount; i++ ) {

        /*
         * Allocate an input buffer
         */
        Status = _TdInBufAlloc( pTd, &pInBuf );
        if ( !NT_SUCCESS( Status ) )
            return( Status );
    
        /*
         * Initialize the read IRP
         */
        Status = _TdInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            return( Status );
    
        /*
         * Let the device level code complete the IRP initialization
         */
        Status = DeviceInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            return( Status );
    
        /*
         * Place the INBUF on the busy list and call the device submit routine.
         * (TDI based drivers use receive indications, so we let
         * the TD specific code call the driver.)
         */
        ExInterlockedInsertTailList( &pTd->InBufBusyHead, &pInBuf->Links,
                                     &pTd->InBufListLock );
        Status = DeviceSubmitRead( pTd, pInBuf );
    }

    /*
     * Allocate an input buffer
     */
    Status = _TdInBufAlloc( pTd, &pInBuf );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Reference the file object and keep a local pointer to it.
     * This is done so that when the endpoint object gets closed,
     * and pTd->pFileObject gets dereferenced and cleared, the file
     * object will not get deleted before all of the pending input IRPs
     * (which reference the file object) get cancelled.
     */
    ObReferenceObject( (pFileObject = pTd->pFileObject) );

    /*
     * Loop reading input data until cancelled or we get an error.
     */
    for (;;) {

        /*
         * Initialize the read IRP
         */
        Status = _TdInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) ) {
            TRACE0(("TdInputThread: _TdInitializeRead Status=0x%x\n", Status));
            KeSetEvent( &pTd->InputEvent, 1, FALSE );
            break;
        }

    
        /*
         * Let the device level code complete the IRP initialization
         */
        Status = DeviceInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) ) {
            TRACE0(("TdInputThread: DeviceInitializeRead Status=0x%x\n", Status));
            KeSetEvent( &pTd->InputEvent, 1, FALSE );
            break;
        }

    
        /*
         * Place the INBUF on the busy list and call the device submit routine.
         * (TDI based drivers use receive indications, so we let
         * the TD specific code call the driver.)
         */
        ExInterlockedInsertTailList( &pTd->InBufBusyHead, &pInBuf->Links,
                                     &pTd->InBufListLock );
        Status = DeviceSubmitRead( pTd, pInBuf );
        /*
         * Indicate we no longer have an INBUF referenced
         */
        pInBuf = NULL;

        if ( !NT_SUCCESS(Status) ) {
            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: IoCallDriver Status=0x%x\n", Status ));
            TRACE0(("TdInputThread: IoCallDriver Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
            pTd->ReadErrorCount++;
            pTd->pStatus->Input.TdErrors++;
            if ( pTd->ReadErrorCount >= pTd->ReadErrorThreshold ) {
                // Submit failed, set the event since no IRP's are queued
                KeSetEvent( &pTd->InputEvent, 1, FALSE );
                break;
            }
        }

        /*
         * If the INBUF completed list is empty,
         * then wait for one to be available.
         */
waitforread:
        ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        if ( IsListEmpty( &pTd->InBufDoneHead ) ) {

            KeClearEvent( &pTd->InputEvent );

            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            Status = DeviceWaitForRead( pTd );

            /*
             *  Check for broken connection
             */
            if ( pTd->fClosing ) {
                TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: fClosing set\n" ));
                TRACE0(("TdInputThread: fClosing set Context 0x%x\n",pTd->pAfd ));
                break;
            } else if ( Status != STATUS_SUCCESS) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: DeviceWaitForRead Status=0x%x\n", Status ));
                TRACE0(( "TdInputThread: DeviceWaitForRead Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    goto waitforread;
                break;
            }
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );

        /*
         *  Check for broken connection
         */
        } else if ( pTd->fClosing ) {
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: fClosing set\n" ));
            TRACE0(("TdInputThread: fClosing set Context 0x%x\n",pTd->pAfd ));
            break;
        }
    
        /*
         *  If the list is empty as this point, we will just bail.
         */
        if (!IsListEmpty( &pTd->InBufDoneHead )) {
            
            /*
             * Take the first INBUF off the completed list.
             */
            Head = RemoveHeadList( &pTd->InBufDoneHead );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
    
            /*
             * Do any preliminary read complete processing
             */
            (VOID) _TdReadComplete( pTd, pInBuf );
    
            /*
             * Get status from IRP.  Note that we allow warning and informational
             * status codes as they can also return valid data.
             */
            Status = pInBuf->pIrp->IoStatus.Status;
            InputByteCount = (ULONG)pInBuf->pIrp->IoStatus.Information;
            if (NT_ERROR(Status)) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: IRP Status=0x%x\n", Status ));
                TRACE0(("TdInputThread: IRP Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    continue;
                break;
            }
            if ( Status == STATUS_TIMEOUT )
                Status = STATUS_SUCCESS;
    
            /*
             *  Make sure we got some data
             */
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: read cnt=%04u, Status=0x%x\n", 
                    InputByteCount, Status ));
    
            /*
             *  Check for consecutive zero byte reads
             *  -- the client may have dropped the connection and ReadFile does
             *     not always return an error.
             *  -- some tcp networks return zero byte reads now and then 
             */
            if ( InputByteCount == 0 ) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "recv warning: zero byte count\n" ));
                TRACE0(("recv warning: zero byte count, Context 0x%x\n",pTd->pAfd ));
                if ( ++pTd->ZeroByteReadCount > MAXIMUM_ZERO_BYTE_READS ) {
                    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "recv failed: %u zero bytes\n", MAXIMUM_ZERO_BYTE_READS ));
                    TRACE0(("recv failed: %u zero bytes Context 0x%x\n", MAXIMUM_ZERO_BYTE_READS, pTd->pAfd ));
                    Status = STATUS_CTX_TD_ERROR;
                    break;
                }
                continue;
            }
    
            /*
             * Clear count of consecutive zero byte reads
             */
            pTd->ZeroByteReadCount = 0;
        
            TRACEBUF(( pTd->pContext, TC_TD, TT_IRAW, pInBuf->pBuffer, InputByteCount ));
    
            /*
             * Do device specific read completion processing.
             * If the byte count returned is 0, then the device routine
             * processed all input data so there is nothing for us to do.
             */
            Status = DeviceReadComplete( pTd, pInBuf->pBuffer, &InputByteCount );
            if ( !NT_SUCCESS(Status) ) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: DeviceReadComplete Status=0x%x\n", Status ));
                TRACE0(("TdInputThread: DeviceReadComplete Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    continue;
                break;
            }
            if ( InputByteCount == 0 )
                continue;
    
            /*
             * Clear count of consecutive read errors
             */
            pTd->ReadErrorCount = 0;
    
            /*
             *  Update input byte counter
             */
            pTd->pStatus->Input.Bytes += (InputByteCount - pTd->InBufHeader);
            if ( pTd->PdFlag & PD_FRAME )
                pTd->pStatus->Input.Frames++;
        
            /*
             *  Send input data to upstream stack driver
             */
            Status = IcaRawInput( pTd->pContext, 
                                  NULL, 
                                  (pInBuf->pBuffer + pTd->InBufHeader),
                                  (InputByteCount - pTd->InBufHeader) );
            if ( !NT_SUCCESS(Status) ) 
                break;
        }
        else {
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: InBuf is empty\n" ));
            ASSERT(FALSE);
            pTd->ReadErrorCount++;  
            pTd->pStatus->Input.TdErrors++;
            if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                goto waitforread;
            else
                break;
        }
    }

    TRACE0(("TdInputThread: Breaking Connection Context 0x%x\n",pTd->pAfd));

    /*
     * Free current INBUF if we have one
     */
    if ( pInBuf )
        _TdInBufFree( pTd, pInBuf );

    /*
     *  Cancel all i/o 
     */
    (VOID) StackCancelIo( pTd, NULL );

    /*
     * Wait for pending read (if any) to be cancelled
     */
    (VOID) IcaWaitForSingleObject( pTd->pContext, &pTd->InputEvent, -1 );

    /*
     * Free all remaining INBUFs
     */
    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
    while ( !IsListEmpty( &pTd->InBufBusyHead ) ||
            !IsListEmpty( &pTd->InBufDoneHead ) ) {

        if ( !IsListEmpty( &pTd->InBufBusyHead ) ) {
            BOOLEAN rc;

            Head = RemoveHeadList( &pTd->InBufBusyHead );
            Head->Flink = NULL;
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            rc = IoCancelIrp( pInBuf->pIrp );
#if DBG
            if ( !rc ) {
                DbgPrint("TDCOMMON: StackCancelIo: Could not cancel IRP 0x%x\n",pInBuf->pIrp);
            }
#endif
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }

        if ( IsListEmpty( &pTd->InBufDoneHead ) ) {
            KeClearEvent( &pTd->InputEvent );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            Status = DeviceWaitForRead( pTd );
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }

        if ( !IsListEmpty( &pTd->InBufDoneHead ) ) {
            Head = RemoveHeadList( &pTd->InBufDoneHead );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            _TdInBufFree( pTd, pInBuf );
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }
    }
    ASSERT( IsListEmpty( &pTd->InBufBusyHead ) );
    ASSERT( IsListEmpty( &pTd->InBufDoneHead ) );
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * Release our reference on the underlying file object
     */
    ObDereferenceObject( pFileObject );

    /*
     *  Report broken connection if no modem callback in progress
     */
    if ( !pTd->fCallbackInProgress ) {
        Command.Header.Command          = ICA_COMMAND_BROKEN_CONNECTION;

        //
        // If it's not an unexpected disconnection then set the reason
        // to disconnect. This prevents problems where termsrv resets the
        // session if it receives the wrong type of notification.
        //
        if (pTd->UserBrokenReason == TD_USER_BROKENREASON_UNEXPECTED) {
            Command.BrokenConnection.Reason = Broken_Unexpected;
            //
            // We don't know better so pick server as the source
            //
            Command.BrokenConnection.Source = BrokenSource_Server;
        }
        else
        {
            Command.BrokenConnection.Reason = Broken_Disconnect;
            Command.BrokenConnection.Source = BrokenSource_User;
        }

        (void) IcaChannelInput( pTd->pContext, 
                                Channel_Command, 
                                0, 
                                NULL, 
                                (PCHAR) &Command, 
                                sizeof(Command) );
    }

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (exit), Status=0x%x\n", Status ));
    TRACE0(("TdInputThread (exit), Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));

    return( Status );
}


/*******************************************************************************
 *
 *  _TdInBufAlloc
 *
 *    Routine to allocate an INBUF and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdInBufAlloc(
    PTD pTd,
    PINBUF *ppInBuf
    )
{
    ULONG InBufLength;
    ULONG irpSize;
    ULONG mdlSize;
    ULONG AllocationSize;
    KIRQL oldIrql;
    PINBUF pInBuf;
    NTSTATUS Status;

#define INBUF_STACK_SIZE 4

    /*
     * Determine size of input buffer
     */
    InBufLength = pTd->OutBufLength + pTd->InBufHeader;

    /*
     * Determine the sizes of the various components of an INBUF.
     * Note that these are all worst-case calculations--
     * actual size of the MDL may be smaller.
     */
    irpSize = IoSizeOfIrp( INBUF_STACK_SIZE ) + 8;
    mdlSize = (ULONG)MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), InBufLength );

    /*
     * Add up the component sizes of an INBUF to determine
     * the total size that is needed to allocate.
     */
    AllocationSize = (((sizeof(INBUF) + InBufLength + 
                     irpSize + mdlSize) + 3) & ~3);

    Status = MemoryAllocate( AllocationSize, &pInBuf );
    if ( !NT_SUCCESS( Status ) )
        return( STATUS_NO_MEMORY );

    /*
     * Initialize the IRP pointer and the IRP itself.
     */
    if ( irpSize ) {
        pInBuf->pIrp = (PIRP)(( ((ULONG_PTR)(pInBuf + 1)) + 7) & ~7);
        IoInitializeIrp( pInBuf->pIrp, (USHORT)irpSize, INBUF_STACK_SIZE );
    }

    /*
     * Set up the MDL pointer but don't build it yet.
     * It will be built by the TD write code if needed.
     */
    if ( mdlSize ) {
        pInBuf->pMdl = (PMDL)((PCHAR)pInBuf->pIrp + irpSize);
    }

    /*
     * Set up the address buffer pointer.
     */
    pInBuf->pBuffer = (PUCHAR)pInBuf + sizeof(INBUF) + irpSize + mdlSize;

    /*
     *  Initialize the rest of InBuf
     */
    InitializeListHead( &pInBuf->Links );
    pInBuf->MaxByteCount = InBufLength;
    pInBuf->ByteCount = 0;
    pInBuf->pPrivate = pTd;

    /*
     *  Return buffer to caller
     */
#if DBG
    DbgPrint( "TdInBufAlloc: pInBuf=0x%x\n", pInBuf );
#endif  // DBG
    *ppInBuf = pInBuf;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TdInBufFree
 *
 *    Routine to free an INBUF and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

VOID
_TdInBufFree(
    PTD pTd,
    PINBUF pInBuf
    )
{
    MemoryFree( pInBuf );
}


/*******************************************************************************
 *
 *  _TdInitializeRead
 *
 *    Routine to allocate and initialize the input IRP and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdInitializeRead(
    PTD pTd,
    PINBUF pInBuf
    )
{
    PIRP irp = pInBuf->pIrp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;

    /*
     *  Check if driver is being closed or endpoint has been closed
     */
    if ( pTd->fClosing || pTd->pDeviceObject == NULL ) {
        TRACE(( pTd->pContext, TC_TD, TT_API2, "_TdInitializeRead: closing\n" ));
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     * Set current thread for IoSetHardErrorOrVerifyDevice.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    /*
     * Get a pointer to the stack location of the first driver which will be
     * invoked.  This is where the function codes and the parameters are set.
     */
    irpSp = IoGetNextIrpStackLocation( irp );

    /*
     * Set the file/device objects and anything not specific to
     * the TD. and read parameters.
     */
    irpSp->FileObject = pTd->pFileObject;
    irpSp->DeviceObject = pTd->pDeviceObject;

    irp->MdlAddress = NULL;

    irp->Flags = IRP_READ_OPERATION;

    /*
     * Register the I/O completion routine
     */
    if ( pTd->pSelfDeviceObject ) {
        IoSetCompletionRoutineEx( pTd->pSelfDeviceObject, irp, _TdReadCompleteRoutine, pInBuf,
                                TRUE, TRUE, TRUE );
    } else {
        IoSetCompletionRoutine( irp, _TdReadCompleteRoutine, pInBuf,
                                TRUE, TRUE, TRUE );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TdReadCompleteRoutine
 *
 *    This routine is called at DPC level by the lower level device
 *    driver when an input IRP is completed.
 *
 * ENTRY:
 *    DeviceObject (input)
 *       not used
 *    pIrp (input)
 *       pointer to IRP that is complete
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding INBUF.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdReadCompleteRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    KIRQL oldIrql;
    PINBUF pInBuf = (PINBUF)Context;
    PTD pTd = (PTD)pInBuf->pPrivate;

    /*
     * Unlink inbuf from busy list and place on completed list
     */
    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );

    if ( pInBuf->Links.Flink )
        RemoveEntryList( &pInBuf->Links );
    InsertTailList( &pTd->InBufDoneHead, &pInBuf->Links );

    /*
     * Check the auxiliary buffer pointer in the packet and if a buffer was
     * allocated, deallocate it now.  Note that this buffer must be freed
     * here since the pointer is overlayed with the APC that will be used
     * to get to the requesting thread's context.
     */
    if (Irp->Tail.Overlay.AuxiliaryBuffer) {
        IcaStackFreePool( Irp->Tail.Overlay.AuxiliaryBuffer );
        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //
    if (Irp->MdlAddress != NULL) {
        PMDL mdl, thisMdl;

        //
        // Unlock any pages that may be described by MDLs.
        //
        mdl = Irp->MdlAddress;
        while (mdl != NULL) {
            thisMdl = mdl;
            mdl = mdl->Next;
            if (thisMdl == pInBuf->pMdl)
                continue;

            MmUnlockPages( thisMdl );
            IoFreeMdl( thisMdl );
        }
    }

    /*
     * Indicate an INBUF was completed
     */
    KeSetEvent( &pTd->InputEvent, 1, FALSE );

    // WARNING!: At this point, we may context switch back to the input thread
    //           and unload the darn driver!!!  This has been temporarily hacked
    //           for TDPipe by remoing the unload entry point ;-(
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * We return STATUS_MORE_PROCESS_REQUIRED so that no further
     * processing for this IRP is done by the I/O completion routine.
     */
    return( STATUS_MORE_PROCESSING_REQUIRED );
}


/*******************************************************************************
 *
 *  _TdReadComplete
 *
 *    This routine is called at program level after an input IRP
 *    has been completed.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdReadComplete(
    IN PTD pTd,
    IN PINBUF pInBuf
    )
{
    PIRP irp = pInBuf->pIrp;

    /*
     * Handle the buffered I/O case
     */
    if (irp->Flags & IRP_BUFFERED_IO) {

        //
        // Copy the data if this was an input operation.  Note that no copy
        // is performed if the status indicates that a verify operation is
        // required, or if the final status was an error-level severity.
        //

        if (irp->Flags & IRP_INPUT_OPERATION  &&
            irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
            !NT_ERROR( irp->IoStatus.Status )) {

            //
            // Copy the information from the system buffer to the caller's
            // buffer.  This is done with an exception handler in case
            // the operation fails because the caller's address space
            // has gone away, or it's protection has been changed while
            // the service was executing.
            //
            try {
                RtlCopyMemory( irp->UserBuffer,
                               irp->AssociatedIrp.SystemBuffer,
                               irp->IoStatus.Information );
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred while attempting to copy the
                // system buffer contents to the caller's buffer.  Set
                // a new I/O completion status.
                //

                irp->IoStatus.Status = GetExceptionCode();
            }
        }

        //
        // Free the buffer if needed.
        //

        if (irp->Flags & IRP_DEALLOCATE_BUFFER) {
            IcaStackFreePool( irp->AssociatedIrp.SystemBuffer );
        }
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\ntdd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   ntdd.c

Abstract:

    This module contains support for standard NT driver initialization.

    This module is intended to be included in each WD/TD/PD on a Hydra
    system.

Author:

Revision History:

--*/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#define DEVICE_NAME_PREFIX L"\\Device\\"

//
// Global data
//
PDEVICE_OBJECT DrvDeviceObject;

//
// External references
//

// This is the name of the WD/TD/PD module we are initializing as.
extern PWCHAR ModuleName;

// This is the stack driver module entry point defined in ntos\citrix\inc\sdapi.h
NTSTATUS
_stdcall
ModuleEntry(
    IN OUT PSDCONTEXT pSdContext,
    IN BOOLEAN bLoad
    );

//
// Forward refrences
//
VOID DrvUnload( PDRIVER_OBJECT );

NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Standard NT driver entry routine.

Arguments:

    DriverObject - NT passed driver object
    RegistryPath - Path to driver specific registry entry

Return Value:

    NTSTATUS code.

Environment:

    Kernel mode, DDK
--*/

{
    ULONG i;
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    PWCHAR NameBuffer;
    ULONG  NameSize;

    PAGED_CODE( );

    NameSize = sizeof(DEVICE_NAME_PREFIX) + sizeof(WCHAR);
    NameSize += (wcslen(ModuleName) * sizeof(WCHAR));

    NameBuffer = IcaStackAllocatePool( NonPagedPool, NameSize );
    if( NameBuffer == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy( NameBuffer, DEVICE_NAME_PREFIX );
    wcscat( NameBuffer, ModuleName );

    RtlInitUnicodeString( &DeviceName, NameBuffer );


    Status = IoCreateDevice(
                 DriverObject,
                 0,       // No DeviceExtension
                 &DeviceName,
                 FILE_DEVICE_TERMSRV,
                 0,
                 FALSE,
                 &DrvDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
#if DBG
        DbgPrint("TD DriverEntry: Could not create Device %wZ, Status 0x%x\n",&DeviceName,Status);
        DbgBreakPoint();
#endif
        IcaStackFreePool( NameBuffer );
        return( Status );
    }

    DriverObject->DriverUnload = DrvUnload;
    DriverObject->FastIoDispatch = NULL;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DrvDispatch;
    }

    DrvDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IcaStackFreePool( NameBuffer );

    return( Status );
}

VOID
DrvUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Driver unload routine.

Arguments:

    DriverObject - Driver object being unloaded.

Return Value:

    None.

Environment:

    Kernel mode, DDK
--*/

{
    PAGED_CODE( );

    IoDeleteDevice( DrvDeviceObject );

    return;
}

NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for the driver.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Environment:

    Kernel mode, DDK
--*/

{
    PIO_STACK_LOCATION irpSp;
    KIRQL saveIrql;
    NTSTATUS Status;
    PSD_MODULE_INIT pmi;

    DeviceObject;   // prevent compiler warnings

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MajorFunction ) {

        case IRP_MJ_CREATE:

            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:

            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.IoControlCode !=
                    IOCTL_SD_MODULE_INIT ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(SD_MODULE_INIT) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            // Return the SD module entry point.
            pmi = (PSD_MODULE_INIT)Irp->UserBuffer;
            pmi->SdLoadProc = ModuleEntry;

            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(SD_MODULE_INIT);
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_CLEANUP:

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_CLOSE:

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        default:
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            IoCompleteRequest( Irp, 0 );

            return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\stack.c ===
/*************************************************************************
*
* stack.c
*
* ICA STACK IOCTLS
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>



/*=============================================================================
==   External procedures defined
=============================================================================*/

NTSTATUS StackCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCdCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCallbackInitiate( PTD, PSD_IOCTL );
NTSTATUS StackCallbackComplete( PTD, PSD_IOCTL );
NTSTATUS StackOpenEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCloseEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackConnectionWait( PTD, PSD_IOCTL );
NTSTATUS StackConnectionSend( PTD, PSD_IOCTL );
NTSTATUS StackConnectionRequest( PTD, PSD_IOCTL );
NTSTATUS StackQueryParams( PTD, PSD_IOCTL );
NTSTATUS StackSetParams( PTD, PSD_IOCTL );
NTSTATUS StackQueryLastError( PTD, PSD_IOCTL );
NTSTATUS StackWaitForStatus( PTD, PSD_IOCTL );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS StackQueryRemoteAddress( PTD, PSD_IOCTL );
NTSTATUS StackQueryLocalAddress( PTD, PSD_IOCTL );

/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _TdCreateInputThread( PTD );


/*=============================================================================
==   Procedures used
=============================================================================*/

NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceQueryRemoteAddress( PTD, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS DeviceQueryLocalAddress( PTD, PVOID, ULONG, PULONG );

NTSTATUS TdInputThread( PTD );
NTSTATUS TdSyncWrite( PTD, PSD_SYNCWRITE );


/*******************************************************************************
 *
 *  StackCreateEndpoint                         IOCTL_ICA_STACK_CREATE_ENDPOINT
 *
 *  Create new transport endpoint
 *
 *  The endpoint structure contains everything necessary to preserve
 *  a client connection across a transport driver unload and reload.
 *
 *  This routine creates a new endpoint, using the optional local address.
 *  In the case of a network connection, the actual endpoint cannot be
 *  created until the client connection is established.  What this routine
 *  creates is an endpoint to listen on.  
 *
 *  DeviceConnectionWait and DeviceConnectionRequest return the endpoint.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_ADDRESS (or NULL)
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCreateEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PICA_STACK_ADDRESS pAddressIn;
    PICA_STACK_ADDRESS pAddressOut;
    NTSTATUS Status;

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {

        /*
         *  No address specified 
         */
        pAddressIn = NULL;

    } else {

        /* 
         *  Get local address to use, if any
         */
        pAddressIn = pSdIoctl->InputBuffer;
    }

    if ( pSdIoctl->OutputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {

        /*
         *  No address specified 
         */
        pAddressOut = NULL;

    } else {

        /* 
         *  Get local address to use, if any
         */
        pAddressOut = pSdIoctl->OutputBuffer;
    }

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceCreateEndpoint( pTd, pAddressIn, pAddressOut );
    if ( !NT_SUCCESS(Status) ) 
        goto badcreate;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCreateEndpoint: %x, success\n", pAddressIn ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint create failed
     */
badcreate:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackCreateEndpoint: %x, Status=0x%x\n", pAddressIn, Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackCdCreateEndpoint                    IOCTL_ICA_STACK_CD_CREATE_ENDPOINT
 *
 *  Create an endpoint based on a data provided by a connection driver.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - <endpoint data)
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCdCreateEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCdCreateEndpoint: entry\n" ));

    pTd->fClosing = FALSE;

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceIoctl( pTd, pSdIoctl );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCdCreateEndpoint: success\n" ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint open failed
     */
badopen:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR,
            "TD: StackCdCreateEndpoint: Status=0x%x\n",
            Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackCallbackInitiate                     IOCTL_ICA_STACK_CALLBACK_INITIATE
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_CALLBACK
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCallbackInitiate( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCallbackInitiate: entry\n" ));

    pTd->fCallbackInProgress = TRUE;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  StackCallbackComplete                     IOCTL_ICA_STACK_CALLBACK_COMPLETE
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCallbackComplete( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCallbackComplete: entry\n" ));

    pTd->fCallbackInProgress = FALSE;

    /*
     *  Create the input thread if one is not running.
     */
    if ( pTd->pInputThread ) {
        Status = IcaWaitForSingleObject( pTd->pContext,
                                         pTd->pInputThread, 0 );
        if ( Status != STATUS_TIMEOUT) {    // if input thread not running
            /* 
             * The old input thread has gone away, but hasn't
             * been cleaned up.  Clean it up now.
             */
            ObDereferenceObject( pTd->pInputThread );
            pTd->pInputThread = NULL;
        }
    }
    if ( !pTd->pInputThread ) {
        Status = _TdCreateInputThread( pTd );
        if ( !NT_SUCCESS(Status) ) 
            goto badthreadcreate;
    }
    return( STATUS_SUCCESS );

badthreadcreate:
    return( Status );
}

/*******************************************************************************
 *
 *  StackOpenEndpoint                             IOCTL_ICA_STACK_OPEN_ENDPOINT
 *
 *  Open an existing transport endpoint
 *
 *  The endpoint structure contains everything necessary to preserve
 *  a client connection across a transport driver unload and reload.
 *
 *  This routine will bind to an existing endpoint which is passed as
 *  the input parameter.
 *  
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - <endpoint data>
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackOpenEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceOpenEndpoint( pTd, 
                                 pSdIoctl->InputBuffer,
                                 pSdIoctl->InputBufferLength );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    /*
     * Create the input thread now.
     */    
    Status = _TdCreateInputThread( pTd );
    if ( !NT_SUCCESS(Status) ) 
        goto badthreadcreate;
        
    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackOpenEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed - we used to close the endpoint, however TermSrv
     *  does not expect this and would do a double free.  Now we just rely on
     *  TermSrv to turn around and close the endpoint.
     */
badthreadcreate:
//  (void) DeviceCloseEndpoint( pTd );  

    /*
     *  endpoint open failed
     */
badopen:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackOpenEndpoint, Status=0x%x\n", Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackCloseEndpoint                           IOCTL_ICA_STACK_CLOSE_ENDPOINT
 *
 *  Close transport endpoint
 *
 *  This will terminate any client connection
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCloseEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    /*
     *  Close transport driver endpoint
     */
    Status = DeviceCloseEndpoint( pTd );  
    if ( !NT_SUCCESS(Status) ) 
        goto badclose;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCloseEndpoint: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint close failed
     */
badclose:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackCloseEndpoint: 0x%x\n", Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackConnectionWait                         IOCTL_ICA_STACK_CONNECTION_WAIT
 *
 *  Waits for a new client connection
 *
 *  After the transport driver is loaded and StackCreateEndpoint is called 
 *  this routine is called to wait for a new client connection.
 *
 *  If an endpoint does not yet exist, DeviceConnectionWait will create one
 *  when the client connects.
 *
 * Changed 02/18/97 JohnR:
 *
 *  This routine returns an opaque 32 bit handle to a data structure that
 *  is maintained by ICADD.SYS. This data structure allows the transport
 *  driver to maintain specific state information in a secure manner.
 *
 *  This state information is only known to the transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionWait( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionWait: enter\n" ));

    /*
     *  Initialize return byte count 
     *  - size of returned endpoint structure
     */
    pSdIoctl->BytesReturned = 0;

    /*
     *  Wait for physical connection
     *
     *  - DeviceConnectionWait should check OutputBufferLength to make
     *    sure it's long enough to return an endpoint structure before
     *    blocking.
     */
    Status = DeviceConnectionWait( pTd, 
                                   pSdIoctl->OutputBuffer,
                                   pSdIoctl->OutputBufferLength,
                                   &pSdIoctl->BytesReturned );
    if ( !NT_SUCCESS(Status) ) 
        goto badwait;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionWait: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed
     *  Wait failed
     */
badwait:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackConnectionWait: Status=0x%x\n", Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackConnectionSend                         IOCTL_ICA_STACK_CONNECTION_SEND
 *
 *  Initialize transport driver module data to send to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionSend( PTD pTd, PSD_IOCTL pSdIoctl )  
{
    return( DeviceConnectionSend( pTd ) );
}


/*******************************************************************************
 *
 *  StackConnectionRequest                   IOCTL_ICA_STACK_CONNECTION_REQUEST
 *
 *  Initiate a connection to the specified remote address
 *
 *  - this routine is only used by shadow 
 *
 *  DeviceConnectionRequest will create a new endpoint after establishing
 *  a connection.
 *
 *  This routine returns the endpoint data structure.  The endpoint structure
 *  contains everything necessary to preserve a connection across a transport
 *  driver unload and reload.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 *  typedef struct _ICA_STACK_ADDRESS {
 *      BYTE Address[MAX_BR_ADDRESS];   // bytes 0,1 family, 2-n address
 *  } ICA_STACK_ADDRESS, *PICA_STACK_ADDRESS;
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_ADDRESS (remote address)
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionRequest( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    NTSTATUS Status;

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto badbuffer;
    }

    /*
     *  Establish physical connection
     *
     *  - DeviceConnectionRequest should check OutputBufferLength to make
     *    sure it is long enough to return an endpoint structure before
     *    making a connection.
     */
    Status = DeviceConnectionRequest( pTd, 
                                      pSdIoctl->InputBuffer,
                                      pSdIoctl->OutputBuffer,
                                      pSdIoctl->OutputBufferLength,
                                      &pSdIoctl->BytesReturned );
    if ( !NT_SUCCESS(Status) ) 
        goto badrequest;

    /*
     *  Create input thread
     */
    Status = _TdCreateInputThread( pTd );
    if ( !NT_SUCCESS(Status) ) 
        goto badthreadcreate;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionRequest: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed
     *  connection request failed
     *  buffer too small
     */
badthreadcreate:
badrequest:
badbuffer:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackConnectionRequest: Status=0x%x\n", Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackQueryParams                               IOCTL_ICA_STACK_QUERY_PARAMS
 *
 *  query transport driver parameters
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - SDCLASS
 *       output - PDPARAMS
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackQueryParams( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    PPDPARAMS pParams;

    if ( pSdIoctl->InputBufferLength < sizeof(SDCLASS) ||
         pSdIoctl->OutputBufferLength < sizeof(PDPARAMS) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pParams = pSdIoctl->OutputBuffer;

    *pParams = pTd->Params;
    pSdIoctl->BytesReturned = sizeof(PDPARAMS);

    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  StackQueryRemoteAddress                   IOCTL_TS_STACK_QUERY_REMOTEADDRESS
 *
 *  query for the remote address
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - endpoint data
 *       output - sockaddr
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
StackQueryRemoteAddress( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    Status = DeviceQueryRemoteAddress( pTd,
                                       pSdIoctl->InputBuffer,
                                       pSdIoctl->InputBufferLength,
                                       pSdIoctl->OutputBuffer,
                                       pSdIoctl->OutputBufferLength,
                                       &pSdIoctl->BytesReturned );

    if ( !NT_SUCCESS(Status) )
    {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackQueryRemoteAddress: 0x%\n", Status ));
    }

    return Status;
}


/*******************************************************************************
 *
 *  StackQueryLocalIPAddress                   IOCTL_ICA_STACK_QUERY_LOCALIPADDRESS
 *
 *  query for the RDP-Enabled IP Address 
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (output)
 *       input  - no
 *       output - ULONG (IP Address)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
StackQueryLocalAddress( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    Status = DeviceQueryLocalAddress( pTd,
                                      pSdIoctl->OutputBuffer,
                                      pSdIoctl->OutputBufferLength,
                                      &pSdIoctl->BytesReturned );

    if ( !NT_SUCCESS(Status) )
    {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackQueryLocalIP: 0x%\n", Status ));
    }

    return Status;
}


/*******************************************************************************
 *
 *  StackSetParams                                   IOCTL_ICA_STACK_SET_PARAMS
 *
 *  set transport driver parameters
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - PDPARAMS
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackSetParams( PTD pTd, PSD_IOCTL pSdIoctl )  
{
    PPDPARAMS pParams;

    if ( pSdIoctl->InputBufferLength < sizeof(PDPARAMS) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pParams = pSdIoctl->InputBuffer;

    pTd->Params = *pParams;

    return( DeviceSetParams( pTd ) );
}


/*******************************************************************************
 *
 *  StackQueryLastError                        IOCTL_ICA_STACK_QUERY_LAST_ERROR
 *
 *  Query transport driver error code and message
 *
 *  typedef struct _ICA_STACK_LAST_ERROR {
 *      ULONG Error;
 *      CHAR Message[ MAX_ERRORMESSAGE ];
 *  } ICA_STACK_LAST_ERROR, *PICA_STACK_LAST_ERROR;
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - ICA_STACK_LAST_ERROR
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackQueryLastError( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    if ( pSdIoctl->OutputBufferLength < sizeof(ICA_STACK_LAST_ERROR) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pSdIoctl->BytesReturned = sizeof(ICA_STACK_LAST_ERROR);

    return( DeviceGetLastError( pTd, pSdIoctl->OutputBuffer ) );
}


/*******************************************************************************
 *
 *  StackWaitForStatus                          IOCTL_ICA_STACK_WAIT_FOR_STATUS
 *
 *  Wait for transport driver status to change
 *  - only supported by async transport driver to wait for rs232 signal change
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackWaitForStatus( PTD pTd, PSD_IOCTL pSdIoctl )
{
    /*
     *  Check if driver is being closed
     */
    if ( pTd->fClosing ) 
        return( STATUS_CTX_CLOSE_PENDING );

    return( DeviceWaitForStatus( pTd ) );
}


/*******************************************************************************
 *
 *  StackCancelIo                                    IOCTL_ICA_STACK_CANCEL_IO
 *
 *  cancel all current and future transport driver i/o
 *
 *  NOTE: no more i/o can be done after StackCancelIo is called.
 *        The transport driver must be unloaded and reloaded to
 *        re-enable i/o.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCancelIo( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCancelIo (enter)\n" ));

    /*
     *  Set stack closing flag
     */
    pTd->fClosing = TRUE;

    /*
     *  Clear error thresholds now
     */
    pTd->ReadErrorThreshold = 0;
    pTd->WriteErrorThreshold = 0;

    /*
     * Call device specific cancel I/O routine
     */
    Status = DeviceCancelIo( pTd );
    ASSERT( Status == STATUS_SUCCESS );

    /*
     * Wait for all writes to complete
     */
    Status = TdSyncWrite( pTd, NULL );
    ASSERT( Status == STATUS_SUCCESS );

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCancelIo, %u (exit)\n", Status ));

    return( Status );
}

/*******************************************************************************
 *
 *  StackSetBrokenReason                       IOCTL_ICA_STACK_SET_BROKENREASON
 *
 *  Store a broken reason for later use (when reporting back up the stack)
 *
 *  NOTE: Does not break the connection
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_BROKENREASON
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
StackSetBrokenReason( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PICA_STACK_BROKENREASON pBrkReason;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackSetBrokenReason (enter)\n" ));

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_BROKENREASON) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pBrkReason = pSdIoctl->InputBuffer;
    pTd->UserBrokenReason = pBrkReason->BrokenReason;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackSetBrokenReason, %u (exit)\n", STATUS_SUCCESS ));
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *
 *  _TdCreateInputThread
 *
 *  Start the input thread running.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdCreateInputThread( PTD pTd )
{
    HANDLE hInputThread;
    NTSTATUS Status;

    /*
     *  Create input thread
     */
    Status = IcaCreateThread( pTd->pContext,
                              TdInputThread,
                              pTd,
                              ICALOCK_DRIVER,
                              &hInputThread );
    if ( !NT_SUCCESS(Status) ) 
        return( Status );

    /*
     * Convert thread handle to pointer reference
     */
    Status = ObReferenceObjectByHandle( hInputThread,
                                        THREAD_ALL_ACCESS,
                                        NULL,
                                        KernelMode,
                                        &pTd->pInputThread,
                                        NULL );
    (VOID) ZwClose( hInputThread );
    if ( !NT_SUCCESS( Status ) ) {
        (VOID) StackCancelIo( pTd, NULL );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\common\tdapi.c ===
/****************************************************************************/
// tdapi.c
//
// Common code for all Transport Drivers
//
// Typical connection sequence:
//
//  TdLoad                load driver
//  TdOpen                open driver (parameters)
//  StackCreateEndpoint   create new endpoint
//  StackConnectionWait   establish client connection (endpoint)
//  TdClose               close driver (does not close endpoint)
//  TdUnload              unload driver
//
//  TdLoad                load driver
//  TdOpen                open driver
//  StackOpenEndpoint     bind to an existing endpoint
//  StackConnectionSend   initialize host module data sent to client
//
//  (connected session)
//
//  StackCloseEndpoint    disconnect client connection
//  TdClose               close driver
//  TdUnload              unload driver
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#define REG_GUID_TABLE  L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\lanatable"

#define LANA_ID      L"LanaId"


/*=============================================================================
==   External Functions Defined
=============================================================================*/
NTSTATUS ModuleEntry( PSDCONTEXT, BOOLEAN );
NTSTATUS TdLoad( PSDCONTEXT );
NTSTATUS TdUnload( PSDCONTEXT );
NTSTATUS TdOpen( PTD, PSD_OPEN );
NTSTATUS TdClose( PTD, PSD_CLOSE );
NTSTATUS TdRawWrite( PTD, PSD_RAWWRITE );
NTSTATUS TdChannelWrite( PTD, PSD_CHANNELWRITE );
NTSTATUS TdSyncWrite( PTD, PSD_SYNCWRITE );
NTSTATUS TdIoctl( PTD, PSD_IOCTL );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/
NTSTATUS _TdInitializeWrite( PTD, POUTBUF );
NTSTATUS _TdWriteCompleteRoutine( PDEVICE_OBJECT, PIRP, PVOID );
VOID     _TdWriteCompleteWorker( PTD, PVOID );


/*=============================================================================
==   Functions used
=============================================================================*/
NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );

NTSTATUS StackCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCdCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCallbackInitiate( PTD, PSD_IOCTL );
NTSTATUS StackCallbackComplete( PTD, PSD_IOCTL );
NTSTATUS StackOpenEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCloseEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackConnectionWait( PTD, PSD_IOCTL );
NTSTATUS StackConnectionSend( PTD, PSD_IOCTL );
NTSTATUS StackConnectionRequest( PTD, PSD_IOCTL );
NTSTATUS StackQueryParams( PTD, PSD_IOCTL );
NTSTATUS StackSetParams( PTD, PSD_IOCTL );
NTSTATUS StackQueryLastError( PTD, PSD_IOCTL );
NTSTATUS StackWaitForStatus( PTD, PSD_IOCTL );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS StackSetBrokenReason( PTD, PSD_IOCTL );
NTSTATUS StackQueryRemoteAddress( PTD, PSD_IOCTL );
NTSTATUS StackQueryLocalAddress( PTD, PSD_IOCTL );

VOID     OutBufFree( PTD, POUTBUF );
VOID     OutBufError( PTD, POUTBUF );
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Static global data
=============================================================================*/

/*
 *  Transport driver procedures
 */
PSDPROCEDURE G_pTdProcedures[] =
{
    TdOpen,
    TdClose,
    TdRawWrite,
    TdChannelWrite,
    TdSyncWrite,
    TdIoctl,
};


/*******************************************************************************
 *  ModuleEntry
 *
 *  ICA driver entry point.
 *
 *    pContext (input/output)
 *       pointer to the SD context structure
 *    fLoad (input)
 *       TRUE - load driver
 *       FALSE - unload driver
 ******************************************************************************/
NTSTATUS ModuleEntry(PSDCONTEXT pContext, BOOLEAN fLoad)
{
    if (fLoad)
        return TdLoad(pContext);
    else
        return TdUnload(pContext);
}


/*******************************************************************************
 *  TdLoad
 *
 *    The ICA driver directly calls this routine immediately after loading
 *    this transport driver.
 *
 *    1) initialize procedure dispatch table
 *    2) allocate transport driver data structure
 ******************************************************************************/
NTSTATUS TdLoad(PSDCONTEXT pContext)
{
    NTSTATUS Status;
    PTD pTd;

    /*
     *  Initialize td procedures
     */
    pContext->pProcedures = G_pTdProcedures;

    /*
     *  Since this is the last stack driver there are no callup procedures
     */
    pContext->pCallup = NULL;

    /*
     *  Allocate TD data structure
     */
    Status = MemoryAllocate( sizeof(TD), &pTd );
    if (Status == STATUS_SUCCESS) {
        RtlZeroMemory(pTd, sizeof(TD));
        pTd->pContext = pContext;
        pContext->pContext = pTd;
    }
    else {
        TRACE((pContext, TC_TD, TT_ERROR, "TdLoad: Failed alloc TD\n"));
    }

    return Status;
}


/*******************************************************************************
 *  TdUnload
 *
 *    The ICA driver directly calls this routine immediately after closing
 *    this transport driver.
 *
 *    1) free all transport driver data structures
 ******************************************************************************/
NTSTATUS TdUnload(PSDCONTEXT pContext)
{
    PTD pTd;

    /*
     *  Get pointers to TD data structures
     */
    pTd = pContext->pContext;

    /*
     *  Free TD private data structures
     */
    if (pTd->pPrivate)
        MemoryFree(pTd->pPrivate);

    if (pTd->pAfd)
        MemoryFree(pTd->pAfd);

    /* 
     *  Free TD data structure
     */
    MemoryFree(pTd);

    /*
     *  Clear context structure
     */
    pContext->pContext = NULL;
    pContext->pProcedures = NULL;
    pContext->pCallup = NULL;

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  TdOpen
 *
 *    The ICA driver directly calls this routine immediately after loading
 *    this transport driver.
 *
 *    1) initialize transport driver parameters
 *    2) call device specfic open
 *    3) allocate data buffers
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure 
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS TdOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    SD_CLOSE SdClose;
    NTSTATUS Status;

    /*
     *  Initialize TD data structure
     */
    InitializeListHead( &pTd->IoBusyOutBuf );
    pTd->InBufCount = 1;
    KeInitializeSpinLock( &pTd->InBufListLock );
    InitializeListHead( &pTd->InBufBusyHead );
    InitializeListHead( &pTd->InBufDoneHead );
    InitializeListHead( &pTd->WorkItemHead );
    pTd->pClient          = pSdOpen->pClient;
    pTd->pStatus          = pSdOpen->pStatus;
    pTd->PdFlag           = pSdOpen->PdConfig.Create.PdFlag;
    pTd->OutBufLength     = pSdOpen->PdConfig.Create.OutBufLength;
    pTd->PortNumber       = pSdOpen->PdConfig.Create.PortNumber;
    pTd->Params           = pSdOpen->PdConfig.Params;
    pTd->UserBrokenReason = TD_USER_BROKENREASON_UNEXPECTED;

    /*
     *  Open device
     */
    Status = DeviceOpen(pTd, pSdOpen);
    if (NT_SUCCESS(Status)) {
        /*
         *  Save size of header and trailer for td
         */
        pTd->OutBufHeader  = pSdOpen->SdOutBufHeader;
        pTd->OutBufTrailer = pSdOpen->SdOutBufTrailer;
        KeInitializeEvent(&pTd->SyncWriteEvent, NotificationEvent, FALSE);
        TRACE((pTd->pContext, TC_TD, TT_API1, "TdOpen: success\n"));
    }
    else {
        DeviceClose(pTd, &SdClose);
        TRACE((pTd->pContext, TC_TD, TT_ERROR, "TdOpen, Status=0x%x\n", Status));
    }

    return Status;
}


/*******************************************************************************
 *  TdClose
 *
 *    The ICA driver directly calls this routine immediately before unloading
 *    this transport driver.
 *
 *    NOTE: This does NOT terminate the client connection
 *
 *    1) cancel all i/o (returns all OUTBUFs)
 *    2) terminate read thread 
 *    3) free data buffers
 *    4) call device specific close
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 ******************************************************************************/
NTSTATUS TdClose(PTD pTd, PSD_CLOSE pSdClose)
{
    NTSTATUS Status;

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdClose: (enter)\n"));

    /*
     *  Cancel all pending i/o (read thread)
     */
    (VOID)StackCancelIo(pTd, NULL);

    /*
     *  Return size of header and trailer for pd
     */
    pSdClose->SdOutBufHeader  = pTd->OutBufHeader;
    pSdClose->SdOutBufTrailer = pTd->OutBufTrailer;

    /*
     *  All reads and writes should have previously been canceled
     */
    ASSERT( pTd->fClosing );
    ASSERT( IsListEmpty( &pTd->IoBusyOutBuf ) );

    /*
     *  Wait for input thread to exit
     */
    if (pTd->pInputThread) {
        Status = IcaWaitForSingleObject(pTd->pContext, pTd->pInputThread, 60000);

        if ( !NT_SUCCESS(Status) && (Status!=STATUS_CTX_CLOSE_PENDING) ) {
            DbgPrint("TdClose: wait for the input thread to exit failed: status=%x pTd=%p\n", Status, pTd);
            ASSERT( NT_SUCCESS(Status) || (Status==STATUS_CTX_CLOSE_PENDING) );
        }

        /*
         * Dereference input thread if it hasn't been already
         * (it may have been done in StackCallbackComplete while we waited).
         */
        if (pTd->pInputThread) {
            ObDereferenceObject(pTd->pInputThread);
            pTd->pInputThread = NULL;
        }
    }

    /*
     *  Close device
     */
    Status = DeviceClose(pTd, pSdClose);

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdClose: Status=0x%x\n", Status));
    return Status;
}


/*******************************************************************************
 *  _TdInitializeWrite
 *
 *    Initialize the supplied OutBuf and corresponding IRP for writing.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    pOutBuf (input/output)
 *       Points to the OutBuf to be initialized for writing
 ******************************************************************************/
__inline NTSTATUS _TdInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP irp = pOutBuf->pIrp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;

    /*
     *  Make sure endpoint is open
     */
    if (pTd->pDeviceObject != NULL) {
        // Set current thread for IoSetHardErrorOrVerifyDevice.
        irp->Tail.Overlay.Thread = PsGetCurrentThread();

        // Get a pointer to the stack location of the first driver which will be
        // invoked. This is where the function codes and the parameters are set.
        irpSp = IoGetNextIrpStackLocation(irp);

        // Set the major function code, file/device objects, and write
        // parameters.
        irpSp->FileObject = pTd->pFileObject;
        irpSp->DeviceObject = pTd->pDeviceObject;

        irp->Flags = 0;
        return STATUS_SUCCESS;
    }
    else {
        return STATUS_CTX_CLOSE_PENDING;
    }
}


/*******************************************************************************
 *  TdRawWrite
 *
 *    The up stream stack driver calls this routine when it has data
 *    to write to the transport.  This data has all the necessary
 *    headers and trailers already appended.  
 *
 *    The OUTBUF pointed to by this write request must always be
 *    returned to the up stream stack driver after the write completes
 *    successfully or unsuccessfully.
 *   
 *    1) call device specific write
 *    2) return OUTBUF after write completes (OutBufFree)
 *       return OUTBUF after an error (OutBufError)
 *
 *    pTd (input)
 *       Pointer to td data structure 
 *    pSdRawWrite (input)
 *       Points to the parameter structure SD_RAWWRITE
 ******************************************************************************/
NTSTATUS TdRawWrite(PTD pTd, PSD_RAWWRITE pSdRawWrite)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;
    PLIST_ENTRY pWorkItem = NULL;
    KIRQL oldIrql;


    pOutBuf = pSdRawWrite->pOutBuf;
    ASSERT(pOutBuf);

    // Check if driver is being closed
    if (!pTd->fClosing) {
        // See if we have had too many consecutive write errors
        if (pTd->WriteErrorCount <= pTd->WriteErrorThreshold) {
            // Initialize the IRP contained in the outbuf.
            Status = _TdInitializeWrite(pTd, pOutBuf);
            if (NT_SUCCESS(Status)) {
                // Let the device level code complete the IRP initialization.
                Status = DeviceInitializeWrite(pTd, pOutBuf);
                if (NT_SUCCESS(Status)) {
                    // Update the MDL byte count to reflect the exact number
                    // of bytes to send.
                    pOutBuf->pMdl->ByteCount = pOutBuf->ByteCount;

                    // Save our TD structure pointer in the OUTBUF
                    // so the I/O completion routine can get it.
                    pOutBuf->pPrivate = pTd;

                    // Insert outbuf on busy list
                    InsertTailList(&pTd->IoBusyOutBuf, &pOutBuf->Links);

                    // Preallocate a completion workitem now and chain it to list of workitems.
                    Status = IcaAllocateWorkItem(&pWorkItem);
                    if (!NT_SUCCESS(Status)) {
                        //
                        //we inserted the outbuf into the list. In badwrite below,
                        //we reinitialize this entry and we free it (or return to the pool)
                        //so, we need to remove this outbuf entry from the list
                        //
                        TRACE((pTd->pContext, TC_TD, TT_OUT1,
                                "TdRawWrite : No memory to allocate WorkItem. Removing Outbuf from the list %04u, %p\n",
                                pOutBuf->ByteCount, pOutBuf));
                        RemoveEntryList( &pOutBuf->Links );
                        goto badwrite;
                    }
                    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
                    InsertTailList( &pTd->WorkItemHead, pWorkItem );
                    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
    
                    // Register I/O completion routine
                    if ( pTd->pSelfDeviceObject == NULL ) {
                        IoSetCompletionRoutine(pOutBuf->pIrp,
                                _TdWriteCompleteRoutine, pOutBuf, TRUE, TRUE,
                                TRUE);
                    } else {
                        IoSetCompletionRoutineEx(pTd->pSelfDeviceObject,
                                pOutBuf->pIrp,
                                _TdWriteCompleteRoutine, pOutBuf, TRUE, TRUE,
                                TRUE);
                    }

                    // Call the device driver
                    // From this point on we must NOT free the outbuf.
                    // It will be free'd by the write complete routine.
                    Status = IoCallDriver(pTd->pDeviceObject, pOutBuf->pIrp);
                    if (NT_SUCCESS(Status)) {
                        // Update output counters
                        pTd->pStatus->Output.Bytes += pOutBuf->ByteCount;
                        pTd->pStatus->Output.Frames++;

                        TRACE((pTd->pContext, TC_TD, TT_OUT1,
                                "TdRawWrite %04u, %08x\n",
                                pOutBuf->ByteCount, pOutBuf));
                        TRACEBUF((pTd->pContext, TC_TD, TT_ORAW,
                                pOutBuf->pBuffer, pOutBuf->ByteCount));

                        Status = STATUS_SUCCESS;
                    }
                    else {
                        //
                        //for some reason, IoCallDriver failed (probably a out of memory?)
                        //in this case, we are leaking the WorkItem and Outbuf because 
                        //we may never a get a call into our completion routine?
                        //do we need to remove the workitem and outbuf from the list here and free it?
                        //
                        goto badcalldriver;
                    }
                }
                else {
                    goto badwrite;
                }
            }
            else {
                goto badwrite;
            }
        }
        else {
            OutBufError(pTd, pOutBuf);
            TRACE((pTd->pContext, TC_TD, TT_API2,
                    "TdRawWrite: WriteErrorThreshold exceeded\n"));
            Status = pTd->LastError;
        }
    }
    else {
        OutBufError(pTd, pOutBuf);
        TRACE((pTd->pContext, TC_TD, TT_API2, "TdRawWrite: closing\n"));
        Status = STATUS_CTX_CLOSE_PENDING;
    }

    return Status;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  write completed with an error
     */
badwrite:
    InitializeListHead( &pOutBuf->Links );
    OutBufError(pTd, pOutBuf);

    /*
     * IoCallDriver returned an error
     * NOTE: We must NOT free the outbuf here.
     *       It will be free'd by the write complete routine.
     */
badcalldriver:
    TRACE(( pTd->pContext, TC_TD, TT_OUT1, "TdRawWrite, Status=0x%x\n", Status ));
    pTd->LastError = Status;
    pTd->WriteErrorCount++;
    pTd->pStatus->Output.TdErrors++;
    if (pTd->WriteErrorCount < pTd->WriteErrorThreshold)
        Status = STATUS_SUCCESS;
    return Status;
}


/*******************************************************************************
 *  TdChannelWrite - channel write
 *
 *    This routine should never be called
 *
 *    pTd (input)
 *       Pointer to td data structure 
 *    pSdChannelWrite (input)
 *       Points to the parameter structure SD_CHANNELWRITE
 ******************************************************************************/
NTSTATUS TdChannelWrite(PTD pTd, PSD_CHANNELWRITE pSdChannelWrite)
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 *  TdSyncWrite
 *
 *    This routine is called by the up stream stack driver to wait
 *    for all pending writes to complete.
 *
 *    1) wait for all writes to complete
 *    2) return all OUTBUFs
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdFlush (input)
 *       Points to the parameter structure SD_FLUSH
 ******************************************************************************/
NTSTATUS TdSyncWrite(PTD pTd, PSD_SYNCWRITE pSdSyncWrite)
{
    NTSTATUS Status = STATUS_TIMEOUT;

    TRACE(( pTd->pContext, TC_TD, TT_OUT1, "TdSyncWrite (enter)\n" ));

    while (Status == STATUS_TIMEOUT)
    {
        /*
         *  Return if there are no writes pending
         */
        if (IsListEmpty(&pTd->IoBusyOutBuf))
            return STATUS_SUCCESS;

        /*
         * Reset sync event and indicate we are waiting
         */
        if (!pTd->fSyncWriteWaiter) {
            pTd->fSyncWriteWaiter = TRUE;
            KeResetEvent(&pTd->SyncWriteEvent);
        }

        /*
         * Wait for event to be triggered
         */
        Status = IcaWaitForSingleObject( pTd->pContext, &pTd->SyncWriteEvent, 60000 );
        if (Status == STATUS_CTX_CLOSE_PENDING)
            Status = STATUS_SUCCESS;
    }

    TRACE((pTd->pContext, TC_TD, TT_OUT1, "TdSyncWrite (exit)\n"));
    return Status;
}


/*******************************************************************************
 *  TdIoctl
 *
 *    This routine is called by the up stream stack driver.  These
 *    ioctls are used to connect, disconnect, query parameters, and
 *    set parameters.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS TdIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS Status;

    switch (pSdIoctl->IoControlCode) {
        case IOCTL_ICA_STACK_CREATE_ENDPOINT:
            Status = StackCreateEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_OPEN_ENDPOINT:
            Status = StackOpenEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CLOSE_ENDPOINT:
            StackCancelIo(pTd, pSdIoctl);
            Status = StackCloseEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_WAIT :
            Status = StackConnectionWait(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_SEND :
            Status = StackConnectionSend(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_REQUEST :
            Status = StackConnectionRequest(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_PARAMS :
            Status = StackQueryParams(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_SET_PARAMS :
            Status = StackSetParams(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_LAST_ERROR :
            Status = StackQueryLastError(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_WAIT_FOR_STATUS :
            Status = StackWaitForStatus(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CANCEL_IO :
            Status = StackCancelIo(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CD_CREATE_ENDPOINT :
            Status = StackCdCreateEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CALLBACK_INITIATE :
            Status = StackCallbackInitiate(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CALLBACK_COMPLETE :
            Status = StackCallbackComplete(pTd, pSdIoctl);
            break;

        case IOCTL_TS_STACK_QUERY_REMOTEADDRESS:
            Status = StackQueryRemoteAddress( pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_LOCALADDRESS:
            Status = StackQueryLocalAddress(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_STATE :
        case IOCTL_ICA_STACK_SET_STATE :
        case IOCTL_ICA_STACK_ENABLE_DRIVER :
        case IOCTL_ICA_STACK_CONNECTION_QUERY :
            Status = STATUS_SUCCESS;
            break;

        case IOCTL_ICA_STACK_SET_BROKENREASON:
            Status = StackSetBrokenReason(pTd, pSdIoctl);
            break;

        default:
            Status = DeviceIoctl(pTd, pSdIoctl);
            break;
    }

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdIoctl(0x%08x): Status=0x%08x\n",
            pSdIoctl->IoControlCode, Status));

    return Status;
}


/*******************************************************************************
 *  _TdWriteCompleteRoutine
 *
 *    This routine is called at DPC level by the lower level device
 *    driver when an IRP corresponding to an outbuf is completed.
 *
 *    DeviceObject (input)
 *       not used
 *    pIrp (input)
 *       pointer to IRP that is complete
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding outbuf.
 ******************************************************************************/
NTSTATUS _TdWriteCompleteRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context)
{
    POUTBUF pOutBuf = (POUTBUF)Context;
    PTD pTd = (PTD)pOutBuf->pPrivate;
    PLIST_ENTRY pWorkItem;
    KIRQL oldIrql;

    // To prevent the OutBuf associated IRP from being canceled by
    // DeviceCancelIo between queuing the PASSIVE_LEVEL work item below
    // and the actual processing, set the completed flag.
    pOutBuf->fIrpCompleted = TRUE;

    /*
     * Unqueue one of the pre-allocated workitems and use it
     * to queue the completion worker.
     */

    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
    ASSERT(!IsListEmpty(&pTd->WorkItemHead));
    pWorkItem = pTd->WorkItemHead.Flink;
    RemoveEntryList(pWorkItem);
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * Queue the outbuf completion processing to a worker thread
     * since we are not in the correct context to do it here.
     */
    IcaQueueWorkItemEx( pTd->pContext, _TdWriteCompleteWorker, Context,
                      ICALOCK_DRIVER, pWorkItem );

    /*
     * We return STATUS_MORE_PROCESS_REQUIRED so that no further
     * processing for this IRP is done by the I/O completion routine.
     */
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*******************************************************************************
 *  _TdWriteCompleteWorker
 *
 *    This routine is called by an ExWorker thread to complete processing
 *    on an outbuf.  We will release the outbuf and trigger the syncwrite
 *    event if anyone is waiting.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding outbuf.
 ******************************************************************************/
void _TdWriteCompleteWorker(IN PTD pTd, IN PVOID Context)
{
    POUTBUF pOutBuf = (POUTBUF)Context;
    PIRP pIrp = pOutBuf->pIrp;
    NTSTATUS Status;
    
    TRACE(( pTd->pContext, TC_TD, TT_API3, "_TdWriteCompleteWorker: %08x\n", pOutBuf ));

    /*
     * Unlink outbuf from busy list
     */
    RemoveEntryList( &pOutBuf->Links );
    InitializeListHead( &pOutBuf->Links );

    //
    // Check to see whether any pages need to be unlocked.
    //
    if (pIrp->MdlAddress != NULL) {
        PMDL mdl, thisMdl;

        // Unlock any pages that may be described by MDLs.
        mdl = pIrp->MdlAddress;
        while (mdl != NULL) {
            thisMdl = mdl;
            mdl = mdl->Next;
            if (thisMdl == pOutBuf->pMdl)
                continue;

            MmUnlockPages( thisMdl );
            IoFreeMdl( thisMdl );
        }
    }

    /*
     * Any MDL we set in DeviceInitializeWrite() is part of the OUTBUF.
     */
    pIrp->MdlAddress = NULL;

    // Check for IRP cancellation and success.
    if (!pIrp->Cancel && NT_SUCCESS(pIrp->IoStatus.Status)) {
        // Clear the consecutive error count and complete the outbuf by
        // calling OutBufFree.
        pTd->WriteErrorCount = 0;
        OutBufFree(pTd, pOutBuf);
    }
    else {
        // If IRP was cancelled or completed with a failure status,
        // then increment the error counts and call OutBufError.
        if (pIrp->Cancel)
            pTd->LastError = (ULONG)STATUS_CANCELLED;
        else
            pTd->LastError = pIrp->IoStatus.Status;
        pTd->WriteErrorCount++;
        pTd->pStatus->Output.TdErrors++;
        OutBufError(pTd, pOutBuf);
    }

    /*
     * If there is a waiter in TdSyncWrite and the outbuf busy list
     * is now empty, then satisfy the wait now.
     */
    if (pTd->fSyncWriteWaiter && IsListEmpty(&pTd->IoBusyOutBuf)) {
        pTd->fSyncWriteWaiter = FALSE;
        KeSetEvent(&pTd->SyncWriteEvent, 1, FALSE);
    }
}


NTSTATUS _OpenRegKey(PHANDLE HandlePtr, PWCHAR KeyName)
/*++
    Opens a Registry key and returns a handle to it.

Arguments:
    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);
    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes, &UKeyName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    return ZwOpenKey(HandlePtr, KEY_READ, &ObjectAttributes);
}


NTSTATUS _GetRegDWORDValue(HANDLE KeyHandle, PWCHAR ValueName, PULONG ValueData)
/*++
    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.
--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
#define WORK_BUFFER_SIZE 512
    UCHAR                       keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING              UValueName;

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));

    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);
    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


NTSTATUS _GetRegStringValue(
        HANDLE                         KeyHandle,
        PWCHAR                         ValueName,
        PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
        PUSHORT                        ValueSize)
/*++
    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.
--*/
{
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                 KeyHandle,
                 &UValueName,
                 KeyValuePartialInformation,
                 *ValueData,
                 (ULONG) *ValueSize,
                 &resultLength);
    if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
        PVOID temp;

        // Free the old buffer and allocate a new one of the
        // appropriate size.
        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {
            status = MemoryAllocate(resultLength, &temp);
            if (status != STATUS_SUCCESS)
                return status;

            if (*ValueData != NULL)
                MemoryFree(*ValueData);

            *ValueData = temp;
            *ValueSize = (USHORT) resultLength;

            status = ZwQueryValueKey(KeyHandle,
                                     &UValueName,
                                     KeyValuePartialInformation,
                                     *ValueData,
                                     *ValueSize,
                                     &resultLength);

            ASSERT((status != STATUS_BUFFER_OVERFLOW) &&
                    (status != STATUS_BUFFER_TOO_SMALL));
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return status;
}


NTSTATUS _GetRegMultiSZValue(
        HANDLE           KeyHandle,
        PWCHAR           ValueName,
        PUNICODE_STRING  ValueData)

/*++
    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.
--*/

{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = _GetRegStringValue(
                 KeyHandle,
                 ValueName,
                 (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
                 &(ValueData->MaximumLength));

    if (NT_SUCCESS(status)) {
        keyValuePartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION)ValueData->Buffer;
        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {
            ValueData->Length = (USHORT)
                    keyValuePartialInformation->DataLength;
            RtlCopyMemory(
                    ValueData->Buffer,
                    &(keyValuePartialInformation->Data),
                    ValueData->Length);
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;
}


NTSTATUS _GetRegSZValue(
        HANDLE           KeyHandle,
        PWCHAR           ValueName,
        PUNICODE_STRING  ValueData,
        PULONG           ValueType)

/*++
    Reads a REG_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.
    ValueType  - On return, contains the Registry type of the value read.
--*/

{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = _GetRegStringValue(
            KeyHandle,
            ValueName,
            (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
            &(ValueData->MaximumLength));
    if (NT_SUCCESS(status)) {
        keyValuePartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION)ValueData->Buffer;
        if ((keyValuePartialInformation->Type == REG_SZ) ||
                (keyValuePartialInformation->Type == REG_EXPAND_SZ)) {
            WCHAR *src;
            WCHAR *dst;
            ULONG dataLength;

            *ValueType = keyValuePartialInformation->Type;
            dataLength = keyValuePartialInformation->DataLength;

            ASSERT(dataLength <= ValueData->MaximumLength);

            dst = ValueData->Buffer;
            src = (PWCHAR) &(keyValuePartialInformation->Data);

            while (ValueData->Length <= dataLength) {
                if ((*dst++ = *src++) == UNICODE_NULL)
                    break;
                ValueData->Length += sizeof(WCHAR);
            }

            if (ValueData->Length < (ValueData->MaximumLength - 1)) {
                ValueData->Buffer[ValueData->Length / sizeof(WCHAR)] =
                        UNICODE_NULL;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;
}


PWCHAR _EnumRegMultiSz(
        IN PWCHAR   MszString,
        IN ULONG    MszStringLength,
        IN ULONG    StringIndex)
/*++
     Parses a REG_MULTI_SZ string and returns the specified substring.

 Arguments:
    MszString        - A pointer to the REG_MULTI_SZ string.
    MszStringLength  - The length of the REG_MULTI_SZ string, including the
                       terminating null character.
    StringIndex      - Index number of the substring to return. Specifiying
                       index 0 retrieves the first substring.

 Return Value:
    A pointer to the specified substring.

 Notes:
    This code is called at raised IRQL. It is not pageable.

--*/
{
    PWCHAR string = MszString;

    if (MszStringLength < (2 * sizeof(WCHAR)))
        return NULL;

    // Find the start of the desired string.
    while (StringIndex) {
        while (MszStringLength >= sizeof(WCHAR)) {
            MszStringLength -= sizeof(WCHAR);

            if (*string++ == UNICODE_NULL)
                break;
        }

        // Check for index out of range.
        if (MszStringLength < (2 * sizeof(UNICODE_NULL)))
            return NULL;

        StringIndex--;
    }

    if (MszStringLength < (2 * sizeof(UNICODE_NULL)))
        return NULL;

    return string;
}


VOID GetGUID(
        OUT PUNICODE_STRING szGuid,
        IN  int Lana)
/*++
    Enumerates through the guid table setup from TSConfig tool
    
Arguments:
    szGuid - This is an out param containing the guid in this format '{ ... }'
    Lana   - The id to confirm the one to one association

Return Value:
    VOID -- _TcpGetTransportAddress will fail if szGuid is invalid
--*/
{
    // open guidtable key
    HANDLE hKey;
    UNICODE_STRING TempString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;

    status = _OpenRegKey(&hKey, REG_GUID_TABLE);
    if (NT_SUCCESS(status)) {
        // enumerate this key
        ULONG ulByteRead = 0;
        ULONG Index = 0;
        ULONG ulLana = 0;
        HANDLE hSubKey;
        PKEY_BASIC_INFORMATION pKeyBasicInformation = NULL;
        BYTE buffer[ 512 ]; // work space

        pKeyBasicInformation = (PKEY_BASIC_INFORMATION)buffer;
        RtlZeroMemory(pKeyBasicInformation, sizeof(buffer));
        do {
            status = ZwEnumerateKey( 
                    hKey,
                    Index,
                    KeyBasicInformation,
                    (PVOID)pKeyBasicInformation,
                    sizeof(buffer),
                    &ulByteRead);
            KdPrint(("TDTCP: GetGUID ZwEnumerateKey returned 0x%x\n", status));

            if (status != STATUS_SUCCESS)
                break;

            // extract unicode name            
            TempString.Length = (USHORT) pKeyBasicInformation->NameLength;
            TempString.MaximumLength = (USHORT) pKeyBasicInformation->NameLength;
            TempString.Buffer = pKeyBasicInformation->Name;
            RtlZeroMemory( &ObjectAttributes , sizeof( OBJECT_ATTRIBUTES ) );
            InitializeObjectAttributes(
                    &ObjectAttributes,
                    &TempString,
                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                    hKey,
                    NULL);
            
            status = ZwOpenKey(&hSubKey, KEY_READ, &ObjectAttributes);
            if (NT_SUCCESS(status)) {
                status = _GetRegDWORDValue(hSubKey, LANA_ID, &ulLana);
                ZwClose(hSubKey);
                if (NT_SUCCESS(status)) {
                    if (Lana == (int)ulLana) {
                        KdPrint(("TDTCP:GetGUID We've found a Lana %d\n", ulLana));

                        status = MemoryAllocate(TempString.Length +
                                sizeof(WCHAR), &szGuid->Buffer);
                        if (NT_SUCCESS(status)) {
                            szGuid->MaximumLength = TempString.Length +
                                    sizeof(WCHAR);
                            RtlZeroMemory(szGuid->Buffer, szGuid->MaximumLength);
                            RtlCopyUnicodeString(szGuid, &TempString);
                            break;
                        }
                    }
                }
            }

            Index++;            

        } while (TRUE);

        ZwClose(hKey);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\inc\td.h ===
/***************************************************************************
*
*  TD.H
*
*  This module contains Transport Driver defines and structures 
*
*  Copyright Microsoft, 1998
*
*  
****************************************************************************/

/*
 *  Maximum number of zero byte reads before we will drop the client connection
 */
#define MAXIMUM_ZERO_BYTE_READS 100

/*
 *  TD error message structure
 */
typedef struct _TDERRORMESSAGE {
    ULONG Error;
    char * pMessage;
} TDERRORMESSAGE, * PTDERRORMESSAGE;

/*
 *  TD structure
 */
typedef struct _TD {

    PSDCONTEXT pContext;      

    ULONG PdFlag;               // pd flags (PD_?)
    SDCLASS SdClass;            // class of sd (PdAsync, PdReli, ...)
    PDPARAMS Params;            // pd parameters
    PCLIENTMODULES pClient;     // pointer to winstation client data structure
    PPROTOCOLSTATUS pStatus;    // pointer to winstation status structure

    PFILE_OBJECT pFileObject;   // file object for transport I/O
    PDEVICE_OBJECT pDeviceObject; // device object for transport I/O

    ULONG LastError;            // error code of last protocol error
    ULONG ReadErrorCount;       // count of consecutive read errors
    ULONG ReadErrorThreshold;   // max allowed consecutive read errors
    ULONG WriteErrorCount;      // count of consecutive write errors
    ULONG WriteErrorThreshold;  // max allowed consecutive write errors
    ULONG ZeroByteReadCount;    // count of consecutive zero byte reads

    ULONG PortNumber;           // network listen port number 

    ULONG OutBufHeader;         // number of reserved header bytes for this td
    ULONG OutBufTrailer;        // number of reserved trailer bytes for this td
    ULONG OutBufLength;         // length of input/output buffers

    LIST_ENTRY IoBusyOutBuf;    // pointer to i/o busy outbufs
    KEVENT SyncWriteEvent;      // event waited on by SyncWrite

    PKTHREAD pInputThread;      // input thread pointer
    LONG InBufCount;            // count of INBUFs to allocate
    KSPIN_LOCK InBufListLock;   // spinlock to protect INBUF Busy/Done lists
    LIST_ENTRY InBufBusyHead;   // list of busy INBUFs (waiting for input)
    LIST_ENTRY InBufDoneHead;   // list of completed INBUFs (with input data)
    ULONG InBufHeader;          // number of reserved header bytes for this td
    KEVENT InputEvent;          // input event

    ULONG fClosing: 1;          // stack driver is closing
    ULONG fCallbackInProgress: 1; // modem callback in progress
    ULONG fSyncWriteWaiter: 1;  // there is a waiter in SyncWrite

    PVOID pPrivate;             // pointer to private pd data 
    PVOID pAfd;                 // pointer to private afd data 
    LIST_ENTRY WorkItemHead;    // preallocated workitem list.

    PDEVICE_OBJECT pSelfDeviceObject;// device object for this driver

    ULONG UserBrokenReason;     // broken reason sent down from the user

} TD, * PTD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdicom\tdilib.c ===
/*************************************************************************
* tdlib.c
*
* TDI library functions.
*
* Copyright 1998 Microsoft
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>

#include "tdtdi.h"

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>

#include <td.h>


#define _TDI_POLL_TIMEOUT       (30 * 1000) // 30 seconds
#define _TDI_CONNECT_TIMEOUT    45
#define _TDI_DISCONNECT_TIMEOUT 60

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * To use TDI:
 *
 * To connect to a remote server:
 *
 *    Create Address EndPoint
 *
 *    Create Connection Object
 *
 *    Associate the Address EndPoint with the Connection Object
 *
 *    Do a Connect
 *
 * To receive connections:
 *
 *    Create Address EndPoint
 *
 *    Create Connection Object
 *
 *    Associate the Address EndPoint with the Connection Object
 *
 *    Listen for a connection.
 *
 *    Return connection
 */



/*
 * Global data
 */

//
//  Wait for xx seconds before polling on thread deletion.
//

ULONG
_TdiPollTimeout = _TDI_POLL_TIMEOUT;

/*
 * Forward references
 */

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTSTATUS
_TdiRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    );

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
_TdiSubmitRequest (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN bKeepLock
    );

/*
 * External references
 */
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );

BOOLEAN
PsIsThreadTerminating(
    IN PETHREAD Thread
    );


/*
 * Functions
 */

NTSTATUS
_TdiCreateAddress (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           TdiAddress,
    IN ULONG           TdiAddressLength,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EABuffer;
    PDEVICE_OBJECT DeviceObject;
    HANDLE         TdiHandle  = NULL;
    PFILE_OBJECT   FileObject = NULL;

    /*
     * The TDI interfaces uses an EA of name "TdiTransportName"
     * to specify the structure TA_ADDRESS.
     */
    Status = MemoryAllocate( (sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                    TdiAddressLength), &EABuffer);

    if ( !NT_SUCCESS(Status) ) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EABuffer->NextEntryOffset = 0;
    EABuffer->Flags = 0;
    EABuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EABuffer->EaValueLength = (USHORT)TdiAddressLength;

    // Copy in the EA name
    RtlCopyMemory(EABuffer->EaName, TdiTransportAddress, EABuffer->EaNameLength+1);

    // Copy the TA_ADDRESS parameter
    RtlCopyMemory(&EABuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH+1], TdiAddress,
                                    EABuffer->EaValueLength);

    TRACE0(("TdiCreateAddress Create endpoint of %wZ\n",pTransportName));

    InitializeObjectAttributes (
        &AddressAttributes,
        pTransportName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE ,
        NULL,           // RootDirectory
        NULL            // SecurityDescriptor
        );

    Status = ZwCreateFile(
                 &TdiHandle, // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &AddressAttributes, // Object Attributes
                 &IoStatusBlock, // Final I/O status block
                 NULL,           // Allocation Size
                 FILE_ATTRIBUTE_NORMAL, // Normal attributes
                 0,             // Sharing attributes
                 FILE_OPEN_IF,  // Create disposition
                 0,             // CreateOptions
                 EABuffer,      // EA Buffer
                 FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) +
                 TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                 TdiAddressLength // EA length
                 );

    MemoryFree(EABuffer);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x from function\n",Status));
        return( Status );
    }

    if (!NT_SUCCESS(Status = IoStatusBlock.Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x from Iosb\n",Status));
        return( Status );
    }

    //
    //  Obtain a referenced pointer to the file object.
    //
    Status = ObReferenceObjectByHandle (
                                TdiHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&FileObject,
                                NULL
                                );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x Referencing FileObject\n",Status));
        goto error_cleanup;

    }


    //
    //  Get the address of the device object for the endpoint.
    //

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    // Copy the out parameters
    *pHandle = TdiHandle;
    *ppFileObject = FileObject;
    *ppDeviceObject = DeviceObject;

    return STATUS_SUCCESS;

error_cleanup:

    if ( FileObject != NULL ) {
        ObDereferenceObject( FileObject );
    }

    if ( TdiHandle != NULL ) {
        ZwClose( TdiHandle );
    }

    return Status;
}

NTSTATUS
_TdiOpenConnection (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           ConnectionContext,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EABuffer;
    CONNECTION_CONTEXT UNALIGNED *ContextPointer;
    PDEVICE_OBJECT DeviceObject;
    HANDLE ConnHandle = NULL;
    PFILE_OBJECT FileObject = NULL;

    Status = MemoryAllocate( (sizeof(FILE_FULL_EA_INFORMATION)-1 +
                              TDI_CONNECTION_CONTEXT_LENGTH+1 +
                              sizeof(CONNECTION_CONTEXT)), &EABuffer);

    if( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    EABuffer->NextEntryOffset = 0;
    EABuffer->Flags = 0;
    EABuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EABuffer->EaValueLength = sizeof(CONNECTION_CONTEXT);

    // Copy in the EA name
    RtlCopyMemory(EABuffer->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH+1);

    // Copy in the EA data
    ContextPointer =
        (CONNECTION_CONTEXT UNALIGNED *)&EABuffer->EaName[TDI_CONNECTION_CONTEXT_LENGTH+1];
    *ContextPointer = ConnectionContext;

    TRACE0(("_TdiOpenConnection: Create connection object on transport %wZ\n",pTransportName));

    InitializeObjectAttributes (&AddressAttributes,
                                    pTransportName, // Name
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE ,   // Attributes
                                    NULL,                   // RootDirectory
                                    NULL);                  // SecurityDescriptor

    Status = ZwCreateFile(&ConnHandle,               // Handle
                          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                          &AddressAttributes, // Object Attributes
                          &IoStatusBlock, // Final I/O status block
                          NULL,           // Allocation Size
                          FILE_ATTRIBUTE_NORMAL, // Normal attributes
                          FILE_SHARE_READ | FILE_SHARE_WRITE, // Sharing attributes
                          FILE_OPEN_IF,   // Create disposition
                          0,              // CreateOptions
                          EABuffer,       // EA Buffer
                          sizeof(FILE_FULL_EA_INFORMATION) +
                            TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                            sizeof(CONNECTION_CONTEXT));


    MemoryFree(EABuffer);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error 0x%x Creating Connection object\n",Status));
        return(Status);
    }

    Status = IoStatusBlock.Status;
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error 0x%x Creating Connection object in Iosb\n",Status));
        return(Status);
    }

    TRACE0(("_TdiOpenConnection: Returning connection handle %lx\n", ConnHandle));


    //
    //  Obtain a referenced pointer to the file object.
    //
    Status = ObReferenceObjectByHandle (
                                ConnHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&FileObject,
                                NULL
                                );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error Status 0x%x Referencing FileObject\n",Status));
        ZwClose( ConnHandle );
        return(Status);
    }



    //
    //  Get the address of the device object for the endpoint.
    //

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    // Copy the out parameters
    *pHandle        = ConnHandle;
    *ppFileObject   = FileObject;
    *ppDeviceObject = DeviceObject;

    return(Status);
}

NTSTATUS
_TdiListen(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    TdiBuildListen(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        0,           // Flags
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, FALSE);

    TRACE0(("_TdiListen: Status 0x%x\n",Status));

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiAccept(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    TdiBuildAccept(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, FALSE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiConnect(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PLARGE_INTEGER pTimeout OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN ULONG              RemoteTransportAddressLength,
    IN PTRANSPORT_ADDRESS pRemoteTransportAddress
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;


    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    RequestInfo.RemoteAddressLength = RemoteTransportAddressLength;
    RequestInfo.RemoteAddress = pRemoteTransportAddress;


    TdiBuildConnect(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pTimeout,
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, TRUE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiAssociateAddress(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN HANDLE         AddressHandle,
    IN PDEVICE_OBJECT AddressDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, AddressDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    TdiBuildAssociateAddress(
        Irp,
        AddressDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        AddressHandle
        );

    Status = _TdiSubmitRequest(pTd, AddressDeviceObject, Irp, FALSE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiDisconnect(
    IN PTD pTd,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    PIRP Irp;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
    if (Irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    TdiBuildDisconnect(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        0,
        TDI_DISCONNECT_ABORT,
        NULL,
        NULL
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, TRUE);

    IoFreeIrp( Irp );

    return(Status);
}

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )
/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID EventContext - Supplies the context for the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    Irp = _TdiAllocateIrp( FileObject, NULL );

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, EventContext);

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeIrp( Irp );

    return Status;
}

NTSTATUS
_TdiSubmitRequest (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN bKeepLock
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    NTSTATUS Status;
    PKEVENT  Event;

    Status = MemoryAllocate( sizeof(KEVENT), &Event );
    if( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    KeInitializeEvent (Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, _TdiRequestComplete, Event, TRUE, TRUE, TRUE);

    //
    //  Submit the request
    //

    Status = IoCallDriver(DeviceObject, Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiSubmitRequest: submit request.  Status = %X", Status));
        MemoryFree( Event );
        return Status;
    }

    if (Status == STATUS_PENDING) {

        TRACE0(("TDI request issued, waiting..."));

        do {

            //
            //  Wait for a couple of seconds for the request to complete
            //
            //  If it times out, and the thread is terminating, cancel the
            //  request and unwind that way.
            //

            if ( !bKeepLock ) {
                Status = IcaWaitForSingleObject(
                             pTd->pContext,
                             Event,
                             _TdiPollTimeout
                             );
            } else {
                LARGE_INTEGER WaitTimeout;
                PLARGE_INTEGER pWaitTimeout = NULL;

                WaitTimeout = RtlEnlargedIntegerMultiply( _TdiPollTimeout, -10000 );
                pWaitTimeout = &WaitTimeout;
                
                Status = KeWaitForSingleObject(
                             Event,
                             UserRequest,
                             UserMode,
                             FALSE,
                             pWaitTimeout 
                             );
            }

            TRACE0(("_TdiSubmitRequest: Status 0x%x from IcaWaitForSingleObject\n",Status));

            //
            //  If we timed out the wait, and the thread is terminating,
            //  give up and cancel the IRP.
            //

            if ( (Status == STATUS_TIMEOUT)

                   &&

                 ARGUMENT_PRESENT(Irp)

                   &&

                 PsIsThreadTerminating( Irp->Tail.Overlay.Thread ) ) {

                //
                //  Ask the I/O system to cancel this IRP.  This will cause
                //  everything to unwind properly.
                //
                DBGPRINT(("_TdiSubmitRequest: Irp being canceled\n"));

                IoCancelIrp(Irp);
            }

        } while (  Status == STATUS_TIMEOUT );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("Could not wait for connection to complete\n"));
            MemoryFree( Event );
            return Status;
        }

        Status = Irp->IoStatus.Status;
    }

    TRACE0(("TDI request complete Status 0x%x\n",Status));

    MemoryFree( Event );

    return(Status);
}

NTSTATUS
_TdiRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    )

/*++

Routine Description:

    Completion routine for _TdiRequestSubmit operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(DeviceObject);

    TRACE0(("_TdiRequestComplete: Context %lx\n", Ctx));

    //
    //  Set the event to the Signalled state with 0 priority increment and
    //  indicate that we will not be blocking soon.
    //

    KeSetEvent((PKEVENT) Ctx, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )
/*++

Routine Description:

    This function allocates and builds an I/O request packet.

Arguments:

    FileObject - Supplies a pointer to the file object for which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The redir accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    DeviceObject - Supplies a pointer to a device object to direct this
        request to.  If this is not supplied, it uses the file object to
        determine the device object.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.

--*/

{
    PIRP Irp;

    if (ARGUMENT_PRESENT(DeviceObject)) {
        Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    } else {
        Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);
    }

    if (Irp == NULL) {
        return(NULL);
    }

    Irp->Tail.Overlay.OriginalFileObject = FileObject;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    Irp->RequestorMode = KernelMode;

    return Irp;
}

NTSTATUS
_TdiReceiveDatagram(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN ULONG RecvFlags,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pReturnLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL;
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL;

	MemoryAllocate( sizeof( *pRequestInfo), &pRequestInfo);
    MemoryAllocate( sizeof( *pReturnInfo), &pReturnInfo);
 
	if ((!pRequestInfo) || (!pReturnInfo)) {
		if (pRequestInfo) MemoryFree( pRequestInfo);
        if (pReturnInfo) MemoryFree( pReturnInfo);
        return( STATUS_INSUFFICIENT_RESOURCES);
    }
 
    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( pRequestInfo, sizeof( *pRequestInfo) );
    RtlZeroMemory( pReturnInfo,  sizeof( *pReturnInfo) );

    // Copy in info to return remote address
    pReturnInfo->RemoteAddress = pRemoteAddress;
    pReturnInfo->RemoteAddressLength = RemoteAddressLength;

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pBuffer,
               BufferLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        MemoryFree( pRequestInfo);
        MemoryFree( pReturnInfo);

        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildReceiveDatagram(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pMdl,        // Mdl address
        BufferLength,
        pRequestInfo,
        pReturnInfo,
        RecvFlags    // InFlags
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if ( NT_SUCCESS(Status) ) {
        // Packet length returned is in the Iosb
        *pReturnLength = (ULONG)Irp->IoStatus.Information;
        TRACE0(("_TdiReceiveDatagram: Irp DataLength 0x%x UserDataLength 0x%x, "
        "OptionsLength 0x%x, RemoteAddressLength 0x%x\n", *pReturnLength,
        ReturnInfo.UserDataLength, ReturnInfo.OptionsLength,
        ReturnInfo.RemoteAddressLength));
    }

	MemoryFree( pRequestInfo);
    MemoryFree( pReturnInfo);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiSendDatagram(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN PVOID pBuffer,
    IN ULONG BufferLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION SendInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &SendInfo, sizeof(SendInfo) );

    // We must fill in our destination address
    SendInfo.RemoteAddress = pRemoteAddress;
    SendInfo.RemoteAddressLength = RemoteAddressLength;

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pBuffer,
               BufferLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildSendDatagram(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pMdl,        // Mdl address
        BufferLength,
        &SendInfo
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiQueryAddressInfo(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTDI_ADDRESS_INFO pAddressInfo,
    IN ULONG AddressInfoLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pAddressInfo,
               AddressInfoLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildQueryInformation(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        TDI_QUERY_ADDRESS_INFO,
        pMdl
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdicom\tdtdi.c ===
/****************************************************************************/
// tdtdi.c
//
// Common code for all TDI based Transport Drivers
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>

#include "tdtdi.h"

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>

#include <td.h>
#include <tdi.h>


#define TDTDI_LISTEN_QUEUE_DEPTH 5  // This was hardcoded in afdcom

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#if DBG
ULONG DbgPrint(PCH Format, ...);
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define DBGENTER(x) DbgPrint x
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)
#else
#define DBGENTER(x)
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define DBGENTER(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*

   DOCUMENT THIS INTERFACE FINALLY! 

   This is the best I can dig out of these existing interfaces.

   Common Sequences:

   Startup and Listen - DeviceOpen, DeviceCreateEndpoint, DeviceConnectionWait

    DeviceConnectionWait returns an internal handle to represent the connection
    it has listened for, accepted, and returned. This handle is useless for any
    operations, and is only good for feeding to DeviceOpenEndpoint to get
    an endpoint that can be used for communications.

   Connect - DeviceOpen, DeviceOpenEndpoint

    A DeviceOpen is done to create a new endpoint, then its handle
    from DeviceConnectionWait is "inserted" into the empty endpoint.
    We now have a real, live connection

   Disconnect From Client - DeviceCancelIo

   Disconnect From disconn command - DeviceCloseEndpoint?, DeviceCancelIo?

   Reconnect - DeviceCancelIo, DeviceClose, DeviceOpen, DeviceOpenEndpoint

    Once the user has fully logged onto a new connected WinStation, a
    DeviceCancelIo and then a DeviceClose is issued to release the
    new logged on WinStation from the connection. While this connection
    remains up, a new DeviceOpen and DeviceOpenEndpoint is done to
    connect this connection to the users previously disconnected WinStation.

NTSTATUS DeviceOpen( PTD, PSD_OPEN );

   Open and initialize private data structures. Calls the TdiDeviceOpen(), but
   this is a no-op.


NTSTATUS DeviceClose( PTD, PSD_CLOSE );

   Close the transport driver. If its an address endpoint,
   it will destroy it. If its a connection endpoint, it
   DOES not destroy it. 

   If the connection endpoint is destroyed, disconnect/reconnect
   will be broken.

   Calls TdiDeviceClose(), which is another no-op.


NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );

   Creates and Address endpoint that can be used for listening.

   This does not create any connection endpoints.

NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );

   Takes an existing connection endpoint handle, and makes
   an "endpoint" out of it.

   This is used by disconnect/reconnect.


NTSTATUS DeviceCloseEndpoint( PTD );

   This closes the endpoint.

   If its a connection endpoint, it is destroyed.


NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );

   This waits for connections to come in, and returns connected
   endpoints in the pIcaEndpoint structure.


NTSTATUS DeviceCancelIo( PTD );

   This asks for all I/O on the given endpoint to be canceled.

   With TDI, we can not actually cancel I/O, but must hold IRP's
   until indication handlers tell us to submit. This is because canceling
   I/O on a TDI connection causes the TDI provider to kill the connection.

NTSTATUS DeviceConnectionSend( PTD );

    This names sounds like send TD specific data to the host.

    This does not actually send anything, but fills in
    a structure for the upper level who may actually send it
    at some time.


NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );

    This is used by shadow to act as a network client and
    initiate a connection. This is obsolete and not used since
    a named pipe TD will handle all shadow traffic.

NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
*/


/*
 * Context used for connect accept
 */
typedef struct _ACCEPT_CONTEXT {
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint;

    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;
} ACCEPT_CONTEXT, *PACCEPT_CONTEXT;

/*=============================================================================
==   External Functions Defined
=============================================================================*/

// These are the functions our TD supplies to ICADD
NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS DeviceQueryRemoteAddress( PTD, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS DeviceQueryLocalAddress( PTD, PVOID, ULONG, PULONG );



/*=============================================================================
==   External Functions Referenced
=============================================================================*/

// These functions are provided by the protocol specific TD module
NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceQueryLocalAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );

// These are functions in our support libraries

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );

// Tdilib functions

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTSTATUS
_TdiCreateAddress (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           TdiAddress,
    IN ULONG           TdiAddressLength,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    );

NTSTATUS
_TdiOpenConnection (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           ConnectionContext,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    );

NTSTATUS
_TdiListen(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
_TdiConnect(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PLARGE_INTEGER pTimeout OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN ULONG              RemoteTransportAddressLength,
    IN PTRANSPORT_ADDRESS pRemoteTransportAddress
    );

NTSTATUS
_TdiAssociateAddress(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN HANDLE         AddressHandle,
    IN PDEVICE_OBJECT AddressDeviceObject
    );

NTSTATUS
_TdiDisconnect(
    IN PTD pTd,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
_TdiQueryAddressInfo(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTDI_ADDRESS_INFO pAddressInfo,
    IN ULONG AddressInfoLength
    );

NTSTATUS
_TdCancelReceiveQueue(
    PTD          pTd,
    PTD_ENDPOINT pEndpoint,
    NTSTATUS     CancelStatus
    );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdCreateEndpointStruct( PTD, PUNICODE_STRING, PTD_ENDPOINT *, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS _TdCloseEndpoint( PTD, PTD_ENDPOINT );

NTSTATUS
_TdConnectHandler(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
_TdDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
_TdReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
_TdAcceptComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
_TdCreateConnectionObject(
    IN  PTD pTd,
    IN  PUNICODE_STRING pTransportName,
    OUT PTD_ENDPOINT *ppEndpoint,
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG TransportAddressLength
    );

NTSTATUS
_TdWaitForDatagramConnection(
    IN PTD pTd,
    IN PTD_ENDPOINT pAddressEndpoint,
    OUT PTD_ENDPOINT *ppConnectionEndpoint
    );

/*
 * Global Data
 */

extern USHORT TdiDeviceEndpointType; // Datagram or stream set by TD
extern USHORT TdiDeviceAddressType;  // TDI address format by TD
extern USHORT TdiDeviceInBufHeader;  // Bytes of header set by TD (0 for stream)


/*******************************************************************************
 * DeviceOpen
 *
 * Allocate and initialize private data structures
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS DeviceOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;

    DBGENTER(("DeviceOpen: PTD 0x%x\n",pTd));

    /*
     *  Set protocol driver class
     */
    pTd->SdClass = SdNetwork;
    pTd->InBufHeader = TdiDeviceInBufHeader; // For packet oriented protocols

    /*
     *  Return size of header and trailer
     */
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /*
     *  Allocate TDI TD data structure
     */
    Status = MemoryAllocate( sizeof(*pTdTdi), &pTdTdi );
    if ( !NT_SUCCESS(Status) ) 
        goto badalloc;

    ASSERT( pTd->pAfd == NULL );

    pTd->pAfd = pTdTdi;

    /*
     *  Initialize TDTDI data structure
     */
    RtlZeroMemory( pTdTdi, sizeof(*pTdTdi) );

    /*
     * Some protocols will make decisions on lower level
     * flow control depending on this value.
     */
    pTdTdi->OutBufDelay = pSdOpen->PdConfig.Create.OutBufDelay;

    /*
     *  Open device
     */
    Status = TdiDeviceOpen( pTd, pSdOpen );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE0(("DeviceOpen: Context 0x%x\n",pTd->pAfd));

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  open failed
     */
badopen:
    MemoryFree( pTd->pAfd );
    pTd->pAfd = NULL;

    /*
     *  allocate failed
     */
badalloc:
    return Status;
}


/*******************************************************************************
 * DeviceClose
 *
 * Close transport driver
 * NOTE: this must not close the current connection endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 ******************************************************************************/
NTSTATUS DeviceClose(PTD pTd, PSD_CLOSE pSdClose)
{
    PTDTDI pTdTdi;
    PTD_ENDPOINT pEndpoint;

    DBGENTER(("DeviceClose: PTD 0x%x Context 0x%x\n",pTd,pTd->pAfd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Close address endpoint if we have one
     */
    if (pTdTdi != NULL) {
        if ( pEndpoint = pTdTdi->pAddressEndpoint ) {
            TRACE0(("DeviceClose: Closing AddressEndpoint 0x%x\n",pTdTdi->pAddressEndpoint));
            pTdTdi->pAddressEndpoint = NULL;
            _TdCloseEndpoint( pTd, pEndpoint );
        }
    
    #if DBG
        if( pEndpoint = pTdTdi->pConnectionEndpoint ) {
            ASSERT( IsListEmpty( &pEndpoint->ReceiveQueue) );
            TRACE0(("DeviceClose: Connection Endpoint 0x%x idled\n",pEndpoint));
        }
    #endif
    }

    /*
     *  Close device
     */
    (void)TdiDeviceClose(pTd, pSdClose);

    // TdUnload in td\common will free pTd->pAfd

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceCreateEndpoint
 *
 *  Create a TDI address object. Do not wait for, or make any connections.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLocalAddress (input)
 *       Pointer to local address (or null)
 *    pReturnedAddress (input)
 *       Pointer to location to save returned (created) address (or null)
 ******************************************************************************/
NTSTATUS DeviceCreateEndpoint(
        PTD pTd,
        PICA_STACK_ADDRESS pLocalAddress,
        PICA_STACK_ADDRESS pReturnedAddress)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    ULONG TransportAddressLength;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pTransportAddress = NULL;

    DBGENTER(("DeviceCreateEndpoint: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Build transport device name and address. This is in the TD.
     */
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pLocalAddress,
                                                    &TransportName,
                                                    &pTransportAddress,
                                                    &TransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    /*
     * Create the Endpoint structure.
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &TransportName,
                 &pEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error creating endpointstruct 0x%x\n",Status));
        goto badcreate;
    }

    pEndpoint->EndpointType = TdiAddressObject;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error creating TDI address object 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        goto badcreate;
    }

    if ( pReturnedAddress ) {
        DBGPRINT(("DeviceCreateEndpoint: Address returned Type 0x%x\n",pTransportAddress->Address[0].AddressType));
        RtlCopyMemory( pReturnedAddress,
                       &pTransportAddress->Address[0].AddressType,
                       min( sizeof( *pReturnedAddress ),
                            pEndpoint->TransportAddressLength ) );
    }
    
    /*
     * Save a pointer to the address endpoint
     */
    pTdTdi->pAddressEndpoint = pEndpoint;

    /*
     * Free transport name and address buffers
     */
    MemoryFree( TransportName.Buffer );
    MemoryFree( pTransportAddress );
    
    TRACE0(("DeviceCreateEndPoint: AddressEndpoint 0x%x Created, FO 0x%x DO 0x%x, Handle 0x%x\n",pEndpoint,pEndpoint->pFileObject,pEndpoint->pDeviceObject,pEndpoint->TransportHandle));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badcreate:
    if ( TransportName.Buffer )
        MemoryFree( TransportName.Buffer );
    if ( pTransportAddress )
        MemoryFree( pTransportAddress );

badaddress:
    return( Status );
}


/*******************************************************************************
 * DeviceOpenEndpoint
 *
 *  Causes an existing end point to copy its data into a new one.
 *  The handle is passed in from TermSrv, and was returned to it at one time
 *  from DeviceConnectionWait().
 *  NOTE: TermSrv can call this multiple times with the same handle for
 *        multiple connects/disconnects.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 ******************************************************************************/
NTSTATUS DeviceOpenEndpoint(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG IcaEndpointLength)
{
    PTDTDI pTdTdi;
    PTD_STACK_ENDPOINT pStackEndpoint;
    PVOID Handle;
    ULONG Length;
    NTSTATUS Status;

    DBGENTER(("DeviceOpenEndpoint: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDTDI: DeviceOpenEndpoint, copying existing endpoint\n" ));

    if( IcaEndpointLength < sizeof(PVOID) ) {
        DBGPRINT(("DeviceOpenEndpoint: IcaEndpointLength to small %d\n",IcaEndpointLength));
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    /*
     * Capture the parameter
     */
    try {
        Handle = (*((PVOID *)pIcaEndpoint));
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceOpenEndpoint: Exception 0x%x\n",Status));
        goto done;
    }

    TRACE0(("DeviceOpenEndpoint: Fetching Handle 0x%x\n",Handle));

    /*
     * See if ICADD knows about the handle
     */
    Status = IcaReturnHandle( Handle, &pStackEndpoint, &Length );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceOpenEndpoint: ICADD handle 0x%x no good 0x%x\n",Handle,Status));
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    if( Length != sizeof(TD_STACK_ENDPOINT) ) {
#if DBG
        DBGPRINT(("DeviceOpenEndpoint: Bad TD_STACK_ENDPOINT length %d, sb %d\n",Length,sizeof(TD_STACK_ENDPOINT)));
        DbgBreakPoint(); // Internal corruption
#endif
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    ASSERT( pStackEndpoint->AddressType == TdiDeviceAddressType );
    ASSERT( pStackEndpoint->pEndpoint->hIcaHandle == Handle );

    /*
     * Save endpoint as the current connection endpoint
     */
    pTdTdi->pConnectionEndpoint = pStackEndpoint->pEndpoint;

    ASSERT( IsListEmpty( &pTdTdi->pConnectionEndpoint->ReceiveQueue) );

    TRACE0(("DeviceOpenEndpoint: Returned Endpoint 0x%x\n",pStackEndpoint->pEndpoint));

    /*
     * Save the file/device objects used for I/O in the TD structure
     */
    pTd->pFileObject = pTdTdi->pConnectionEndpoint->pFileObject;
    pTd->pDeviceObject = pTdTdi->pConnectionEndpoint->pDeviceObject;

    TRACE0(("DeviceOpenEndpoint: Connection Endpoint 0x%x opened on Context 0x%x\n",pTdTdi->pConnectionEndpoint,pTd->pAfd));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pTdTdi->pConnectionEndpoint->pFileObject,pTdTdi->pConnectionEndpoint->pDeviceObject,pTdTdi->pConnectionEndpoint->TransportHandle));

    Status = STATUS_SUCCESS;

    if ( NT_SUCCESS(Status) ) {
        Status = TdiDeviceOpenEndpoint( pTd, pIcaEndpoint, IcaEndpointLength );
    }

done:
    return( Status );
}


/*******************************************************************************
 * DeviceCloseEndpoint
 ******************************************************************************/
NTSTATUS DeviceCloseEndpoint(PTD pTd)
{
    ULONG Length;
    KIRQL OldIrql;
    PTDTDI pTdTdi;
    NTSTATUS Status;
    PTD_ENDPOINT pEndpoint;
    PTD_STACK_ENDPOINT pStackEndpoint;

    DBGENTER(("DeviceCloseEndpoint: PTD 0x%x, Context 0x%x\n",pTd,pTd->pAfd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Close connection endpoint if we have one
     * NOTE: The address endpoint, if there is one,
     *       gets closed in the DeviceClose routine.
     */
    if ( pEndpoint = pTdTdi->pConnectionEndpoint ) {

        TRACE0(("DeviceCloseEndpoint: Closing Connection Endpoint 0x%x, on Context 0x%x\n",pEndpoint,pTd->pAfd));
        ASSERT( pEndpoint->EndpointType != TdiAddressObject );

        ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

        pEndpoint->Disconnected = TRUE;

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cancel any pended receives
         */
        _TdCancelReceiveQueue(pTd, pEndpoint, STATUS_LOCAL_DISCONNECT );

        pTd->pFileObject = NULL;
        pTd->pDeviceObject = NULL;
        pTdTdi->pConnectionEndpoint = NULL;

        // If a handle registered with ICADD, close it
        if( pEndpoint->hIcaHandle ) {
            Status = IcaCloseHandle( pEndpoint->hIcaHandle, &pStackEndpoint, &Length );
            if( NT_SUCCESS(Status) ) {
                ASSERT( pStackEndpoint->pEndpoint == pEndpoint );
                /*
                 * Release our context memory
                 */
                MemoryFree( pStackEndpoint );
            }
            else {
                DBGPRINT(("DeviceCloseEndpoint: hIcaDevice 0x%x Invalid!\n",pEndpoint->hIcaHandle));
#if DBG
                DbgBreakPoint();
#endif
            }
        }

        _TdCloseEndpoint( pTd, pEndpoint );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 * DeviceConnectionWait
 *
 *  This function is called in a loop from the upper level. We must create
 *  a connection object, associate it with the address object, listen on it,
 *  and return a single connection to our caller. We are called again for
 *  more connections.
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Points to the actual number of bytes written to pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionWait(
        PTD pTd, 
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PVOID Handle;
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint = NULL;
    PTD_STACK_ENDPOINT pStackEndpoint = NULL;

    DBGENTER(("DeviceConnectionWait: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    if (pTd->fClosing) {
        return STATUS_DEVICE_NOT_READY;
    }

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if ( Length < sizeof(TD_STACK_ENDPOINT) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        DBGPRINT(("DeviceConnectionWait: Output buffer to small\n"));        
        goto done;
    }

    /*
     * Ensure we have a TDI address endpoint already
     */
    if ( (pAddressEndpoint = pTdTdi->pAddressEndpoint) == NULL ) {
        Status = STATUS_DEVICE_NOT_READY;
        DBGPRINT(("DeviceConnectionWait: No TDI address object\n"));        
        goto done;
    }

    /*
     * Different handling for datagram connections
     */
    if (TdiDeviceEndpointType == TdiConnectionDatagram) {
        Status = _TdWaitForDatagramConnection(
                pTd,
                pAddressEndpoint,
                &pConnectionEndpoint);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("DeviceConnectionWait: Error Status 0x%x from "
                    "_TdWaitForDatagramConnection\n", Status));
            return Status;
        }

        goto ConnectAccepted;
    }

    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Data receive indication must be registered on the
     * address endpoint before any data endpoints are created.
     *
     * This is because we can not set receive indication on a
     * dataendpoint, it can only be inherited from its
     * address endpoint.
     */
    if (!pAddressEndpoint->RecvIndicationRegistered) {
        pAddressEndpoint->RecvIndicationRegistered = TRUE;
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Register the receive event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_RECEIVE,
                    (PVOID)_TdReceiveHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );

        pAddressEndpoint->DisconnectIndicationRegistered = TRUE;

            /*
         * Register the disconnect event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_DISCONNECT,
                    (PVOID)_TdDisconnectHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
    }

    /*
     * Everytime into this function, we attempt to create more
     * Connection object's util we have reached TDTDI_LISTEN_QUEUE_DEPTH.
     *
     * These connection objects are linked off of our address endpoint.
     *
     * This is because we can only create connection objects
     * at call level, not at indication level. The indication level
     * will grab connection objects off of the address endpoint,
     * and accept them. It will then set the accept event on the
     * address object. This is optimized for only (1) thread
     * accepting connections, which is the current TD design.
     * Otherwise, thundering herd could occur on the accept event.
     *
     * This function then returns with the accepted connection
     * object. The upper level listen thread will then call
     * this function again to retrieve another connection.
     *
     * This prevents the refusing of connections due to not
     * having any outstanding listen's available when a WinFrame
     * client connect request comes in.
     */

    while (pAddressEndpoint->ConnectionQueueSize <= TDTDI_LISTEN_QUEUE_DEPTH) {

        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        Status = _TdCreateConnectionObject(
                     pTd,
                     &pAddressEndpoint->TransportName,
                     &pConnectionEndpoint,
                     pAddressEndpoint->pTransportAddress,
                     pAddressEndpoint->TransportAddressLength
                     );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("DeviceConnectionWait: Error 0x%x Creating ConnectionObject\n",Status));        
            break;
        }
        ASSERT( pConnectionEndpoint->Connected == FALSE );
        InsertTailList( &pAddressEndpoint->ConnectionQueue, &pConnectionEndpoint->ConnectionLink );
        pAddressEndpoint->ConnectionQueueSize++;
    }

    /*
     * If we have not registered our Connect Indication handler
     * yet, do it now. We had to delay it until connection objects
     * were created and ready.
     */
    if (!pAddressEndpoint->ConnectIndicationRegistered) {
        pTdTdi->pAddressEndpoint->ConnectIndicationRegistered = TRUE;
        ASSERT( !IsListEmpty( &pAddressEndpoint->ConnectionQueue ) );
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        /*
         * Register to receive connect indications
         *
         * *** Note that Connect events can be delivered IMMEDIATELY upon
         *     completion of this request!
         */
        Status = _TdiSetEventHandler(
                     pTd,
                     pAddressEndpoint->pDeviceObject,
                     pAddressEndpoint->pFileObject,
                     TDI_EVENT_CONNECT,
                     (PVOID)_TdConnectHandler,
                     (PVOID)pAddressEndpoint   // Context
                     );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("DeviceConnectionWait: Error 0x%x Setting TdiConnectHandler\n",Status));        
            ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
            pTdTdi->pAddressEndpoint->ConnectIndicationRegistered = FALSE;
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            goto done;
        }

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
    }

    /*
     * While holding the spinlock, see if any connected objects
     * are on the connected queue.
     */
    while (IsListEmpty( &pAddressEndpoint->ConnectedQueue)) {
        KeResetEvent( &pAddressEndpoint->AcceptEvent );
        ASSERT( pAddressEndpoint->Waiter == FALSE );
        pAddressEndpoint->Waiter = TRUE;
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        Status = IcaWaitForSingleObject(
                     pTd->pContext,
                     &pAddressEndpoint->AcceptEvent,
                     (-1) // No timeout
                     );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

        ASSERT( pAddressEndpoint->Waiter == TRUE );
        pAddressEndpoint->Waiter = FALSE;

        /*
         * Wait failure, could be due to thread receiving APC.
         */
        if( Status != STATUS_SUCCESS ) {
            DBGPRINT(("DeviceConnectionWait: Thread wait interrupted! Status 0x%x\n",Status));
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            return( Status );
        }

        if( pTd->fClosing ) {
            DBGPRINT(("DeviceConnectionWait: TD is Closing!\n"));
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            return( STATUS_CTX_CLOSE_PENDING );
        }

        // Should only be (1) accept thread in the TD.
        ASSERT( !IsListEmpty(&pAddressEndpoint->ConnectedQueue) );
    }

    /*
     * Dequeue the connected connection object
     */
    pEntry = RemoveHeadList( &pAddressEndpoint->ConnectedQueue );
    pAddressEndpoint->ConnectionQueueSize--;
    pConnectionEndpoint = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );

    ASSERT( pConnectionEndpoint->Connected == TRUE );

    /*
     * There could have been a final phase accept error, or
     * the remote side dropped the connection right away.
     *
     * In this case, we must tear down the errored connection.
     */
    if (!NT_SUCCESS(pConnectionEndpoint->Status)) {
        Status = pConnectionEndpoint->Status;
        DBGPRINT(("DeviceConnectionWait: Accept indication failed, Status 0x%x\n",Status));        
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

ConnectAccepted:
    /*
     * Allocate a context structure and register our endpoint as
     * a handle with ICADD. The handle returned by ICADD will then
     * be placed into the user mode callers buffer as the endpoint
     * handle.
     *
     * A later call to DeviceOpenEndpoint() will validate this handle,
     * retreive the context, and allow use of the endpoint.
     */
    Status = MemoryAllocate( sizeof(TD_STACK_ENDPOINT), &pStackEndpoint );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionWait: Could not allocate memory 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    pStackEndpoint->AddressType = TdiDeviceAddressType;
    pStackEndpoint->pEndpoint = pConnectionEndpoint;

    Status = IcaCreateHandle( (PVOID)pStackEndpoint, sizeof(TD_STACK_ENDPOINT), &Handle );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionWait: Error creating ICADD handle 0x%x\n",Status));
        MemoryFree( pStackEndpoint );
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    Status = STATUS_SUCCESS;

    /*
     * Fill in the stack endpoint structure to be returned
     */
    try {
        *((PVOID *)pIcaEndpoint) = Handle;
        *BytesReturned = sizeof(PVOID);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();

    }

    // Exception
    if( !NT_SUCCESS(Status) ) {
        ULONG Length;
        NTSTATUS Status2;

        DBGPRINT(("DeviceConnectionWait: Exception returning result 0x%x\n",Status));

        Status2 = IcaCloseHandle( Handle, &pStackEndpoint, &Length );
        if( NT_SUCCESS(Status2) ) {
            MemoryFree( pStackEndpoint );
        }
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    pConnectionEndpoint->hIcaHandle = Handle;

    TRACE0(("DeviceConnectionWait: New Connection Endpoint 0x%x Returned on Context 0x%x, AddressEndpoint 0x%x\n",pConnectionEndpoint,pTd->pAfd,pAddressEndpoint));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pConnectionEndpoint->pFileObject,pConnectionEndpoint->pDeviceObject,pConnectionEndpoint->TransportHandle));

done:
    return Status;
}


/*******************************************************************************
 * DeviceConnectionSend
 *
 * Initialize host module data structure, which gets sent to the client.
 ******************************************************************************/
NTSTATUS DeviceConnectionSend(PTD pTd)
{
    return TdiDeviceConnectionSend(pTd);
}


/*******************************************************************************
 * DeviceConnectionRequest
 *
 *  Initiate a connection to the specified remote address
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pRemoteAddress (input)
 *       Pointer to remote address to connect to
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Pointer to location to return length of pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionRequest(
        PTD pTd,
        PICA_STACK_ADDRESS pRemoteAddress,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PVOID Handle;
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint = NULL;
    PTD_STACK_ENDPOINT pStackEndpoint = NULL;

    ICA_STACK_ADDRESS LocalAddress;    
    PICA_STACK_ADDRESS pLocalAddress = &LocalAddress;    

    UNICODE_STRING TransportName;
    ULONG TransportAddressLength;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pTransportAddress = NULL;

    UNICODE_STRING RemoteTransportName;
    ULONG RemoteTransportAddressLength;
    PTRANSPORT_ADDRESS pRemoteTransportAddress = NULL;

    ULONG timeout;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;

    PTDI_ADDRESS_IP pTdiAddress;

#if DBG
    PTDI_ADDRESS_INFO pTdiLocalAddressInfo;
    ULONG LocalAddressInfoLength;
#endif

    DBGENTER(("DeviceConnectionRequest: PTD 0x%x\n",pTd));

    //
    // This part is from the above DeviceConnectionwait:
    //

    if (pRemoteAddress == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }
    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    if (pTd->fClosing) {
        return STATUS_DEVICE_NOT_READY;
    }

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if ( Length < sizeof(TD_STACK_ENDPOINT) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        DBGPRINT(("DeviceConnectionRequest: Output buffer to small\n"));        
        goto done;
    }

    /*
     * Different handling for datagram connections
     */
    if (TdiDeviceEndpointType == TdiConnectionDatagram) {
        Status = STATUS_NOT_SUPPORTED;
        goto done;
    }

    //
    // Extract timeout value and reset to NULL, will require adding timeout
    // into ICA_STACK_ADDRESS, too riskly for Whistler.
    //
    pTdiAddress = (PTDI_ADDRESS_IP) ((PCHAR)pRemoteAddress + 2);
    RtlCopyMemory( &timeout, &pTdiAddress->sin_zero[0], sizeof(timeout) );
    RtlZeroMemory( &pTdiAddress->sin_zero[0], sizeof(timeout) );


    //
    // Build the remote address
    //
    DBGPRINT(("TDTCP:DeviceConnectionRequest: building REMOTE address ...\n"));
    DBGPRINT(("TDTCP:DeviceConnectionRequest: Timeout %d\n", timeout));
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pRemoteAddress,
                                                    &RemoteTransportName,
                                                    &pRemoteTransportAddress,
                                                    &RemoteTransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    MemoryFree( RemoteTransportName.Buffer ); // not used, should make it optional in the call above
    RemoteTransportName.Buffer = NULL;

    /*
     * Build transport device name and address. This is in the TD.
     */

    DBGPRINT(("TDTCP:DeviceConnectionRequest: building LOCAL address ...\n"));

    //
    // We build a wild card local address let tcpip driver pick up port and NIC card.
    //
    RtlZeroMemory(pLocalAddress, sizeof(LocalAddress));
    *(PUSHORT)pLocalAddress = TDI_ADDRESS_TYPE_IP;
   
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pLocalAddress,
                                                    &TransportName,
                                                    &pTransportAddress,
                                                    &TransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    /*
     * Create the Endpoint structure.
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &TransportName,
                 &pEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating endpointstruct 0x%x\n",Status));
        goto badcreate;
    }

    pEndpoint->EndpointType = TdiAddressObject;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating TDI address object 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        goto badcreate;
    }

    /*
     * Save a pointer to the address endpoint
     */
    pTdTdi->pAddressEndpoint = pEndpoint;
    pAddressEndpoint = pTdTdi->pAddressEndpoint;
    /*
     * Free transport name and address buffers
     */
    MemoryFree( TransportName.Buffer );
    TransportName.Buffer = NULL;
    MemoryFree( pTransportAddress );
    pTransportAddress = NULL;
    
    //*************************************************************

    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Data receive indication must be registered on the
     * address endpoint before any data endpoints are created.
     *
     * This is because we can not set receive indication on a
     * dataendpoint, it can only be inherited from its
     * address endpoint.
     */
    if (!pAddressEndpoint->RecvIndicationRegistered) {
        pAddressEndpoint->RecvIndicationRegistered = TRUE;

        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Register the receive event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_RECEIVE,
                    (PVOID)_TdReceiveHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );
        if( !NT_SUCCESS(Status) )
        {
            // Already released the spin lock
            DBGPRINT(("DeviceConnectionRequest: failed to _TdiSetEventHandler on TDI_EVENT_RECEIVE 0x%x\n",Status));        
            goto badconnect1;
        }

        pAddressEndpoint->DisconnectIndicationRegistered = TRUE;

        /*
         * Register the disconnect event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_DISCONNECT,
                    (PVOID)_TdDisconnectHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );
        if( !NT_SUCCESS(Status) )
        {
            // Already released the spin lock
            DBGPRINT(("DeviceConnectionRequest: failed to _TdiSetEventHandler on TDI_EVENT_DISCONNECT 0x%x\n",Status));        
            goto badconnect1;
        }
    }
    else {
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
    }


    // now create a TDI connection object
    Status = _TdCreateConnectionObject(
                 pTd,
                 &pAddressEndpoint->TransportName,
                 &pConnectionEndpoint,
                 pAddressEndpoint->pTransportAddress,
                 pAddressEndpoint->TransportAddressLength
                 );

    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: failed to create ConnectionObject 0x%x\n",Status));        
        goto badconnect1;
    }

    if( 0 != timeout ) {
        WaitTimeout = RtlEnlargedIntegerMultiply( timeout * 1000, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    pTdTdi->pConnectionEndpoint = pConnectionEndpoint;

    Status = _TdiConnect( pTd,
                          NULL, // will allocate the IRP internally
                          pWaitTimeout,
                          pConnectionEndpoint->pFileObject, 
                          pConnectionEndpoint->pDeviceObject,
                          RemoteTransportAddressLength,
                          pRemoteTransportAddress
                          );

    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: failed to connect 0x%x\n",Status));        
        goto badconnect;
    }

    //
    // signal accept event, connect logic don't depend on it.
    //
    KeSetEvent( &pAddressEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE );

    MemoryFree( pRemoteTransportAddress );
    pRemoteTransportAddress = NULL;

#if DBG
    //
    // Query local address use to connect.
    //
    LocalAddressInfoLength = pAddressEndpoint->TransportAddressLength+4;
    Status = MemoryAllocate( LocalAddressInfoLength, &pTdiLocalAddressInfo );
    if ( NT_SUCCESS( Status ) ) {
        Status = _TdiQueryAddressInfo(
                                pTd,
                                NULL,
                                pConnectionEndpoint->pFileObject,
                                pConnectionEndpoint->pDeviceObject,
                                pTdiLocalAddressInfo,
                                LocalAddressInfoLength
                            );

        if( NT_SUCCESS(Status) )
        {
            int i;
            TA_ADDRESS* pTdAddress;
            TDI_ADDRESS_IP* pTdiAddressIp;

            pTdAddress = &pTdiLocalAddressInfo->Address.Address[0];

            DBGPRINT( ("number of local address %d\n", pTdiLocalAddressInfo->Address.TAAddressCount) );

            for( i=0; i < pTdiLocalAddressInfo->Address.TAAddressCount; i++ )
            {
                DBGPRINT( (" Address Type %d\n", pTdAddress->AddressType) );
                if( TDI_ADDRESS_TYPE_IP == pTdAddress->AddressType )
                {
                    pTdiAddressIp = (TDI_ADDRESS_IP *)&pTdAddress->Address[0];
                    DBGPRINT(("  Port %x\n", pTdiAddressIp->sin_port) );        
                    DBGPRINT(("  IP %u.%u.%u.%u\n", 
                                 (pTdiAddressIp->in_addr & 0xff000000) >> 24,
                                 (pTdiAddressIp->in_addr & 0x00ff0000) >> 16,
                                 (pTdiAddressIp->in_addr & 0x0000ff00) >> 8,
                                 (pTdiAddressIp->in_addr & 0x000000ff) ));
                }

                pTdAddress++;
            }
        }

        MemoryFree( pTdiLocalAddressInfo );
    }
#endif

    //**********************************************************************************
    /*
     * Allocate a context structure and register our endpoint as
     * a handle with ICADD. The handle returned by ICADD will then
     * be placed into the user mode callers buffer as the endpoint
     * handle.
     */
    Status = MemoryAllocate( sizeof(TD_STACK_ENDPOINT), &pStackEndpoint );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Could not allocate memory 0x%x\n",Status));
        goto badconnect;
    }

    pStackEndpoint->AddressType = TdiDeviceAddressType;
    pStackEndpoint->pEndpoint = pConnectionEndpoint;

    Status = IcaCreateHandle( (PVOID)pStackEndpoint, sizeof(TD_STACK_ENDPOINT), &Handle );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating ICADD handle 0x%x\n",Status));
        MemoryFree( pStackEndpoint );
        goto badconnect;
    }

    Status = STATUS_SUCCESS;

    /*
     * Fill in the stack endpoint structure to be returned
     */
    try {
        *((PVOID *)pIcaEndpoint) = Handle;
        *BytesReturned = sizeof(PVOID);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceConnectionRequest: Exception returning result 0x%x\n",Status));
    }

    // Exception
    if( !NT_SUCCESS(Status) ) {
        goto badsetup;
    }

    pConnectionEndpoint->hIcaHandle = Handle;

    /*
     * Save the file/device objects used for I/O in the TD structure
     */
    pTd->pFileObject = pTdTdi->pConnectionEndpoint->pFileObject;
    pTd->pDeviceObject = pTdTdi->pConnectionEndpoint->pDeviceObject;

    TRACE0(("DeviceConnectionRequest: New Connection Endpoint 0x%x Returned on Context 0x%x, AddressEndpoint 0x%x\n",pConnectionEndpoint,pTd->pAfd,pAddressEndpoint));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pConnectionEndpoint->pFileObject,pConnectionEndpoint->pDeviceObject,pConnectionEndpoint->TransportHandle));

    //**********************************************************************************

    // should be a success
    return Status;
    
/*=============================================================================
==   Error returns
=============================================================================*/
badsetup:
    {
        ULONG Length;
        NTSTATUS Status2;

        DBGPRINT(("DeviceConnectionRequest: Exception returning result 0x%x\n",Status));

        Status2 = IcaCloseHandle( Handle, &pStackEndpoint, &Length );
        if( NT_SUCCESS(Status2) ) {
            MemoryFree( pStackEndpoint );
        }
    }

badconnect:
    _TdCloseEndpoint(pTd, pConnectionEndpoint);
    pTdTdi->pConnectionEndpoint = NULL;

badconnect1:
    //
    // It is imperative that we do not close address end point, 
    // We will close address end point on next IOCTL call which triggle 
    // Closing of address end point, if we do it here, we will end up
    // double free and bug check.
    // _TdCloseEndpoint(pTd, pAddressEndpoint);

badcreate:
    if ( TransportName.Buffer )
        MemoryFree( TransportName.Buffer );
    if ( pTransportAddress )
        MemoryFree( pTransportAddress );

    if ( RemoteTransportName.Buffer )
        MemoryFree( RemoteTransportName.Buffer );
    if ( pRemoteTransportAddress )
        MemoryFree( pRemoteTransportAddress );
badaddress:
done:
    return Status;
}


/*******************************************************************************
 * DeviceIoctl
 *
 *  Query/Set configuration information for the td.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS DeviceIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    DBGENTER(("DeviceIoctl: PTD 0x%x\n",pTd));
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceInitializeRead
 *
 * Setup the IRP for a TDI read.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 ******************************************************************************/
NTSTATUS DeviceInitializeRead(PTD pTd, PINBUF pInBuf)
{
    PIRP Irp;
    PTDTDI pTdTdi;
    PIO_STACK_LOCATION _IRPSP;

    pTdTdi = (PTDTDI) pTd->pAfd;

    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    ASSERT( pTd );
    ASSERT( pTd->pDeviceObject );
    ASSERT( !(pTd->pDeviceObject->Flags & DO_BUFFERED_IO) );

    Irp = pInBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation( Irp );

    ASSERT( Irp->MdlAddress == NULL );

    /*
     * TDI interfaces always use an MDL regardless of the driver I/O type.
     */
    MmInitializeMdl( pInBuf->pMdl, pInBuf->pBuffer, pTd->InBufHeader + pTd->OutBufLength );
    MmBuildMdlForNonPagedPool( pInBuf->pMdl );
    Irp->MdlAddress = pInBuf->pMdl;

    if( pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionStream ) {
        PTDI_REQUEST_KERNEL_RECEIVE p;
        KIRQL OldIrql;
        NTSTATUS Status;
        PTD_ENDPOINT pEndpoint = pTdTdi->pConnectionEndpoint;

        ASSERT( TdiDeviceEndpointType == TdiConnectionStream );

        /* 
         * Most TDI users use the macro TdiBuildReceive(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */

        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_RECEIVE;

        ASSERT( _IRPSP->DeviceObject == pTd->pDeviceObject );
        ASSERT( _IRPSP->FileObject == pTd->pFileObject );
        ASSERT( Irp->MdlAddress );

        // Cast the generic parameters field to the TDI structure needed
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;
        p->ReceiveFlags = 0;
        p->ReceiveLength = pTd->InBufHeader + pTd->OutBufLength;

        return( STATUS_SUCCESS );
    }
    else if( pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionDatagram ) {
        PTDI_REQUEST_KERNEL_RECEIVEDG p;

        ASSERT( TdiDeviceEndpointType == TdiConnectionDatagram );

        /* 
         * Most TDI users use the macro TdiBuildReceiveDatagram(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
    
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_RECEIVE_DATAGRAM;

        ASSERT( _IRPSP->DeviceObject );
        ASSERT( _IRPSP->FileObject );
        ASSERT( Irp->MdlAddress );

        // Cast the generic parameters field to the TDI structure needed
        p = (PTDI_REQUEST_KERNEL_RECEIVEDG)&_IRPSP->Parameters;
        p->ReceiveFlags = 0;
        p->ReceiveLength = pTd->InBufHeader + pTd->OutBufLength;

        p->ReceiveDatagramInformation = NULL;
        p->ReturnDatagramInformation = NULL;

        return( STATUS_SUCCESS );
    }
    else {
        DBGPRINT(("DeviceInitializeRead: Bad EndpointType 0x%x\n",pTdTdi->pConnectionEndpoint->EndpointType));
        return( STATUS_INVALID_HANDLE );
    }
    // NOTREACHED
}


/*******************************************************************************
 * DeviceSubmitRead
 *
 * Submit the read IRP to the driver.
 ******************************************************************************/
NTSTATUS DeviceSubmitRead(PTD pTd, PINBUF pInBuf)
{
    NTSTATUS Status;
    PIRP Irp;
    PTDTDI pTdTdi;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PTD_ENDPOINT pEndpoint;
    PIO_STACK_LOCATION _IRPSP;
    PTDI_REQUEST_KERNEL_RECEIVE p;

    Irp = pInBuf->pIrp;

    /*
     * Datagram endpoints do not use a receive indication handler.
     */
    if( TdiDeviceEndpointType == TdiConnectionDatagram ) {
        Status = IoCallDriver( pTd->pDeviceObject, Irp );
        return( Status );
    }

    pTdTdi = (PTDTDI) pTd->pAfd;
    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    pEndpoint = pTdTdi->pConnectionEndpoint;

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

    // The other end may have disconnected
    if( pEndpoint->Disconnected ) {
        TRACE0(("DeviceSubmitRead: Connection disconnecting! pEndpoint 0x%x\n",pEndpoint));
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        Irp->IoStatus.Status = STATUS_REMOTE_DISCONNECT;
        Irp->IoStatus.Information = 0;

        // Since the IRP has not been submitted with IoCallDriver() yet,
        // we must simulate.
        IoSetNextIrpStackLocation( Irp );

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return STATUS_REMOTE_DISCONNECT;
    }

    /*
     * We queue the receive IRP onto the connection
     * endpoint so that the indication handler can
     * submit it. Because we could have received an
     * indication while processing the previous receive,
     * the indication will set the indicated byte count
     * in RecvBytesReady that the call side can submit the IRP.
     *
     * The ReceiveQueue is designed to allow our caller to submit
     * multiple read IRP's in case we need to handle a TDI
     * provider that drops data when no receives are ready.
     */
    InsertTailList( &pEndpoint->ReceiveQueue, &Irp->Tail.Overlay.ListEntry );

    /*
     * Connection oriented endpoints disconnect the connection when
     * a submitted I/O is canceled. This breaks the Citrix disconnect
     * reconnect sequence that occurs on a new connection since the
     * reader thread must be killed on one winstation, and the
     * connection passed to another reader thread for a different
     * winstation.
     *
     * This problem is solved by using a receive indication handler
     * and only submitting IRP's when we know we will not block.
     * This allows us to "cancel" I/O within our driver, and not
     * have to do a IoCancelIrp() onto the TDI provider.
     */
    if( pEndpoint->RecvBytesReady ) {

        //
        // Indication came in without IRP ready, or more bytes indicated than
        // ICA outbuf IRP can handle.
        //
        // We subtract the number of bytes we can receive from the indication
        // bytes. We do not need to handle the IRP cancel case, since the TDI
        // will nuke the connection anyway.
        //

        ASSERT( !IsListEmpty( &pEndpoint->ReceiveQueue ) );

        pEntry = RemoveHeadList( &pEndpoint->ReceiveQueue );
        Irp = CONTAINING_RECORD( pEntry, IRP, Tail.Overlay.ListEntry );

        _IRPSP = IoGetNextIrpStackLocation( Irp );
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;

        if( p->ReceiveLength > pEndpoint->RecvBytesReady ) {
            pEndpoint->RecvBytesReady = 0;
        }
        else {
            pEndpoint->RecvBytesReady -= p->ReceiveLength;
        }
        TRACE1(("DeviceSubmitRead: RecvBytesReady, Calling Driver with IRP 0x%x\n",Irp));
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
        Status = IoCallDriver( pTd->pDeviceObject, Irp );
        return( Status );
    }
    else {

        // In this case we let the indication handler submit it.
        TRACE1(("DeviceSubmitRead: Letting indication handler submit. Irp 0x%x\n",Irp));

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
        return( STATUS_SUCCESS );
    }
}


/*******************************************************************************
 * DeviceWaitForRead
 ******************************************************************************/
NTSTATUS DeviceWaitForRead(PTD pTd)
{
    /*
     * Just wait on the input event and return the wait status
     */
    return IcaWaitForSingleObject(pTd->pContext, &pTd->InputEvent, -1);
}


/*******************************************************************************
 * DeviceReadComplete
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location to return byte count read
 ******************************************************************************/
NTSTATUS DeviceReadComplete(PTD pTd, PUCHAR pBuffer, PULONG pByteCount)
{
    /*
     * Do any protocol specific read complete processing
     */
    return TdiDeviceReadComplete(pTd, pBuffer, pByteCount);
}


/*******************************************************************************
 * DeviceInitializeWrite
 ******************************************************************************/
NTSTATUS DeviceInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP Irp;
    PTDTDI pTdTdi;
    ULONG WriteLength;
    PIO_STACK_LOCATION _IRPSP;

    pTdTdi = (PTDTDI) pTd->pAfd;

    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    ASSERT( pTd );
    ASSERT( pTd->pDeviceObject );

    Irp = pOutBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation(Irp);

    ASSERT(Irp->MdlAddress == NULL);

    /*
     * TDI interfaces always use an MDL regardless of the driver I/O type.
     */
    MmInitializeMdl(pOutBuf->pMdl, pOutBuf->pBuffer, pOutBuf->ByteCount);
    MmBuildMdlForNonPagedPool(pOutBuf->pMdl);
    Irp->MdlAddress = pOutBuf->pMdl;

    if (pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionStream) {
        PTDI_REQUEST_KERNEL_SEND p;

        /* 
         * Most TDI users use the macro TdiBuildSend(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
        ASSERT( TdiDeviceEndpointType == TdiConnectionStream );

        /*
         * Now write in the reformatted parameters for a TDI SEND
         */
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_SEND;

        ASSERT( _IRPSP->DeviceObject == pTd->pDeviceObject );
        ASSERT( _IRPSP->FileObject == pTd->pFileObject );
        ASSERT( Irp->MdlAddress );

        p = (PTDI_REQUEST_KERNEL_SEND)&_IRPSP->Parameters;
        p->SendFlags = 0;
        p->SendLength = pOutBuf->ByteCount;

        return STATUS_SUCCESS;
    }
    else if (pTdTdi->pConnectionEndpoint->EndpointType ==
            TdiConnectionDatagram) {
        PTDI_REQUEST_KERNEL_SENDDG p;

        /* 
         * Most TDI users use the macro TdiBuildSendDatagram(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
        ASSERT( TdiDeviceEndpointType == TdiConnectionDatagram );

        /*
         * Now write in the reformatted parameters for a TDI SEND
         */
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_SEND_DATAGRAM;

        ASSERT( _IRPSP->DeviceObject );
        ASSERT( _IRPSP->FileObject );
        ASSERT( Irp->MdlAddress );

        p = (PTDI_REQUEST_KERNEL_SENDDG)&_IRPSP->Parameters;
        p->SendLength = pOutBuf->ByteCount;

        // Include the remote address with every datagram send
        p->SendDatagramInformation = &pTdTdi->pConnectionEndpoint->SendInfo;

        return STATUS_SUCCESS;
    }
    else {
        DBGPRINT(("DeviceInitializeWrite: Bad EndpointType 0x%x\n",
                pTdTdi->pConnectionEndpoint->EndpointType));
        ASSERT(FALSE);  // Catch this
        return STATUS_INVALID_HANDLE;
    }
}


/*******************************************************************************
 * DeviceWaitForStatus
 *
 *  Wait for device status to change (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceWaitForStatus(PTD pTd)
{
    DBGENTER(("DeviceWaitForStatus: PTD 0x%x\n",pTd));
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 * DeviceCancelIo
 *
 *  cancel all current and future i/o
 ******************************************************************************/
NTSTATUS DeviceCancelIo(PTD pTd)
{
    KIRQL  OldIrql;
    PTDTDI pTdTdi;
    PIRP   Irp;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pEndpoint;
    POUTBUF pOutBuf;

    DBGENTER(("DeviceCancelIo: PTD 0x%x\n", pTd));
    pTdTdi = (PTDTDI)pTd->pAfd;
    ASSERT(pTdTdi != NULL);

    
    if ((pEndpoint = pTdTdi->pConnectionEndpoint) != NULL ) {
        DBGPRINT(("DeviceCancelIo [%p]: Endpoint 0x%p\n", pTd, pEndpoint));

        
//      DbgPrint("DeviceCancelIo [0x%p]: Endpoint 0x%p, connected = %ld, disconnected = %ld\n", 
//               pTd, pEndpoint, pEndpoint->Connected, pEndpoint->Disconnected);
        
        /* 
         * Disconnect the endpoint first to make all the I/O activity stop!
         */
        if (pEndpoint->Connected) {
            NTSTATUS Status;

            Status = _TdiDisconnect(pTd, 
                                    pEndpoint->pFileObject, 
                                    pEndpoint->pDeviceObject);
            pEndpoint->Connected = FALSE;

        }
        
        /*
         * Cancel any pended receives
         */
        _TdCancelReceiveQueue(pTd, pEndpoint, STATUS_LOCAL_DISCONNECT);

        /*
         * We now check to see if we have send IRP's on the
         * outgoing queue that have been submitted to the TDI.
         * When we register a disconnect indication handler, the TDI
         * provider will not cancel IRP's when the connection drops.
         * They will hang waiting to send on a connection that no longer
         * is taking data.
         *
         * NOTE: We should be protected by the stack driver lock
         *       while we walk this chain.
         */


        //
        // Close the enpoint handle to cause completion of any pending send Irp
        //
        if (pEndpoint->TransportHandle) {
            ZwClose( pEndpoint->TransportHandle );
            pEndpoint->TransportHandle = NULL;
        }
    }
    else
        DBGPRINT(("DeviceCancelIo [0x%p]: Endpoint is NULL\n", pTd));

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceSetParams
 *
 * Set device pararameters (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceSetParams(PTD pTd)
{
    DBGENTER(("DeviceSetParams: PTD 0x%x\n", pTd));
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceGetLastError
 *
 *  This routine returns the last transport error code and message
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLastError (output)
 *       address to return information on last transport error
 ******************************************************************************/
NTSTATUS DeviceGetLastError(PTD pTd, PICA_STACK_LAST_ERROR pLastError)
{
    DBGENTER(("DeviceGetLastError: PTD 0x%x\n",pTd));
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdCreateEndpointStruct
 *
 *  Create and initialize a new Endpoint structure. Does not create any
 *  TDI objects.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pTransportName (input)
 *       Pointer to UNICODE_STRING containing transport device name
 *    ppEndpoint (output)
 *       Pointer to location to return TD_ENDPOINT pointer
 ******************************************************************************/
NTSTATUS _TdCreateEndpointStruct(
        IN  PTD pTd,
        IN  PUNICODE_STRING pTransportName,
        OUT PTD_ENDPOINT *ppEndpoint,
        IN  PTRANSPORT_ADDRESS pTransportAddress,
        IN  ULONG TransportAddressLength)
{
    NTSTATUS Status;
    ULONG    Length;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status2;
    PVOID pContext;
    ULONG ContextLength;


    /*
     * Allocate an endpoint object and room for the transport name
     */
    Length = sizeof(*pEndpoint) + pTransportName->MaximumLength;
    Status = MemoryAllocate(Length, &pEndpoint);
    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(pEndpoint, Length);
        Status = IcaCreateHandle( (PVOID)pEndpoint, sizeof(TD_ENDPOINT), &pEndpoint->hConnectionEndPointIcaHandle );
        if (!NT_SUCCESS(Status)) {
            MemoryFree(pEndpoint);
            return Status;
        }
    } else {
        return Status;
    }

    KeInitializeSpinLock( &pEndpoint->Spinlock );
    KeInitializeEvent( &pEndpoint->AcceptEvent, NotificationEvent, FALSE );
    InitializeListHead( &pEndpoint->ConnectionQueue );
    InitializeListHead( &pEndpoint->ConnectedQueue );
    InitializeListHead( &pEndpoint->AcceptQueue );
    InitializeListHead( &pEndpoint->ReceiveQueue );

    /*
     * Build the transport name UNICODE_STRING and copy it
     */
    pEndpoint->TransportName.Length = pTransportName->Length;
    pEndpoint->TransportName.MaximumLength = pTransportName->MaximumLength;
    pEndpoint->TransportName.Buffer = (PWCHAR)(pEndpoint + 1);
    RtlCopyMemory( pEndpoint->TransportName.Buffer, pTransportName->Buffer,
                   pTransportName->MaximumLength );

    /*
     * If a transport address is supplied, copy it in.
     */
    if (pTransportAddress && TransportAddressLength) {
        /*
         * Allocate and copy the transport address
         */
        Status = MemoryAllocate(TransportAddressLength,
                &pEndpoint->pTransportAddress);
        if (NT_SUCCESS(Status)) {
            Status = IcaCreateHandle( (PVOID)pEndpoint->pTransportAddress, sizeof(TRANSPORT_ADDRESS), &pEndpoint->hTransportAddressIcaHandle );

            if (!NT_SUCCESS(Status)) {
                Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
                MemoryFree(pEndpoint->pTransportAddress);
                MemoryFree(pEndpoint);
                return Status;
            }

            RtlCopyMemory(pEndpoint->pTransportAddress, pTransportAddress,
                    TransportAddressLength);
            pEndpoint->TransportAddressLength = TransportAddressLength;
        }
        else {
            Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
            MemoryFree(pEndpoint);
            return Status;
        }
    }

    *ppEndpoint = pEndpoint;
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdCloseEndpoint
 *
 *  Close a TDI endpoint object
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdCloseEndpoint(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    KIRQL OldIrql;
    NTSTATUS Status;
    PTDTDI pAfd;
    PVOID pContext;
    ULONG  ContextLength ;
    NTSTATUS Status2;


    TRACE0(("_TdCloseEndpoint: pEndpoint 0x%x Context 0x%x Type 0x%x FO 0x%x, "
            "DO 0x%x, Handle 0x%x\n", pEndpoint,pTd->pAfd,
            pEndpoint->EndpointType, pEndpoint->pFileObject,
            pEndpoint->pDeviceObject, pEndpoint->TransportHandle));

    /*
     * If this is an address endpoint, we could have
     * a thread waiting for a connection.
     *
     * NOTE: Closing an address endpoint causes TDI to nuke all of the
     *       open connections that were created from it. Our upper
     *       level caller code understands this.
     */
    if (pEndpoint->EndpointType == TdiAddressObject) {
        PTD_ENDPOINT p;
        PLIST_ENTRY pEntry;

        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);

        while (pEndpoint->Waiter) {
            TRACE0(("_TdCloseEndpoint: Closing AddressEndpoint, Cleaning up listen thread...\n"));
            KeSetEvent( &pEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE );
            ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
            IcaSleep( pTd->pContext, 100 );
            ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );
        }

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cancel the accept indication handler if necessary
         * (FileObject may not be present if DeviceCreateEndpoint fails).
         */
        if (( TdiDeviceEndpointType != TdiConnectionDatagram ) &&
            (pEndpoint->pFileObject)) {
            Status = _TdiSetEventHandler(
                         pTd,
                         pEndpoint->pDeviceObject,
                         pEndpoint->pFileObject,
                         TDI_EVENT_CONNECT,
                         (PVOID)NULL,  // Handler
                         (PVOID)NULL   // Context
                         );

            ASSERT( NT_SUCCESS(Status) );
        }


        /*
         * Cleanup connected, but not returned objects
         */

        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        while( !IsListEmpty( &pEndpoint->ConnectedQueue ) ) {
            pEntry = pEndpoint->ConnectedQueue.Flink;
            RemoveEntryList( pEntry );
            ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
            ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        }
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cleanup queue of wait for Accept complete connections
         */

        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        while( !IsListEmpty( &pEndpoint->AcceptQueue ) ) {
            pEntry = pEndpoint->AcceptQueue.Flink;
            RemoveEntryList( pEntry );
            ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
            ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        }

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cleanup queue of empty connections
         */

        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        while( !IsListEmpty( &pEndpoint->ConnectionQueue ) ) {
            pEntry = pEndpoint->ConnectionQueue.Flink;
            RemoveEntryList( pEntry );
            ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
            ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
        }
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
    }

    /*
     * If this endpoint has ever been connected,
     * then tell the transport driver we are closing down.
     */
    if (pEndpoint->Connected) {
        (VOID) _TdiDisconnect(pTd,
                pEndpoint->pFileObject,
                pEndpoint->pDeviceObject);
    }
    pEndpoint->pDeviceObject = NULL;

    /*
     * If a file object, dereference it
     */
    if (pEndpoint->pFileObject) {
        ObDereferenceObject( pEndpoint->pFileObject );
        pEndpoint->pFileObject = NULL;
    }

    /*
     * If a file handle, close it
     */
    if (pEndpoint->TransportHandle) {
        ASSERT( pEndpoint->TransportHandleProcess == IoGetCurrentProcess() );
        ZwClose( pEndpoint->TransportHandle );
        pEndpoint->TransportHandleProcess = NULL;
        pEndpoint->TransportHandle = NULL;
    }

    /*
     * If an IRP, free it
     *
     * NOTE: This must be *AFTER* the close since the
     *       IRP is in the bowels of the TCP driver!
     */
    if( pEndpoint->AcceptIrp ) {
        IoFreeIrp( pEndpoint->AcceptIrp );
        pEndpoint->AcceptIrp = NULL;
    }

    /*
     * If a transport address, free it, and Also close it handle if there is one.
     */
    if (pEndpoint->hTransportAddressIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hTransportAddressIcaHandle , &pContext, &ContextLength );
    }
    if ( pEndpoint->pTransportAddress ) {
        MemoryFree( pEndpoint->pTransportAddress );
        pEndpoint->pTransportAddress = NULL;
    }

    /*
     * If a remote address, free it
     */
    if ( pEndpoint->pRemoteAddress ) {
        MemoryFree( pEndpoint->pRemoteAddress );
        pEndpoint->pRemoteAddress = NULL;
    }

    if (pEndpoint->hConnectionEndPointIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
    }
    DBGPRINT(("_TdCloseEndpoint [%p]: 0x%p\n", pTd, pEndpoint));
    MemoryFree(pEndpoint);
    return STATUS_SUCCESS;
}


/****************************************************************************/
// _TdConnectHandler
//
// This is the transport connect event handler for the server.  It is
// specified as the connect handler for all endpoints opened by the
// server.  It attempts to dequeue a free connection from a list
// anchored in the address endpoint.  If successful, it returns the
// connection to the transport.  Otherwise, the connection is rejected.
/****************************************************************************/
NTSTATUS _TdConnectHandler(
        IN PVOID TdiEventContext,
        IN int RemoteAddressLength,
        IN PVOID RemoteAddress,
        IN int UserDataLength,
        IN PVOID UserData,
        IN int OptionsLength,
        IN PVOID Options,
        OUT CONNECTION_CONTEXT *ConnectionContext,
        OUT PIRP *AcceptIrp)
{
    KIRQL OldIrql;
    NTSTATUS Status;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pConnection;
    PTD_ENDPOINT pAddressEndpoint;
    PACCEPT_CONTEXT Context;

    UserDataLength, UserData;               // avoid compiler warnings
    OptionsLength, Options;

    pAddressEndpoint = (PTD_ENDPOINT)TdiEventContext;

    TRACE0(("_TdConnectHandler: Connect event! Context 0x%x\n",pAddressEndpoint));

    /*
     * First try and get memory. If error, the TDI transport provider
     * will drop the connect request.
     */
    Status = MemoryAllocate(sizeof(ACCEPT_CONTEXT), &Context);
    if (NT_SUCCESS(Status)) {
        memset(Context, 0, sizeof(ACCEPT_CONTEXT));
    }
    else {
        DBGPRINT(("_TdConnectHandler: No memory for context\n"));
        return Status;
    }

    /*
     * Get the spinlock to synchronize with the call side
     */
    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Get the connection object on the front of the list
     */
    if (!IsListEmpty(&pAddressEndpoint->ConnectionQueue))  {
        pEntry = RemoveHeadList(&pAddressEndpoint->ConnectionQueue);
        pConnection = CONTAINING_RECORD(pEntry, TD_ENDPOINT, ConnectionLink);

        // Put it on the end of the accept list
        InsertTailList(&pAddressEndpoint->AcceptQueue,
                &pConnection->ConnectionLink);
    }
    else {
        DBGPRINT(("_TdConnectHandler: Empty ConnectionQueue! 0x%x\n",
                pAddressEndpoint));
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);
        MemoryFree(Context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Context->pAddressEndpoint = pAddressEndpoint;
    Context->pConnectionEndpoint = pConnection;
    ASSERT(pConnection->AcceptIrp != NULL);

    //
    //  remember the remote address in the connection endpoint
    //
    if ( NULL != RemoteAddress )
    {
        ASSERT( NULL == pConnection->pRemoteAddress );
        ASSERT( 0 != RemoteAddressLength );
        if ( NT_SUCCESS( MemoryAllocate( RemoteAddressLength, &pConnection->pRemoteAddress )))
        {
            RtlCopyMemory( pConnection->pRemoteAddress, RemoteAddress, RemoteAddressLength );
            pConnection->RemoteAddressLength = RemoteAddressLength;
        }
    }

    TdiBuildAccept(
            pConnection->AcceptIrp,
            pConnection->pDeviceObject,
            pConnection->pFileObject,
            _TdAcceptComplete,        // Completion routine
            Context,                  // Context
            &Context->RequestInfo,
            &Context->ReturnInfo);

    /*
     * Make the next stack location current.  Normally IoCallDriver would
     * do this, but since we're bypassing that, we do it directly.
     */
    IoSetNextIrpStackLocation(pConnection->AcceptIrp);

    /*
     * Return the connection context (the connection address) to the
     * transport.  Return a pointer to the Accept IRP.  Indicate that
     * the Connect event has been handled. This must be the same
     * context specified when the connection object was created.
     */
    *ConnectionContext = pConnection;
    *AcceptIrp = pConnection->AcceptIrp;
    ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS _TdAcceptComplete(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Ctx)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PACCEPT_CONTEXT Context;
    PTD_ENDPOINT pConnection;
    PTD_ENDPOINT pAddressEndpoint;

    Context = (PACCEPT_CONTEXT)Ctx;

    pConnection = Context->pConnectionEndpoint;
    pAddressEndpoint = Context->pAddressEndpoint;

    ASSERT( pConnection != NULL );
    ASSERT( pAddressEndpoint != NULL );
    ASSERT( pConnection->EndpointType == TdiConnectionStream );
    ASSERT( pAddressEndpoint->EndpointType == TdiAddressObject );    

    TRACE0(("_TdAcceptComplete: Status 0x%x, Endpoint 0x%x\n",Irp->IoStatus.Status,pConnection));

    /*
     * Get the spinlock to synchronize with the call side
     */
    ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

    if (IsListEmpty( &pAddressEndpoint->AcceptQueue))  {
        DBGPRINT(("_TdAcceptComplete: Empty Accept Queue! 0x%x\n",
                pAddressEndpoint));
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Release the context memory
         */

        MemoryFree(Context);

        // Let it drop
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        pEntry = RemoveHeadList(&pAddressEndpoint->AcceptQueue);
        pConnection = CONTAINING_RECORD(pEntry, TD_ENDPOINT, ConnectionLink);
        /*
         * Put it on the end of the connect list
         */
        InsertTailList(&pAddressEndpoint->ConnectedQueue,
                &pConnection->ConnectionLink);
    }

    /*
     * If the accept failed, the caller will check this status
     * and tear down the connection, causing a RST to be sent
     * to the other side.
     */
    pConnection->Status = Irp->IoStatus.Status;

    /*
     * Signal that it is connected (Could be in error)
     */
    pConnection->Connected = TRUE;

    /*
     * Set the event on the address object
     */
    KeSetEvent(&Context->pAddressEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE);

    ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

    /*
     * Release the context memory
     */
    MemoryFree(Context);

    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*****************************************************************************
 *  _TdReceiveHandler
 *
 *   This function is called by the TDI when receive data is available
 *   on the connection. This is done so we do not submit the IRP until
 *   data is available. The disconnect-reconnect logic in ICA causes an
 *   IoCancelIrp() to be sent on the input thread, and TDI providers drop the
 *   connection on a read or write I/O cancel.
 *
 *   WARNING: This critical behavior is only needed for a reconnect
 *            sequence. For normal ICA I/O, it is OK to block the reader
 *            thread in the TDI driver.
 *
 *   TdiEventContext (input)
 *       Context registered with event handler on address object.
 *       (address endpoint)
 *
 *   ConnectionContext (input)
 *       Connection context registered with the connection
 *       create.
 ****************************************************************************/
NTSTATUS _TdReceiveHandler(
        IN PVOID TdiEventContext,
        IN CONNECTION_CONTEXT ConnectionContext,
        IN ULONG ReceiveFlags,
        IN ULONG BytesIndicated,
        IN ULONG BytesAvailable,
        OUT ULONG *BytesTaken,
        IN PVOID Tsdu,
        OUT PIRP *IoRequestPacket)
{
    KIRQL OldIrql;
    PIRP  Irp;
    PLIST_ENTRY pEntry;
    PIO_STACK_LOCATION _IRPSP;
    PTDI_REQUEST_KERNEL_RECEIVE p;
    PTD_ENDPOINT pEndpoint = (PTD_ENDPOINT)ConnectionContext;

    /*
     * Only stream transports use a receive indication handler.
     */
    ASSERT( TdiDeviceEndpointType != TdiConnectionDatagram );

    ASSERT( pEndpoint != NULL );
    ASSERT( pEndpoint->EndpointType == TdiConnectionStream );

    TRACE1(("_TdReceiveHandler: ReceiveDataIndication! pEndpoint 0x%x\n",pEndpoint));

    ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);

    *BytesTaken = 0;

    /*
     * Submit an IRP at indication time if we have one on
     * the queue.
     */
    if (!IsListEmpty( &pEndpoint->ReceiveQueue)) {
        pEntry = RemoveHeadList(&pEndpoint->ReceiveQueue);
        Irp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        TRACE1(("_TdReceiveHandler: Passing IRP for Receive Indication %d bytes\n",
                BytesAvailable));

        _IRPSP = IoGetNextIrpStackLocation(Irp);
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;
        if (p->ReceiveLength < BytesAvailable) {
            pEndpoint->RecvBytesReady += (BytesAvailable - p->ReceiveLength);
            TRACE1(("_TdReceiveHandler: Excess Bytes %d Added to RecvBytesReady, now %d\n",
                    (BytesAvailable - p->ReceiveLength),
                    pEndpoint->RecvBytesReady));
        }

        ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
        *IoRequestPacket = Irp;
        IoSetNextIrpStackLocation(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // No RecvIrp, So we can not take any data. Let the callside get it.
    TRACE1(("_TdReceiveHandler: No RecvIrp, Adding To RecvBytesReady. %d Bytes\n",BytesAvailable));

    pEndpoint->RecvBytesReady += BytesAvailable;
    ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
    return STATUS_DATA_NOT_ACCEPTED;
}


/*****************************************************************************
 *  _TdDisconnectHandler
 *
 *   This function is called by the TDI when a disconnect occurs
 *   on the connection.
 *
 *   TdiEventContext (input)
 *       Context registered with event handler on address object.
 *       (address endpoint)
 *
 *   ConnectionContext (input)
 *       Connection context registered with the connection
 *       create.
 ****************************************************************************/
NTSTATUS _TdDisconnectHandler(
        IN PVOID TdiEventContext,
        IN CONNECTION_CONTEXT ConnectionContext,
        IN int DisconnectDataLength,
        IN PVOID DisconnectData,
        IN int DisconnectInformationLength,
        IN PVOID DisconnectInformation,
        IN ULONG DisconnectFlags)
{
    KIRQL OldIrql;
    PIRP  Irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pEndpoint = (PTD_ENDPOINT)ConnectionContext;

    /*
     * Only stream transports use a disconnect indication handler.
     */
    ASSERT( TdiDeviceEndpointType != TdiConnectionDatagram );
    ASSERT( pEndpoint != NULL );
    ASSERT( pEndpoint->EndpointType == TdiConnectionStream );

//  DbgPrint("\n");
//  DbgPrint("_TdDisconnectHandler : pEndpoint = 0x%p\n", pEndpoint);

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );
    pEndpoint->Disconnected = TRUE;
    ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

    _TdCancelReceiveQueue(NULL, pEndpoint, STATUS_REMOTE_DISCONNECT );
    return STATUS_SUCCESS;
}


/****************************************************************************/
// Create an idle connection object associated with an address object.
// This must be called from call (thread) level, and not from indication
// time (DPC level).
/****************************************************************************/
NTSTATUS _TdCreateConnectionObject(
        IN  PTD pTd,
        IN  PUNICODE_STRING pTransportName,
        OUT PTD_ENDPOINT *ppEndpoint,
        IN  PTRANSPORT_ADDRESS pTransportAddress,
        IN  ULONG TransportAddressLength)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    PTD_ENDPOINT pEndpoint;

    pTdTdi = (PTDTDI)pTd->pAfd;

    // Create and init structure and spinlock
    Status = _TdCreateEndpointStruct(
                 pTd,
                 pTransportName,
                 ppEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                 );
    if (NT_SUCCESS(Status)) {
        pEndpoint = *ppEndpoint;
    }
    else {
        return Status;
    }

    // The TD sets whether data gram, or stream
    pEndpoint->EndpointType = TdiDeviceEndpointType;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create a TDI connection object
     */
    Status = _TdiOpenConnection(
                 &pEndpoint->TransportName,
                 (PVOID)pEndpoint,  // Context
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdCreateConnectionObject: _TdiOpenConnection failed, Status 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        return Status;
    }

    // Allocate an IRP for connect/disconnect handling
    // This is needed since we use the connect indication hander.
    pEndpoint->AcceptIrp = _TdiAllocateIrp(pEndpoint->pFileObject,
            pEndpoint->pDeviceObject);
    if (pEndpoint->AcceptIrp == NULL) {
        DBGPRINT(("_TdCreateConnectionObject: Could not allocate IRP\n"));
        _TdCloseEndpoint(pTd, pEndpoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Associate the connection object with its address object
    Status = _TdiAssociateAddress(
                 pTd,
                 pEndpoint->AcceptIrp,
                 pEndpoint->pFileObject,
                 pTdTdi->pAddressEndpoint->TransportHandle,
                 pTdTdi->pAddressEndpoint->pDeviceObject
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdCreateConnectionObject: _TdiAssociateAddress failed, Status 0x%x\n",Status));
        _TdCloseEndpoint(pTd, pEndpoint);
        return Status;
    }

    return Status;
}


/*******************************************************************************
 * _TdWaitForDatagramConnection
 *
 *  For for an incoming datagram connection request and accept it.
 *
 *  Datagram endpoints listen on a TDI address object bound to the local
 *  (netcard) and well known ICA socket number. Packets then received on
 *  the ICA socket number are checked for ICA request connection, and then
 *  a new TDI address object is bound with the wild-card local address
 *  (0). This causes a new, unused socket number to be assigned to this
 *  address object. This new TDI address object is used for further
 *  communication to the now "connected" IPX ICA client.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pAddressEndpoint (input)
 *       Pointer Address endpoint object
 *    ppConnectionEndpoint (output)
 *       Pointer to location to return Connection endpoint pointer
 ******************************************************************************/
NTSTATUS _TdWaitForDatagramConnection(
        IN PTD pTd,
        IN PTD_ENDPOINT pAddressEndpoint,
        OUT PTD_ENDPOINT *ppConnectionEndpoint)
{
    NTSTATUS Status;
    PTRANSPORT_ADDRESS pLocalAddress;
    ULONG LocalAddressLength;
    ULONG AddressInfoLength;
    ULONG RemoteAddressLength = 0;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pRemoteAddress = NULL;
    PTDI_ADDRESS_INFO pAddressInfo = NULL;

    /*
     * Get a copy of the local transport address.
     *
     * Clear the TDI address part of the structure so that we can
     * use it to bind the connection endpoint to a wild-card address.
     *
     * This wildcard address (0), will cause the packet level TDI
     * provider to assign us a unique socket when the TDI address
     * object is created.
     */
    Status = MemoryAllocate(pAddressEndpoint->TransportAddressLength,
            &pLocalAddress);
    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(pLocalAddress, pAddressEndpoint->pTransportAddress,
                pAddressEndpoint->TransportAddressLength);
        RtlZeroMemory(pLocalAddress->Address[0].Address,
                pLocalAddress->Address[0].AddressLength);
    }
    else {
        goto badmalloc;
    }

    LocalAddressLength = pAddressEndpoint->TransportAddressLength;

    /*
     * Call protocol specific routine to wait for
     * a datagram connection request to arrive.
     *
     * This returns when a valid ICA connect datagram comes in
     * from a remote address. No reply has been sent.
     */
    Status = TdiDeviceWaitForDatagramConnection(pTd,
            pAddressEndpoint->pFileObject,
            pAddressEndpoint->pDeviceObject,
            &pRemoteAddress,
            &RemoteAddressLength);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in TdiDeviceWaitForDatagramConnction\n",Status));
        goto badwait;
    }

    ASSERT( pRemoteAddress != NULL );

    /*
     * Create a new address endpoint bound to the wildcard local address.
     * A unique "socket" will be created for us. This will become
     * our datagram "connection".
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &pAddressEndpoint->TransportName,
                 &pEndpoint,
                 pLocalAddress,
                 LocalAddressLength
                 );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdCreateEndpointStruct\n",Status));
        goto badopen;
    }

    pEndpoint->EndpointType = TdiConnectionDatagram;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdiCreateAddress\n",Status));
        goto badbind;
    }

    /*
     * Allocate a work buffer for querying the transport address
     */
    AddressInfoLength = pEndpoint->TransportAddressLength+4;
    Status = MemoryAllocate( AddressInfoLength, &pAddressInfo );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x Allocating Memory %d bytes\n",Status,AddressInfoLength));
        goto badbind;
    }

    /*
     * Now query the unique socket address that the TDI assigned for us.
     */
    Status = _TdiQueryAddressInfo(
                 pTd,
                 NULL,   // Irp
                 pEndpoint->pFileObject,
                 pEndpoint->pDeviceObject,
                 pAddressInfo,
                 AddressInfoLength
                 );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdiQueryAddressInfo\n",Status));
        goto badbind;
    }

    /*
     * Update the callers transport address buffer
     */
    RtlCopyMemory( pEndpoint->pTransportAddress,
                   &pAddressInfo->Address,
                   pEndpoint->TransportAddressLength );

    /*
     * Save the remote address in the connection endpoint
     * structure so that we can send to it with our datagram sends.
     */
    ASSERT( pEndpoint->pRemoteAddress == NULL );
    pEndpoint->pRemoteAddress = pRemoteAddress;
    pEndpoint->RemoteAddressLength = RemoteAddressLength;

    pEndpoint->SendInfo.RemoteAddress = pRemoteAddress;
    pEndpoint->SendInfo.RemoteAddressLength = RemoteAddressLength;

    /*
     * Call protocol specific routine to complete the datagram connection.
     *
     * This sends the ICA connect reply datagram.
     */
    Status = TdiDeviceCompleteDatagramConnection(
                 pTd,
                 pEndpoint->pFileObject,
                 pEndpoint->pDeviceObject,
                 pEndpoint->SendInfo.RemoteAddress,
                 pEndpoint->SendInfo.RemoteAddressLength
                 );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in TdiDeviceCompleteDatagramConnection\n",Status));
        goto badcomplete;
    }

    *ppConnectionEndpoint = pEndpoint;
    MemoryFree(pLocalAddress);
    MemoryFree(pAddressInfo);

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badcomplete:
badbind:
    if (pEndpoint)
        _TdCloseEndpoint(pTd, pEndpoint);

badopen:
    if (pAddressInfo)
        MemoryFree(pAddressInfo);
    if (pRemoteAddress)
        MemoryFree(pRemoteAddress);

badwait:
    MemoryFree(pLocalAddress);

badmalloc:
    return Status;
}


/*****************************************************************************
 *
 *  returns the remote address
 *
 ****************************************************************************/
NTSTATUS DeviceQueryRemoteAddress( 
    PTD pTd, 
    PVOID pIcaEndpoint, 
    ULONG EndpointSize, 
    PVOID pOutputAddress, 
    ULONG OutputAddressSize, 
    PULONG BytesReturned)
{
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    PTD_STACK_ENDPOINT pStackEndpoint;
    PTRANSPORT_ADDRESS pRemoteAddress;
    PTA_ADDRESS     pRemoteIP;
    PVOID    Handle;
    ULONG    Length;
    struct   {
        USHORT  sa_family;
        CHAR    sa_data[1];
    } *pOutput;

    *BytesReturned = 0;

    if ( sizeof(PVOID) != EndpointSize )
    {
        status = STATUS_INVALID_PARAMETER_4;
        goto exitpt;
    }

    pOutput = pOutputAddress;
    if ( NULL == pOutput )
    {
        status = STATUS_INVALID_PARAMETER_5;
        goto exitpt;
    }

    try {
        RtlZeroMemory( pOutput, OutputAddressSize );
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        status = GetExceptionCode();
        DBGPRINT(("DeviceQueryRemoteAddress: Exception 0x%x\n", status));
        goto exitpt;
    }

    /*
     * Capture the parameter
     */
    try {
        Handle = (*((PVOID *)pIcaEndpoint));
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
        DBGPRINT(("DeviceQueryRemoteAddress: Exception 0x%x\n", status));
        goto exitpt;
    }

    TRACE0(("DeviceOpenEndpoint: Fetching Handle 0x%x\n", Handle));

    /*
     * See if TERMDD knows about the handle
     */
    status = IcaReturnHandle( Handle, &pStackEndpoint, &Length );
    if( !NT_SUCCESS(status) ) {
        DBGPRINT(("DeviceQueryRemoteAddress: TERMDD handle 0x%x no good 0x%x\n", Handle, status));
        status = STATUS_INVALID_PARAMETER_3;
        goto exitpt;
    }

    if ( TDI_ADDRESS_TYPE_IP != pStackEndpoint->AddressType &&
         TDI_ADDRESS_TYPE_IP6 != pStackEndpoint->AddressType )
    {
        status = STATUS_NOT_SUPPORTED;
        goto exitpt;
    }

    if ( NULL == pStackEndpoint->pEndpoint )
    {
        status = STATUS_INVALID_PARAMETER_3;    // remote address wasn't recorded
        goto exitpt;
    }


    pRemoteAddress = pStackEndpoint->pEndpoint->pRemoteAddress;

    ASSERT( 1 == pRemoteAddress->TAAddressCount );
    pRemoteIP = pRemoteAddress->Address;

    //
    //  check the size of the output including the protocol family
    //
    if ( pRemoteIP->AddressLength + sizeof( USHORT ) > OutputAddressSize )
    {
        status = STATUS_BUFFER_TOO_SMALL;
        goto exitpt;
    }

    ASSERT( sizeof( TDI_ADDRESS_IP )  == pRemoteIP->AddressLength || 
            sizeof( TDI_ADDRESS_IP6 ) == pRemoteIP->AddressLength );
    ASSERT( TDI_ADDRESS_TYPE_IP  == pRemoteIP->AddressType ||
            TDI_ADDRESS_TYPE_IP6 == pRemoteIP->AddressType );

    pOutput->sa_family = pRemoteIP->AddressType;
    RtlCopyMemory( &pOutput->sa_data, &(pRemoteIP->Address), pRemoteIP->AddressLength );
    *BytesReturned = sizeof( *pOutput );

    status = STATUS_SUCCESS;
exitpt:
    return status;
}

/*****************************************************************************
 *
 *  returns the RDP-Enabled local IP Address
 *
 ****************************************************************************/
NTSTATUS DeviceQueryLocalAddress( 
    PTD pTd, 
    PVOID pOutputAddress, 
    ULONG OutputAddressSize, 
    PULONG BytesReturned)
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    ULONG TransportAddressLength;
    PTRANSPORT_ADDRESS pTransportAddress = NULL;
    PSocketAddr pOutput;


    DBGENTER(("DeviceQueryLocalAddress: PTD 0x%x\n",pTd));

    pOutput = pOutputAddress;
    if ( NULL == pOutput )
    {
        Status = STATUS_INVALID_PARAMETER_3;
        goto badaddress;
    }

    try {
        RtlZeroMemory( pOutput, OutputAddressSize );
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceQueryLocalAddress: Exception 0x%x\n", Status));
        goto badaddress;
    }


    Status = TdiDeviceQueryLocalAddress( pTd,
                                         &pTransportAddress,
                                         &TransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceQueryLocalAddress: Error getting address 0x%x\n",Status));
        goto badaddress;
    }

    //
    //  check the size of the output including the protocol family
    //
    if ( pTransportAddress->Address[0].AddressLength + sizeof(USHORT) > OutputAddressSize )
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto badaddress;
    }

    try {
        pOutput->sa_family = pTransportAddress->Address[0].AddressType;
        RtlCopyMemory( pOutput->sa_data, pTransportAddress->Address[0].Address, pTransportAddress->Address[0].AddressLength );
        *BytesReturned = pTransportAddress->Address[0].AddressLength + sizeof(USHORT);
        Status = STATUS_SUCCESS;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceQueryLocalAddress: Exception returning result 0x%x\n",Status));
    }

/*=============================================================================
==   Error returns
=============================================================================*/

badaddress:
    if (pTransportAddress != NULL)
        MemoryFree( pTransportAddress );
    return( Status );
}


/*****************************************************************************
 * _TdCancelReceiveQueue
 *
 * Cancel all of the I/O in the current Receive Queue
 ****************************************************************************/
NTSTATUS _TdCancelReceiveQueue(PTD pTd, PTD_ENDPOINT pEndpoint, NTSTATUS CancelStatus)
{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;

    DBGPRINT(("_TdCancelReceiveQueue [%p]: Endpoint 0x%p\n", pTd, pEndpoint));

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

    /*
     * If we have any Receive Irp's, we are waiting for the
     * indication handler to submit the I/O. Since the IRP
     * is not submitted yet, we must cancel the IRP's.
     */
    while (!IsListEmpty(&pEndpoint->ReceiveQueue)) {
        pEntry = RemoveHeadList( &pEndpoint->ReceiveQueue );
        Irp = CONTAINING_RECORD( pEntry, IRP, Tail.Overlay.ListEntry );

        TRACE0(("_TdCancelReceiveQueue: Cancel Receive Irp 0x%x on pEndpoint 0x%x\n",Irp,pEndpoint));

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        Irp->IoStatus.Status = CancelStatus;
        Irp->IoStatus.Information = 0;

        // Since the IRP has not been submitted with IoCallDriver() yet,
        // we must simulate.
        IoSetNextIrpStackLocation(Irp);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
    }

    ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdpipe\tdpipe.c ===
/****************************************************************************/
// tdpipe.c
//
// TS named pipe transport driver.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <ntosp.h>

#include <winstaw.h>
#define  _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdpipe.h"


#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdpipe";
#endif


#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdOpenEndpoint( PTD, PICA_STACK_ADDRESS, PTD_ENDPOINT * );
NTSTATUS _TdCloseEndpoint( PTD, PTD_ENDPOINT );
NTSTATUS _TdStartListen( PTD, PTD_ENDPOINT );
NTSTATUS _TdWaitForListen( PTD, PTD_ENDPOINT );
NTSTATUS _TdConnectRequest( PTD, PTD_ENDPOINT );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS
ZwClose(
    IN HANDLE Handle
    );

NTSTATUS
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSTATUS
ZwCreateNamedPipeFile(
         OUT PHANDLE FileHandle,
         IN ULONG DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         OUT PIO_STATUS_BLOCK IoStatusBlock,
         IN ULONG ShareAccess,
         IN ULONG CreateDisposition,
         IN ULONG CreateOptions,
         IN ULONG NamedPipeType,
         IN ULONG ReadMode,
         IN ULONG CompletionMode,
         IN ULONG MaximumInstances,
         IN ULONG InboundQuota,
         IN ULONG OutboundQuota,
         IN PLARGE_INTEGER DefaultTimeout OPTIONAL)

/*++
    Creates and opens the server end handle of the first instance of a
    specific named pipe or another instance of an existing named pipe.

Arguments:
    FileHandle - Supplies a handle to the file on which the service is being
        performed.
    DesiredAccess - Supplies the types of access that the caller would like to
        the file.
    ObjectAttributes - Supplies the attributes to be used for file object
        (name, SECURITY_DESCRIPTOR, etc.)
    IoStatusBlock - Address of the caller's I/O status block.
    ShareAccess - Supplies the types of share access that the caller would
        like to the file.
    CreateDisposition - Supplies the method for handling the create/open.
    CreateOptions - Caller options for how to perform the create/open.
    NamedPipeType - Type of named pipe to create (Bitstream or message).
    ReadMode - Mode in which to read the pipe (Bitstream or message).
    CompletionMode - Specifies how the operation is to be completed.
    MaximumInstances - Maximum number of simultaneous instances of the named
        pipe.
    InboundQuota - Specifies the pool quota that is reserved for writes to the
        inbound side of the named pipe.
    OutboundQuota - Specifies the pool quota that is reserved for writes to
        the inbound side of the named pipe.
    DefaultTimeout - Optional pointer to a timeout value that is used if a
        timeout value is not specified when waiting for an instance of a named
        pipe.

Return Value:
    The function value is the final status of the create/open operation.
--*/

{
    NAMED_PIPE_CREATE_PARAMETERS namedPipeCreateParameters;
    NTSTATUS status;

    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then capture it in the named pipe create parameter structure.
    if (ARGUMENT_PRESENT( DefaultTimeout )) {
        // Indicate that a default timeout period was specified.
        namedPipeCreateParameters.TimeoutSpecified = TRUE;
        namedPipeCreateParameters.DefaultTimeout = *DefaultTimeout;

        // A default timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
    } else {
        // Indicate that no default timeout period was specified.
        namedPipeCreateParameters.TimeoutSpecified = FALSE;
        namedPipeCreateParameters.DefaultTimeout.QuadPart = 0;
    }

    // Store the remainder of the named pipe-specific parameters in the
    // structure for use in the call to the common create file routine.
    namedPipeCreateParameters.NamedPipeType = NamedPipeType;
    namedPipeCreateParameters.ReadMode = ReadMode;
    namedPipeCreateParameters.CompletionMode = CompletionMode;
    namedPipeCreateParameters.MaximumInstances = MaximumInstances;
    namedPipeCreateParameters.InboundQuota = InboundQuota;
    namedPipeCreateParameters.OutboundQuota = OutboundQuota;

    status = IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNamedPipe,
                         &namedPipeCreateParameters,
                         IO_NO_PARAMETER_CHECKING);

    return status;
}


NTSTATUS
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

extern POBJECT_TYPE *IoFileObjectType;
extern PDEVICE_OBJECT DrvDeviceObject;


/*******************************************************************************
 * DeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS DeviceOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    PTDPIPE pTdPipe;
    NTSTATUS Status;

    /*
     * Hideous HACK alert!  NULL out the unload routine for TDPIPE since
     * the timing is hosed and we sometimes unload before the IO completion
     * routine has issued a return statement. BARF!
     */
    // see correction of the hack below...
    //DrvDeviceObject->DriverObject->DriverUnload = NULL;

    // correction of the above hack: a pointer to the device object of the current
    // driver is stored in the TD struct. When an IRP is initialized, the function
    // IoSetCompletionRoutineEx will be used and this function will set a parent
    // completion routine which references and dereferences the device object
    // around the call of the normal completion routine in order to maintain the 
    // driver in memory.
    // DO NOT USE THIS POINTER AFTER THE DeviceClose !!!
    pTd->pSelfDeviceObject = pSdOpen->DeviceObject;

    /*
     *  Set protocol driver class
     */
    pTd->SdClass = SdNetwork;           // until we have SdPipe defined

    /*
     *  Return size of header and trailer
     */
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /*
     *  Allocate PIPE TD data structure
     */
    pTdPipe = IcaStackAllocatePoolWithTag(NonPagedPool, sizeof(*pTdPipe), 'ipDT');
    if (pTdPipe != NULL) {
        /*
         *  Initialize TDPIPE data structure
         */
        RtlZeroMemory(pTdPipe, sizeof(*pTdPipe));
        pTd->pPrivate = pTdPipe;
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


/*******************************************************************************
 * DeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 ******************************************************************************/
NTSTATUS DeviceClose(PTD pTd, PSD_CLOSE pSdClose)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;

    pTd->pSelfDeviceObject = NULL;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Close address endpoint if we have one
     */
    if (pEndpoint = pTdPipe->pAddressEndpoint) {
        pTdPipe->pAddressEndpoint = NULL;
        _TdCloseEndpoint(pTd, pEndpoint);
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceCreateEndpoint
 *
 * Create a new endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLocalAddress (input)
 *       Pointer to local address (or null)
 *    pReturnedAddress (input)
 *       Pointer to location to save returned (created) address (or null)
 ******************************************************************************/
NTSTATUS DeviceCreateEndpoint(
        PTD pTd,
        PICA_STACK_ADDRESS pLocalAddress,
        PICA_STACK_ADDRESS pReturnedAddress)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Create an endpoint which ConnectionWait will use to listen on.
     */
    Status = _TdOpenEndpoint(pTd, pLocalAddress, &pEndpoint);
    if (NT_SUCCESS(Status)) {
        /*
         * Prepare to listen on the new address endpoint.
         */
        Status = _TdStartListen(pTd, pEndpoint);
        if (NT_SUCCESS(Status)) {
            /*
             * Save a pointer to the address endpoint
             */
            pTdPipe->pAddressEndpoint = pEndpoint;
            Status = STATUS_SUCCESS;
        }
        else {
            _TdCloseEndpoint(pTd, pEndpoint);
        }
    }

    return Status;
}


/*******************************************************************************
 * DeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 ******************************************************************************/
NTSTATUS DeviceOpenEndpoint(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG IcaEndpointLength)
{
    PTDPIPE pTdPipe;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    TRACE((pTd->pContext, TC_TD, TT_API2,
            "TDPIPE: DeviceOpenEndpoint, copying existing endpoint\n"));

    try {
        /*
         * Verify the stack endpoint data looks valid
         */
        pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
        if (IcaEndpointLength == sizeof(TD_STACK_ENDPOINT) &&
                //pStackEndpoint->pEndpoint >= MM_LOWEST_NONPAGED_SYSTEM_START &&
                //pStackEndpoint->pEndpoint <= MM_NONPAGED_POOL_END &&
                MmIsNonPagedSystemAddressValid(pStackEndpoint->pEndpoint)) {
            /*
             * Save endpoint as the current connection endpoint
             */
            pTdPipe->pConnectionEndpoint = pStackEndpoint->pEndpoint;

            /*
             * Save the file/device objects used for I/O in the TD structure
             */
            pTd->pFileObject = pTdPipe->pConnectionEndpoint->pFileObject;
            pTd->pDeviceObject = pTdPipe->pConnectionEndpoint->pDeviceObject;

            Status = STATUS_SUCCESS;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}


/*******************************************************************************
 * DeviceCloseEndpoint
 ******************************************************************************/
NTSTATUS DeviceCloseEndpoint(PTD pTd)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Close connection endpoint if we have one
     * NOTE: The address endpoint, if there is one,
     *       gets closed in the DeviceClose routine.
     */
    if (pEndpoint = pTdPipe->pConnectionEndpoint) {
        pTd->pFileObject = NULL;
        pTd->pDeviceObject = NULL;
        pTdPipe->pConnectionEndpoint = NULL;
        _TdCloseEndpoint(pTd, pEndpoint);
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceConnectionWait
 *
 *  NOTE: The endpoint structure is an opaque, variable length data
 *        structure whose length and contents are determined by the
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Points to the actual number of bytes written to pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionWait(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDPIPE pTdPipe;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if (Length >= sizeof(TD_STACK_ENDPOINT)) {
        /*
         * Ensure we have an address endpoint already
         */
        if (pTdPipe->pAddressEndpoint != NULL) {
            /*
             * Wait for a new virtual circuit connection.
             */
            Status = _TdWaitForListen(pTd, pTdPipe->pAddressEndpoint);
            if (NT_SUCCESS(Status)) {
                /*
                 * The listen was successful.
                 * Return the existing address endpoint as the connection endpoint
                 * and forget that we have an address endpoint anymore.
                 */
                pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
                pStackEndpoint->pEndpoint = pTdPipe->pAddressEndpoint;
                pTdPipe->pAddressEndpoint = NULL;
            }
            else {
                goto done;
            }
        }
        else {
            Status = STATUS_DEVICE_NOT_READY;
            goto done;
        }
    }
    else {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto done;
    }

done:
    return Status;
}


/*******************************************************************************
 * DeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 ******************************************************************************/
NTSTATUS DeviceConnectionSend(PTD pTd)
{
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceConnectionRequest
 *
 *  Initiate a connection to the specified remote address
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pRemoteAddress (input)
 *       Pointer to remote address to connect to
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Pointer to location to return length of pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionRequest(
        PTD pTd,
        PICA_STACK_ADDRESS pRemoteAddress,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pConnectionEndpoint;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    ASSERT( pRemoteAddress );
    if (pRemoteAddress != NULL) {
        /*
         * Initialize return buffer size
         */
        *BytesReturned = sizeof(TD_STACK_ENDPOINT);

        /*
         * Verify output endpoint buffer is large enough
         */
        if (Length >= sizeof(TD_STACK_ENDPOINT)) {
            pTdPipe = (PTDPIPE) pTd->pPrivate;

            /*
             * Create an endpoint which we will use to connect with
             */
            Status = _TdOpenEndpoint(pTd, pRemoteAddress, &pConnectionEndpoint);
            if (NT_SUCCESS(Status)) {
                /*
                 * Attempt to connect to the specified remote address
                 */
                Status = _TdConnectRequest(pTd, pConnectionEndpoint);
                if (NT_SUCCESS(Status)) {
                    /*
                     * Fill in the stack endpoint structure to be returned
                     */
                    pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
                    pStackEndpoint->pEndpoint = pConnectionEndpoint;

                    /*
                     * Save a pointer to the connection endpoint
                     */
                    pTdPipe->pConnectionEndpoint = pConnectionEndpoint;

                    /*
                     * Save the file/device objects for I/O in the TD structure
                     */
                    pTd->pFileObject = pConnectionEndpoint->pFileObject;
                    pTd->pDeviceObject = pConnectionEndpoint->pDeviceObject;

                    return STATUS_SUCCESS;
                }
                else {
                    goto badconnect;
                }
            }
            else {
                goto badcreate;
            }
        }
        else {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto buftoosmall;
        }
    }
    else {
        return STATUS_INVALID_PARAMETER;
    }


/*=============================================================================
==   Error returns
=============================================================================*/

badconnect:
    _TdCloseEndpoint(pTd, pConnectionEndpoint);

badcreate:
buftoosmall:
    return Status;
}


/*******************************************************************************
 * DeviceIoctl
 *
 *  Query/Set configuration information for the td.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS DeviceIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceInitializeRead
 ******************************************************************************/
NTSTATUS DeviceInitializeRead(PTD pTd, PINBUF pInBuf)
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    irp = pInBuf->pIrp;
    irpSp = IoGetNextIrpStackLocation(irp);

    /*
     * Set the major function code and read parameters.
     */
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->Parameters.Read.Length = pTd->InBufHeader + pTd->OutBufLength;

    ASSERT(irp->MdlAddress == NULL);

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if (pTd->pDeviceObject->Flags & DO_BUFFERED_IO) {
        /*
         * The target device supports buffered I/O operations.  Since our
         * input buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to our input buffer.  No buffer copying
         * will be required.
         */
        irp->AssociatedIrp.SystemBuffer = pInBuf->pBuffer;
        irp->UserBuffer = pInBuf->pBuffer;
        irp->Flags |= IRP_BUFFERED_IO;
    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {
        /*
         * The target device supports direct I/O operations.
         * A MDL is preallocated in the PTD and never freed by the
         * Device level TD.  So just initialize it here.
         */
        MmInitializeMdl( pInBuf->pMdl, pInBuf->pBuffer, pTd->InBufHeader+pTd->OutBufLength );
        MmBuildMdlForNonPagedPool( pInBuf->pMdl );
        irp->MdlAddress = pInBuf->pMdl;
    } else {
        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        irp->UserBuffer = pInBuf->pBuffer;
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceSubmitRead
 *
 * Submit the read IRP to the driver.
 ******************************************************************************/
NTSTATUS DeviceSubmitRead(PTD pTd, PINBUF pInBuf)
{
    return IoCallDriver(pTd->pDeviceObject, pInBuf->pIrp);
}


/*******************************************************************************
 * DeviceWaitForRead
 ******************************************************************************/
NTSTATUS DeviceWaitForRead(PTD pTd)
{
    /*
     * Just wait on the input event and return the wait status
     */
    return IcaWaitForSingleObject(pTd->pContext, &pTd->InputEvent, -1);
}


/*******************************************************************************
 * DeviceReadComplete
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location to return byte count read
 ******************************************************************************/
NTSTATUS DeviceReadComplete(PTD pTd, PUCHAR pBuffer, PULONG pByteCount)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceInitializeWrite
 ******************************************************************************/
NTSTATUS DeviceInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP Irp;
    PIO_STACK_LOCATION _IRPSP;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TDPIPE: DeviceInitializeWrite Entry\n" ));

    Irp = pOutBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation(Irp);

    /*
     * Setup a WRITE IRP
     */
    _IRPSP->MajorFunction = IRP_MJ_WRITE;
    _IRPSP->Parameters.Write.Length = pOutBuf->ByteCount;

    ASSERT(Irp->MdlAddress == NULL);

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if (pTd->pDeviceObject->Flags & DO_BUFFERED_IO) {
        /*
         * The target device supports buffered I/O operations.  Since our
         * output buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to the output buffer.  No buffer copying
         * will be required.
         */
        Irp->AssociatedIrp.SystemBuffer = pOutBuf->pBuffer;
        Irp->UserBuffer = pOutBuf->pBuffer;
        Irp->Flags |= IRP_BUFFERED_IO;
    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {
        /*
         * The target device supports direct I/O operations.
         * Initialize the MDL and point to it from the IRP.
         *
         * This MDL is allocated for every OUTBUF, and free'd with it.
         */
        MmInitializeMdl( pOutBuf->pMdl, pOutBuf->pBuffer, pOutBuf->ByteCount );
        MmBuildMdlForNonPagedPool( pOutBuf->pMdl );
        Irp->MdlAddress = pOutBuf->pMdl;
    } else {
        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        Irp->UserBuffer = pOutBuf->pBuffer;
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceWaitForStatus
 *
 *  Wait for device status to change (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceWaitForStatus(PTD pTd)
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 * DeviceCancelIo
 *
 *  cancel all current and future i/o
 ******************************************************************************/
NTSTATUS DeviceCancelIo(PTD pTd)
{
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *  DeviceQueryRemoteAddress
 *
 *   not supported for Pipe transport
 ******************************************************************************/
NTSTATUS
DeviceQueryRemoteAddress(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG EndpointSize,
    PVOID pOutputAddress,
    ULONG OutputAddressSize,
    PULONG BytesReturned)
{
    //
    //  unsupported for Async
    //
    return STATUS_NOT_SUPPORTED;
}

/*******************************************************************************
 *  DeviceQueryLocalIPAddress
 *
 *   not supported for Pipe transport
 ******************************************************************************/
NTSTATUS
DeviceQueryLocalAddress( 
    PTD pTd, 
    PVOID pOutputAddress, 
    ULONG OutputAddressSize, 
    PULONG BytesReturned)
{
    //
    //  unsupported for Pipe
    //
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceSetParams
 *
 *  Set device pararameters (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceSetParams(PTD pTd)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceGetLastError
 *
 *  This routine returns the last transport error code and message
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLastError (output)
 *       address to return information on last transport error
 ******************************************************************************/
NTSTATUS DeviceGetLastError(PTD pTd, PICA_STACK_LAST_ERROR pLastError)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdOpenEndpoint
 *
 *  Open a new endpoint object
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pPipeName (input)
 *       Pointer to ICA_STACK_ADDRESS containing pipe name
 *    ppEndpoint (output)
 *       Pointer to location to return TD_ENDPOINT pointer
 ******************************************************************************/
NTSTATUS _TdOpenEndpoint(
        IN PTD pTd,
        IN PICA_STACK_ADDRESS pPipeName,
        OUT PTD_ENDPOINT *ppEndpoint)
{
    ULONG Length;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;
    

    /*
     * Allocate an endpoint object and room for the pipe name
     */
    if (pPipeName == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    Length = wcslen( (PWSTR)pPipeName ) * sizeof( WCHAR );
    pEndpoint = IcaStackAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(*pEndpoint) + Length + sizeof(UNICODE_NULL),
                    'ipDT' );
    if (pEndpoint != NULL) {
        RtlZeroMemory(pEndpoint, sizeof(*pEndpoint));
        Status = IcaCreateHandle( (PVOID)pEndpoint, sizeof(*pEndpoint) + Length + sizeof(UNICODE_NULL), &pEndpoint->hConnectionEndPointIcaHandle );
        if (!NT_SUCCESS(Status)) {
            IcaStackFreePool(pEndpoint);
            return Status;
        }

        /*
         * Build the pipe name UNICODE_STRING and copy it
         */
        pEndpoint->PipeName.Length = (USHORT)Length;
        pEndpoint->PipeName.MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        pEndpoint->PipeName.Buffer = (PWCHAR)(pEndpoint + 1);
        RtlCopyMemory( pEndpoint->PipeName.Buffer, pPipeName, Length );

        *ppEndpoint = pEndpoint;
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


/*******************************************************************************
 * _TdCloseEndpoint
 *
 *  Close an endpoint object
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdCloseEndpoint(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;
    NTSTATUS Status2;
    PVOID pContext;
    ULONG ContextLength;

    /*
     * If we have a file object, then dereference it and
     * close the corresponding file handle.
     */
    if ( pEndpoint->pFileObject ) {
        ASSERT( pEndpoint->pDeviceObject );

        /* This ZwFsControlFile and following lines were taken out because
           in npfs.sys the FSCTL_PIPE_DISCONNECT causes data in the pipe's internal
           buffers to be thrown out.  This means if the shadower end of the pipe (the
           passthru stack) has sent out a partial packet to his client, he will never
           get the rest of it, which is BAD!
        */
#ifdef notdef
        Status = ZwFsControlFile(
                    pEndpoint->PipeHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    FSCTL_PIPE_DISCONNECT,
                    NULL,
                    0,
                    NULL,
                    0 );
        if ( Status == STATUS_PENDING ) {
            Status = IcaWaitForSingleObject( pTd->pContext,
                                             &pEndpoint->pFileObject->Event,
                                             -1 );
            if ( NT_SUCCESS( Status ) ) {
                Status = IoStatus.Status;
            }
        }
        /*
         * Status should be either SUCCESS,
         * PIPE_DISCONNECTED if the server end is already disconnected,
         * or ILLEGAL_FUNCTION if this is the client end of the pipe.
         */
        ASSERT( Status == STATUS_SUCCESS ||
                Status == STATUS_PIPE_DISCONNECTED ||
                Status == STATUS_ILLEGAL_FUNCTION ||
                Status == STATUS_CTX_CLOSE_PENDING );
#endif

        ObDereferenceObject( pEndpoint->pFileObject );
        pEndpoint->pFileObject = NULL;
        pEndpoint->pDeviceObject = NULL;

        ASSERT( pEndpoint->PipeHandle );
        ASSERT( pEndpoint->PipeHandleProcess == IoGetCurrentProcess() );
        ZwClose( pEndpoint->PipeHandle );
        pEndpoint->PipeHandle = NULL;
        pEndpoint->PipeHandleProcess = NULL;
    }

    /*
     * If the Enpoint has a handle, close it.
     */

    if (pEndpoint->hConnectionEndPointIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
    }

    /*
     * Free the endpoint object (this also free's the pipe name string)
     */
    IcaStackFreePool(pEndpoint);
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdStartListen
 *
 *  Initialize an endpoint for listening
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdStartListen(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    OBJECT_ATTRIBUTES Obja;
    LARGE_INTEGER Timeout;
    IO_STATUS_BLOCK IoStatus;
    HANDLE pipeHandle;
    PFILE_OBJECT pipeFileObject;
    NTSTATUS Status;

    InitializeObjectAttributes(
            &Obja,
            &pEndpoint->PipeName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

    Timeout.QuadPart = -10 * 1000 * 5000;   // 5 seconds

    /*
     * Create the server side of the pipe
     */
    Status = ZwCreateNamedPipeFile(
            &pipeHandle,
            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
            &Obja,
            &IoStatus,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_CREATE,
            0,
            FILE_PIPE_MESSAGE_TYPE,
            FILE_PIPE_MESSAGE_MODE,
            FILE_PIPE_QUEUE_OPERATION,
            1,
            1024,        /* inbound  */
            1024 * 20,   /* outbound */
            &Timeout);
    if (NT_SUCCESS(Status)) {
        /*
         * Get a pointer reference to the pipe object
         */
        Status = ObReferenceObjectByHandle(
                pipeHandle,
                0L,                         // DesiredAccess
                NULL,
                KernelMode,
                (PVOID *)&pipeFileObject,
                NULL);
        ASSERT(NT_SUCCESS(Status));

        /*
         * Initialize the endpoint object and return a pointer to it
         */
        pEndpoint->PipeHandle = pipeHandle;
        pEndpoint->PipeHandleProcess = IoGetCurrentProcess();
        pEndpoint->pFileObject = pipeFileObject;
        pEndpoint->pDeviceObject = IoGetRelatedDeviceObject(pipeFileObject);

        Status = STATUS_SUCCESS;
    }
    else {
        TRACE((pTd->pContext, TC_TD, TT_ERROR,
                "TDPIPE: _TdStartListen failed (lx)\n", Status));
    }

    return Status;
}


/*******************************************************************************
 * _TdWaitForListen
 *
 *  For for an incoming connection request and accept it
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer to Address endpoint object
 ******************************************************************************/
NTSTATUS _TdWaitForListen(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    PTDPIPE pTdPipe;
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;

    /*
     *  Get pointer to PIPE parameters
     */
    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Wait for a connection attempt to arrive.
     */
    Status = ZwFsControlFile(
            pEndpoint->PipeHandle,
            NULL,
            NULL,
            NULL,
            &pTdPipe->IoStatus,
            FSCTL_PIPE_LISTEN,
            NULL,
            0,
            NULL,
            0);
    if (Status == STATUS_PENDING) {
        /*
         * Increment the pointer reference count so the file
         * doesn't go away while we're waiting below.
         */
        pFileObject = pEndpoint->pFileObject;
        Status = ObReferenceObjectByPointer( pEndpoint->pFileObject,
                                             SYNCHRONIZE,
                                             *IoFileObjectType,
                                             KernelMode );
        ASSERT( Status == STATUS_SUCCESS );

        Status = IcaWaitForSingleObject( pTd->pContext,
                                         &pFileObject->Event,
                                         10000 );

        ObDereferenceObject( pFileObject );
        if ( Status == STATUS_TIMEOUT ) {
            ZwFsControlFile( pEndpoint->PipeHandle,
                             NULL,
                             NULL,
                             NULL,
                             &pTdPipe->IoStatus,
                             FSCTL_PIPE_DISCONNECT,
                             NULL,
                             0,
                             NULL,
                             0 );
            Status = STATUS_IO_TIMEOUT;
        } else if ( NT_SUCCESS( Status ) ) {
            Status = pTdPipe->IoStatus.Status;
        }
    }

    // Let pipe connected go thru since it means the client beat us to the pipe
    else {
        if (!NT_SUCCESS( Status ) && (Status != STATUS_PIPE_CONNECTED))
            goto badlisten;
    }

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badlisten:
    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR,
                "TDPIPE: _TdWaitForListen failed(lx)\n", Status));
    }
    return Status;
}


/*******************************************************************************
 * _TdConnectRequest
 *
 *  Attempt to connect to a remote address
 ******************************************************************************/
NTSTATUS _TdConnectRequest(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatus;
    HANDLE pipeHandle;
    PFILE_OBJECT pipeFileObject;
    NTSTATUS Status;

    InitializeObjectAttributes(
            &Obja,
            &pEndpoint->PipeName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

    /*
     * Open the client end of the pipe
     */
    Status = ZwCreateFile(
            &pipeHandle,
            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
            &Obja,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE,
            NULL,
            0 );
    if (NT_SUCCESS(Status)) {
        /*
         * Get a pointer reference to the pipe object
         */
        Status = ObReferenceObjectByHandle(
                pipeHandle,
                0L,                         // DesiredAccess
                NULL,
                KernelMode,
                (PVOID *)&pipeFileObject,
                NULL);
        ASSERT(NT_SUCCESS(Status));

        /*
         * Initialize the endpoint object and return a pointer to it
         */
        pEndpoint->PipeHandle = pipeHandle;
        pEndpoint->PipeHandleProcess = IoGetCurrentProcess();
        pEndpoint->pFileObject = pipeFileObject;
        pEndpoint->pDeviceObject = IoGetRelatedDeviceObject( pipeFileObject );

        Status = STATUS_SUCCESS;
    }
    else {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            TRACE((pTd->pContext, TC_TD, TT_ERROR,
                    "TDPIPE: _TdConnectRequest failed (lx)\n", Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdicom\tdtdi.h ===
/***************************************************************************
*
* tdtdi.h
*
* This module contains internal defines and structures for TDI based TDs.
*
* Copyright 1998 Microsoft
*  
*  
****************************************************************************/

typedef enum _ENDPOINT_TYPE {
    TdiAddressObject,
    TdiConnectionStream,
    TdiConnectionDatagram
} ENDPOINT_TYPE;

/*
 * TD stack endpoint structure.
 *
 * This is registered with ICADD.SYS to create a "handle" that can be returned
 * to ICASRV to represent a connection in a secure manner.
 */
typedef struct _TD_STACK_ENDPOINT {
    ULONG AddressType;              // Address type (family) for this endpoint
    struct _TD_ENDPOINT *pEndpoint; // Pointer to real endpoint structure
} TD_STACK_ENDPOINT, *PTD_STACK_ENDPOINT;

/*
 * TD endpoint structure
 *
 * This structure contains all information about an endpoint.
 * An endpoint may be either an address endpoint or a connection endpoint.
 */
typedef struct _TD_ENDPOINT {

    NTSTATUS Status;


    HANDLE TransportHandle;
    PEPROCESS TransportHandleProcess;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING TransportName;
    PTRANSPORT_ADDRESS pTransportAddress;
    ULONG TransportAddressLength;
    PTRANSPORT_ADDRESS pRemoteAddress;
    ULONG RemoteAddressLength;
    ENDPOINT_TYPE EndpointType;

    // This protects the following fields
    KSPIN_LOCK Spinlock;

    // These fields are only used on Address endpoints
    LIST_ENTRY ConnectedQueue;
    LIST_ENTRY AcceptQueue;
    LIST_ENTRY ConnectionQueue;
    ULONG      ConnectionQueueSize;
    BOOLEAN    ConnectIndicationRegistered;
    BOOLEAN    DisconnectIndicationRegistered;
    BOOLEAN    RecvIndicationRegistered;
    KEVENT     AcceptEvent;
    BOOLEAN    Waiter;

    // This is used on Connection endpoints
    HANDLE hIcaHandle;      // Handle for TD_STACK_ENDPOINT
    BOOLEAN    Connected;
    BOOLEAN    Disconnected;
    PIRP       AcceptIrp;
    LIST_ENTRY ReceiveQueue;
    LIST_ENTRY ConnectionLink;
    TDI_CONNECTION_INFORMATION SendInfo;
    ULONG      RecvBytesReady;
    HANDLE hConnectionEndPointIcaHandle;  // handle for TD_ENDPOINT (this structure)
    HANDLE hTransportAddressIcaHandle;    // handle for TRANSPORT_ADDRESS

} TD_ENDPOINT, *PTD_ENDPOINT;


/*
 *  TDI TD structure
 */
typedef struct _TDTDI {

    PTD_ENDPOINT pAddressEndpoint;

    PTD_ENDPOINT pConnectionEndpoint;

     ULONG       OutBufDelay;  // Outbuf delay for connection

} TDTDI, * PTDTDI;


/*
*  TDI SocketAddr structure
*/
typedef struct   {
        USHORT  sa_family;
        CHAR    sa_data[1];
} SocketAddr, *PSocketAddr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdtcp\tdtcp.c ===
/****************************************************************************/
// tdtcp.c
//
// TDI based TCP transport specific routines.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <tdi.h>

#include <ntddtcp.h>

#include <tdiinfo.h>
#include <tdistat.h>
#include <ipinfo.h>

#include <winstaw.h>
#define  _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdtcp.h"

#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdtcp";
#endif

#define REGISTRY_SERVICES \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define REGISTRY_TCP_LINKAGE \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Linkage"
#define REGISTRY_TCP_INTERFACES \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"


// \nt\private\inc\tcpinfo.h
#define TCP_SOCKET_NODELAY 1

#define TL_INSTANCE        0

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*=============================================================================
==   External Functions Defined
=============================================================================*/

// These are called by TDICOM
NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceQueryLocalAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TcpGetTransportAddress( PTD, int, PULONG );

VOID
_UnicodeToAnsi(
    CHAR * pAnsiString,
    ULONG lAnsiMax,
    WCHAR * pUnicodeString
    );

unsigned long
_inet_addr(
    IN const char *cp
    );

NTSTATUS
_TcpSetNagle(
    IN PFILE_OBJECT   pFileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN        Flag
    );

NTSTATUS
_TdiTcpSetInformation (
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

NTSTATUS
_OpenRegKey(
    PHANDLE HandlePtr,
    PWCHAR KeyName
    );

NTSTATUS
_GetRegDWORDValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PULONG ValueData
    );

NTSTATUS
_GetRegStringValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT ValueSize
    );

NTSTATUS
_GetRegMultiSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData
    );

NTSTATUS
_GetRegSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData,
    PULONG ValueType
    );

PWCHAR
_EnumRegMultiSz(
    PWCHAR MszString,
    ULONG MszStringLength,
    ULONG StringIndex
    );

VOID
GetGUID(
    OUT PUNICODE_STRING szGuid ,
    IN  int Lana
    );



/*=============================================================================
==   Global variables
=============================================================================*/

USHORT TdiDeviceEndpointType = TdiConnectionStream; // tdicom\tdtdi.h
USHORT TdiDeviceAddressType = TDI_ADDRESS_TYPE_IP;  // TDI address type
USHORT TdiDeviceInBufHeader = 0;  // For packet oriented protocols

/*******************************************************************************
 *
 * TdiDeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpenEndpoint(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG IcaEndpointLength
    )
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    BOOLEAN Flag;

    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * JohnR: Adaptive TCP flow control. 03/02/97
     *
     *        If the OutBufDelay is 0, there is no OutBuf timer,
     *        and no Nagles. This setting is for the most response time
     *        sensitive networks with the side effect of sending smaller
     *        segments.
     *
     *        If the OutBufDelay is greater than 1, the standard CITRIX
     *        ICA timer is used to determine at the WD level when to
     *        send a segment. No nagling is enabled since the extra
     *        delay would not be benefitial.
     *
     *        The new OutBufDelay == 1, means that the WD will treat the
     *        OutBufDelay as if it were 0, but the TCP code will enable
     *        the "Nagle" algorithum. This algorithum will send data
     *        immediately if no un-acknowledged segments are outstanding,
     *        OR if half of the send window is filled. If not, data is
     *        stored locally until either a segment acknowledge comes in,
     *        or more data is sent causing half the send window to fill.
     *        This has the advantage of dynamically sizing our "outbuf timer"
     *        to be the round trip time of the network, and not some
     *        arbritrary fixed value.
     */
    if( pTdTdi->OutBufDelay == 1 ) {
        /*
         * OutBufDelay == 1 means NAGLE only.
         */
        Flag = TRUE;
    }
    else {
        /*
         * Turn off nagling for any OutBufDelay timer value, or 0
         */
        Flag = FALSE;
    }

    Status = _TcpSetNagle(
                 pTd->pFileObject,
                 pTd->pDeviceObject,
                 Flag
                 );

    DBGPRINT(("TdiDeviceOpenEndpoint: SetNagle 0x%x Result 0x%x\n",Flag,Status));

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildTransportNameAndAddress
 *
 *  Build the Transport Name and Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pLocalAddress (input)
 *     pointer to local address to use (OPTIONAL)
 *   pTransportName (output)
 *     pointer to UNICODE_STRING to return transport name
 *     NOTE: the buffer pointed to be pTransportName.Buffer must
 *           be free'd by the caller
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildTransportNameAndAddress(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PUNICODE_STRING pTransportName,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_IP pIpAddress;
    int Lana;
    NTSTATUS Status;

    /*
     * For TCP, the transport device name is fixed,
     * so just allocate and initialize the transport name string here.
     */
    Status = MemoryAllocate( sizeof(DD_TCP_DEVICE_NAME), &pTransportName->Buffer );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc1;
    wcscpy( pTransportName->Buffer, DD_TCP_DEVICE_NAME );
    pTransportName->Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(UNICODE_NULL);
    pTransportName->MaximumLength = pTransportName->Length + sizeof(UNICODE_NULL);

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IP);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc2;

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pIpAddress = (PTDI_ADDRESS_IP)(*ppTransportAddress)->Address[0].Address;
    pIpAddress->sin_port = htons( (USHORT)pTd->PortNumber );
    RtlZeroMemory( pIpAddress->sin_zero, sizeof(pIpAddress->sin_zero) );

    /*
     * If a local address is specified, then use it.
     */
    if ( pLocalAddress ) {

        /*
         * Skip over the address family(type) data (bytes 0&1) of the
         * local address struct, and copy the remainder of the address
         * directly to the Address field of the TransportAddress struct.
         */
        ASSERT( *(PUSHORT)pLocalAddress == TDI_ADDRESS_TYPE_IP );
        RtlCopyMemory( pIpAddress, &((PCHAR)pLocalAddress)[2], sizeof(TDI_ADDRESS_IP) );

    /*
     * There was no local address specified.
     * In this case, we use the LanAdapter value from the PDPARAMS
     * structure to lookup the corresponding IP address.
     */
    } else if ( (Lana = pTd->Params.Network.LanAdapter) ) {
        ULONG in_addr;

        /*
         * Get Local Address Information
         */
        Status = _TcpGetTransportAddress( pTd, Lana, &in_addr );
        if ( !NT_SUCCESS( Status ) )
            goto badadapterdata;
        pIpAddress->in_addr = in_addr;
    
    /*
     * No LanAdapter value was specified, so use the wildcard address (zero)
     */
    } else {
        pIpAddress->in_addr = 0;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badadapterdata:
    MemoryFree( *ppTransportAddress );

badmalloc2:
    MemoryFree( pTransportName->Buffer );

badmalloc1:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceQueryLocalAddress
 *
 *  Query Transport Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceQueryLocalAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_IP pIpAddress;
    int Lana;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IP);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc;

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pIpAddress = (PTDI_ADDRESS_IP)(*ppTransportAddress)->Address[0].Address;
    pIpAddress->sin_port = htons( (USHORT)pTd->PortNumber );
    RtlZeroMemory( pIpAddress->sin_zero, sizeof(pIpAddress->sin_zero) );

    //In this case, we use the LanAdapter value from the PDPARAMS
    // structure to lookup the corresponding IP address.
    
    if ( (Lana = pTd->Params.Network.LanAdapter) ) {
        ULONG in_addr;

        /*
         * Get Local Address Information
         */
        Status = _TcpGetTransportAddress( pTd, Lana, &in_addr );
        if ( !NT_SUCCESS( Status ) )
            goto badadapterdata;
        pIpAddress->in_addr = in_addr;    
    /*
     * No LanAdapter value was specified, so use the wildcard address (zero)
     */
    } else {
        pIpAddress->in_addr = 0;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badadapterdata:
    MemoryFree( *ppTransportAddress );
    *ppTransportAddress = NULL;

badmalloc:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildWildcardAddress
 *
 *  Build a wildcard Address for this protocol.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppWildcardAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pWildcardAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildWildcardAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppWildcardAddress,
    PULONG pWildcardAddressLength
    )
{
    PTDI_ADDRESS_IP pIpAddress;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pWildcardAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IP);
    Status = MemoryAllocate( *pWildcardAddressLength, ppWildcardAddress );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Initialize the static part of the transport address
     */
    (*ppWildcardAddress)->TAAddressCount = 1;
    (*ppWildcardAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    (*ppWildcardAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pIpAddress = (PTDI_ADDRESS_IP)(*ppWildcardAddress)->Address[0].Address;
    pIpAddress->sin_port = 0;
    pIpAddress->in_addr = 0;
    RtlZeroMemory( pIpAddress->sin_zero, sizeof(pIpAddress->sin_zero) );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceWaitForDatagramConnection
 *
 *  Wait for a datagram connection request, validate it,
 *  and return the remote transport address of the connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object to wait for a connection on
 *   ppRemoteAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pRemoteAddressLength (output)
 *     pointer to location to return RemoteAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceWaitForDatagramConnection(
    PTD pTd,
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS *ppRemoteAddress,
    PULONG pRemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*****************************************************************************
 *
 *  TdiDeviceCompleteDatagramConnection
 *
 *  Do any final work to complete a datagram connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object for this connection
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceCompleteDatagramConnection(
    PTD pTd, 
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS pRemoteAddress,
    ULONG RemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*******************************************************************************
 *
 *  TdiDeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
    pClient->TdVersionL = VERSION_HOSTL_TDTCP;
    pClient->TdVersionH = VERSION_HOSTH_TDTCP;
    pClient->TdVersion  = VERSION_HOSTH_TDTCP;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TdiDeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TcpGetTransportAddress
 *
 *  Get TCP transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number, 1-based based on the tscc.msc UI ordering.
 *     pIpAddr (output)
 *        address to return IP address
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

#if 0 // replacement below

NTSTATUS _TcpGetTransportAddress(PTD pTd, int Lana, PULONG pIpAddr)
{
    HANDLE KeyHandle;
    UNICODE_STRING RouteString;
    PWCHAR pInterfaceGuid;
    NTSTATUS Status;
    unsigned Len;
    PWCHAR Str;

    /*
     * Open the Tcp Linkage key
     */
    Status = _OpenRegKey( &KeyHandle, REGISTRY_TCP_LINKAGE );
    if ( !NT_SUCCESS( Status ) )
        goto badopen;

    /*
     * Alloc and read in the linkage route multi-string.
     *
     * This is of the form (including the double quotes):
     * "{<guid>}"\0"{<guid>}"\0"NdisWanIp"\0\0
     *
     * Each of the GUIDs is a link to the adapter interface keys
     * stored at HKLM\System\CCS\Services\tcpip\Parameters\Interfaces,
     * inside of which is the IP address information.
     */
    RouteString.Length = 0;
    RouteString.MaximumLength = 0;
    RouteString.Buffer = NULL;
    Status = _GetRegMultiSZValue( KeyHandle, L"Route", &RouteString );
    ZwClose( KeyHandle );
    if ( !NT_SUCCESS( Status ) )
        goto badvalue;

    /*
     * Find the interface GUID that corresponds to the specified UI LANA
     * index. The LANA index corresponds to the registry ordering of the
     * interfaces, skipping the PPP interface(s). From the way the
     * registry looks PPP interfaces do not have GUIDs specified in
     * the Linkage key, so we skip the non-GUID entries.
     */
    if (RouteString.Length < (2 * sizeof(WCHAR))) {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }
    Len = RouteString.Length;
    Str = RouteString.Buffer;
    for (;;) {
        // Check current string to see if it's a GUID (it must start with an
        // open brace after initial double-quote).
        if (Str[1] == L'{') {
            // Have we found it?
            if (Lana == 1)
                break;
            Lana--;
        }

        // Skip through current string past NULL.
        while (Len >= sizeof(WCHAR)) {
            Len -= sizeof(WCHAR);
            if (*Str++ == UNICODE_NULL)
                break;
        }

        // Check for index out of range.
        if (Len < (2 * sizeof(UNICODE_NULL))) {
            Status = STATUS_DEVICE_DOES_NOT_EXIST;
            goto PostAllocRouteString;
        }
    }
    if (Len >= (2 * sizeof(UNICODE_NULL))) {
        ULONG DhcpEnabled;
        UNICODE_STRING IpAddrString;
        UNICODE_STRING KeyString;
        WCHAR KeyName[256];
        char AnsiBuf[256];

        // Skip the initial double quote, and change the ending quote to a
        // NULL.
        Str++;
        pInterfaceGuid = Str;
        while (*Str != L'\"')
            Str++;
        *Str = L'\0';

        /*
         * Use the GUID to look up the interface IP info.
         */

        // We open HKLM\System\CCS\Services\tcpip\Parameters\Interfaces\<GUID>
        // to get to the DHCP and IP address information.
        KeyString.Length = 0;
        KeyString.MaximumLength = sizeof(KeyName);
        KeyString.Buffer = KeyName;
        RtlAppendUnicodeToString(&KeyString, REGISTRY_TCP_INTERFACES);
        RtlAppendUnicodeToString(&KeyString, pInterfaceGuid);
        Status = _OpenRegKey(&KeyHandle, KeyName);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Query the "EnableDHCP" value.
        Status = _GetRegDWORDValue(KeyHandle, L"EnableDHCP", &DhcpEnabled);
        if (!NT_SUCCESS(Status)) {
            ZwClose(KeyHandle);
            goto PostAllocRouteString;
        }

        IpAddrString.Length = 0;
        IpAddrString.MaximumLength = 0;
        IpAddrString.Buffer = NULL;
        if (DhcpEnabled) {
            ULONG ValueType;

            // If DHCP is enabled for this device, then we query the current
            // IP address from the "DhcpIPAddress" value.
            Status = _GetRegSZValue(KeyHandle, L"DhcpIPAddress",
                    &IpAddrString, &ValueType);
        }
        else {
            // DHCP is not enabled for this device, so we query the
            // IP address from the "IPAddress" value.
            Status = _GetRegMultiSZValue(KeyHandle, L"IPAddress",
                    &IpAddrString);
        }
        ZwClose(KeyHandle);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Convert IP address from Unicode to ansi to a ULONG.
        _UnicodeToAnsi(AnsiBuf, sizeof(AnsiBuf) - 1, IpAddrString.Buffer);

        *pIpAddr = _inet_addr(AnsiBuf);

        MemoryFree(IpAddrString.Buffer);
    }
    else {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }

PostAllocRouteString:
    MemoryFree(RouteString.Buffer);

badvalue:
badopen:
    return Status;
}
#endif

/*******************************************************************************
 *
 *  _TcpGetTransportAddress(2)
 *
 *  Get TCP transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number, 1-based based on the tscc.msc UI ordering.
 *     pIpAddr (output)
 *        address to return IP address
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS _TcpGetTransportAddress(PTD pTd, int Lana, PULONG pIpAddr)
{
    HANDLE KeyHandle;
    UNICODE_STRING RouteString;
    PWCHAR pInterfaceGuid;
    NTSTATUS Status;
    unsigned Len;
    PWCHAR Str;

    
    RtlInitUnicodeString( &RouteString , NULL );

    GetGUID( &RouteString , Lana );

    Len = RouteString.Length;    
    Str = RouteString.Buffer;

    KdPrint( ( "TDTCP: _TcpGetTransportAddress Length = %d GUID = %ws\n" , Len , Str ) );

    if( Str == NULL )
    {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if (Len >= (2 * sizeof(UNICODE_NULL))) {
        ULONG DhcpEnabled;
        UNICODE_STRING IpAddrString;
        UNICODE_STRING KeyString;
        WCHAR KeyName[256];
        char AnsiBuf[256];

        pInterfaceGuid = Str;

        // Skip the initial double quote, and change the ending quote to a
        // NULL.
        /*
        Str++;
        pInterfaceGuid = Str;
        while (*Str != L'\"')
            Str++;
        *Str = L'\0';
        */

        /*
         * Use the GUID to look up the interface IP info.
         */

        // We open HKLM\System\CCS\Services\tcpip\Parameters\Interfaces\<GUID>
        // to get to the DHCP and IP address information.
        KeyString.Length = 0;
        KeyString.MaximumLength = sizeof(KeyName);
        KeyString.Buffer = KeyName;
        RtlAppendUnicodeToString(&KeyString, REGISTRY_TCP_INTERFACES);
        RtlAppendUnicodeToString(&KeyString, pInterfaceGuid);
        Status = _OpenRegKey(&KeyHandle, KeyName);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Query the "EnableDHCP" value.
        Status = _GetRegDWORDValue(KeyHandle, L"EnableDHCP", &DhcpEnabled);
        if (!NT_SUCCESS(Status)) {
            ZwClose(KeyHandle);
            goto PostAllocRouteString;
        }

        IpAddrString.Length = 0;
        IpAddrString.MaximumLength = 0;
        IpAddrString.Buffer = NULL;
        if (DhcpEnabled) {
            ULONG ValueType;

            // If DHCP is enabled for this device, then we query the current
            // IP address from the "DhcpIPAddress" value.
            Status = _GetRegSZValue(KeyHandle, L"DhcpIPAddress",
                    &IpAddrString, &ValueType);
        }
        else {
            // DHCP is not enabled for this device, so we query the
            // IP address from the "IPAddress" value.
            Status = _GetRegMultiSZValue(KeyHandle, L"IPAddress",
                    &IpAddrString);
        }
        ZwClose(KeyHandle);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Convert IP address from Unicode to ansi to a ULONG.
        _UnicodeToAnsi(AnsiBuf, sizeof(AnsiBuf) - 1, IpAddrString.Buffer);

        *pIpAddr = _inet_addr(AnsiBuf);

        MemoryFree(IpAddrString.Buffer);
    }
    else {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }

PostAllocRouteString:

    if( RouteString.Buffer != NULL )
    {
        MemoryFree(RouteString.Buffer);
    }

    return Status;
}

/*******************************************************************************
 *
 *  _UnicodeToAnsi
 *
 *     convert a UNICODE (WCHAR) string into an ANSI (CHAR) string
 *
 * ENTRY:
 *
 *    pAnsiString (output)
 *       buffer to place ANSI string into
 *    lAnsiMax (input)
 *       maximum number of characters to write into pAnsiString
 *    pUnicodeString (input)
 *       UNICODE string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
_UnicodeToAnsi(
    CHAR * pAnsiString,
    ULONG lAnsiMax,
    WCHAR * pUnicodeString )
{
    ULONG ByteCount;

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString);

    RtlUnicodeToMultiByteN( pAnsiString, lAnsiMax, &ByteCount,
                            pUnicodeString,
                            ((wcslen(pUnicodeString) + 1) << 1) );
}


/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
unsigned long
_inet_addr(
    IN const char *cp
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    cp - A character string representing a number expressed in the
        Internet standard "." notation.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        register unsigned long val, base, n;
        register char c;
        unsigned long parts[4], *pp = parts;
#define INADDR_NONE 0xffffffff
#define htonl(x) ((((x) >> 24) & 0x000000FFL) | \
                 (((x) >>  8) & 0x0000FF00L) | \
                 (((x) <<  8) & 0x00FF0000L) | \
                 (((x) << 24) & 0xFF000000L))

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0') {
                base = 8, cp++;
                if (*cp == 'x' || *cp == 'X')
                        base = 16, cp++;
        }
        
        while (c = *cp) {
                if (isdigit(c)) {
                        val = (val * base) + (c - '0');
                        cp++;
                        continue;
                }
                if (base == 16 && isxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        return ((unsigned long) -1);
                }
                *pp++ = val, cp++;
                goto again;
        }

        /*
         * Check for trailing characters.
         */
        if (*cp && !isspace(*cp)) {
                return (INADDR_NONE);
        }
        *pp++ = val;

        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (unsigned long)(pp - parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (INADDR_NONE);
        }
        val = htonl(val);
        return (val);
}


/*****************************************************************************
 *
 *  _TcpSetNagle
 *
 *   This function turns on, or off the NAGLE algorithum.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
_TcpSetNagle(
    IN PFILE_OBJECT   pFileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN        Flag
    )
{
    NTSTATUS Status;
    ULONG    Value;

    if( Flag ) {
        Value = FALSE;
    }
    else {
        Value = TRUE;
    }

    Status = _TdiTcpSetInformation(
                 pFileObject,
                 DeviceObject,
                 CO_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_CONNECTION,
                 TCP_SOCKET_NODELAY,
                 &Value,
                 sizeof(Value),
                 TRUE
                 );

    DBGPRINT(("_TcpSetNagle: Flag 0x%x, Result 0x%x\n",Flag,Status));

    return( Status );
}


NTSTATUS
_TdiTcpSetInformation (
        IN PFILE_OBJECT   pFileObject,
        IN PDEVICE_OBJECT DeviceObject,
        IN ULONG Entity,
        IN ULONG Class,
        IN ULONG Type,
        IN ULONG Id,
        IN PVOID Value,
        IN ULONG ValueLength,
        IN BOOLEAN WaitForCompletion)

/*++

NOTE: This is a modified routine from WSHTCPIP.C

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

Return Value:

    NTSTATUS code
--*/

{
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX pSetInfoEx;
    PIO_STATUS_BLOCK pIOSB;

    // Allocate space to hold the TDI set information buffers and the IO
    // status block. Note the IOSB is a required field for the lower
    // layers despite the OPTIONAL label in CtxDeviceIoControlFile.
    status = MemoryAllocate(sizeof(*pSetInfoEx) + ValueLength +
            sizeof(IO_STATUS_BLOCK), &pIOSB);
    if (status == STATUS_SUCCESS) {
        // The SetInfoEx is after the I/O status block in this alloc.
        pSetInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)(pIOSB + 1);

        // Initialize the TDI information buffers.
        pSetInfoEx->ID.toi_entity.tei_entity = Entity;
        pSetInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
        pSetInfoEx->ID.toi_class = Class;
        pSetInfoEx->ID.toi_type = Type;
        pSetInfoEx->ID.toi_id = Id;

        RtlCopyMemory(pSetInfoEx->Buffer, Value, ValueLength);
        pSetInfoEx->BufferSize = ValueLength;

        // Make the actual TDI action call. The Streams TDI mapper will
        // translate this into a TPI option management request for us and
        // give it to TCP/IP.
        status = CtxDeviceIoControlFile(pFileObject,
                IOCTL_TCP_SET_INFORMATION_EX, pSetInfoEx,
                sizeof(*pSetInfoEx) + ValueLength, NULL, 0, FALSE, NULL,
                pIOSB, NULL);

        MemoryFree(pIOSB);
    }

#if DBG
    if (!NT_SUCCESS(status)) {
        DBGPRINT(("_TdiTcpSetInformation: Error 0x%x\n",status));
    }
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdtcp\tdtcp.h ===
/***************************************************************************
*
* tdtcp.h
*
* This module contains private Transport Driver defines and structures
*
* Copyright 1998, Microsoft
*
*  
****************************************************************************/


#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

// it seems that ntohs is the same as above since ntohs(htons(x)) = x  and htnos(htons(x)) = x
#define ntohs(x)        htons(x)


#define CITRIX_TCP_PORT  1494  // Offical IANA assigned ICA Port number
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\beep.c ===
/*************************************************************************
*
* beep.c
*
* This module contains routines for managing the Termdd beep channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddbeep.h>


NTSTATUS
IcaDeviceControlBeep(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    CLONG Method;

    // Verify the buffer method.
    Method = IrpSp->Parameters.DeviceIoControl.IoControlCode & 0x03;
    ASSERT( Method == METHOD_BUFFERED );

    if ( Method != METHOD_BUFFERED ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {
        SdIoctl.IoControlCode      = IrpSp->Parameters.DeviceIoControl.IoControlCode;
        SdIoctl.InputBuffer        = Irp->AssociatedIrp.SystemBuffer;
        SdIoctl.InputBufferLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
        SdIoctl.OutputBuffer       = Irp->UserBuffer;
        SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\td\tdpipe\tdpipe.h ===
/***************************************************************************
*
* tdpipe.h
*
* This module contains internal defines and structures for the named pipe TD.
*
* Copyright 1998, Microsoft
*  
****************************************************************************/


/*
 * TD stack endpoint structure
 *
 * This structure is passed on the stack
 */
typedef struct _TD_STACK_ENDPOINT {
//  ULONG AddressType;              // Address type (family) for this endpoint
    struct _TD_ENDPOINT *pEndpoint; // Pointer to real endpoint structure
} TD_STACK_ENDPOINT, *PTD_STACK_ENDPOINT;


/*
 * TD endpoint structure
 *
 * This structure contains all information about an endpoint.
 * An endpoint may be either an address endpoint or a connection endpoint.
 */
typedef struct _TD_ENDPOINT {

    HANDLE PipeHandle;
    PEPROCESS PipeHandleProcess;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING PipeName;
    HANDLE hConnectionEndPointIcaHandle;  // handle for TD_ENDPOINT (this structure)

} TD_ENDPOINT, *PTD_ENDPOINT;


/*
 *  PIPE TD structure
 */
typedef struct _TDPIPE {

    PTD_ENDPOINT pAddressEndpoint;

    PTD_ENDPOINT pConnectionEndpoint;

    IO_STATUS_BLOCK IoStatus;

} TDPIPE, * PTDPIPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\connect.c ===
/*************************************************************************
*
* connect.c
*
* This module contains routines for managing TerminalServer connections.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
IcaDeviceControlConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaStartStopTrace(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PICA_TRACE pTrace
    );

NTSTATUS
IcaUnbindVirtualChannel(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

/*
 * Local procedure prototypes
 */
PICA_CONNECTION _IcaAllocateConnection( VOID );
VOID _IcaFreeConnection( PICA_CONNECTION );


/*
 * Dispatch table for ICA connection objects
 */
PICA_DISPATCH IcaConnectionDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE                   
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE        
    IcaCloseConnection,         // IRP_MJ_CLOSE                    
    NULL,                       // IRP_MJ_READ                     
    NULL,                       // IRP_MJ_WRITE                    
    NULL,                       // IRP_MJ_QUERY_INFORMATION        
    NULL,                       // IRP_MJ_SET_INFORMATION          
    NULL,                       // IRP_MJ_QUERY_EA                 
    NULL,                       // IRP_MJ_SET_EA                   
    NULL,                       // IRP_MJ_FLUSH_BUFFERS            
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION 
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION   
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL        
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL      
    IcaDeviceControlConnection, // IRP_MJ_DEVICE_CONTROL           
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL  
    NULL,                       // IRP_MJ_SHUTDOWN                 
    NULL,                       // IRP_MJ_LOCK_CONTROL             
    IcaCleanupConnection,       // IRP_MJ_CLEANUP                  
    NULL,                       // IRP_MJ_CREATE_MAILSLOT          
    NULL,                       // IRP_MJ_QUERY_SECURITY           
    NULL,                       // IRP_MJ_SET_SECURITY             
    NULL,                       // IRP_MJ_SET_POWER                
    NULL,                       // IRP_MJ_QUERY_POWER              
};

extern PERESOURCE IcaTraceResource;

// resource used to protect access to the code that start/stops the keep alive thread
PERESOURCE   g_pKeepAliveResource;

extern NTSTATUS _IcaKeepAlive( 
        IN BOOLEAN  startKeepAliveThread,
        IN ULONG    interval );

NTSTATUS
IcaCreateConnection (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to create a new ICA_CONNECTION object.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_CONNECTION pConnect;

    /*
     * Allocate a new ICA connect object
     */
    pConnect = _IcaAllocateConnection();
    if ( pConnect == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Save a pointer to the connection in the file object
     * so that we can find it in future calls.
     */
    IrpSp->FileObject->FsContext = pConnect;

    IcaDereferenceConnection( pConnect );

    return( STATUS_SUCCESS );
}


NTSTATUS
IcaDeviceControlConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    ICA_TRACE LocalTrace;
    PICA_TRACE_BUFFER pTraceBuffer;
    ULONG code;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    BOOLEAN bConnectionLocked = FALSE;
    BYTE *Buffer = NULL;
    PICA_KEEP_ALIVE     pKeepAlive;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

#if DBG
    if ( code != IOCTL_ICA_SYSTEM_TRACE && code != IOCTL_ICA_TRACE ) {
        TRACE(( pConnect, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlConnection, fc %d (enter)\n",
                (code & 0x3fff) >> 2 ));
    }
#endif

    try {
        switch ( code ) {
    
            case IOCTL_ICA_SET_SYSTEM_TRACE :

                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_TRACE) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(ICA_TRACE), sizeof(BYTE) );
                }
                LocalTrace = *(PICA_TRACE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite( IcaTraceResource, TRUE );

                try {

                  Status = IcaStartStopTrace( &G_TraceInfo, &LocalTrace );

                } finally {

                  ExReleaseResourceLite( IcaTraceResource );
                  KeLeaveCriticalRegion();
                }
                break;
    
            case IOCTL_ICA_SET_TRACE :
                
                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_TRACE) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }
                LocalTrace = *(PICA_TRACE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                IcaLockConnection( pConnect );
				bConnectionLocked = TRUE;

                Status = IcaStartStopTrace( &pConnect->TraceInfo, &LocalTrace );

                
                if ( !IsListEmpty(&pConnect->StackHead)) {
                    PICA_STACK pStack;
                    pStack = CONTAINING_RECORD( pConnect->StackHead.Flink,
                                                ICA_STACK, StackEntry );
                    SdIoctl.IoControlCode = code;
                    SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                    SdIoctl.OutputBuffer = NULL;
                    SdIoctl.OutputBufferLength = 0;
                    _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);
                }            
                
                IcaUnlockConnection( pConnect );
                break;
    
            case IOCTL_ICA_SYSTEM_TRACE :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) ) 
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }

                pTraceBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite( IcaTraceResource, TRUE );

                try {

                   IcaTraceFormat( &G_TraceInfo,
                                   pTraceBuffer->TraceClass,
                                   pTraceBuffer->TraceEnable,
                                   pTraceBuffer->Data );

                } finally {

                  ExReleaseResourceLite( IcaTraceResource );
                  KeLeaveCriticalRegion();
                }

                Status = STATUS_SUCCESS;
                break;
    
            case IOCTL_ICA_TRACE :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) ) 
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }

                pTraceBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                IcaLockConnection( pConnect );
				bConnectionLocked=TRUE;
                IcaTraceFormat( &pConnect->TraceInfo,
                                pTraceBuffer->TraceClass,
                                pTraceBuffer->TraceEnable,
                                pTraceBuffer->Data );
                IcaUnlockConnection( pConnect );
                Status = STATUS_SUCCESS;
                break;
    
            case IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VIRTUALCHANNELNAME) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(VIRTUALCHANNELNAME), sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                IcaLockConnection( pConnect );
                bConnectionLocked = TRUE;
                Status = IcaUnbindVirtualChannel( pConnect, (PVIRTUALCHANNELNAME)Buffer );
                IcaUnlockConnection( pConnect );

                break;
    
            case IOCTL_ICA_SET_SYSTEM_PARAMETERS:
                // Settings coming from TermSrv, copy to global variable.
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(TERMSRV_SYSTEM_PARAMS))
                    return(STATUS_BUFFER_TOO_SMALL);
                if (Irp->RequestorMode != KernelMode)
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.
                            Type3InputBuffer, sizeof(TERMSRV_SYSTEM_PARAMS),
                            sizeof(BYTE));
                SysParams = *(PTERMSRV_SYSTEM_PARAMS)(IrpSp->Parameters.
                        DeviceIoControl.Type3InputBuffer);
                        Status = STATUS_SUCCESS;
                break;

        case IOCTL_ICA_SYSTEM_KEEP_ALIVE:

                // This should  only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_KEEP_ALIVE ) ) 
                    return( STATUS_BUFFER_TOO_SMALL );

                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(ICA_KEEP_ALIVE ), sizeof(BYTE) );
                }
                
                pKeepAlive = (PICA_KEEP_ALIVE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                KeEnterCriticalRegion();
                ExAcquireResourceExclusive( g_pKeepAliveResource, TRUE );

                try {

                  Status = _IcaKeepAlive( pKeepAlive->start, pKeepAlive->interval  );

                } finally {

                  ExReleaseResource(  g_pKeepAliveResource );
                  KeLeaveCriticalRegion();
                }

            break;

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }
    } except(EXCEPTION_EXECUTE_HANDLER){
       Status = GetExceptionCode();
	   if (bConnectionLocked) {
		   IcaUnlockConnection( pConnect );
	   }       
    }

    if (Buffer) {
        ICA_FREE_POOL(Buffer);
        Buffer = NULL;
    }

#if DBG
    if ( code != IOCTL_ICA_SYSTEM_TRACE && code != IOCTL_ICA_TRACE ) {
        TRACE(( pConnect, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlConnection, fc %d, 0x%x\n",
                (code & 0x3fff) >> 2, Status ));
    }
#endif

    return( Status );
}


NTSTATUS
IcaCleanupConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaCloseConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{

    /*
     * Remove the file object reference for this connection.
     * This will cause the connection to be deleted when all other
     * references (including stack/channel references) are gone.
     */
    IcaDereferenceConnection( pConnect );

    return( STATUS_SUCCESS );
}


VOID
IcaReferenceConnection(
    IN PICA_CONNECTION pConnect
    )
{

    ASSERT( pConnect->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement(&pConnect->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceConnection(
    IN PICA_CONNECTION pConnect
    )
{

    ASSERT( pConnect->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, free the connection.
     */
    if ( InterlockedDecrement( &pConnect->RefCount) == 0 ) {
        _IcaFreeConnection( pConnect );
    }
}


PICA_CONNECTION
_IcaAllocateConnection( VOID )
{
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    pConnect = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pConnect) );
    if ( pConnect == NULL )
        return NULL;

    RtlZeroMemory( pConnect, sizeof(*pConnect) );

    /*
     * Initialize the reference count to 2,
     * one for the caller's reference, one for the file object reference.
     */
    pConnect->RefCount = 2;

    /*
     * Initialize the rest of the connect object
     */
    pConnect->Header.Type = IcaType_Connection;
    pConnect->Header.pDispatchTable = IcaConnectionDispatchTable;
    ExInitializeResourceLite( &pConnect->Resource );
    ExInitializeResourceLite( &pConnect->ChannelTableLock );
    InitializeListHead( &pConnect->StackHead );
    InitializeListHead( &pConnect->ChannelHead );
    InitializeListHead( &pConnect->VcBindHead );


    return( pConnect );
}


VOID
_IcaFreeConnection( PICA_CONNECTION pConnect )
{
    ICA_TRACE TraceControl;
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head;

    ASSERT( pConnect->RefCount == 0 );
    ASSERT( IsListEmpty( &pConnect->StackHead ) );
    ASSERT( IsListEmpty( &pConnect->ChannelHead ) );
    ASSERT( IsListEmpty( &pConnect->VcBindHead ) );
    ASSERT( !ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    TRACE(( pConnect, TC_ICADD, TT_API2, "ICADD: _IcaFreeConnection: %x\n",  pConnect ));

    /*
     * Close trace file, if any
     */
    RtlZeroMemory( &TraceControl, sizeof(TraceControl) );
    (void) IcaStartStopTrace( &pConnect->TraceInfo, &TraceControl );

    ExDeleteResourceLite( &pConnect->Resource );
    ExDeleteResourceLite( &pConnect->ChannelTableLock );

    ICA_FREE_POOL( pConnect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\icadata.h ===
/*************************************************************************
*
* icadata.h
*
* This module declares global data for the Termdd driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

extern PDEVICE_OBJECT IcaDeviceObject;
extern PDEVICE_OBJECT MouDeviceObject;
extern PDEVICE_OBJECT KbdDeviceObject;

extern BOOLEAN PortDriverInitialized;

extern KSPIN_LOCK IcaSpinLock;
extern KSPIN_LOCK IcaTraceSpinLock;
extern KSPIN_LOCK IcaStackListSpinLock;

extern PERESOURCE IcaReconnectResource;

extern PERESOURCE IcaSdLoadResource;
extern LIST_ENTRY IcaSdLoadListHead;
extern LIST_ENTRY IcaStackListHead;
extern PLIST_ENTRY IcaNextStack;
extern ULONG IcaTotalNumOfStacks;
extern PKEVENT pIcaKeepAliveEvent;
extern PKTHREAD pKeepAliveThreadObject;
extern BOOLEAN gCapture;

// NOTE: Changes to these sizes will require changes to the mapping tables.
#define MinOutBufAlloc  512
#define MaxOutBufAlloc  8192

// Defines the bit range size to look at to map from Min to MaxOutBufAlloc.
#define NumAllocSigBits 4

#define NumOutBufPools  5
#define FreeThisOutBuf  -1

extern unsigned MaxOutBufMdlOverhead;
extern const unsigned char OutBufPoolMapping[1 << NumAllocSigBits];
extern const unsigned OutBufPoolAllocSizes[NumOutBufPools];


extern LIST_ENTRY IcaFreeOutBufHead[];

extern FAST_IO_DISPATCH IcaFastIoDispatch;

extern PEPROCESS IcaSystemProcess;

extern CCHAR IcaIrpStackSize;
#define ICA_DEFAULT_IRP_STACK_SIZE 1

extern CCHAR IcaPriorityBoost;
#define ICA_DEFAULT_PRIORITY_BOOST 2

extern TERMSRV_SYSTEM_PARAMS SysParams;


/*
 * The following are exported kernel variables
 */
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\buffer.c ===
/****************************************************************************/
// buffer.c
//
// TermDD default OutBuf management.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*
 * Define default stack size for IRP allocation.
 * (This size will be checked by the TdRawWrite routine.)
 */
#define OUTBUF_STACK_SIZE 4
#define OUTBUF_TIMEOUT 60000   // 1 minute


#if DBG
extern PICA_DISPATCH IcaStackDispatchTable[];
#endif


/****************************************************************************/
// IcaBufferGetUsableSpace
//
// Used by the protocol stack drivers to determine the number of usable bytes
// in a TermDD-created OutBuf, given the total size of the OutBuf. This allows
// a stack driver to target a particular OutBuf size and pack data up to the
// edges of the internal OutBuf headers. The returned size can be used as an
// allocation size request that will return an OutBuf of the right size.
/****************************************************************************/
unsigned IcaBufferGetUsableSpace(unsigned OutBufTotalSize)
{
    unsigned IrpSize;
    unsigned MdlSize;
    unsigned MaxOutBufOverhead;

    // Use the same overhead calculations used in IcaBufferAllocInternal()
    // below, plus a 4-byte offset to cover the extra 1-byte difference
    // required in the requesting size to reach a target buffer size.
    IrpSize = IoSizeOfIrp(OUTBUF_STACK_SIZE) + 8;

    if (OutBufTotalSize <= MaxOutBufAlloc)
        MdlSize = MaxOutBufMdlOverhead;
    else
        MdlSize = (unsigned)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1),
                OutBufTotalSize);

    MaxOutBufOverhead = ((sizeof(OUTBUF) + 7) & ~7) + IrpSize + MdlSize;
    return OutBufTotalSize - MaxOutBufOverhead - 4;
}


/*******************************************************************************
 *  IcaBufferAlloc
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    fWait (input)
 *       wait for buffer
 *    fControl (input)
 *       control buffer flag
 *    ByteCount (input)
 *       size of buffer to allocate (zero - use default size)
 *    pOutBufOrig (input)
 *       pointer to original OUTBUF (or null)
 *    pOutBuf (output)
 *       address to return pointer to OUTBUF structure
 ******************************************************************************/
NTSTATUS IcaBufferAlloc(
        IN PSDCONTEXT pContext,
        IN BOOLEAN fWait,
        IN BOOLEAN fControl,
        IN ULONG ByteCount,
        IN POUTBUF pOutBufOrig,
        OUT POUTBUF *ppOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferAlloc callup routine.  If we find one, then call the
     * driver BufferAlloc routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT( pSdLink->pStack == pStack );
        if (pSdLink->SdContext.pCallup->pSdBufferAlloc) {
            IcaReferenceSdLink(pSdLink);
            Status = (pSdLink->SdContext.pCallup->pSdBufferAlloc)(
                    pSdLink->SdContext.pContext,
                    fWait,
                    fControl,
                    ByteCount,
                    pOutBufOrig,
                    ppOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return Status;
        }
    }

    /*
     * We didn't find a callup routine to handle the request,
     * so we'll process it here.
     */
    Status = IcaBufferAllocInternal(pContext, fWait, fControl, ByteCount,
            pOutBufOrig, ppOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferAlloc: 0x%08x, Status=0x%x\n", *ppOutBuf,
            Status));

    return Status;
}


NTSTATUS IcaBufferAllocInternal(
        IN PSDCONTEXT pContext,
        IN BOOLEAN fWait,
        IN BOOLEAN fControl,
        IN ULONG ByteCount,
        IN POUTBUF pOutBufOrig,
        OUT POUTBUF *ppOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    int PoolIndex;
    ULONG irpSize;
    ULONG mdlSize;
    ULONG AllocationSize;
    KIRQL oldIrql;
    PLIST_ENTRY Head;
    POUTBUF pOutBuf;
    NTSTATUS Status;
    unsigned MaxOutBufOverhead;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     *  If original buffer is specified use it's flags
     */
    if (pOutBufOrig) {
        fWait    = (BOOLEAN) pOutBufOrig->fWait;
        fControl = (BOOLEAN) pOutBufOrig->fControl;
    }

    /*
     *  Check if we already have our maximum number of buffers allocated
     */
    while (!fControl && (pStack->OutBufAllocCount >= pStack->OutBufCount)) {
        /*
         *  increment performance counter 
         */
        pStack->ProtocolStatus.Output.WaitForOutBuf++;

        /*
         *  Return if it's not ok to wait
         */
        if (!fWait)
            return(STATUS_IO_TIMEOUT);

        /*
         *  We hit the high watermark
         */
        pStack->fWaitForOutBuf = TRUE;

        /*
         *  Only wait for non-control requests
         */
        KeClearEvent(&pStack->OutBufEvent);
        Status = IcaWaitForSingleObject(pContext, &pStack->OutBufEvent,
                OUTBUF_TIMEOUT);
        if (NT_SUCCESS(Status)) {
            if (Status != STATUS_WAIT_0)
                return STATUS_IO_TIMEOUT;
        }
        else {
            return Status;
        }
    }

    /*
     * If the caller did not specify a byte count
     * then use the standard outbuf size for this stack.
     */
    if (ByteCount == 0)
        ByteCount = pStack->OutBufLength;

    // Note MaxOutBufOverhead is the max for the default max allocation.
    // It will be recalculated if the requested alloc size is greater
    // than can be handled by the default.
    irpSize = IoSizeOfIrp(OUTBUF_STACK_SIZE) + 8;
    mdlSize = MaxOutBufMdlOverhead;
    MaxOutBufOverhead = ((sizeof(OUTBUF) + 7) & ~7) + irpSize + mdlSize;

    /*
     * Determine which buffer pool to use, if any,
     * and the OutBuf length to allocate, if necessary.
     * Note that the max requested ByteCount that will hit the buffer pool
     * is (MaxOutBufAlloc - 1 - MaxOutBufOverhead).
     */
    if ((ByteCount + MaxOutBufOverhead) < MaxOutBufAlloc) {

        ASSERT(((ByteCount + MaxOutBufOverhead) / MinOutBufAlloc) <
                (1 << NumAllocSigBits));
        PoolIndex = OutBufPoolMapping[(ByteCount + MaxOutBufOverhead) /
                MinOutBufAlloc];

        IcaAcquireSpinLock(&IcaSpinLock, &oldIrql);
        if (!IsListEmpty(&IcaFreeOutBufHead[PoolIndex])) {
            Head = RemoveHeadList(&IcaFreeOutBufHead[PoolIndex]);
            IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
            pOutBuf = CONTAINING_RECORD(Head, OUTBUF, Links);
            ASSERT(pOutBuf->PoolIndex == PoolIndex);
        }
        else {
            IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
            AllocationSize = OutBufPoolAllocSizes[PoolIndex];
            pOutBuf = ICA_ALLOCATE_POOL(NonPagedPool, AllocationSize);
            if (pOutBuf == NULL)
                return STATUS_NO_MEMORY;

            // Prevent leaking control OutBufs on OutBuf free.
            if (fControl)
                PoolIndex = FreeThisOutBuf;
        }
    }
    else {
        PoolIndex = FreeThisOutBuf;

        /*
         * Determine the sizes of the various components of an OUTBUF.
         * Note that these are all worst-case calculations --
         * actual size of the MDL may be smaller.
         */
        mdlSize = (ULONG)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1), ByteCount);

        /*
         * Add up the component sizes of an OUTBUF to determine
         * the total size that is needed to allocate.
         */
        AllocationSize = ((sizeof(OUTBUF) + 7) & ~7) + irpSize + mdlSize +
                ((ByteCount + 3) & ~3);

        pOutBuf = ICA_ALLOCATE_POOL(NonPagedPool, AllocationSize);
        if (pOutBuf == NULL)
            return STATUS_NO_MEMORY;
    }

    /*
     * Initialize the IRP pointer and the IRP itself.
     */
    pOutBuf->pIrp = (PIRP)((BYTE *)pOutBuf + ((sizeof(OUTBUF) + 7) & ~7));
    IoInitializeIrp(pOutBuf->pIrp, (USHORT)irpSize, OUTBUF_STACK_SIZE);

    /*
     * Set up the MDL pointer but don't build it yet.
     * It will be built by the TD write code if needed.
     */
    pOutBuf->pMdl = (PMDL)((PCHAR)pOutBuf->pIrp + irpSize);

    /*
     * Set up the address buffer pointer.
     */
    pOutBuf->pBuffer = (PUCHAR)pOutBuf->pMdl + mdlSize +
            pStack->SdOutBufHeader;

    /*
     *  Initialize the rest of output buffer
     */
    InitializeListHead(&pOutBuf->Links);
    pOutBuf->OutBufLength = ByteCount;
    pOutBuf->PoolIndex = PoolIndex;
    pOutBuf->MaxByteCount = ByteCount - (pStack->SdOutBufHeader +
            pStack->SdOutBufTrailer);
    pOutBuf->ByteCount = 0;
    pOutBuf->fIrpCompleted = FALSE;

    /*
     *  Copy inherited fields 
     */
    if (pOutBufOrig == NULL) {
        pOutBuf->fWait       = fWait;      // wait for outbuf allocation
        pOutBuf->fControl    = fControl;   // control buffer (ack/nak)
        pOutBuf->fRetransmit = FALSE;      // not a retransmit
        pOutBuf->fCompress   = TRUE;       // compress data 
        pOutBuf->StartTime   = 0;          // time stamp
        pOutBuf->Sequence    = 0;          // zero sequence number
        pOutBuf->Fragment    = 0;          // zero fragment number
    }
    else {
        pOutBuf->fWait       = pOutBufOrig->fWait;
        pOutBuf->fControl    = pOutBufOrig->fControl;
        pOutBuf->fRetransmit = pOutBufOrig->fRetransmit;
        pOutBuf->fCompress   = pOutBufOrig->fCompress;
        pOutBuf->StartTime   = pOutBufOrig->StartTime;
        pOutBuf->Sequence    = pOutBufOrig->Sequence;
        pOutBuf->Fragment    = pOutBufOrig->Fragment++;
    }

    /*
     *  Increment allocated buffer count
     */
    pStack->OutBufAllocCount++;

    /*
     *  Return buffer to caller
     */
    *ppOutBuf = pOutBuf;

    /*
     *  Return buffer to caller
     */
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * IcaBufferFree
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    pOutBuf (input)
 *       pointer to OUTBUF structure
 ******************************************************************************/
void IcaBufferFree(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferFree callup routine.  If we find one, then call the
     * driver BufferFree routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT(pSdLink->pStack == pStack);
        if (pSdLink->SdContext.pCallup->pSdBufferFree) {
            IcaReferenceSdLink(pSdLink);
            (pSdLink->SdContext.pCallup->pSdBufferFree)(
                    pSdLink->SdContext.pContext,
                    pOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return;
        }
    }

    IcaBufferFreeInternal(pContext, pOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferFree: 0x%08x\n", pOutBuf));
}


/*******************************************************************************
 * IcaBufferError
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    pOutBuf (input)
 *       pointer to OUTBUF structure
 ******************************************************************************/
void IcaBufferError(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferError callup routine.  If we find one, then call the
     * driver BufferError routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT(pSdLink->pStack == pStack);
        if (pSdLink->SdContext.pCallup->pSdBufferError) {
            IcaReferenceSdLink(pSdLink);
            (pSdLink->SdContext.pCallup->pSdBufferError)(
                    pSdLink->SdContext.pContext,
                    pOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return;
        }
    }

    IcaBufferFreeInternal(pContext, pOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferError: 0x%08x\n", pOutBuf));
}


void IcaBufferFreeInternal(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    KIRQL oldIrql;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);

    /*
     * If the buffer came from a free pool, return it to the pool,
     * otherwise free it. Note that pOutBuf->OutBufLength is actually the
     * pool index to use.
     */
    if (pOutBuf->PoolIndex != FreeThisOutBuf) {
        ASSERT(pOutBuf->PoolIndex >= 0 &&
                pOutBuf->PoolIndex < NumOutBufPools);
        IcaAcquireSpinLock(&IcaSpinLock, &oldIrql);
        InsertHeadList(&IcaFreeOutBufHead[pOutBuf->PoolIndex],
                &pOutBuf->Links);
        IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
    }
    else {
        ICA_FREE_POOL(pOutBuf);
    }

    /*
     *  Decrement allocated buffer count
     */
    pStack->OutBufAllocCount--;
    ASSERT((LONG)pStack->OutBufAllocCount >= 0);

    /*
    * If we hit the high watermark then we should wait until the low
    * watermark is hit before signaling the allocator to continue.
    * This should prevent excessive task switching.
    */
    if (pStack->fWaitForOutBuf) {
        if (pStack->OutBufAllocCount <= pStack->OutBufLowWaterMark) {
            pStack->fWaitForOutBuf = FALSE;

        /*
        *  Signal outbuf event (buffer is now available)
        */
        (void) KeSetEvent(&pStack->OutBufEvent, EVENT_INCREMENT, FALSE);
        }
    }
}


/*******************************************************************************
* IcaGetLowWaterMark
*
*   Description : Gets the low water mark that the stack specified
*
*   pContext (input)
*       pointer to SDCONTEXT of caller
******************************************************************************/
ULONG IcaGetLowWaterMark(IN PSDCONTEXT pContext)
{
    ULONG ulRet = 0;
    PICA_STACK pStack;
    PSDLINK pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);

    ASSERT(pSdLink);
    
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);

    ASSERT(ExIsResourceAcquiredExclusive( &pSdLink->pStack->Resource));
    
    if (NULL != pSdLink) {
        pStack = pSdLink->pStack;
        ulRet = pStack->OutBufLowWaterMark;
    }
    return ulRet;
}

/*******************************************************************************
* IcaGetSizeForNoLowWaterMark
*
*   Description : Finds if the stack specified a no low water mark
*				  If so, returns the size needed to bypass ring
*                 returns zero if the stack does not specify a PD_NO_LOWWATERMARK
*   pContext (input)
*       pointer to SDCONTEXT of caller
******************************************************************************/
ULONG IcaGetSizeForNoLowWaterMark(IN PSDCONTEXT pContext)
{
	ULONG retVal = 0;
    ULONG ulLowWm = IcaGetLowWaterMark(pContext);

	if ( MAX_LOW_WATERMARK == ulLowWm ) {
		retVal = MaxOutBufAlloc;
	}
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\dispatch.c ===
/*************************************************************************
*
* dispatch.c
*
* This module contains the dispatch routines for the TERMDD driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

NTSTATUS
IcaDeviceControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaRead (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWrite (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWriteSync (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for ICA.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    KIRQL saveIrql;
    NTSTATUS Status;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    /*
     * Fan out the IRPs based on device type
     */
    if (*((ULONG *)(DeviceObject->DeviceExtension)) != DEV_TYPE_TERMDD)
    {
        /*
         * This is for the port driver part of TermDD
         */
        switch ( irpSp->MajorFunction ) {

            case IRP_MJ_CREATE:
                return PtCreate(DeviceObject, Irp);

            case IRP_MJ_CLOSE:
                return PtClose(DeviceObject, Irp);

            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
                return PtInternalDeviceControl(DeviceObject, Irp);

            case IRP_MJ_DEVICE_CONTROL:
                return PtDeviceControl(DeviceObject, Irp);

            case IRP_MJ_FLUSH_BUFFERS:
                return STATUS_NOT_IMPLEMENTED;

            case IRP_MJ_PNP:
                return PtPnP(DeviceObject, Irp);

            case IRP_MJ_POWER:
                return PtPower(DeviceObject, Irp);

            case IRP_MJ_SYSTEM_CONTROL:
                return PtSystemControl(DeviceObject, Irp);

            default:
                KdPrint(( "IcaDispatch: Invalid major function FOR PORT DRIVER %lx\n",
                          irpSp->MajorFunction ));
                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return STATUS_NOT_IMPLEMENTED;
        }
    }
    else
    {
        switch ( irpSp->MajorFunction ) {

            case IRP_MJ_WRITE:

                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Length ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Key ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );

                saveIrql = KeGetCurrentIrql();

                irpSp->Parameters.Write.Key = 0;

                Status = IcaWrite( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                return Status;

            case IRP_MJ_READ:

                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Key ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );

                saveIrql = KeGetCurrentIrql();

                irpSp->Parameters.Read.Key = 0;

                Status = IcaRead( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                return Status;

            case IRP_MJ_DEVICE_CONTROL:

                saveIrql = KeGetCurrentIrql();

                Status = IcaDeviceControl( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return( Status );

            case IRP_MJ_CREATE:

                Status = IcaCreate( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            case IRP_MJ_FLUSH_BUFFERS :

                Status = IcaWriteSync( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            case IRP_MJ_CLEANUP:

                Status = IcaCleanup( Irp, irpSp );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                return Status;

            case IRP_MJ_CLOSE:

                Status = IcaClose( Irp, irpSp );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                return Status;

            case IRP_MJ_QUERY_SECURITY:

                Status = STATUS_INVALID_DEVICE_REQUEST;

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            default:
                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return STATUS_NOT_IMPLEMENTED;
        }
    }
}

BOOLEAN
IcaIsSystemProcessRequest (
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    BOOLEAN *pbSystemClient)
{
    PACCESS_STATE accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PACCESS_TOKEN CallerAccessToken;
    PACCESS_TOKEN ClientAccessToken;
    PTOKEN_USER userId = NULL;
    BOOLEAN result = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    PSID systemSid;


    ASSERT(Irp != NULL);
    
    ASSERT(IrpSp != NULL);

    ASSERT(pbSystemClient != NULL);

    *pbSystemClient = FALSE;

    securityContext = IrpSp->Parameters.Create.SecurityContext;

    ASSERT(securityContext != NULL);

    //
    //  Get the well-known system SID.
    //
    systemSid = ExAllocatePoolWithTag(
                            PagedPool,
                            RtlLengthRequiredSid(1),
                            ICA_POOL_TAG
                            );
    if (systemSid) {
        SID_IDENTIFIER_AUTHORITY identifierAuthority = SECURITY_NT_AUTHORITY;
        *(RtlSubAuthoritySid(systemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        status = RtlInitializeSid(systemSid, &identifierAuthority, (UCHAR)1);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    accessState = securityContext->AccessState;

     //
    //  Get the non-impersonated, primary token for the IRP request.
    //
    CallerAccessToken = accessState->SubjectSecurityContext.PrimaryToken;

    //
    // get the impersonated token.
    //
    ClientAccessToken = accessState->SubjectSecurityContext.ClientToken;


    //
    // We got the system SID. Now compare the caller and client's SIDs.
    //
    if (NT_SUCCESS(status) && CallerAccessToken){
        //
        //  Get the user ID associated with the primary token for the process
        //  that generated the IRP.
        //
        status = SeQueryInformationToken(
            CallerAccessToken,
            TokenUser,
            &userId
        );

        //
        //  Do the comparison.
        //  
        if (NT_SUCCESS(status)) {
            result = RtlEqualSid(systemSid, userId->User.Sid);
            ExFreePool(userId);
        }

        if (ClientAccessToken)
        {
        	
	        //
	        //  Get the user ID associated with the client  token (impersonation token) 
	        //
	        status = SeQueryInformationToken(
	            ClientAccessToken,
	            TokenUser,
	            &userId
	        );

	        //
	        //  Do the comparison.
	        //  
	        if (NT_SUCCESS(status)) {
	            *pbSystemClient = RtlEqualSid(systemSid, userId->User.Sid);
	            ExFreePool(userId);
	        }

        }
        else
        {
        	// 
        	// we dont have  ClientAccessToken, impling there is no impersonation going on.
        	// in this case lets set *pbSystemClient = caller
        	//
        	*pbSystemClient = result;
        }
        
    }


  
    if (systemSid) {
        ExFreePool(systemSid);
    }

    return result;
}



NTSTATUS
IcaCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Create IRPs in ICA.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_OPEN_PACKET openPacket;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    PFILE_OBJECT pConnectFileObject;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;
    BOOLEAN bSystemCaller; // was the caller of this IRP system?
    BOOLEAN bSystemClient; // was the client of this IRP system?




    PAGED_CODE( );

    // Save result in FsContext2: if the requestor is system process or not
    bSystemCaller = IcaIsSystemProcessRequest(Irp, IrpSp, &bSystemClient);
    IrpSp->FileObject->FsContext2 = (VOID *)bSystemCaller;

    


    /*
     * Find the open packet from the EA buffer in the system buffer of
     * the associated IRP.  If no EA buffer was specified, then this
     * is a request to open a new ICA connection.
     */
    eaBuffer = Irp->AssociatedIrp.SystemBuffer;
    if ( eaBuffer == NULL ) {
        if ( (Irp->RequestorMode != KernelMode) &&  !bSystemCaller) {

            return STATUS_ACCESS_DENIED;
        }
        return( IcaCreateConnection( Irp, IrpSp ) );
    }

    if (eaBuffer->EaValueLength < sizeof(ICA_OPEN_PACKET)) {
       ASSERT(FALSE);
       return STATUS_INVALID_PARAMETER;
    }



    openPacket = (PICA_OPEN_PACKET)(eaBuffer->EaName + eaBuffer->EaNameLength + 1);

    /*
     * Validate parameters in the open packet.
     */
    if ( openPacket->OpenType != IcaOpen_Stack &&
         openPacket->OpenType != IcaOpen_Channel ) {
        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;
    }
    /*
     * If this open is not for a virtual channel then the caller has to be system or kernel mode.
     */


    if ((openPacket->OpenType == IcaOpen_Stack) || openPacket->TypeInfo.ChannelClass != Channel_Virtual) {
        if ( (Irp->RequestorMode != KernelMode) &&  !bSystemCaller) {
            return STATUS_ACCESS_DENIED;
        }
    }

     /*
      *   if we are creating a Virtual Channel, then add some more restriction on security. as an RPC caller 
      *   can cause us to open the v channel, mark the object so if the either caller or client is non system.
      */
     if (openPacket->OpenType == IcaOpen_Channel && openPacket->TypeInfo.ChannelClass == Channel_Virtual) 
     {
         if (!_stricmp(VIRTUAL_THINWIRE, openPacket->TypeInfo.VirtualName))
         {
             // THIS IS A UGLY SPECIAL CASE. IN SHADOWWORKER, THIS CHANNEL IS CREATED WHILE IMPERSONATED.
             // BUT WE DONT LET THIS CHANNLE TO BE OPENED BY RPCOPENVIRTUAL CHANNEL. SO LETS MARK MAKE AN EXCEPTION FOR THIS.
         }
         else
         {
            IrpSp->FileObject->FsContext2 = (VOID *)(BOOLEAN)(bSystemClient && bSystemCaller);
         }
     }



    /*
     * Use the specified ICA connection handle to get a pointer to
     * the connection object.
     */
    Status = ObReferenceObjectByHandle(
                 openPacket->IcaHandle,
                 STANDARD_RIGHTS_READ,                         // DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 (PVOID *)&pConnectFileObject,
                 NULL
                 );
    if ( !NT_SUCCESS(Status) )
        return( Status );

    /*
     * Ensure what we have is a connection object
     */

    if (pConnectFileObject->DeviceObject != IcaDeviceObject) {
        ASSERT(FALSE);
        ObDereferenceObject( pConnectFileObject );
        return STATUS_INVALID_PARAMETER;
    }
    pConnect = pConnectFileObject->FsContext;
    ASSERT( pConnect->Header.Type == IcaType_Connection );
    if ( pConnect->Header.Type != IcaType_Connection ) {
        ObDereferenceObject( pConnectFileObject );
        return( STATUS_INVALID_CONNECTION );
    }

    /*
     * Create a new stack or new channel
     */
    IcaReferenceConnection( pConnect );

    switch ( openPacket->OpenType ) {
        case IcaOpen_Stack :
            Status = IcaCreateStack( pConnect, openPacket, Irp, IrpSp );
            break;

        case IcaOpen_Channel :
            Status = IcaCreateChannel( pConnect, openPacket, Irp, IrpSp );
            break;
    }

    IcaDereferenceConnection( pConnect );
    ObDereferenceObject( pConnectFileObject );

    return( Status );
}


NTSTATUS
IcaRead (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the read routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a read routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_READ] == NULL ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        return( Status );
    }

    /*
     * Call the read routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_READ])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaWrite (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the write routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a write routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_WRITE] == NULL ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        return( Status );
    }

    /*
     * Call the write routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_WRITE])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaWriteSync (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the flush routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a flush routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_FLUSH_BUFFERS] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    /*
     * Call the flush routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_FLUSH_BUFFERS])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaDeviceControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for ICA IOCTLs.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a device control routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_DEVICE_CONTROL] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    /*
     * Call the device control routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_DEVICE_CONTROL])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Cleanup IRPs in ICA.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS --

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a cleanup routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_CLEANUP] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    Status = (pIcaHeader->pDispatchTable[IRP_MJ_CLEANUP])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Close IRPs in ICA.  It
    dereferences the endpoint specified in the IRP, which will result in
    the endpoint being freed when all other references go away.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    PAGED_CODE( );

    /*
     * Get pointer to ICA object header.
     * If a close routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_CLOSE] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    Status = (pIcaHeader->pDispatchTable[IRP_MJ_CLOSE])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
CaptureUsermodeBuffer (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PVOID *pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID *pOutBuffer,
    IN ULONG OutBufferSize,
    IN BOOLEAN MethodBuffered,
    OUT PVOID *pAllocatedTemporaryBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID pBuffer = NULL;

    try {

        if (MethodBuffered) {
            if (pInBuffer != NULL) {
                *pInBuffer = Irp->AssociatedIrp.SystemBuffer;
            }
            if (pOutBuffer != NULL) {
                *pOutBuffer = Irp->AssociatedIrp.SystemBuffer;
            }
            if (pAllocatedTemporaryBuffer != NULL) {
                *pAllocatedTemporaryBuffer = NULL;
            }

        } else{
            ULONG AlignedInputSize = (InBufferSize + sizeof(BYTE*) - 1) & ~(sizeof(BYTE*) - 1);
            ULONG AllocationSize = AlignedInputSize +OutBufferSize;
            if (AllocationSize != 0 ) {
                if (gCapture && (Irp->RequestorMode == UserMode) ) {
                    pBuffer = ExAllocatePoolWithTag(PagedPool, AllocationSize, ICA_POOL_TAG);
                    if (pBuffer == NULL) {
                        ExRaiseStatus(STATUS_NO_MEMORY);
                    } else{
                        if (pInBuffer != NULL) {
                            *pInBuffer = pBuffer;
                        }
                        if (pOutBuffer != NULL) {
                            *pOutBuffer = (PVOID)((BYTE*)pBuffer+AlignedInputSize);
                        }
                        if (pAllocatedTemporaryBuffer != NULL) {
                            *pAllocatedTemporaryBuffer = pBuffer;
                        }
                        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) {
                            RtlCopyMemory( pBuffer, 
                                           IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, 
                                           IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                        }
                        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0 ) {
                            RtlCopyMemory((PVOID) ((BYTE*)pBuffer+AlignedInputSize), 
                                           Irp->UserBuffer, 
                                           IrpSp->Parameters.DeviceIoControl.OutputBufferLength);
                        }
                    }
                }   else{
                    if (pInBuffer != NULL) {
                        *pInBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    }
                    if (pOutBuffer != NULL) {
                        *pOutBuffer = Irp->UserBuffer;
                    }
                    if (pAllocatedTemporaryBuffer != NULL) {
                        *pAllocatedTemporaryBuffer = NULL;
                    }
                }

            }else {
                if (pInBuffer != NULL) {
                    *pInBuffer = NULL;
                }
                if (pOutBuffer != NULL) {
                    *pOutBuffer = NULL;
                }
                if (pAllocatedTemporaryBuffer != NULL) {
                    *pAllocatedTemporaryBuffer = NULL;
                }

            }
        }
    }   except(EXCEPTION_EXECUTE_HANDLER){
            if (pBuffer != NULL) {
                ExFreePool(pBuffer);
            }
            if (pAllocatedTemporaryBuffer != NULL) {
                *pAllocatedTemporaryBuffer = NULL;
            }
            Status = GetExceptionCode();

    }
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\icadata.c ===
/*************************************************************************
* icadata.c
*
* This module declares global data for Termdd
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


PDEVICE_OBJECT IcaDeviceObject;
PDEVICE_OBJECT MouDeviceObject = NULL;
PDEVICE_OBJECT KbdDeviceObject = NULL;

BOOLEAN PortDriverInitialized;

KSPIN_LOCK IcaSpinLock;
KSPIN_LOCK IcaTraceSpinLock;
KSPIN_LOCK IcaStackListSpinLock;

PERESOURCE IcaReconnectResource;
PERESOURCE IcaTraceResource;

PERESOURCE IcaSdLoadResource;
LIST_ENTRY IcaSdLoadListHead;

LIST_ENTRY IcaTdHandleList;

LIST_ENTRY IcaFreeOutBufHead[NumOutBufPools];

LIST_ENTRY IcaStackListHead;
ULONG      IcaTotalNumOfStacks;
PLIST_ENTRY IcaNextStack;
PKEVENT    pIcaKeepAliveEvent;
PKTHREAD   pKeepAliveThreadObject;

HANDLE     g_TermServProcessID=NULL;

unsigned MaxOutBufMdlOverhead;

BOOLEAN gCapture = TRUE;

// Used by OutBuf alloc code to map a bit range from the alloc size
// (requested alloc size + header sizes) into a particular buffer pool.
// We use a 512-byte granularity, but alloc sizes that are various multiples
// of 512 bytes, to correspond with various protocol typical allocation sizes.
const unsigned char OutBufPoolMapping[1 << NumAllocSigBits] =
{
         // Index  Binary   AllocRange   Pool  PoolAllocSize
    0,   //   0     0000       0..511      0        1024
    0,   //   1     0001     512..1023     0        1024
    1,   //   2     0010    1024..1535     1        1536
    2,   //   3     0011    1536..2047     2        2048
    3,   //   4     0100    2048..2559     3        2560
    4,   //   5     0101    2560..3071     4        8192
    4,   //   6     0110    3072..3583     4        8192
    4,   //   7     0111    3584..4095     4        8192
    4,   //   8     1000    4096..4607     4        8192
    4,   //   9     1001    4608..5119     4        8192
    4,   //  10     1010    5120..5631     4        8192
    4,   //  11     1011    5632..6143     4        8192
    4,   //  12     1100    6144..6655     4        8192
    4,   //  13     1101    6656..7167     4        8192
    4,   //  14     1110    7168..7679     4        8192
    4,   //  15     1111    7680..8191     4        8192
};

// After mapping we have a pool number and need to know the size to alloc.
const unsigned OutBufPoolAllocSizes[NumOutBufPools] =
{
    1024, 1536, 2048, 2560, 8192
};


FAST_IO_DISPATCH IcaFastIoDispatch;

PEPROCESS IcaSystemProcess;

CCHAR IcaIrpStackSize = ICA_DEFAULT_IRP_STACK_SIZE;

CCHAR IcaPriorityBoost = ICA_DEFAULT_PRIORITY_BOOST;

TERMSRV_SYSTEM_PARAMS SysParams =
{
    DEFAULT_MOUSE_THROTTLE_SIZE,
    DEFAULT_KEYBOARD_THROTTLE_SIZE,
};


#ifdef notdef
FAST_IO_DISPATCH IcaFastIoDispatch =
{
    11,                        // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    IcaFastIoRead,             // FastIoRead
    IcaFastIoWrite,            // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    NULL,                      // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    IcaFastIoDeviceControl     // FastIoDeviceControl
};
#endif

#if DBG
ULONG IcaLocksAcquired = 0;
#endif


BOOLEAN
IcaInitializeData (
    VOID
    )
{
    int i, j;

    PAGED_CODE( );

#if DBG
    IcaInitializeDebugData( );
#endif

    //
    // Initialize global lists.
    //
    InitializeListHead( &IcaSdLoadListHead );
    InitializeListHead( &IcaStackListHead );

    IcaTotalNumOfStacks = 0;
    IcaNextStack = &IcaStackListHead;

    pKeepAliveThreadObject = NULL;

    for ( i = 0; i < NumOutBufPools; i++ )
        InitializeListHead( &IcaFreeOutBufHead[i] );
    //
    // Initialize global spin locks and resources used by ICA.
    //
    KeInitializeSpinLock( &IcaSpinLock );
    KeInitializeSpinLock( &IcaTraceSpinLock );
    KeInitializeSpinLock( &IcaStackListSpinLock );


    IcaInitializeHandleTable();

    IcaReconnectResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaReconnectResource) );
    if ( IcaReconnectResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaReconnectResource );

    IcaSdLoadResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaSdLoadResource) );
    if ( IcaSdLoadResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaSdLoadResource );

    IcaTraceResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaTraceResource) );
    if ( IcaTraceResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaTraceResource );


    pIcaKeepAliveEvent = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(KEVENT));
    if ( pIcaKeepAliveEvent != NULL ) {
        KeInitializeEvent(pIcaKeepAliveEvent, NotificationEvent, FALSE);
    }
    else {
        return FALSE;
    }


    // Used by OutBuf alloc code for determining max overhead of OutBuf info
    // for the default max size allocation.
    MaxOutBufMdlOverhead = (unsigned)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1),
            MaxOutBufAlloc);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\icap.h ===
/****************************************************************************/
// icap.h
//
// TermDD private header.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/


#define ICA_POOL_TAG ' acI'


/*
 * Enumerated ICA object types
 */
typedef enum _ICA_TYPE {
    IcaType_Connection,
    IcaType_Stack,
    IcaType_Channel
} ICA_TYPE;


/*
 * ICA dispatch prototype
 */
typedef NTSTATUS (*PICA_DISPATCH) (
        IN PVOID IcaObject,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp);


/*
 * Deferred trace structure
 */
#pragma warning(disable : 4200)  // for Buffer[] nonstandard extension.
typedef struct _DEFERRED_TRACE {
    struct _DEFERRED_TRACE *Next;
    ULONG Length;
    WCHAR Buffer[];
} DEFERRED_TRACE, *PDEFERRED_TRACE;
#pragma warning(default : 4200)

/*
 * Trace Information structure
 */
typedef struct _ICA_TRACE_INFO {
    ULONG TraceClass;                 // trace - enabled trace classes (TC_?)
    ULONG TraceEnable;                // trace - enabled trace types (TT_?)
    BOOLEAN fTraceDebugger;           // trace - send trace messages to the debugger
    BOOLEAN fTraceTimestamp;          // trace - time stamp trace messages
    PWCHAR pTraceFileName;
    PFILE_OBJECT pTraceFileObject;
    PDEFERRED_TRACE pDeferredTrace;
} ICA_TRACE_INFO, *PICA_TRACE_INFO;


/*
 * Common header for all ICA objects
 */
typedef struct _ICA_HEADER {
    ICA_TYPE Type;
    PICA_DISPATCH *pDispatchTable;
} ICA_HEADER, *PICA_HEADER;


/*
 * ICA connection object
 */
typedef struct _ICA_CONNECTION {
    ICA_HEADER  Header;         // WARNING: This field MUST ALWAYS be first
    LONG        RefCount;       // Reference count for this connection
    ERESOURCE   Resource;       // Resource protecting access to this object
    BOOLEAN     fPassthruEnabled;
    LIST_ENTRY  StackHead;      // List of stack objects for this connection
    LIST_ENTRY  ChannelHead;    // List of channel objects for this connection
    LIST_ENTRY  VcBindHead;     // List of vcbind objects for this connection
    ICA_TRACE_INFO TraceInfo;   // trace information

    /*
     * Channel pointers array.  This array should be indexed using the
     * channel number plus the virtual channel number.  This allows a
     * fast lookup of any bound channel given the channel/virtual number.
     */
    struct _ICA_CHANNEL *pChannel[CHANNEL_COUNT+VIRTUAL_MAXIMUM];
    ERESOURCE ChannelTableLock;
} ICA_CONNECTION, *PICA_CONNECTION;


//
// define the Maximum Low Water Mark setting to resume transmission
//
#define MAX_LOW_WATERMARK				((ULONG)((ULONG_PTR)-1))
/*
 * ICA stack object
 */
typedef struct _ICA_STACK {
    ICA_HEADER  Header;             // WARNING: This field MUST ALWAYS be first
    LONG        RefCount;           // Reference count for this stack
    ERESOURCE   Resource;           // Resource protecting access to this object
    STACKCLASS  StackClass;         // Stack type (primary/shadow)
    LIST_ENTRY  StackEntry;         // Links for connection object stack list
    LIST_ENTRY  SdLinkHead;         // Head of SDLINK list for this stack
    struct _ICA_STACK *pPassthru;   // Pointer to passthru stack
    BOOLEAN fIoDisabled;
    BOOLEAN fClosing;
    BOOLEAN fDoingInput;
    BOOLEAN fDisablingIo;
    KEVENT  IoEndEvent;
    LARGE_INTEGER LastInputTime;    // last time of keyboard/mouse input 
    PVOID pBrokenEventObject;

    /*
     * Pointer to connection object.
     * Note this is typed as PUCHAR instead of PICA_CONNECTION to prevent use
     * of it directly.  All references to the connection object a stack is
     * attached to should be made by calling IcaGetConnectionForStack() if
     * the stack is already locked, or IcaLockConnectionForStack() otherwise.
     * This is required because this is a dynamic pointer, which can be
     * modified during stack reconnect.
     */
    PUCHAR pConnect;                // Pointer to connection object

    BOOLEAN fWaitForOutBuf;         // outbuf - did we hit the high watermark
    ULONG OutBufLength;             // outbuf - length of output buffer
    ULONG OutBufCount;              // outbuf - maximum number of outbufs
    ULONG OutBufAllocCount;         // outbuf - number of outbufs allocated
    KEVENT OutBufEvent;             // outbuf - allocate event
    ULONG SdOutBufHeader;           // reserved output buffer header bytes
    ULONG SdOutBufTrailer;          // reserved output buffer trailer bytes 

    CLIENTMODULES ClientModules;    // stack driver client module data
    PROTOCOLSTATUS ProtocolStatus;  // stack driver protocol status

    LIST_ENTRY StackNode;           // for linking all stacks together
    LARGE_INTEGER  LastKeepAliveTime;       // Time last keepalive packet sent
    ULONG OutBufLowWaterMark;           // low water mark to resume transmission
} ICA_STACK, *PICA_STACK;


/*
 * Channel Filter Input/Output procedure prototype
 */
typedef NTSTATUS
(_stdcall * PFILTERPROC)( PVOID, PCHAR, ULONG, PINBUF * );

/*
 * ICA channel filter object
 */
typedef struct _ICA_FILTER {
    PFILTERPROC InputFilter;    // Input filter procedure
    PFILTERPROC OutputFilter;   // Output filter procedure
} ICA_FILTER, *PICA_FILTER;


/*
 * ICA virtual class bind structure
 */
typedef struct _ICA_VCBIND {
    VIRTUALCHANNELNAME  VirtualName;   // Virtual channel name
    VIRTUALCHANNELCLASS VirtualClass;  // Virtual channel number (0-31, -1 unbound)
    ULONG Flags;
    LIST_ENTRY   Links;         // Links for vcbind structure list
} ICA_VCBIND, *PICA_VCBIND;


/*
 * ICA channel object
 */
typedef struct _ICA_CHANNEL {
    ICA_HEADER   Header;        // WARNING: This field MUST ALWAYS be first
    LONG         RefCount;      // Reference count for this channel
    ERESOURCE    Resource;      // Resource protecting access to this object
    ULONG        Flags;         // Channel flags (see CHANNEL_xxx below)
    LONG         OpenCount;     // Count of opens on this object
    PICA_CONNECTION pConnect;   // Pointer to connection object
    PICA_FILTER  pFilter;       // Pointer to filter object for this channel
    CHANNELCLASS ChannelClass;  // Channel type
    VIRTUALCHANNELNAME  VirtualName;   // Virtual channel name
    VIRTUALCHANNELCLASS VirtualClass;  // Virtual channel number (0-31, -1 unbound)
    LIST_ENTRY   Links;         // Links for channel structure list
    LIST_ENTRY   InputIrpHead;  // Head of pending IRP list
    LIST_ENTRY   InputBufHead;  // Head of input buffer list
    unsigned     InputBufCurSize;  // Bytes held in input buffers.
    unsigned     InputBufMaxSize;  // High watermark for input buffers.
    PERESOURCE pChannelTableLock;
    ULONG        CompletionRoutineCount;
} ICA_CHANNEL, *PICA_CHANNEL;

/*
 *  VirtualClass - virtual channel is not yet bound to a virtual class number
 */
#define UNBOUND_CHANNEL -1
 
/*
 * Channel Flags
 */
#define CHANNEL_MESSAGE_MODE      0x00000001  // This is a message mode channel
#define CHANNEL_SHADOW_IO         0x00000002  // Pass shadow data
#define CHANNEL_SCREENDATA        0x00000004  // This is a screen data channel
#define CHANNEL_CLOSING           0x00000008  // This channel is being closed
#define CHANNEL_SHADOW_PERSISTENT 0x00000010  // Used for virtual channels: still up during shadow
#define CHANNEL_SESSION_DISABLEIO 0x00000020  // Used disable IO for help session while not in shadow mode
#define CHANNEL_CANCEL_READS      0x00000040  // To cancel reads to CommandChannel on Winstation termination


/*
 * Stack Driver load structure
 * There exists exactly one of these structures for
 * each Stack Driver (WD/PD/TD) loaded in the system.
 */
typedef struct _SDLOAD {
    WDNAMEW     SdName;         // Name of this SD
    LONG        RefCount;       // Reference count
    LIST_ENTRY  Links;          // Links for SDLOAD list
    PVOID       ImageHandle;    // Image handle for this driver
    PVOID       ImageBase;      // Image base for this driver
    PSDLOADPROC DriverLoad;     // Pointer to driver load routine
    PFILE_OBJECT FileObject;    // Reference to underlying driver
    PVOID       pUnloadWorkItem;// Pointer to workitem for delayed unload
    PDEVICE_OBJECT DeviceObject;// Pointer device object to use the unload safe completion routine
} SDLOAD, *PSDLOAD;


/*
 * Stack Driver link structure
 * There exists one of these structures for each WD/PD/TD in a stack.
 */
typedef struct _SDLINK {
    PICA_STACK  pStack;         // Pointer to ICA_STACK object for this driver
    PSDLOAD     pSdLoad;        // Pointer to SDLOAD object for this driver
    LIST_ENTRY  Links;          // Links for SDLINK list
    LONG        RefCount;   
    SDCONTEXT   SdContext;      // Contains SD proc table, context value, callup table
    ERESOURCE   Resource;
} SDLINK, * PSDLINK;


/*
 * Lock/Unlock macros
 */
#if DBG

/*
 *
 * NOTE: Under DBG builds, the following routines will validate
 *       that the correct locking order is not violated.
 *       The correct order is:
 *          1) Connection
 *          2) Stack
 *          3) Channel
 */
BOOLEAN IcaLockConnection(PICA_CONNECTION);
void    IcaUnlockConnection(PICA_CONNECTION);

BOOLEAN IcaLockStack(PICA_STACK);
void    IcaUnlockStack(PICA_STACK);

BOOLEAN IcaLockChannel(PICA_CHANNEL);
void    IcaUnlockChannel(PICA_CHANNEL);

#else // DBG

#define IcaLockConnection(p) { \
        IcaReferenceConnection( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockConnection(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceConnection( p ); \
    }

#define IcaLockStack(p) { \
        IcaReferenceStack( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockStack(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceStack( p ); \
    }

#define IcaLockChannel(p) { \
        IcaReferenceChannel( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockChannel(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceChannel(p); \
    }


#endif // DBG

PICA_CONNECTION IcaGetConnectionForStack(PICA_STACK);

PICA_CONNECTION IcaLockConnectionForStack(PICA_STACK);

void IcaUnlockConnectionForStack(PICA_STACK);


/*
 * Memory alloc/free macros
 */
#if DBG

PVOID IcaAllocatePool(IN POOL_TYPE, IN ULONG, PCHAR, ULONG, BOOLEAN);

#define ICA_ALLOCATE_POOL(a,b) IcaAllocatePool(a, b, __FILE__, __LINE__, FALSE)
#define ICA_ALLOCATE_POOL_WITH_QUOTA(a,b) IcaAllocatePool(a, b, __FILE__, __LINE__, TRUE)

void IcaFreePool (IN PVOID);

#define ICA_FREE_POOL(a) IcaFreePool(a)

#else // DBG

#define ICA_ALLOCATE_POOL(a,b) ExAllocatePoolWithTag(a,b,ICA_POOL_TAG)
#define ICA_ALLOCATE_POOL_WITH_QUOTA(a,b) ExAllocatePoolWithQuotaTag(a,b,ICA_POOL_TAG)
#define ICA_FREE_POOL(a) ExFreePool(a)

#endif // DBG


/*
 * Spinlock acquire/release macros
 */
#if DBG

extern ULONG IcaLocksAcquired;

#define IcaAcquireSpinLock(a,b) KeAcquireSpinLock((a),(b)); IcaLocksAcquired++

#define IcaReleaseSpinLock(a,b) IcaLocksAcquired--; KeReleaseSpinLock((a),(b))

void IcaInitializeDebugData(void);

#else // DBG

#define IcaAcquireSpinLock(a,b) KeAcquireSpinLock((a),(b))
#define IcaReleaseSpinLock(a,b) KeReleaseSpinLock((a),(b))

#endif // DBG


/*
 *  Trace
 */
extern ICA_TRACE_INFO G_TraceInfo;

#undef TRACE
#undef TRACESTACK
#undef TRACESTACKBUF
#undef TRACECHANNEL

#if DBG
VOID _cdecl _IcaTrace( PICA_CONNECTION, ULONG, ULONG, CHAR *, ... );
VOID _cdecl _IcaStackTrace( PICA_STACK, ULONG, ULONG, CHAR *, ... );
VOID        _IcaStackTraceBuffer( PICA_STACK, ULONG, ULONG, PVOID, ULONG );
VOID _cdecl _IcaChannelTrace( PICA_CHANNEL, ULONG, ULONG, CHAR *, ... );

#define TRACE(_arg)         _IcaTrace _arg
#define TRACESTACK(_arg)    _IcaStackTrace _arg
#define TRACESTACKBUF(_arg) _IcaStackTraceBuffer _arg
#define TRACECHANNEL(_arg)  _IcaChannelTrace _arg

#else

#define TRACE(_arg)         
#define TRACESTACK(_arg)    
#define TRACESTACKBUF(_arg) 
#define TRACECHANNEL(_arg)  

#endif


/*
 *  Need to define these to have MP save driver ( proper locked operation will generated for x86)-Bug# 209464
 */

 #define _NTSRV_
 #define _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\channel.c ===
/****************************************************************************/
// channel.c
//
// Terminal Server channel handling.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>
#include <ntddmou.h>

#include "ptdrvcom.h"


#define min(a,b)            (((a) < (b)) ? (a) : (b))


NTSTATUS
IcaExceptionFilter( 
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );

NTSTATUS
IcaReadChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWriteChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaDeviceControlChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaFlushChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
IcaFreeAllVcBind(
    IN PICA_CONNECTION pConnect
    );

NTSTATUS 
IcaCancelReadChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Local procedure prototypes
 */
NTSTATUS
_IcaReadChannelComplete(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS _IcaQueueReadChannelRequest(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
_IcaCopyDataToUserBuffer(
    IN PIRP Irp,
    IN PUCHAR pBuffer,
    IN ULONG ByteCount
    );

VOID
_IcaReadChannelCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID _IcaProcessIrpList(
    IN PICA_CHANNEL pChannel
    );

PICA_CHANNEL
_IcaAllocateChannel(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

void _IcaFreeChannel(IN PICA_CHANNEL);

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaRegisterVcBind(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN ULONG Flags
    );

VIRTUALCHANNELCLASS
_IcaFindVcBind(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName,
    OUT PULONG pFlags
    );

VOID
_IcaBindChannel(
    IN PICA_CHANNEL pChannel,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN ULONG Flags
    );



/*
 * Dispatch table for ICA channel objects
 */
PICA_DISPATCH IcaChannelDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE
    IcaCloseChannel,            // IRP_MJ_CLOSE
    IcaReadChannel,             // IRP_MJ_READ
    IcaWriteChannel,            // IRP_MJ_WRITE
    NULL,                       // IRP_MJ_QUERY_INFORMATION
    NULL,                       // IRP_MJ_SET_INFORMATION
    NULL,                       // IRP_MJ_QUERY_EA
    NULL,                       // IRP_MJ_SET_EA
    IcaFlushChannel,            // IRP_MJ_FLUSH_BUFFERS
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL
    IcaDeviceControlChannel,    // IRP_MJ_DEVICE_CONTROL
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL
    NULL,                       // IRP_MJ_SHUTDOWN
    NULL,                       // IRP_MJ_LOCK_CONTROL
    IcaCleanupChannel,          // IRP_MJ_CLEANUP
    NULL,                       // IRP_MJ_CREATE_MAILSLOT
    NULL,                       // IRP_MJ_QUERY_SECURITY
    NULL,                       // IRP_MJ_SET_SECURITY
    NULL,                       // IRP_MJ_SET_POWER
    NULL,                       // IRP_MJ_QUERY_POWER
};

#if DBG
extern PICA_DISPATCH IcaStackDispatchTable[];
#endif


NTSTATUS IcaCreateChannel(
        IN PICA_CONNECTION pConnect,
        IN PICA_OPEN_PACKET openPacket,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This routine is called to create a new ICA_CHANNEL object.
    - the reference count is incremented by one

Arguments:

    pConnect -- pointer to ICA_CONNECTION object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_CHANNEL pChannel;
    CHANNELCLASS ChannelClass;
    NTSTATUS Status;

    /*
     * Validate ChannelClass
     */
    ChannelClass = openPacket->TypeInfo.ChannelClass;
    if ( !(ChannelClass >= Channel_Keyboard && ChannelClass <= Channel_Virtual) )
        return( STATUS_INVALID_PARAMETER );

    /*
     * Ensure VirtualName has a trailing NULL
     */
    if ( !memchr( openPacket->TypeInfo.VirtualName,
                  '\0',
                  sizeof( openPacket->TypeInfo.VirtualName ) ) )
        return( STATUS_INVALID_PARAMETER );


    /*
     * Must lock connection object to create new channel.
     */
    IcaLockConnection( pConnect );

    TRACE(( pConnect, TC_ICADD, TT_API2, "TermDD: IcaCreateChannel: cc %u, vn %s\n",
            ChannelClass, openPacket->TypeInfo.VirtualName ));

    /*
     *  Locate channel object
     */
    pChannel = IcaFindChannelByName(pConnect,
            ChannelClass,
            openPacket->TypeInfo.VirtualName);

    /*
     * See if this channel has already been created.
     * If not, then create/initialize it now.
     */
    if ( pChannel == NULL ) {
        /*
         * Allocate a new ICA channel object
         */
        pChannel = _IcaAllocateChannel(pConnect,
                ChannelClass,
                openPacket->TypeInfo.VirtualName);
        if (pChannel == NULL) {
            IcaUnlockConnection(pConnect);
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    /*
     * Increment open count for this channel
     */
    if (InterlockedIncrement(&pChannel->OpenCount) <= 0) {
        ASSERT( FALSE );
    }

    /*
     * If the CHANNEL_CLOSING flag is set, then we are re-referenceing
     * a channel object that was just closed by a previous caller,
     * but has not yet been completely dereferenced.
     * This can happen if this create call comes in between the
     * calls to IcaCleanupChannel and IcaCloseChannel which happen
     * when a channel handle is closed.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING ) {
        /*
         * Lock channel while we clear out the CHANNEL_CLOSING flag.
         */
        IcaLockChannel(pChannel);
        pChannel->Flags &= ~CHANNEL_CLOSING;
        IcaUnlockChannel(pChannel);
    }

    IcaUnlockConnection(pConnect);

    /*
     * Save a pointer to the channel in the file object
     * so that we can find it in future calls.
     * - leave the reference on the channel object
     */
    IrpSp->FileObject->FsContext = pChannel;

    /*
     *  Exit with the channel reference count incremented by one
     */
    return STATUS_SUCCESS;
}


NTSTATUS IcaReadChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This is the read routine for ICA channels.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    KIRQL cancelIrql;
    NTSTATUS Status = STATUS_PENDING;
    ULONG bChannelAlreadyLocked;


    /*
     * Determine the channel type to see if read is supported.
     * Also do read size verification for keyboard/mouse.
     */
    switch ( pChannel->ChannelClass ) {
        /*
         * Make sure input size is a multiple of KEYBOARD_INPUT_DATA
         */
        case Channel_Keyboard :
            if ( IrpSp->Parameters.Read.Length % sizeof(KEYBOARD_INPUT_DATA) )
                Status = STATUS_BUFFER_TOO_SMALL;
            break;

        /*
         * Make sure input size is a multiple of MOUSE_INPUT_DATA
         */
        case Channel_Mouse :
            if ( IrpSp->Parameters.Read.Length % sizeof(MOUSE_INPUT_DATA) )
                Status = STATUS_BUFFER_TOO_SMALL;
            break;

        /*
         * Nothing required for Command/Virtual channels
         */
        case Channel_Command :
        case Channel_Virtual :
            break;

        /*
         * Read not supported for the following channels
         */
        case Channel_Video :
        case Channel_Beep :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            ASSERTMSG( "TermDD: Invalid Channel Class", FALSE );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    /*
     * If read length is 0, or an error is being returned, return now.
     */
    if (Status == STATUS_PENDING && IrpSp->Parameters.Read.Length == 0)
        Status = STATUS_SUCCESS;
    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status ));
        return Status;
    }

    /*
     * Verify user's buffer is valid
     */
    if (Irp->RequestorMode != KernelMode) {
        try {
            ProbeForWrite(Irp->UserBuffer, IrpSp->Parameters.Read.Length, sizeof(BYTE));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IcaPriorityBoost);
            TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                    "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                    pChannel->ChannelClass, pChannel->VirtualClass, Status));
            return Status;
        }
    }

    /*
     * Lock the channel while we determine how to handle this read request.
     * One of the following will be true:
     *   1) Input data is available; copy it to user buffer and complete IRP,
     *   2) No data available, IRP cancel is requested; cancel/complete IRP,
     *   3) No data; add IRP to pending read list, return STATUS_PENDING.
     */
    if (ExIsResourceAcquiredExclusiveLite(&(pChannel->Resource))) {
        bChannelAlreadyLocked = TRUE;
        IcaReferenceChannel(pChannel); 
    }
    else {
        bChannelAlreadyLocked = FALSE;
        IcaLockChannel(pChannel);
    }

    /*
     * If the channel is being closed,
     * then don't allow any further read requests.
     */
    if (pChannel->Flags & CHANNEL_CLOSING) {
        Status = STATUS_FILE_CLOSED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status));
        IcaUnlockChannel(pChannel);
        return Status;
    }

    /*
     * If the Winstation is terminating and Reads are cancelled
     * then don't allow any further read requests.
     */
    if (pChannel->Flags & CHANNEL_CANCEL_READS) {
        Status = STATUS_FILE_CLOSED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status));
        IcaUnlockChannel(pChannel);
        return Status;
    }



    if (InterlockedCompareExchange(&(pChannel->CompletionRoutineCount), 1, 0) == 0) {
    
        /*
         * If there is already input data available,
         * then use it to satisfy the caller's read request.
         */
        if ( !IsListEmpty( &pChannel->InputBufHead ) ) {
            _IcaProcessIrpList(pChannel);

            if (!IsListEmpty( &pChannel->InputBufHead )) {
                Status = _IcaReadChannelComplete( pChannel, Irp, IrpSp );

                TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3, "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, Status ));

                _IcaProcessIrpList(pChannel);                        
            }
            else {
                Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);    
            }            
        }
        else {
            Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);    
        }
        
        InterlockedDecrement(&(pChannel->CompletionRoutineCount));
        ASSERT(pChannel->CompletionRoutineCount == 0);                                    
    }
    else {
        Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);            
    }
    
    /*
     * Unlock channel now
     */
    if (bChannelAlreadyLocked) {
        IcaDereferenceChannel( pChannel ); 
    }
    else {
        IcaUnlockChannel(pChannel);
    }
    return Status;
}

void _IcaProcessIrpList(
        IN PICA_CHANNEL pChannel)
{
    KIRQL cancelIrql;
    PIRP irpFromQueue;
    PIO_STACK_LOCATION irpSpFromQueue;
    PLIST_ENTRY irpQueueHead;
    NTSTATUS irpStatus;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    /*
     * Acquire IoCancel spinlock while checking InputIrp list
     */
    IoAcquireCancelSpinLock( &cancelIrql );

    /*
     * If there is a pending read IRP, then remove it from the
     * list and try to complete it now.
     */
    
    while (!IsListEmpty( &pChannel->InputIrpHead ) && 
            !IsListEmpty( &pChannel->InputBufHead )) {

        irpQueueHead = RemoveHeadList( &pChannel->InputIrpHead );
        irpFromQueue = CONTAINING_RECORD( irpQueueHead, IRP, Tail.Overlay.ListEntry );
        irpSpFromQueue = IoGetCurrentIrpStackLocation( irpFromQueue );

        /*
         * Clear the cancel routine for this IRP
         */
        IoSetCancelRoutine( irpFromQueue, NULL );

        IoReleaseCancelSpinLock( cancelIrql );

        irpStatus = _IcaReadChannelComplete( pChannel, irpFromQueue, irpSpFromQueue );

        TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3, "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, irpStatus ));

        /*
         * Acquire IoCancel spinlock while checking InputIrp list
         */
        IoAcquireCancelSpinLock( &cancelIrql );                                        
    }

    IoReleaseCancelSpinLock( cancelIrql );                       
}

NTSTATUS _IcaQueueReadChannelRequest(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    NTSTATUS Status = STATUS_PENDING;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    /*
     * Acquire the IoCancel spinlock.
     * We use this spinlock to protect access to the InputIrp list.
     */
    IoAcquireCancelSpinLock(&cancelIrql);

    /*
     * No input data is available.
     * Add the Irp to the pending Irp list for this channel.
     */
    InsertTailList(&pChannel->InputIrpHead, &Irp->Tail.Overlay.ListEntry);
    IoMarkIrpPending(Irp);
    /*
     * If this IRP is being cancelled, then cancel it now.
     * Otherwise, set the cancel routine for this request.
     */
    if (Irp->Cancel) {
        Irp->CancelIrql = cancelIrql;
        _IcaReadChannelCancelIrp(IrpSp->DeviceObject, Irp);
        TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3,
                "TermDD: _IcaQueueReadChannelRequest, cc %u, vc %d (canceled)\n",
                pChannel->ChannelClass, pChannel->VirtualClass));
        return STATUS_CANCELLED;
    }

    IoSetCancelRoutine(Irp, _IcaReadChannelCancelIrp);
    IoReleaseCancelSpinLock(cancelIrql);

    TRACECHANNEL((pChannel, TC_ICADD, TT_IN3,
            "TermDD: _IcaQueueReadChannelRequest, cc %u, vc %d (pending)\n",
            pChannel->ChannelClass, pChannel->VirtualClass));
    
    return STATUS_PENDING;

}

NTSTATUS _IcaReadChannelComplete(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PINBUF pInBuf;
    PVOID pBuffer;
    ULONG CopyCount;
    NTSTATUS Status;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    TRACECHANNEL(( pChannel, TC_ICADD, TT_IN4, "TermDD: _IcaReadChannelComplete, cc %u, vc %d\n",
                   pChannel->ChannelClass, pChannel->VirtualClass ));

    /*
     * Get pointer to first input buffer
     */
    ASSERT( !IsListEmpty( &pChannel->InputBufHead ) );
    Head = pChannel->InputBufHead.Flink;
    pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
     
    /*
     * Clear the cancel routine for this IRP,
     * since one way or the other it will be completed.
     */
    IoAcquireCancelSpinLock( &cancelIrql );
    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( cancelIrql );

    /*
     * If this is a message mode channel, all data from a single input
     * buffer must fit in the user buffer, otherwise we return an error.
     */
    if (IrpSp->Parameters.Read.Length < pInBuf->ByteCount &&
            (pChannel->Flags & CHANNEL_MESSAGE_MODE)) {
        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR,
                       "TermDD: _IcaReadChannelComplete: cc %u, vc %d (buffer too small)\n",
                       pChannel->ChannelClass, pChannel->VirtualClass ));
        return STATUS_BUFFER_TOO_SMALL;
    }

    /*
     * Determine amount of data to copy to user's buffer.
     */
    CopyCount = min(IrpSp->Parameters.Read.Length, pInBuf->ByteCount);

    /*
     * Copy input data to user's buffer
     */
    Status = _IcaCopyDataToUserBuffer(Irp, pInBuf->pBuffer, CopyCount);

    
    /*
     * Update ICA buffer pointer and bytes remaining.
     * If no bytes remain, then unlink the input buffer and free it.
     */
    if ( Status == STATUS_SUCCESS ) {
        pChannel->InputBufCurSize -= CopyCount;
        pInBuf->pBuffer += CopyCount;
        pInBuf->ByteCount -= CopyCount;
        if ( pInBuf->ByteCount == 0 ) {
            RemoveEntryList( &pInBuf->Links );
            ICA_FREE_POOL( pInBuf );
        }
    }

    /*
     * Mark the Irp complete
     */
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IcaPriorityBoost );
    TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3,
                   "TermDD: _IcaReadChannelComplete: cc %u, vc %d, bc %u, 0x%x\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, CopyCount, Status ));    
    
    return Status;
}


NTSTATUS _IcaCopyDataToUserBuffer(
        IN PIRP Irp,
        IN PUCHAR pBuffer,
        IN ULONG ByteCount)
{
    NTSTATUS Status;

    /*
     * If we are in the context of the original caller's process,
     * then just copy the data into the user's buffer directly.
     */
    if ( IoGetRequestorProcess( Irp ) == IoGetCurrentProcess() ) {
        try {
            Status = STATUS_SUCCESS;
            RtlCopyMemory( Irp->UserBuffer, pBuffer, ByteCount );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
        }

    /*
     * If there is a MDL allocated for this IRP, then copy the data
     * directly to the users buffer via the MDL.
     */
    } else if ( Irp->MdlAddress ) {
        PVOID UserBuffer;

        UserBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );
        try {
            if (UserBuffer != NULL) {
                Status = STATUS_SUCCESS;
                RtlCopyMemory( UserBuffer, pBuffer, ByteCount );
            }else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
        }

    /*
     * There is no MDL for this request.  We must allocate a secondary
     * buffer, copy the data to it, and indicate this is a buffered I/O
     * request in the IRP.  The I/O completion routine will copy the
     * data to the user's buffer.
     */
    } else {
        ASSERT( Irp->AssociatedIrp.SystemBuffer == NULL );
        Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( PagedPool,
                                                                 ByteCount,
                                                                 ICA_POOL_TAG );
        if ( Irp->AssociatedIrp.SystemBuffer == NULL )
            return( STATUS_INSUFFICIENT_RESOURCES );
        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, pBuffer, ByteCount );
        Irp->Flags |= (IRP_BUFFERED_IO |
                       IRP_DEALLOCATE_BUFFER |
                       IRP_INPUT_OPERATION);
        Status = STATUS_SUCCESS;
    }

    if ( Status == STATUS_SUCCESS )
        Irp->IoStatus.Information = ByteCount;

    return Status;
}


VOID _IcaReadChannelCancelIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION IrpSp;
    PICA_CHANNEL pChannel;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    pChannel = IrpSp->FileObject->FsContext;

    /*
     * Remove IRP from channel pending IRP list and release cancel spinlock
     */
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    /*
     * Complete the IRP with a cancellation status code.
     */
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IcaPriorityBoost);
}


NTSTATUS IcaWriteChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This is the write routine for ICA channels.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet.  Flags, specific to this
    driver, can be specified as a pointer to a ULONG flags value.  
    The pointer to this value is the first element in the 
    IRP.Tail.Overlay.DriverContext field.  
    
    Currently, only CHANNEL_WRITE_LOWPRIO is supported.  Write IRP's with
    this flag set will take lower priority than Write IRP's without this
    flag set.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    SD_CHANNELWRITE SdWrite;
    NTSTATUS Status = STATUS_PENDING;

    /*
     * Determine the channel type to see if write is supported.
     */
    switch ( pChannel->ChannelClass ) {

        case Channel_Virtual :
            if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        /*
         * Write not supported for the following channels
         */
        case Channel_Command :
        case Channel_Keyboard :
        case Channel_Mouse :
        case Channel_Video :
        case Channel_Beep :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            ASSERTMSG( "ICA.SYS: Invalid Channel Class", FALSE );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    /*
     * If the channel is being closed,
     * then don't allow any further write requests.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING )
        Status = STATUS_FILE_CLOSED;

    /*
     * If write length is 0, or an error is being returned, return now.
     */
    if ( Status == STATUS_PENDING && IrpSp->Parameters.Write.Length == 0 )
        Status = STATUS_SUCCESS;
    if ( Status != STATUS_PENDING ) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "TermDD: IcaWriteChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, Status ));
        return( Status );
    }

    /*
     * Verify user's buffer is valid
     */
    if ( Irp->RequestorMode != KernelMode ) {
        try {
            ProbeForRead( Irp->UserBuffer, IrpSp->Parameters.Write.Length, sizeof(BYTE) );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, IcaPriorityBoost );
            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "TermDD: IcaWriteChannel, cc %u, vc %d, 0x%x\n",
                           pChannel->ChannelClass, pChannel->VirtualClass, Status ));
            return( Status );
        }
    }

    /*
     * Call the top level stack driver to handle the write
     */
    SdWrite.ChannelClass = pChannel->ChannelClass;
    SdWrite.VirtualClass = pChannel->VirtualClass;
    SdWrite.pBuffer = Irp->UserBuffer;
    SdWrite.ByteCount = IrpSp->Parameters.Write.Length;
    SdWrite.fScreenData = (BOOLEAN)(pChannel->Flags & CHANNEL_SCREENDATA);
    SdWrite.fFlags = 0;

    /*
     * See if the low prio write flag is set in the IRP.
     *
	 * The flags field is passed to termdd.sys via an IRP_MJ_WRITE 
	 * Irp, as a ULONG pointer in the Irp->Tail.Overlay.DriverContext[0] field.     
     */
    if (Irp->Tail.Overlay.DriverContext[0] != NULL) {
        ULONG flags = *((ULONG *)Irp->Tail.Overlay.DriverContext[0]);
        if (flags & CHANNEL_WRITE_LOWPRIO) {
            SdWrite.fFlags |= SD_CHANNELWRITE_LOWPRIO;
        }
    }

    Status = IcaCallDriver( pChannel, SD$CHANNELWRITE, &SdWrite );

    /*
     * Complete the IRP now since all channel writes are synchronous
     * (the user data is captured by the stack driver before returning).
     */
    Irp->IoStatus.Status = Status;
    if ( Status == STATUS_SUCCESS )
        Irp->IoStatus.Information = IrpSp->Parameters.Write.Length;
    IoCompleteRequest( Irp, IcaPriorityBoost );

    TRACECHANNEL(( pChannel, TC_ICADD, TT_OUT3, "TermDD: IcaWriteChannel, cc %u, vc %d, bc %u, 0x%x\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, SdWrite.ByteCount, Status ));

    return Status;
}


NTSTATUS IcaDeviceControlChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    ULONG code;
    PICA_TRACE_BUFFER pTraceBuffer;
    NTSTATUS Status;


    /*
     * If the channel is being closed,
     * then don't allow any further requests.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING )
        return( STATUS_FILE_CLOSED );

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;


#if DBG
    if ( code != IOCTL_ICA_CHANNEL_TRACE ) {
        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlChannel, fc %d, ref %u (enter)\n",
                       (code & 0x3fff) >> 2, pChannel->RefCount ));
    }
#endif
    

    /*
     *  Process generic channel ioctl requests
     */
    try {
        switch ( code ) {

            case IOCTL_ICA_CHANNEL_TRACE :

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) )
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                pTraceBuffer = (PICA_TRACE_BUFFER)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                IcaLockConnection( pChannel->pConnect );
                IcaTraceFormat( &pChannel->pConnect->TraceInfo,
                                pTraceBuffer->TraceClass,
                                pTraceBuffer->TraceEnable,
                                pTraceBuffer->Data );
                IcaUnlockConnection( pChannel->pConnect );

                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO:

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags |= CHANNEL_SESSION_DISABLEIO;
                Status = IcaFlushChannel( pChannel, Irp, IrpSp );
                IcaUnlockConnection( pChannel->pConnect );
                break;

            case IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO:

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags &= ~CHANNEL_SESSION_DISABLEIO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL : 
                
                IcaLockConnection( pChannel->pConnect );
                Status = IcaCancelReadChannel(pChannel, Irp, IrpSp);                
                IcaUnlockConnection( pChannel->pConnect );
                break;

            case IOCTL_ICA_CHANNEL_ENABLE_SHADOW :

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags |= CHANNEL_SHADOW_IO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_DISABLE_SHADOW :

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags &= ~CHANNEL_SHADOW_IO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_END_SHADOW : 
            {
                PLIST_ENTRY Head, Next;
                PICA_STACK pStack;
                BOOLEAN bShadowEnded = FALSE;
                PICA_CHANNEL_END_SHADOW_DATA pData;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ICA_CHANNEL_END_SHADOW_DATA) ) {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                    break;
                }
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                pData = (PICA_CHANNEL_END_SHADOW_DATA)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                /*
                 * Lock the connection object.
                 * This will serialize all channel calls for this connection.
                 */
                IcaLockConnection( pChannel->pConnect );
                if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                    IcaUnlockConnection( pChannel->pConnect );
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                /*
                 * Look for shadow stack(s).
                 */
                Head = &pChannel->pConnect->StackHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                    pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

                    /*
                     * If this is a shadow stack, end it.
                     */
                    if ( pStack->StackClass == Stack_Shadow ) {
                        if ( pStack->pBrokenEventObject ) {
                            KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
                            bShadowEnded = TRUE;
                        }
                    }
                }

                /*
                 * Unlock the connection object now.
                 */
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;

                if (bShadowEnded && pData->bLogError) {
                    IcaLogError(NULL, pData->StatusCode, NULL, 0, NULL, 0);
                }
                break;
            }

            // This IOCTL is not supported by RDP or ICA driver
            case IOCTL_VIDEO_ENUM_MONITOR_PDO:

                Status = STATUS_DEVICE_NOT_READY;
                break;
    

            default :

                /*
                 * Call the appropriate worker routine based on channel type
                 */
                switch ( pChannel->ChannelClass ) {

                    case Channel_Keyboard :
                        Status = IcaDeviceControlKeyboard( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Mouse :
                        Status = IcaDeviceControlMouse( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Video :
                        Status = IcaDeviceControlVideo( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Beep :
                        Status = IcaDeviceControlBeep( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Virtual :
                        Status = IcaDeviceControlVirtual( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Command :
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;

                    default:
                        ASSERTMSG( "ICA.SYS: Invalid Channel Class", FALSE );
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }
        }
    } except( IcaExceptionFilter( L"IcaDeviceControlChannel TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }

#if DBG
    if ( code != IOCTL_ICA_CHANNEL_TRACE ) {
        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlChannel, fc %d, ref %u, 0x%x\n",
                       (code & 0x3fff) >> 2, pChannel->RefCount, Status ));
    }
#endif
    

    return Status;
}


NTSTATUS IcaFlushChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PINBUF pInBuf;

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaFlushChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Lock channel while we flush any input buffers.
     */
    IcaLockChannel(pChannel);

    while (!IsListEmpty( &pChannel->InputBufHead)) {
        Head = RemoveHeadList(&pChannel->InputBufHead);
        pInBuf = CONTAINING_RECORD(Head, INBUF, Links);
        ICA_FREE_POOL(pInBuf);
    }

    IcaUnlockChannel(pChannel);

    return STATUS_SUCCESS;
}


NTSTATUS IcaCleanupChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PIRP ReadIrp;
    PINBUF pInBuf;

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaCleanupChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Decrement the open count; if it is 0, perform channel cleanup now.
     */
    ASSERT(pChannel->OpenCount > 0);
    if (InterlockedDecrement( &pChannel->OpenCount) == 0) {

        /*
         * Lock channel while we clear out any
         * pending read IRPs and/or input buffers.
         */
        IcaLockChannel(pChannel);

        /*
         * Indicate this channel is being closed
         */
        pChannel->Flags |= CHANNEL_CLOSING;

        IoAcquireCancelSpinLock( &cancelIrql );
        while ( !IsListEmpty( &pChannel->InputIrpHead ) ) {
            Head = pChannel->InputIrpHead.Flink;
            ReadIrp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
            ReadIrp->CancelIrql = cancelIrql;
            IoSetCancelRoutine( ReadIrp, NULL );
            _IcaReadChannelCancelIrp( IrpSp->DeviceObject, ReadIrp );
            IoAcquireCancelSpinLock( &cancelIrql );
        }
        IoReleaseCancelSpinLock( cancelIrql );

        while ( !IsListEmpty( &pChannel->InputBufHead ) ) {
            Head = RemoveHeadList( &pChannel->InputBufHead );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            ICA_FREE_POOL( pInBuf );
        }

        IcaUnlockChannel(pChannel);
    }

    return STATUS_SUCCESS;
}


NTSTATUS IcaCloseChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    PICA_CONNECTION pConnect;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API2, "TermDD: IcaCloseChannel, cc %u, vc %d, vn %s\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, pChannel->VirtualName ));

    pConnect = pChannel->pConnect;

    /*
     * Remove the file object reference for this channel.
     */
    IcaDereferenceChannel(pChannel);

    return STATUS_SUCCESS;
}


NTSTATUS IcaChannelInput(
        IN PSDCONTEXT pContext,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount)

/*++

Routine Description:

    This is the input (stack callup) routine for ICA channel input.

Arguments:

    pContext - Pointer to SDCONTEXT for this Stack Driver

    ChannelClass - Channel number for input

    VirtualClass - Virtual channel number for input

    pInBuf - Pointer to INBUF containing data

    pBuffer - Pointer to input data

        NOTE: Either pInBuf OR pBuffer must be specified, but not both.

    ByteCount - length of data in pBuffer

Return Value:

    NTSTATUS -- Indicates whether the request was handled successfully.

--*/

{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;   // save stack pointer for use below
    pConnect = IcaGetConnectionForStack( pStack );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaChannelInput, bc=%u (enter)\n", ByteCount ));

    /*
     * Only the stack object should be locked during input.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a ChannelInput callup routine.  If we find one, then call the
     * driver ChannelInput routine to let it handle the call.
     */
    while ( (pSdLink = IcaGetPreviousSdLink( pSdLink )) != NULL ) {
        ASSERT( pSdLink->pStack == pStack );
        if ( pSdLink->SdContext.pCallup->pSdChannelInput ) {
            IcaReferenceSdLink( pSdLink );
            Status = (pSdLink->SdContext.pCallup->pSdChannelInput)(
                        pSdLink->SdContext.pContext,
                        ChannelClass,
                        VirtualClass,
                        pInBuf,
                        pBuffer,
                        ByteCount );
            IcaDereferenceSdLink( pSdLink );
            return Status;
        }
    }

    return IcaChannelInputInternal(pStack, ChannelClass, VirtualClass,
            pInBuf, pBuffer, ByteCount);
}


NTSTATUS IcaChannelInputInternal(
        IN PICA_STACK pStack,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount)
{
    PICA_COMMAND_HEADER pHeader;
    PICA_CONNECTION pConnect;
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    KIRQL cancelIrql;
    ULONG CopyCount;
    NTSTATUS Status;
    SD_IOCTL SdIoctl;

    TRACESTACK(( pStack, TC_ICADD, TT_API2,
                 "TermDD: IcaChannelInputInternal: cc %u, vc %d, bc %u\n",
                 ChannelClass, VirtualClass, ByteCount ));

    /*
     *  Check for channel command
     */
    switch ( ChannelClass ) {

        case Channel_Keyboard :
        case Channel_Mouse :
            KeQuerySystemTime( &pStack->LastInputTime );
            break;

        case Channel_Command :

            if ( ByteCount < sizeof(ICA_COMMAND_HEADER) ) {
                TRACESTACK(( pStack, TC_ICADD, TT_ERROR,
                             "TermDD: IcaChannelInputInternal: Channel_command bad bytecount\n" ));
                break;
            }

            pHeader = (PICA_COMMAND_HEADER) pBuffer;

            switch ( pHeader->Command ) {
                case ICA_COMMAND_BROKEN_CONNECTION :
                    TRACESTACK(( pStack, TC_ICADD, TT_API1,
                                 "TermDD: IcaChannelInputInternal, Broken Connection\n" ));

                    /* set closing flag */
                    pStack->fClosing = TRUE;

                    /*
                     *  Send cancel i/o to stack drivers
                     *  - fClosing flag must be set before issuing cancel i/o
                     */
                    SdIoctl.IoControlCode = IOCTL_ICA_STACK_CANCEL_IO;
                    (void) _IcaCallStackNoLock( pStack, SD$IOCTL, &SdIoctl );

                    /*
                     * If a broken event has been registered for this stack,
                     * then signal the event now.
                     * NOTE: In this case we exit without forwarding the
                     *       broken notification to the channel.
                     */
                    if ( pStack->pBrokenEventObject ) {
                        KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
                        ObDereferenceObject( pStack->pBrokenEventObject );
                        pStack->pBrokenEventObject = NULL;
                        if ( pInBuf )
                            ICA_FREE_POOL( pInBuf );
                        return( STATUS_SUCCESS );
                    }
                    break;
            }
            break;
    }

    /*
     * Get the specified channel for this input packet.
     * If not found, we have no choice but to bit-bucket the data.
     */
    pConnect = IcaGetConnectionForStack(pStack);
    pChannel = IcaFindChannel(pConnect, ChannelClass, VirtualClass);
    if (pChannel == NULL) {
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);
        TRACESTACK((pStack, TC_ICADD, TT_ERROR,
                "TermDD: IcaChannelInputInternal: channel not found\n" ));
        return STATUS_SUCCESS;
    }

    /*
     * Lock channel while processing I/O
     */
    IcaLockChannel(pChannel);

    /*
     * If input is from a shadow stack and this channel should not
     * process shadow I/O then bit bucket the data.
     * Do the same if the channel is closing or IO are disabled.
     */
    if ( (pChannel->Flags & (CHANNEL_SESSION_DISABLEIO | CHANNEL_CLOSING)) ||
         (pStack->StackClass == Stack_Shadow &&
           !(pChannel->Flags & CHANNEL_SHADOW_IO)) ) {

        IcaUnlockChannel(pChannel);
        IcaDereferenceChannel(pChannel);
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);
        TRACESTACK((pStack, TC_ICADD, TT_API2,
                "TermDD: IcaChannelInputInternal: shadow or closing channel input\n"));
        return STATUS_SUCCESS;
    }

    /*
     * If input is from an INBUF, initialize pBuffer and ByteCount
     * with values from the buffer header.
     */
    if (pInBuf) {
        pBuffer = pInBuf->pBuffer;
        ByteCount = pInBuf->ByteCount;
    }

    /*
     * If there is a channel filter loaded for this channel,
     * then pass the input data through it before going on.
     */
    if (pChannel->pFilter) {
        PINBUF pFilterBuf;

        pChannel->pFilter->InputFilter(pChannel->pFilter, pBuffer, ByteCount,
                &pFilterBuf);
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);

        /*
         * Refresh INBUF pointer, buffer pointer, and byte count.
         */
        pInBuf = pFilterBuf;
        pBuffer = pInBuf->pBuffer;
        ByteCount = pInBuf->ByteCount;
    }


    /*
     * Process the input data
     */
    while ( ByteCount != 0 ) {

        /*
         * If this is a shadow stack, see if the stack we're shadowing is
         * for a console session
         */
        if (pStack->StackClass == Stack_Shadow)
        {
            PICA_STACK  pTopStack;
            PLIST_ENTRY Head, Next;

            Head = &pConnect->StackHead;
            Next = Head->Flink;

            pTopStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

            if (pTopStack->StackClass == Stack_Console)
            {
                /*
                 * It is the console, so put on our keyboard/mouse port
                 * driver hat and inject the input that way
                 */
                if (ChannelClass == Channel_Mouse)
                {
                    MOUSE_INPUT_DATA *pmInputData;
                    ULONG count;

                    pmInputData = (MOUSE_INPUT_DATA *)pBuffer;
                    count = ByteCount / sizeof(MOUSE_INPUT_DATA);

                    /*
                     * This function will always consume all the data
                     */
                    PtSendCurrentMouseInput(MouDeviceObject, pmInputData, count);
                    ByteCount = 0;
                    continue;
                }
                else if (ChannelClass == Channel_Keyboard)
                {
                    KEYBOARD_INPUT_DATA *pkInputData;
                    ULONG count;

                    pkInputData = (KEYBOARD_INPUT_DATA *)pBuffer;
                    count = ByteCount / sizeof(KEYBOARD_INPUT_DATA);

                    /*
                     * This function will always consume all the data
                     */
                    PtSendCurrentKeyboardInput(KbdDeviceObject, pkInputData, count);
                    ByteCount = 0;
                    continue;
                }
            }
        }
        /*
         * Acquire IoCancel spinlock while checking InputIrp list
         */
        IoAcquireCancelSpinLock( &cancelIrql );

        /*
         * If there is a pending read IRP, then remove it from the
         * list and try to complete it now.
         */
        if ( !IsListEmpty( &pChannel->InputIrpHead ) ) {

            Head = RemoveHeadList( &pChannel->InputIrpHead );
            Irp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            /*
             * Clear the cancel routine for this IRP
             */
            IoSetCancelRoutine( Irp, NULL );
            IoReleaseCancelSpinLock( cancelIrql );

            /*
             * If this is a message mode channel, all data from a single input
             * buffer must fit in the user buffer, otherwise we return an error.
             */
            if ( IrpSp->Parameters.Read.Length < ByteCount &&
                 (pChannel->Flags & CHANNEL_MESSAGE_MODE) ) {
                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                IoCompleteRequest( Irp, IcaPriorityBoost );
                TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
                               "TermDD: IcaChannelInputInternal: cc %u, vc %d, (too small)\n",
                               ChannelClass, VirtualClass ));
                continue;
            }

            /*
             * Determine amount of data to copy to user's buffer.
             */
            CopyCount = min( IrpSp->Parameters.Read.Length, ByteCount );

            /*
             * Copy input data to user's buffer
             */
            Status = _IcaCopyDataToUserBuffer( Irp, pBuffer, CopyCount );

            /*
             * Mark the Irp complete and return success
             */
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, IcaPriorityBoost );
            TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
                           "TermDD: IcaChannelInputInternal: cc %u, vc %d, bc %u, 0x%x\n",
                           ChannelClass, VirtualClass, CopyCount, Status ));

            /*
             * Update input data pointer and count remaining.
             * Note no need to update pChannel->InputBufCurSize since we never
             * stored this data.
             */
            if ( Status == STATUS_SUCCESS ) {
                pBuffer += CopyCount;
                ByteCount -= CopyCount;
                if ( pInBuf ) {
                    pInBuf->pBuffer += CopyCount;
                    pInBuf->ByteCount -= CopyCount;
                }
            }

        /*
         * There are no pending IRPs for this channel, so just queue the data.
         */
        } else {

            IoReleaseCancelSpinLock( cancelIrql );

            /*
             * Check to see if we need to discard the data (too much data
             * backed up). This policy only takes effect when the max size
             * is nonzero, which is currently only the case for mouse and
             * keyboard inputs which can withstand being dropped.
             * Note that the read IRPs sent for channels that can have
             * data dropped must request in integral numbers of input
             * blocks -- e.g. a mouse read IRP must have a read buffer size
             * that is a multiple of sizeof(MOUSE_INPUT_DATA). If this is
             * not the case the immediate-copy block above may copy
             * partial input blocks before arriving here.
             */
            if (pChannel->InputBufMaxSize == 0 ||
                    (pChannel->InputBufCurSize + ByteCount) <=
                    pChannel->InputBufMaxSize) {
                /*
                 * If necessary, allocate an input buffer and copy the data
                 */
                if (pInBuf == NULL) {
                    /*
                     * Get input buffer and copy the data
                     * If this fails, we have no choice but to bail out.
                     */
                    pInBuf = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(INBUF) +
                            ByteCount);
                    if (pInBuf != NULL) {
                        pInBuf->ByteCount = ByteCount;
                        pInBuf->MaxByteCount = ByteCount;
                        pInBuf->pBuffer = (PUCHAR)(pInBuf + 1);
                        RtlCopyMemory(pInBuf->pBuffer, pBuffer, ByteCount);
                    }
                    else {
                        break;
                    }
                }

                /*
                 * Add buffer to tail of input list and clear pInBuf
                 * to indicate we have no buffer to free when done.
                 */
                InsertTailList( &pChannel->InputBufHead, &pInBuf->Links );
                pChannel->InputBufCurSize += ByteCount;
                pInBuf = NULL;

                /*
                 * If any read(s) were posted while we allocated the input
                 * buffer, then try to complete as many as possible.
                 */
                IoAcquireCancelSpinLock( &cancelIrql );
                while ( !IsListEmpty( &pChannel->InputIrpHead ) &&
                        !IsListEmpty( &pChannel->InputBufHead ) ) {

                    Head = RemoveHeadList( &pChannel->InputIrpHead );
                    Irp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
                    IoSetCancelRoutine( Irp, NULL );
                    IoReleaseCancelSpinLock( cancelIrql );

                    IrpSp = IoGetCurrentIrpStackLocation( Irp );

                    Status = _IcaReadChannelComplete( pChannel, Irp, IrpSp );
                    IoAcquireCancelSpinLock( &cancelIrql );
                }
                IoReleaseCancelSpinLock( cancelIrql );
            }
            else {
                TRACESTACK(( pStack, TC_ICADD, TT_ERROR,
                        "TermDD: IcaChannelInputInternal: Dropped %u bytes "
                        "on channelclass %u\n", ByteCount, ChannelClass));
            }

            break;
        }
    }

    /*
     * Unlock channel now
     */
    IcaUnlockChannel(pChannel);

    /*
     * If we still have an INBUF, free it now.
     */
    if (pInBuf)
        ICA_FREE_POOL(pInBuf);

    /*
     * Decrement channel refcount and return
     */
    IcaDereferenceChannel(pChannel);

    return STATUS_SUCCESS;
}


/****************************************************************************/
// IcaFindChannel
// IcaFindChannelByName
//
// Searches for a given channel in the connection channel list, and returns
// a pointer to it (with an added reference). Returns NULL if not found.
/****************************************************************************/
PICA_CHANNEL IcaFindChannel(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass)
{
    PICA_CHANNEL pChannel;
    KIRQL oldIrql;
    NTSTATUS Status;

    /*
     * Ensure we're not looking for an invalid virtual channel number
     */
    ASSERT( ChannelClass != Channel_Virtual ||
            (VirtualClass >= 0 && VirtualClass < VIRTUAL_MAXIMUM) );

    /*
     * If channel does not exist, return NULL.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    pChannel = pConnect->pChannel[ ChannelClass + VirtualClass ];

    if (pChannel == NULL) {
        TRACE(( pConnect, TC_ICADD, TT_API3,
                "TermDD: IcaFindChannel, cc %u, vc %d (not found)\n",
                ChannelClass, VirtualClass ));
        IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
        return NULL;
    }

    IcaReferenceChannel(pChannel);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  

    TRACE((pConnect, TC_ICADD, TT_API3,
            "TermDD: IcaFindChannel, cc %u, vc %d -> %s\n",
            ChannelClass, VirtualClass, pChannel->VirtualName));

    return pChannel;
}


PICA_CHANNEL IcaFindChannelByName(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head, Next;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     *  If this is not a virtual channel use channel class only
     */
    if (ChannelClass != Channel_Virtual) {
        return IcaFindChannel( pConnect, ChannelClass, 0);
    }

    /*
     * Search the existing channel structures to locate virtual channel name
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    Head = &pConnect->ChannelHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pChannel = CONTAINING_RECORD( Next, ICA_CHANNEL, Links );
        if ( (pChannel->ChannelClass == Channel_Virtual) &&
             !_stricmp( pChannel->VirtualName, pVirtualName ) ) {
            break;
        }
    }

    /*
     * If name does not exist, return unbound
     */
    if (Next == Head) {
        TRACE((pConnect, TC_ICADD, TT_API2,
                "TermDD: IcaFindChannelByName: vn %s (not found)\n", pVirtualName));
        IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
        return(NULL);
    }

    IcaReferenceChannel(pChannel);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: IcaFindChannelByName: vn %s, vc %d, ref %u\n",
            pVirtualName, pChannel->VirtualClass,
            (pChannel != NULL ? pChannel->RefCount : 0)));

    return pChannel;
}


VOID IcaReferenceChannel(IN PICA_CHANNEL pChannel)
{
    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaReferenceChannel: cc %u, vc %d, ref %u\n",
            pChannel->ChannelClass, pChannel->VirtualClass, pChannel->RefCount));

    ASSERT(pChannel->RefCount >= 0);

    /*
     * Increment the reference count
     */
    if (InterlockedIncrement( &pChannel->RefCount) <= 0) {
        ASSERT(FALSE);
    }
}


VOID IcaDereferenceChannel(
        IN PICA_CHANNEL pChannel)
{
    BOOLEAN bNeedLock = FALSE;
    BOOLEAN bChannelFreed = FALSE;
    PERESOURCE pResource = pChannel->pChannelTableLock;
    PICA_CONNECTION pConnect = pChannel->pConnect;
    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaDefeferenceChannel: cc %u, vc %d, ref %u\n",
            pChannel->ChannelClass, pChannel->VirtualClass,
            pChannel->RefCount));

    ASSERT(pChannel->RefCount > 0);

    /*
     * Lock the channel table since a reference going to Zero would cause
     * to change table entry.
     */
    if (pChannel->RefCount == 1) {
        bNeedLock = TRUE;
        IcaLockChannelTable(pResource);
    }

    /*
     * Decrement the reference count; if it is 0, free the channel.
     */
    if (InterlockedDecrement(&pChannel->RefCount) == 0){
        ASSERT(bNeedLock);
        _IcaFreeChannel(pChannel);
        bChannelFreed = TRUE;
    }

    if (bNeedLock) {
        IcaUnlockChannelTable(pResource);  
    }

    /*
     * Remove the reference to the Connection object for this channel.
     * moved this here from _IcaFreeChannel because we need to be sure
     * the connection object can't go away before the call to IcaUnlockChannelTable
     * because the connection object is where the channel table locck live.
     */
    if (bChannelFreed) {
        IcaDereferenceConnection(pConnect);
    }
}


NTSTATUS IcaBindVirtualChannels(IN PICA_STACK pStack)
{
    PICA_CONNECTION pConnect;
    PSD_VCBIND pSdVcBind = NULL;
    SD_VCBIND aSdVcBind[ VIRTUAL_MAXIMUM ];
    ULONG SdVcBindCount;
    VIRTUALCHANNELCLASS VirtualClass;
    PICA_CHANNEL pChannel;
    NTSTATUS Status;
    ULONG i, Flags;
    SD_IOCTL SdIoctl;

    pConnect = IcaLockConnectionForStack(pStack);

    SdIoctl.IoControlCode = IOCTL_ICA_VIRTUAL_QUERY_BINDINGS;
    SdIoctl.InputBuffer = NULL;
    SdIoctl.InputBufferLength = 0;
    SdIoctl.OutputBuffer = aSdVcBind;
    SdIoctl.OutputBufferLength = sizeof(aSdVcBind);
    Status = _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);
    if (NT_SUCCESS(Status)) {
        pSdVcBind = &aSdVcBind[0];
        SdVcBindCount = SdIoctl.BytesReturned / sizeof(SD_VCBIND);

        for (i = 0; i < SdVcBindCount; i++, pSdVcBind++) {
            TRACE((pConnect, TC_ICADD, TT_API2,
                    "TermDD: IcaBindVirtualChannels: %s -> %d Flags=%x\n",
                    pSdVcBind->VirtualName, pSdVcBind->VirtualClass, pSdVcBind->Flags));

            /*
             *  Locate virtual class binding
             */
            VirtualClass = _IcaFindVcBind(pConnect, pSdVcBind->VirtualName, &Flags);

            /*
             *  If virtual class binding does not exist, create one
             */
            if (VirtualClass == UNBOUND_CHANNEL) {
                /*
                 * Allocate a new virtual bind object
                 */
                Status = _IcaRegisterVcBind(pConnect, pSdVcBind->VirtualName,
                        pSdVcBind->VirtualClass, pSdVcBind->Flags );
                if (!NT_SUCCESS(Status))
                    goto PostLockConnection;
            } 

            /*
             *  Locate channel object
             */
            pChannel = IcaFindChannelByName(pConnect, Channel_Virtual,
                    pSdVcBind->VirtualName);

            /*
             *  If we found an existing channel object - update it
             */
            if (pChannel != NULL) {
                IcaLockChannel(pChannel);
                _IcaBindChannel(pChannel, Channel_Virtual, pSdVcBind->VirtualClass, pSdVcBind->Flags);
                IcaUnlockChannel(pChannel);
                IcaDereferenceChannel(pChannel);
            }
        }
    }

PostLockConnection:
    IcaUnlockConnection(pConnect);
    return Status;
}


VOID IcaRebindVirtualChannels(IN PICA_CONNECTION pConnect)
{
    PLIST_ENTRY Head, Next;
    PICA_VCBIND pVcBind;
    PICA_CHANNEL pChannel;

    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD(Next, ICA_VCBIND, Links);

        /*
         *  Locate channel object
         */
        pChannel = IcaFindChannelByName(pConnect, Channel_Virtual,
                pVcBind->VirtualName);

        /*
         *  If we found an existing channel object - update it
         */
        if (pChannel != NULL) {
            IcaLockChannel(pChannel);
            _IcaBindChannel(pChannel, Channel_Virtual, pVcBind->VirtualClass, pVcBind->Flags);
            IcaUnlockChannel(pChannel);
            IcaDereferenceChannel(pChannel);
        }
    }
}


VOID IcaUnbindVirtualChannels(IN PICA_CONNECTION pConnect)
{
    PLIST_ENTRY Head, Next;
    PICA_CHANNEL pChannel;
    KIRQL oldIrql;

    /*
     * Loop through the channel list and clear the virtual class
     * for all virtual channels.  Also remove the channel pointer
     * from the channel pointers array in the connection object.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock);  
    Head = &pConnect->ChannelHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pChannel = CONTAINING_RECORD(Next, ICA_CHANNEL, Links);
        if (pChannel->ChannelClass == Channel_Virtual &&
                pChannel->VirtualClass != UNBOUND_CHANNEL) {
            pConnect->pChannel[pChannel->ChannelClass +
                    pChannel->VirtualClass] = NULL;
            pChannel->VirtualClass = UNBOUND_CHANNEL;
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
}


NTSTATUS IcaUnbindVirtualChannel(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PLIST_ENTRY Head, Next;
    PICA_CHANNEL pChannel;
    PICA_VCBIND pVcBind;
    KIRQL oldIrql;

    /*
     * Loop through the channel list and clear the virtual class
     * for the matching virtual channel.  Also remove the channel pointer
     * from the channel pointers array in the connection object.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock);  
    Head = &pConnect->ChannelHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pChannel = CONTAINING_RECORD(Next, ICA_CHANNEL, Links);
        if (pChannel->ChannelClass == Channel_Virtual &&
                pChannel->VirtualClass != UNBOUND_CHANNEL &&
                !_stricmp( pChannel->VirtualName, pVirtualName)) {
            pConnect->pChannel[pChannel->ChannelClass +
                    pChannel->VirtualClass] = NULL;
            pChannel->VirtualClass = UNBOUND_CHANNEL;
            break;
        }
    }

    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD( Next, ICA_VCBIND, Links );
        if (!_stricmp(pVcBind->VirtualName, pVirtualName)) {
            RemoveEntryList( &pVcBind->Links );
            ICA_FREE_POOL(pVcBind);
            IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
            return STATUS_SUCCESS;
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  

    return STATUS_OBJECT_NAME_NOT_FOUND;
}


PICA_CHANNEL _IcaAllocateChannel(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PICA_CHANNEL pChannel;
    VIRTUALCHANNELCLASS VirtualClass;
    KIRQL oldIrql;
    NTSTATUS Status;
    ULONG Flags;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pConnect->Resource));

    pChannel = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(*pChannel));
    if (pChannel == NULL)
        return( NULL );

    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaAllocateChannel: cc %u, vn %s, %x\n",
            ChannelClass, pVirtualName, pChannel));

    RtlZeroMemory(pChannel, sizeof(*pChannel));


    /*
     * Reference the connection object this channel belongs to
     */
    IcaReferenceConnection(pConnect);
    pChannel->pConnect = pConnect;
    pChannel->pChannelTableLock = &pConnect->ChannelTableLock;


    /*
     * Initialize channel reference count to 1;
     *   for the file object reference that will be made by the caller.
     */
    pChannel->RefCount = 1;
    pChannel->CompletionRoutineCount = 0;

    /*
     * Initialize the rest of the channel object for non-zero values.
     */
    pChannel->Header.Type = IcaType_Channel;
    pChannel->Header.pDispatchTable = IcaChannelDispatchTable;

    ExInitializeResourceLite(&pChannel->Resource);
    InitializeListHead(&pChannel->InputIrpHead);
    InitializeListHead(&pChannel->InputBufHead);

    IcaLockChannel(pChannel);

    if (ChannelClass == Channel_Virtual) {
        strncpy(pChannel->VirtualName, pVirtualName, VIRTUALCHANNELNAME_LENGTH);
        VirtualClass = _IcaFindVcBind(pConnect, pVirtualName, &Flags);
    } else {
        VirtualClass = 0;
        Flags = 0;
    }

    _IcaBindChannel(pChannel, ChannelClass, VirtualClass, Flags);

    /*
     *  Link channel object to connect object
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    InsertHeadList(&pConnect->ChannelHead, &pChannel->Links);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock); 

    /*
     * Set channel type specific flags/fields
     * (i.e. shadow I/O is implicitly enabled for the video, beep,
     *  and command channels; the command and all virtual channels
     *  are message mode channels)
     * Also sets throttling values taken from registry (if appropriate,
     * plus remember a zeromem done to channel struct above).
     */
    switch (ChannelClass) {
        case Channel_Keyboard:
            pChannel->InputBufMaxSize = SysParams.KeyboardThrottleSize;
            break;

        case Channel_Mouse :
            pChannel->InputBufMaxSize = SysParams.MouseThrottleSize;
            break;

        case Channel_Video :
        case Channel_Beep :
            pChannel->Flags |= CHANNEL_SHADOW_IO;
            break;

        case Channel_Command :
            pChannel->Flags |= CHANNEL_SHADOW_IO;
            /* fall through */

        case Channel_Virtual :
            pChannel->Flags |= CHANNEL_MESSAGE_MODE;
            if (!_stricmp( pVirtualName, VIRTUAL_THINWIRE)) {
                pChannel->Flags |= CHANNEL_SCREENDATA;
            }
            break;
    }

    // Per above assert, this function is assumed to be called while the
    // connection lock is held.
    IcaUnlockChannel(pChannel);

    return pChannel;
}


void _IcaFreeChannel(IN PICA_CHANNEL pChannel)
{
    KIRQL oldIrql;

    ASSERT(pChannel->RefCount == 0);
    ASSERT(IsListEmpty(&pChannel->InputIrpHead));
    ASSERT(IsListEmpty(&pChannel->InputBufHead));
    ASSERT(!ExIsResourceAcquiredExclusiveLite(&pChannel->Resource));

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: _IcaFreeChannel: cc %u, vn %s, \n",
            pChannel->ChannelClass, pChannel->VirtualName));



    /*
     * Unlink this channel from the channel list for this connection.
     * this routine must be called with channel table lock held.
     */

    RemoveEntryList(&pChannel->Links);

    if (pChannel->VirtualClass != UNBOUND_CHANNEL) {
        pChannel->pConnect->pChannel[pChannel->ChannelClass + pChannel->VirtualClass] = NULL;
    }


    ExDeleteResourceLite(&pChannel->Resource);

    ICA_FREE_POOL(pChannel);
}


NTSTATUS _IcaRegisterVcBind(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN ULONG Flags)
{
    PICA_VCBIND pVcBind;
    NTSTATUS Status;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pConnect->Resource));

    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaRegisterVcBind: %s -> %d\n",
            pVirtualName, VirtualClass));

    /*
     *  Allocate bind structure
     */
    pVcBind = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pVcBind) );
    if (pVcBind != NULL) {
        /*
         *  Initialize structure
         */
        RtlZeroMemory(pVcBind, sizeof(*pVcBind));
        strncpy(pVcBind->VirtualName, pVirtualName, VIRTUALCHANNELNAME_LENGTH);
        pVcBind->VirtualClass = VirtualClass;
        pVcBind->Flags = Flags;

        /*
         *  Link bind structure to connect object
         */
        InsertHeadList(&pConnect->VcBindHead, &pVcBind->Links);

        return STATUS_SUCCESS;
    }
    else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


VOID IcaFreeAllVcBind(IN PICA_CONNECTION pConnect)
{
    PICA_VCBIND pVcBind;
    PLIST_ENTRY Head;

    TRACE(( pConnect, TC_ICADD, TT_API2, "TermDD: IcaFreeAllVcBind\n" ));

    /*
     *  Free all bind structures
     */
    while ( !IsListEmpty( &pConnect->VcBindHead ) ) {
        Head = RemoveHeadList( &pConnect->VcBindHead );
        pVcBind = CONTAINING_RECORD( Head, ICA_VCBIND, Links );
        ICA_FREE_POOL( pVcBind );
    }

}


VIRTUALCHANNELCLASS _IcaFindVcBind(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName,
        OUT PULONG pFlags)
{
    PICA_VCBIND pVcBind;
    PLIST_ENTRY Head, Next;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * Search the existing VC bind structures to locate virtual channel name
     */
    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD(Next, ICA_VCBIND, Links);
        if (!_stricmp(pVcBind->VirtualName, pVirtualName)) {
            TRACE((pConnect, TC_ICADD, TT_API2,
                    "TermDD: _IcaFindVcBind: vn %s -> vc %d\n",
                    pVirtualName, pVcBind->VirtualClass));
            *pFlags = pVcBind->Flags;
            return pVcBind->VirtualClass;
        }
    }

    /*
     * If name does not exist, return UNBOUND_CHANNEL
     */
    TRACE(( pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaFindVcBind: vn %s (not found)\n", pVirtualName ));
    return UNBOUND_CHANNEL;
}


VOID _IcaBindChannel(
        IN PICA_CHANNEL pChannel,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN ULONG Flags)
{
    KIRQL oldIrql;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pChannel->Resource));

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
            "TermDD: _IcaBindChannel: cc %u, vn %s vc %d\n",
            ChannelClass, pChannel->VirtualName, VirtualClass ));

    pChannel->ChannelClass = ChannelClass;
    pChannel->VirtualClass = VirtualClass;
    IcaLockChannelTable(pChannel->pChannelTableLock);  

    if (Flags & SD_CHANNEL_FLAG_SHADOW_PERSISTENT)
        pChannel->Flags |= CHANNEL_SHADOW_PERSISTENT;

    if (VirtualClass != UNBOUND_CHANNEL) {
        ASSERT(pChannel->pConnect->pChannel[ChannelClass + VirtualClass] == NULL);
        pChannel->pConnect->pChannel[ChannelClass + VirtualClass] = pChannel;
    }
    IcaUnlockChannelTable(pChannel->pChannelTableLock);  
}



BOOLEAN IcaLockChannelTable(PERESOURCE pResource)
{
    KIRQL oldIrql;
    BOOLEAN Result;


    /*
     *  lock the channel  object
     */
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusiveLite( pResource, TRUE );

    return Result;
}


void IcaUnlockChannelTable(PERESOURCE pResource)
{

    ExReleaseResourceLite(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

}

NTSTATUS IcaCancelReadChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PIRP ReadIrp;
    PINBUF pInBuf;


    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaCancelReadChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Lock channel while we clear out any
     * pending read IRPs and/or input buffers.
     */
    IcaLockChannel(pChannel);

    /*
     * Indicate that Reads are cancelled to this channel
     */
    pChannel->Flags |= CHANNEL_CANCEL_READS;

    IoAcquireCancelSpinLock( &cancelIrql );
    while ( !IsListEmpty( &pChannel->InputIrpHead ) ) {
        Head = pChannel->InputIrpHead.Flink;
        ReadIrp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
        ReadIrp->CancelIrql = cancelIrql;
        IoSetCancelRoutine( ReadIrp, NULL );
        _IcaReadChannelCancelIrp( IrpSp->DeviceObject, ReadIrp );
        IoAcquireCancelSpinLock( &cancelIrql );
    }
    IoReleaseCancelSpinLock( cancelIrql );


    IcaUnlockChannel(pChannel);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\icaprocs.h ===
/*************************************************************************
*
* icap.h
*
* This module contains routine prototypes for the ICA driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN
IcaInitializeData (
    VOID
    );

VOID _cdecl
IcaTrace(
    IN ULONG TraceClass, 
    IN ULONG TraceEnable, 
    IN CHAR * Format, 
    IN ... );

VOID 
IcaTraceBuffer(
    IN ULONG TraceClass, 
    IN ULONG TraceEnable,
    IN PVOID pBuffer,
    IN ULONG ByteCount );

VOID
IcaTraceFormat( 
    IN PICA_TRACE_INFO pTraceInfo,
    IN ULONG TraceClass,
    IN ULONG TraceEnable,
    IN PCHAR pData );

NTSTATUS
IcaDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IcaCreateConnection (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreateStack (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreateChannel (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Channel IO dispatch routines
 */
NTSTATUS
IcaDeviceControlKeyboard (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlMouse (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlVideo (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlBeep (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlConsole (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlVirtual (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Stack Driver (SD) call routine
 */
NTSTATUS
IcaCallDriver(
    IN PICA_CHANNEL pChannel,
    IN ULONG ProcIndex,
    IN PVOID pParms
    );


/*
 * Miscellaneous worker routines
 */
VOID
IcaReferenceConnection(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaDereferenceConnection(
    IN PICA_CONNECTION pConnect
    );

PICA_CHANNEL
IcaFindChannelByName(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

PICA_CHANNEL
IcaFindChannel(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass
    );

VOID
IcaReferenceChannel(
    IN PICA_CHANNEL pChannel
    );

VOID IcaDereferenceChannel(IN PICA_CHANNEL);



BOOLEAN IcaLockChannelTable(
    PERESOURCE pResource);

void IcaUnlockChannelTable(
    PERESOURCE pResource);


VOID
IcaReferenceStack(
    IN PICA_STACK pStack
    );

VOID
IcaDereferenceStack(
    IN PICA_STACK pStack
    );

VOID
IcaReferenceSdLink(
    IN PSDLINK pSdLink
    );

VOID
IcaDereferenceSdLink(
    IN PSDLINK pSdLink
    );

PSDLINK
IcaGetNextSdLink(
    IN PSDLINK pSdLink
    );

PSDLINK
IcaGetPreviousSdLink(
    IN PSDLINK pSdLink
    );


VOID
IcaKeepAliveThread(
    IN PVOID pData
    );



NTSTATUS
CaptureUsermodeBuffer (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PVOID *pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID *pOutBuffer,
    IN ULONG OutBufferSize,
    IN BOOLEAN MethodBuffered,
    OUT PVOID *pAllocatedTemporaryBuffer
    );


/*
 * Internal versions of Stack Driver helper routines
 */
NTSTATUS
IcaBufferAllocInternal(
    IN PSDCONTEXT pContext,
    IN BOOLEAN bWait,
    IN BOOLEAN bControl,
    IN ULONG ByteCount,
    IN POUTBUF pOutBufOrig,
    OUT POUTBUF *ppOutBuf
    );

VOID
IcaBufferFreeInternal(
    IN PSDCONTEXT pContext,
    IN POUTBUF pOutBuf
    );

NTSTATUS
IcaRawInputInternal(
    IN PICA_STACK pStack,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    );

NTSTATUS
IcaChannelInputInternal(
    IN PICA_STACK pStack,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    );

void
IcaInitializeHandleTable(
    void
);
void
IcaCleanupHandleTable(
    void
);

/*
 * Routines to handle fast IO.
 */
#ifdef notdef
BOOLEAN
IcaFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
IcaFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
IcaFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\init.c ===
/*************************************************************************
*
* init.c
*
* This module performs initialization for the ICA device driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


ULONG
IcaReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
IcaOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

VOID
IcaReadRegistry (
    VOID
    );

BOOLEAN
IsPtDrvInstalled(
    IN PUNICODE_STRING RegistryPath
    );

VOID
IcaUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, IcaUnload )
#endif


extern PERESOURCE IcaTraceResource;
extern PERESOURCE g_pKeepAliveResource;

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the ICA device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    CLONG i;
    BOOLEAN success;
    HANDLE ThreadHandle;

    PAGED_CODE( );

    //
    // Initialize global data.
    //
    success = IcaInitializeData( );
    if ( !success ) {
        IcaUnload(DriverObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pKeepAliveResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(* g_pKeepAliveResource) );
    if (  g_pKeepAliveResource == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ExInitializeResource( g_pKeepAliveResource );

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //
    RtlInitUnicodeString( &deviceName, ICA_DEVICE_NAME );

    /*
     * The device extension stores the device type, which is used
     *  to fan out received IRPs in IcaDispatch.
     */
    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 sizeof(ULONG),                  // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_TERMSRV,            // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &IcaDeviceObject                // DeviceObject
                 );


    if ( !NT_SUCCESS(status) ) {
        IcaUnload(DriverObject);
        KdPrint(( "ICA DriverEntry: unable to create device object: %X\n", status ));
        return status;
    }

    //
    // Set up the device type
    //
    *((ULONG *)(IcaDeviceObject->DeviceExtension)) = DEV_TYPE_TERMDD;

    //IcaDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object for this file system driver.
    //
    DriverObject->DriverUnload   = IcaUnload;
    DriverObject->FastIoDispatch = NULL;

    //
    // We handle all possible IRPs in IcaDispatch and then fan them out
    // to the Port Driver or ICA components based on the device type stored
    // as the first ULONG's worth of the device extension
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = IcaDispatch;
    }

#ifdef notdef
    //
    // Read registry information.
    //
    IcaReadRegistry( );
#endif

    //
    // Initialize our device object.
    //
    IcaDeviceObject->StackSize = IcaIrpStackSize;

    //
    // Remember a pointer to the system process.  We'll use this pointer
    // for KeAttachProcess() calls so that we can open handles in the
    // context of the system process.
    //
    IcaSystemProcess = IoGetCurrentProcess( );

    //
    // Tell MM that it can page all of ICA it is desires.
    //
    //MmPageEntireDriver( DriverEntry );

    //
    // Now see if the port driver component has been installed.
    // Initialise it if so.
    //
    if ( NT_SUCCESS(status) ) {
        if (IsPtDrvInstalled(RegistryPath)) {
            //
            // Initialise the mouse/keyboard port driver component.
            //
            Print(DBG_PNP_TRACE, ( "TermDD DriverEntry: calling PtEntry\n" ));

            status = PtEntry(DriverObject, RegistryPath);

            if ( NT_SUCCESS(status) ) {
                //
                // Set up the port driver's plug and play entry points.
                //
                Print(DBG_PNP_TRACE, ( "TermDD DriverEntry: PtEntry succeeded Status=%#x\n", status ));
                DriverObject->DriverStartIo = PtStartIo;
                DriverObject->DriverExtension->AddDevice = PtAddDevice;
                PortDriverInitialized = TRUE;
            } else {
                //
                // This means that remote input will not be available when
                // shadowing the console session - but that's no reason to
                // fail the rest of the initialisation
                //
                Print(DBG_PNP_ERROR, ( "TermDD DriverEntry: PtEntry failed Status=%#x\n", status ));
                status = STATUS_SUCCESS;
            }
        } else {
            Print(DBG_PNP_INFO | DBG_PNP_TRACE, ( "TermDD DriverEntry: Port driver not installed\n" ));
        }
    }
    if (!NT_SUCCESS(status)) {
        IcaUnload(DriverObject);
    }

    return (status);
}


VOID
IcaUnload (
    IN PDRIVER_OBJECT DriverObject
    )
{
    DriverObject;

    PAGED_CODE( );

    KdPrint(( "IcaUnload called for termdd.sys.\n" ));

    // Set IcaKeepAliveEvent to wake up KeepAlive thread
    if (pIcaKeepAliveEvent != NULL ) {
        KeSetEvent(pIcaKeepAliveEvent, 0, FALSE);

    }

    // Wait for the thread to exit
    if (pKeepAliveThreadObject != NULL ) {
        KeWaitForSingleObject(pKeepAliveThreadObject, Executive, KernelMode, TRUE, NULL);
        // Deference the thread object
        ObDereferenceObject(pKeepAliveThreadObject);
        pKeepAliveThreadObject = NULL;
    }

    // Now we can free the KeepAlive Event
    if (pIcaKeepAliveEvent != NULL) {
        ICA_FREE_POOL(pIcaKeepAliveEvent);
        pIcaKeepAliveEvent = NULL;
    }

    // Call onto the port driver component, if it was ever initialised.
    if (PortDriverInitialized) {
        Print(DBG_PNP_TRACE, ( "TermDD IcaUnload: calling RemotePrt PtUnload\n" ));
        PtUnload(DriverObject);
        PortDriverInitialized = FALSE;
        Print(DBG_PNP_TRACE, ( "TermDD IcaUnload: RemotePrt PtUnload done\n" ));
    }

    // Free resources 

    if (IcaReconnectResource != NULL) {
        ExDeleteResourceLite(IcaReconnectResource );
        ICA_FREE_POOL(IcaReconnectResource);
        IcaReconnectResource = NULL;
    }


    if (IcaSdLoadResource != NULL) {
        ExDeleteResourceLite(IcaSdLoadResource );
        ICA_FREE_POOL(IcaSdLoadResource);
        IcaSdLoadResource = NULL;
    }

    if (IcaTraceResource != NULL) {
        ExDeleteResourceLite(IcaTraceResource );
        ICA_FREE_POOL(IcaTraceResource);
        IcaTraceResource = NULL;
    }


    if (g_pKeepAliveResource != NULL) {
        ExDeleteResource(g_pKeepAliveResource );
        ICA_FREE_POOL(g_pKeepAliveResource);
        g_pKeepAliveResource = NULL;
    }


    //
    // Delete the main device object.
    //
    if (IcaDeviceObject != NULL) {
        IoDeleteDevice (IcaDeviceObject);
        IcaDeviceObject = NULL;
    }

    //
    // Cleanup handle table, if necessary.
    //
    IcaCleanupHandleTable();

    KdPrint(("Finish TermDD.sys unload\n"));
    return;
}

BOOLEAN
IsPtDrvInstalled(
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG value = 0;
    ULONG defaultValue = 0;
    BOOLEAN rc = FALSE;

    PAGED_CODE( );

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"PortDriverEnable";
    paramTable[0].EntryContext  = &value;       // where to put the result
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultValue;
    paramTable[0].DefaultLength = sizeof(ULONG);

    //
    // The second (blank) entry in paramTable signals the end of the table.
    //

    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     RegistryPath->Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL );
    if (!NT_SUCCESS(status)) {
        value = defaultValue;
    }

    if (value != 0) {
        rc = TRUE;
    }

    return(rc);
}


#ifdef notdef
VOID
IcaReadRegistry (
    VOID
    )

/*++

Routine Description:

    Reads the ICA section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{
    HANDLE parametersHandle;
    NTSTATUS status;
    ULONG stackSize;
    ULONG priorityBoost;
    ULONG ignorePushBit;
    UNICODE_STRING registryPath;
    CLONG i;

    PAGED_CODE( );

    RtlInitUnicodeString( &registryPath, REGISTRY_ICA_INFORMATION );

    status = IcaOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS) {
        return;
    }

    //
    // Read the stack size and priority boost values from the registry.
    //

    stackSize = IcaReadSingleParameter(
                    parametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    (ULONG)IcaIrpStackSize
                    );

    if ( stackSize > 255 ) {
        stackSize = 255;
    }

    IcaIrpStackSize = (CCHAR)stackSize;

    priorityBoost = IcaReadSingleParameter(
                        parametersHandle,
                        REGISTRY_PRIORITY_BOOST,
                        (ULONG)IcaPriorityBoost
                        );

    if ( priorityBoost > 16 ) {
        priorityBoost = ICA_DEFAULT_PRIORITY_BOOST;
    }

    IcaPriorityBoost = (CCHAR)priorityBoost;

    //
    // Read other config variables from the registry.
    //

    for ( i = 0; i < ICA_CONFIG_VAR_COUNT; i++ ) {

        *IcaConfigInfo[i].Variable =
            IcaReadSingleParameter(
                parametersHandle,
                IcaConfigInfo[i].RegistryValueName,
                *IcaConfigInfo[i].Variable
                );
    }

    ignorePushBit = IcaReadSingleParameter(
                        parametersHandle,
                        REGISTRY_IGNORE_PUSH_BIT,
                        (ULONG)IcaIgnorePushBitOnReceives
                        );

    IcaIgnorePushBitOnReceives = (BOOLEAN)( ignorePushBit != 0 );

    ZwClose( parametersHandle );

    return;
}


NTSTATUS
IcaOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by ICA to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE( );

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwCreateKey(
                 &configHandle,
                 KEY_WRITE,
                 &objectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &disposition       // disposition
                 );

    if (!NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&parametersKeyName, parametersString);

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );
    if (!NT_SUCCESS(status)) {

        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened or created.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;
}


ULONG
IcaReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by ICA to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    PAGED_CODE( );

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if ((status == STATUS_SUCCESS) && (information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {

            returnValue = DefaultValue;

        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//

#define KEYBOARD_PORT_WMI_STD_DATA_GUID {0x4731F89A, 0x71CB, 0x11d1, 0xA5, 0x2C, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}
typedef struct _KEYBOARD_PORT_WMI_STD_DATA {
    //
    // Connector types
    //
#define KEYBOARD_PORT_WMI_STD_I8042 0
#define KEYBOARD_PORT_WMI_STD_SERIAL 1
#define KEYBOARD_PORT_WMI_STD_USB 2
    ULONG   ConnectorType;

    //
    // Size of data queue (number of entries)
    //
    ULONG   DataQueueSize;

    //
    // The error Count
    //
    ULONG   ErrorCount;

    //
    // Number of Function keys on the device.
    //
    ULONG   FunctionKeys;

    //
    // Number of Indicators on the device.
    //
    ULONG   Indicators;

} KEYBOARD_PORT_WMI_STD_DATA, * PKEYBOARD_PORT_WMI_STD_DATA;

#define POINTER_PORT_WMI_STD_DATA_GUID  {0x4731F89C, 0x71CB, 0x11d1, 0xA5, 0x2C, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}
typedef struct _POINTER_PORT_WMI_STD_DATA {
    //
    // Connector types
    //
#define POINTER_PORT_WMI_STD_I8042 0
#define POINTER_PORT_WMI_STD_SERIAL 1
#define POINTER_PORT_WMI_STD_USB 2
    ULONG   ConnectorType;

    //
    // Size of data queue (number of entries)
    //
    ULONG   DataQueueSize;

    //
    // The error Count
    //
    ULONG   ErrorCount;

    //
    // Number of Buttons on the pointer device
    //
    ULONG   Buttons;

    //
    // Hardware Types
    //
#define POINTER_PORT_WMI_STD_MOUSE        0
#define POINTER_PORT_WMI_STD_POINTER      1
#define POINTER_PORT_WMI_ABSOLUTE_POINTER 2
#define POINTER_PORT_WMI_TABLET           3
#define POINTER_PORT_WMI_TOUCH_SCRENE     4
#define POINTER_PORT_WMI_PEN              5
#define POINTER_PORT_WMI_TRACK_BALL       6
#define POINTER_PORT_WMI_OTHER            0x100
    ULONG   HardwareType;

} POINTER_PORT_WMI_STD_DATA, * PPOINTER_PORT_WMI_STD_DATA;

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\keyboard.c ===
/*************************************************************************
*
* keyboard.c
*
* This module contains routines for managing the ICA keyboard channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>


NTSTATUS
IcaDeviceControlKeyboard(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the device control routine for the ICA keyboard channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    PICA_STACK pStack;
    NTSTATUS Status;
    CLONG Method;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlKeyboard, fc %d, ref %u (enter)\n",
                   (code & 0x3fff) >> 2, pChannel->RefCount ));
    switch ( code ) {

#if 0 // no longer used
        /*
         * Special IOCTL to allow keyboard input data to be fed
         * into the keyboard channel.
         */
        case IOCTL_KEYBOARD_ICA_INPUT :

            /*
             * Make sure the input data is the correct size.
             */
            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength %
                 sizeof(KEYBOARD_INPUT_DATA) )
                return( STATUS_BUFFER_TOO_SMALL );

            /*
             * We need a stack object to pass to IcaChannelInputInternal.
             * Any one will do so we grab the head of the stack list.
             * (There MUST be one for this IOCTL to succeed.)
             */
            IcaLockConnection( pChannel->pConnect );
            if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }
            pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                        ICA_STACK, StackEntry );
            IcaReferenceStack( pStack );
            IcaUnlockConnection( pChannel->pConnect );

            /*
             * Send keyboard input
             */
            IcaChannelInputInternal( pStack, Channel_Keyboard, 0, NULL,
                                     (PCHAR)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                     IrpSp->Parameters.DeviceIoControl.InputBufferLength );

            IcaDereferenceStack( pStack );
            Status = STATUS_SUCCESS;
            break;
#endif


        /*
         * The following keyboard ioctls use METHOD_NEITHER so get the
         * input buffer from the DeviceIoControl parameters.
         */
        case IOCTL_KEYBOARD_ICA_LAYOUT :
        case IOCTL_KEYBOARD_ICA_SCANMAP :
        case IOCTL_KEYBOARD_ICA_TYPE :
            if ( Irp->RequestorMode != KernelMode ) {
                ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                              IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                              TYPE_ALIGNMENT(BYTE) );
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                               TYPE_ALIGNMENT(BYTE) );
            }
    
            SdIoctl.IoControlCode = code;
            SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            SdIoctl.OutputBuffer = Irp->UserBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
            break;


        /*
         * All other keyboard ioctls use METHOD_BUFFERED so get the
         * input buffer from the AssociatedIrp.SystemBuffer field.
         */
        default:
            // Verify the buffer method.
            Method = code & 0x03;
            ASSERT( Method == METHOD_BUFFERED );

            if ( Method != METHOD_BUFFERED ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else {
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Irp->AssociatedIrp.SystemBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = SdIoctl.InputBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );

                if (Status == STATUS_SUCCESS ) 
                    Irp->IoStatus.Information = SdIoctl.BytesReturned;
            }

            break;
    }

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlKeyboard, fc %d, ref %u, 0x%x\n",
                   (code & 0x3fff) >> 2, pChannel->RefCount, Status ));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\misc.c ===
/****************************************************************************/
// misc.c
//
// Miscellaneous TermDD routines.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop


#if DBG

LIST_ENTRY IcaGlobalPoolListHead;
ULONG IcaTotalAllocations = 0;
ULONG IcaTotalFrees = 0;
ULONG IcaTotalBytesAllocated = 0;
KSPIN_LOCK IcaDebugSpinLock;

typedef struct _ICA_POOL_HEADER {
    LIST_ENTRY GlobalPoolListEntry;
    PCHAR FileName;
    ULONG LineNumber;
    ULONG Size;
    ULONG InUse;
} ICA_POOL_HEADER, *PICA_POOL_HEADER;

typedef struct _ICA_POOL_TRAILER {
    ULONG Size;
    ULONG_PTR CheckSum;
} ICA_POOL_TRAILER, *PICA_POOL_TRAILER;


void IcaInitializeDebugData(void)
{
    KeInitializeSpinLock(&IcaDebugSpinLock);
    InitializeListHead(&IcaGlobalPoolListHead);
}


BOOLEAN IcaLockConnection(PICA_CONNECTION pConnect)
{
    PERESOURCE pResource = &pConnect->Resource;
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    KIRQL oldIrql;
    ULONG i;
    BOOLEAN Result;

    TRACE((pConnect, TC_ICADD, TT_SEM,
            "TermDD: IcaLockConnection: 0x%x\n", pResource));



    /*
     * Ensure we don't already have the connection locked
     */
    ASSERT( !ExIsResourceAcquiredExclusiveLite( pResource ) );

    /*
     * Reference and lock the connection object
     */
    IcaReferenceConnection( pConnect );
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusive( pResource, TRUE );

    /*
     * Ensure we don't own any stack locks
     */
    Head = &pConnect->StackHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );
        ASSERT( !ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );
    }

    /*
     * Ensure we don't own any channel locks
     */
    IcaLockChannelTable(&pConnect->ChannelTableLock);

    for ( i = 0; i < sizeof(pConnect->pChannel) / sizeof(*pConnect->pChannel); i++ ) {
        if (pConnect->pChannel[i]) {
            ASSERT(!ExIsResourceAcquiredExclusiveLite(&pConnect->pChannel[i]->Resource));
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);

    return Result;
}


void IcaUnlockConnection(PICA_CONNECTION pConnect)
{
    PERESOURCE pResource = &pConnect->Resource;

    TRACE((pConnect, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockConnection: 0x%x\n", pResource));

    /*
     * Ensure we already have the connection locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceConnection(pConnect);
}


BOOLEAN IcaLockStack(PICA_STACK pStack)
{
    PERESOURCE pResource = &pStack->Resource;
    PICA_CONNECTION pConnect;
    PLIST_ENTRY Head, Next;
    PICA_STACK pNextStack;
    KIRQL oldIrql;
    ULONG i;
    BOOLEAN Result;

    /*
     * Ensure we don't already have the stack locked
     */
    ASSERT( !ExIsResourceAcquiredExclusiveLite( pResource ) );

    /*
     * Reference and lock the stack object
     */
    IcaReferenceStack( pStack );
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusive( pResource, TRUE );

    TRACESTACK((pStack, TC_ICADD, TT_SEM,
            "TermDD: IcaLockStack: 0x%x\n", pStack));

    /*
     * Ensure we don't own any other stack locks
     */
    pConnect = IcaGetConnectionForStack( pStack );
    Head = &pConnect->StackHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pNextStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );
        if ( pNextStack != pStack ) {
            ASSERT( !ExIsResourceAcquiredExclusiveLite( &pNextStack->Resource ) );
        }
    }

    /*
     * Ensure we don't own any channel locks
     */
    IcaLockChannelTable(&pConnect->ChannelTableLock);
    for ( i = 0; i < sizeof(pConnect->pChannel) / sizeof(*pConnect->pChannel); i++ ) {
        if ( pConnect->pChannel[i] ) {
            ASSERT( !ExIsResourceAcquiredExclusiveLite( &pConnect->pChannel[i]->Resource ) );
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);

    return Result;
}


void IcaUnlockStack(PICA_STACK pStack)
{
    PERESOURCE pResource = &pStack->Resource;

    TRACESTACK((pStack, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockStack: 0x%x\n", pStack));

    /*
     * Ensure we already have the stack locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceStack(pStack);
}


BOOLEAN IcaLockChannel(PICA_CHANNEL pChannel)
{
    PERESOURCE pResource = &pChannel->Resource;

    TRACECHANNEL((pChannel, TC_ICADD, TT_SEM,
            "TermDD: IcaLockChannel: cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    IcaReferenceChannel(pChannel);

    // Need to disable APC calls when holding a resource.
    KeEnterCriticalRegion();
    return ExAcquireResourceExclusive(pResource, TRUE);
}


void IcaUnlockChannel(IN PICA_CHANNEL pChannel)
{
    PERESOURCE pResource = &pChannel->Resource;

    TRACECHANNEL((pChannel, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockChannel: cc %u, vc %d\n", 
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Ensure we already have the channel locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceChannel(pChannel);
}


PVOID IcaAllocatePool(
        IN POOL_TYPE PoolType,
        IN ULONG NumberOfBytes,
        IN PCHAR FileName,
        IN ULONG LineNumber,
        IN BOOLEAN WithQuota)
{
    PICA_POOL_HEADER header;
    PICA_POOL_TRAILER trailer;
    KIRQL oldIrql;

    ASSERT( PoolType == NonPagedPool || PoolType == NonPagedPoolMustSucceed );

    // make sure number of bytes are 64bit aligned
    NumberOfBytes = (NumberOfBytes + 7) & ~7;

    if (WithQuota) {
        try {
            header = ExAllocatePoolWithQuotaTag(
                         PoolType,
                         NumberOfBytes + sizeof(*header) + sizeof(*trailer),
                         ICA_POOL_TAG
                         );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            return NULL;
        }
    } else {
        header = ExAllocatePoolWithTag(
                     PoolType,
                     NumberOfBytes + sizeof(*header) + sizeof(*trailer),
                     ICA_POOL_TAG
                     );
    }

    if (header == NULL) {
        return NULL;
    }

    header->FileName = FileName;
    header->LineNumber = LineNumber;
    header->Size = NumberOfBytes;
    header->InUse = 1;

    trailer = (PICA_POOL_TRAILER)((PCHAR)(header + 1) + NumberOfBytes);
    trailer->Size = NumberOfBytes;
    trailer->CheckSum = (ULONG_PTR)header + (ULONG_PTR)FileName + LineNumber +
            NumberOfBytes;

    InterlockedIncrement(
        &IcaTotalAllocations
        );

    ExInterlockedAddUlong(
        &IcaTotalBytesAllocated,
        header->Size,
        &IcaDebugSpinLock
        );

    ExInterlockedInsertTailList( &IcaGlobalPoolListHead,
                                 &header->GlobalPoolListEntry,
                                 &IcaDebugSpinLock );

    return (PVOID)(header + 1);
}


void IcaFreePool(IN PVOID Pointer)
{
    KIRQL oldIrql;
    PICA_POOL_HEADER header = (PICA_POOL_HEADER)Pointer - 1;
    PICA_POOL_TRAILER trailer;

    trailer = (PICA_POOL_TRAILER)((PCHAR)(header + 1) + header->Size);
    ASSERT( header->Size == trailer->Size );
    ASSERT( trailer->CheckSum = (ULONG_PTR)header + (ULONG_PTR)header->FileName +
                                header->LineNumber + header->Size );

    InterlockedIncrement(
        &IcaTotalFrees
        );

    ExInterlockedAddUlong(
        &IcaTotalBytesAllocated,
        -1*header->Size,
        &IcaDebugSpinLock
        );

    KeAcquireSpinLock( &IcaDebugSpinLock, &oldIrql );
    RemoveEntryList( &header->GlobalPoolListEntry );
    KeReleaseSpinLock( &IcaDebugSpinLock, oldIrql );

    header->GlobalPoolListEntry.Flink = (PLIST_ENTRY)(-1);
    header->GlobalPoolListEntry.Blink = (PLIST_ENTRY)(-1);
    header->InUse = 0;

    if (header->Size == trailer->Size)
        RtlFillMemory(Pointer, header->Size, 0xff);

    ExFreePool((PVOID)header);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\mouse.c ===
/*************************************************************************
*
* mouse.c
*
* This module contains routines for managing the ICA mouse channel.
*
* Copyright 1998, Microsoft.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddmou.h>


NTSTATUS
IcaDeviceControlMouse(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the DeviceControl routine for the ICA mouse channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    PICA_STACK pStack;
    NTSTATUS Status;
    CLONG Method;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch ( code ) {

#if 0 // no longer used
        /*
         * Special IOCTL to allow mouse input data to be fed
         * into the mouse channel.
         */
        case IOCTL_MOUSE_ICA_INPUT :

            /*
             * Make sure the input data is the correct size.
             */
            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength %
                 sizeof(MOUSE_INPUT_DATA) )
                return( STATUS_BUFFER_TOO_SMALL );

            /*
             * We need a stack object to pass to IcaChannelInputInternal.
             * Any one will do so we grab the head of the stack list.
             * (There MUST be one for this IOCTL to succeed.)
             */
            IcaLockConnection( pChannel->pConnect );
            if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }
            pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                        ICA_STACK, StackEntry );
            IcaReferenceStack( pStack );
            IcaUnlockConnection( pChannel->pConnect );

            /*
             * Send mouse input
             */
            IcaChannelInputInternal( pStack, Channel_Mouse, 0, NULL,
                                     (PCHAR)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                     IrpSp->Parameters.DeviceIoControl.InputBufferLength );

            IcaDereferenceStack( pStack );
            Status = STATUS_SUCCESS;
            break;
#endif

        default:
            // Verify the buffer method.
            Method = code & 0x03;
            ASSERT( Method == METHOD_BUFFERED );

            if ( Method != METHOD_BUFFERED ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else {
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Irp->AssociatedIrp.SystemBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
            }

            break;
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ntload.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

   ntload.c

   This module contains support for loading and unloading WD/PD/TD's as
   standard NT drivers.

--*/

#include <precomp.h>
#pragma hdrstop


#if DBG
#define DBGPRINT(x) DbgPrint x
#else
#define DBGPRINT(x)
#endif

#define DEVICE_NAME_PREFIX L"\\Device\\"

#define SERVICE_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"


NTSTATUS
_IcaLoadSdWorker(
    IN PDLLNAME SdName,
    OUT PSDLOAD *ppSdLoad
    )

/*++

Routine Description:

    Replacement routine for Citrix _IcaLoadSdWorker that uses
    standard NT driver loading.

Arguments:

    SdName - Name of the stack driver to load

    ppSdLoad - Pointer to return stack driver structure in.

Return Value:

    NTSTATUS code.

Environment:

    Kernel mode, DDK
--*/

{
    PIRP Irp;
    PKEVENT pEvent;
    NTSTATUS Status;
    PSDLOAD pSdLoad;
    UNICODE_STRING DriverName;
    UNICODE_STRING DeviceName;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    IO_STATUS_BLOCK Iosb;
    PSD_MODULE_INIT pmi;
    PIO_STACK_LOCATION IrpSp;
    PWCHAR pDriverPath;
    PWCHAR pDeviceName;
    ULONG  szDriverPath;
    ULONG  szDeviceName;

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );

    //
    // Allocate a SDLOAD struct
    //
    pSdLoad = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pSdLoad) );
    if ( pSdLoad == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    pEvent = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(KEVENT) );
    if( pEvent == NULL ) {
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    pmi = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(SD_MODULE_INIT) );
    if( pmi == NULL ) {
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    szDeviceName = sizeof(DEVICE_NAME_PREFIX) + sizeof(pSdLoad->SdName) + sizeof(WCHAR);
    pDeviceName = ICA_ALLOCATE_POOL( NonPagedPool, szDeviceName );
    if( pDeviceName == NULL ) {
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory( pmi, sizeof(*pmi) );

    pSdLoad->RefCount = 1;
    RtlCopyMemory( pSdLoad->SdName, SdName, sizeof( pSdLoad->SdName ) );

    szDriverPath = sizeof(SERVICE_PATH) + sizeof(pSdLoad->SdName) + sizeof(WCHAR);
    pDriverPath = ICA_ALLOCATE_POOL( NonPagedPool, szDriverPath );
    if( pDriverPath == NULL ) {
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy(pDriverPath, SERVICE_PATH);
    wcscat(pDriverPath, pSdLoad->SdName);

    RtlInitUnicodeString( &DriverName, pDriverPath );

    wcscpy(pDeviceName, DEVICE_NAME_PREFIX);
    wcscat(pDeviceName, pSdLoad->SdName);
    pSdLoad->pUnloadWorkItem = NULL;

    RtlInitUnicodeString( &DeviceName, pDeviceName );

    KeInitializeEvent( pEvent, NotificationEvent, FALSE );

    // Load the NT driver
    Status = ZwLoadDriver( &DriverName );
    if ( !NT_SUCCESS( Status ) && (Status != STATUS_IMAGE_ALREADY_LOADED)) {
        DBGPRINT(("TermDD: ZwLoadDriver %wZ failed, 0x%x, 0x%x\n", &DriverName, Status, &DriverName ));
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( Status );
    }

    //
    // Now open the driver and get our stack driver pointers
    //

    Status = IoGetDeviceObjectPointer(
                 &DeviceName,  // Device name is module name IE: \Device\TDTCP
                 GENERIC_ALL,
                 &FileObject,
                 &DeviceObject
                 );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TermDD: IoGetDeviceObjectPointer %wZ failed, 0x%x\n", &DeviceName, Status ));
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( Status );
    }

    //
    // Send the internal IOCTL_SD_MODULE_INIT to the device to
    // get its stack interface pointers.
    //
    Irp = IoBuildDeviceIoControlRequest(
              IOCTL_SD_MODULE_INIT,
              DeviceObject,
              NULL,         // InputBuffer
              0,            // InputBufferLength
              (PVOID)pmi,   // OutputBuffer
              sizeof(*pmi), // OutputBufferLength
              TRUE,         // Use IRP_MJ_INTERNAL_DEVICE_CONTROL
              pEvent,
              &Iosb
              );

    if( Irp == NULL ) {
        ObDereferenceObject( FileObject );
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        DBGPRINT(( "TermDD: Could not allocate IRP %S failed\n", SdName ));
        return( Status );
    }

    ObReferenceObject( FileObject );
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->FileObject = FileObject;
    Irp->Flags |= IRP_SYNCHRONOUS_API;

    // Call the driver
    Status = IoCallDriver( DeviceObject, Irp );
    if( Status == STATUS_PENDING ) {
        Status = KeWaitForSingleObject( pEvent, UserRequest, KernelMode, FALSE, NULL );
    }

    // Get the result from the actual I/O operation
    if( Status == STATUS_SUCCESS ) {
        Status = Iosb.Status;
    }

    if( NT_SUCCESS(Status) ) {
        ASSERT( Iosb.Information == sizeof(*pmi) );
        pSdLoad->DriverLoad = pmi->SdLoadProc;
        pSdLoad->FileObject = FileObject;
        pSdLoad->DeviceObject = DeviceObject;
        InsertHeadList( &IcaSdLoadListHead, &pSdLoad->Links );
        *ppSdLoad = pSdLoad;
    }
    else {
        DBGPRINT(("TermDD: Error getting module pointers 0x%x\n",Status));
#if DBG
DbgBreakPoint();
#endif
        ObDereferenceObject( FileObject );
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pSdLoad );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pDriverPath );
        return( Status );
    }

    // Cleanup

    ICA_FREE_POOL( pDeviceName );
    ICA_FREE_POOL( pDriverPath );
    ICA_FREE_POOL( pmi );
    ICA_FREE_POOL( pEvent );

    return( Status );
}

NTSTATUS
_IcaUnloadSdWorker(
    IN PSDLOAD pSdLoad
    )

/*++

    Replacement routine for Citrix _IcaUnloadSdWorker that uses
    standard NT driver unloading.

Arguments:
    SdName - Name of the stack driver to load
    ppSdLoad - Pointer to return stack driver structure in.

Environment:
    Kernel mode, DDK
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DriverName;
    WCHAR DriverPath[sizeof(SERVICE_PATH) + 
                     sizeof(pSdLoad->SdName) + 
                     sizeof(WCHAR)];
    PSDLOAD pSdLoadInList;
    PLIST_ENTRY Head, Next;


    /*
     * free the workitem
     */

    ASSERT(pSdLoad->pUnloadWorkItem != NULL);
    ICA_FREE_POOL(pSdLoad->pUnloadWorkItem);
    pSdLoad->pUnloadWorkItem = NULL;
    
    wcscpy(DriverPath, SERVICE_PATH);
    wcscat(DriverPath, pSdLoad->SdName);
    RtlInitUnicodeString(&DriverName, DriverPath);


    /*
     * Lock the ICA Resource exclusively to search the SdLoad list.
     * Note when holding a resource we need to prevent APC calls, so
     * use KeEnterCriticalRegion().
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );

    /*
     * Look for the requested SD.  If found, and refcount is still 0, then
     * unload it. If refcount is not zero then someone has referenced it since
     * we have posted the workitem and we do not want to unload it anymore.
     *
     */
    Head = &IcaSdLoadListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pSdLoadInList = CONTAINING_RECORD( Next, SDLOAD, Links );
        if ( !wcscmp( pSdLoad->SdName, pSdLoadInList->SdName ) ) {
            ASSERT(pSdLoad == pSdLoadInList);
            if (--pSdLoad->RefCount != 0) {
                break;
            }
            
            /*
             * We found the driver and Refcount is Zero let unload it
             */
            Status = ZwUnloadDriver(&DriverName);

            if (Status != STATUS_INVALID_DEVICE_REQUEST) {
                RemoveEntryList(&pSdLoad->Links);
                ObDereferenceObject (pSdLoad->FileObject);
                ICA_FREE_POOL(pSdLoad);
            }
            else {
                // If the driver unloading fails because of invalid request,
                // we keep this pSdLoad around.  It will get cleaned up
                // either unload succeeds or the driver exits.
                // TODO: termdd currently not cleanup all the memory it allocates
                // It does not have unload correctly implemented.  So, we didn't put
                // cleanup for this in the unload function.  That needs to be looked
                // at it once unload function is hooked up.
                DBGPRINT(("TermDD: ZwUnLoadDriver %wZ failed, 0x%x, 0x%x\n", &DriverName, Status, &DriverName ));
            }

            break;

        }
    }

    /*
     * We should always find the driver in the list
     */

    ASSERT(Next != Head);
    ExReleaseResourceLite( IcaSdLoadResource);
    KeLeaveCriticalRegion();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\khandle.c ===
/*************************************************************************
*
* khandle.c
*
* Manage kernel mode handles for transport drivers.
*
* Copyright 1998, Microsoft.
*  
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

ULONG gHandleTableSize;                           

#ifdef TERMDD_NO_USE_TABLE_PACKAGE

typedef struct _TDHANDLE_ENTRY {
    LIST_ENTRY Link;
    PVOID      Context;
    ULONG      ContextSize;
} TDHANDLE_ENTRY, *PTDHANDLE_ENTRY;

/*
 * Global Data
 */
LIST_ENTRY IcaTdHandleList;

/*
 * These set of routines allows TD's to create a handle that will survive
 * across them being unloaded and re-loaded. This allows a handle to be
 * passed back to ICASRV in a secure manner.
 *
 * NOTE: We do not deal with ICASRV leaking these handles. It never exits.
 *       If it does, we will need to have ICADD return a real NT handle, or
 *       destroy all handles for a TD when it unloads.
 */


/*****************************************************************************
 *
 *  IcaCreateHandle
 *
 *   Create a handle entry for the context and length.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;

    p = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(TDHANDLE_ENTRY) );
    if( p == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    RtlZeroMemory( p, sizeof(TDHANDLE_ENTRY) );
    p->Context = Context;
    p->ContextSize = ContextSize;

    *ppHandle = (PVOID)p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );
    InsertHeadList( &IcaTdHandleList, &p->Link );
    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
    InterlockedIncrement(&gHandleTableSize);

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  IcaReturnHandle
 *
 *   Return the context and length for the handle.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    pEntry = IcaTdHandleList.Flink;

    while( pEntry != &IcaTdHandleList ) {

        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );

        if( (PVOID)p == Handle ) {
            *ppContext = p->Context;
            *pContextSize = p->ContextSize;
            IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
            return( STATUS_SUCCESS );
        }

        pEntry = pEntry->Flink;
    }

    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );

    return( STATUS_INVALID_HANDLE );
}

/*****************************************************************************
 *
 *  IcaCloseHandle
 *
 *   Return the context and length for the handle. Delete the
 *   handle entry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    pEntry = IcaTdHandleList.Flink;

    while( pEntry != &IcaTdHandleList ) {

        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );

        if( (PVOID)p == Handle ) {
            RemoveEntryList( &p->Link );
            IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
            InterlockedDecrement(&gHandleTableSize);
            *ppContext = p->Context;
            *pContextSize = p->ContextSize;
            ICA_FREE_POOL( p );
            return( STATUS_SUCCESS );
        }

        pEntry = pEntry->Flink;
    }

    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );

    return( STATUS_INVALID_HANDLE );
}


/*****************************************************************************
 *
 *  IcaInitializeHandleTable
 *
 *   Initializes handle table at driver load.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/
void
IcaInitializeHandleTable(
    void
)
{
    InitializeListHead( &IcaTdHandleList );
}
/*****************************************************************************
 *
 *  IcaCleanupHandleTable
 *
 *   Cleans up handle table at driver unload.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/

void
IcaCleanupHandleTable(
    void
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;



    KdPrint(("TermDD: IcaCleanupHandleTable table size is %d\n",gHandleTableSize));

    for (pEntry = IcaTdHandleList.Flink; pEntry != &IcaTdHandleList; pEntry = IcaTdHandleList.Flink) {
        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );
        RemoveEntryList(&p->Links);
        ICA_FREE_POOL( p->Context );
        ICA_FREE_POOL( p );
    }
}

#else


typedef struct _TDHANDLE_ENTRY {
    PVOID      Context;
    ULONG      ContextSize;
} TDHANDLE_ENTRY, *PTDHANDLE_ENTRY;

RTL_GENERIC_TABLE IcaHandleReferenceTable;



RTL_GENERIC_COMPARE_RESULTS
NTAPI
IcaCompareHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
);


PVOID
IcaAllocateHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
);


VOID
IcaFreeHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
);

/*****************************************************************************
 *
 *  IcaInitializeHandleTable
 *
 *   Initializes handle table at driver load.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/
void
IcaInitializeHandleTable(
    void
)
{
    RtlInitializeGenericTable(  &IcaHandleReferenceTable,
                                IcaCompareHandleTableEntry,
                                IcaAllocateHandleTableEntry,
                                IcaFreeHandleTableEntry,
                                NULL);
}


/*****************************************************************************
 *
 *  IcaCleanupHandleTable
 *
 *   Cleanup handle table at driver unload.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/

void
IcaCleanupHandleTable(
    void
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;
    PVOID pContext;
    TDHANDLE_ENTRY key;

    KdPrint(("TermDD: IcaCleanupHandleTable table size is %d\n",gHandleTableSize));

    while (p = RtlEnumerateGenericTable(&IcaHandleReferenceTable,TRUE)) {
        key.Context = p->Context;
        RtlDeleteElementGenericTable(&IcaHandleReferenceTable, &key);
        ICA_FREE_POOL(key.Context);
    }

}


/*****************************************************************************
 *
 *  IcaCreateHandle
 *
 *   Create a handle entry for the context and length.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
)
{
    KIRQL OldIrql;
    TDHANDLE_ENTRY key;
    BOOLEAN bNewElement;


    key.Context = Context;
    key.ContextSize = ContextSize;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );
    if (!RtlInsertElementGenericTable(&IcaHandleReferenceTable,(PVOID) &key, sizeof(TDHANDLE_ENTRY), &bNewElement )) {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_NO_MEMORY;
    }
    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
    ASSERT(bNewElement);
    if (!bNewElement) {
        return STATUS_INVALID_PARAMETER;
    }

    InterlockedIncrement(&gHandleTableSize);

    *ppHandle = Context;


    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  IcaReturnHandle
 *
 *   Return the context and length for the handle.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;
    TDHANDLE_ENTRY key;

    key.Context = Handle;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    p = RtlLookupElementGenericTable(&IcaHandleReferenceTable, &key);
    if (p != NULL) {
        *ppContext = p->Context;
        *pContextSize = p->ContextSize;
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_SUCCESS;
    } else {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_INVALID_HANDLE; 
    }

}


/*****************************************************************************
 *
 *  IcaCloseHandle
 *
 *   Return the context and length for the handle. Delete the
 *   handle entry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;
    TDHANDLE_ENTRY key;

    key.Context = Handle;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );


    p = RtlLookupElementGenericTable(&IcaHandleReferenceTable, &key);
    if (p != NULL) {
        *ppContext = p->Context;
        *pContextSize = p->ContextSize;
        RtlDeleteElementGenericTable(&IcaHandleReferenceTable, &key);
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        InterlockedDecrement(&gHandleTableSize);
        return STATUS_SUCCESS;
    } else {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return  STATUS_INVALID_HANDLE;
    }

}


/*****************************************************************************
 *
 *  IcaCompareHandleTableEntry
 *
 *   Generic table support.Compare two handles table entry instances
 *
 *
 ****************************************************************************/

RTL_GENERIC_COMPARE_RESULTS
NTAPI
IcaCompareHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
)
{
    ULONG_PTR FirstHandle = (ULONG_PTR)((PTDHANDLE_ENTRY)FirstInstance)->Context;
    ULONG_PTR SecondHandle = (ULONG_PTR)((PTDHANDLE_ENTRY)SecondInstance)->Context;

    if (FirstHandle < SecondHandle ) {
        return GenericLessThan;
    }

    if (FirstHandle > SecondHandle ) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}


/*****************************************************************************
 *
 *  IcaAllocateHandleTableEntry
 *
 *   Generic table support. Allocates a new table entry
 *
 *
 ****************************************************************************/

PVOID
IcaAllocateHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    )
{

    return ICA_ALLOCATE_POOL( NonPagedPool, ByteSize );
}


/*****************************************************************************
 *
 *  IcaFreeHandleTableEntry
 *
 *   Generic table support. frees a new table entry
 *
 *
 ****************************************************************************/

VOID
IcaFreeHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    )
{

    ICA_FREE_POOL(Buffer);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

/*
 *  Need to define these to have MP save driver ( proper locked operation will generated for x86)-Bug# 209464
 */


#include <ntosp.h>

#include <zwapi.h>
#include <winstaw.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <icadd.h>
#include <sdapi.h>
#include "icap.h"
#include "icadata.h"
#include "icaprocs.h"

#include "stdarg.h"
#include "stdio.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvcom.h ===
/*

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvprt.h

Abstract:

    Structures and defines used the RDP remote port driver.

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#ifndef _PTDRVCOM_
#define _PTDRVCOM_

#include <ntddk.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntdd8042.h>
#include <kbdmou.h>
#include <wmilib.h>

#include "ptdrvstr.h"


//
// Define the device types for the first field in the device extensions
//

#define DEV_TYPE_TERMDD 1
#define DEV_TYPE_PORT   2

#define REMOTE_PORT_POOL_TAG (ULONG) 'PMER'
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, REMOTE_PORT_POOL_TAG)

//
// Set up some debug options
//
#ifdef PAGED_CODE
#undef PAGED_CODE
#endif

#if DBG
#define PTDRV_VERBOSE 1

#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "RemotePrt: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        DbgBreakPoint(); \
        }
#else
#define PAGED_CODE()
#endif

//
// Define device name for our driver
//

#define RDP_CONSOLE_BASE_NAME0 L"\\Device\\RDP_CONSOLE0"
#define RDP_CONSOLE_BASE_NAME1 L"\\Device\\RDP_CONSOLE1"

//
// Custom resource type used when pruning the fdo's resource lists
//
#define PD_REMOVE_RESOURCE 0xef

//
// Mouse reset IOCTL
//
#define IOCTL_INTERNAL_MOUSE_RESET  \
            CTL_CODE(FILE_DEVICE_MOUSE, 0x0FFF, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Default number of function keys, number of LED indicators, and total
// number of keys
//
#define KEYBOARD_NUM_FUNCTION_KEYS         12
#define KEYBOARD_NUM_INDICATORS             3
#define KEYBOARD_NUM_KEYS_TOTAL           101

//
// Default values for keyboard typematic rate and delay.
//
#define KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250

//
// Default info for the mouse
//
#define MOUSE_IDENTIFIER MOUSE_I8042_HARDWARE
#define MOUSE_NUM_BUTTONS                   2
#define MOUSE_SAMPLE_RATE                  60
#define MOUSE_INPUT_QLEN                    0

//
// Defines and macros for Globals.ControllerData->HardwarePresent.
//
#define KEYBOARD_HARDWARE_PRESENT               0x001
#define MOUSE_HARDWARE_PRESENT                  0x002
#define WHEELMOUSE_HARDWARE_PRESENT             0x008
#define DUP_KEYBOARD_HARDWARE_PRESENT           0x010
#define DUP_MOUSE_HARDWARE_PRESENT              0x020
#define KEYBOARD_HARDWARE_INITIALIZED           0x100
#define MOUSE_HARDWARE_INITIALIZED              0x200

#define TEST_HARDWARE_PRESENT(bits) \
                ((Globals.ControllerData->HardwarePresent & (bits)) == (bits))
#define CLEAR_HW_FLAGS(bits) (Globals.ControllerData->HardwarePresent &= ~(bits))
#define SET_HW_FLAGS(bits)   (Globals.ControllerData->HardwarePresent |= (bits))

#define KEYBOARD_PRESENT()     TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_PRESENT)
#define MOUSE_PRESENT()        TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_PRESENT)
#define KEYBOARD_INITIALIZED() TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_INITIALIZED)
#define MOUSE_INITIALIZED()    TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_INITIALIZED)

#define CLEAR_MOUSE_PRESENT()    CLEAR_HW_FLAGS(MOUSE_HARDWARE_INITIALIZED | MOUSE_HARDWARE_PRESENT | WHEELMOUSE_HARDWARE_PRESENT)
#define CLEAR_KEYBOARD_PRESENT() CLEAR_HW_FLAGS(KEYBOARD_HARDWARE_INITIALIZED | KEYBOARD_HARDWARE_PRESENT)

#define KBD_POWERED_UP_STARTED      0x0001
#define MOU_POWERED_UP_STARTED      0x0010
#define MOU_POWERED_UP_SUCCESS      0x0100
#define MOU_POWERED_UP_FAILURE      0x0200
#define KBD_POWERED_UP_SUCCESS      0x1000
#define KBD_POWERED_UP_FAILURE      0x2000

#define CLEAR_POWERUP_FLAGS()   (Globals.PowerUpFlags = 0x0)
#define SET_PWR_FLAGS(bits)     (Globals.PowerUpFlags |= (bits))
#define KEYBOARD_POWERED_UP_STARTED()       SET_PWR_FLAGS(KBD_POWERED_UP_STARTED)
#define MOUSE_POWERED_UP_STARTED()          SET_PWR_FLAGS(MOU_POWERED_UP_STARTED)

#define KEYBOARD_POWERED_UP_SUCCESSFULLY()  SET_PWR_FLAGS(KBD_POWERED_UP_SUCCESS)
#define MOUSE_POWERED_UP_SUCCESSFULLY()     SET_PWR_FLAGS(MOU_POWERED_UP_SUCCESS)

#define KEYBOARD_POWERED_UP_FAILED()  SET_PWR_FLAGS(KBD_POWERED_UP_FAILURE)
#define MOUSE_POWERED_UP_FAILED()     SET_PWR_FLAGS(MOU_POWERED_UP_FAILURE)

//
// Define the i8042 controller input/output ports.
//
typedef enum _I8042_IO_PORT_TYPE {
    DataPort = 0,
    CommandPort,
    MaximumPortCount

} I8042_IO_PORT_TYPE;

//
// Intel i8042 configuration information.
//
typedef struct _I8042_CONFIGURATION_INFORMATION {

    //
    // The port/register resources used by this device.
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[MaximumPortCount];
    ULONG PortListCount;

} I8042_CONFIGURATION_INFORMATION, *PI8042_CONFIGURATION_INFORMATION;

//
// Define the common portion of the keyboard/mouse device extension.
//
typedef struct COMMON_DATA {
    //
    // Device type field
    //
    ULONG deviceType;

    //
    // Pointer back to the this extension's device object.
    //
    PDEVICE_OBJECT Self;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT TopOfStack;

    //
    // "THE PDO"  (ejected by root)
    //
    PDEVICE_OBJECT PDO;

    //
    // Current power state that the device is in
    //
    DEVICE_POWER_STATE PowerState;
    POWER_ACTION ShutdownType; 

    //
    // Reference count for number of keyboard enables.
    //
    LONG EnableCount;

    //
    // Class connection data.
    //
    CONNECT_DATA ConnectData;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    BOOLEAN Initialized;

    BOOLEAN IsKeyboard;

    UNICODE_STRING DeviceName;

    //
    // Has it been started?
    // Has the device been manually removed?
    //
    BOOLEAN Started;
    BOOLEAN ManuallyRemoved;

} *PCOMMON_DATA;

#define GET_COMMON_DATA(ext) ((PCOMMON_DATA) ext)

//
// Define the keyboard portion of the port device extension.
//
typedef struct _PORT_KEYBOARD_EXTENSION {

    //
    // Data in common with the mouse extension;
    //
    struct COMMON_DATA;

} PORT_KEYBOARD_EXTENSION, *PPORT_KEYBOARD_EXTENSION;

//
// Define the mouse portion of the port device extension.
//
typedef struct _PORT_MOUSE_EXTENSION {

    //
    // Data in common with the keyboard extension;
    //
    struct COMMON_DATA;

} PORT_MOUSE_EXTENSION, *PPORT_MOUSE_EXTENSION;

//
// controller specific data used by both devices
//
typedef struct _CONTROLLER_DATA {

    //
    // Indicate which hardware is actually present (keyboard and/or mouse).
    //
    ULONG HardwarePresent;

    //
    // IOCTL synchronization object
    //
    PCONTROLLER_OBJECT ControllerObject;

    //
    // Port configuration information.
    //
    I8042_CONFIGURATION_INFORMATION Configuration;

    //
    // Spin lock to guard powering the devices back up
    //
    KSPIN_LOCK PowerUpSpinLock;

} CONTROLLER_DATA, *PCONTROLLER_DATA;

typedef struct _GLOBALS {

#if PTDRV_VERBOSE
    //
    // Flags:  Bit field for enabling debugging print statements
    // Level:  Legacy way of controllign debugging statements
    //
    ULONG DebugFlags;
#endif

    //
    // Pointer to controller specific data that both extensions may access it
    //
    PCONTROLLER_DATA ControllerData;

    //
    // The two possible extensions that can be created
    //
    PPORT_MOUSE_EXTENSION    MouseExtension;
    PPORT_KEYBOARD_EXTENSION KeyboardExtension;

    //
    // Path to the driver's entry in the registry
    //
    UNICODE_STRING RegistryPath;

    //
    // Keep track of the number of AddDevice and StartDevice calls.  Want to
    // postpone h/w initialization until the last StartDevice is received
    // (due to some h/w which freezes if initialized more than once)
    //
    LONG  AddedKeyboards;
    LONG  AddedMice;
    ULONG ulDeviceNumber;

    USHORT PowerUpFlags;
    

    //
    // Provide mutual exclusion during dispatch functions
    //
    FAST_MUTEX DispatchMutex;

} GLOBALS;

extern GLOBALS Globals;

//
// Statically allocate the (known) scancode-to-indicator-light mapping.
// This information is returned by the
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION device control request.
//

#define KEYBOARD_NUMBER_OF_INDICATORS 3

static const INDICATOR_LIST IndicatorList[KEYBOARD_NUMBER_OF_INDICATORS] = {
        {0x3A, KEYBOARD_CAPS_LOCK_ON},
        {0x45, KEYBOARD_NUM_LOCK_ON},
        {0x46, KEYBOARD_SCROLL_LOCK_ON}};

//
// Function prototypes.
//

NTSTATUS
PtEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#if PTDRV_VERBOSE
VOID
PtServiceParameters(
    IN PUNICODE_STRING RegistryPath
    );
#endif

VOID
PtSendCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA pInput,
    IN ULONG ulEntries
    );

VOID
PtSendCurrentMouseInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA pInput,
    IN ULONG ulEntries
    );

NTSTATUS
PtClose (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtCreate (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PtStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PtKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PtKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    );

VOID
PtFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtFindPortCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

LONG
PtManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    );

NTSTATUS
PtPnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PtPower (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtPowerUpToD0Complete (
	IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
PtRemovePort(
    IN PIO_RESOURCE_DESCRIPTOR ResDesc
    );

NTSTATUS
PtSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PtUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PtSystemControl (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtInitWmi(
    PCOMMON_DATA CommonData
    );

NTSTATUS
PtSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
PtSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
PtKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
PtMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
PtQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );


extern WMIGUIDREGINFO KbWmiGuidList[1];
extern WMIGUIDREGINFO MouWmiGuidList[1];

#if DBG
#define DEFAULT_DEBUG_FLAGS 0x8cc88888
#else
#define DEFAULT_DEBUG_FLAGS 0x0
#endif


#if PTDRV_VERBOSE
//
//Debug messaging and breakpoint macros
//
#define DBG_ALWAYS                 0x00000000

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_DPC_MASK               0x0000F000
#define DBG_DPC_NOISE              0x00001000
#define DBG_DPC_TRACE              0x00002000
#define DBG_DPC_INFO               0x00004000
#define DBG_DPC_ERROR              0x00008000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define Print(_flags_, _x_) \
            if (Globals.DebugFlags & (_flags_) || !(_flags_)) { \
                DbgPrint (pDriverName); \
                DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else

#define Print(_l_,_x_)
#define TRAP()

#endif  // PTDRV_VERBOSE

#endif // _PTDRVCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvkbd.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvkbd.c

Abstract:

    Keyboard specific parts of the RDP remote port driver.

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtKeyboardConfiguration)
#pragma alloc_text(PAGE, PtKeyboardStartDevice)
#pragma alloc_text(PAGE, PtKeyboardRemoveDevice)
#endif


VOID
PtSendCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA pInput,
    IN ULONG ulEntries
    )
/*++

Routine Description:

    This routine calls the keyboard class driver until all the data has been
    queued.

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_KEYBOARD_EXTENSION deviceExtension;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;
    PUCHAR pEnd;

    Print(DBG_DPC_NOISE, ("PtSendCurrentKeyboardInput: enter\n"));

    if (DeviceObject != NULL) {
        deviceExtension = DeviceObject->DeviceExtension;

        if (deviceExtension->EnableCount) {
            PVOID classService;
            PVOID classDeviceObject;
            ULONG dataNotConsumed = 0;
            ULONG inputDataConsumed = 0;

            //
            // Call the connected class driver's callback ISR
            //
            classDeviceObject = deviceExtension->ConnectData.ClassDeviceObject;
            classService      = deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            Print(DBG_DPC_NOISE,
                  ("PtSendCurrentKeyboardInput: calling class callback (%p, %ld)\n",
                  pInput, ulEntries));

            dataNotConsumed = ulEntries;
            pEnd = (PUCHAR)pInput + (ulEntries * sizeof(KEYBOARD_INPUT_DATA));
            while (dataNotConsumed)
            {
                KIRQL oldIrql;

                inputDataConsumed = 0;

                //
                // Class Service Callback routines need to be execusted at
                // DISPATCH_LEVEL, so raise IRQL before calling the callback.
                //

                KeRaiseIrql( DISPATCH_LEVEL, &oldIrql);

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      pInput,
                      pEnd,
                      &inputDataConsumed);

                //
                // reset the IRQL.
                //

                KeLowerIrql( oldIrql );

                dataNotConsumed = ((ULONG)(pEnd - (PUCHAR)pInput)
                                   /sizeof(KEYBOARD_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("PtSendCurrentKeyboardInput: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed));

                if (dataNotConsumed)
                {
                    //
                    // update the input pointer
                    //
                    pInput = (PKEYBOARD_INPUT_DATA)((PUCHAR)pInput +
                                    inputDataConsumed * sizeof(KEYBOARD_INPUT_DATA));

                    //
                    // sleep for 1 ms
                    //
                    SleepTime = RtlEnlargedIntegerMultiply( 1, -10000 );
                    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );
                }
            }
        }

    } else {
        Print(DBG_DPC_ERROR, ("PtSendCurrentKeyboardInput called with NULL Keyboard Device Object\n"));
    }

    Print(DBG_DPC_NOISE, ("PtSendCurrentKeyboardInput: exit\n"));
}


NTSTATUS
PtKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the keyboard.

Arguments:

    KeyboardExtension - Keyboard extension

    ResourceList - Translated resource list give to us via the start IRP

Return Value:

    STATUS_SUCCESS if all the resources required are presented

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    PKEYBOARD_ID                        keyboardId;

    ULONG                               count,
                                        i;

    PAGED_CODE();

    if (ResourceList) {
        fullResDesc = ResourceList->List;
        if (!fullResDesc) {
            //
            // this should never happen
            //
            ASSERT(fullResDesc != NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        configuration = &Globals.ControllerData->Configuration;

        partialResList = &fullResDesc->PartialResourceList;
        currentResDesc = firstResDesc = partialResList->PartialDescriptors;
        count = partialResList->Count;

        for (i = 0; i < count; i++, currentResDesc++) {
            switch (currentResDesc->Type) {
            case CmResourceTypePort:
                //
                // Copy the port information.  We will sort the port list
                // into ascending order based on the starting port address
                // later (note that we *know* there are a max of two port
                // ranges for the i8042).
                //
                Print(DBG_SS_NOISE,
                      ("port is %s\n",
                      currentResDesc->Flags == CM_RESOURCE_PORT_MEMORY ?
                         "memory" :
                         "an io port"
                      ));

                if (configuration->PortListCount < MaximumPortCount) {
                    configuration->PortList[configuration->PortListCount] =
                        *currentResDesc;
                    configuration->PortListCount += 1;
                }
                else {
                    Print(DBG_SS_INFO | DBG_SS_ERROR,
                          ("KB::PortListCount already at max (%d)\n",
                           configuration->PortListCount
                          )
                         );
                }
                break;

            default:
                Print(DBG_ALWAYS,
                      ("resource type 0x%x unhandled...\n",
                      (LONG) currentResDesc->Type
                      ));
                break;
            }
        }

    }
    else
        Print(DBG_SS_INFO | DBG_SS_TRACE, ("keyboard with null resources\n"));

    return status;
}

NTSTATUS
PtKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Configures the keyboard's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the keyboard is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    KeyboardExtension - Keyboard extesnion

    ResourceList - Translated resource list for this device

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    ULONG                               dumpData[1];
    NTSTATUS                            status = STATUS_SUCCESS;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("PtKeyboardStartDevice, enter\n"));

    //
    // Check to see if kb has been started.  If so, fail this start
    //
    if (KEYBOARD_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many kbs!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the keyboards were bogus, but it is
        // done so that Globals.AddedKeyboards == # of actual started keyboards
        //
        InterlockedDecrement(&Globals.AddedKeyboards);

        status = STATUS_NO_SUCH_DEVICE;
        goto PtKeyboardStartDeviceExit;
    }
    else if (KeyboardExtension->ConnectData.ClassService == NULL) {
        //
        // We are never really going to get here because if we don't have the
        // class driver on top of us, extension->IsKeyboard will be false and
        // we will think that the device is a mouse, but for completeness

        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class
        // driver is that the AddedKeyboards count is not incremented for this
        // device
        //

        Print(DBG_SS_ERROR, ("Keyboard started with out a service cb!\n"));
        return STATUS_INVALID_DEVICE_STATE;
    }

    status = PtKeyboardConfiguration(KeyboardExtension,
                                      ResourceList
                                      );

    if (!NT_SUCCESS(status)) {
        goto PtKeyboardStartDeviceExit;
    }

    ASSERT( KEYBOARD_PRESENT() );

    Globals.KeyboardExtension = KeyboardExtension;

    PtInitWmi(GET_COMMON_DATA(KeyboardExtension));

    KeyboardExtension->Initialized = TRUE;

PtKeyboardStartDeviceExit:
    Print(DBG_SS_INFO,
          ("PtKeyboardStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("PtKeyboardStartDevice exit (0x%x)\n", status));

    return status;
}

VOID
PtKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes the device.  This will only occur if the device removed itself.
    Disconnects the interrupt, removes the synchronization flag for the mouse if
    present, and frees any memory associated with the device.

Arguments:

    DeviceObject - The device object for the keyboard

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    PPORT_KEYBOARD_EXTENSION keyboardExtension = DeviceObject->DeviceExtension;
    PIRP irp;

    Print(DBG_PNP_INFO, ("PtKeyboardRemoveDevice enter\n"));

    PAGED_CODE();

    if (Globals.KeyboardExtension == keyboardExtension && keyboardExtension) {
        Globals.KeyboardExtension = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvmou.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvmou.c

Abstract:

    Mouse specific parts of the RDP remote port driver.

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtMouseConfiguration)
#pragma alloc_text(PAGE, PtMouseStartDevice)
#endif

NTSTATUS
PtMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST     ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the mouse.

Arguments:

    MouseExtension - Mouse extension

    ResourceList   - Translated resource list give to us via the start IRP

Return Value:

    STATUS_SUCCESS if all the resources required are presented

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc   = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc    = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    ULONG                               count,
                                        i;

    PAGED_CODE();

    if (ResourceList) {
        fullResDesc = ResourceList->List;

        if (!fullResDesc) {
            //
            // this should never happen
            //
            ASSERT(fullResDesc != NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);
        configuration = &Globals.ControllerData->Configuration;

        partialResList = &fullResDesc->PartialResourceList;
        currentResDesc = firstResDesc = partialResList->PartialDescriptors;
        count = partialResList->Count;

        //
        // NOTE:  not all of the resources associated with the i8042 may be given at
        //        this time.  From empirical tests, the mouse is only associated with its
        //        interrupt, while the keyboard will receive the ports along with its
        //        interrupt
        //
        for (i = 0; i < count; i++, currentResDesc++) {
            switch (currentResDesc->Type) {
            case CmResourceTypePort:
                //
                // Copy the port information.  We will sort the port list
                // into ascending order based on the starting port address
                // later (note that we *know* there are a max of two port
                // ranges for the i8042).
                //
                Print(DBG_SS_NOISE, ("io flags are 0x%x\n", currentResDesc->Flags));

                if (configuration->PortListCount < MaximumPortCount) {
                    configuration->PortList[configuration->PortListCount] = *currentResDesc;
                    configuration->PortListCount += 1;
                }
                else {
                    Print(DBG_SS_INFO | DBG_SS_ERROR,
                          ("Mouse::PortListCount already at max (%d)",
                          configuration->PortListCount
                          ));
                }
                break;

            default:
                Print(DBG_ALWAYS,
                      ("resource type 0x%x unhandled...\n",
                      (LONG) currentResDesc->Type
                      ));
                break;

            }
        }
    }
    else {
        Print(DBG_SS_INFO | DBG_SS_TRACE, ("mouse with null resources\n"));
    }

    if (NT_SUCCESS(status)) {
        Globals.ControllerData->HardwarePresent |= MOUSE_HARDWARE_INITIALIZED;
    }
    return status;
}

VOID
PtSendCurrentMouseInput(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PMOUSE_INPUT_DATA pInput,
    IN ULONG             ulEntries
    )
/*++

Routine Description:

    This routine calls the mouse class driver until all the data has been
    queued.

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_MOUSE_EXTENSION deviceExtension;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;
    PUCHAR pEnd;

    Print(DBG_DPC_NOISE, ("PtSendCurrentMouseInput: enter\n"));

    if (DeviceObject != NULL) {

        deviceExtension = DeviceObject->DeviceExtension;

        if (deviceExtension->EnableCount) {
            PVOID classService;
            PVOID classDeviceObject;
            ULONG dataNotConsumed = 0;
            ULONG inputDataConsumed = 0;

            //
            // Call the connected class driver's callback ISR with the supplied data
            //
            classDeviceObject = deviceExtension->ConnectData.ClassDeviceObject;
            classService      = deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            Print(DBG_DPC_NOISE,
                  ("PtSendCurrentMouseInput: calling class callback (%p, %ld)\n",
                  pInput, ulEntries));

            dataNotConsumed = ulEntries;
            pEnd = (PUCHAR)pInput + (ulEntries * sizeof(MOUSE_INPUT_DATA));
            while (dataNotConsumed)
            {
                KIRQL oldIrql;

                inputDataConsumed = 0;

                //
                // Class Service Callback routines need to be execusted at
                // DISPATCH_LEVEL, so raise IRQL before calling the callback.
                //

                KeRaiseIrql( DISPATCH_LEVEL, &oldIrql);

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      pInput,
                      pEnd,
                      &inputDataConsumed);

                //
                // reset the IRQL.
                //

                KeLowerIrql( oldIrql );

                dataNotConsumed = ((ULONG)(pEnd - (PUCHAR)pInput)
                                   /sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("PtSendCurrentMouseInput: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed));

                if (dataNotConsumed)
                {
                    //
                    // update the input pointer
                    //
                    pInput = (PMOUSE_INPUT_DATA)((PUCHAR)pInput +
                                    inputDataConsumed * sizeof(MOUSE_INPUT_DATA));

                    //
                    // sleep for 1 ms
                    //
                    SleepTime = RtlEnlargedIntegerMultiply( 1, -10000 );
                    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );
                }
            }
        }

    } else {
        Print(DBG_DPC_ERROR, ("PtSendCurrentMouseInput called with NULL Mouse Device Object\n"));
    }

    Print(DBG_DPC_NOISE, ("PtSendCurrentMouseInput: exit\n"));
}


NTSTATUS
PtMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST  ResourceList
    )
/*++

Routine Description:

    Configures the mouse's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the mouse is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    MouseExtension - Mouse extesnion

    ResourceList - Translated resource list for this device

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("PtMouseStartDevice, enter\n"));

    //
    // Check to see if a mouse has been started. If so, fail this start.
    //
    if (MOUSE_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many mice!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the mice were bogus, but it is
        // done so that Globals.AddedMice == # of actual started mice
        //
        InterlockedDecrement(&Globals.AddedMice);

        status =  STATUS_NO_SUCH_DEVICE;
        goto PtMouseStartDeviceExit;
    }
    else if (MouseExtension->ConnectData.ClassService == NULL) {
        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class
        // driver is that the AddedMice count is not incremented for this
        // device
        //
        Print(DBG_SS_ERROR, ("Mouse started with out a service cb!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
        goto PtMouseStartDeviceExit;
    }

    //
    // Parse and store all of the resources associated with the mouse
    //
    status = PtMouseConfiguration(MouseExtension,
                                  ResourceList
                                  );
    if (!NT_SUCCESS(status)) {
        PtManuallyRemoveDevice(GET_COMMON_DATA(MouseExtension));
        goto PtMouseStartDeviceExit;
    }

    ASSERT( MOUSE_PRESENT() );

    Globals.MouseExtension = MouseExtension;

    PtInitWmi(GET_COMMON_DATA(MouseExtension));

    MouseExtension->Initialized = TRUE;

PtMouseStartDeviceExit:
    Print(DBG_SS_INFO,
          ("PtMouseStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("PtMouseStartDevice exit (0x%x)\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvcom.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvcom.c

Abstract:

    Code for the RDP remote port driver which is common to the mouse and keyboard

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include <poclass.h>

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtCreate)
#pragma alloc_text(PAGE, PtDeviceControl)
#pragma alloc_text(INIT, PtEntry)
#pragma alloc_text(PAGE, PtUnload)
#if PTDRV_VERBOSE
#pragma alloc_text(INIT, PtServiceParameters)
#endif
#endif // ALLOC_PRAGMA

GLOBALS Globals;

NTSTATUS
PtCreate (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PCOMMON_DATA        commonData = NULL;

    Print(DBG_IOCTL_TRACE, ("Create enter\n"));

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    if (NULL == commonData->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print(DBG_IOCTL_ERROR,
              ("ERROR: enable before connect!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
    }
    else if (commonData->ManuallyRemoved) {
        status = STATUS_NO_SUCH_DEVICE;
    }
    else if (1 >= InterlockedIncrement(&commonData->EnableCount)) {
        Print(DBG_IOCTL_INFO,
             ("Enabling %s (%d)\n",
             commonData->IsKeyboard ? "Keyboard" : "Mouse",
             commonData->EnableCount
             ));
    }

    //
    // No need to call the lower driver (the root bus) because it only handles
    // Power and PnP Irps
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    Print(DBG_IOCTL_TRACE, ("Create (%x)\n", status));

    return status;
}

NTSTATUS
PtClose (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PCOMMON_DATA        commonData;

    PAGED_CODE();

    Print(DBG_IOCTL_TRACE, ("Close\n"));

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    ASSERT(0 < commonData->EnableCount);

    if (0 >= InterlockedDecrement(&commonData->EnableCount)) {
        Print(DBG_IOCTL_INFO,
              ("Disabling %s (%d)\n",
              commonData->IsKeyboard ? "Keyboard" : "Mouse",
              commonData->EnableCount
              ));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
PtDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPORT_KEYBOARD_EXTENSION    kbExtension;
    PIO_STACK_LOCATION          stack;
    NTSTATUS                    status = STATUS_INVALID_DEVICE_REQUEST;

    PAGED_CODE();

    //
    // Get a pointer to the device extension.
    //
    kbExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    if (!kbExtension->Started || !kbExtension->IsKeyboard ||
        kbExtension->ManuallyRemoved) {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {
        stack = IoGetCurrentIrpStackLocation(Irp);
        switch (stack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_GET_SYS_BUTTON_CAPS:
            //
            // We don't support any system buttons
            //
            if (stack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                Print(DBG_IOCTL_ERROR, ("get caps, buffer too small\n"));
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            else {
                Print(DBG_IOCTL_INFO, ("Returned sys btn caps of 0x0\n"));
                *(PULONG) Irp->AssociatedIrp.SystemBuffer = 0x0;
                status = STATUS_SUCCESS;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            break;

        default:
            Print(DBG_IOCTL_ERROR, ("Invalid request 0x%x\n",
                stack->Parameters.DeviceIoControl.IoControlCode));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
PtInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    This routine cannot be paged because the class drivers send down internal
    IOCTLs at DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION                  irpSp;
    PPORT_MOUSE_EXTENSION               mouseExtension = DeviceObject->DeviceExtension;
    PPORT_KEYBOARD_EXTENSION            kbExtension = DeviceObject->DeviceExtension;
    NTSTATUS                            status;
    ULONG                               sizeOfTranslation;
    PDEVICE_OBJECT                      topOfStack;

    Print(DBG_IOCTL_TRACE, ("IOCTL: enter\n"));

    Irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //

    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // PtPnp and PtKeyboardStartDevice routines
        //

        if (KEYBOARD_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ kb connects!\n"));
            SET_HW_FLAGS(DUP_KEYBOARD_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedKeyboards);

        kbExtension->IsKeyboard = TRUE;

        SET_HW_FLAGS(KEYBOARD_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard connect\n"));

        //
        // Save away the keyboard device object - we'll need it later
        //
        KbdDeviceObject = DeviceObject;

        //
        // Only allow a connection if the keyboard hardware is present.
        // Also, only allow one connection.
        //
        if (kbExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //

        kbExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard disconnect\n"));

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Connect a mouse class device driver to the port driver.
    //
    case IOCTL_INTERNAL_MOUSE_CONNECT:

        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // PtPnp and PtMouseStartDevice routines
        //
        if (MOUSE_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ mouse connects!\n"));
            SET_HW_FLAGS(DUP_MOUSE_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedMice);

        mouseExtension->IsKeyboard = FALSE;

        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse connect\n"));

        //
        // Save away the mouse device object - we'll need it later
        //
        MouDeviceObject = DeviceObject;

        //
        // Only allow a connection if the mouse hardware is present.
        // Also, only allow one connection.
        //
        if (mouseExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        mouseExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a mouse class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_MOUSE_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse disconnect\n"));

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Query the keyboard attributes.  First check for adequate buffer
    // length.  Then, copy the keyboard attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            PKEYBOARD_ATTRIBUTES pKBA =
                (PKEYBOARD_ATTRIBUTES)Irp->AssociatedIrp.SystemBuffer;

            pKBA->KeyboardIdentifier.Type    = 0x51;
            pKBA->KeyboardIdentifier.Subtype = 0;

            pKBA->KeyboardMode         = 1;
            pKBA->NumberOfFunctionKeys = KEYBOARD_NUM_FUNCTION_KEYS;
            pKBA->NumberOfIndicators   = KEYBOARD_NUM_INDICATORS;
            pKBA->NumberOfKeysTotal    = KEYBOARD_NUM_KEYS_TOTAL;
            pKBA->InputDataQueueLength = 100;

            pKBA->KeyRepeatMinimum.UnitId    = 0;
            pKBA->KeyRepeatMinimum.Rate      = 2;
            pKBA->KeyRepeatMinimum.Delay     = 250;

            pKBA->KeyRepeatMaximum.UnitId    = 0;
            pKBA->KeyRepeatMaximum.Rate      = 30;
            pKBA->KeyRepeatMaximum.Delay     = 1000;

            Irp->IoStatus.Information = sizeof(KEYBOARD_ATTRIBUTES);
            status = STATUS_SUCCESS;

        }

        break;

    //
    // Query the scan code to indicator-light mapping. Validate the
    // parameters, and copy the indicator mapping information from
    // the port device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION: {

        PKEYBOARD_INDICATOR_TRANSLATION translation;

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicator translation\n"));

        sizeOfTranslation = sizeof(KEYBOARD_INDICATOR_TRANSLATION)
            + (sizeof(INDICATOR_LIST)
            * (KEYBOARD_NUM_INDICATORS - 1));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeOfTranslation) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the indicator mapping information to the system
            // buffer.
            //

            translation = (PKEYBOARD_INDICATOR_TRANSLATION)
                Irp->AssociatedIrp.SystemBuffer;
            translation->NumberOfIndicatorKeys = KEYBOARD_NUM_INDICATORS;

            RtlMoveMemory(
                translation->IndicatorList,
                (PCHAR) IndicatorList,
                sizeof(INDICATOR_LIST) * translation->NumberOfIndicatorKeys
                );

            Irp->IoStatus.Information = sizeOfTranslation;
            status = STATUS_SUCCESS;
        }

        break;
    }

    //
    // Query the keyboard indicators.  Validate the parameters, and
    // copy the indicator information from the port device extension to
    // the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATORS:

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicators\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Just say they're all off
            //
            ((PKEYBOARD_INDICATOR_PARAMETERS)Irp->AssociatedIrp.SystemBuffer)->LedFlags = 0;
            Irp->IoStatus.Information = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Set the keyboard indicators
    //
    case IOCTL_KEYBOARD_SET_INDICATORS:

        // Just return success
        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set indicators\n"));
        status = STATUS_SUCCESS;

        break;

    //
    // Query the current keyboard typematic rate and delay.  Validate
    // the parameters, and copy the typematic information from the port
    // device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query typematic\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // just return our default info
            //
            PKEYBOARD_TYPEMATIC_PARAMETERS pKTP =
                (PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;

            pKTP->Rate  = KEYBOARD_TYPEMATIC_RATE_DEFAULT;
            pKTP->Delay = KEYBOARD_TYPEMATIC_DELAY_DEFAULT;

            Irp->IoStatus.Information = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Sets the keyboard typematic rate and delay
    // We just say 'fine'
    //
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        {
            status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_KEYBOARD_SET_IME_STATUS:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set ime status\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    //
    // Query the mouse attributes.  First check for adequate buffer
    // length.  Then, copy the mouse attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_MOUSE_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUSE_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            PMOUSE_ATTRIBUTES pMA = (PMOUSE_ATTRIBUTES)
                                              Irp->AssociatedIrp.SystemBuffer;
            pMA->MouseIdentifier      = MOUSE_IDENTIFIER;
            pMA->NumberOfButtons      = MOUSE_NUM_BUTTONS;
            pMA->SampleRate           = MOUSE_SAMPLE_RATE;
            pMA->InputDataQueueLength = MOUSE_INPUT_QLEN;

            Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse send buffer\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER:
        status = STATUS_NOT_SUPPORTED;
        break;

    default:

        Print(DBG_IOCTL_ERROR, ("IOCTL: INVALID REQUEST\n"));

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject,
                      Irp,
                      (PULONG) NULL,
                      NULL
                      );
    }
    else {
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT
                          );
    }

    Print(DBG_IOCTL_TRACE, ("IOCTL: exit (0x%x)\n", status));

    return status;
}


VOID
PtStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine starts an I/O operation for the device which is further
    controlled by the controller object

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/
{
    KIRQL                     cancelIrql;
    PIO_STACK_LOCATION        irpSp;

    Print(DBG_IOCTL_TRACE, ("PtStartIo: enter\n"));

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
    case IOCTL_KEYBOARD_SET_IME_STATUS:
    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
    case IOCTL_INTERNAL_MOUSE_RESET:
    default:

        Print(DBG_IOCTL_ERROR, ("PtStartIo: INVALID REQUEST\n"));

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject, FALSE);
    }

    Print(DBG_IOCTL_TRACE, ("PtStartIo: exit\n"));
}

NTSTATUS
PtEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;


    RtlZeroMemory(&Globals,
                  sizeof(GLOBALS)
                  );

    Globals.ControllerData = (PCONTROLLER_DATA) ExAllocatePool(
        NonPagedPool,
        sizeof(CONTROLLER_DATA)
        );

    if (!Globals.ControllerData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory(Globals.ControllerData,
                  sizeof(CONTROLLER_DATA)
                  );

    Globals.ControllerData->ControllerObject = IoCreateController(0);

    if (!Globals.ControllerData->ControllerObject) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    Globals.RegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    Globals.RegistryPath.Length = RegistryPath->Length;
    Globals.RegistryPath.Buffer = ExAllocatePool(
                                       NonPagedPool,
                                       Globals.RegistryPath.MaximumLength
                                       );

    if (!Globals.RegistryPath.Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory (Globals.RegistryPath.Buffer,
                   Globals.RegistryPath.MaximumLength);

    RtlMoveMemory (Globals.RegistryPath.Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);

#if PTDRV_VERBOSE
    PtServiceParameters(RegistryPath);
#endif

    ExInitializeFastMutex(&Globals.DispatchMutex);
    KeInitializeSpinLock(&Globals.ControllerData->PowerUpSpinLock);

    Print(DBG_SS_TRACE, ("PortDriverEntry (0x%x) \n", status));

    return status;

DriverEntryError:

    //
    // Clean after something has gone wrong
    // and set pointers to NULL for PtUnload
    //
    if (Globals.ControllerData) {
        if (Globals.ControllerData->ControllerObject) {
            IoDeleteController(Globals.ControllerData->ControllerObject);
        }

        ExFreePool(Globals.ControllerData);
        Globals.ControllerData = NULL;
    }

    if (Globals.RegistryPath.Buffer) {
        ExFreePool(Globals.RegistryPath.Buffer);
        Globals.RegistryPath.Buffer = NULL;
        Globals.RegistryPath.Length = 0;
        Globals.RegistryPath.MaximumLength = 0;
    }

    Print(DBG_SS_ERROR, ("PortDriverEntry (0x%x) \n", status));
    return status;
}

VOID
PtUnload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    ULONG i;

    PAGED_CODE();

    ASSERT(NULL == Driver->DeviceObject);

    Print(DBG_SS_TRACE, ("Unload \n"));

    //
    // Free resources in Globals
    //

    // test for all pointers in case they were not allocated
    if (Globals.ControllerData) {
        if (Globals.ControllerData->ControllerObject) {
            IoDeleteController(Globals.ControllerData->ControllerObject);
        }
        ExFreePool(Globals.ControllerData);
        Globals.ControllerData = NULL;
    }

    if (Globals.RegistryPath.Buffer) {
        ExFreePool(Globals.RegistryPath.Buffer);
        Globals.RegistryPath.Buffer = NULL;
        Globals.RegistryPath.Length = 0;
        Globals.RegistryPath.MaximumLength = 0;
    }
    

    return;
}


#if PTDRV_VERBOSE
VOID
PtServiceParameters(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    NTSTATUS                            status = STATUS_SUCCESS;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PRTL_QUERY_REGISTRY_TABLE           parameters = NULL;
    PWSTR                               path = NULL;
    ULONG                               defaultDebugFlags = DEFAULT_DEBUG_FLAGS;
    ULONG                               i = 0;
    UNICODE_STRING                      parametersPath;
    USHORT                              queries = 2;

    if (Globals.ControllerData == NULL)
        return;

    configuration = &(Globals.ControllerData->Configuration);
    parametersPath.Buffer = NULL;

    Globals.DebugFlags = DEFAULT_DEBUG_FLAGS;
    //
    // Registry path is already null-terminated, so just use it.
    //
    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
        parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("%s: couldn't allocate table for Rtl query to %ws for %ws\n",
                 pFncServiceParameters,
                 pwParameters,
                 path
                 ));
            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &parametersPath, NULL );
            parametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            parametersPath.Buffer = ExAllocatePool(
                PagedPool,
                parametersPath.MaximumLength
                );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("%s: Couldn't allocate string for path to %ws for %ws\n",
                     pFncServiceParameters,
                     pwParameters,
                     path
                     ));
                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            pwParameters
            );

        Print(DBG_SS_INFO,
             ("%s: %ws path is %ws\n",
             pFncServiceParameters,
             pwParameters,
             parametersPath.Buffer
             ));

        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwDebugFlags;
        parameters[i].EntryContext = &Globals.DebugFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDebugFlags;
        parameters[i].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            parametersPath.Buffer,
            parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(status)) {

            Print(DBG_SS_INFO,
                 ("%s: RtlQueryRegistryValues failed with 0x%x\n",
                 pFncServiceParameters,
                 status
                 ));
        }
    }

    Print(DBG_SS_NOISE, ("PtServiceParameters results..\n"));

    Print(DBG_SS_NOISE,
          ("\tDebug flags are 0x%x\n",
          Globals.DebugFlags
          ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}
#endif // PTDRV_VERBOSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvpnp.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvpnp.c

Abstract:

    This module contains general PnP code for the RDP remote port driver.

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtAddDevice)
#pragma alloc_text(PAGE, PtManuallyRemoveDevice)
#pragma alloc_text(PAGE, PtPnP)
//#pragma alloc_text(PAGE, PtPower)
#pragma alloc_text(PAGE, PtSendIrpSynchronously)
#endif

NTSTATUS
PtAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:

    Adds a device to the stack and sets up the appropriate flags and
    device extension for the newly created device.

Arguments:

    Driver - The driver object
    PDO    - the device that we are attaching ourselves on top of

Return Value:

    NTSTATUS result code.

--*/
{
    PCOMMON_DATA             commonData;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;
    ULONG                    maxSize;
    UNICODE_STRING           fullRDPName;
    UNICODE_STRING           baseRDPName;
    UNICODE_STRING           deviceNameSuffix;


    PAGED_CODE();

    Print(DBG_PNP_TRACE, ("enter Add Device: %ld \n", Globals.ulDeviceNumber));

    //
    // Initialize the various unicode structures for forming the device name.
    //
    if (Globals.ulDeviceNumber == 0)
        RtlInitUnicodeString(&fullRDPName, RDP_CONSOLE_BASE_NAME0);
    else
        RtlInitUnicodeString(&fullRDPName, RDP_CONSOLE_BASE_NAME1);

    maxSize = sizeof(PORT_KEYBOARD_EXTENSION) > sizeof(PORT_MOUSE_EXTENSION) ?
              sizeof(PORT_KEYBOARD_EXTENSION) :
              sizeof(PORT_MOUSE_EXTENSION);

    status = IoCreateDevice(Driver,                 // driver
                            maxSize,                // size of extension
                            NULL,                   // device name
                            FILE_DEVICE_8042_PORT,  // device type  ?? unknown at this time!!!
                            FILE_DEVICE_SECURE_OPEN,// device characteristics
                            FALSE,                  // exclusive
                            &device                 // new device
                            );

    if (!NT_SUCCESS(status)) {
        Print(DBG_SS_TRACE, ("Add Device failed! (0x%x) \n", status));
        return status;
    }

    Globals.ulDeviceNumber++;

    RtlZeroMemory(device->DeviceExtension, maxSize);

    //
    // Set up the device type
    //
    *((ULONG *)(device->DeviceExtension)) = DEV_TYPE_PORT;

    commonData = GET_COMMON_DATA(device->DeviceExtension);
    RtlInitUnicodeString(&commonData->DeviceName, fullRDPName.Buffer);

    commonData->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    ASSERT(commonData->TopOfStack);

    commonData->Self =       device;
    commonData->PDO =        PDO;

    device->Flags |= DO_BUFFERED_IO;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    Print(DBG_PNP_TRACE, ("Add Device (0x%x)\n", status));

    return status;
}

NTSTATUS
PtSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Generic routine to send an irp DeviceObject and wait for its return up the
    device stack.

Arguments:

    DeviceObject - The device object to which we want to send the Irp

    Irp - The Irp we want to send

Return Value:

    return code from the Irp
--*/
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           PtPnPComplete,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PtPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    Completion routine for all PnP IRPs

Arguments:

    DeviceObject - Pointer to the DeviceObject

    Irp - Pointer to the request packet

    Event - The event to set once processing is complete

Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    stack = IoGetCurrentIrpStackLocation(Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PtPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for PnP requests
Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request packet


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PPORT_KEYBOARD_EXTENSION   kbExtension;
    PPORT_MOUSE_EXTENSION      mouseExtension;
    PCOMMON_DATA               commonData;
    PIO_STACK_LOCATION         stack;
    NTSTATUS                   status = STATUS_SUCCESS;
    KIRQL                      oldIrql;

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);
    stack = IoGetCurrentIrpStackLocation(Irp);

    Print(DBG_PNP_TRACE,
          ("PtPnP (%s),  enter (min func=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          (ULONG) stack->MinorFunction
          ));

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.

            ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);

            if (commonData->Started) {
                Print(DBG_PNP_ERROR,
                      ("received 1+ starts on %s\n",
                      commonData->IsKeyboard ? "kb" : "mouse"
                      ));
            }
            else {
                //
                // commonData->IsKeyboard is set during
                //  IOCTL_INTERNAL_KEYBOARD_CONNECT to TRUE and
                //  IOCTL_INTERNAL_MOUSE_CONNECT to FALSE
                //
                if (commonData->IsKeyboard) {
                    status = PtKeyboardStartDevice(
                      (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }
                else {
                    status = PtMouseStartDevice(
                      (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }

                if (NT_SUCCESS(status)) {
                    commonData->Started = TRUE;
                }
            }

            ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED ||
            status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;
        }

        //
        // do stuff here...
        //
        if (NT_SUCCESS(status)) {
            if (commonData->ManuallyRemoved &&
                !(commonData->IsKeyboard ? KEYBOARD_PRESENT():MOUSE_PRESENT())) {

                commonData->Started = FALSE;
                (PNP_DEVICE_STATE) Irp->IoStatus.Information |=
                    (PNP_DEVICE_REMOVED | PNP_DEVICE_DONT_DISPLAY_IN_UI);
            }

            //
            // In all cases this device must be disableable
            //
            (PNP_DEVICE_STATE) Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

            //
            // Don't show it in the device manager
            //
            (PNP_DEVICE_STATE) Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;


        } else {
           Print(DBG_PNP_ERROR,
                 ("error pending query pnp device state event (0x%x)\n",
                 status
                 ));
        }

        //
        // Irp->IoStatus.Information will contain the new i/o resource
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    //
    // Don't let either of the requests succeed, otherwise the kb/mouse
    // might be rendered useless.
    //
    //  NOTE: this behavior is particular to i8042prt.  Any other driver,
    //        especially any other keyboard or port driver, should
    //        succeed the query remove or stop.  i8042prt has this different
    //        behavior because of the shared I/O ports but independent interrupts.
    //
    //        FURTHERMORE, if you allow the query to succeed, it should be sent
    //        down the stack (see sermouse.sys for an example of how to do this)
    //
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
        status = (commonData->ManuallyRemoved ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    //
    // PnP rules dictate we send the IRP down to the PDO first
    //
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED ||
            status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_REMOVE_DEVICE:

        Print(DBG_PNP_TRACE, ("remove device\n"));

        if (commonData->Started && !commonData->ManuallyRemoved) {
            //
            // This should never happen.  The only way we can get a remove is if
            // a start has failed.
            //
            //  NOTE:  Again, this should never happen for i8042prt, but any
            //         other input port driver should allow itself to be removed
            //         (see sermouse.sys on how to do this correctly)
            //
            Print(DBG_PNP_ERROR, ("Cannot remove a started device!!!\n"));
            ASSERT(FALSE);
        }

        if (commonData->Initialized) {
            IoWMIRegistrationControl(commonData->Self,
                                     WMIREG_ACTION_DEREGISTER
                                     );
        }

        ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);
        if (commonData->IsKeyboard) {
            PtKeyboardRemoveDevice(DeviceObject);
        }
        ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);

        //
        // Nothing has been allocated or connected
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);

        IoDetachDevice(commonData->TopOfStack); 
        IoDeleteDevice(DeviceObject);
        
        break;

    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    default:
        //
        // Here the driver below i8042prt might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);

        break;
    }

    Print(DBG_PNP_TRACE,
          ("PtPnP (%s) exit (status=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          status
          ));

    return status;
}

LONG
PtManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Invalidates CommonData->PDO's device state and sets the manually removed
    flag

Arguments:

    CommonData - represent either the keyboard or mouse

Return Value:

    new device count for that particular type of device

--*/
{
    LONG deviceCount;

    PAGED_CODE();

    if (CommonData->IsKeyboard) {

        deviceCount = InterlockedDecrement(&Globals.AddedKeyboards);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear kb (manually remove)\n"));
            CLEAR_KEYBOARD_PRESENT();
        }

    } else {

        deviceCount = InterlockedDecrement(&Globals.AddedMice);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear mou (manually remove)\n"));
            CLEAR_MOUSE_PRESENT();
        }

    }

    CommonData->ManuallyRemoved = TRUE;
    IoInvalidateDeviceState(CommonData->PDO);

    return deviceCount;
}


NTSTATUS
PtPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PCOMMON_DATA        commonData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;

    //PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    stack = IoGetCurrentIrpStackLocation(Irp);

    Print(DBG_POWER_TRACE,
          ("Power (%s), enter\n",
          commonData->IsKeyboard ? "keyboard" :
                                   "mouse"
          ));

    switch(stack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_WAIT_WAKE\n" ));
        break;

    case IRP_MN_POWER_SEQUENCE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_POWER_SEQUENCE\n" ));
        break;

    case IRP_MN_SET_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_SET_POWER\n" ));

        //
        // Don't handle anything but DevicePowerState changes
        //
        if (stack->Parameters.Power.Type != DevicePowerState) {
            Print(DBG_POWER_TRACE, ("not a device power irp\n"));
            break;
        }

        //
        // Check for no change in state, and if none, do nothing
        //
        if (stack->Parameters.Power.State.DeviceState ==
            commonData->PowerState) {
            Print(DBG_POWER_INFO,
                  ("no change in state (PowerDeviceD%d)\n",
                  commonData->PowerState-1
                  ));
            break;
        }

        switch (stack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            Print(DBG_POWER_TRACE, ("Powering up to PowerDeviceD0\n"));

            commonData->IsKeyboard ? KEYBOARD_POWERED_UP_STARTED()
                                   : MOUSE_POWERED_UP_STARTED();

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   PtPowerUpToD0Complete,
                                   NULL,
                                   TRUE,                // on success
                                   TRUE,                // on error
                                   TRUE                 // on cancel
                                   );

            //
            // PoStartNextPowerIrp() gets called when the irp gets completed
            //
            IoMarkIrpPending(Irp);
            PoCallDriver(commonData->TopOfStack, Irp);

            return STATUS_PENDING;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            Print(DBG_POWER_TRACE,
                  ("Powering down to PowerDeviceD%d\n",
                  stack->Parameters.Power.State.DeviceState-1
                  ));

            PoSetPowerState(DeviceObject,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );

            commonData->PowerState = stack->Parameters.Power.State.DeviceState;
            commonData->ShutdownType = stack->Parameters.Power.ShutdownType;

            //
            // For what we are doing, we don't need a completion routine
            // since we don't race on the power requests.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCopyCurrentIrpStackLocationToNext(Irp);  // skip ?

            PoStartNextPowerIrp(Irp);
            return  PoCallDriver(commonData->TopOfStack, Irp);

        default:
            Print(DBG_POWER_INFO, ("unknown state\n"));
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_QUERY_POWER\n" ));
        break;

    default:
        Print(DBG_POWER_NOISE,
              ("Got unhandled minor function (%d)\n",
              stack->MinorFunction
              ));
        break;
    }

    Print(DBG_POWER_TRACE, ("Power, exit\n"));

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(commonData->TopOfStack, Irp);
}

NTSTATUS
PtPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Reinitializes the i8042 haardware after any type of hibernation/sleep.

Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request

    Context - Context passed in from the funciton that set the completion
              routine. UNUSED.


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    NTSTATUS            status;
    PCOMMON_DATA        commonData;
    PIO_STACK_LOCATION  stack;
    KIRQL               irql;

    UNREFERENCED_PARAMETER(Context);

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    Print(DBG_POWER_TRACE,
          ("PowerUpToD0Complete (%s), Enter\n",
          commonData->IsKeyboard ? "kb" : "mouse"
          ));

    KeAcquireSpinLock(&Globals.ControllerData->PowerUpSpinLock, &irql);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        commonData->IsKeyboard ? KEYBOARD_POWERED_UP_SUCCESSFULLY()
                               : MOUSE_POWERED_UP_SUCCESSFULLY();

        status = STATUS_MORE_PROCESSING_REQUIRED;

    }
    else {
        commonData->IsKeyboard ? KEYBOARD_POWERED_UP_FAILED()
                               : MOUSE_POWERED_UP_FAILED();

        status = Irp->IoStatus.Status;

#if DBG
        if (commonData->IsKeyboard) {
            ASSERT(KEYBOARD_POWERED_UP_FAILED());
        }
        else {
            ASSERT(MOUSE_POWERED_UP_FAILED());
        }
#endif // DBG
    }

    KeReleaseSpinLock(&Globals.ControllerData->PowerUpSpinLock, irql);


    if (NT_SUCCESS(status)) {

        Print(DBG_SS_NOISE, ("reinit, status == 0x%x\n", status));

        stack = IoGetCurrentIrpStackLocation(Irp);

        ASSERT(stack->Parameters.Power.State.DeviceState == PowerDeviceD0);
        commonData->PowerState = stack->Parameters.Power.State.DeviceState;
        commonData->ShutdownType = PowerActionNone;

        PoSetPowerState(commonData->Self,
                        stack->Parameters.Power.Type,
                        stack->Parameters.Power.State
                        );
    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Reset PoweredDevices so that we can keep track of the powered device
    //  the next time the machine is power managed off.
    //
    CLEAR_POWERUP_FLAGS();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvstr.h ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvstr.h

Abstract:

    These are the string constants used in the RDP Remote Port driver.
    Using pointers to these string allows for better memory
    utilization and more readable code

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#ifndef _PTDRVSTR_H_
#define _PTDRVSTR_H_

//
// Nmes used in debug print statements
//
#define PTDRV_DRIVER_NAME_A                          "RemotePrt: "
#define PTDRV_FNC_SERVICE_PARAMETERS_A               "PtServiceParameters"

//
// Some strings used frequently by the driver
//
#define PTDRV_DEBUGFLAGS_W                          L"DebugFlags"
#define PTDRV_PARAMETERS_W                          L"\\Parameters"

//
// Make these variables globally visible
//
extern  const   PSTR    pDriverName;
extern  const   PSTR    pFncServiceParameters;

extern  const   PWSTR   pwDebugFlags;
extern  const   PWSTR   pwParameters;

#endif // _PTDRVSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\ptdrvstr.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvstr.c

Abstract:

    These are the string constants used in the RDP Remote Port Driver.
    Using pointers to these string allows for better memory
    utilization and more readable code

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include "ptdrvstr.h"

//
// Define some of the constant strings used for the debugger
//
const   PSTR    pDriverName                 = PTDRV_DRIVER_NAME_A;
const   PSTR    pFncServiceParameters       = PTDRV_FNC_SERVICE_PARAMETERS_A;

//
// Define some Constant strings that the drivers uses
//
const   PWSTR   pwDebugFlags                = PTDRV_DEBUGFLAGS_W;
const   PWSTR   pwParameters                = PTDRV_PARAMETERS_W;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\stack.c ===
/****************************************************************************/
// stack.c
//
// Routines for managing Terminal Server driver stacks.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop
#include <ntimage.h>

#include <minmax.h>
#include <regapi.h>

/*
 * Prototypes for procedures
 */

NTSTATUS
IcaDeviceControlStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Local procedure prototypes
 */
NTSTATUS
_LogError(
    IN PDEVICE_OBJECT pDeviceObject,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    );

NTSTATUS
_IcaDriverThread(
    IN PVOID pData
    );

PICA_STACK
_IcaAllocateStack(
    VOID
    );

VOID
_IcaFreeStack(
    PICA_STACK pStack
    );

NTSTATUS
_IcaPushStack(
    IN PICA_STACK pStack,
    IN PICA_STACK_PUSH pStackPush
    );

NTSTATUS
_IcaPopStack(
    IN PICA_STACK pStack
    );

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaLoadSd(
    IN PDLLNAME SdName,
    OUT PSDLINK *ppSdLink
    );

NTSTATUS
_IcaUnloadSd(
    IN PSDLINK pSdLink
    );

NTSTATUS
_IcaCallSd(
    IN PSDLINK pSdLink,
    IN ULONG ProcIndex,
    IN PVOID pParms
    );

VOID
_IcaReferenceSdLoad(
    IN PSDLOAD pSdLoad
    );

VOID
_IcaDereferenceSdLoad(
    IN PSDLOAD pSdLoad
    );

NTSTATUS
_IcaLoadSdWorker(
    IN PDLLNAME SdName,
    OUT PSDLOAD *ppSdLoad
    );

NTSTATUS
_IcaUnloadSdWorker(
    IN PSDLOAD pSdLoad
    );

NTSTATUS
IcaExceptionFilter(
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );

NTSTATUS
_RegisterBrokenEvent(
    IN PICA_STACK pStack,
    IN PICA_STACK_BROKEN pStackBroken
    );

NTSTATUS
_EnablePassthru( PICA_STACK pStack );

NTSTATUS
_DisablePassthru( PICA_STACK pStack );

NTSTATUS
_ReconnectStack( PICA_STACK pStack, HANDLE hIca );



NTSTATUS
IcaBindVirtualChannels(
    IN PICA_STACK pStack
    );

VOID
IcaRebindVirtualChannels(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaUnbindVirtualChannels(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaFreeAllVcBind(
    IN PICA_CONNECTION pConnect
    );

/*
 * Buffer Allocation counters.
 */

ULONG gAllocSucceed;
ULONG gAllocFailed;
ULONG gAllocFreed;

extern HANDLE   g_TermServProcessID;
ULONG   g_KeepAliveInterval=0;
/*
 * Dispatch table for stack objects
 */
PICA_DISPATCH IcaStackDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE
    IcaCloseStack,              // IRP_MJ_CLOSE
    NULL,                       // IRP_MJ_READ
    NULL,                       // IRP_MJ_WRITE
    NULL,                       // IRP_MJ_QUERY_INFORMATION
    NULL,                       // IRP_MJ_SET_INFORMATION
    NULL,                       // IRP_MJ_QUERY_EA
    NULL,                       // IRP_MJ_SET_EA
    NULL,                       // IRP_MJ_FLUSH_BUFFERS
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL
    IcaDeviceControlStack,      // IRP_MJ_DEVICE_CONTROL
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL
    NULL,                       // IRP_MJ_SHUTDOWN
    NULL,                       // IRP_MJ_LOCK_CONTROL
    IcaCleanupStack,            // IRP_MJ_CLEANUP
    NULL,                       // IRP_MJ_CREATE_MAILSLOT
    NULL,                       // IRP_MJ_QUERY_SECURITY
    NULL,                       // IRP_MJ_SET_SECURITY
    NULL,                       // IRP_MJ_SET_POWER
    NULL,                       // IRP_MJ_QUERY_POWER
};


NTSTATUS
IcaCreateStack (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to create a new ICA_STACK objecte.

Arguments:

    pConnect -- pointer to ICA_CONNECTION object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    KIRQL OldIrql;
    LONG PrimaryCount, ShadowCount, PassthruCount, ConsoleCount;
    NTSTATUS Status;
    PICA_STACK pPrimaryStack = NULL;

    /*
     * Allocate a new ICA stack object
     */
    pStack = _IcaAllocateStack();
    if ( pStack == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Finish initializing the stack object
     * (non-primary stacks are initialized with the fIoDisabled
     *  flag set to TRUE, i.e. they must be manually enabled)
     */
    pStack->StackClass = openPacket->TypeInfo.StackClass;
    pStack->fIoDisabled = ((pStack->StackClass != Stack_Primary) &&
                           (pStack->StackClass != Stack_Console));

    /*
     * Lock connection object while creating new stack
     */
    IcaLockConnection( pConnect );

    /*
     * Reference the connection object this stack belongs to.
     */
    IcaReferenceConnection( pConnect );
    pStack->pConnect = (PUCHAR)pConnect;

    /*
     * Search the existing stacks to check for invalid combinations.
     * 1) there can be only 1 primary stack per connection,
     * 2) there can be multiple shadow stacks per connection,
     *    but ONLY if there is no passthru stack,
     * 3) there can be only 1 passthru stack per connection,
     *    but only if there is an existing primary stack AND no shadow stacks.
     * 4) there can be only 1 console stack
     */
    Head = &pConnect->StackHead;
    PrimaryCount = ShadowCount = PassthruCount = ConsoleCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        PICA_STACK pCurrentStack;

        pCurrentStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

        switch ( pCurrentStack->StackClass ) {
            case Stack_Primary :
                PrimaryCount++;

                if( pStack->StackClass == Stack_Passthru) {
                    // store the primary stack pointer for
                    // passthru setup
                    pPrimaryStack = pCurrentStack;
                }
                ASSERT(PrimaryCount == 1);

            break;

            case Stack_Shadow :
                ShadowCount++;
                break;

            case Stack_Passthru :
                PassthruCount++;
                ASSERT(PassthruCount == 1);
                break;

            case Stack_Console :
                ConsoleCount++;
                ASSERT(ConsoleCount == 1);
                break;
        }
    }

    Status = STATUS_SUCCESS;
    switch ( pStack->StackClass ) {
        case Stack_Primary :
            if ( PrimaryCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;

        case Stack_Shadow :
            if ( PassthruCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;

        case Stack_Passthru :
            if ( PassthruCount != 0 || PrimaryCount != 1 || ShadowCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            else {
                /*
                 * Put the stack pointers in place. 
                 * This will make sure that we don't end up in a 
                 * a race condition and drop some pdus before the 
                 * shadow sequence completes.
                 */
                // PrimaryCount is 1 so pPrimaryStack is valid
                ASSERT(pPrimaryStack);
                pPrimaryStack->pPassthru = pStack;
                pStack->pPassthru = pPrimaryStack;
            }
            break;

        case Stack_Console :
            if ( ConsoleCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;
    }

    if ( Status != STATUS_SUCCESS ) {
        IcaUnlockConnection( pConnect );
        pStack->RefCount = 0;
        _IcaFreeStack( pStack );
        TRACE(( pConnect, TC_ICADD, TT_ERROR, "TermDD: IcaCreateStack failed, 0x%x\n", Status ));
        return( Status );
    }

    /*
     * Link this stack into the connection object stack list.
     */
    if (( pStack->StackClass == Stack_Primary ) ||
        ( pStack->StackClass == Stack_Console )) {
        InsertHeadList( &pConnect->StackHead, &pStack->StackEntry );
    } else {
        InsertTailList( &pConnect->StackHead, &pStack->StackEntry );
    }

    /*
     * Unlock connection object now
     */
    IcaUnlockConnection( pConnect );

    /*
     * Initialize the LastKeepAliveTime field to current system time
     */
    KeQuerySystemTime(&pStack->LastKeepAliveTime);

    /*
     * Lock the stack list for updating
     */
    IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

    /*
     * Insert the stack to the stack list, increment total number of stacks
     */
    InsertTailList(IcaNextStack, &pStack->StackNode);
    IcaTotalNumOfStacks++;

    /*
     * Unlock the stack list now
     */
    IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

    /*
     * Save a pointer to the stack in the file object
     * so that we can find it in future calls.
     */
    IrpSp->FileObject->FsContext = pStack;

    IcaDereferenceStack( pStack );

    TRACE(( pConnect, TC_ICADD, TT_API1, "TermDD: IcaCreateStack, success\n" ));
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaDeviceControlStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PICA_CONNECTION pConnect;
    PICA_TRACE_BUFFER pTraceBuffer;
    PICA_STACK_RECONNECT pStackReconnect;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    ULONG code;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    BYTE *Buffer = NULL;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

#if DBG
    if ( code != IOCTL_ICA_STACK_TRACE ) {
        IcaLockStack( pStack );
        TRACESTACK(( pStack, TC_ICADD, TT_API2, "TermDD: IcaDeviceControlStack, fc %d (enter)\n",
                     (code & 0x3fff) >> 2 ));
        IcaUnlockStack( pStack );
    }
#endif

    try {
        switch ( code ) {

            case IOCTL_ICA_STACK_PUSH :
            {
                ICA_STACK_PUSH StackPush;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_PUSH) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_PUSH),
                                  sizeof(BYTE) );
                }

                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }

                memcpy(&StackPush, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_PUSH));

                Status = _IcaPushStack( pStack, &StackPush );
                break;
            }
            case IOCTL_ICA_STACK_POP :
                IcaLockConnectionForStack( pStack );
                Status = _IcaPopStack( pStack );
                IcaUnlockConnectionForStack( pStack );
                break;

            case IOCTL_ICA_STACK_QUERY_STATUS :
                if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(pStack->ProtocolStatus) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   sizeof(pStack->ProtocolStatus),
                                   sizeof(BYTE) );
                }

                RtlCopyMemory( Irp->UserBuffer,
                               &pStack->ProtocolStatus,
                               sizeof(pStack->ProtocolStatus) );
                Irp->IoStatus.Information = sizeof(pStack->ProtocolStatus);
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_STACK_QUERY_CLIENT :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_AUTORECONNECT :
                if ( Irp->RequestorMode != KernelMode ) {

                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );

                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }
    
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_MODULE_DATA :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }
                
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                /* this is so IoStatus.Information gets returned to the caller */
                if (Status == STATUS_BUFFER_TOO_SMALL)
                    Status = STATUS_BUFFER_OVERFLOW;
                
                break;

            case IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME :
                if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ICA_STACK_LAST_INPUT_TIME) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   sizeof(ICA_STACK_LAST_INPUT_TIME),
                                   sizeof(BYTE) );
                }

                ((PICA_STACK_LAST_INPUT_TIME)Irp->UserBuffer)->LastInputTime = pStack->LastInputTime;
                Irp->IoStatus.Information = sizeof(ICA_STACK_LAST_INPUT_TIME);
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_STACK_TRACE :
            {
           
                unsigned DataLen = 0;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0]) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) )
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                pTraceBuffer = (PICA_TRACE_BUFFER)Buffer;

                // Make sure the trace buffer is NULL terminated
                DataLen = IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET(ICA_TRACE_BUFFER, Data);
                if (pTraceBuffer->Data[DataLen - 1] == 0) {
                    pConnect = IcaLockConnectionForStack( pStack );
                    IcaTraceFormat( &pConnect->TraceInfo,
                                    pTraceBuffer->TraceClass,
                                    pTraceBuffer->TraceEnable,
                                    pTraceBuffer->Data );
                    IcaUnlockConnectionForStack( pStack );
                    Status = STATUS_SUCCESS;
                }
                else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }

                break;
            }

            case IOCTL_ICA_STACK_REGISTER_BROKEN :
            {
                ICA_STACK_BROKEN BrokenEvent;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_BROKEN) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_BROKEN),
                                  sizeof(BYTE) );
                }

                memcpy(&BrokenEvent, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_BROKEN));

                Status = _RegisterBrokenEvent( pStack,
                                               &BrokenEvent );
                break;
            }

            case IOCTL_ICA_STACK_ENABLE_IO :
                pStack->fIoDisabled = FALSE;
                /* If enabling the passthru stack, then enable passthru mode */
                if ( pStack->StackClass == Stack_Passthru ) {
                    Status = _EnablePassthru( pStack );
                } else {
                    Status = STATUS_SUCCESS;
                }
                break;

            case IOCTL_ICA_STACK_DISABLE_IO :
                pStack->fIoDisabled = TRUE;
                /* If disabling the passthru stack, then disable passthru mode */
                if ( pStack->StackClass == Stack_Passthru ) {

                    Status = _DisablePassthru( pStack );

                    IcaLockStack( pStack );
                    // Now wait for any input still in progress to end.
                    if ( pStack->fDoingInput ) {
                        NTSTATUS WaitStatus;

                        pStack->fDisablingIo = TRUE;
                        KeClearEvent( &pStack->IoEndEvent );
                        IcaUnlockStack( pStack );

                        //
                        // Convert the timeout to a relative system time value and wait.
                        //
                        WaitTimeout = RtlEnlargedIntegerMultiply( 60000, -10000 );
                        pWaitTimeout = &WaitTimeout;

                        WaitStatus = KeWaitForSingleObject( &pStack->IoEndEvent,
                                        UserRequest, UserMode, FALSE, pWaitTimeout );

#if DBG
                        if ( WaitStatus != STATUS_SUCCESS ) {
                            DbgPrint("TermDD: IOCTL_ICA_STACK_DISABLE_IO: WaitStatus=%x\n", WaitStatus);
                            ASSERT(WaitStatus == STATUS_SUCCESS);
                        }
#endif

                        IcaLockStack( pStack );

                        pStack->fDisablingIo = FALSE;
                    }
                    IcaUnlockStack( pStack );

                } else {
                    Status = STATUS_SUCCESS;
                }
                break;

            case IOCTL_ICA_STACK_DISCONNECT :
            {
                HANDLE hIca;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_RECONNECT) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_RECONNECT),
                                  sizeof(BYTE) );
                }
                pStackReconnect = (PICA_STACK_RECONNECT)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                hIca = pStackReconnect->hIca;

                /*
                 * Notify stack drivers of disconnect
                 */
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;
                (void)_IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

                /*
                 * Disconnect stack
                 */
                Status = _ReconnectStack( pStack, hIca );
                break;
            }

            case IOCTL_ICA_STACK_RECONNECT :
            {
                ICA_STACK_RECONNECT StackReconnect;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_RECONNECT) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_RECONNECT),
                                  sizeof(BYTE) );
                }

                /*
                 * Reconnect stack
                 */
                memcpy(&StackReconnect, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_RECONNECT));

                Status = _ReconnectStack( pStack, StackReconnect.hIca );

                /*
                 * Notify stack drivers of reconnect
                 */
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = &StackReconnect;
                SdIoctl.InputBufferLength = sizeof(ICA_STACK_RECONNECT);
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;
                (void)_IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

                break;
            }

            case IOCTL_ICA_STACK_WAIT_FOR_ICA:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                if ( NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: Binding vchannels\n"));
                    Status = IcaBindVirtualChannels( pStack );
                }

                break;

            case IOCTL_ICA_STACK_CONSOLE_CONNECT:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: console connect\n"));
                if ( NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: Binding vchannels\n"));
                    Status = IcaBindVirtualChannels( pStack );
                }

                break;

            case IOCTL_ICA_STACK_CANCEL_IO :
                pStack->fClosing = TRUE;
                /* fall through */


            default:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                /* initialize virtual channel name bindings */
                if ( NT_SUCCESS(Status) && (code == IOCTL_ICA_STACK_CONNECTION_QUERY) ) {
                    Status = IcaBindVirtualChannels( pStack );
                    if ( Status == STATUS_SUCCESS ) {

                        ICA_STACK_QUERY_BUFFER icaSQB;
                        NTSTATUS QueryStatus;

                        SdIoctl.IoControlCode =  IOCTL_ICA_STACK_QUERY_BUFFER;
                        SdIoctl.InputBuffer = NULL;
                        SdIoctl.InputBufferLength = 0;
                        SdIoctl.OutputBuffer = &icaSQB;
                        SdIoctl.OutputBufferLength = sizeof(icaSQB);
                        QueryStatus = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                        if ( NT_SUCCESS(QueryStatus) ) {
                            pStack->OutBufCount  = icaSQB.WdBufferCount;
                            pStack->OutBufLength = icaSQB.TdBufferSize;
                        }
                    }
                }

                /* this is so IoStatus.Information gets returned to the caller */
                if ( Status == STATUS_BUFFER_TOO_SMALL )
                    Status = STATUS_BUFFER_OVERFLOW;
                break;
        }
    } except( IcaExceptionFilter( L"IcaDeviceControlStack TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        
        Status = GetExceptionCode();
    }

    if (Buffer) {
        ICA_FREE_POOL(Buffer);
        Buffer = NULL;
    }

#if DBG
    if ( code != IOCTL_ICA_STACK_TRACE ) {
        IcaLockStack( pStack );
        TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlStack, fc %d, 0x%x\n",
                     (code & 0x3fff) >> 2, Status ));
        IcaUnlockStack( pStack );
    }
#endif
    return( Status );
}


NTSTATUS
IcaCleanupStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaCloseStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    SD_IOCTL SdIoctl;
    PICA_CONNECTION pConnect;
    KIRQL OldIrql;

#if DBG
    IcaLockStack( pStack );
    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaCloseStack (enter)\n" ));
    IcaUnlockStack( pStack );
#endif

    /*
     * If passthru mode is enabled, disable it now.
     */
    if ( pStack->pPassthru ) {
        _DisablePassthru( pStack );
    }

    /*
     *  Send cancel i/o to stack drivers
     */
    SdIoctl.IoControlCode = IOCTL_ICA_STACK_CANCEL_IO;
    (void) _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

    /*
     * Make sure all Stack Drivers are unloaded.
     */
    pConnect = IcaLockConnectionForStack( pStack );
    while ( _IcaPopStack( pStack ) == STATUS_SUCCESS )
        ;
    IcaUnlockConnection( pConnect );

    /*
     * Dereference the broken event if we have one
     */
    if ( pStack->pBrokenEventObject ) {
        KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
        ObDereferenceObject( pStack->pBrokenEventObject );
        pStack->pBrokenEventObject = NULL;
    }

    /*
     * If closing the primary stack, unbind the virtual channels.
     * Unlink this stack from the stack list for this connection.
     */
    pConnect = IcaLockConnectionForStack( pStack );
    if ( pStack->StackClass == Stack_Primary || pStack->StackClass == Stack_Console ) {
        IcaUnbindVirtualChannels( pConnect );
        IcaFreeAllVcBind( pConnect );
    }
    RemoveEntryList( &pStack->StackEntry );
    IcaUnlockConnection( pConnect );

    /*
     * Lock the stack list for update
     */
    IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

    /*
     * Remove the stack from the stack list. Before doing so, check if IcaNextStack
     * is pointing to this stack, if so, move IcaNextStack to the next stack
     * in the list.  Also, decrement total number of stacks
     */
    if (&pStack->StackNode == IcaNextStack) {
        IcaNextStack = pStack->StackNode.Flink;
    }
    RemoveEntryList(&pStack->StackNode);

    if (IcaTotalNumOfStacks != 0) {
        IcaTotalNumOfStacks--;
    }

    /*
     * Unlock the stack list now
     */
    IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

    /*
     * Remove the file object reference for this stack.
     * This will cause the stack to be deleted when all other
     * references are gone.
     */
    IcaDereferenceStack( pStack );

    return( STATUS_SUCCESS );
}


VOID
IcaReferenceStack(
    IN PICA_STACK pStack
    )
{

    ASSERT( pStack->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pStack->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceStack(
    IN PICA_STACK pStack
    )
{

    ASSERT( pStack->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, free the stack.
     */
    if ( InterlockedDecrement( &pStack->RefCount) == 0 ) {
        _IcaFreeStack( pStack );
    }
}


PICA_CONNECTION
IcaGetConnectionForStack(
    IN PICA_STACK pStack
    )
{

    /*
     * As long as the stack object is locked, it's safe for us
     * to pick up the pConnect pointer and return it.
     * WARNING: Once the caller unlocks the stack object, the pointer
     *          returned below must not be referenced anymore and may
     *          no longer be valid.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    return( (PICA_CONNECTION)pStack->pConnect );
}


PICA_CONNECTION
IcaLockConnectionForStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;

    /*
     * Acquire the Reconnect resource lock so that the pConnect
     * pointer cannot change before we get the connection locked.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite( IcaReconnectResource, TRUE );
    pConnect = (PICA_CONNECTION)pStack->pConnect;
    IcaLockConnection( pConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();

    return( pConnect );
}


VOID
IcaUnlockConnectionForStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;

    /*
     * As long as the connection object is locked, it's safe for us
     * to pick up the pConnect pointer from the stack and use it.
     */
    pConnect = (PICA_CONNECTION)pStack->pConnect;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    IcaUnlockConnection( pConnect );
}


/*******************************************************************************
 *
 *  IcaCallDriver
 *
 *    Call the topmost stack driver
 *
 *    This is the main interface routine that all channels use
 *    to call the stack driver(s).
 *
 * ENTRY:
 *    pChannel (input)
 *       pointer to channel object this call is from
 *    ProcIndex (input)
 *       index of driver proc to call
 *    pParms (input)
 *       pointer to driver parms
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaCallDriver(
    IN PICA_CHANNEL pChannel,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API4, "TermDD: IcaCallDriver, ProcIndex=%u (enter)\n", ProcIndex ));

    // Open/Close should never be called from a channel!
    ASSERT( ProcIndex != SD$OPEN && ProcIndex != SD$CLOSE );

    /*
     * Lock the connection object.
     * This will serialize all channel calls for this connection.
     */
    IcaLockConnection( pChannel->pConnect );

    /*
     * Send this call down to the stack(s).
     * If Passthru mode is enabled, then we bit bucket all channel I/O.
     * However if this channel is flagged as shadow persistent, let
     * the data go through.
     */
    if ( !pChannel->pConnect->fPassthruEnabled ||
         (pChannel->Flags & CHANNEL_SHADOW_PERSISTENT) ) {

        Head = &pChannel->pConnect->StackHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

            /*
             * If I/O is disabled for this stack, or if this is a
             * shadow stack and this call is from a channel that does
             * not process shadow I/O, or if it's a PassThru stack
             * and the channel is shadow persistent, then skip this stack.
             */
            if ( !(pStack->fIoDisabled ||
                 pStack->StackClass == Stack_Shadow &&
                 !(pChannel->Flags & CHANNEL_SHADOW_IO) ||
                 (pChannel->pConnect->fPassthruEnabled && 
                  pStack->StackClass == Stack_Passthru)) ) {
                Status = _IcaCallStack( pStack, ProcIndex, pParms );
            }
        }
    }

    /*
     * Unlock the connection object now.
     */
    IcaUnlockConnection( pChannel->pConnect );

    return( Status );
}


NTSTATUS
IcaCallNextDriver(
    IN PSDCONTEXT pContext,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    ASSERT( ProcIndex != SD$OPEN && ProcIndex != SD$CLOSE );

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API4, "TermDD: IcaCallNextDriver, ProcIndex=%u (enter)\n", ProcIndex ));

    /*
     * Call the next driver if there is one
     */
    if ( (pSdLink = IcaGetNextSdLink( pSdLink )) == NULL )
        return( STATUS_INVALID_PARAMETER );

    ASSERT( pSdLink->pStack == pStack );

    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    return( Status );
}


NTSTATUS
IcaRawInput (
    IN PSDCONTEXT pContext,
    IN PINBUF pInBuf OPTIONAL,
    IN PUCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This is the input (stack callup) routine for ICA raw input.

Arguments:

    pContext - Pointer to SDCONTEXT for this Stack Driver

    pInBuf - Pointer to INBUF containing data

    pBuffer - Pointer to input data

        NOTE: Either pInBuf OR pBuffer must be specified, but not both.

    ByteCount - length of data in pBuffer

Return Value:

    NTSTATUS -- Indicates whether the request was handled successfully.

--*/

{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the stack object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;   // save stack pointer for use below
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pStack, TC_ICADD, TT_API2, "TermDD: IcaRawInput, bc=%u (enter)\n", ByteCount ));

    /*
     * Only the stack object should be locked during input.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );
    ASSERT( (pConnect = IcaGetConnectionForStack( pStack )) &&
            !ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a RawInput callup routine.  If we find one, then call the
     * driver RawInput routine to let it handle the call.
     */
    while ( (pSdLink = IcaGetPreviousSdLink( pSdLink )) != NULL ) {
        ASSERT( pSdLink->pStack == pStack );
        if ( pSdLink->SdContext.pCallup->pSdRawInput ) {
            IcaReferenceSdLink( pSdLink );
            Status = (pSdLink->SdContext.pCallup->pSdRawInput)(
                        pSdLink->SdContext.pContext,
                        pInBuf,
                        pBuffer,
                        ByteCount );
            IcaDereferenceSdLink( pSdLink );
            return( Status );
        }
    }

    return( IcaRawInputInternal( pStack, pInBuf, pBuffer, ByteCount ) );
}


NTSTATUS
IcaRawInputInternal(
    IN PICA_STACK pStack,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    )
{
    SD_RAWWRITE SdRawWrite;
    NTSTATUS Status;

    /*
     * See if passthru mode is enabled.
     * If so, then we simply turn around and write the input data
     * directly to the passthru stack.
     */
    if ( pStack->pPassthru ) {
        PICA_STACK pPassthru;

        if ( pInBuf ) {
            SdRawWrite.pOutBuf = NULL;
            SdRawWrite.pBuffer = pInBuf->pBuffer;
            SdRawWrite.ByteCount = pInBuf->ByteCount;
        } else {
            SdRawWrite.pOutBuf = NULL;
            SdRawWrite.pBuffer = pBuffer;
            SdRawWrite.ByteCount = ByteCount;
        }

        // Grab a copy of pPassthru onto our local stack before we release
        // the local stack lock. This has been a problem (NT bug #328433)
        // where we release the local stack lock and pStack->pPassthru
        // becomes NULL in _DisablePassthru() before we take out the
        // passthrough stack lock inside of _IcaCallStack().
        pPassthru = pStack->pPassthru;

        // If data are being forwarded to the passthru, make
        // sure it's fully initialized. If not, drop the data.
        if((pPassthru->StackClass == Stack_Passthru) &&
            pPassthru->fIoDisabled) {
            return( STATUS_SUCCESS );
        }

        // Take a reference on the passthrough stack to make sure it does
        // not go away before we get to it in the call below.
        IcaReferenceStack(pPassthru);

        // Unlock our current stack while in call to passthrough stack.
        pStack->fDoingInput = TRUE;
        IcaUnlockStack(pStack);
        Status = _IcaCallStack(pPassthru, SD$RAWWRITE, &SdRawWrite);
        IcaLockStack(pStack);

        if ( pStack->fDisablingIo ) {
            KeSetEvent( &pStack->IoEndEvent, 0, FALSE );
        }

        pStack->fDoingInput = FALSE;

        // Mirror the refrence above.
        IcaDereferenceStack(pPassthru);

    /*
     * Passthru is not enabled.
     * We have no choice but to drop the input data.
     */
    } else {
        Status = STATUS_SUCCESS;
    }

    return( Status );
}


NTSTATUS
IcaSleep(
    IN PSDCONTEXT pContext,
    IN ULONG Duration
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaSleep %d msec (enter)\n", Duration ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the sleep duration to a relative system time value and sleep.
     */
    SleepTime = RtlEnlargedIntegerMultiply( Duration, -10000 );
    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: Sleep, ERROR 0x%x\n", Status ));
    }
#endif

    return( Status );
}


NTSTATUS
IcaWaitForSingleObject(
    IN PSDCONTEXT pContext,
    IN PVOID pObject,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API2, "TermDD: IcaWaitForSingleObject, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForSingleObject( pObject, UserRequest, UserMode, FALSE,
                                    pWaitTimeout );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


/*
 * Same as IcaSleep() except it is assumed that the connection lock is
 * held.  This is used by the VD flow control routines.
 */
NTSTATUS
IcaFlowControlSleep(
    IN PSDCONTEXT pContext,
    IN ULONG Duration
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaSleep %d msec (enter)\n", Duration ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Unlock the connection lock
     */
    IcaUnlockConnectionForStack( pSdLink->pStack );

    /*
     * Convert the sleep duration to a relative system time value and sleep.
     */
    SleepTime = RtlEnlargedIntegerMultiply( Duration, -10000 );
    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );

    /*
     * Relock the connection lock
     */
    IcaLockConnectionForStack( pSdLink->pStack );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: Sleep, ERROR 0x%x\n", Status ));
    }
#endif

    return( Status );
}


/*
 * Same as IcaWaitForSingleObject() except it is assumed that the connection lock is
 * held.  This is used by the VD flow control routines.
 */
NTSTATUS
IcaFlowControlWait(
    IN PSDCONTEXT pContext,
    IN PVOID pObject,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API2, "TermDD: IcaWaitForSingleObject, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Unlock the connection lock
     */
    IcaUnlockConnectionForStack( pSdLink->pStack );

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForSingleObject( pObject, UserRequest, KernelMode, TRUE,
                                    pWaitTimeout );

    /*
     * Relock the connection lock
     */
    IcaLockConnectionForStack( pSdLink->pStack );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


NTSTATUS
IcaWaitForMultipleObjects(
    IN PSDCONTEXT pContext,
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForMultipleObjects( Count, Object, WaitType, UserRequest,
                                       KernelMode, TRUE, pWaitTimeout, NULL );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


NTSTATUS
IcaLogError(
    IN PSDCONTEXT pContext,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    )
{
    return( _LogError( IcaDeviceObject, Status, pArgStrings, ArgStringCount, pRawData, RawDataLength ) );
}

NTSTATUS
_LogError(
    IN PDEVICE_OBJECT pDeviceObject,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    )
{
    LPWSTR *TmpPtr;
    PUCHAR ptrToString;
    ULONG Tmp, StringSize, TotalStringSize;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    // Get the bytes needed for strings storage
    Tmp = ArgStringCount;
    TmpPtr = pArgStrings;
    TotalStringSize = 0;

    while( Tmp ) {

        TotalStringSize += ((wcslen(*TmpPtr)+1)*sizeof(WCHAR));
        Tmp--;
        TmpPtr++;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        pDeviceObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                RawDataLength +
                                TotalStringSize)
                        );

    if ( errorLogEntry != NULL ) {

        errorLogEntry->ErrorCode = Status;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = Status;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLength;

        // Copy raw data
        if (RawDataLength) {

            RtlCopyMemory(
                &errorLogEntry->DumpData[0],
                pRawData,
                RawDataLength
                );

            ptrToString =
                ((PUCHAR)&errorLogEntry->DumpData[0])+RawDataLength;

        } else {
            ptrToString = (PUCHAR)&errorLogEntry->DumpData[0];
        }

        // round up to next word boundary
        // it's ok to add 1 byte because we allocated more bytes than we needed:
        // the number of extra bytes is the size of DumpData which is ULONG.
        ptrToString = (PUCHAR)((ULONG_PTR)(ptrToString + sizeof(WCHAR) - 1) & ~(ULONG_PTR)(sizeof(WCHAR) - 1));

        // Copy strings following raw data
        errorLogEntry->NumberOfStrings = (USHORT)ArgStringCount;

        if( ArgStringCount ) {
            errorLogEntry->StringOffset = (USHORT)(ptrToString -
                                                (PUCHAR)errorLogEntry);
        }
        else {
            errorLogEntry->StringOffset = 0;
        }

        while( ArgStringCount ) {

            StringSize = (wcslen(*pArgStrings)+1)*sizeof(WCHAR);

            RtlCopyMemory(
                ptrToString,
                *pArgStrings,
                StringSize
            );

            ptrToString += StringSize;
            ArgStringCount--;
            pArgStrings++;

        }

        IoWriteErrorLogEntry(errorLogEntry);
        return STATUS_SUCCESS;
    }
    else {
        return STATUS_NO_MEMORY;
    }
}

#define KEEP_ALIVE_MIN_INTERVAL  50000000     // 5 sec in terms of 100 nanosecs

VOID
IcaCheckStackAlive( )
{
    NTSTATUS status;
    KIRQL OldIrql;
    PICA_STACK pStack;
    SD_IOCTL SdIoctl;
    LARGE_INTEGER SleepTime;
    LARGE_INTEGER CurrentTime;
    LONGLONG    KeepAliveInterval;

    while (TRUE) {
        KeepAliveInterval = g_KeepAliveInterval * 600000000 ;   // in 100 nanosecs
        pStack = NULL;

        // Lock the stack list for reading
        IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

        //KdPrint(("Total number of stacks: %d\n", IcaTotalNumOfStacks));

        // determine new sleep time for the keepalive thread
        // it is the keepalive interval for a stack divided by total
        // number of stacks
        // the low threshold for sleep time is 5 sec.  Since relative
        // sleeptime is a negative value, we use min instead of max
        if (IcaTotalNumOfStacks > 1) {
            SleepTime.QuadPart = min(0 - KEEP_ALIVE_MIN_INTERVAL,
                    0 - (KeepAliveInterval / IcaTotalNumOfStacks));
        }
        else {
            SleepTime.QuadPart = min(0 - KEEP_ALIVE_MIN_INTERVAL,
                    0 - KeepAliveInterval);
        }

        // If the stack list is not empty, get the stack for keepalive
        // checking and move the IcaNextStack pointer to the next stack
        if (IcaNextStack != &IcaStackListHead) {
            pStack = CONTAINING_RECORD(IcaNextStack, ICA_STACK, StackNode);

            // Reference the stack so that the stack won't be deleted while we
            // are accessing it
            IcaReferenceStack(pStack);

            IcaNextStack = IcaNextStack->Flink;
        }
        else {
            if (IcaNextStack->Flink != &IcaStackListHead) {
                pStack = CONTAINING_RECORD(IcaNextStack->Flink, ICA_STACK, StackNode);

                // Reference the stack so that the stack won't be deleted while we
                // are accessing it
                IcaReferenceStack(pStack);

                IcaNextStack = IcaNextStack->Flink->Flink;
            }
        }

        // Unlock the stack list now
        IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

        // If the stack pointer is invalid or LastInputTime on the stack is 0,
        // the stack is not in the active state, so we don't need to send
        // keepalive pkt on that stack.
        if (pStack != NULL && pStack->LastInputTime.QuadPart != 0) {
            // Get the current system time
            KeQuerySystemTime(&CurrentTime);

            // Check if it is time to send a keepalive packet depends on
            // the keepalive timestamp and lastinput timestamp
            if (CurrentTime.QuadPart - pStack->LastKeepAliveTime.QuadPart >= KeepAliveInterval &&
                    CurrentTime.QuadPart - pStack->LastInputTime.QuadPart >= KeepAliveInterval) {

                // Initialize the IOCTL struct
                SdIoctl.IoControlCode = IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;

                //KdPrint(("In IcaCheckStackAlive: To call WD, pStack=%p\n", pStack));

                // Send an IOCTL to the stack requesting to send a keepalive packet
                _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);

                // Update the LastKeepAlive timestamp for the stack
                KeQuerySystemTime(&pStack->LastKeepAliveTime);
            }
#if DBG
            else {
                if (CurrentTime.QuadPart - pStack->LastKeepAliveTime.QuadPart < KeepAliveInterval) {
                    //KdPrint(("Not time to do keep alive yet, pstack=%p\n", pStack));
                }
                if (CurrentTime.QuadPart - pStack->LastInputTime.QuadPart < KeepAliveInterval) {
                    //KdPrint(("- Last Input Time is less than KeepAliveInterval, pstack=%p\n", pStack));
                }
            }
#endif
        }
#if DBG
        else{
            if (pStack != NULL) {
                //KdPrint(("No need to send KeepAlive PDU on pstack=%p\n", pStack));
            }
        }
#endif
        // Decrement the reference to the stack so that it can be deleted
        if (pStack != NULL) {
            IcaDereferenceStack(pStack);
        }

        // Start sleep timer again
        // We would return if the unload module signal the IcaKeepAliveEvent
        // to stop this keepalive thread
        status = KeWaitForSingleObject(pIcaKeepAliveEvent, Executive, KernelMode, TRUE, &SleepTime);

        if (status == STATUS_SUCCESS) {
            return;
        }
    }
}


VOID
IcaKeepAliveThread(
    IN PVOID pData)
{
    IcaCheckStackAlive();
}

#ifdef notdef
VOID
IcaAcquireIoLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaLockConnectionForStack( pSdLink->pStack );
}


VOID
IcaReleaseIoLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaUnlockConnectionForStack( pSdLink->pStack );
}


VOID
IcaAcquireDriverLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaLockStack( pSdLink->pStack );
}


VOID
IcaReleaseDriverLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaUnlockStack( pSdLink->pStack );
}


VOID
IcaIncrementDriverReference(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaReferenceSdLink( pSdLink );
}


VOID
IcaDecrementDriverReference(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaDereferenceSdLink( pSdLink );
}
#endif


typedef NTSTATUS (*PTHREAD_ROUTINE) ( PVOID );

typedef struct _ICACREATETHREADINFO {
    PTHREAD_ROUTINE pProc;
    PVOID pParm;
    PSDLINK pSdLink;
    ULONG LockFlags;
} ICACREATETHREADINFO, *PICACREATETHREADINFO;


NTSTATUS
IcaCreateThread(
    IN PSDCONTEXT pContext,
    IN PVOID pProc,
    IN PVOID pParm,
    IN ULONG LockFlags,
    OUT PHANDLE pThreadHandle
    )
{
    PSDLINK pSdLink;
    PICACREATETHREADINFO pThreadInfo;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaCreateThread (enter)\n" ));

    pThreadInfo = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pThreadInfo) );
    if ( pThreadInfo == NULL )
        return( STATUS_NO_MEMORY );

    pThreadInfo->pProc = pProc;
    pThreadInfo->pParm = pParm;
    pThreadInfo->pSdLink = pSdLink;
    pThreadInfo->LockFlags = LockFlags;

    /*
     * Reference the SDLINK object on behalf of the new thread.
     */
    IcaReferenceSdLink( pSdLink );

    Status = PsCreateSystemThread( pThreadHandle,
                                   THREAD_ALL_ACCESS,
                                   NULL,
                                   NtCurrentProcess(),
                                   NULL,
                                   _IcaDriverThread,
                                   (PVOID) pThreadInfo );
    if ( !NT_SUCCESS( Status ) ) {
        IcaDereferenceSdLink( pSdLink );
        ICA_FREE_POOL( pThreadInfo );
        return( Status );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
_IcaDriverThread(
    IN PVOID pData
    )
{
    PICACREATETHREADINFO pThreadInfo = (PICACREATETHREADINFO)pData;
    PTHREAD_ROUTINE pProc;
    PVOID pParm;
    PSDLINK pSdLink;
    PICA_STACK pStack;
    ULONG LockFlags;
    NTSTATUS Status;

    pProc = pThreadInfo->pProc;
    pParm = pThreadInfo->pParm;
    pSdLink = pThreadInfo->pSdLink;
    LockFlags = pThreadInfo->LockFlags;
    ICA_FREE_POOL( pThreadInfo );
    pStack = pSdLink->pStack;

    /*
     * Obtain any required locks before calling the worker routine.
     */
    ASSERT( !(LockFlags & ICALOCK_IO) );
    if ( LockFlags & ICALOCK_DRIVER )
        IcaLockStack( pStack );

    /*
     * Call the thread routine
     */
#if DBG
    try {
#endif
        /*
         * If stack is being closed, then indicate this to caller.
         */
        if ( !pStack->fClosing )
            Status = (pProc)( pParm );
        else
            Status = STATUS_CTX_CLOSE_PENDING;
#if DBG
    } except( IcaExceptionFilter( L"_IcaDriverThread TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }
#endif

    /*
     * Release any locks acquired above.
     */
    if ( LockFlags & ICALOCK_DRIVER )
        IcaUnlockStack( pStack );

    /*
     * Dereference the SDLINK object now.
     * This undoes the reference that was made on our behalf in
     * the IcaCreateThread routine when this thread was created.
     */
    IcaDereferenceSdLink( pSdLink );

    return( Status );
}

PICA_STACK
_IcaAllocateStack( VOID )
{
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     *  Allocate and initialize stack structure
     */
    pStack = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pStack) );
    if ( pStack == NULL )
        return NULL;
    RtlZeroMemory( pStack, sizeof(*pStack) );

    /*
     * Initialize the reference count to 2,
     * one for the caller's reference, one for the file object reference.
     */
    pStack->RefCount = 2;

    /*
     * Initialize the rest of the stack object
     */
    pStack->Header.Type = IcaType_Stack;
    pStack->Header.pDispatchTable = IcaStackDispatchTable;
    ExInitializeResourceLite( &pStack->Resource );
    InitializeListHead( &pStack->SdLinkHead );
    KeInitializeEvent( &pStack->OutBufEvent, NotificationEvent, FALSE );
    KeInitializeEvent( &pStack->IoEndEvent, NotificationEvent, FALSE );

    return( pStack );
}


VOID
_IcaFreeStack( PICA_STACK pStack )
{
    PICA_CONNECTION pConnect;

    ASSERT( pStack->RefCount == 0 );
    ASSERT( IsListEmpty( &pStack->SdLinkHead ) );
    ASSERT( !ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    /*
     * Remove the reference to the Connection object for this stack.
     */
    pConnect = (PICA_CONNECTION)pStack->pConnect;
    IcaDereferenceConnection( pConnect );

    ExDeleteResourceLite( &pStack->Resource );

    ICA_FREE_POOL( pStack );
}


NTSTATUS
_IcaPushStack(
    IN PICA_STACK pStack,
    IN PICA_STACK_PUSH pStackPush
    )
{
    PSD_OPEN pSdOpen = NULL;
    PSDLINK pSdLink;
    NTSTATUS Status;

    if ( g_TermServProcessID == NULL)
    {
        g_TermServProcessID = IoGetCurrentProcess();
    }

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );

    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: _IcaPushStack, type %u, name %S (enter)\n",
                 pStackPush->StackModuleType, pStackPush->StackModuleName ));

    /*
     * If stack is being closed, then indicate this to caller
     */
    if ( pStack->fClosing ) {
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }

    pSdOpen = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(SD_OPEN) );
    if ( pSdOpen == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    /*
     * Load an instance of the requested stack driver
     */
    Status = _IcaLoadSd( pStackPush->StackModuleName, &pSdLink );
    if ( !NT_SUCCESS( Status ) )
        goto done;

    /*
     * If this is the first stack driver loaded, then initialize
     * some of the stack data from the ICA_STACK_PUSH parameters.
     * NOTE: Since we're testing for an empty list we must make
     *       this check before the InsertHeadList below.
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        pStack->OutBufLength = pStackPush->PdConfig.Create.OutBufLength;
        pStack->OutBufCount = pStackPush->PdConfig.Create.OutBufCount;
        
        
        //
        //Set the low water mark using the PD config
        //
        if ( !(pStackPush->PdConfig.Create.PdFlag & PD_NOLOW_WATERMARK) ) {
            //
            //set to default
            //
            pStack->OutBufLowWaterMark = (pStackPush->PdConfig.Create.OutBufCount/ 3) + 1;
        }
        else {
            pStack->OutBufLowWaterMark = MAX_LOW_WATERMARK;
        }
    }

    /*
     * Increment the stack ref count for this SD,
     * and push the new SD on the stack.
     */
    IcaReferenceStack( pStack );
    InsertHeadList( &pStack->SdLinkHead, &pSdLink->Links );
    pSdLink->pStack = pStack;

    /*
     * Initialize the SD open parameters
     */
    pSdOpen->StackClass        = pStack->StackClass;
    pSdOpen->pStatus           = &pStack->ProtocolStatus;
    pSdOpen->pClient           = &pStack->ClientModules;
    pSdOpen->WdConfig          = pStackPush->WdConfig;
    pSdOpen->PdConfig          = pStackPush->PdConfig;
    pSdOpen->OutBufHeader      = pStack->SdOutBufHeader;
    pSdOpen->OutBufTrailer     = pStack->SdOutBufTrailer;
    pSdOpen->DeviceObject      = pSdLink->pSdLoad->DeviceObject;

    RtlCopyMemory( pSdOpen->OEMId, pStackPush->OEMId, sizeof(pSdOpen->OEMId) );
    RtlCopyMemory( pSdOpen->WinStationRegName, pStackPush->WinStationRegName,
                   sizeof(pSdOpen->WinStationRegName) );

    /*
     * Call the SD open procedure
     */
    Status = _IcaCallSd( pSdLink, SD$OPEN, pSdOpen );
    if ( !NT_SUCCESS( Status ) ) {
        RemoveEntryList( &pSdLink->Links );
        pSdLink->Links.Flink = pSdLink->Links.Blink = NULL;
        IcaDereferenceSdLink( pSdLink );
        goto done;
    }

    /*
     *  Increment number of reserved output buffer bytes
     */
    pStack->SdOutBufHeader  += pSdOpen->SdOutBufHeader;
    pStack->SdOutBufTrailer += pSdOpen->SdOutBufTrailer;

done:
    if ( pSdOpen ) {
        ICA_FREE_POOL( pSdOpen );
    }

    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaPopStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;
    SD_CLOSE SdClose;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );
    

    ASSERT( (pConnect = IcaGetConnectionForStack( pStack )) &&
            ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * If no SDs remain, then return error
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        Status = STATUS_NO_MORE_ENTRIES;
        goto done;
    }

    /*
     * Call the SD close procedure for the topmost SD
     */
    pSdLink = CONTAINING_RECORD( pStack->SdLinkHead.Flink, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, SD$CLOSE, &SdClose );

    /*
     *  Decrement number of reserved output buffer bytes
     */
    pStack->SdOutBufHeader  -= SdClose.SdOutBufHeader;
    pStack->SdOutBufTrailer -= SdClose.SdOutBufTrailer;

    /*
     * Remove the SdLink from the top of the list,
     * and dereference the SDLINK object.
     */
    RemoveEntryList( &pSdLink->Links );
    pSdLink->Links.Flink = pSdLink->Links.Blink = NULL;
    IcaDereferenceSdLink( pSdLink );

done:
    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    )
{
    PLIST_ENTRY Head;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );

    /*
     * Call the topmost Stack Driver, if there is one
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        IcaUnlockStack( pStack );
        return( STATUS_INVALID_PARAMETER );
    }

    Head = pStack->SdLinkHead.Flink;
    pSdLink = CONTAINING_RECORD( Head, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    )
{
    PLIST_ENTRY Head;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Call the topmost Stack Driver, if there is one
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    Head = pStack->SdLinkHead.Flink;
    pSdLink = CONTAINING_RECORD( Head, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    return( Status );
}


NTSTATUS
_IcaLoadSd(
    IN PDLLNAME SdName,
    OUT PSDLINK *ppSdLink
    )
{
    PSDLINK pSdLink;
    PSDLOAD pSdLoad;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    /*
     * Allocate a SDLINK struct
     */
    pSdLink = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pSdLink) );
    if ( pSdLink == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );
    RtlZeroMemory( pSdLink, sizeof(*pSdLink) );

    /*
     * Initialize reference count
     */
    pSdLink->RefCount = 1;
#if DBG
    ExInitializeResourceLite( &pSdLink->Resource );
#endif

    /*
     * Lock the ICA Resource exclusively to search the SdLoad list.
     * Note when holding a resource we need to prevent APC calls, so
     * use KeEnterCriticalRegion().
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );

    /*
     * Look for the requested SD.  If found, increment the ref count for it.
     */
    Head = &IcaSdLoadListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pSdLoad = CONTAINING_RECORD( Next, SDLOAD, Links );
        if ( !wcscmp( pSdLoad->SdName, SdName ) ) {
            _IcaReferenceSdLoad( pSdLoad );
            break;
        }
    }

    /*
     * If the requested SD was not found, then load it now.
     */
    if ( Next == Head ) {
        Status = _IcaLoadSdWorker( SdName, &pSdLoad );
        if ( !NT_SUCCESS( Status ) ) {
            ExReleaseResourceLite( IcaSdLoadResource );
            KeLeaveCriticalRegion();
#if DBG
            ExDeleteResourceLite( &pSdLink->Resource);
#endif
            ICA_FREE_POOL( pSdLink );
            return( Status );
        }
    }

    ExReleaseResourceLite( IcaSdLoadResource );
    KeLeaveCriticalRegion();

    pSdLink->pSdLoad = pSdLoad;

    /*
     * Call the driver load procedure.
     * The driver will fill in the fields in the SDCONTEXT structure.
     */
    Status = (pSdLoad->DriverLoad)( &pSdLink->SdContext, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );
        _IcaDereferenceSdLoad( pSdLink->pSdLoad );
        ExReleaseResourceLite( IcaSdLoadResource );
        KeLeaveCriticalRegion();
#if DBG
        ExDeleteResourceLite( &pSdLink->Resource );
#endif
        ICA_FREE_POOL( pSdLink );
        return( Status );
    }

    *ppSdLink = pSdLink;

    return( Status );
}


NTSTATUS
_IcaUnloadSd(
    IN PSDLINK pSdLink
    )
{
    KIRQL oldIrql;
    NTSTATUS Status;

    ASSERT( pSdLink->RefCount == 0 );
    ASSERT( pSdLink->Links.Flink == NULL );

    /*
     * Inform driver of unload
     */
    Status = (pSdLink->pSdLoad->DriverLoad)( &pSdLink->SdContext, FALSE );

    /*
     * Decrement ref count on SdLoad object.
     * This will cause it to be unloaded if the ref count goes to 0.
     * Note that while holding a resource we need to disable APC calls,
     * hence the CriticalRegion calls.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );
    _IcaDereferenceSdLoad( pSdLink->pSdLoad );
    ExReleaseResourceLite( IcaSdLoadResource );
    KeLeaveCriticalRegion();

    /*
     * Remove reference this SDLINK object had on the stack.
     */
    IcaDereferenceStack( pSdLink->pStack );

#if DBG
    ExDeleteResourceLite( &pSdLink->Resource );
#endif

    ICA_FREE_POOL( pSdLink );

    return( Status );
}


NTSTATUS
_IcaCallSd(
    IN PSDLINK pSdLink,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PSDPROCEDURE pSdProcedure;
    NTSTATUS Status;

    /*
     * If there is no procedure call table, return success.
     * This should only happen during load/unload and should not be a problem.
     */
    if ( pSdLink->SdContext.pProcedures == NULL )
        return( STATUS_SUCCESS );

    /*
     * Get a pointer to the SD proc based on specified ProcIndex.
     * If NULL, then this ProcIndex is not supported by this driver.
     */
    pSdProcedure = ((PSDPROCEDURE *)pSdLink->SdContext.pProcedures)[ ProcIndex ];
    if ( pSdProcedure == NULL )
        return( STATUS_NOT_SUPPORTED );

    IcaReferenceSdLink( pSdLink );


    Status = (pSdProcedure)( pSdLink->SdContext.pContext, pParms );

    IcaDereferenceSdLink( pSdLink );

    return( Status );
}


VOID
IcaReferenceSdLink(
    IN PSDLINK pSdLink
    )
{

    ASSERT( pSdLink->RefCount >= 0 );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pSdLink->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceSdLink(
    IN PSDLINK pSdLink
    )
{

    ASSERT( pSdLink->RefCount > 0 );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     * Decrement the reference count; if it is 0, unload the SD.
     */
    if ( InterlockedDecrement( &pSdLink->RefCount) == 0 ) {
        _IcaUnloadSd( pSdLink );
    }
}


PSDLINK
IcaGetNextSdLink(
    IN PSDLINK pSdLink
    )
{
    PLIST_ENTRY Next;
    PSDLINK pNextSdLink;

    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( pSdLink->RefCount > 0 || pSdLink->Links.Flink == NULL );
    ASSERT( pSdLink->SdContext.pProcedures );
    ASSERT( pSdLink->SdContext.pContext );

    if ( pSdLink->Links.Flink == NULL )
        return( NULL );

    Next = pSdLink->Links.Flink;
    if ( Next == &pSdLink->pStack->SdLinkHead )
        return( NULL );

    pNextSdLink = CONTAINING_RECORD( Next, SDLINK, Links );
    ASSERT( pNextSdLink->pStack == pSdLink->pStack );
    ASSERT( pNextSdLink->RefCount > 0 );
    ASSERT( pNextSdLink->SdContext.pProcedures );
    ASSERT( pNextSdLink->SdContext.pContext );

    return( pNextSdLink );
}


PSDLINK
IcaGetPreviousSdLink(
    IN PSDLINK pSdLink
    )
{
    PLIST_ENTRY Prev;
    PSDLINK pPrevSdLink;

    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( pSdLink->RefCount > 0 || pSdLink->Links.Flink == NULL );
    ASSERT( pSdLink->SdContext.pProcedures );
    ASSERT( pSdLink->SdContext.pContext );

    if ( pSdLink->Links.Blink == NULL )
        return( NULL );

    Prev = pSdLink->Links.Blink;
    if ( Prev == &pSdLink->pStack->SdLinkHead )
        return( NULL );

    pPrevSdLink = CONTAINING_RECORD( Prev, SDLINK, Links );
    ASSERT( pPrevSdLink->pStack == pSdLink->pStack );
    ASSERT( pPrevSdLink->RefCount > 0 );
    ASSERT( pPrevSdLink->SdContext.pProcedures );
    ASSERT( pPrevSdLink->SdContext.pContext );

    return( pPrevSdLink );
}


VOID
_IcaReferenceSdLoad(
    IN PSDLOAD pSdLoad
    )
{

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );
    ASSERT( pSdLoad->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    ++pSdLoad->RefCount;
    ASSERT( pSdLoad->RefCount > 0 );
}


VOID
_IcaDereferenceSdLoad(
    IN PSDLOAD pSdLoad
    )
{

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );
    ASSERT( pSdLoad->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, unload the SD by queuing
     * a passive level DPC. We must do this to prevent continuing to hold
     * ObpInitKillMutant in the loader -- the driver unload can cause RPC
     * calls which deadlock on that object.
     */
    if ( pSdLoad->RefCount == 1 ) {
        PWORK_QUEUE_ITEM pItem;

        pItem = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (pItem != NULL) {
            ExInitializeWorkItem(pItem, _IcaUnloadSdWorker, pSdLoad);
            pSdLoad->pUnloadWorkItem = pItem;
            ExQueueWorkItem(pItem, DelayedWorkQueue);
        }
        /* If we cannot allocate workitem do not unload here. It is
         * better to temporarly leak one driver than deadlocking the
         * system.
         */
    }else{
        pSdLoad->RefCount--;
    }
}


NTSTATUS IcaExceptionFilter(PWSTR OutputString, PEXCEPTION_POINTERS pexi)
{
    DbgPrint( "TermDD: %S\n", OutputString );
    DbgPrint( "TermDD: ExceptionRecord=%p ContextRecord=%p\n",
              pexi->ExceptionRecord, pexi->ContextRecord );
#ifdef i386
    DbgPrint( "TermDD: Exception code=%08x, flags=%08x, addr=%p, IP=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress,
              pexi->ContextRecord->Eip );

    DbgPrint( "TermDD: esp=%p ebp=%p\n",
              pexi->ContextRecord->Esp, pexi->ContextRecord->Ebp );
#else
    DbgPrint( "TermDD: Exception code=%08x, flags=%08x, addr=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress );
#endif

    {
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
        NTSTATUS Status;

        Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
                &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
        if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
             DbgBreakPoint();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


//
// Helper routine to break if there is a debugger attached
//
//
VOID
IcaBreakOnDebugger( )
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
    NTSTATUS Status;

    Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
            &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
    if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
         DbgBreakPoint();
}


/*******************************************************************************
 *
 *  _RegisterBrokenEvent
 *
 *    Register an event to be signaled when the stack is broken
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to stack structure
 *    pStackBroken (input)
 *       pointer to buffer containing event info
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_RegisterBrokenEvent(
    IN PICA_STACK pStack,
    IN PICA_STACK_BROKEN pStackBroken
    )
{
    NTSTATUS Status;

    /*
     * There should not already be any event registered
     */
    if ( pStack->pBrokenEventObject ) {
        ASSERT( FALSE );
        return( STATUS_OBJECT_NAME_COLLISION );
    }

    /*
     * Reference the event and save a pointer to the object
     */
    Status = ObReferenceObjectByHandle( pStackBroken->BrokenEvent,
                                        0L,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *)&pStack->pBrokenEventObject,
                                        NULL
                                        );

    return( Status );
}


/*******************************************************************************
 *
 *  _EnablePassthru
 *
 *    Enable passthru mode for this connection
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to passthru stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_EnablePassthru( PICA_STACK pStack )
{
    PICA_CONNECTION pConnect;
    PLIST_ENTRY Prev;
    PICA_STACK pPrimaryStack;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ASSERT( pStack->pPassthru != NULL );
    ASSERT( !IsListEmpty( &pStack->StackEntry ) );

    /*
     * Lock connection object and get a pointer to it.
     */
    pConnect = IcaLockConnectionForStack( pStack );

    /*
     * Get pointer to previous stack for this connection.
     * If there is one (i.e. prev does not point to the stack head),
     * then it must be the primary stack which we will connect to.
     */
    Prev = pStack->StackEntry.Blink;
    if ( Prev != &pConnect->StackHead ) {
        pPrimaryStack = CONTAINING_RECORD( Prev, ICA_STACK, StackEntry );
        ASSERT( pPrimaryStack->StackClass == Stack_Primary );

        /*
         * Connect the primary and passthru stacks
         */
        pConnect->fPassthruEnabled = TRUE;
        Status = STATUS_SUCCESS;
    }

    IcaUnlockConnection( pConnect );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _DisablePassthru
 *
 *    Disable passthru mode for this connection
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to passthru stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_DisablePassthru(PICA_STACK pStack)
{
    PICA_CONNECTION pConnect;

    pConnect = IcaLockConnectionForStack(pStack);

    if (pStack->pPassthru) {
        // Lock each stack while clearing the pPassthru pointer.
        // This synchronizes references through the pPassthru pointer
        // within the function IcaRawInputInternal().
        // NOTE: We assume that we have ZERO locks on entry to this function.
        // We then take only one lock at a time so we cannot deadlock.
        IcaLockStack(pStack->pPassthru);
        pStack->pPassthru->pPassthru = NULL;
        IcaUnlockStack(pStack->pPassthru);

        IcaLockStack(pStack);
        pStack->pPassthru = NULL;
        IcaUnlockStack(pStack);

        pConnect->fPassthruEnabled = FALSE;
    }

    IcaUnlockConnection(pConnect);

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *
 *  _ReconnectStack
 *
 *    Reconnect the stack to a new connection object.
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_ReconnectStack(PICA_STACK pStack, HANDLE hIca)
{
    PFILE_OBJECT pNewConnectFileObject;
    PICA_CONNECTION pNewConnect;
    PICA_CONNECTION pOldConnect;
    PLIST_ENTRY pSaveVcBind;
    NTSTATUS Status;

    /*
     * Only allow a reconnect on a Primary stack.
     */
    if ( pStack->StackClass != Stack_Primary )
        return( STATUS_NOT_SUPPORTED );

    /*
     * If passthru mode is enabled, disable it now.
     */
    if ( pStack->pPassthru ) {
        _DisablePassthru( pStack );
    }

    /*
     * Open the file object for the new connection we will attach to.
     */
    Status = ObReferenceObjectByHandle(
                 hIca,
                 0L,                         // DesiredAccess
                 *IoFileObjectType,
                 KernelMode,
                 (PVOID *)&pNewConnectFileObject,
                 NULL
                 );
    if (!NT_SUCCESS(Status))
        return(Status);

    /*
     * Ensure what we have is a connection object
     */

    if (pNewConnectFileObject->DeviceObject != IcaDeviceObject) {
        ASSERT(FALSE);
        ObDereferenceObject( pNewConnectFileObject );
        return( STATUS_INVALID_PARAMETER );
    }

    /*
     * Get a pointer to the new connection object and reference it.
     */
    pNewConnect = pNewConnectFileObject->FsContext;
    ASSERT( pNewConnect->Header.Type == IcaType_Connection );
    if ( pNewConnect->Header.Type != IcaType_Connection ) {
        ObDereferenceObject( pNewConnectFileObject );
        return( STATUS_INVALID_CONNECTION );
    }
    
    IcaReferenceConnection(pNewConnect);

    /*
     * Obtain the necessary locks to perform the stack reconnect.
     *
     * First, we acquire the global resource lock.
     *
     * Next lock the connection this stack is currently attached to
     * as well as the new connection the stack will be moved to.
     * NOTE: Because of the use of the global resource lock,
     *       there is no possiblility of deadlock even though we
     *       are attempting to lock two connection objects at the
     *       same time.
     * NOTE: While holding a resource we need to disable APC calls
     *       with the CriticalRegion calls.
     *
     * Finally, lock the stack object itself.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(IcaReconnectResource, TRUE);

    pOldConnect = IcaLockConnectionForStack(pStack);
    if (pOldConnect == pNewConnect) {
        Status = STATUS_UNSUCCESSFUL;
        goto badoldconnect;
    }

    IcaLockConnection(pNewConnect);
    if (!IsListEmpty(&pNewConnect->VcBindHead)) {
        Status = STATUS_UNSUCCESSFUL;
        goto badnewconnect;
    }
    if (!IsListEmpty(&pNewConnect->StackHead)) {
        PICA_STACK pHeadStack;
        pHeadStack = CONTAINING_RECORD(pStack->StackEntry.Flink, ICA_STACK, StackEntry);
        if (pHeadStack->StackClass == Stack_Primary) {
            Status = STATUS_UNSUCCESSFUL;
            goto badnewconnect;
        }
    }

    IcaLockStack(pStack);

    /*
     * Unbind the virtual channels,
     * and unlink the VcBind list and save a pointer to it
     * (but only if the list is non-empty).
     */
    IcaUnbindVirtualChannels( pOldConnect );
    if ( !IsListEmpty( &pOldConnect->VcBindHead ) ) {
        pSaveVcBind = pOldConnect->VcBindHead.Flink;
        RemoveEntryList( &pOldConnect->VcBindHead );
        InitializeListHead( &pOldConnect->VcBindHead );
    } else {
        pSaveVcBind = NULL;
    }

    /*
     * Unlink this stack from the stack list for this connection,
     * and remove the reference to the Connection object.
     */
    RemoveEntryList( &pStack->StackEntry );
    IcaDereferenceConnection( pOldConnect );

    /*
     * We're done with the old connection object so unlock it now.
     */
    IcaUnlockConnection( pOldConnect );

    /*
     * Restore the VcBind list and Rebind the virtual channels.
     */
    if ( pSaveVcBind ) {
        InsertTailList( pSaveVcBind, &pNewConnect->VcBindHead );
        IcaRebindVirtualChannels( pNewConnect );
    }

    /*
     * Insert this stack in the stack list for this connection,
     * and save the new Connection object pointer for this stack.
     */
    InsertHeadList( &pNewConnect->StackHead, &pStack->StackEntry );
    pStack->pConnect = (PUCHAR)pNewConnect;

    /*
     * Release stack/connection objects and global resource
     */
    IcaUnlockStack( pStack );
    IcaUnlockConnection( pNewConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();

    /*
     * The stack requires a connection object reference,
     * so leave the one made above, but dereference the file object.
     */
    //IcaDereferenceConnection( pNewConnect );
    ObDereferenceObject( pNewConnectFileObject );

    return( STATUS_SUCCESS );

badnewconnect:
    IcaUnlockConnection( pNewConnect );

badoldconnect:
    IcaUnlockConnection( pOldConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();
    IcaDereferenceConnection( pNewConnect );
    ObDereferenceObject( pNewConnectFileObject );

    return( Status );
}



PVOID IcaStackAllocatePoolWithTag(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag )
{
    PVOID pBuffer;


    pBuffer = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    if (pBuffer != NULL) {
        gAllocSucceed++;
    } else {
        gAllocFailed++;
    }
    return pBuffer;  
}

PVOID IcaStackAllocatePool(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes)
{

    PVOID pBuffer;

    pBuffer = ExAllocatePoolWithTag(PoolType, NumberOfBytes, ICA_POOL_TAG);
    if (pBuffer != NULL) {
        gAllocSucceed++;
    } else {
        gAllocFailed++;
    }
    return pBuffer;  
}


void IcaStackFreePool(IN PVOID Pointer)
{

    ExFreePool(Pointer);
    gAllocFreed++;
}



NTSTATUS _IcaKeepAlive( 
        IN BOOLEAN  enableKeepAlive,
        IN ULONG    interval )
{

    NTSTATUS    status = STATUS_SUCCESS;
    HANDLE      ThreadHandle;

    if ( enableKeepAlive  )
    {
        // a request has come to start the keep alive thread

        if (pKeepAliveThreadObject == NULL ) // if we have no thread object, thread is not running
        {
            // keep alive thread uses this interval.
            g_KeepAliveInterval = interval;

            // Create a new thread to handle keep alive
            status = PsCreateSystemThread( &ThreadHandle,
                                           THREAD_ALL_ACCESS,
                                           NULL,
                                           NtCurrentProcess(),
                                           NULL,
                                           IcaKeepAliveThread,
                                           NULL );
        
            if (status == STATUS_SUCCESS) {
                // Reference the thread handle by object
                status = ObReferenceObjectByHandle(ThreadHandle, THREAD_ALL_ACCESS, NULL,
                        KernelMode,  (PVOID *)&pKeepAliveThreadObject, NULL);
        
                if (status == STATUS_SUCCESS) 
                {
                    // KdPrint(("In TermDD: KeepAlive thread created successfully\n"));
                }
                else 
                {
                    KdPrint(("TermDD: Unable to reference object by thread handle: %d\n", status));
                }
        
                ZwClose(ThreadHandle);
            }
            else 
            {
                KdPrint(("In TermDD: Unable to create KeepAlive thread.\n"));
            }
        }
        else
        {
            // otherwise, keep alive thread is running, but we might have to change the interval to some new value

            // set the new value so that next time around the while loop, it will be picked up.
            g_KeepAliveInterval = interval;
            // KdPrint(("In TermDD: KeepAliveInterval was changes to %d \n",g_KeepAliveInterval  ));
        }
    }
    else
    {
        // we don't need the keep alive thread

        if (pKeepAliveThreadObject != NULL ) 
        {
            // Set IcaKeepAliveEvent to wake up KeepAlive thread
            if (pIcaKeepAliveEvent != NULL ) 
            {
                KeSetEvent(pIcaKeepAliveEvent, 0, FALSE);
            }

            // Wait for the thread to exit
            KeWaitForSingleObject(pKeepAliveThreadObject, Executive, KernelMode, TRUE, NULL);

            // Deference the thread object
            ObDereferenceObject(pKeepAliveThreadObject);
            pKeepAliveThreadObject = NULL;

            // KdPrint(("In TermDD: KeepAlive thread was terminated successfully \n"));

            status = STATUS_SUCCESS;
        }
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\video.c ===
/*************************************************************************
*
* video.c
*
* This module contains routines for managing the ICA video channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


NTSTATUS
IcaDeviceControlVideo(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the DeviceControl routine for the ICA video channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    CLONG Method;

    // Verify the buffer method.
    Method = IrpSp->Parameters.DeviceIoControl.IoControlCode & 0x03;
    ASSERT( Method == METHOD_BUFFERED );

    if ( Method != METHOD_BUFFERED ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {
        SdIoctl.BytesReturned      = 0;
        SdIoctl.IoControlCode      = IrpSp->Parameters.DeviceIoControl.IoControlCode;
        SdIoctl.InputBuffer        = Irp->AssociatedIrp.SystemBuffer;
        SdIoctl.InputBufferLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
        SdIoctl.OutputBuffer       = Irp->AssociatedIrp.SystemBuffer;
        SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );

        Irp->IoStatus.Information = SdIoctl.BytesReturned;
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\timer.c ===
/*************************************************************************
*
* timer.c
*
* This module contains the ICA timer routines.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>
#include <ntddmou.h>


/*
 * Local structures
 */
typedef VOID (*PICATIMERFUNC)( PVOID, PVOID );

typedef struct _ICA_WORK_ITEM {
    LIST_ENTRY Links;
    WORK_QUEUE_ITEM WorkItem;
    PICATIMERFUNC pFunc;
    PVOID pParam;
    PSDLINK pSdLink;
    ULONG LockFlags;
    ULONG fCanceled: 1;
} ICA_WORK_ITEM, *PICA_WORK_ITEM;

/*
 *  Timer structure
 */
typedef struct _ICA_TIMER {
    LONG RefCount;
    KTIMER kTimer;
    KDPC TimerDpc;
    PSDLINK pSdLink;
    LIST_ENTRY WorkItemListHead;
} ICA_TIMER, * PICA_TIMER;


/*
 * Local procedure prototypes
 */
VOID
_IcaTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
_IcaDelayedWorker(
    IN PVOID WorkerContext
    );

BOOLEAN
_IcaCancelTimer(
    PICA_TIMER pTimer,
    PICA_WORK_ITEM *ppWorkItem
    );

VOID
_IcaReferenceTimer(
    PICA_TIMER pTimer
    );

VOID
_IcaDereferenceTimer(
    PICA_TIMER pTimer
    );

NTSTATUS
IcaExceptionFilter(
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );


/*******************************************************************************
 *
 *  IcaTimerCreate
 *
 *  Create a timer  
 *
 *
 *  ENTRY:
 *     pContext (input)
 *         Pointer to SDCONTEXT of caller
 *     phTimer (output)
 *         address to return timer handle
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaTimerCreate(
    IN PSDCONTEXT pContext,
    OUT PVOID * phTimer
    )
{
    PICA_TIMER pTimer;
    NTSTATUS Status;

    /*
     * Allocate timer object and initialize it
     */
    pTimer = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_TIMER) );
    if ( pTimer == NULL )
        return( STATUS_NO_MEMORY );
 
    RtlZeroMemory( pTimer, sizeof(ICA_TIMER) );
    pTimer->RefCount = 1;
    KeInitializeTimer( &pTimer->kTimer );
    KeInitializeDpc( &pTimer->TimerDpc, _IcaTimerDpc, pTimer );
    pTimer->pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    InitializeListHead( &pTimer->WorkItemListHead );

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, "ICADD: TimerCreate: %08x\n", pTimer ));

    *phTimer = (PVOID) pTimer;
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaTimerStart
 *
 *  Start a timer  
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     TimeLeft (input)
 *        relative time until timer expires (1/1000 seconds)
 *     LockFlags (input)
 *        Bit flags to specify which (if any) stack locks to obtain
 *
 *  EXIT:
 *     TRUE  : timer was already armed and had to be canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerStart(
    IN PVOID TimerHandle,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG TimeLeft,
    IN ULONG LockFlags )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    KIRQL oldIrql;
    PICA_WORK_ITEM pWorkItem;
    LARGE_INTEGER DueTime;
    BOOLEAN bCanceled, bSet;
 
    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerStart: %08x, Time %08x, pFunc %08x (%08x)\n", 
                 TimerHandle, TimeLeft, pFunc, pParam ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel the timer if it currently armed,
     * and get the current workitem and reuse it if there was one.
     */
    bCanceled = _IcaCancelTimer( pTimer, &pWorkItem );

    /*
     * Initialize the ICA work item (allocate one first if there isn't one).
     */
    if ( pWorkItem == NULL ) {
        pWorkItem = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
        if ( pWorkItem == NULL ) {
            return( FALSE );
        }
    }

    pWorkItem->pFunc = pFunc;
    pWorkItem->pParam = pParam;
    pWorkItem->pSdLink = pTimer->pSdLink;
    pWorkItem->LockFlags = LockFlags;
    pWorkItem->fCanceled = FALSE;
    ExInitializeWorkItem( &pWorkItem->WorkItem, _IcaDelayedWorker, pWorkItem );

    /*
     * If the timer was NOT canceled above (we are setting it for
     * the first time), then reference the SDLINK object on behalf
     * of the timer thread.
     */
    if ( !bCanceled )
        IcaReferenceSdLink( pTimer->pSdLink );

    /*
     * If timer should run immediately, then just queue the
     * workitem to an ExWorker thread now.
     */
    if ( TimeLeft == 0 ) {

        ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );

    } else {
    
        /*
         * Convert timer time from milliseconds to system relative time
         */
        DueTime = RtlEnlargedIntegerMultiply( TimeLeft, -10000 );

        /*
         * Increment the timer reference count,
         * insert the workitem onto the workitem list,
         * and arm the timer.
         */
        _IcaReferenceTimer( pTimer );
        IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );
        InsertTailList( &pTimer->WorkItemListHead, &pWorkItem->Links );
        IcaReleaseSpinLock( &IcaSpinLock, oldIrql );
        bSet = KeSetTimer( &pTimer->kTimer, DueTime, &pTimer->TimerDpc );
        ASSERT( !bSet );
    }

    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaTimerCancel
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerCancel( IN PVOID TimerHandle )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    BOOLEAN bCanceled;

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerCancel: %08x\n", pTimer ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel timer if it is enabled
     */
    bCanceled = _IcaCancelTimer( pTimer, NULL );
    if ( bCanceled )
        IcaDereferenceSdLink( pTimer->pSdLink );

    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaTimerClose
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerClose( IN PVOID TimerHandle )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    BOOLEAN bCanceled;

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerClose: %08x\n", pTimer ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel timer if it is enabled
     */
    bCanceled = IcaTimerCancel( TimerHandle );

    /*
     * Decrement timer reference
     * (the last reference will free the object)
     */
    //ASSERT( pTimer->RefCount == 1 );
    //ASSERT( IsListEmpty( &pTimer->WorkItemListHead ) );
    _IcaDereferenceTimer( pTimer );
 
    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaQueueWorkItemEx, IcaQueueWorkItem.
 *
 *  Queue a work item for async execution
 *
 *  REM: IcaQueueWorkItemEx is the new API. It allows the caller to preallocate
 *  the ICA_WORK_ITEM. IcaQueueWorkItem is left there for lecacy drivers that have not 
 *  been compiled with the new library not to crash the system.
 *
 *  ENTRY:
 *     pContext (input)
 *         Pointer to SDCONTEXT of caller
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     LockFlags (input)
 *        Bit flags to specify which (if any) stack locks to obtain
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/



NTSTATUS
IcaQueueWorkItem(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags )
{
    PSDLINK pSdLink;
    PICA_WORK_ITEM pWorkItem;

    NTSTATUS Status;

    Status = IcaQueueWorkItemEx( pContext, pFunc, pParam, LockFlags, NULL );
    return Status;
}


NTSTATUS
IcaQueueWorkItemEx(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags,
    IN PVOID pIcaWorkItem )
{
    PSDLINK pSdLink;
    PICA_WORK_ITEM pWorkItem = (PICA_WORK_ITEM) pIcaWorkItem;
 
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    /*
     * Allocate the ICA work item if not yet allocated and initialize it.
     */
    if (pWorkItem == NULL) {
        pWorkItem = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
        if ( pWorkItem == NULL )
            return( STATUS_NO_MEMORY );
    }

    pWorkItem->pFunc = pFunc;
    pWorkItem->pParam = pParam;
    pWorkItem->pSdLink = pSdLink;
    pWorkItem->LockFlags = LockFlags;
    ExInitializeWorkItem( &pWorkItem->WorkItem, _IcaDelayedWorker, pWorkItem );

    /*
     * Reference the SDLINK object on behalf of the delayed worker routine.
     */
    IcaReferenceSdLink( pSdLink );

    /*
     * Queue work item to an ExWorker thread.
     */
    ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );

    return( STATUS_SUCCESS );
}



/*******************************************************************************
 *
 *  IcaAllocateWorkItem.
 *
 *  Allocate ICA_WORK_ITEM structure to queue a workitem.
 *
 *  REM:  The main reason to allocate this in termdd (instead of doing it
 *  in the caller is to keep ICA_WORK_ITEM an internal termdd structure that is
 *  opaque for protocol drivers. There is no need for an IcaFreeWorkItem() API in
 *  termdd since the deallocation is transparently done in termdd once the workitem
 *  has been delivered.
 *
 *  ENTRY:
 *     pParam (output) : pointer to return allocated workitem
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaAllocateWorkItem(
    OUT PVOID *pParam )
{
    PICA_WORK_ITEM pWorkItem;

    *pParam = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
    if ( *pParam == NULL ){
        return( STATUS_NO_MEMORY );
    }
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *
 *  _IcaTimerDpc
 *
 *  Ica timer DPC routine.
 *
 *
 *  ENTRY:
 *     Dpc (input)
 *        Unused
 * 
 *     DeferredContext (input)
 *        Pointer to ICA_TIMER object.
 * 
 *     SystemArgument1 (input)
 *        Unused
 * 
 *     SystemArgument2 (input)
 *        Unused
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PICA_TIMER pTimer = (PICA_TIMER)DeferredContext;
    KIRQL oldIrql;
    PLIST_ENTRY Head;
    PICA_WORK_ITEM pWorkItem;

    /*
     * Acquire spinlock and remove the first workitem from the list
     */
    IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );

    Head = RemoveHeadList( &pTimer->WorkItemListHead );
    pWorkItem = CONTAINING_RECORD( Head, ICA_WORK_ITEM, Links );

    IcaReleaseSpinLock( &IcaSpinLock, oldIrql );

    /*
     * If workitem has been canceled, just free the memory now.
     */
    if ( pWorkItem->fCanceled ) {

        ICA_FREE_POOL( pWorkItem );

    /*
     * Otherwise, queue workitem to an ExWorker thread.
     */
    } else {

        ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );
    }

    _IcaDereferenceTimer( pTimer );
}


/*******************************************************************************
 *
 *  _IcaDelayedWorker
 *
 *  Ica delayed worker routine.
 *
 *
 *  ENTRY:
 *     WorkerContext (input)
 *        Pointer to ICA_WORK_ITEM object.
 * 
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaDelayedWorker(
    IN PVOID WorkerContext
    )
{
    PICA_CONNECTION pConnect;
    PICA_WORK_ITEM pWorkItem = (PICA_WORK_ITEM)WorkerContext;
    PICA_STACK pStack = pWorkItem->pSdLink->pStack;
    NTSTATUS Status;

    /*
     * Obtain any required locks before calling the worker routine.
     */
    if ( pWorkItem->LockFlags & ICALOCK_IO ) {
        pConnect = IcaLockConnectionForStack( pStack );
    }
    if ( pWorkItem->LockFlags & ICALOCK_DRIVER ) {
        IcaLockStack( pStack );
    }

    /*
     * Call the worker routine.
     */
    try {
        (*pWorkItem->pFunc)( pWorkItem->pSdLink->SdContext.pContext,
                             pWorkItem->pParam );
    } except( IcaExceptionFilter( L"_IcaDelayedWorker TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }

    /*
     * Release any locks acquired above.
     */
    if ( pWorkItem->LockFlags & ICALOCK_DRIVER ) {
        IcaUnlockStack( pStack );
    }
    if ( pWorkItem->LockFlags & ICALOCK_IO ) {
        IcaUnlockConnection( pConnect );
    }

    /*
     * Dereference the SDLINK object now.
     * This undoes the reference that was made on our behalf in the
     * IcaTimerStart or IcaQueueWorkItem routine.
     */
    IcaDereferenceSdLink( pWorkItem->pSdLink );

    /*
     * Free the ICA_WORK_ITEM memory block.
     */
    ICA_FREE_POOL( pWorkItem );
}


BOOLEAN
_IcaCancelTimer(
    PICA_TIMER pTimer,
    PICA_WORK_ITEM *ppWorkItem
    )
{
    KIRQL oldIrql;
    PLIST_ENTRY Tail;
    PICA_WORK_ITEM pWorkItem;
    BOOLEAN bCanceled;

    /*
     * Get IcaSpinLock to in order to cancel any previous timer
     */
    IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );

    /*
     * See if the timer is currently armed.
     * The timer is armed if the workitem list is non-empty and
     * the tail entry is not marked canceled.
     */
    if ( !IsListEmpty( &pTimer->WorkItemListHead ) &&
         (Tail = pTimer->WorkItemListHead.Blink) &&
         (pWorkItem = CONTAINING_RECORD( Tail, ICA_WORK_ITEM, Links )) &&
         !pWorkItem->fCanceled ) {

        /*
         * If the timer can be canceled, remove the workitem from the list
         * and decrement the reference count for the timer.
         */
        if ( KeCancelTimer( &pTimer->kTimer ) ) {
            RemoveEntryList( &pWorkItem->Links );
            pTimer->RefCount--;
            ASSERT( pTimer->RefCount > 0 );


        /*
         * The timer was armed but could not be canceled.
         * On a MP system, its possible for this to happen and the timer
         * DPC can be executing on another CPU in parallel with this code.
         *
         * Mark the workitem as canceled,
         * but leave it for the timer DPC routine to cleanup.
         */
        } else {
            pWorkItem->fCanceled = TRUE;
            pWorkItem = NULL;
        }

        /*
         * Indicate we (effectively) canceled the timer
         */
        bCanceled = TRUE;

    /*
     * No timer is armed
     */
    } else {
        pWorkItem = NULL;
        bCanceled = FALSE;
    }

    /*
     * Release IcaSpinLock now
     */
    IcaReleaseSpinLock( &IcaSpinLock, oldIrql );

    if ( ppWorkItem ) {
        *ppWorkItem = pWorkItem;
    } else if ( pWorkItem ) {
        ICA_FREE_POOL( pWorkItem );
    }

    return( bCanceled );
}


VOID
_IcaReferenceTimer(
    PICA_TIMER pTimer
    )
{

    ASSERT( pTimer->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pTimer->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
_IcaDereferenceTimer(
    PICA_TIMER pTimer
    )
{

    ASSERT( pTimer->RefCount > 0 );

    /*
     * Decrement the reference count
     * If it is 0 then free the timer now.
     */
    if ( InterlockedDecrement( &pTimer->RefCount) == 0 ) {
        ASSERT( IsListEmpty( &pTimer->WorkItemListHead ) );
        ICA_FREE_POOL( pTimer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\tsq\tsq.h ===
//=====================================================
// FILE: TSQ.h
// Internal structures for the TS Queue implementation.
//=====================================================

#include "TSQPublic.h"

// TS Queue flags
#define TSQUEUE_BEING_DELETED   0x80    // Delete request has been received for this TS queue.

// Maximum number of work items that can be held by the TS Queue.
#define MAX_WORKITEMS           10

// Data Structures

typedef struct _TSQUEUE_WORK_ITEM {
    LIST_ENTRY Links;       
    PTSQ_CALLBACK pCallBack;        // Pointer to the callback function.
    PVOID pContext;                 // Context.
} TSQUEUE_WORK_ITEM, *PTSQUEUE_WORK_ITEM;


typedef struct _TSQUEUE {
    LIST_ENTRY  WorkItemsHead;      // Head of the work items.
    ULONG       Flags;              // Own Thread, Queue Priority, Being deleted
    ULONG       MaxThreads;         // Maximum number of threads that can be by this queue.
    ULONG       ThreadsCount;       // Number of Items being processed.
    KEVENT      TerminateEvent;     // Replace this type by pointer to event.
    KSPIN_LOCK  TsqSpinLock;        // Spin lock.
    PDEVICE_OBJECT pDeviceObject;   // Device object.
} TSQUEUE, *PTSQUEUE;


typedef struct _TSQ_CONTEXT {
    PTSQUEUE        pTsQueue;       // TS queue
    PIO_WORKITEM    pWorkItem;      // Work item
} TSQ_CONTEXT, *PTSQ_CONTEXT;


// Function prototypes

// TS Queue worker thread.
void TSQueueWorker(PTSQUEUE pTsQueue);

// TS Queue callback function.
void TSQueueCallback(PDEVICE_OBJECT, PVOID);


/*
// Optimized version of TS Queue worker thread.
typedef struct _TSQ_WORKER_INPUT {
    BOOL    WorkItem;                   // Pointer to the work item or to the queue.
    union {
        PTSQUEUE_WORK_ITEM  WorkItem;
        PQUEUE              pQueue;
    }
} TSQ_WORKER_INPUT, *PTSQ_WORKER_INPUT;

NTSTATUS TSQueueworker(PTSQ_WORKER_INPUT pWorkerInput);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\wmi.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    RDP remote port driver.

Environment:

    Kernel mode

Revision History :

    02/12/99 - Initial Revision based on pnpi8042 driver


--*/

#include <precomp.h>
#pragma hdrstop

#include <wmistr.h>

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtInitWmi)
#pragma alloc_text(PAGE, PtSystemControl)
#pragma alloc_text(PAGE, PtSetWmiDataItem)
#pragma alloc_text(PAGE, PtSetWmiDataBlock)
#pragma alloc_text(PAGE, PtKeyboardQueryWmiDataBlock)
#pragma alloc_text(PAGE, PtMouseQueryWmiDataBlock)
#pragma alloc_text(PAGE, PtQueryWmiRegInfo)
#endif

#define WMI_KEYBOARD_PORT_INFORMATION 0
#define WMI_MOUSE_PORT_INFORMATION    0

GUID KbKeyboardPortGuid = KEYBOARD_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO KbWmiGuidList[1] =
{
    { &KbKeyboardPortGuid, 1, 0 }  // Keyboard Port driver information
};

GUID MouPointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO MouWmiGuidList[1] =
{
    { &MouPointerPortGuid,  1, 0 }  // Pointer Port driver information
};

NTSTATUS
PtInitWmi(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Initializes the WmiLibInfo data structure for the device represented by
    CommonData

Arguments:

    CommonData - the device

Return Value:

    status from IoWMIRegistrationControl

--*/
{
    PAGED_CODE();

    if (CommonData->IsKeyboard) {
        CommonData->WmiLibInfo.GuidCount = sizeof(KbWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = KbWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = PtKeyboardQueryWmiDataBlock;
    }
    else {
        CommonData->WmiLibInfo.GuidCount = sizeof(MouWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = MouWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = PtMouseQueryWmiDataBlock;
    }

    CommonData->WmiLibInfo.QueryWmiRegInfo = PtQueryWmiRegInfo;
    CommonData->WmiLibInfo.SetWmiDataBlock = PtSetWmiDataBlock;
    CommonData->WmiLibInfo.SetWmiDataItem = PtSetWmiDataItem;
    CommonData->WmiLibInfo.ExecuteWmiMethod = NULL;
    CommonData->WmiLibInfo.WmiFunctionControl = NULL;

    return IoWMIRegistrationControl(CommonData->Self,
                                    WMIREG_ACTION_REGISTER
                                    );
}

NTSTATUS
PtSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PCOMMON_DATA           commonData;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS               status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&commonData->WmiLibInfo,
                              DeviceObject,
                              Irp,
                              &disposition
                              );
    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;
    }

    return status;
}

//
// WMI System Call back functions
//
NTSTATUS
PtSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    // case WMI_MOUSE_PORT_INFORMATION:  // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    // case WMI_MOUSE_PORT_INFORMATION:     // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(KEYBOARD_PORT_WMI_STD_DATA);
    KEYBOARD_PORT_WMI_STD_DATA  kbData;

    PAGED_CODE();

    ASSERT(InstanceIndex == 0 && InstanceCount == 1);

    switch (GuidIndex) {
    case WMI_KEYBOARD_PORT_INFORMATION:

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&kbData,
                      size
                      );

        kbData.ConnectorType = KEYBOARD_PORT_WMI_STD_I8042;
        kbData.DataQueueSize = 1;
        kbData.ErrorCount    = 0;
        kbData.FunctionKeys  = KEYBOARD_NUM_FUNCTION_KEYS;
        kbData.Indicators    = KEYBOARD_NUM_INDICATORS;

        *(PKEYBOARD_PORT_WMI_STD_DATA) Buffer = kbData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(POINTER_PORT_WMI_STD_DATA);
    POINTER_PORT_WMI_STD_DATA   mouData;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);

    switch (GuidIndex) {
    case WMI_MOUSE_PORT_INFORMATION:

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&mouData,
                      size
                      );

        mouData.ConnectorType = POINTER_PORT_WMI_STD_I8042;
        mouData.DataQueueSize = 0;

        //
        // We always claim to be a 3 button (wheel) mouse
        //
        mouData.Buttons = MOUSE_NUM_BUTTONS;
        mouData.ErrorCount = 0;
        mouData.HardwareType = POINTER_PORT_WMI_STD_MOUSE;

        *(PPOINTER_PORT_WMI_STD_DATA) Buffer = mouData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PCOMMON_DATA commonData;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = commonData->PDO;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\tsq\tsq.c ===
#p